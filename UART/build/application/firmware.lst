
build/application/firmware.elf:     file format elf32-littlearm
build/application/firmware.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00014d19

Program Header:
0x70000001 off    0x0001c73c vaddr 0x0001c73c paddr 0x0001c73c align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010000 vaddr 0x00010000 paddr 0x00010000 align 2**16
         filesz 0x0000c744 memsz 0x0000c744 flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x0001c744 align 2**16
         filesz 0x0000094c memsz 0x0000094c flags rw-
    LOAD off    0x00020950 vaddr 0x10000950 paddr 0x10000950 align 2**16
         filesz 0x00000000 memsz 0x00000d80 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name             Size      VMA       LMA       File off  Algn  Flags
  0 .text            0000c73c  00010000  00010000  00010000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data            0000094c  10000000  0001c744  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2       00000000  20000000  20000000  0002094c  2**2  CONTENTS
  3 .bss             00000d80  10000950  10000950  00020950  2**3  ALLOC
  4 .ARM.exidx       00000008  0001c73c  0001c73c  0001c73c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .uninit_RESERVED 00000000  10000000  10000000  0002094c  2**2  CONTENTS
  6 .noinit_RAM2     00000000  20000000  20000000  0002094c  2**2  CONTENTS
  7 .noinit          00000000  100016d0  100016d0  0002094c  2**2  CONTENTS
  8 .ARM.attributes  00000030  00000000  00000000  0002094c  2**0  CONTENTS, READONLY
  9 .comment         0000007e  00000000  00000000  0002097c  2**0  CONTENTS, READONLY
 10 .debug_info      0005f1a3  00000000  00000000  000209fa  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev    000061c2  00000000  00000000  0007fb9d  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges   00001530  00000000  00000000  00085d5f  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges    00001460  00000000  00000000  0008728f  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_line      00009b67  00000000  00000000  000886ef  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_str       0001ae3e  00000000  00000000  00092256  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame     00005274  00000000  00000000  000ad094  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
20000000 l    d  .data_RAM2	00000000 .data_RAM2
10000950 l    d  .bss	00000000 .bss
0001c73c l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
20000000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
100016d0 l    d  .noinit	00000000 .noinit
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 interrupt.cpp
000152f4 l     F .text	0000002c NVIC_EnableIRQ
00015320 l     F .text	00000054 NVIC_SetPriority
00010000 l     O .text	000000e4 kInterruptVectorTable
0001b528 l     O .text	0000000e InterruptLookupHandler::file
0001b538 l     O .text	0000001e InterruptLookupHandler::__PRETTY_FUNCTION__
0001022c l       .text	00000000 handler2_address_const
00000000 l    df *ABS*	00000000 startup.cpp
0001b27c l     O .text	0000003e Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__
100007dc l     O .data	00000008 (anonymous namespace)::system_timer
100007e4 l     O .data	00000004 (anonymous namespace)::system_controller
100007e8 l     O .data	0000000c (anonymous namespace)::timer0
00014b34 l     F .text	00000040 (anonymous namespace)::Lpc40xxUptime()
100012a8 l     O .bss	00000060 idle_task_tcb
10001308 l     O .bss	00000140 idle_task_stack
0001b1c4 l     O .text	0000000c LowLevelInit()::file
0001b2bc l     O .text	00000014 LowLevelInit()::__PRETTY_FUNCTION__
000102fc l     O .text	00000004 kCrpWord
00015208 l     F .text	000000dc __static_initialization_and_destruction_0(int, int)
000152e4 l     F .text	0000000e _GLOBAL__sub_I_UptimeRTOS
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crti.o
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
0001032c l     F .text	00000000 __do_global_dtors_aux
10000950 l       .bss	00000001 completed.9929
00010350 l     F .text	00000000 frame_dummy
10000954 l       .bss	00000018 object.9934
0001030c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 LabUART.cpp
10000970 l     O .bss	00000008 (anonymous namespace)::uptime
00010ad8 l     F .text	00000030 (anonymous namespace)::DefaultUptime()
0001a554 l     O .text	0000001c Gpio::ValidPortCheck()::__PRETTY_FUNCTION__
0001a570 l     O .text	00000039 Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001a518 l     O .text	0000003b Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001a3d8 l     O .text	00000049 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__
0001a480 l     O .text	0000005c Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
0001a424 l     O .text	0000005a Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
0001a4dc l     O .text	0000003a Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__
1000045c l     O .data	00000008 UART
000138d4 l     F .text	00000058 __static_initialization_and_destruction_0(int, int)
0001392c l     F .text	00000028 _GLOBAL__sub_I__ZN7LabUART19Global_Queue_HandleE
00000000 l    df *ABS*	00000000 main.cpp
0001abb4 l     O .text	00000009 main::file
0001abc0 l     O .text	0000000b main::__PRETTY_FUNCTION__
000139d8 l     F .text	00000064 __static_initialization_and_destruction_0(int, int)
00013a3c l     F .text	00000028 _GLOBAL__sub_I_uart_rx
00000000 l    df *ABS*	00000000 diskio.cpp
0001c5cc l     O .text	00000031 Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__
0001c600 l     O .text	0000003c Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__
0001c63c l     O .text	00000034 Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__
0001c670 l     O .text	00000069 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__
1000165c l     O .bss	00000068 (anonymous namespace)::sd_card
000193a8 l     F .text	00000050 __static_initialization_and_destruction_0(int, int)
000193f8 l     F .text	00000028 _GLOBAL__sub_I_disk_status
00000000 l    df *ABS*	00000000 pinconn.cpp
00000000 l    df *ABS*	00000000 newlib.cpp
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 tasks.c
10001554 l     O .bss	00000064 pxReadyTasksLists
100015b8 l     O .bss	00000014 xDelayedTaskList1
100015cc l     O .bss	00000014 xDelayedTaskList2
100015e0 l     O .bss	00000004 pxDelayedTaskList
100015e4 l     O .bss	00000004 pxOverflowDelayedTaskList
100015e8 l     O .bss	00000014 xPendingReadyList
100015fc l     O .bss	00000014 xTasksWaitingTermination
10001610 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
10001614 l     O .bss	00000014 xSuspendedTaskList
10001628 l     O .bss	00000004 uxCurrentNumberOfTasks
1000162c l     O .bss	00000004 xTickCount
10001630 l     O .bss	00000004 uxTopReadyPriority
10001634 l     O .bss	00000004 xSchedulerRunning
10001638 l     O .bss	00000004 uxPendedTicks
1000163c l     O .bss	00000004 xYieldPending
10001640 l     O .bss	00000004 xNumOfOverflows
10001644 l     O .bss	00000004 uxTaskNumber
10001648 l     O .bss	00000004 xNextTaskUnblockTime
1000164c l     O .bss	00000004 xIdleTaskHandle
10001650 l     O .bss	00000004 uxSchedulerSuspended
10001654 l     O .bss	00000004 ulTaskSwitchedInTime
10001658 l     O .bss	00000004 ulTotalRunTime
00015940 l     F .text	000000f2 prvInitialiseNewTask
00015a34 l     F .text	000000dc prvAddNewTaskToReadyList
00016098 l     F .text	0000007c prvInitialiseTaskLists
0001616c l     F .text	0000003a prvDeleteTCB
000161a8 l     F .text	00000040 prvResetNextTaskUnblockTime
000162b0 l     F .text	000000c8 prvAddCurrentTaskToDelayedList
0001608c l     F .text	0000000c prvIdleTask
00016114 l     F .text	00000058 prvCheckTasksWaitingTermination
00000000 l    df *ABS*	00000000 queue.c
0001648e l     F .text	00000048 prvInitialiseNewQueue
000166c8 l     F .text	000000d2 prvCopyDataToQueue
000167e4 l     F .text	000000ae prvUnlockQueue
0001679a l     F .text	0000004a prvCopyDataFromQueue
00016892 l     F .text	0000002a prvIsQueueEmpty
00000000 l    df *ABS*	00000000 port.c
100008e0 l     O .data	00000004 uxCriticalNesting
0001691c l     F .text	00000026 prvTaskExitError
00016970 l       .text	00000000 pxCurrentTCBConst2
00016978 l     F .text	00000024 prvPortStartFirstTask
00016af8 l     F .text	00000010 vPortEnableVFP
00016ab0 l       .text	00000000 pxCurrentTCBConst
00000000 l    df *ABS*	00000000 heap_3.c
00000000 l    df *ABS*	00000000 printf.cpp
00016b50 l     F .text	00000044 _out_buffer(char, void*, unsigned int, unsigned int)
00016b94 l     F .text	00000030 _out_null(char, void*, unsigned int, unsigned int)
00016bc4 l     F .text	00000044 _out_char(char, void*, unsigned int, unsigned int)
00016c08 l     F .text	00000044 _strlen(char const*)
00016c4c l     F .text	00000044 _is_digit(char)
00016c90 l     F .text	00000060 _atoi(char const**)
00016cf0 l     F .text	0000025c _ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)
00016f4c l     F .text	000000e4 _ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)
00017030 l     F .text	000000f4 _ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)
0001b588 l     O .text	00000028 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10
00017124 l     F .text	00000438 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)
0001755c l     F .text	000008f4 _vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)
00000000 l    df *ABS*	00000000 pure.cc
00000000 l    df *ABS*	00000000 eh_terminate.cc
00000000 l    df *ABS*	00000000 sf_round.c
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcpy-stub.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 findfp.c
00000000 l    df *ABS*	00000000 eh_term_handler.cc
00000000 l    df *ABS*	00000000 impure.c
100008ec l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 reent.c
10001248 g     O .bss	00000004 LabUART::Global_Queue_Handle
000115f8  w    F .text	0000003e Lpc40xxSystemController::GetPeripheralFrequency() const
000155f0 g     F .text	00000038 putchar
10000a78  w    O .bss	00000001 LabUART::selUart
00015374  w    F .text	0000006c Pwm0IrqHandler
0001a0d4  w    O .text	00000009 Gpio::SetInterruptEdge(GpioInterface::Edge)::file
00010218 g     F .text	0000001c HardFaultHandler
00015508 g     F .text	00000024 _getpid
000155b4 g     F .text	0000003c _putchar
00015374  w    F .text	0000006c EepromIrqHandler
00015374  w    F .text	0000006c Timer2IrqHandler
100007c8  w    O .data	00000014 uart0
000156f4 g     F .text	0000002c GetStackDepth()
0001c4dc  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
000114c0  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
0001b18c  w    O .text	00000004 Timer::kTimerIrq
00016a1c g     F .text	00000028 vPortExitCritical
0001c514  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00019abc g     F .text	00000024 _kill_r
0001010c g       .text	00000000 bss_section_table_end
00017e50 g     F .text	0000004c printf
10000764  w    O .data	00000004 SystemTimer::sys_tick
00015374  w    F .text	0000006c I2c1IrqHandler
00014dc0  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)2>()
10000778  w    O .data	00000010 Uart::uart
00013510 g     F .text	0000006c LabUART::UartReceive()
0001c544  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00010000 g       *ABS*	00000000 __vectors_start__
000128d0  w    F .text	00000090 Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)
00019ae6 g     F .text	00000002 __malloc_unlock
00010b08  w    F .text	00000044 Milliseconds()
0001175c  w    F .text	00000110 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)
0001277c  w    F .text	00000094 Ssd1306::Ssd1306()
00011aa0  w    F .text	00000034 SspInterface::SspInterface()
00015374  w    F .text	0000006c BusFaultHandler
1000144c g     O .bss	00000100 stack_trace
10000000  w    O .data	00000004 Pin::pin_map
00014380  w    F .text	000000e4 Uart::Initialize(unsigned long)
20000000 g       *ABS*	00000000 __base_RAM2
000164d6 g     F .text	000000b0 xQueueGenericSendFromISR
0001277c  w    F .text	00000094 Ssd1306::Ssd1306()
0001c744 g       .ARM.exidx	00000000 __exidx_end
000113b0  w    F .text	0000007c Gpio::ClearEdgeRising()
00011a44  w    F .text	00000030 Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)
0001a0c8  w    O .text	00000009 Gpio::ValidPortCheck()::file
00013194  w    F .text	0000006c OledTerminal::OledTerminal()
10001550 g     O .bss	00000004 pxCurrentTCB
0001036c  w    F .text	00000034 PinInterface::PinInterface()
000156b0 g     F .text	0000001c __cyg_profile_func_exit
00019148  w    F .text	00000048 Sd::Crc7Add(unsigned char, unsigned char)
00018060  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
00015028  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()
100016cc g     O .bss	00000004 errno
0001c744 g       .ARM.exidx	00000000 _etext
10000048  w    O .data	00000004 Lpc40xxSystemController::system_controller
000114e4  w    F .text	00000090 Lpc40xxSystemController::SetClockFrequency(unsigned char)
00014150  w    F .text	00000030 unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)
000115e4  w    F .text	00000014 Lpc40xxSystemController::GetSystemFrequency() const
00014944  w    F .text	000001f0 Uart::GenerateUartCalibration(float)
10000008  w    O .data	00000018 Gpio::gpio_port
00014180  w    F .text	000000f8 Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)
00014c40  w    F .text	000000bc LowLevelInit()
00015374  w    F .text	0000006c LcdIrqHandler
0001c56c  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
00080000 g       *ABS*	00000000 __top_MFlash512
00011da0  w    F .text	0000006c Ssp::Transfer(unsigned short)
00015fcc g     F .text	00000024 vTaskInternalSetTimeOutState
000145e4  w    F .text	000000f8 Uart::Receive(unsigned long)
000116fc  w    F .text	00000030 Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)
00017ffc  w    F .text	00000030 Delay(unsigned long long)
0001b1b4  w    O .text	00000010 Uart::kPowerbit
00015374  w    F .text	0000006c I2c2IrqHandler
10001254  w    O .bss	00000004 SystemTimer::system_timer_isr
00011278  w    F .text	00000040 Gpio::DetachInterrupt()
00013a64 g     F .text	00000064 pinconn::clear7(unsigned char, unsigned char)
00013b88 g     F .text	000000c0 pinconn::uart2_rxd(unsigned char, unsigned char)
00015374  w    F .text	0000006c CanIrqHandler
000169a0 g     F .text	00000054 xPortStartScheduler
000198c4 g     F .text	00000016 memcpy
00015ef8 g     F .text	0000002c vTaskPlaceOnEventList
000108a8  w    F .text	00000074 Pin::EnableDac(bool)
00014c14 g     F .text	0000002c vPortSetupTimerInterrupt
000105d8  w    F .text	0000007c Pin::SetAsAnalogMode(bool)
00016ab8 g     F .text	00000040 xPortSysTickHandler
000119dc  w    F .text	00000068 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)
00019200  w    F .text	000000fc Sd::GetCrc16(unsigned char*, unsigned short)
0001954c g     F .text	00000000 .hidden __aeabi_uldivmod
100016d0 g       .noinit	00000000 _noinit
00015628 g     F .text	00000060 puts
00016b2e g     F .text	00000022 vPortFree
100007f4 g     O .data	000000e4 dynamic_isr_vector_table
00010f98  w    F .text	0000002c Gpio::GetPin()
00011040  w    F .text	0000005c Gpio::SetInterruptRoutine(void (*)())
00010b4c  w    F .text	00000034 GpioInterface::GpioInterface()
00011aa0  w    F .text	00000034 SspInterface::SspInterface()
00015374  w    F .text	0000006c RitIrqHandler
00015374  w    F .text	0000006c Uart2IrqHandler
0001091c  w    F .text	00000064 Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)
0001a14c  w    O .text	00000016 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file
0001c4fc  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000198a4 g     F .text	00000010 malloc
000134ac g     F .text	00000064 LabUART::UartSend(int)
00012104  w    F .text	00000160 Ssp::GetPeripheralMode()
000150c8  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()
0001944c g     F .text	00000060 roundf
00019a5c g     F .text	00000050 _raise_r
00017f0c  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::_FUN()
00011a74  w    F .text	0000002c int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)
00011ad4  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10010000 g       *ABS*	00000000 __top_RAM
0001b1b0  w    O .text	00000004 Uart::kRxUartPortFunction
00017f38  w    F .text	000000c4 Wait(unsigned long long)
00016a50 g     F .text	00000066 xPortPendSVHandler
00017e9c g     F .text	00000044 vsnprintf
0001802c  w    F .text	00000034 SdInterface::SdInterface()
00014278  w    F .text	0000003c Timer::GetTimer()
10000000 g       *ABS*	00000000 __base_RamLoc64
000156cc g     F .text	00000028 GetStackTrace()
100008dc g     O .data	00000004 out
00015766 g     F .text	0000003e vListInsertEnd
1000004c  w    O .data	00000004 Lpc40xxSystemController::speed_in_hertz
0001c54c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001c534  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00019ae0 g     F .text	00000004 _getpid_r
00000000 g       *ABS*	00000000 __base_MFlash512
0001a214  w    O .text	0000004c vtable for Ssp
10010000 g       *ABS*	00000000 StackTop
00018510  w    F .text	00000064 Sd::WaitToReadBlock()
0001a164  w    O .text	00000003 Ssp::kPinSelect
00012ecc  w    F .text	00000038 Graphics::Clear()
00012868  w    F .text	00000068 Ssd1306::AvailableColors()
0001957c g     F .text	000002cc .hidden __udivmoddi4
00015374  w    F .text	0000006c I2sIrqHandler
00019a3c g     F .text	00000020 _sbrk_r
000100fc g       .text	00000000 bss_section_table
00013144  w    F .text	00000050 OledTerminal::ClearRow(unsigned int)
00010300 g       .text	00000000 __CRP_WORD_END__
20008000 g       *ABS*	00000000 __top_RAM2
00014d18 g     F .text	00000030 ResetIsr
00015756 g     F .text	00000010 vListInitialiseItem
0001a1bc  w    O .text	0000002c vtable for Ssd1306
000184cc  w    F .text	00000044 Sd::ToBool(bool)
00013624 g     F .text	00000048 LabUART::RX_Int()
0001a260  w    O .text	00000028 vtable for SspInterface
00016588 g     F .text	00000140 xQueueReceive
00015374  w    F .text	0000006c PendSVHandler
1000005c  w    O .data	00000400 font8x8_basic
00011e68  w    F .text	00000030 unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)
00013e68  w    F .text	00000034 SystemTimer::SetIsrFunction(void (*)())
00013754  w    F .text	00000044 bool bit::Read<unsigned long>(unsigned long, unsigned long)
0001366c g     F .text	00000078 LabUART::ALU(int*)
00011d28  w    F .text	00000078 Ssp::IsTransferRegBusy()
00013d08 g     F .text	000000c0 pinconn::uart3_rxd(unsigned char, unsigned char)
00015374  w    F .text	0000006c UsageFaultHandler
20000000 g       *ABS*	00000000 __user_heap_base
00012c68  w    F .text	0000008c Graphics::Graphics(PixelDisplayInterface*)
0001c73c g       .text	00000000 __exidx_start
000107c0  w    F .text	00000074 Pin::EnableI2cHighCurrentDrive(bool)
00015374  w    F .text	0000006c Uart4IrqHandler
0001109c  w    F .text	00000054 Gpio::ClearInterruptRoutine()
00010744  w    F .text	0000007c Pin::EnableI2cHighSpeedMode(bool)
000101fc g     F .text	00000018 InitFpu()
00010654  w    F .text	0000007c Pin::EnableDigitalFilter(bool)
00012810  w    F .text	0000002c Ssd1306::GetWidth()
0001985c g     F .text	00000048 __libc_init_array
00015374 g     F .text	0000006c InterruptLookupHandler
0001172c  w    F .text	00000030 Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)
000115cc  w    F .text	00000018 Lpc40xxSystemController::GetPeripheralClockDivider() const
10000004  w    O .data	00000004 Uptime
0001a318  w    O .text	00000048 vtable for GpioInterface
000144b0  w    F .text	000000e8 Uart::Send(unsigned char)
0001984c g     F .text	0000000e abort
00015374  w    F .text	0000006c BodIrqHandler
0001555c g     F .text	00000058 _sbrk
00016b0c g     F .text	00000022 pvPortMalloc
00012450  w    F .text	00000184 Ssp::GetClock()
00010300 g     F .text	00000000 _init
0001010c g       .text	00000000 section_table_end
00015168  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()
00013200 g     F .text	00000040 LabUART::LabUART(unsigned char)
00015720 g     F .text	00000036 vListInitialise
00013200 g     F .text	00000040 LabUART::LabUART(unsigned char)
00019440 g     F .text	0000000a std::terminate()
000194ac g     F .text	0000009e .hidden __aeabi_d2f
0001142c  w    F .text	0000007c Gpio::ClearEdgeFalling()
00015374  w    F .text	0000006c SysTickHandler
000100e4 g       .text	00000000 section_table_start
100016d0 g       .bss	00000000 _ebss
00012bf4  w    F .text	00000074 Ssd1306::Update()
00011334  w    F .text	0000007c Gpio::SetEdgeFalling()
0001c50c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00015374  w    F .text	0000006c RtcIrqHandler
000161e8 g     F .text	000000c8 xTaskPriorityDisinherit
00010f28  w    F .text	00000070 Gpio::Read()
00012c68  w    F .text	0000008c Graphics::Graphics(PixelDisplayInterface*)
00014e38  w    F .text	000000a8 Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})
eff762fa g       *ABS*	00000000 ValidUserCodeChecksum
00015374  w    F .text	0000006c Uart0IrqHandler
0001543c g     F .text	00000078 GetRegistersFromStack
00013718  w    F .text	0000003c unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)
00012f04  w    F .text	0000004c OledTerminal::Initialize()
00015f24 g     F .text	000000a8 xTaskRemoveFromEventList
00012e94  w    F .text	00000038 Graphics::Update()
0001a39c  w    O .text	0000003c vtable for PinInterface
00015374  w    F .text	0000006c UsbIrqHandler
00015374  w    F .text	0000006c AdcIrqHandler
00014598  w    F .text	0000004c Uart::Receive(unsigned long)::{lambda()#1}::operator()() const
00013dc8  w    F .text	00000030 SetUptimeFunction(unsigned long long (*)())
0001c6dc g     O .text	00000020 __sf_fake_stderr
000125d4  w    F .text	00000094 PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)
0001c1dc  w    O .text	00000100 Sd::kCrcTable8
00019430 g     F .text	00000010 std::get_terminate()
0001484c  w    F .text	00000074 Uart::FractionalEstimate(float, float)
00011120  w    F .text	00000088 Gpio::SetInterruptEdge(GpioInterface::Edge)
00015374  w    F .text	0000006c EnetIrqHandler
00015374  w    F .text	0000006c DmaIrqHandler
0001010c g     F .text	00000090 InitDataSection()
000153e0 g     F .text	0000005c RegisterIsr(IRQn, void (*)(), bool, long)
00000000 g       *ABS*	00000000 __base_Flash
00015374  w    F .text	0000006c Eint1IrqHandler
10000050  w    O .data	0000000c Ssp::ssp_registers
00015374  w    F .text	0000006c SvcHandler
00012f50  w    F .text	00000158 OledTerminal::printf(char const*, ...)
00015ff0 g     F .text	0000008c xTaskCheckForTimeOut
00015374  w    F .text	0000006c GpioIrqHandler
000198ec g     F .text	0000009c _free_r
0001c55c  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
00015374  w    F .text	0000006c SdioIrqHandler
10010000 g       *ABS*	00000000 __top_RamLoc64
10000950 g       .bss	00000000 _bss
0001c4f4  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
10000a7c  w    O .bss	00000001 LabUART::pc
00015374  w    F .text	0000006c Pll1IrqHandler
00015374  w    F .text	0000006c MemManageHandler
000126f8  w    F .text	00000028 PixelDisplayInterface::Disable()
00015bac g     F .text	00000014 vTaskSuspendAll
00019420 g     F .text	00000006 __cxa_pure_virtual
00012e3c  w    F .text	00000058 Graphics::DrawPixel(unsigned long, unsigned long)
000136e4 g     F .text	00000034 LabUART::Uqueue()
00015374  w    F .text	0000006c Pwm1IrqHandler
0001580c g     F .text	0000004a uxListRemove
000110f0  w    F .text	00000030 unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)
00015374  w    F .text	0000006c Timer0IrqHandler
00014ee0  w    F .text	000000a8 Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})
0001283c  w    F .text	0000002c Ssd1306::GetHeight()
00080000 g       *ABS*	00000000 __top_Flash
000148c0  w    F .text	00000084 Uart::IsDecmial(float)
00012264  w    F .text	000001ec Ssp::SetClock(bool, bool, unsigned char, unsigned char)
000130a8  w    F .text	0000009c OledTerminal::Update()
00015856 g     F .text	0000005c xTaskCreateStatic
100016d0 g       .noinit	00000000 _end_noinit
00013df8  w    F .text	0000003c SystemTimer::DisableTimer()
10001250 g     O .bss	00000001 uart_rx
00018b88  w    F .text	00000120 Sd::DeleteBlock(unsigned long, unsigned long)
00015e30 g     F .text	000000c8 vTaskSwitchContext
0001380c  w    F .text	00000054 unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)
000103a0  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
00011ec8  w    F .text	00000030 unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)
0001c51c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
1000124c  w    O .bss	00000004 guard variable for LabUART::oled_terminal
0001b1ac  w    O .text	00000004 Uart::kTxUartPortFunction
00012d40  w    F .text	000000fc Graphics::DrawCharacter(long, long, char, bool)
00015374  w    F .text	0000006c Uart3IrqHandler
000114a8  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
0001c554  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
20000000 g       *ABS*	00000000 __base_RamPeriph32
00012b60  w    F .text	00000094 Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)
00014be0 g     F .text	00000034 vApplicationGetIdleTaskMemory
0001a0e0  w    O .text	00000009 Gpio::ClearInterruptEdge(GpioInterface::Edge)::file
1000154c g     O .bss	00000004 stack_depth
00010e44  w    F .text	0000006c Gpio::Toggle()
0001c52c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001c2dc  w    O .text	00000200 Sd::kCrcTable16
10000978  w    O .bss	00000100 Gpio::interrupthandlers
00019848  w    F .text	00000002 .hidden __aeabi_ldiv0
00015374  w    F .text	0000006c Timer1IrqHandler
00012668  w    F .text	00000068 PixelDisplayInterface::Color_t::Color_t()
000147d8  w    F .text	00000074 Uart::DividerEstimate(float, float)
00010d38  w    F .text	00000064 Gpio::SetHigh()
000146dc  w    F .text	000000fc Uart::FindClosestFractional(float)
00011b60  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
000100e4 g       .text	00000000 data_section_table
0001a104  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
00010470  w    F .text	00000080 Pin::SetMode(PinInterface::Mode)
00018574  w    F .text	00000050 Sd::WaitWhileBusy()
00019ae4 g     F .text	00000002 __malloc_lock
00013f38  w    F .text	00000094 SystemTimer::SetTickFrequency(unsigned long)
0001c6fc g     O .text	00000020 __sf_fake_stdin
00013860  w    F .text	00000074 unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)
000102fc g       .text	00000000 __CRP_WORD_START__
0001b190  w    O .text	00000010 Timer::kTimerIsr
00012960  w    F .text	000000f0 Ssd1306::InitializationPanel()
00011230  w    F .text	00000048 Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)
00015374  w    F .text	0000006c Uart1IrqHandler
00010bfc  w    F .text	0000007c Gpio::SetAsInput()
00015688 g     F .text	00000028 __cyg_profile_func_enter
000198da g     F .text	00000010 memset
00013954 g     F .text	00000084 main
00018060  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
10000020  w    O .data	00000028 Gpio::interrupt
00013ffc  w    F .text	00000020 Timer::DoNothingIsr()
00015374  w    F .text	0000006c QeiIrqHandler
20000000 g       *ABS*	00000000 heap
000157a4 g     F .text	00000068 vListInsert
00015374  w    F .text	0000006c Ssp2IrqHandler
0001341c g     F .text	00000090 LabUART::setBaudrate9600()
00010980  w    F .text	0000002c Pin::GetPort() const
000189dc  w    F .text	000001ac Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)
000103a0  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
000194ac g     F .text	0000009e .hidden __truncdfsf2
00010320 g       .text	00000000 __init_array_end
00016950 g     F .text	00000026 vPortSVCHandler
000154b4 g     F .text	0000003c FirmwareStdOut(int)
00019988 g     F .text	000000b4 _malloc_r
0001c574  w    O .text	0000002c vtable for Sd
000111a8  w    F .text	00000088 Gpio::ClearInterruptEdge(GpioInterface::Edge)
00015374  w    F .text	0000006c Ssp1IrqHandler
00014d48  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)0>()
0001a1b0  w    O .text	0000000c Ssp::kPowerBit
000109ac  w    F .text	0000002c Pin::GetPin() const
0001642c g     F .text	00000062 xQueueGenericCreate
000142b4  w    F .text	000000cc Uart::SetBaudRate(unsigned long)
0001b1d0  w    O .text	0000003c vtable for Uart
00010cf4  w    F .text	00000044 Gpio::SetDirection(GpioInterface::Direction)
00010c78  w    F .text	0000007c Gpio::SetAsOutput()
0001c53c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001186c  w    F .text	00000170 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)
00013194  w    F .text	0000006c OledTerminal::OledTerminal()
00010d9c  w    F .text	00000064 Gpio::SetLow()
0001a288  w    O .text	00000024 vtable for Lpc40xxSystemController
000185c4  w    F .text	00000418 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)
0001c564  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
0001a0ec  w    O .text	00000016 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file
00014cfc g     F .text	0000001a SystemInit
0001401c  w    F .text	00000134 Timer::Initialize(unsigned long, void (*)(), long)
00011638  w    F .text	00000030 Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)
20008000 g       *ABS*	00000000 heap_end
00011c44  w    F .text	000000e4 Ssp::Initialize()
0001b20c  w    O .text	00000038 vtable for Timer
00011ad4  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10000768  w    O .data	00000010 Timer::tim_register
00015374  w    F .text	0000006c Ssp0IrqHandler
00010320 g     F .text	00000000 _fini
00015374  w    F .text	0000006c UsbactivityIrqHandler
00010e00  w    F .text	00000044 Gpio::Set(GpioInterface::State)
00015374  w    F .text	0000006c Pll0IrqHandler
00015bc0 g     F .text	00000118 xTaskResumeAll
00011b0c  w    F .text	00000054 Pin::Pin(Pin const&)
000100fc g       .text	00000000 data_section_table_end
00015374  w    F .text	0000006c CanactivityIrqHandler
00015b10 g     F .text	0000009c vTaskStartScheduler
00015374  w    F .text	0000006c NmiHandler
00012668  w    F .text	00000068 PixelDisplayInterface::Color_t::Color_t()
00012720  w    F .text	00000028 PixelDisplayInterface::Update()
0001a168  w    O .text	00000048 Ssp::kSspPinMatrix
00012ad4  w    F .text	00000054 Ssd1306::SetHorizontalAddressMode()
00010eb0  w    F .text	00000078 Gpio::ReadState()
0001c504  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
100008e8 g     O .data	00000004 _impure_ptr
000192fc  w    F .text	000000ac Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
00019190  w    F .text	00000070 Sd::GetCrc7(unsigned char*, unsigned char)
00012a50  w    F .text	00000084 Ssd1306::Initialize()
00015374  w    F .text	0000006c McpwmIrqHandler
0001030c g       .text	00000000 __preinit_array_end
00015374  w    F .text	0000006c WdtIrqHandler
00017ee0  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::operator()() const
00018ca8  w    F .text	000004a0 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)
000114c0  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
0001a360  w    O .text	0000003c vtable for Pin
00012b28  w    F .text	00000038 Ssd1306::Clear()
10000000 g       .data	00000000 _data
00010564  w    F .text	00000074 Pin::SetAsActiveLow(bool)
000116cc  w    F .text	00000030 Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)
000112b8  w    F .text	0000007c Gpio::SetEdgeRising()
0001c4e4  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001607c g     F .text	00000010 vTaskMissedYield
00013fcc  w    F .text	00000030 unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)
10000464 g     O .data	00000300 pincon
10001298  w    O .bss	00000010 Timer::user_timer_isr
000126d0  w    F .text	00000028 PixelDisplayInterface::Enable()
0001a11c  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
10001258  w    O .bss	00000040 Timer::match
00014464  w    F .text	0000004c Uart::Send(unsigned char)::{lambda()#1}::operator()() const
00015cd8 g     F .text	00000158 xTaskIncrementTick
0001a1e8  w    O .text	0000002c vtable for PixelDisplayInterface
000181b0  w    F .text	0000031c Sd::Mount(SdInterface::CardInfo_t*)
100008e4 g     O .data	00000004 __cxxabiv1::__terminate_handler
00013240 g     F .text	000001dc LabUART::InitializeUart()
00016378 g     F .text	000000b4 xQueueGenericReset
0001a2ac  w    O .text	00000024 vtable for SystemControllerInterface
0001a2d0  w    O .text	00000048 vtable for Gpio
1000094c g       .data	00000000 _edata
10000a80  w    O .bss	000007c8 LabUART::oled_terminal
0001b17c  w    O .text	00000010 Timer::kPowerbit
00014d84  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)1>()
000104f0  w    F .text	00000074 Pin::EnableHysteresis(bool)
00010b4c  w    F .text	00000034 GpioInterface::GpioInterface()
000125d4  w    F .text	00000094 PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)
00015374  w    F .text	0000006c DebugMonHandler
00010fc4  w    F .text	0000007c Gpio::ValidPortCheck()
000158b2 g     F .text	0000008e xTaskCreate
00015374  w    F .text	0000006c Eint2IrqHandler
20008000 g       *ABS*	00000000 __top_RamPeriph32
00011b60  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
00015374  w    F .text	0000006c Timer3IrqHandler
00012748  w    F .text	00000034 PixelDisplayInterface::PixelDisplayInterface()
10000000 g       *ABS*	00000000 __base_RAM
00015374  w    F .text	0000006c Eint3IrqHandler
0001357c g     F .text	000000a8 LabUART::vReceiveByteOverUartTask(void*)
00019426 g     F .text	00000008 __cxxabiv1::__terminate(void (*)())
00014bb4  w    F .text	0000002c unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])
0001552c g     F .text	00000030 _kill
00015374  w    F .text	0000006c I2c0IrqHandler
00011b0c  w    F .text	00000054 Pin::Pin(Pin const&)
0001b1a0  w    O .text	0000000a Timer::Initialize(unsigned long, void (*)(), long)::file
00013e34  w    F .text	00000034 SystemTimer::SystemTimerHandler()
0001c4ec  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001c71c g     O .text	00000020 __sf_fake_stdout
000109d8  w    F .text	00000100 debug::PrintBacktrace(bool, void*)
0001030c g       .text	00000000 __init_array_start
00019848  w    F .text	00000002 .hidden __aeabi_idiv0
0001c5a0  w    O .text	0000002c vtable for SdInterface
00018100  w    F .text	000000b0 Sd::Initialize()
000154f0 g     F .text	00000018 _exit
000106d0  w    F .text	00000074 Pin::EnableFastMode(bool)
00014f88  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()
00015374  w    F .text	0000006c Eint0IrqHandler
00013e9c  w    F .text	0000009c SystemTimer::StartTimer()
00011e98  w    F .text	00000030 unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)
000168bc g     F .text	00000060 pxPortInitialiseStack
0001019c g     F .text	00000060 InitBssSection()
100016c8 g     O .bss	00000004 __malloc_sbrk_start
00010b80  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
00014b74 g     F .text	00000040 UptimeRTOS
00012748  w    F .text	00000034 PixelDisplayInterface::PixelDisplayInterface()
00012cf4  w    F .text	0000004c Graphics::Initialize()
00010834  w    F .text	00000074 Pin::SetAsOpenDrain(bool)
000169f4 g     F .text	00000028 vPortEnterCritical
0001b244  w    O .text	00000038 vtable for SystemTimer
00015374  w    F .text	0000006c SpiIrqHandler
0001c524  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
100016c4 g     O .bss	00000004 __malloc_free_list
00011e0c  w    F .text	0000005c Ssp::SetSpiMasterDefault()
10000788  w    O .data	00000040 Uart::pairs
000114a8  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
00011668  w    F .text	00000030 Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)
0001802c  w    F .text	00000034 SdInterface::SdInterface()
0001030c g       .text	00000000 __preinit_array_start
100008d8  w    O .data	00000004 heap_position
0001a134  w    O .text	00000016 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file
00011698  w    F .text	00000034 Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)
10001448  w    O .bss	00000004 guard variable for Timer::match
00011ef8  w    F .text	0000020c Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)
000103f8  w    F .text	00000078 Pin::SetPinFunction(unsigned char)
00013c48 g     F .text	000000c0 pinconn::uart3_txd(unsigned char, unsigned char)
00013798  w    F .text	00000074 unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)
0001036c  w    F .text	00000034 PinInterface::PinInterface()
00011574  w    F .text	00000058 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)
00010b80  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
00014dfc  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)3>()
00019aac g     F .text	00000010 raise
000198b4 g     F .text	00000010 free
00013ac8 g     F .text	000000c0 pinconn::uart2_txd(unsigned char, unsigned char)



Disassembly of section .text:

00010000 <kInterruptVectorTable>:
   10000:	00 00 01 10 19 4d 01 00 75 53 01 00 19 02 01 00     .....M..uS......
   10010:	75 53 01 00 75 53 01 00 75 53 01 00 fa 62 f7 ef     uS..uS..uS...b..
	...
   1002c:	51 69 01 00 75 53 01 00 00 00 00 00 51 6a 01 00     Qi..uS......Qj..
   1003c:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   1004c:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   1005c:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   1006c:	75 53 01 00 75 53 01 00 00 00 00 00 75 53 01 00     uS..uS......uS..
   1007c:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   1008c:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   1009c:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   100ac:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   100bc:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   100cc:	75 53 01 00 75 53 01 00 75 53 01 00 75 53 01 00     uS..uS..uS..uS..
   100dc:	75 53 01 00 75 53 01 00                             uS..uS..

000100e4 <data_section_table>:
   100e4:	0001c744 	.word	0x0001c744
   100e8:	10000000 	.word	0x10000000
   100ec:	0000094c 	.word	0x0000094c
   100f0:	0001c744 	.word	0x0001c744
   100f4:	20000000 	.word	0x20000000
   100f8:	00000000 	.word	0x00000000

000100fc <bss_section_table>:
   100fc:	10000950 	.word	0x10000950
   10100:	00000d80 	.word	0x00000d80
   10104:	20000000 	.word	0x20000000
   10108:	00000000 	.word	0x00000000

0001010c <InitDataSection()>:
SJ2_IGNORE_STACK_TRACE(void SystemInit());

// Functions to carry out the initialization of RW and BSS data sections.
SJ2_SECTION(".after_vectors")
void InitDataSection()
{
   1010c:	b086      	sub	sp, #24
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   1010e:	2300      	movs	r3, #0
   10110:	9305      	str	r3, [sp, #20]
   10112:	9a05      	ldr	r2, [sp, #20]
   10114:	4613      	mov	r3, r2
   10116:	005b      	lsls	r3, r3, #1
   10118:	4413      	add	r3, r2
   1011a:	009b      	lsls	r3, r3, #2
   1011c:	4a1d      	ldr	r2, [pc, #116]	; (10194 <InitDataSection()+0x88>)
   1011e:	4413      	add	r3, r2
   10120:	4a1d      	ldr	r2, [pc, #116]	; (10198 <InitDataSection()+0x8c>)
   10122:	4293      	cmp	r3, r2
   10124:	d233      	bcs.n	1018e <InitDataSection()+0x82>
  {
    uint32_t * rom_location = data_section_table[i].rom_location;
   10126:	491b      	ldr	r1, [pc, #108]	; (10194 <InitDataSection()+0x88>)
   10128:	9a05      	ldr	r2, [sp, #20]
   1012a:	4613      	mov	r3, r2
   1012c:	005b      	lsls	r3, r3, #1
   1012e:	4413      	add	r3, r2
   10130:	009b      	lsls	r3, r3, #2
   10132:	440b      	add	r3, r1
   10134:	681b      	ldr	r3, [r3, #0]
   10136:	9303      	str	r3, [sp, #12]
    uint32_t * ram_location = data_section_table[i].ram_location;
   10138:	4916      	ldr	r1, [pc, #88]	; (10194 <InitDataSection()+0x88>)
   1013a:	9a05      	ldr	r2, [sp, #20]
   1013c:	4613      	mov	r3, r2
   1013e:	005b      	lsls	r3, r3, #1
   10140:	4413      	add	r3, r2
   10142:	009b      	lsls	r3, r3, #2
   10144:	440b      	add	r3, r1
   10146:	685b      	ldr	r3, [r3, #4]
   10148:	9302      	str	r3, [sp, #8]
    uint32_t length         = data_section_table[i].length;
   1014a:	4912      	ldr	r1, [pc, #72]	; (10194 <InitDataSection()+0x88>)
   1014c:	9a05      	ldr	r2, [sp, #20]
   1014e:	4613      	mov	r3, r2
   10150:	005b      	lsls	r3, r3, #1
   10152:	4413      	add	r3, r2
   10154:	009b      	lsls	r3, r3, #2
   10156:	440b      	add	r3, r1
   10158:	3308      	adds	r3, #8
   1015a:	681b      	ldr	r3, [r3, #0]
   1015c:	9301      	str	r3, [sp, #4]
    for (size_t j = 0; j < length; j++)
   1015e:	2300      	movs	r3, #0
   10160:	9304      	str	r3, [sp, #16]
   10162:	9a04      	ldr	r2, [sp, #16]
   10164:	9b01      	ldr	r3, [sp, #4]
   10166:	429a      	cmp	r2, r3
   10168:	d20d      	bcs.n	10186 <InitDataSection()+0x7a>
    {
      ram_location[j] = rom_location[j];
   1016a:	9b04      	ldr	r3, [sp, #16]
   1016c:	009b      	lsls	r3, r3, #2
   1016e:	9a03      	ldr	r2, [sp, #12]
   10170:	441a      	add	r2, r3
   10172:	9b04      	ldr	r3, [sp, #16]
   10174:	009b      	lsls	r3, r3, #2
   10176:	9902      	ldr	r1, [sp, #8]
   10178:	440b      	add	r3, r1
   1017a:	6812      	ldr	r2, [r2, #0]
   1017c:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   1017e:	9b04      	ldr	r3, [sp, #16]
   10180:	3301      	adds	r3, #1
   10182:	9304      	str	r3, [sp, #16]
   10184:	e7ed      	b.n	10162 <InitDataSection()+0x56>
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   10186:	9b05      	ldr	r3, [sp, #20]
   10188:	3301      	adds	r3, #1
   1018a:	9305      	str	r3, [sp, #20]
   1018c:	e7c1      	b.n	10112 <InitDataSection()+0x6>
    }
  }
}
   1018e:	bf00      	nop
   10190:	b006      	add	sp, #24
   10192:	4770      	bx	lr
   10194:	000100e4 	.word	0x000100e4
   10198:	000100fc 	.word	0x000100fc

0001019c <InitBssSection()>:

// Functions to initialization BSS data sections. This is important because
// the std c libs assume that BSS is set to zero.
SJ2_SECTION(".after_vectors")
void InitBssSection()
{
   1019c:	b084      	sub	sp, #16
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   1019e:	2300      	movs	r3, #0
   101a0:	9303      	str	r3, [sp, #12]
   101a2:	9b03      	ldr	r3, [sp, #12]
   101a4:	00db      	lsls	r3, r3, #3
   101a6:	4a13      	ldr	r2, [pc, #76]	; (101f4 <InitBssSection()+0x58>)
   101a8:	4413      	add	r3, r2
   101aa:	4a13      	ldr	r2, [pc, #76]	; (101f8 <InitBssSection()+0x5c>)
   101ac:	4293      	cmp	r3, r2
   101ae:	d21e      	bcs.n	101ee <InitBssSection()+0x52>
  {
    uint32_t * ram_location = bss_section_table[i].ram_location;
   101b0:	4a10      	ldr	r2, [pc, #64]	; (101f4 <InitBssSection()+0x58>)
   101b2:	9b03      	ldr	r3, [sp, #12]
   101b4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   101b8:	9301      	str	r3, [sp, #4]
    uint32_t length         = bss_section_table[i].length;
   101ba:	4a0e      	ldr	r2, [pc, #56]	; (101f4 <InitBssSection()+0x58>)
   101bc:	9b03      	ldr	r3, [sp, #12]
   101be:	00db      	lsls	r3, r3, #3
   101c0:	4413      	add	r3, r2
   101c2:	685b      	ldr	r3, [r3, #4]
   101c4:	9300      	str	r3, [sp, #0]
    for (size_t j = 0; j < length; j++)
   101c6:	2300      	movs	r3, #0
   101c8:	9302      	str	r3, [sp, #8]
   101ca:	9a02      	ldr	r2, [sp, #8]
   101cc:	9b00      	ldr	r3, [sp, #0]
   101ce:	429a      	cmp	r2, r3
   101d0:	d209      	bcs.n	101e6 <InitBssSection()+0x4a>
    {
      ram_location[j] = 0;
   101d2:	9b02      	ldr	r3, [sp, #8]
   101d4:	009b      	lsls	r3, r3, #2
   101d6:	9a01      	ldr	r2, [sp, #4]
   101d8:	4413      	add	r3, r2
   101da:	2200      	movs	r2, #0
   101dc:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   101de:	9b02      	ldr	r3, [sp, #8]
   101e0:	3301      	adds	r3, #1
   101e2:	9302      	str	r3, [sp, #8]
   101e4:	e7f1      	b.n	101ca <InitBssSection()+0x2e>
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101e6:	9b03      	ldr	r3, [sp, #12]
   101e8:	3301      	adds	r3, #1
   101ea:	9303      	str	r3, [sp, #12]
   101ec:	e7d9      	b.n	101a2 <InitBssSection()+0x6>
    }
  }
}
   101ee:	bf00      	nop
   101f0:	b004      	add	sp, #16
   101f2:	4770      	bx	lr
   101f4:	000100fc 	.word	0x000100fc
   101f8:	0001010c 	.word	0x0001010c

000101fc <InitFpu()>:
      // Write back the modified value to the CPACR
      "STR     R1, [R0]\n"
      // Wait for store to complete
      "DSB\n"
      // reset pipeline now the FPU is enabled
      "ISB\n");
   101fc:	f8df 0014 	ldr.w	r0, [pc, #20]	; 10214 <InitFpu()+0x18>
   10200:	6801      	ldr	r1, [r0, #0]
   10202:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   10206:	6001      	str	r1, [r0, #0]
   10208:	f3bf 8f4f 	dsb	sy
   1020c:	f3bf 8f6f 	isb	sy
}
   10210:	bf00      	nop
   10212:	4770      	bx	lr
   10214:	e000ed88 	.word	0xe000ed88

00010218 <HardFaultHandler>:
      " mrseq r0, msp                                       \n"
      " mrsne r0, psp                                       \n"
      " ldr r1, [r0, #24]                                   \n"
      " ldr r2, handler2_address_const                      \n"
      " bx r2                                               \n"
      " handler2_address_const: .word GetRegistersFromStack \n");
   10218:	f01e 0f04 	tst.w	lr, #4
   1021c:	bf0c      	ite	eq
   1021e:	f3ef 8008 	mrseq	r0, MSP
   10222:	f3ef 8009 	mrsne	r0, PSP
   10226:	6981      	ldr	r1, [r0, #24]
   10228:	4a00      	ldr	r2, [pc, #0]	; (1022c <handler2_address_const>)
   1022a:	4710      	bx	r2

0001022c <handler2_address_const>:
   1022c:	0001543d 	.word	0x0001543d
#endif
}
   10230:	bf00      	nop
   10232:	4770      	bx	lr
   10234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1023c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1024c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1025c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000102fc <__CRP_WORD_START__>:
   102fc:	ffffffff 	.word	0xffffffff

00010300 <_init>:
   10300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10302:	bf00      	nop
   10304:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10306:	bc08      	pop	{r3}
   10308:	469e      	mov	lr, r3
   1030a:	4770      	bx	lr

0001030c <__init_array_start>:
   1030c:	00010351 	.word	0x00010351
   10310:	0001392d 	.word	0x0001392d
   10314:	00013a3d 	.word	0x00013a3d
   10318:	000152e5 	.word	0x000152e5
   1031c:	000193f9 	.word	0x000193f9

00010320 <_fini>:
   10320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10322:	bf00      	nop
   10324:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10326:	bc08      	pop	{r3}
   10328:	469e      	mov	lr, r3
   1032a:	4770      	bx	lr

0001032c <__do_global_dtors_aux>:
   1032c:	b510      	push	{r4, lr}
   1032e:	4c05      	ldr	r4, [pc, #20]	; (10344 <__do_global_dtors_aux+0x18>)
   10330:	7823      	ldrb	r3, [r4, #0]
   10332:	b933      	cbnz	r3, 10342 <__do_global_dtors_aux+0x16>
   10334:	4b04      	ldr	r3, [pc, #16]	; (10348 <__do_global_dtors_aux+0x1c>)
   10336:	b113      	cbz	r3, 1033e <__do_global_dtors_aux+0x12>
   10338:	4804      	ldr	r0, [pc, #16]	; (1034c <__do_global_dtors_aux+0x20>)
   1033a:	f3af 8000 	nop.w
   1033e:	2301      	movs	r3, #1
   10340:	7023      	strb	r3, [r4, #0]
   10342:	bd10      	pop	{r4, pc}
   10344:	10000950 	.word	0x10000950
   10348:	00000000 	.word	0x00000000
   1034c:	0001c744 	.word	0x0001c744

00010350 <frame_dummy>:
   10350:	b508      	push	{r3, lr}
   10352:	4b03      	ldr	r3, [pc, #12]	; (10360 <frame_dummy+0x10>)
   10354:	b11b      	cbz	r3, 1035e <frame_dummy+0xe>
   10356:	4903      	ldr	r1, [pc, #12]	; (10364 <frame_dummy+0x14>)
   10358:	4803      	ldr	r0, [pc, #12]	; (10368 <frame_dummy+0x18>)
   1035a:	f3af 8000 	nop.w
   1035e:	bd08      	pop	{r3, pc}
   10360:	00000000 	.word	0x00000000
   10364:	10000954 	.word	0x10000954
   10368:	0001c744 	.word	0x0001c744

0001036c <PinInterface::PinInterface()>:
#include <cstdio>

#include "L0_LowLevel/LPC40xx.h"
#include "utility/macros.hpp"

class PinInterface
   1036c:	b530      	push	{r4, r5, lr}
   1036e:	b083      	sub	sp, #12
   10370:	4675      	mov	r5, lr
   10372:	9001      	str	r0, [sp, #4]
   10374:	462b      	mov	r3, r5
   10376:	4619      	mov	r1, r3
   10378:	4807      	ldr	r0, [pc, #28]	; (10398 <PinInterface::PinInterface()+0x2c>)
   1037a:	f005 f985 	bl	15688 <__cyg_profile_func_enter>
   1037e:	4a07      	ldr	r2, [pc, #28]	; (1039c <PinInterface::PinInterface()+0x30>)
   10380:	9b01      	ldr	r3, [sp, #4]
   10382:	601a      	str	r2, [r3, #0]
   10384:	9c01      	ldr	r4, [sp, #4]
   10386:	462b      	mov	r3, r5
   10388:	4619      	mov	r1, r3
   1038a:	4803      	ldr	r0, [pc, #12]	; (10398 <PinInterface::PinInterface()+0x2c>)
   1038c:	f005 f990 	bl	156b0 <__cyg_profile_func_exit>
   10390:	4623      	mov	r3, r4
   10392:	4618      	mov	r0, r3
   10394:	b003      	add	sp, #12
   10396:	bd30      	pop	{r4, r5, pc}
   10398:	0001036d 	.word	0x0001036d
   1039c:	0001a3a4 	.word	0x0001a3a4

000103a0 <Pin::Pin(unsigned char, unsigned char)>:
  // no effect.
  static constexpr Pin CreateInactivePin()
  {
    return Pin(5, 4);
  }
  constexpr Pin(uint8_t port_number, uint8_t pin_number)
   103a0:	b530      	push	{r4, r5, lr}
   103a2:	b083      	sub	sp, #12
   103a4:	4675      	mov	r5, lr
   103a6:	9001      	str	r0, [sp, #4]
   103a8:	460b      	mov	r3, r1
   103aa:	f88d 3003 	strb.w	r3, [sp, #3]
   103ae:	4613      	mov	r3, r2
   103b0:	f88d 3002 	strb.w	r3, [sp, #2]
   103b4:	462b      	mov	r3, r5
   103b6:	4619      	mov	r1, r3
   103b8:	480d      	ldr	r0, [pc, #52]	; (103f0 <Pin::Pin(unsigned char, unsigned char)+0x50>)
   103ba:	f005 f965 	bl	15688 <__cyg_profile_func_enter>
      : port_(port_number), pin_(pin_number)
   103be:	9b01      	ldr	r3, [sp, #4]
   103c0:	4618      	mov	r0, r3
   103c2:	f7ff ffd3 	bl	1036c <PinInterface::PinInterface()>
   103c6:	4a0b      	ldr	r2, [pc, #44]	; (103f4 <Pin::Pin(unsigned char, unsigned char)+0x54>)
   103c8:	9b01      	ldr	r3, [sp, #4]
   103ca:	601a      	str	r2, [r3, #0]
   103cc:	9b01      	ldr	r3, [sp, #4]
   103ce:	f89d 2003 	ldrb.w	r2, [sp, #3]
   103d2:	711a      	strb	r2, [r3, #4]
   103d4:	9b01      	ldr	r3, [sp, #4]
   103d6:	f89d 2002 	ldrb.w	r2, [sp, #2]
   103da:	715a      	strb	r2, [r3, #5]
  {
  }
   103dc:	9c01      	ldr	r4, [sp, #4]
   103de:	462b      	mov	r3, r5
   103e0:	4619      	mov	r1, r3
   103e2:	4803      	ldr	r0, [pc, #12]	; (103f0 <Pin::Pin(unsigned char, unsigned char)+0x50>)
   103e4:	f005 f964 	bl	156b0 <__cyg_profile_func_exit>
   103e8:	4623      	mov	r3, r4
   103ea:	4618      	mov	r0, r3
   103ec:	b003      	add	sp, #12
   103ee:	bd30      	pop	{r4, r5, pc}
   103f0:	000103a1 	.word	0x000103a1
   103f4:	0001a368 	.word	0x0001a368

000103f8 <Pin::SetPinFunction(unsigned char)>:
  void SetPinFunction(uint8_t function) override
   103f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   103fa:	b085      	sub	sp, #20
   103fc:	4677      	mov	r7, lr
   103fe:	9003      	str	r0, [sp, #12]
   10400:	460b      	mov	r3, r1
   10402:	f88d 300b 	strb.w	r3, [sp, #11]
   10406:	463b      	mov	r3, r7
   10408:	4619      	mov	r1, r3
   1040a:	4817      	ldr	r0, [pc, #92]	; (10468 <Pin::SetPinFunction(unsigned char)+0x70>)
   1040c:	f005 f93c 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   10410:	4b16      	ldr	r3, [pc, #88]	; (1046c <Pin::SetPinFunction(unsigned char)+0x74>)
   10412:	681b      	ldr	r3, [r3, #0]
   10414:	9a03      	ldr	r2, [sp, #12]
   10416:	7912      	ldrb	r2, [r2, #4]
   10418:	4610      	mov	r0, r2
   1041a:	9a03      	ldr	r2, [sp, #12]
   1041c:	7952      	ldrb	r2, [r2, #5]
   1041e:	4611      	mov	r1, r2
   10420:	0142      	lsls	r2, r0, #5
   10422:	440a      	add	r2, r1
   10424:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 function & 0b111, 3);
   10428:	f89d 300b 	ldrb.w	r3, [sp, #11]
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   1042c:	f003 0207 	and.w	r2, r3, #7
    pin_map->_register[port_][pin_] =
   10430:	4b0e      	ldr	r3, [pc, #56]	; (1046c <Pin::SetPinFunction(unsigned char)+0x74>)
   10432:	681c      	ldr	r4, [r3, #0]
   10434:	9b03      	ldr	r3, [sp, #12]
   10436:	791b      	ldrb	r3, [r3, #4]
   10438:	461e      	mov	r6, r3
   1043a:	9b03      	ldr	r3, [sp, #12]
   1043c:	795b      	ldrb	r3, [r3, #5]
   1043e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   10440:	2303      	movs	r3, #3
   10442:	9300      	str	r3, [sp, #0]
   10444:	4613      	mov	r3, r2
   10446:	2200      	movs	r2, #0
   10448:	9803      	ldr	r0, [sp, #12]
   1044a:	f000 fa67 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1044e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10450:	0173      	lsls	r3, r6, #5
   10452:	442b      	add	r3, r5
   10454:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10458:	463b      	mov	r3, r7
   1045a:	4619      	mov	r1, r3
   1045c:	4802      	ldr	r0, [pc, #8]	; (10468 <Pin::SetPinFunction(unsigned char)+0x70>)
   1045e:	f005 f927 	bl	156b0 <__cyg_profile_func_exit>
  }
   10462:	bf00      	nop
   10464:	b005      	add	sp, #20
   10466:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10468:	000103f9 	.word	0x000103f9
   1046c:	10000000 	.word	0x10000000

00010470 <Pin::SetMode(PinInterface::Mode)>:
  void SetMode(PinInterface::Mode mode) override
   10470:	b5f0      	push	{r4, r5, r6, r7, lr}
   10472:	b087      	sub	sp, #28
   10474:	4677      	mov	r7, lr
   10476:	9003      	str	r0, [sp, #12]
   10478:	460b      	mov	r3, r1
   1047a:	f88d 300b 	strb.w	r3, [sp, #11]
   1047e:	463b      	mov	r3, r7
   10480:	4619      	mov	r1, r3
   10482:	4819      	ldr	r0, [pc, #100]	; (104e8 <Pin::SetMode(PinInterface::Mode)+0x78>)
   10484:	f005 f900 	bl	15688 <__cyg_profile_func_enter>
  {
    uint8_t ui_mode                 = static_cast<uint8_t>(mode);
   10488:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1048c:	f88d 3017 	strb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   10490:	4b16      	ldr	r3, [pc, #88]	; (104ec <Pin::SetMode(PinInterface::Mode)+0x7c>)
   10492:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   10494:	9a03      	ldr	r2, [sp, #12]
   10496:	7912      	ldrb	r2, [r2, #4]
   10498:	4610      	mov	r0, r2
   1049a:	9a03      	ldr	r2, [sp, #12]
   1049c:	7952      	ldrb	r2, [r2, #5]
   1049e:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   104a0:	0142      	lsls	r2, r0, #5
   104a2:	440a      	add	r2, r1
   104a4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   104a8:	f89d 3017 	ldrb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   104ac:	f003 0203 	and.w	r2, r3, #3
   104b0:	4b0e      	ldr	r3, [pc, #56]	; (104ec <Pin::SetMode(PinInterface::Mode)+0x7c>)
   104b2:	681c      	ldr	r4, [r3, #0]
   104b4:	9b03      	ldr	r3, [sp, #12]
   104b6:	791b      	ldrb	r3, [r3, #4]
   104b8:	461e      	mov	r6, r3
   104ba:	9b03      	ldr	r3, [sp, #12]
   104bc:	795b      	ldrb	r3, [r3, #5]
   104be:	461d      	mov	r5, r3
   104c0:	2302      	movs	r3, #2
   104c2:	9300      	str	r3, [sp, #0]
   104c4:	4613      	mov	r3, r2
   104c6:	2203      	movs	r2, #3
   104c8:	9803      	ldr	r0, [sp, #12]
   104ca:	f000 fa27 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   104ce:	4602      	mov	r2, r0
   104d0:	0173      	lsls	r3, r6, #5
   104d2:	442b      	add	r3, r5
   104d4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   104d8:	463b      	mov	r3, r7
   104da:	4619      	mov	r1, r3
   104dc:	4802      	ldr	r0, [pc, #8]	; (104e8 <Pin::SetMode(PinInterface::Mode)+0x78>)
   104de:	f005 f8e7 	bl	156b0 <__cyg_profile_func_exit>
  }
   104e2:	bf00      	nop
   104e4:	b007      	add	sp, #28
   104e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   104e8:	00010471 	.word	0x00010471
   104ec:	10000000 	.word	0x10000000

000104f0 <Pin::EnableHysteresis(bool)>:
  void EnableHysteresis(bool enable_hysteresis = true) override
   104f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   104f2:	b085      	sub	sp, #20
   104f4:	4677      	mov	r7, lr
   104f6:	9003      	str	r0, [sp, #12]
   104f8:	460b      	mov	r3, r1
   104fa:	f88d 300b 	strb.w	r3, [sp, #11]
   104fe:	463b      	mov	r3, r7
   10500:	4619      	mov	r1, r3
   10502:	4816      	ldr	r0, [pc, #88]	; (1055c <Pin::EnableHysteresis(bool)+0x6c>)
   10504:	f005 f8c0 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   10508:	4b15      	ldr	r3, [pc, #84]	; (10560 <Pin::EnableHysteresis(bool)+0x70>)
   1050a:	681b      	ldr	r3, [r3, #0]
   1050c:	9a03      	ldr	r2, [sp, #12]
   1050e:	7912      	ldrb	r2, [r2, #4]
   10510:	4610      	mov	r0, r2
   10512:	9a03      	ldr	r2, [sp, #12]
   10514:	7952      	ldrb	r2, [r2, #5]
   10516:	4611      	mov	r1, r2
   10518:	0142      	lsls	r2, r0, #5
   1051a:	440a      	add	r2, r1
   1051c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   10520:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   10524:	4b0e      	ldr	r3, [pc, #56]	; (10560 <Pin::EnableHysteresis(bool)+0x70>)
   10526:	681c      	ldr	r4, [r3, #0]
   10528:	9b03      	ldr	r3, [sp, #12]
   1052a:	791b      	ldrb	r3, [r3, #4]
   1052c:	461e      	mov	r6, r3
   1052e:	9b03      	ldr	r3, [sp, #12]
   10530:	795b      	ldrb	r3, [r3, #5]
   10532:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   10534:	2301      	movs	r3, #1
   10536:	9300      	str	r3, [sp, #0]
   10538:	4613      	mov	r3, r2
   1053a:	2205      	movs	r2, #5
   1053c:	9803      	ldr	r0, [sp, #12]
   1053e:	f000 f9ed 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   10542:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10544:	0173      	lsls	r3, r6, #5
   10546:	442b      	add	r3, r5
   10548:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   1054c:	463b      	mov	r3, r7
   1054e:	4619      	mov	r1, r3
   10550:	4802      	ldr	r0, [pc, #8]	; (1055c <Pin::EnableHysteresis(bool)+0x6c>)
   10552:	f005 f8ad 	bl	156b0 <__cyg_profile_func_exit>
                 enable_hysteresis, 1);
  }
   10556:	bf00      	nop
   10558:	b005      	add	sp, #20
   1055a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1055c:	000104f1 	.word	0x000104f1
   10560:	10000000 	.word	0x10000000

00010564 <Pin::SetAsActiveLow(bool)>:
  void SetAsActiveLow(bool set_as_active_low = true) override
   10564:	b5f0      	push	{r4, r5, r6, r7, lr}
   10566:	b085      	sub	sp, #20
   10568:	4677      	mov	r7, lr
   1056a:	9003      	str	r0, [sp, #12]
   1056c:	460b      	mov	r3, r1
   1056e:	f88d 300b 	strb.w	r3, [sp, #11]
   10572:	463b      	mov	r3, r7
   10574:	4619      	mov	r1, r3
   10576:	4816      	ldr	r0, [pc, #88]	; (105d0 <Pin::SetAsActiveLow(bool)+0x6c>)
   10578:	f005 f886 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   1057c:	4b15      	ldr	r3, [pc, #84]	; (105d4 <Pin::SetAsActiveLow(bool)+0x70>)
   1057e:	681b      	ldr	r3, [r3, #0]
   10580:	9a03      	ldr	r2, [sp, #12]
   10582:	7912      	ldrb	r2, [r2, #4]
   10584:	4610      	mov	r0, r2
   10586:	9a03      	ldr	r2, [sp, #12]
   10588:	7952      	ldrb	r2, [r2, #5]
   1058a:	4611      	mov	r1, r2
   1058c:	0142      	lsls	r2, r0, #5
   1058e:	440a      	add	r2, r1
   10590:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   10594:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   10598:	4b0e      	ldr	r3, [pc, #56]	; (105d4 <Pin::SetAsActiveLow(bool)+0x70>)
   1059a:	681c      	ldr	r4, [r3, #0]
   1059c:	9b03      	ldr	r3, [sp, #12]
   1059e:	791b      	ldrb	r3, [r3, #4]
   105a0:	461e      	mov	r6, r3
   105a2:	9b03      	ldr	r3, [sp, #12]
   105a4:	795b      	ldrb	r3, [r3, #5]
   105a6:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   105a8:	2301      	movs	r3, #1
   105aa:	9300      	str	r3, [sp, #0]
   105ac:	4613      	mov	r3, r2
   105ae:	2206      	movs	r2, #6
   105b0:	9803      	ldr	r0, [sp, #12]
   105b2:	f000 f9b3 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   105b6:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   105b8:	0173      	lsls	r3, r6, #5
   105ba:	442b      	add	r3, r5
   105bc:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   105c0:	463b      	mov	r3, r7
   105c2:	4619      	mov	r1, r3
   105c4:	4802      	ldr	r0, [pc, #8]	; (105d0 <Pin::SetAsActiveLow(bool)+0x6c>)
   105c6:	f005 f873 	bl	156b0 <__cyg_profile_func_exit>
                 set_as_active_low, 1);
  }
   105ca:	bf00      	nop
   105cc:	b005      	add	sp, #20
   105ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   105d0:	00010565 	.word	0x00010565
   105d4:	10000000 	.word	0x10000000

000105d8 <Pin::SetAsAnalogMode(bool)>:
  // Set bit to 0 to enable analog mode
  void SetAsAnalogMode(bool set_as_analog = true) override
   105d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   105da:	b085      	sub	sp, #20
   105dc:	4677      	mov	r7, lr
   105de:	9003      	str	r0, [sp, #12]
   105e0:	460b      	mov	r3, r1
   105e2:	f88d 300b 	strb.w	r3, [sp, #11]
   105e6:	463b      	mov	r3, r7
   105e8:	4619      	mov	r1, r3
   105ea:	4818      	ldr	r0, [pc, #96]	; (1064c <Pin::SetAsAnalogMode(bool)+0x74>)
   105ec:	f005 f84c 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   105f0:	4b17      	ldr	r3, [pc, #92]	; (10650 <Pin::SetAsAnalogMode(bool)+0x78>)
   105f2:	681b      	ldr	r3, [r3, #0]
   105f4:	9a03      	ldr	r2, [sp, #12]
   105f6:	7912      	ldrb	r2, [r2, #4]
   105f8:	4610      	mov	r0, r2
   105fa:	9a03      	ldr	r2, [sp, #12]
   105fc:	7952      	ldrb	r2, [r2, #5]
   105fe:	4611      	mov	r1, r2
   10600:	0142      	lsls	r2, r0, #5
   10602:	440a      	add	r2, r1
   10604:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !set_as_analog, 1);
   10608:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1060c:	f083 0301 	eor.w	r3, r3, #1
   10610:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   10612:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   10614:	4b0e      	ldr	r3, [pc, #56]	; (10650 <Pin::SetAsAnalogMode(bool)+0x78>)
   10616:	681c      	ldr	r4, [r3, #0]
   10618:	9b03      	ldr	r3, [sp, #12]
   1061a:	791b      	ldrb	r3, [r3, #4]
   1061c:	461e      	mov	r6, r3
   1061e:	9b03      	ldr	r3, [sp, #12]
   10620:	795b      	ldrb	r3, [r3, #5]
   10622:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   10624:	2301      	movs	r3, #1
   10626:	9300      	str	r3, [sp, #0]
   10628:	4613      	mov	r3, r2
   1062a:	2207      	movs	r2, #7
   1062c:	9803      	ldr	r0, [sp, #12]
   1062e:	f000 f975 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   10632:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10634:	0173      	lsls	r3, r6, #5
   10636:	442b      	add	r3, r5
   10638:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   1063c:	463b      	mov	r3, r7
   1063e:	4619      	mov	r1, r3
   10640:	4802      	ldr	r0, [pc, #8]	; (1064c <Pin::SetAsAnalogMode(bool)+0x74>)
   10642:	f005 f835 	bl	156b0 <__cyg_profile_func_exit>
  }
   10646:	bf00      	nop
   10648:	b005      	add	sp, #20
   1064a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1064c:	000105d9 	.word	0x000105d9
   10650:	10000000 	.word	0x10000000

00010654 <Pin::EnableDigitalFilter(bool)>:
  // Enable by setting bit to 0 to enable digital filter.
  void EnableDigitalFilter(bool enable_digital_filter = true) override
   10654:	b5f0      	push	{r4, r5, r6, r7, lr}
   10656:	b085      	sub	sp, #20
   10658:	4677      	mov	r7, lr
   1065a:	9003      	str	r0, [sp, #12]
   1065c:	460b      	mov	r3, r1
   1065e:	f88d 300b 	strb.w	r3, [sp, #11]
   10662:	463b      	mov	r3, r7
   10664:	4619      	mov	r1, r3
   10666:	4818      	ldr	r0, [pc, #96]	; (106c8 <Pin::EnableDigitalFilter(bool)+0x74>)
   10668:	f005 f80e 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   1066c:	4b17      	ldr	r3, [pc, #92]	; (106cc <Pin::EnableDigitalFilter(bool)+0x78>)
   1066e:	681b      	ldr	r3, [r3, #0]
   10670:	9a03      	ldr	r2, [sp, #12]
   10672:	7912      	ldrb	r2, [r2, #4]
   10674:	4610      	mov	r0, r2
   10676:	9a03      	ldr	r2, [sp, #12]
   10678:	7952      	ldrb	r2, [r2, #5]
   1067a:	4611      	mov	r1, r2
   1067c:	0142      	lsls	r2, r0, #5
   1067e:	440a      	add	r2, r1
   10680:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_digital_filter, 1);
   10684:	f89d 300b 	ldrb.w	r3, [sp, #11]
   10688:	f083 0301 	eor.w	r3, r3, #1
   1068c:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   1068e:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   10690:	4b0e      	ldr	r3, [pc, #56]	; (106cc <Pin::EnableDigitalFilter(bool)+0x78>)
   10692:	681c      	ldr	r4, [r3, #0]
   10694:	9b03      	ldr	r3, [sp, #12]
   10696:	791b      	ldrb	r3, [r3, #4]
   10698:	461e      	mov	r6, r3
   1069a:	9b03      	ldr	r3, [sp, #12]
   1069c:	795b      	ldrb	r3, [r3, #5]
   1069e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   106a0:	2301      	movs	r3, #1
   106a2:	9300      	str	r3, [sp, #0]
   106a4:	4613      	mov	r3, r2
   106a6:	2208      	movs	r2, #8
   106a8:	9803      	ldr	r0, [sp, #12]
   106aa:	f000 f937 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   106ae:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   106b0:	0173      	lsls	r3, r6, #5
   106b2:	442b      	add	r3, r5
   106b4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   106b8:	463b      	mov	r3, r7
   106ba:	4619      	mov	r1, r3
   106bc:	4802      	ldr	r0, [pc, #8]	; (106c8 <Pin::EnableDigitalFilter(bool)+0x74>)
   106be:	f004 fff7 	bl	156b0 <__cyg_profile_func_exit>
  }
   106c2:	bf00      	nop
   106c4:	b005      	add	sp, #20
   106c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   106c8:	00010655 	.word	0x00010655
   106cc:	10000000 	.word	0x10000000

000106d0 <Pin::EnableFastMode(bool)>:
  void EnableFastMode(bool enable_fast_mode = true) override
   106d0:	b5f0      	push	{r4, r5, r6, r7, lr}
   106d2:	b085      	sub	sp, #20
   106d4:	4677      	mov	r7, lr
   106d6:	9003      	str	r0, [sp, #12]
   106d8:	460b      	mov	r3, r1
   106da:	f88d 300b 	strb.w	r3, [sp, #11]
   106de:	463b      	mov	r3, r7
   106e0:	4619      	mov	r1, r3
   106e2:	4816      	ldr	r0, [pc, #88]	; (1073c <Pin::EnableFastMode(bool)+0x6c>)
   106e4:	f004 ffd0 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   106e8:	4b15      	ldr	r3, [pc, #84]	; (10740 <Pin::EnableFastMode(bool)+0x70>)
   106ea:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kSlew, enable_fast_mode, 1);
   106ec:	9a03      	ldr	r2, [sp, #12]
   106ee:	7912      	ldrb	r2, [r2, #4]
   106f0:	4610      	mov	r0, r2
   106f2:	9a03      	ldr	r2, [sp, #12]
   106f4:	7952      	ldrb	r2, [r2, #5]
   106f6:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   106f8:	0142      	lsls	r2, r0, #5
   106fa:	440a      	add	r2, r1
   106fc:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   10700:	f89d 200b 	ldrb.w	r2, [sp, #11]
   10704:	4b0e      	ldr	r3, [pc, #56]	; (10740 <Pin::EnableFastMode(bool)+0x70>)
   10706:	681c      	ldr	r4, [r3, #0]
   10708:	9b03      	ldr	r3, [sp, #12]
   1070a:	791b      	ldrb	r3, [r3, #4]
   1070c:	461e      	mov	r6, r3
   1070e:	9b03      	ldr	r3, [sp, #12]
   10710:	795b      	ldrb	r3, [r3, #5]
   10712:	461d      	mov	r5, r3
   10714:	2301      	movs	r3, #1
   10716:	9300      	str	r3, [sp, #0]
   10718:	4613      	mov	r3, r2
   1071a:	2209      	movs	r2, #9
   1071c:	9803      	ldr	r0, [sp, #12]
   1071e:	f000 f8fd 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   10722:	4602      	mov	r2, r0
   10724:	0173      	lsls	r3, r6, #5
   10726:	442b      	add	r3, r5
   10728:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   1072c:	463b      	mov	r3, r7
   1072e:	4619      	mov	r1, r3
   10730:	4802      	ldr	r0, [pc, #8]	; (1073c <Pin::EnableFastMode(bool)+0x6c>)
   10732:	f004 ffbd 	bl	156b0 <__cyg_profile_func_exit>
  }
   10736:	bf00      	nop
   10738:	b005      	add	sp, #20
   1073a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1073c:	000106d1 	.word	0x000106d1
   10740:	10000000 	.word	0x10000000

00010744 <Pin::EnableI2cHighSpeedMode(bool)>:
  // Enable by setting bit to 0 for i2c high speed mode
  void EnableI2cHighSpeedMode(bool enable_high_speed = true) override
   10744:	b5f0      	push	{r4, r5, r6, r7, lr}
   10746:	b085      	sub	sp, #20
   10748:	4677      	mov	r7, lr
   1074a:	9003      	str	r0, [sp, #12]
   1074c:	460b      	mov	r3, r1
   1074e:	f88d 300b 	strb.w	r3, [sp, #11]
   10752:	463b      	mov	r3, r7
   10754:	4619      	mov	r1, r3
   10756:	4818      	ldr	r0, [pc, #96]	; (107b8 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   10758:	f004 ff96 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   1075c:	4b17      	ldr	r3, [pc, #92]	; (107bc <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   1075e:	681b      	ldr	r3, [r3, #0]
   10760:	9a03      	ldr	r2, [sp, #12]
   10762:	7912      	ldrb	r2, [r2, #4]
   10764:	4610      	mov	r0, r2
   10766:	9a03      	ldr	r2, [sp, #12]
   10768:	7952      	ldrb	r2, [r2, #5]
   1076a:	4611      	mov	r1, r2
   1076c:	0142      	lsls	r2, r0, #5
   1076e:	440a      	add	r2, r1
   10770:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_high_speed, 1);
   10774:	f89d 300b 	ldrb.w	r3, [sp, #11]
   10778:	f083 0301 	eor.w	r3, r3, #1
   1077c:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   1077e:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   10780:	4b0e      	ldr	r3, [pc, #56]	; (107bc <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   10782:	681c      	ldr	r4, [r3, #0]
   10784:	9b03      	ldr	r3, [sp, #12]
   10786:	791b      	ldrb	r3, [r3, #4]
   10788:	461e      	mov	r6, r3
   1078a:	9b03      	ldr	r3, [sp, #12]
   1078c:	795b      	ldrb	r3, [r3, #5]
   1078e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   10790:	2301      	movs	r3, #1
   10792:	9300      	str	r3, [sp, #0]
   10794:	4613      	mov	r3, r2
   10796:	2208      	movs	r2, #8
   10798:	9803      	ldr	r0, [sp, #12]
   1079a:	f000 f8bf 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1079e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   107a0:	0173      	lsls	r3, r6, #5
   107a2:	442b      	add	r3, r5
   107a4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   107a8:	463b      	mov	r3, r7
   107aa:	4619      	mov	r1, r3
   107ac:	4802      	ldr	r0, [pc, #8]	; (107b8 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   107ae:	f004 ff7f 	bl	156b0 <__cyg_profile_func_exit>
  }
   107b2:	bf00      	nop
   107b4:	b005      	add	sp, #20
   107b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   107b8:	00010745 	.word	0x00010745
   107bc:	10000000 	.word	0x10000000

000107c0 <Pin::EnableI2cHighCurrentDrive(bool)>:
  void EnableI2cHighCurrentDrive(bool enable_high_current = true) override
   107c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   107c2:	b085      	sub	sp, #20
   107c4:	4677      	mov	r7, lr
   107c6:	9003      	str	r0, [sp, #12]
   107c8:	460b      	mov	r3, r1
   107ca:	f88d 300b 	strb.w	r3, [sp, #11]
   107ce:	463b      	mov	r3, r7
   107d0:	4619      	mov	r1, r3
   107d2:	4816      	ldr	r0, [pc, #88]	; (1082c <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   107d4:	f004 ff58 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_],
   107d8:	4b15      	ldr	r3, [pc, #84]	; (10830 <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   107da:	681b      	ldr	r3, [r3, #0]
   107dc:	9a03      	ldr	r2, [sp, #12]
   107de:	7912      	ldrb	r2, [r2, #4]
   107e0:	4610      	mov	r0, r2
   107e2:	9a03      	ldr	r2, [sp, #12]
   107e4:	7952      	ldrb	r2, [r2, #5]
   107e6:	4611      	mov	r1, r2
   107e8:	0142      	lsls	r2, r0, #5
   107ea:	440a      	add	r2, r1
   107ec:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   107f0:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   107f4:	4b0e      	ldr	r3, [pc, #56]	; (10830 <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   107f6:	681c      	ldr	r4, [r3, #0]
   107f8:	9b03      	ldr	r3, [sp, #12]
   107fa:	791b      	ldrb	r3, [r3, #4]
   107fc:	461e      	mov	r6, r3
   107fe:	9b03      	ldr	r3, [sp, #12]
   10800:	795b      	ldrb	r3, [r3, #5]
   10802:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_],
   10804:	2301      	movs	r3, #1
   10806:	9300      	str	r3, [sp, #0]
   10808:	4613      	mov	r3, r2
   1080a:	2209      	movs	r2, #9
   1080c:	9803      	ldr	r0, [sp, #12]
   1080e:	f000 f885 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   10812:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10814:	0173      	lsls	r3, r6, #5
   10816:	442b      	add	r3, r5
   10818:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   1081c:	463b      	mov	r3, r7
   1081e:	4619      	mov	r1, r3
   10820:	4802      	ldr	r0, [pc, #8]	; (1082c <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   10822:	f004 ff45 	bl	156b0 <__cyg_profile_func_exit>
                 PinBitMap::kI2cHighCurrentDrive, enable_high_current, 1);
  }
   10826:	bf00      	nop
   10828:	b005      	add	sp, #20
   1082a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1082c:	000107c1 	.word	0x000107c1
   10830:	10000000 	.word	0x10000000

00010834 <Pin::SetAsOpenDrain(bool)>:
  void SetAsOpenDrain(bool set_as_open_drain = true) override
   10834:	b5f0      	push	{r4, r5, r6, r7, lr}
   10836:	b085      	sub	sp, #20
   10838:	4677      	mov	r7, lr
   1083a:	9003      	str	r0, [sp, #12]
   1083c:	460b      	mov	r3, r1
   1083e:	f88d 300b 	strb.w	r3, [sp, #11]
   10842:	463b      	mov	r3, r7
   10844:	4619      	mov	r1, r3
   10846:	4816      	ldr	r0, [pc, #88]	; (108a0 <Pin::SetAsOpenDrain(bool)+0x6c>)
   10848:	f004 ff1e 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   1084c:	4b15      	ldr	r3, [pc, #84]	; (108a4 <Pin::SetAsOpenDrain(bool)+0x70>)
   1084e:	681b      	ldr	r3, [r3, #0]
   10850:	9a03      	ldr	r2, [sp, #12]
   10852:	7912      	ldrb	r2, [r2, #4]
   10854:	4610      	mov	r0, r2
   10856:	9a03      	ldr	r2, [sp, #12]
   10858:	7952      	ldrb	r2, [r2, #5]
   1085a:	4611      	mov	r1, r2
   1085c:	0142      	lsls	r2, r0, #5
   1085e:	440a      	add	r2, r1
   10860:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   10864:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   10868:	4b0e      	ldr	r3, [pc, #56]	; (108a4 <Pin::SetAsOpenDrain(bool)+0x70>)
   1086a:	681c      	ldr	r4, [r3, #0]
   1086c:	9b03      	ldr	r3, [sp, #12]
   1086e:	791b      	ldrb	r3, [r3, #4]
   10870:	461e      	mov	r6, r3
   10872:	9b03      	ldr	r3, [sp, #12]
   10874:	795b      	ldrb	r3, [r3, #5]
   10876:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   10878:	2301      	movs	r3, #1
   1087a:	9300      	str	r3, [sp, #0]
   1087c:	4613      	mov	r3, r2
   1087e:	220a      	movs	r2, #10
   10880:	9803      	ldr	r0, [sp, #12]
   10882:	f000 f84b 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   10886:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10888:	0173      	lsls	r3, r6, #5
   1088a:	442b      	add	r3, r5
   1088c:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10890:	463b      	mov	r3, r7
   10892:	4619      	mov	r1, r3
   10894:	4802      	ldr	r0, [pc, #8]	; (108a0 <Pin::SetAsOpenDrain(bool)+0x6c>)
   10896:	f004 ff0b 	bl	156b0 <__cyg_profile_func_exit>
                 set_as_open_drain, 1);
  }
   1089a:	bf00      	nop
   1089c:	b005      	add	sp, #20
   1089e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   108a0:	00010835 	.word	0x00010835
   108a4:	10000000 	.word	0x10000000

000108a8 <Pin::EnableDac(bool)>:
  void EnableDac(bool enable_dac = true) override
   108a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   108aa:	b085      	sub	sp, #20
   108ac:	4677      	mov	r7, lr
   108ae:	9003      	str	r0, [sp, #12]
   108b0:	460b      	mov	r3, r1
   108b2:	f88d 300b 	strb.w	r3, [sp, #11]
   108b6:	463b      	mov	r3, r7
   108b8:	4619      	mov	r1, r3
   108ba:	4816      	ldr	r0, [pc, #88]	; (10914 <Pin::EnableDac(bool)+0x6c>)
   108bc:	f004 fee4 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   108c0:	4b15      	ldr	r3, [pc, #84]	; (10918 <Pin::EnableDac(bool)+0x70>)
   108c2:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kDacEnable, enable_dac, 1);
   108c4:	9a03      	ldr	r2, [sp, #12]
   108c6:	7912      	ldrb	r2, [r2, #4]
   108c8:	4610      	mov	r0, r2
   108ca:	9a03      	ldr	r2, [sp, #12]
   108cc:	7952      	ldrb	r2, [r2, #5]
   108ce:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   108d0:	0142      	lsls	r2, r0, #5
   108d2:	440a      	add	r2, r1
   108d4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   108d8:	f89d 200b 	ldrb.w	r2, [sp, #11]
   108dc:	4b0e      	ldr	r3, [pc, #56]	; (10918 <Pin::EnableDac(bool)+0x70>)
   108de:	681c      	ldr	r4, [r3, #0]
   108e0:	9b03      	ldr	r3, [sp, #12]
   108e2:	791b      	ldrb	r3, [r3, #4]
   108e4:	461e      	mov	r6, r3
   108e6:	9b03      	ldr	r3, [sp, #12]
   108e8:	795b      	ldrb	r3, [r3, #5]
   108ea:	461d      	mov	r5, r3
   108ec:	2301      	movs	r3, #1
   108ee:	9300      	str	r3, [sp, #0]
   108f0:	4613      	mov	r3, r2
   108f2:	2210      	movs	r2, #16
   108f4:	9803      	ldr	r0, [sp, #12]
   108f6:	f000 f811 	bl	1091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   108fa:	4602      	mov	r2, r0
   108fc:	0173      	lsls	r3, r6, #5
   108fe:	442b      	add	r3, r5
   10900:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10904:	463b      	mov	r3, r7
   10906:	4619      	mov	r1, r3
   10908:	4802      	ldr	r0, [pc, #8]	; (10914 <Pin::EnableDac(bool)+0x6c>)
   1090a:	f004 fed1 	bl	156b0 <__cyg_profile_func_exit>
  }
   1090e:	bf00      	nop
   10910:	b005      	add	sp, #20
   10912:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10914:	000108a9 	.word	0x000108a9
   10918:	10000000 	.word	0x10000000

0001091c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>:
  inline uint32_t BitPlace(uint32_t target, uint32_t position, uint32_t value,
   1091c:	b530      	push	{r4, r5, lr}
   1091e:	b087      	sub	sp, #28
   10920:	4675      	mov	r5, lr
   10922:	9003      	str	r0, [sp, #12]
   10924:	9102      	str	r1, [sp, #8]
   10926:	9201      	str	r2, [sp, #4]
   10928:	9300      	str	r3, [sp, #0]
   1092a:	462b      	mov	r3, r5
   1092c:	4619      	mov	r1, r3
   1092e:	4813      	ldr	r0, [pc, #76]	; (1097c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   10930:	f004 feaa 	bl	15688 <__cyg_profile_func_enter>
                           uint32_t value_width)
  {
    // Generate mask with all 1s
    uint32_t mask = 0xFFFFFFFF >> (32 - value_width);
   10934:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   10936:	f1c3 0320 	rsb	r3, r3, #32
   1093a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1093e:	fa22 f303 	lsr.w	r3, r2, r3
   10942:	9305      	str	r3, [sp, #20]
    target &= ~(mask << position);
   10944:	9a05      	ldr	r2, [sp, #20]
   10946:	9b01      	ldr	r3, [sp, #4]
   10948:	fa02 f303 	lsl.w	r3, r2, r3
   1094c:	43db      	mvns	r3, r3
   1094e:	9a02      	ldr	r2, [sp, #8]
   10950:	4013      	ands	r3, r2
   10952:	9302      	str	r3, [sp, #8]
    target |= (value & mask) << position;
   10954:	9a00      	ldr	r2, [sp, #0]
   10956:	9b05      	ldr	r3, [sp, #20]
   10958:	401a      	ands	r2, r3
   1095a:	9b01      	ldr	r3, [sp, #4]
   1095c:	fa02 f303 	lsl.w	r3, r2, r3
   10960:	9a02      	ldr	r2, [sp, #8]
   10962:	4313      	orrs	r3, r2
   10964:	9302      	str	r3, [sp, #8]
    return target;
   10966:	9c02      	ldr	r4, [sp, #8]
   10968:	462b      	mov	r3, r5
   1096a:	4619      	mov	r1, r3
   1096c:	4803      	ldr	r0, [pc, #12]	; (1097c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   1096e:	f004 fe9f 	bl	156b0 <__cyg_profile_func_exit>
   10972:	4623      	mov	r3, r4
  }
   10974:	4618      	mov	r0, r3
   10976:	b007      	add	sp, #28
   10978:	bd30      	pop	{r4, r5, pc}
   1097a:	bf00      	nop
   1097c:	0001091d 	.word	0x0001091d

00010980 <Pin::GetPort() const>:
  uint8_t GetPort() const override
   10980:	b530      	push	{r4, r5, lr}
   10982:	b083      	sub	sp, #12
   10984:	4675      	mov	r5, lr
   10986:	9001      	str	r0, [sp, #4]
   10988:	462b      	mov	r3, r5
   1098a:	4619      	mov	r1, r3
   1098c:	4806      	ldr	r0, [pc, #24]	; (109a8 <Pin::GetPort() const+0x28>)
   1098e:	f004 fe7b 	bl	15688 <__cyg_profile_func_enter>
  {
    return port_;
   10992:	9b01      	ldr	r3, [sp, #4]
   10994:	791c      	ldrb	r4, [r3, #4]
   10996:	462b      	mov	r3, r5
   10998:	4619      	mov	r1, r3
   1099a:	4803      	ldr	r0, [pc, #12]	; (109a8 <Pin::GetPort() const+0x28>)
   1099c:	f004 fe88 	bl	156b0 <__cyg_profile_func_exit>
   109a0:	4623      	mov	r3, r4
  }
   109a2:	4618      	mov	r0, r3
   109a4:	b003      	add	sp, #12
   109a6:	bd30      	pop	{r4, r5, pc}
   109a8:	00010981 	.word	0x00010981

000109ac <Pin::GetPin() const>:
  uint8_t GetPin() const override
   109ac:	b530      	push	{r4, r5, lr}
   109ae:	b083      	sub	sp, #12
   109b0:	4675      	mov	r5, lr
   109b2:	9001      	str	r0, [sp, #4]
   109b4:	462b      	mov	r3, r5
   109b6:	4619      	mov	r1, r3
   109b8:	4806      	ldr	r0, [pc, #24]	; (109d4 <Pin::GetPin() const+0x28>)
   109ba:	f004 fe65 	bl	15688 <__cyg_profile_func_enter>
  {
    return pin_;
   109be:	9b01      	ldr	r3, [sp, #4]
   109c0:	795c      	ldrb	r4, [r3, #5]
   109c2:	462b      	mov	r3, r5
   109c4:	4619      	mov	r1, r3
   109c6:	4803      	ldr	r0, [pc, #12]	; (109d4 <Pin::GetPin() const+0x28>)
   109c8:	f004 fe72 	bl	156b0 <__cyg_profile_func_exit>
   109cc:	4623      	mov	r3, r4
  }
   109ce:	4618      	mov	r0, r3
   109d0:	b003      	add	sp, #12
   109d2:	bd30      	pop	{r4, r5, pc}
   109d4:	000109ad 	.word	0x000109ad

000109d8 <debug::PrintBacktrace(bool, void*)>:
}

[[gnu::no_instrument_function]]
inline void PrintBacktrace(bool show_make_command = false,
                           void * final_address   = nullptr)
{
   109d8:	b500      	push	{lr}
   109da:	b08b      	sub	sp, #44	; 0x2c
   109dc:	4603      	mov	r3, r0
   109de:	9100      	str	r1, [sp, #0]
   109e0:	f88d 3007 	strb.w	r3, [sp, #7]
  printf("Stack Depth = %zd\n", GetStackDepth());
   109e4:	f004 fe86 	bl	156f4 <GetStackDepth()>
   109e8:	4603      	mov	r3, r0
   109ea:	4619      	mov	r1, r3
   109ec:	4831      	ldr	r0, [pc, #196]	; (10ab4 <debug::PrintBacktrace(bool, void*)+0xdc>)
   109ee:	f007 fa2f 	bl	17e50 <printf>
  // stack_depth-1 to ignore PrintBacktrace()
  // PrintBacktrace shouldn't be ignored in profiling because it causes
  // the exit to still fire, which can result in a negative stack_depth
  void ** list_of_called_functions = GetStackTrace();
   109f2:	f004 fe6b 	bl	156cc <GetStackTrace()>
   109f6:	9007      	str	r0, [sp, #28]
  size_t stack_depth               = GetStackDepth();
   109f8:	f004 fe7c 	bl	156f4 <GetStackDepth()>
   109fc:	9006      	str	r0, [sp, #24]
  // Ignore the last function as it is the Backtrace function
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   109fe:	2300      	movs	r3, #0
   10a00:	9309      	str	r3, [sp, #36]	; 0x24
   10a02:	9b06      	ldr	r3, [sp, #24]
   10a04:	3b01      	subs	r3, #1
   10a06:	9a09      	ldr	r2, [sp, #36]	; 0x24
   10a08:	429a      	cmp	r2, r3
   10a0a:	d20d      	bcs.n	10a28 <debug::PrintBacktrace(bool, void*)+0x50>
  {
    printf("  #%zu: 0x%p\n", pos, list_of_called_functions[pos]);
   10a0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10a0e:	009b      	lsls	r3, r3, #2
   10a10:	9a07      	ldr	r2, [sp, #28]
   10a12:	4413      	add	r3, r2
   10a14:	681b      	ldr	r3, [r3, #0]
   10a16:	461a      	mov	r2, r3
   10a18:	9909      	ldr	r1, [sp, #36]	; 0x24
   10a1a:	4827      	ldr	r0, [pc, #156]	; (10ab8 <debug::PrintBacktrace(bool, void*)+0xe0>)
   10a1c:	f007 fa18 	bl	17e50 <printf>
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10a20:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10a22:	3301      	adds	r3, #1
   10a24:	9309      	str	r3, [sp, #36]	; 0x24
   10a26:	e7ec      	b.n	10a02 <debug::PrintBacktrace(bool, void*)+0x2a>
  }
  if (final_address != nullptr)
   10a28:	9b00      	ldr	r3, [sp, #0]
   10a2a:	2b00      	cmp	r3, #0
   10a2c:	d006      	beq.n	10a3c <debug::PrintBacktrace(bool, void*)+0x64>
  {
    printf("  #%zu: 0x%p\n", stack_depth - 1, final_address);
   10a2e:	9b06      	ldr	r3, [sp, #24]
   10a30:	3b01      	subs	r3, #1
   10a32:	9a00      	ldr	r2, [sp, #0]
   10a34:	4619      	mov	r1, r3
   10a36:	4820      	ldr	r0, [pc, #128]	; (10ab8 <debug::PrintBacktrace(bool, void*)+0xe0>)
   10a38:	f007 fa0a 	bl	17e50 <printf>
  }
  if (show_make_command)
   10a3c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   10a40:	2b00      	cmp	r3, #0
   10a42:	d033      	beq.n	10aac <debug::PrintBacktrace(bool, void*)+0xd4>
  {
    constexpr const char kBuildType[] =
   10a44:	4a1d      	ldr	r2, [pc, #116]	; (10abc <debug::PrintBacktrace(bool, void*)+0xe4>)
   10a46:	ab03      	add	r3, sp, #12
   10a48:	ca07      	ldmia	r2, {r0, r1, r2}
   10a4a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#if defined(APPLICATION)
        "application";
#else
        "bootloader";
#endif
    puts("\nRun: the following command in your project directory");
   10a4e:	481c      	ldr	r0, [pc, #112]	; (10ac0 <debug::PrintBacktrace(bool, void*)+0xe8>)
   10a50:	f004 fdea 	bl	15628 <puts>
    printf("\n  " SJ2_BOLD_WHITE "make stacktrace-%s TRACES=\"", kBuildType);
   10a54:	ab03      	add	r3, sp, #12
   10a56:	4619      	mov	r1, r3
   10a58:	481a      	ldr	r0, [pc, #104]	; (10ac4 <debug::PrintBacktrace(bool, void*)+0xec>)
   10a5a:	f007 f9f9 	bl	17e50 <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10a5e:	2300      	movs	r3, #0
   10a60:	9308      	str	r3, [sp, #32]
   10a62:	9b06      	ldr	r3, [sp, #24]
   10a64:	3b01      	subs	r3, #1
   10a66:	9a08      	ldr	r2, [sp, #32]
   10a68:	429a      	cmp	r2, r3
   10a6a:	d212      	bcs.n	10a92 <debug::PrintBacktrace(bool, void*)+0xba>
    {
      if (pos != 0)
   10a6c:	9b08      	ldr	r3, [sp, #32]
   10a6e:	2b00      	cmp	r3, #0
   10a70:	d002      	beq.n	10a78 <debug::PrintBacktrace(bool, void*)+0xa0>
      {
        putchar(' ');
   10a72:	2020      	movs	r0, #32
   10a74:	f004 fdbc 	bl	155f0 <putchar>
      }
      printf("0x%p", list_of_called_functions[pos]);
   10a78:	9b08      	ldr	r3, [sp, #32]
   10a7a:	009b      	lsls	r3, r3, #2
   10a7c:	9a07      	ldr	r2, [sp, #28]
   10a7e:	4413      	add	r3, r2
   10a80:	681b      	ldr	r3, [r3, #0]
   10a82:	4619      	mov	r1, r3
   10a84:	4810      	ldr	r0, [pc, #64]	; (10ac8 <debug::PrintBacktrace(bool, void*)+0xf0>)
   10a86:	f007 f9e3 	bl	17e50 <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10a8a:	9b08      	ldr	r3, [sp, #32]
   10a8c:	3301      	adds	r3, #1
   10a8e:	9308      	str	r3, [sp, #32]
   10a90:	e7e7      	b.n	10a62 <debug::PrintBacktrace(bool, void*)+0x8a>
    }
    if (final_address != nullptr)
   10a92:	9b00      	ldr	r3, [sp, #0]
   10a94:	2b00      	cmp	r3, #0
   10a96:	d003      	beq.n	10aa0 <debug::PrintBacktrace(bool, void*)+0xc8>
    {
      printf(" 0x%p", final_address);
   10a98:	9900      	ldr	r1, [sp, #0]
   10a9a:	480c      	ldr	r0, [pc, #48]	; (10acc <debug::PrintBacktrace(bool, void*)+0xf4>)
   10a9c:	f007 f9d8 	bl	17e50 <printf>
    }
    puts("\"\n" SJ2_COLOR_RESET);
   10aa0:	480b      	ldr	r0, [pc, #44]	; (10ad0 <debug::PrintBacktrace(bool, void*)+0xf8>)
   10aa2:	f004 fdc1 	bl	15628 <puts>
    puts(
   10aa6:	480b      	ldr	r0, [pc, #44]	; (10ad4 <debug::PrintBacktrace(bool, void*)+0xfc>)
   10aa8:	f004 fdbe 	bl	15628 <puts>
        "This will report the file and line number that led to this function "
        "being called.");
  }
}
   10aac:	bf00      	nop
   10aae:	b00b      	add	sp, #44	; 0x2c
   10ab0:	f85d fb04 	ldr.w	pc, [sp], #4
   10ab4:	00019ae8 	.word	0x00019ae8
   10ab8:	00019afc 	.word	0x00019afc
   10abc:	00019bd8 	.word	0x00019bd8
   10ac0:	00019b0c 	.word	0x00019b0c
   10ac4:	00019b44 	.word	0x00019b44
   10ac8:	00019b6c 	.word	0x00019b6c
   10acc:	00019b74 	.word	0x00019b74
   10ad0:	00019b7c 	.word	0x00019b7c
   10ad4:	00019b84 	.word	0x00019b84

00010ad8 <(anonymous namespace)::DefaultUptime()>:
{
// uptime in nanoseconds
inline uint64_t uptime = 0;
// Returns the system uptime in nanoseconds, do not use this function directly
[[gnu::always_inline]] inline uint64_t DefaultUptime()
{
   10ad8:	b570      	push	{r4, r5, r6, lr}
   10ada:	4676      	mov	r6, lr
   10adc:	4633      	mov	r3, r6
   10ade:	4619      	mov	r1, r3
   10ae0:	4807      	ldr	r0, [pc, #28]	; (10b00 <(anonymous namespace)::DefaultUptime()+0x28>)
   10ae2:	f004 fdd1 	bl	15688 <__cyg_profile_func_enter>
  return uptime;
   10ae6:	4b07      	ldr	r3, [pc, #28]	; (10b04 <(anonymous namespace)::DefaultUptime()+0x2c>)
   10ae8:	e9d3 4500 	ldrd	r4, r5, [r3]
   10aec:	4633      	mov	r3, r6
   10aee:	4619      	mov	r1, r3
   10af0:	4803      	ldr	r0, [pc, #12]	; (10b00 <(anonymous namespace)::DefaultUptime()+0x28>)
   10af2:	f004 fddd 	bl	156b0 <__cyg_profile_func_exit>
   10af6:	4623      	mov	r3, r4
   10af8:	462c      	mov	r4, r5
}
   10afa:	4618      	mov	r0, r3
   10afc:	4621      	mov	r1, r4
   10afe:	bd70      	pop	{r4, r5, r6, pc}
   10b00:	00010ad9 	.word	0x00010ad9
   10b04:	10000970 	.word	0x10000970

00010b08 <Milliseconds()>:
{
  Uptime = uptime_function;
}
// Get system uptime in milliseconds as a 64-bit integer
inline uint64_t Milliseconds()
{
   10b08:	b570      	push	{r4, r5, r6, lr}
   10b0a:	4674      	mov	r4, lr
   10b0c:	4623      	mov	r3, r4
   10b0e:	4619      	mov	r1, r3
   10b10:	480c      	ldr	r0, [pc, #48]	; (10b44 <Milliseconds()+0x3c>)
   10b12:	f004 fdb9 	bl	15688 <__cyg_profile_func_enter>
  return Uptime() / 1'000;
   10b16:	4b0c      	ldr	r3, [pc, #48]	; (10b48 <Milliseconds()+0x40>)
   10b18:	681b      	ldr	r3, [r3, #0]
   10b1a:	4798      	blx	r3
   10b1c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10b20:	f04f 0300 	mov.w	r3, #0
   10b24:	f008 fd12 	bl	1954c <__aeabi_uldivmod>
   10b28:	4602      	mov	r2, r0
   10b2a:	460b      	mov	r3, r1
   10b2c:	4615      	mov	r5, r2
   10b2e:	461e      	mov	r6, r3
   10b30:	4623      	mov	r3, r4
   10b32:	4619      	mov	r1, r3
   10b34:	4803      	ldr	r0, [pc, #12]	; (10b44 <Milliseconds()+0x3c>)
   10b36:	f004 fdbb 	bl	156b0 <__cyg_profile_func_exit>
   10b3a:	462b      	mov	r3, r5
   10b3c:	4634      	mov	r4, r6
}
   10b3e:	4618      	mov	r0, r3
   10b40:	4621      	mov	r1, r4
   10b42:	bd70      	pop	{r4, r5, r6, pc}
   10b44:	00010b09 	.word	0x00010b09
   10b48:	10000004 	.word	0x10000004

00010b4c <GpioInterface::GpioInterface()>:
#include "L0_LowLevel/LPC40xx.h"
#include "L1_Drivers/pin.hpp"
#include "utility/enum.hpp"
#include "utility/log.hpp"

class GpioInterface
   10b4c:	b530      	push	{r4, r5, lr}
   10b4e:	b083      	sub	sp, #12
   10b50:	4675      	mov	r5, lr
   10b52:	9001      	str	r0, [sp, #4]
   10b54:	462b      	mov	r3, r5
   10b56:	4619      	mov	r1, r3
   10b58:	4807      	ldr	r0, [pc, #28]	; (10b78 <GpioInterface::GpioInterface()+0x2c>)
   10b5a:	f004 fd95 	bl	15688 <__cyg_profile_func_enter>
   10b5e:	4a07      	ldr	r2, [pc, #28]	; (10b7c <GpioInterface::GpioInterface()+0x30>)
   10b60:	9b01      	ldr	r3, [sp, #4]
   10b62:	601a      	str	r2, [r3, #0]
   10b64:	9c01      	ldr	r4, [sp, #4]
   10b66:	462b      	mov	r3, r5
   10b68:	4619      	mov	r1, r3
   10b6a:	4803      	ldr	r0, [pc, #12]	; (10b78 <GpioInterface::GpioInterface()+0x2c>)
   10b6c:	f004 fda0 	bl	156b0 <__cyg_profile_func_exit>
   10b70:	4623      	mov	r3, r4
   10b72:	4618      	mov	r0, r3
   10b74:	b003      	add	sp, #12
   10b76:	bd30      	pop	{r4, r5, pc}
   10b78:	00010b4d 	.word	0x00010b4d
   10b7c:	0001a320 	.word	0x0001a320

00010b80 <Gpio::Gpio(unsigned char, unsigned char)>:
  };

  inline static volatile uint32_t * port_status = &(LPC_GPIOINT->IntStatus);

  // For port 0-4, pins 0-31 are available. Port 5 only has pins 0-4 available.
  constexpr Gpio(uint8_t port_number, uint8_t pin_number)
   10b80:	b530      	push	{r4, r5, lr}
   10b82:	b083      	sub	sp, #12
   10b84:	4675      	mov	r5, lr
   10b86:	9001      	str	r0, [sp, #4]
   10b88:	460b      	mov	r3, r1
   10b8a:	f88d 3003 	strb.w	r3, [sp, #3]
   10b8e:	4613      	mov	r3, r2
   10b90:	f88d 3002 	strb.w	r3, [sp, #2]
   10b94:	462b      	mov	r3, r5
   10b96:	4619      	mov	r1, r3
   10b98:	4816      	ldr	r0, [pc, #88]	; (10bf4 <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   10b9a:	f004 fd75 	bl	15688 <__cyg_profile_func_enter>
      : interupt_port_(false),
        pin_(&lpc40xx_pin_),
        lpc40xx_pin_(port_number, pin_number)
   10b9e:	9b01      	ldr	r3, [sp, #4]
   10ba0:	4618      	mov	r0, r3
   10ba2:	f7ff ffd3 	bl	10b4c <GpioInterface::GpioInterface()>
   10ba6:	4a14      	ldr	r2, [pc, #80]	; (10bf8 <Gpio::Gpio(unsigned char, unsigned char)+0x78>)
   10ba8:	9b01      	ldr	r3, [sp, #4]
   10baa:	601a      	str	r2, [r3, #0]
   10bac:	9b01      	ldr	r3, [sp, #4]
   10bae:	2200      	movs	r2, #0
   10bb0:	711a      	strb	r2, [r3, #4]
   10bb2:	9b01      	ldr	r3, [sp, #4]
   10bb4:	f103 020c 	add.w	r2, r3, #12
   10bb8:	9b01      	ldr	r3, [sp, #4]
   10bba:	609a      	str	r2, [r3, #8]
   10bbc:	9b01      	ldr	r3, [sp, #4]
   10bbe:	330c      	adds	r3, #12
   10bc0:	f89d 2002 	ldrb.w	r2, [sp, #2]
   10bc4:	f89d 1003 	ldrb.w	r1, [sp, #3]
   10bc8:	4618      	mov	r0, r3
   10bca:	f7ff fbe9 	bl	103a0 <Pin::Pin(unsigned char, unsigned char)>
  {
    interupt_port_ = (port_number == 2) ? 1 : 0;
   10bce:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10bd2:	2b02      	cmp	r3, #2
   10bd4:	d101      	bne.n	10bda <Gpio::Gpio(unsigned char, unsigned char)+0x5a>
   10bd6:	2201      	movs	r2, #1
   10bd8:	e000      	b.n	10bdc <Gpio::Gpio(unsigned char, unsigned char)+0x5c>
   10bda:	2200      	movs	r2, #0
   10bdc:	9b01      	ldr	r3, [sp, #4]
   10bde:	711a      	strb	r2, [r3, #4]
  }
   10be0:	9c01      	ldr	r4, [sp, #4]
   10be2:	462b      	mov	r3, r5
   10be4:	4619      	mov	r1, r3
   10be6:	4803      	ldr	r0, [pc, #12]	; (10bf4 <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   10be8:	f004 fd62 	bl	156b0 <__cyg_profile_func_exit>
   10bec:	4623      	mov	r3, r4
   10bee:	4618      	mov	r0, r3
   10bf0:	b003      	add	sp, #12
   10bf2:	bd30      	pop	{r4, r5, pc}
   10bf4:	00010b81 	.word	0x00010b81
   10bf8:	0001a2d8 	.word	0x0001a2d8

00010bfc <Gpio::SetAsInput()>:
      : interupt_port_(false), pin_(pin), lpc40xx_pin_(Pin::CreateInactivePin())
  {
    interupt_port_ = pin_->GetPort();
  }
  // Sets the GPIO pin direction as input
  void SetAsInput(void) override
   10bfc:	b530      	push	{r4, r5, lr}
   10bfe:	b083      	sub	sp, #12
   10c00:	4675      	mov	r5, lr
   10c02:	9001      	str	r0, [sp, #4]
   10c04:	462b      	mov	r3, r5
   10c06:	4619      	mov	r1, r3
   10c08:	4819      	ldr	r0, [pc, #100]	; (10c70 <Gpio::SetAsInput()+0x74>)
   10c0a:	f004 fd3d 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_->SetPinFunction(kGpioFunction);
   10c0e:	9b01      	ldr	r3, [sp, #4]
   10c10:	689a      	ldr	r2, [r3, #8]
   10c12:	9b01      	ldr	r3, [sp, #4]
   10c14:	689b      	ldr	r3, [r3, #8]
   10c16:	681b      	ldr	r3, [r3, #0]
   10c18:	681b      	ldr	r3, [r3, #0]
   10c1a:	2100      	movs	r1, #0
   10c1c:	4610      	mov	r0, r2
   10c1e:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR &= ~(1 << pin_->GetPin());
   10c20:	9b01      	ldr	r3, [sp, #4]
   10c22:	689a      	ldr	r2, [r3, #8]
   10c24:	9b01      	ldr	r3, [sp, #4]
   10c26:	689b      	ldr	r3, [r3, #8]
   10c28:	681b      	ldr	r3, [r3, #0]
   10c2a:	3330      	adds	r3, #48	; 0x30
   10c2c:	681b      	ldr	r3, [r3, #0]
   10c2e:	4610      	mov	r0, r2
   10c30:	4798      	blx	r3
   10c32:	4603      	mov	r3, r0
   10c34:	461a      	mov	r2, r3
   10c36:	2301      	movs	r3, #1
   10c38:	4093      	lsls	r3, r2
   10c3a:	43dc      	mvns	r4, r3
   10c3c:	9b01      	ldr	r3, [sp, #4]
   10c3e:	689a      	ldr	r2, [r3, #8]
   10c40:	9b01      	ldr	r3, [sp, #4]
   10c42:	689b      	ldr	r3, [r3, #8]
   10c44:	681b      	ldr	r3, [r3, #0]
   10c46:	332c      	adds	r3, #44	; 0x2c
   10c48:	681b      	ldr	r3, [r3, #0]
   10c4a:	4610      	mov	r0, r2
   10c4c:	4798      	blx	r3
   10c4e:	4603      	mov	r3, r0
   10c50:	461a      	mov	r2, r3
   10c52:	4b08      	ldr	r3, [pc, #32]	; (10c74 <Gpio::SetAsInput()+0x78>)
   10c54:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10c58:	681a      	ldr	r2, [r3, #0]
   10c5a:	4621      	mov	r1, r4
   10c5c:	400a      	ands	r2, r1
   10c5e:	601a      	str	r2, [r3, #0]
   10c60:	462b      	mov	r3, r5
   10c62:	4619      	mov	r1, r3
   10c64:	4802      	ldr	r0, [pc, #8]	; (10c70 <Gpio::SetAsInput()+0x74>)
   10c66:	f004 fd23 	bl	156b0 <__cyg_profile_func_exit>
  }
   10c6a:	bf00      	nop
   10c6c:	b003      	add	sp, #12
   10c6e:	bd30      	pop	{r4, r5, pc}
   10c70:	00010bfd 	.word	0x00010bfd
   10c74:	10000008 	.word	0x10000008

00010c78 <Gpio::SetAsOutput()>:
  // Sets the GPIO pin direction as output
  void SetAsOutput(void) override
   10c78:	b530      	push	{r4, r5, lr}
   10c7a:	b083      	sub	sp, #12
   10c7c:	4675      	mov	r5, lr
   10c7e:	9001      	str	r0, [sp, #4]
   10c80:	462b      	mov	r3, r5
   10c82:	4619      	mov	r1, r3
   10c84:	4819      	ldr	r0, [pc, #100]	; (10cec <Gpio::SetAsOutput()+0x74>)
   10c86:	f004 fcff 	bl	15688 <__cyg_profile_func_enter>
  {
    pin_->SetPinFunction(kGpioFunction);
   10c8a:	9b01      	ldr	r3, [sp, #4]
   10c8c:	689a      	ldr	r2, [r3, #8]
   10c8e:	9b01      	ldr	r3, [sp, #4]
   10c90:	689b      	ldr	r3, [r3, #8]
   10c92:	681b      	ldr	r3, [r3, #0]
   10c94:	681b      	ldr	r3, [r3, #0]
   10c96:	2100      	movs	r1, #0
   10c98:	4610      	mov	r0, r2
   10c9a:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR |= (1 << pin_->GetPin());
   10c9c:	9b01      	ldr	r3, [sp, #4]
   10c9e:	689a      	ldr	r2, [r3, #8]
   10ca0:	9b01      	ldr	r3, [sp, #4]
   10ca2:	689b      	ldr	r3, [r3, #8]
   10ca4:	681b      	ldr	r3, [r3, #0]
   10ca6:	3330      	adds	r3, #48	; 0x30
   10ca8:	681b      	ldr	r3, [r3, #0]
   10caa:	4610      	mov	r0, r2
   10cac:	4798      	blx	r3
   10cae:	4603      	mov	r3, r0
   10cb0:	461a      	mov	r2, r3
   10cb2:	2301      	movs	r3, #1
   10cb4:	fa03 f402 	lsl.w	r4, r3, r2
   10cb8:	9b01      	ldr	r3, [sp, #4]
   10cba:	689a      	ldr	r2, [r3, #8]
   10cbc:	9b01      	ldr	r3, [sp, #4]
   10cbe:	689b      	ldr	r3, [r3, #8]
   10cc0:	681b      	ldr	r3, [r3, #0]
   10cc2:	332c      	adds	r3, #44	; 0x2c
   10cc4:	681b      	ldr	r3, [r3, #0]
   10cc6:	4610      	mov	r0, r2
   10cc8:	4798      	blx	r3
   10cca:	4603      	mov	r3, r0
   10ccc:	461a      	mov	r2, r3
   10cce:	4b08      	ldr	r3, [pc, #32]	; (10cf0 <Gpio::SetAsOutput()+0x78>)
   10cd0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10cd4:	681a      	ldr	r2, [r3, #0]
   10cd6:	4621      	mov	r1, r4
   10cd8:	430a      	orrs	r2, r1
   10cda:	601a      	str	r2, [r3, #0]
   10cdc:	462b      	mov	r3, r5
   10cde:	4619      	mov	r1, r3
   10ce0:	4802      	ldr	r0, [pc, #8]	; (10cec <Gpio::SetAsOutput()+0x74>)
   10ce2:	f004 fce5 	bl	156b0 <__cyg_profile_func_exit>
  }
   10ce6:	bf00      	nop
   10ce8:	b003      	add	sp, #12
   10cea:	bd30      	pop	{r4, r5, pc}
   10cec:	00010c79 	.word	0x00010c79
   10cf0:	10000008 	.word	0x10000008

00010cf4 <Gpio::SetDirection(GpioInterface::Direction)>:
  // Sets the GPIO pin direction as output or input depending on the
  // Direction enum parameter
  inline void SetDirection(Direction direction) override
   10cf4:	b510      	push	{r4, lr}
   10cf6:	b082      	sub	sp, #8
   10cf8:	4674      	mov	r4, lr
   10cfa:	9001      	str	r0, [sp, #4]
   10cfc:	460b      	mov	r3, r1
   10cfe:	f88d 3003 	strb.w	r3, [sp, #3]
   10d02:	4623      	mov	r3, r4
   10d04:	4619      	mov	r1, r3
   10d06:	480b      	ldr	r0, [pc, #44]	; (10d34 <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   10d08:	f004 fcbe 	bl	15688 <__cyg_profile_func_enter>
  {
    (direction) ? SetAsOutput() : SetAsInput();
   10d0c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10d10:	2b00      	cmp	r3, #0
   10d12:	d003      	beq.n	10d1c <Gpio::SetDirection(GpioInterface::Direction)+0x28>
   10d14:	9801      	ldr	r0, [sp, #4]
   10d16:	f7ff ffaf 	bl	10c78 <Gpio::SetAsOutput()>
   10d1a:	e002      	b.n	10d22 <Gpio::SetDirection(GpioInterface::Direction)+0x2e>
   10d1c:	9801      	ldr	r0, [sp, #4]
   10d1e:	f7ff ff6d 	bl	10bfc <Gpio::SetAsInput()>
   10d22:	4623      	mov	r3, r4
   10d24:	4619      	mov	r1, r3
   10d26:	4803      	ldr	r0, [pc, #12]	; (10d34 <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   10d28:	f004 fcc2 	bl	156b0 <__cyg_profile_func_exit>
  }
   10d2c:	bf00      	nop
   10d2e:	b002      	add	sp, #8
   10d30:	bd10      	pop	{r4, pc}
   10d32:	bf00      	nop
   10d34:	00010cf5 	.word	0x00010cf5

00010d38 <Gpio::SetHigh()>:
  // Sets the GPIO output pin to high
  void SetHigh(void) override
   10d38:	b530      	push	{r4, r5, lr}
   10d3a:	b083      	sub	sp, #12
   10d3c:	4675      	mov	r5, lr
   10d3e:	9001      	str	r0, [sp, #4]
   10d40:	462b      	mov	r3, r5
   10d42:	4619      	mov	r1, r3
   10d44:	4813      	ldr	r0, [pc, #76]	; (10d94 <Gpio::SetHigh()+0x5c>)
   10d46:	f004 fc9f 	bl	15688 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->SET = (1 << pin_->GetPin());
   10d4a:	9b01      	ldr	r3, [sp, #4]
   10d4c:	689a      	ldr	r2, [r3, #8]
   10d4e:	9b01      	ldr	r3, [sp, #4]
   10d50:	689b      	ldr	r3, [r3, #8]
   10d52:	681b      	ldr	r3, [r3, #0]
   10d54:	3330      	adds	r3, #48	; 0x30
   10d56:	681b      	ldr	r3, [r3, #0]
   10d58:	4610      	mov	r0, r2
   10d5a:	4798      	blx	r3
   10d5c:	4603      	mov	r3, r0
   10d5e:	461a      	mov	r2, r3
   10d60:	2301      	movs	r3, #1
   10d62:	4093      	lsls	r3, r2
   10d64:	461c      	mov	r4, r3
   10d66:	9b01      	ldr	r3, [sp, #4]
   10d68:	689a      	ldr	r2, [r3, #8]
   10d6a:	9b01      	ldr	r3, [sp, #4]
   10d6c:	689b      	ldr	r3, [r3, #8]
   10d6e:	681b      	ldr	r3, [r3, #0]
   10d70:	332c      	adds	r3, #44	; 0x2c
   10d72:	681b      	ldr	r3, [r3, #0]
   10d74:	4610      	mov	r0, r2
   10d76:	4798      	blx	r3
   10d78:	4603      	mov	r3, r0
   10d7a:	461a      	mov	r2, r3
   10d7c:	4b06      	ldr	r3, [pc, #24]	; (10d98 <Gpio::SetHigh()+0x60>)
   10d7e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10d82:	619c      	str	r4, [r3, #24]
   10d84:	462b      	mov	r3, r5
   10d86:	4619      	mov	r1, r3
   10d88:	4802      	ldr	r0, [pc, #8]	; (10d94 <Gpio::SetHigh()+0x5c>)
   10d8a:	f004 fc91 	bl	156b0 <__cyg_profile_func_exit>
  }
   10d8e:	bf00      	nop
   10d90:	b003      	add	sp, #12
   10d92:	bd30      	pop	{r4, r5, pc}
   10d94:	00010d39 	.word	0x00010d39
   10d98:	10000008 	.word	0x10000008

00010d9c <Gpio::SetLow()>:
  // Sets the GPIO output pin to low
  void SetLow(void) override
   10d9c:	b530      	push	{r4, r5, lr}
   10d9e:	b083      	sub	sp, #12
   10da0:	4675      	mov	r5, lr
   10da2:	9001      	str	r0, [sp, #4]
   10da4:	462b      	mov	r3, r5
   10da6:	4619      	mov	r1, r3
   10da8:	4813      	ldr	r0, [pc, #76]	; (10df8 <Gpio::SetLow()+0x5c>)
   10daa:	f004 fc6d 	bl	15688 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->CLR = (1 << pin_->GetPin());
   10dae:	9b01      	ldr	r3, [sp, #4]
   10db0:	689a      	ldr	r2, [r3, #8]
   10db2:	9b01      	ldr	r3, [sp, #4]
   10db4:	689b      	ldr	r3, [r3, #8]
   10db6:	681b      	ldr	r3, [r3, #0]
   10db8:	3330      	adds	r3, #48	; 0x30
   10dba:	681b      	ldr	r3, [r3, #0]
   10dbc:	4610      	mov	r0, r2
   10dbe:	4798      	blx	r3
   10dc0:	4603      	mov	r3, r0
   10dc2:	461a      	mov	r2, r3
   10dc4:	2301      	movs	r3, #1
   10dc6:	4093      	lsls	r3, r2
   10dc8:	461c      	mov	r4, r3
   10dca:	9b01      	ldr	r3, [sp, #4]
   10dcc:	689a      	ldr	r2, [r3, #8]
   10dce:	9b01      	ldr	r3, [sp, #4]
   10dd0:	689b      	ldr	r3, [r3, #8]
   10dd2:	681b      	ldr	r3, [r3, #0]
   10dd4:	332c      	adds	r3, #44	; 0x2c
   10dd6:	681b      	ldr	r3, [r3, #0]
   10dd8:	4610      	mov	r0, r2
   10dda:	4798      	blx	r3
   10ddc:	4603      	mov	r3, r0
   10dde:	461a      	mov	r2, r3
   10de0:	4b06      	ldr	r3, [pc, #24]	; (10dfc <Gpio::SetLow()+0x60>)
   10de2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10de6:	61dc      	str	r4, [r3, #28]
   10de8:	462b      	mov	r3, r5
   10dea:	4619      	mov	r1, r3
   10dec:	4802      	ldr	r0, [pc, #8]	; (10df8 <Gpio::SetLow()+0x5c>)
   10dee:	f004 fc5f 	bl	156b0 <__cyg_profile_func_exit>
  }
   10df2:	bf00      	nop
   10df4:	b003      	add	sp, #12
   10df6:	bd30      	pop	{r4, r5, pc}
   10df8:	00010d9d 	.word	0x00010d9d
   10dfc:	10000008 	.word	0x10000008

00010e00 <Gpio::Set(GpioInterface::State)>:
  // Sets the GPIO output pin to high or low depending on the State enum
  // parameter
  void Set(State output = kHigh) override
   10e00:	b510      	push	{r4, lr}
   10e02:	b082      	sub	sp, #8
   10e04:	4674      	mov	r4, lr
   10e06:	9001      	str	r0, [sp, #4]
   10e08:	460b      	mov	r3, r1
   10e0a:	f88d 3003 	strb.w	r3, [sp, #3]
   10e0e:	4623      	mov	r3, r4
   10e10:	4619      	mov	r1, r3
   10e12:	480b      	ldr	r0, [pc, #44]	; (10e40 <Gpio::Set(GpioInterface::State)+0x40>)
   10e14:	f004 fc38 	bl	15688 <__cyg_profile_func_enter>
  {
    (output) ? SetHigh() : SetLow();
   10e18:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10e1c:	2b00      	cmp	r3, #0
   10e1e:	d003      	beq.n	10e28 <Gpio::Set(GpioInterface::State)+0x28>
   10e20:	9801      	ldr	r0, [sp, #4]
   10e22:	f7ff ff89 	bl	10d38 <Gpio::SetHigh()>
   10e26:	e002      	b.n	10e2e <Gpio::Set(GpioInterface::State)+0x2e>
   10e28:	9801      	ldr	r0, [sp, #4]
   10e2a:	f7ff ffb7 	bl	10d9c <Gpio::SetLow()>
   10e2e:	4623      	mov	r3, r4
   10e30:	4619      	mov	r1, r3
   10e32:	4803      	ldr	r0, [pc, #12]	; (10e40 <Gpio::Set(GpioInterface::State)+0x40>)
   10e34:	f004 fc3c 	bl	156b0 <__cyg_profile_func_exit>
  }
   10e38:	bf00      	nop
   10e3a:	b002      	add	sp, #8
   10e3c:	bd10      	pop	{r4, pc}
   10e3e:	bf00      	nop
   10e40:	00010e01 	.word	0x00010e01

00010e44 <Gpio::Toggle()>:
  // Toggle the output of a GPIO output pin
  void Toggle() override
   10e44:	b530      	push	{r4, r5, lr}
   10e46:	b083      	sub	sp, #12
   10e48:	4675      	mov	r5, lr
   10e4a:	9001      	str	r0, [sp, #4]
   10e4c:	462b      	mov	r3, r5
   10e4e:	4619      	mov	r1, r3
   10e50:	4815      	ldr	r0, [pc, #84]	; (10ea8 <Gpio::Toggle()+0x64>)
   10e52:	f004 fc19 	bl	15688 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->PIN ^= (1 << pin_->GetPin());
   10e56:	9b01      	ldr	r3, [sp, #4]
   10e58:	689a      	ldr	r2, [r3, #8]
   10e5a:	9b01      	ldr	r3, [sp, #4]
   10e5c:	689b      	ldr	r3, [r3, #8]
   10e5e:	681b      	ldr	r3, [r3, #0]
   10e60:	3330      	adds	r3, #48	; 0x30
   10e62:	681b      	ldr	r3, [r3, #0]
   10e64:	4610      	mov	r0, r2
   10e66:	4798      	blx	r3
   10e68:	4603      	mov	r3, r0
   10e6a:	461a      	mov	r2, r3
   10e6c:	2301      	movs	r3, #1
   10e6e:	fa03 f402 	lsl.w	r4, r3, r2
   10e72:	9b01      	ldr	r3, [sp, #4]
   10e74:	689a      	ldr	r2, [r3, #8]
   10e76:	9b01      	ldr	r3, [sp, #4]
   10e78:	689b      	ldr	r3, [r3, #8]
   10e7a:	681b      	ldr	r3, [r3, #0]
   10e7c:	332c      	adds	r3, #44	; 0x2c
   10e7e:	681b      	ldr	r3, [r3, #0]
   10e80:	4610      	mov	r0, r2
   10e82:	4798      	blx	r3
   10e84:	4603      	mov	r3, r0
   10e86:	461a      	mov	r2, r3
   10e88:	4b08      	ldr	r3, [pc, #32]	; (10eac <Gpio::Toggle()+0x68>)
   10e8a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10e8e:	695a      	ldr	r2, [r3, #20]
   10e90:	4621      	mov	r1, r4
   10e92:	404a      	eors	r2, r1
   10e94:	615a      	str	r2, [r3, #20]
   10e96:	462b      	mov	r3, r5
   10e98:	4619      	mov	r1, r3
   10e9a:	4803      	ldr	r0, [pc, #12]	; (10ea8 <Gpio::Toggle()+0x64>)
   10e9c:	f004 fc08 	bl	156b0 <__cyg_profile_func_exit>
  }
   10ea0:	bf00      	nop
   10ea2:	b003      	add	sp, #12
   10ea4:	bd30      	pop	{r4, r5, pc}
   10ea6:	bf00      	nop
   10ea8:	00010e45 	.word	0x00010e45
   10eac:	10000008 	.word	0x10000008

00010eb0 <Gpio::ReadState()>:
  // Returns the current State state of the pin
  State ReadState(void) override
   10eb0:	b530      	push	{r4, r5, lr}
   10eb2:	b085      	sub	sp, #20
   10eb4:	4675      	mov	r5, lr
   10eb6:	9001      	str	r0, [sp, #4]
   10eb8:	462b      	mov	r3, r5
   10eba:	4619      	mov	r1, r3
   10ebc:	4818      	ldr	r0, [pc, #96]	; (10f20 <Gpio::ReadState()+0x70>)
   10ebe:	f004 fbe3 	bl	15688 <__cyg_profile_func_enter>
  {
    bool state = (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   10ec2:	9b01      	ldr	r3, [sp, #4]
   10ec4:	689a      	ldr	r2, [r3, #8]
   10ec6:	9b01      	ldr	r3, [sp, #4]
   10ec8:	689b      	ldr	r3, [r3, #8]
   10eca:	681b      	ldr	r3, [r3, #0]
   10ecc:	332c      	adds	r3, #44	; 0x2c
   10ece:	681b      	ldr	r3, [r3, #0]
   10ed0:	4610      	mov	r0, r2
   10ed2:	4798      	blx	r3
   10ed4:	4603      	mov	r3, r0
   10ed6:	461a      	mov	r2, r3
   10ed8:	4b12      	ldr	r3, [pc, #72]	; (10f24 <Gpio::ReadState()+0x74>)
   10eda:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10ede:	695c      	ldr	r4, [r3, #20]
   10ee0:	9b01      	ldr	r3, [sp, #4]
   10ee2:	689a      	ldr	r2, [r3, #8]
   10ee4:	9b01      	ldr	r3, [sp, #4]
   10ee6:	689b      	ldr	r3, [r3, #8]
   10ee8:	681b      	ldr	r3, [r3, #0]
   10eea:	3330      	adds	r3, #48	; 0x30
   10eec:	681b      	ldr	r3, [r3, #0]
   10eee:	4610      	mov	r0, r2
   10ef0:	4798      	blx	r3
   10ef2:	4603      	mov	r3, r0
   10ef4:	fa24 f303 	lsr.w	r3, r4, r3
   10ef8:	f003 0301 	and.w	r3, r3, #1
   10efc:	2b00      	cmp	r3, #0
   10efe:	bf14      	ite	ne
   10f00:	2301      	movne	r3, #1
   10f02:	2300      	moveq	r3, #0
   10f04:	f88d 300f 	strb.w	r3, [sp, #15]
    return static_cast<State>(state);
   10f08:	f89d 400f 	ldrb.w	r4, [sp, #15]
   10f0c:	462b      	mov	r3, r5
   10f0e:	4619      	mov	r1, r3
   10f10:	4803      	ldr	r0, [pc, #12]	; (10f20 <Gpio::ReadState()+0x70>)
   10f12:	f004 fbcd 	bl	156b0 <__cyg_profile_func_exit>
   10f16:	4623      	mov	r3, r4
  }
   10f18:	4618      	mov	r0, r3
   10f1a:	b005      	add	sp, #20
   10f1c:	bd30      	pop	{r4, r5, pc}
   10f1e:	bf00      	nop
   10f20:	00010eb1 	.word	0x00010eb1
   10f24:	10000008 	.word	0x10000008

00010f28 <Gpio::Read()>:
  // Returns true if input or output pin is high
  bool Read(void) override
   10f28:	b530      	push	{r4, r5, lr}
   10f2a:	b083      	sub	sp, #12
   10f2c:	4675      	mov	r5, lr
   10f2e:	9001      	str	r0, [sp, #4]
   10f30:	462b      	mov	r3, r5
   10f32:	4619      	mov	r1, r3
   10f34:	4816      	ldr	r0, [pc, #88]	; (10f90 <Gpio::Read()+0x68>)
   10f36:	f004 fba7 	bl	15688 <__cyg_profile_func_enter>
  {
    return (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   10f3a:	9b01      	ldr	r3, [sp, #4]
   10f3c:	689a      	ldr	r2, [r3, #8]
   10f3e:	9b01      	ldr	r3, [sp, #4]
   10f40:	689b      	ldr	r3, [r3, #8]
   10f42:	681b      	ldr	r3, [r3, #0]
   10f44:	332c      	adds	r3, #44	; 0x2c
   10f46:	681b      	ldr	r3, [r3, #0]
   10f48:	4610      	mov	r0, r2
   10f4a:	4798      	blx	r3
   10f4c:	4603      	mov	r3, r0
   10f4e:	461a      	mov	r2, r3
   10f50:	4b10      	ldr	r3, [pc, #64]	; (10f94 <Gpio::Read()+0x6c>)
   10f52:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10f56:	695c      	ldr	r4, [r3, #20]
   10f58:	9b01      	ldr	r3, [sp, #4]
   10f5a:	689a      	ldr	r2, [r3, #8]
   10f5c:	9b01      	ldr	r3, [sp, #4]
   10f5e:	689b      	ldr	r3, [r3, #8]
   10f60:	681b      	ldr	r3, [r3, #0]
   10f62:	3330      	adds	r3, #48	; 0x30
   10f64:	681b      	ldr	r3, [r3, #0]
   10f66:	4610      	mov	r0, r2
   10f68:	4798      	blx	r3
   10f6a:	4603      	mov	r3, r0
   10f6c:	fa24 f303 	lsr.w	r3, r4, r3
   10f70:	f003 0301 	and.w	r3, r3, #1
   10f74:	2b00      	cmp	r3, #0
   10f76:	bf14      	ite	ne
   10f78:	2301      	movne	r3, #1
   10f7a:	2300      	moveq	r3, #0
   10f7c:	b2dc      	uxtb	r4, r3
   10f7e:	462b      	mov	r3, r5
   10f80:	4619      	mov	r1, r3
   10f82:	4803      	ldr	r0, [pc, #12]	; (10f90 <Gpio::Read()+0x68>)
   10f84:	f004 fb94 	bl	156b0 <__cyg_profile_func_exit>
   10f88:	4623      	mov	r3, r4
  }
   10f8a:	4618      	mov	r0, r3
   10f8c:	b003      	add	sp, #12
   10f8e:	bd30      	pop	{r4, r5, pc}
   10f90:	00010f29 	.word	0x00010f29
   10f94:	10000008 	.word	0x10000008

00010f98 <Gpio::GetPin()>:
  PinInterface & GetPin() override
   10f98:	b530      	push	{r4, r5, lr}
   10f9a:	b083      	sub	sp, #12
   10f9c:	4675      	mov	r5, lr
   10f9e:	9001      	str	r0, [sp, #4]
   10fa0:	462b      	mov	r3, r5
   10fa2:	4619      	mov	r1, r3
   10fa4:	4806      	ldr	r0, [pc, #24]	; (10fc0 <Gpio::GetPin()+0x28>)
   10fa6:	f004 fb6f 	bl	15688 <__cyg_profile_func_enter>
  {
    return *pin_;
   10faa:	9b01      	ldr	r3, [sp, #4]
   10fac:	689c      	ldr	r4, [r3, #8]
   10fae:	462b      	mov	r3, r5
   10fb0:	4619      	mov	r1, r3
   10fb2:	4803      	ldr	r0, [pc, #12]	; (10fc0 <Gpio::GetPin()+0x28>)
   10fb4:	f004 fb7c 	bl	156b0 <__cyg_profile_func_exit>
   10fb8:	4623      	mov	r3, r4
  }
   10fba:	4618      	mov	r0, r3
   10fbc:	b003      	add	sp, #12
   10fbe:	bd30      	pop	{r4, r5, pc}
   10fc0:	00010f99 	.word	0x00010f99

00010fc4 <Gpio::ValidPortCheck()>:

  // Checks if the selected gpio port is valid for external interrupts.
  bool ValidPortCheck()
   10fc4:	b530      	push	{r4, r5, lr}
   10fc6:	b087      	sub	sp, #28
   10fc8:	4675      	mov	r5, lr
   10fca:	9003      	str	r0, [sp, #12]
   10fcc:	462b      	mov	r3, r5
   10fce:	4619      	mov	r1, r3
   10fd0:	4817      	ldr	r0, [pc, #92]	; (11030 <Gpio::ValidPortCheck()+0x6c>)
   10fd2:	f004 fb59 	bl	15688 <__cyg_profile_func_enter>
  {
    bool is_valid = (interupt_port_ <= 1);
   10fd6:	9b03      	ldr	r3, [sp, #12]
   10fd8:	791b      	ldrb	r3, [r3, #4]
   10fda:	2b01      	cmp	r3, #1
   10fdc:	bf94      	ite	ls
   10fde:	2301      	movls	r3, #1
   10fe0:	2300      	movhi	r3, #0
   10fe2:	b2db      	uxtb	r3, r3
   10fe4:	f88d 3017 	strb.w	r3, [sp, #23]
    SJ2_ASSERT_WARNING(is_valid,
   10fe8:	f89d 3017 	ldrb.w	r3, [sp, #23]
   10fec:	f083 0301 	eor.w	r3, r3, #1
   10ff0:	b2db      	uxtb	r3, r3
   10ff2:	2b00      	cmp	r3, #0
   10ff4:	d010      	beq.n	11018 <Gpio::ValidPortCheck()+0x54>
   10ff6:	9b03      	ldr	r3, [sp, #12]
   10ff8:	689a      	ldr	r2, [r3, #8]
   10ffa:	9b03      	ldr	r3, [sp, #12]
   10ffc:	689b      	ldr	r3, [r3, #8]
   10ffe:	681b      	ldr	r3, [r3, #0]
   11000:	332c      	adds	r3, #44	; 0x2c
   11002:	681b      	ldr	r3, [r3, #0]
   11004:	4610      	mov	r0, r2
   11006:	4798      	blx	r3
   11008:	4603      	mov	r3, r0
   1100a:	9300      	str	r3, [sp, #0]
   1100c:	23a6      	movs	r3, #166	; 0xa6
   1100e:	4a09      	ldr	r2, [pc, #36]	; (11034 <Gpio::ValidPortCheck()+0x70>)
   11010:	4909      	ldr	r1, [pc, #36]	; (11038 <Gpio::ValidPortCheck()+0x74>)
   11012:	480a      	ldr	r0, [pc, #40]	; (1103c <Gpio::ValidPortCheck()+0x78>)
   11014:	f006 ff1c 	bl	17e50 <printf>
                       "Port %d cannot be used for External Interrupts. Need "
                       "to use GPIO on Port 0 or 2.",
                       pin_->GetPort());
    return is_valid;
   11018:	f89d 4017 	ldrb.w	r4, [sp, #23]
   1101c:	462b      	mov	r3, r5
   1101e:	4619      	mov	r1, r3
   11020:	4803      	ldr	r0, [pc, #12]	; (11030 <Gpio::ValidPortCheck()+0x6c>)
   11022:	f004 fb45 	bl	156b0 <__cyg_profile_func_exit>
   11026:	4623      	mov	r3, r4
  }
   11028:	4618      	mov	r0, r3
   1102a:	b007      	add	sp, #28
   1102c:	bd30      	pop	{r4, r5, pc}
   1102e:	bf00      	nop
   11030:	00010fc5 	.word	0x00010fc5
   11034:	0001a554 	.word	0x0001a554
   11038:	0001a0c8 	.word	0x0001a0c8
   1103c:	00019be4 	.word	0x00019be4

00011040 <Gpio::SetInterruptRoutine(void (*)())>:

  // Assigns the developer's ISR function to the port/pin gpio instance.
  void SetInterruptRoutine(IsrPointer function) override
   11040:	b570      	push	{r4, r5, r6, lr}
   11042:	b082      	sub	sp, #8
   11044:	4676      	mov	r6, lr
   11046:	9001      	str	r0, [sp, #4]
   11048:	9100      	str	r1, [sp, #0]
   1104a:	4633      	mov	r3, r6
   1104c:	4619      	mov	r1, r3
   1104e:	4811      	ldr	r0, [pc, #68]	; (11094 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   11050:	f004 fb1a 	bl	15688 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   11054:	9801      	ldr	r0, [sp, #4]
   11056:	f7ff ffb5 	bl	10fc4 <Gpio::ValidPortCheck()>
    interrupthandlers[interupt_port_][pin_->GetPin()] = function;
   1105a:	9c00      	ldr	r4, [sp, #0]
   1105c:	9b01      	ldr	r3, [sp, #4]
   1105e:	791b      	ldrb	r3, [r3, #4]
   11060:	461d      	mov	r5, r3
   11062:	9b01      	ldr	r3, [sp, #4]
   11064:	689a      	ldr	r2, [r3, #8]
   11066:	9b01      	ldr	r3, [sp, #4]
   11068:	689b      	ldr	r3, [r3, #8]
   1106a:	681b      	ldr	r3, [r3, #0]
   1106c:	3330      	adds	r3, #48	; 0x30
   1106e:	681b      	ldr	r3, [r3, #0]
   11070:	4610      	mov	r0, r2
   11072:	4798      	blx	r3
   11074:	4603      	mov	r3, r0
   11076:	4619      	mov	r1, r3
   11078:	4a07      	ldr	r2, [pc, #28]	; (11098 <Gpio::SetInterruptRoutine(void (*)())+0x58>)
   1107a:	016b      	lsls	r3, r5, #5
   1107c:	440b      	add	r3, r1
   1107e:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
   11082:	4633      	mov	r3, r6
   11084:	4619      	mov	r1, r3
   11086:	4803      	ldr	r0, [pc, #12]	; (11094 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   11088:	f004 fb12 	bl	156b0 <__cyg_profile_func_exit>
  }
   1108c:	bf00      	nop
   1108e:	b002      	add	sp, #8
   11090:	bd70      	pop	{r4, r5, r6, pc}
   11092:	bf00      	nop
   11094:	00011041 	.word	0x00011041
   11098:	10000978 	.word	0x10000978

0001109c <Gpio::ClearInterruptRoutine()>:

  // Clears the developers ISR function from the port/pin gio instance.
  void ClearInterruptRoutine() override
   1109c:	b530      	push	{r4, r5, lr}
   1109e:	b083      	sub	sp, #12
   110a0:	4675      	mov	r5, lr
   110a2:	9001      	str	r0, [sp, #4]
   110a4:	462b      	mov	r3, r5
   110a6:	4619      	mov	r1, r3
   110a8:	480f      	ldr	r0, [pc, #60]	; (110e8 <Gpio::ClearInterruptRoutine()+0x4c>)
   110aa:	f004 faed 	bl	15688 <__cyg_profile_func_enter>
  {
    interrupthandlers[interupt_port_][pin_->GetPin()] = nullptr;
   110ae:	9b01      	ldr	r3, [sp, #4]
   110b0:	791b      	ldrb	r3, [r3, #4]
   110b2:	461c      	mov	r4, r3
   110b4:	9b01      	ldr	r3, [sp, #4]
   110b6:	689a      	ldr	r2, [r3, #8]
   110b8:	9b01      	ldr	r3, [sp, #4]
   110ba:	689b      	ldr	r3, [r3, #8]
   110bc:	681b      	ldr	r3, [r3, #0]
   110be:	3330      	adds	r3, #48	; 0x30
   110c0:	681b      	ldr	r3, [r3, #0]
   110c2:	4610      	mov	r0, r2
   110c4:	4798      	blx	r3
   110c6:	4603      	mov	r3, r0
   110c8:	4619      	mov	r1, r3
   110ca:	4a08      	ldr	r2, [pc, #32]	; (110ec <Gpio::ClearInterruptRoutine()+0x50>)
   110cc:	0163      	lsls	r3, r4, #5
   110ce:	440b      	add	r3, r1
   110d0:	2100      	movs	r1, #0
   110d2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   110d6:	462b      	mov	r3, r5
   110d8:	4619      	mov	r1, r3
   110da:	4803      	ldr	r0, [pc, #12]	; (110e8 <Gpio::ClearInterruptRoutine()+0x4c>)
   110dc:	f004 fae8 	bl	156b0 <__cyg_profile_func_exit>
  }
   110e0:	bf00      	nop
   110e2:	b003      	add	sp, #12
   110e4:	bd30      	pop	{r4, r5, pc}
   110e6:	bf00      	nop
   110e8:	0001109d 	.word	0x0001109d
   110ec:	10000978 	.word	0x10000978

000110f0 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>:
//
// @param enum_type_value variable you would like to get the value of.
// @return the value of the enum class type variable of with the underlying
//         type of the enum class.
template <typename Enum, typename Type = typename std::underlying_type_t<Enum>>
constexpr Type Value(Enum enum_type_value)
   110f0:	b530      	push	{r4, r5, lr}
   110f2:	b083      	sub	sp, #12
   110f4:	4675      	mov	r5, lr
   110f6:	4603      	mov	r3, r0
   110f8:	f88d 3007 	strb.w	r3, [sp, #7]
   110fc:	462b      	mov	r3, r5
   110fe:	4619      	mov	r1, r3
   11100:	4806      	ldr	r0, [pc, #24]	; (1111c <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   11102:	f004 fac1 	bl	15688 <__cyg_profile_func_enter>
{
  return static_cast<Type>(enum_type_value);
   11106:	f89d 4007 	ldrb.w	r4, [sp, #7]
   1110a:	462b      	mov	r3, r5
   1110c:	4619      	mov	r1, r3
   1110e:	4803      	ldr	r0, [pc, #12]	; (1111c <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   11110:	f004 face 	bl	156b0 <__cyg_profile_func_exit>
   11114:	4623      	mov	r3, r4
}
   11116:	4618      	mov	r0, r3
   11118:	b003      	add	sp, #12
   1111a:	bd30      	pop	{r4, r5, pc}
   1111c:	000110f1 	.word	0x000110f1

00011120 <Gpio::SetInterruptEdge(GpioInterface::Edge)>:

  // Sets the selected edge that the gpio interrupt will be triggered on.
  void SetInterruptEdge(Edge edge) override
   11120:	b510      	push	{r4, lr}
   11122:	b084      	sub	sp, #16
   11124:	4674      	mov	r4, lr
   11126:	9003      	str	r0, [sp, #12]
   11128:	460b      	mov	r3, r1
   1112a:	f88d 300b 	strb.w	r3, [sp, #11]
   1112e:	4623      	mov	r3, r4
   11130:	4619      	mov	r1, r3
   11132:	4819      	ldr	r0, [pc, #100]	; (11198 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   11134:	f004 faa8 	bl	15688 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   11138:	9803      	ldr	r0, [sp, #12]
   1113a:	f7ff ff43 	bl	10fc4 <Gpio::ValidPortCheck()>
    switch (edge)
   1113e:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11142:	2b01      	cmp	r3, #1
   11144:	d008      	beq.n	11158 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x38>
   11146:	2b01      	cmp	r3, #1
   11148:	d302      	bcc.n	11150 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x30>
   1114a:	2b02      	cmp	r3, #2
   1114c:	d008      	beq.n	11160 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x40>
   1114e:	e00e      	b.n	1116e <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        SetEdgeRising();
   11150:	9803      	ldr	r0, [sp, #12]
   11152:	f000 f8b1 	bl	112b8 <Gpio::SetEdgeRising()>
        break;
   11156:	e017      	b.n	11188 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        SetEdgeFalling();
   11158:	9803      	ldr	r0, [sp, #12]
   1115a:	f000 f8eb 	bl	11334 <Gpio::SetEdgeFalling()>
        break;
   1115e:	e013      	b.n	11188 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        SetEdgeRising();
   11160:	9803      	ldr	r0, [sp, #12]
   11162:	f000 f8a9 	bl	112b8 <Gpio::SetEdgeRising()>
        SetEdgeFalling();
   11166:	9803      	ldr	r0, [sp, #12]
   11168:	f000 f8e4 	bl	11334 <Gpio::SetEdgeFalling()>
        break;
   1116c:	e00c      	b.n	11188 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   1116e:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11172:	4618      	mov	r0, r3
   11174:	f7ff ffbc 	bl	110f0 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   11178:	4603      	mov	r3, r0
   1117a:	9300      	str	r3, [sp, #0]
   1117c:	23d2      	movs	r3, #210	; 0xd2
   1117e:	4a07      	ldr	r2, [pc, #28]	; (1119c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x7c>)
   11180:	4907      	ldr	r1, [pc, #28]	; (111a0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x80>)
   11182:	4808      	ldr	r0, [pc, #32]	; (111a4 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x84>)
   11184:	f006 fe64 	bl	17e50 <printf>
   11188:	4623      	mov	r3, r4
   1118a:	4619      	mov	r1, r3
   1118c:	4802      	ldr	r0, [pc, #8]	; (11198 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   1118e:	f004 fa8f 	bl	156b0 <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
            util::Value(edge));
      }
    }
  }
   11192:	bf00      	nop
   11194:	b004      	add	sp, #16
   11196:	bd10      	pop	{r4, pc}
   11198:	00011121 	.word	0x00011121
   1119c:	0001a570 	.word	0x0001a570
   111a0:	0001a0d4 	.word	0x0001a0d4
   111a4:	00019c74 	.word	0x00019c74

000111a8 <Gpio::ClearInterruptEdge(GpioInterface::Edge)>:

  // Clears the seleted edge of the gpio interrupt from being triggered.
  void ClearInterruptEdge(Edge edge) override
   111a8:	b510      	push	{r4, lr}
   111aa:	b084      	sub	sp, #16
   111ac:	4674      	mov	r4, lr
   111ae:	9003      	str	r0, [sp, #12]
   111b0:	460b      	mov	r3, r1
   111b2:	f88d 300b 	strb.w	r3, [sp, #11]
   111b6:	4623      	mov	r3, r4
   111b8:	4619      	mov	r1, r3
   111ba:	4819      	ldr	r0, [pc, #100]	; (11220 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   111bc:	f004 fa64 	bl	15688 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   111c0:	9803      	ldr	r0, [sp, #12]
   111c2:	f7ff feff 	bl	10fc4 <Gpio::ValidPortCheck()>
    switch (edge)
   111c6:	f89d 300b 	ldrb.w	r3, [sp, #11]
   111ca:	2b01      	cmp	r3, #1
   111cc:	d008      	beq.n	111e0 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x38>
   111ce:	2b01      	cmp	r3, #1
   111d0:	d302      	bcc.n	111d8 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x30>
   111d2:	2b02      	cmp	r3, #2
   111d4:	d008      	beq.n	111e8 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x40>
   111d6:	e00e      	b.n	111f6 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        ClearEdgeRising();
   111d8:	9803      	ldr	r0, [sp, #12]
   111da:	f000 f8e9 	bl	113b0 <Gpio::ClearEdgeRising()>
        break;
   111de:	e017      	b.n	11210 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        ClearEdgeFalling();
   111e0:	9803      	ldr	r0, [sp, #12]
   111e2:	f000 f923 	bl	1142c <Gpio::ClearEdgeFalling()>
        break;
   111e6:	e013      	b.n	11210 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        ClearEdgeRising();
   111e8:	9803      	ldr	r0, [sp, #12]
   111ea:	f000 f8e1 	bl	113b0 <Gpio::ClearEdgeRising()>
        ClearEdgeFalling();
   111ee:	9803      	ldr	r0, [sp, #12]
   111f0:	f000 f91c 	bl	1142c <Gpio::ClearEdgeFalling()>
        break;
   111f4:	e00c      	b.n	11210 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   111f6:	f89d 300b 	ldrb.w	r3, [sp, #11]
   111fa:	4618      	mov	r0, r3
   111fc:	f7ff ff78 	bl	110f0 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   11200:	4603      	mov	r3, r0
   11202:	9300      	str	r3, [sp, #0]
   11204:	23f2      	movs	r3, #242	; 0xf2
   11206:	4a07      	ldr	r2, [pc, #28]	; (11224 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x7c>)
   11208:	4907      	ldr	r1, [pc, #28]	; (11228 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x80>)
   1120a:	4808      	ldr	r0, [pc, #32]	; (1122c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x84>)
   1120c:	f006 fe20 	bl	17e50 <printf>
   11210:	4623      	mov	r3, r4
   11212:	4619      	mov	r1, r3
   11214:	4802      	ldr	r0, [pc, #8]	; (11220 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   11216:	f004 fa4b 	bl	156b0 <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
           util::Value(edge));
      }
    }
  }
   1121a:	bf00      	nop
   1121c:	b004      	add	sp, #16
   1121e:	bd10      	pop	{r4, pc}
   11220:	000111a9 	.word	0x000111a9
   11224:	0001a518 	.word	0x0001a518
   11228:	0001a0e0 	.word	0x0001a0e0
   1122c:	00019c74 	.word	0x00019c74

00011230 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)>:

  // Assign the developer's ISR and sets the selected edge that the gpio
  // interrupt will be triggered on.
  void AttachInterrupt(IsrPointer function, Edge edge) override
   11230:	b510      	push	{r4, lr}
   11232:	b084      	sub	sp, #16
   11234:	4674      	mov	r4, lr
   11236:	9003      	str	r0, [sp, #12]
   11238:	9102      	str	r1, [sp, #8]
   1123a:	4613      	mov	r3, r2
   1123c:	f88d 3007 	strb.w	r3, [sp, #7]
   11240:	4623      	mov	r3, r4
   11242:	4619      	mov	r1, r3
   11244:	480b      	ldr	r0, [pc, #44]	; (11274 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   11246:	f004 fa1f 	bl	15688 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   1124a:	9803      	ldr	r0, [sp, #12]
   1124c:	f7ff feba 	bl	10fc4 <Gpio::ValidPortCheck()>
    SetInterruptRoutine(function);
   11250:	9902      	ldr	r1, [sp, #8]
   11252:	9803      	ldr	r0, [sp, #12]
   11254:	f7ff fef4 	bl	11040 <Gpio::SetInterruptRoutine(void (*)())>
    SetInterruptEdge(edge);
   11258:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1125c:	4619      	mov	r1, r3
   1125e:	9803      	ldr	r0, [sp, #12]
   11260:	f7ff ff5e 	bl	11120 <Gpio::SetInterruptEdge(GpioInterface::Edge)>
   11264:	4623      	mov	r3, r4
   11266:	4619      	mov	r1, r3
   11268:	4802      	ldr	r0, [pc, #8]	; (11274 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   1126a:	f004 fa21 	bl	156b0 <__cyg_profile_func_exit>
  }
   1126e:	bf00      	nop
   11270:	b004      	add	sp, #16
   11272:	bd10      	pop	{r4, pc}
   11274:	00011231 	.word	0x00011231

00011278 <Gpio::DetachInterrupt()>:

  // Removes the developer's ISR and clears the selected edge of the gpio
  // interrupt from being triggered.
  void DetachInterrupt() override
   11278:	b510      	push	{r4, lr}
   1127a:	b082      	sub	sp, #8
   1127c:	4674      	mov	r4, lr
   1127e:	9001      	str	r0, [sp, #4]
   11280:	4623      	mov	r3, r4
   11282:	4619      	mov	r1, r3
   11284:	480b      	ldr	r0, [pc, #44]	; (112b4 <Gpio::DetachInterrupt()+0x3c>)
   11286:	f004 f9ff 	bl	15688 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   1128a:	9801      	ldr	r0, [sp, #4]
   1128c:	f7ff fe9a 	bl	10fc4 <Gpio::ValidPortCheck()>
    ClearInterruptRoutine();
   11290:	9801      	ldr	r0, [sp, #4]
   11292:	f7ff ff03 	bl	1109c <Gpio::ClearInterruptRoutine()>
    ClearEdgeRising();
   11296:	9801      	ldr	r0, [sp, #4]
   11298:	f000 f88a 	bl	113b0 <Gpio::ClearEdgeRising()>
    ClearEdgeFalling();
   1129c:	9801      	ldr	r0, [sp, #4]
   1129e:	f000 f8c5 	bl	1142c <Gpio::ClearEdgeFalling()>
   112a2:	4623      	mov	r3, r4
   112a4:	4619      	mov	r1, r3
   112a6:	4803      	ldr	r0, [pc, #12]	; (112b4 <Gpio::DetachInterrupt()+0x3c>)
   112a8:	f004 fa02 	bl	156b0 <__cyg_profile_func_exit>
  }
   112ac:	bf00      	nop
   112ae:	b002      	add	sp, #8
   112b0:	bd10      	pop	{r4, pc}
   112b2:	bf00      	nop
   112b4:	00011279 	.word	0x00011279

000112b8 <Gpio::SetEdgeRising()>:
    *interrupt[triggered_port].clear |= (1 << triggered_pin);
  }

 private:
  // Sets the gpio interrupt to trigger on a rising edge.
  void SetEdgeRising()
   112b8:	b530      	push	{r4, r5, lr}
   112ba:	b083      	sub	sp, #12
   112bc:	4675      	mov	r5, lr
   112be:	9001      	str	r0, [sp, #4]
   112c0:	462b      	mov	r3, r5
   112c2:	4619      	mov	r1, r3
   112c4:	4819      	ldr	r0, [pc, #100]	; (1132c <Gpio::SetEdgeRising()+0x74>)
   112c6:	f004 f9df 	bl	15688 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge |= (1 << pin_->GetPin());
   112ca:	9b01      	ldr	r3, [sp, #4]
   112cc:	689a      	ldr	r2, [r3, #8]
   112ce:	9b01      	ldr	r3, [sp, #4]
   112d0:	689b      	ldr	r3, [r3, #8]
   112d2:	681b      	ldr	r3, [r3, #0]
   112d4:	3330      	adds	r3, #48	; 0x30
   112d6:	681b      	ldr	r3, [r3, #0]
   112d8:	4610      	mov	r0, r2
   112da:	4798      	blx	r3
   112dc:	4603      	mov	r3, r0
   112de:	461a      	mov	r2, r3
   112e0:	2301      	movs	r3, #1
   112e2:	fa03 f002 	lsl.w	r0, r3, r2
   112e6:	9b01      	ldr	r3, [sp, #4]
   112e8:	791b      	ldrb	r3, [r3, #4]
   112ea:	4619      	mov	r1, r3
   112ec:	4a10      	ldr	r2, [pc, #64]	; (11330 <Gpio::SetEdgeRising()+0x78>)
   112ee:	460b      	mov	r3, r1
   112f0:	009b      	lsls	r3, r3, #2
   112f2:	440b      	add	r3, r1
   112f4:	009b      	lsls	r3, r3, #2
   112f6:	4413      	add	r3, r2
   112f8:	330c      	adds	r3, #12
   112fa:	681b      	ldr	r3, [r3, #0]
   112fc:	681a      	ldr	r2, [r3, #0]
   112fe:	4604      	mov	r4, r0
   11300:	9b01      	ldr	r3, [sp, #4]
   11302:	791b      	ldrb	r3, [r3, #4]
   11304:	4618      	mov	r0, r3
   11306:	490a      	ldr	r1, [pc, #40]	; (11330 <Gpio::SetEdgeRising()+0x78>)
   11308:	4603      	mov	r3, r0
   1130a:	009b      	lsls	r3, r3, #2
   1130c:	4403      	add	r3, r0
   1130e:	009b      	lsls	r3, r3, #2
   11310:	440b      	add	r3, r1
   11312:	330c      	adds	r3, #12
   11314:	681b      	ldr	r3, [r3, #0]
   11316:	4322      	orrs	r2, r4
   11318:	601a      	str	r2, [r3, #0]
   1131a:	462b      	mov	r3, r5
   1131c:	4619      	mov	r1, r3
   1131e:	4803      	ldr	r0, [pc, #12]	; (1132c <Gpio::SetEdgeRising()+0x74>)
   11320:	f004 f9c6 	bl	156b0 <__cyg_profile_func_exit>
  }
   11324:	bf00      	nop
   11326:	b003      	add	sp, #12
   11328:	bd30      	pop	{r4, r5, pc}
   1132a:	bf00      	nop
   1132c:	000112b9 	.word	0x000112b9
   11330:	10000020 	.word	0x10000020

00011334 <Gpio::SetEdgeFalling()>:

  // Sets the gpio interrupt to trigger on a falling edge.
  void SetEdgeFalling()
   11334:	b530      	push	{r4, r5, lr}
   11336:	b083      	sub	sp, #12
   11338:	4675      	mov	r5, lr
   1133a:	9001      	str	r0, [sp, #4]
   1133c:	462b      	mov	r3, r5
   1133e:	4619      	mov	r1, r3
   11340:	4819      	ldr	r0, [pc, #100]	; (113a8 <Gpio::SetEdgeFalling()+0x74>)
   11342:	f004 f9a1 	bl	15688 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge |= (1 << pin_->GetPin());
   11346:	9b01      	ldr	r3, [sp, #4]
   11348:	689a      	ldr	r2, [r3, #8]
   1134a:	9b01      	ldr	r3, [sp, #4]
   1134c:	689b      	ldr	r3, [r3, #8]
   1134e:	681b      	ldr	r3, [r3, #0]
   11350:	3330      	adds	r3, #48	; 0x30
   11352:	681b      	ldr	r3, [r3, #0]
   11354:	4610      	mov	r0, r2
   11356:	4798      	blx	r3
   11358:	4603      	mov	r3, r0
   1135a:	461a      	mov	r2, r3
   1135c:	2301      	movs	r3, #1
   1135e:	fa03 f002 	lsl.w	r0, r3, r2
   11362:	9b01      	ldr	r3, [sp, #4]
   11364:	791b      	ldrb	r3, [r3, #4]
   11366:	4619      	mov	r1, r3
   11368:	4a10      	ldr	r2, [pc, #64]	; (113ac <Gpio::SetEdgeFalling()+0x78>)
   1136a:	460b      	mov	r3, r1
   1136c:	009b      	lsls	r3, r3, #2
   1136e:	440b      	add	r3, r1
   11370:	009b      	lsls	r3, r3, #2
   11372:	4413      	add	r3, r2
   11374:	3310      	adds	r3, #16
   11376:	681b      	ldr	r3, [r3, #0]
   11378:	681a      	ldr	r2, [r3, #0]
   1137a:	4604      	mov	r4, r0
   1137c:	9b01      	ldr	r3, [sp, #4]
   1137e:	791b      	ldrb	r3, [r3, #4]
   11380:	4618      	mov	r0, r3
   11382:	490a      	ldr	r1, [pc, #40]	; (113ac <Gpio::SetEdgeFalling()+0x78>)
   11384:	4603      	mov	r3, r0
   11386:	009b      	lsls	r3, r3, #2
   11388:	4403      	add	r3, r0
   1138a:	009b      	lsls	r3, r3, #2
   1138c:	440b      	add	r3, r1
   1138e:	3310      	adds	r3, #16
   11390:	681b      	ldr	r3, [r3, #0]
   11392:	4322      	orrs	r2, r4
   11394:	601a      	str	r2, [r3, #0]
   11396:	462b      	mov	r3, r5
   11398:	4619      	mov	r1, r3
   1139a:	4803      	ldr	r0, [pc, #12]	; (113a8 <Gpio::SetEdgeFalling()+0x74>)
   1139c:	f004 f988 	bl	156b0 <__cyg_profile_func_exit>
  }
   113a0:	bf00      	nop
   113a2:	b003      	add	sp, #12
   113a4:	bd30      	pop	{r4, r5, pc}
   113a6:	bf00      	nop
   113a8:	00011335 	.word	0x00011335
   113ac:	10000020 	.word	0x10000020

000113b0 <Gpio::ClearEdgeRising()>:

  // Clears the gpio interrupt to no longer trigger on a rising edge.
  void ClearEdgeRising()
   113b0:	b530      	push	{r4, r5, lr}
   113b2:	b083      	sub	sp, #12
   113b4:	4675      	mov	r5, lr
   113b6:	9001      	str	r0, [sp, #4]
   113b8:	462b      	mov	r3, r5
   113ba:	4619      	mov	r1, r3
   113bc:	4819      	ldr	r0, [pc, #100]	; (11424 <Gpio::ClearEdgeRising()+0x74>)
   113be:	f004 f963 	bl	15688 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge &= ~(1 << pin_->GetPin());
   113c2:	9b01      	ldr	r3, [sp, #4]
   113c4:	689a      	ldr	r2, [r3, #8]
   113c6:	9b01      	ldr	r3, [sp, #4]
   113c8:	689b      	ldr	r3, [r3, #8]
   113ca:	681b      	ldr	r3, [r3, #0]
   113cc:	3330      	adds	r3, #48	; 0x30
   113ce:	681b      	ldr	r3, [r3, #0]
   113d0:	4610      	mov	r0, r2
   113d2:	4798      	blx	r3
   113d4:	4603      	mov	r3, r0
   113d6:	461a      	mov	r2, r3
   113d8:	2301      	movs	r3, #1
   113da:	4093      	lsls	r3, r2
   113dc:	43d8      	mvns	r0, r3
   113de:	9b01      	ldr	r3, [sp, #4]
   113e0:	791b      	ldrb	r3, [r3, #4]
   113e2:	4619      	mov	r1, r3
   113e4:	4a10      	ldr	r2, [pc, #64]	; (11428 <Gpio::ClearEdgeRising()+0x78>)
   113e6:	460b      	mov	r3, r1
   113e8:	009b      	lsls	r3, r3, #2
   113ea:	440b      	add	r3, r1
   113ec:	009b      	lsls	r3, r3, #2
   113ee:	4413      	add	r3, r2
   113f0:	330c      	adds	r3, #12
   113f2:	681b      	ldr	r3, [r3, #0]
   113f4:	681a      	ldr	r2, [r3, #0]
   113f6:	4604      	mov	r4, r0
   113f8:	9b01      	ldr	r3, [sp, #4]
   113fa:	791b      	ldrb	r3, [r3, #4]
   113fc:	4618      	mov	r0, r3
   113fe:	490a      	ldr	r1, [pc, #40]	; (11428 <Gpio::ClearEdgeRising()+0x78>)
   11400:	4603      	mov	r3, r0
   11402:	009b      	lsls	r3, r3, #2
   11404:	4403      	add	r3, r0
   11406:	009b      	lsls	r3, r3, #2
   11408:	440b      	add	r3, r1
   1140a:	330c      	adds	r3, #12
   1140c:	681b      	ldr	r3, [r3, #0]
   1140e:	4022      	ands	r2, r4
   11410:	601a      	str	r2, [r3, #0]
   11412:	462b      	mov	r3, r5
   11414:	4619      	mov	r1, r3
   11416:	4803      	ldr	r0, [pc, #12]	; (11424 <Gpio::ClearEdgeRising()+0x74>)
   11418:	f004 f94a 	bl	156b0 <__cyg_profile_func_exit>
  }
   1141c:	bf00      	nop
   1141e:	b003      	add	sp, #12
   11420:	bd30      	pop	{r4, r5, pc}
   11422:	bf00      	nop
   11424:	000113b1 	.word	0x000113b1
   11428:	10000020 	.word	0x10000020

0001142c <Gpio::ClearEdgeFalling()>:

  // Clears the gpio interrupt to no longer trigger on a falling edge.
  void ClearEdgeFalling()
   1142c:	b530      	push	{r4, r5, lr}
   1142e:	b083      	sub	sp, #12
   11430:	4675      	mov	r5, lr
   11432:	9001      	str	r0, [sp, #4]
   11434:	462b      	mov	r3, r5
   11436:	4619      	mov	r1, r3
   11438:	4819      	ldr	r0, [pc, #100]	; (114a0 <Gpio::ClearEdgeFalling()+0x74>)
   1143a:	f004 f925 	bl	15688 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge &= ~(1 << pin_->GetPin());
   1143e:	9b01      	ldr	r3, [sp, #4]
   11440:	689a      	ldr	r2, [r3, #8]
   11442:	9b01      	ldr	r3, [sp, #4]
   11444:	689b      	ldr	r3, [r3, #8]
   11446:	681b      	ldr	r3, [r3, #0]
   11448:	3330      	adds	r3, #48	; 0x30
   1144a:	681b      	ldr	r3, [r3, #0]
   1144c:	4610      	mov	r0, r2
   1144e:	4798      	blx	r3
   11450:	4603      	mov	r3, r0
   11452:	461a      	mov	r2, r3
   11454:	2301      	movs	r3, #1
   11456:	4093      	lsls	r3, r2
   11458:	43d8      	mvns	r0, r3
   1145a:	9b01      	ldr	r3, [sp, #4]
   1145c:	791b      	ldrb	r3, [r3, #4]
   1145e:	4619      	mov	r1, r3
   11460:	4a10      	ldr	r2, [pc, #64]	; (114a4 <Gpio::ClearEdgeFalling()+0x78>)
   11462:	460b      	mov	r3, r1
   11464:	009b      	lsls	r3, r3, #2
   11466:	440b      	add	r3, r1
   11468:	009b      	lsls	r3, r3, #2
   1146a:	4413      	add	r3, r2
   1146c:	3310      	adds	r3, #16
   1146e:	681b      	ldr	r3, [r3, #0]
   11470:	681a      	ldr	r2, [r3, #0]
   11472:	4604      	mov	r4, r0
   11474:	9b01      	ldr	r3, [sp, #4]
   11476:	791b      	ldrb	r3, [r3, #4]
   11478:	4618      	mov	r0, r3
   1147a:	490a      	ldr	r1, [pc, #40]	; (114a4 <Gpio::ClearEdgeFalling()+0x78>)
   1147c:	4603      	mov	r3, r0
   1147e:	009b      	lsls	r3, r3, #2
   11480:	4403      	add	r3, r0
   11482:	009b      	lsls	r3, r3, #2
   11484:	440b      	add	r3, r1
   11486:	3310      	adds	r3, #16
   11488:	681b      	ldr	r3, [r3, #0]
   1148a:	4022      	ands	r2, r4
   1148c:	601a      	str	r2, [r3, #0]
   1148e:	462b      	mov	r3, r5
   11490:	4619      	mov	r1, r3
   11492:	4803      	ldr	r0, [pc, #12]	; (114a0 <Gpio::ClearEdgeFalling()+0x74>)
   11494:	f004 f90c 	bl	156b0 <__cyg_profile_func_exit>
  }
   11498:	bf00      	nop
   1149a:	b003      	add	sp, #12
   1149c:	bd30      	pop	{r4, r5, pc}
   1149e:	bf00      	nop
   114a0:	0001142d 	.word	0x0001142d
   114a4:	10000020 	.word	0x10000020

000114a8 <SystemControllerInterface::SystemControllerInterface()>:
#include "L0_LowLevel/LPC40xx.h"
#include "utility/enum.hpp"
#include "utility/log.hpp"
#include "utility/macros.hpp"

class SystemControllerInterface
   114a8:	b082      	sub	sp, #8
   114aa:	9001      	str	r0, [sp, #4]
   114ac:	4a03      	ldr	r2, [pc, #12]	; (114bc <SystemControllerInterface::SystemControllerInterface()+0x14>)
   114ae:	9b01      	ldr	r3, [sp, #4]
   114b0:	601a      	str	r2, [r3, #0]
   114b2:	9b01      	ldr	r3, [sp, #4]
   114b4:	4618      	mov	r0, r3
   114b6:	b002      	add	sp, #8
   114b8:	4770      	bx	lr
   114ba:	bf00      	nop
   114bc:	0001a2b4 	.word	0x0001a2b4

000114c0 <Lpc40xxSystemController::Lpc40xxSystemController()>:
  static constexpr uint32_t kDefaultIRCFrequency    = 12'000'000;
  static constexpr uint32_t kDefaultTimeout         = 1'000;  // ms

  inline static LPC_SC_TypeDef * system_controller = LPC_SC;

  constexpr Lpc40xxSystemController() {}
   114c0:	b500      	push	{lr}
   114c2:	b083      	sub	sp, #12
   114c4:	9001      	str	r0, [sp, #4]
   114c6:	9b01      	ldr	r3, [sp, #4]
   114c8:	4618      	mov	r0, r3
   114ca:	f7ff ffed 	bl	114a8 <SystemControllerInterface::SystemControllerInterface()>
   114ce:	4a04      	ldr	r2, [pc, #16]	; (114e0 <Lpc40xxSystemController::Lpc40xxSystemController()+0x20>)
   114d0:	9b01      	ldr	r3, [sp, #4]
   114d2:	601a      	str	r2, [r3, #0]
   114d4:	9b01      	ldr	r3, [sp, #4]
   114d6:	4618      	mov	r0, r3
   114d8:	b003      	add	sp, #12
   114da:	f85d fb04 	ldr.w	pc, [sp], #4
   114de:	bf00      	nop
   114e0:	0001a290 	.word	0x0001a290

000114e4 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>:

  uint32_t SetClockFrequency(uint8_t frequency_in_mhz) override
   114e4:	b500      	push	{lr}
   114e6:	b085      	sub	sp, #20
   114e8:	9001      	str	r0, [sp, #4]
   114ea:	460b      	mov	r3, r1
   114ec:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    uint32_t offset = 0;
   114f0:	2300      	movs	r3, #0
   114f2:	9303      	str	r3, [sp, #12]
    SelectOscillatorSource(OscillatorSource::kIrc);
   114f4:	2100      	movs	r1, #0
   114f6:	9801      	ldr	r0, [sp, #4]
   114f8:	f000 f8ce 	bl	11698 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    if (frequency_in_mhz > 12)
   114fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11500:	2b0c      	cmp	r3, #12
   11502:	d916      	bls.n	11532 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x4e>
    {
      offset = SetMainPll(PllInput::kIrc, frequency_in_mhz);
   11504:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11508:	b29b      	uxth	r3, r3
   1150a:	461a      	mov	r2, r3
   1150c:	210c      	movs	r1, #12
   1150e:	9801      	ldr	r0, [sp, #4]
   11510:	f000 f9ac 	bl	1186c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>
   11514:	9003      	str	r0, [sp, #12]
      SelectMainClockSource(MainClockSource::kPllClock);
   11516:	f44f 7180 	mov.w	r1, #256	; 0x100
   1151a:	9801      	ldr	r0, [sp, #4]
   1151c:	f000 f8d6 	bl	116cc <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = frequency_in_mhz * 1'000'000;
   11520:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11524:	4a10      	ldr	r2, [pc, #64]	; (11568 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x84>)
   11526:	fb02 f303 	mul.w	r3, r2, r3
   1152a:	461a      	mov	r2, r3
   1152c:	4b0f      	ldr	r3, [pc, #60]	; (1156c <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   1152e:	601a      	str	r2, [r3, #0]
   11530:	e006      	b.n	11540 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x5c>
    }
    else
    {
      SelectMainClockSource(MainClockSource::kBaseClock);
   11532:	2100      	movs	r1, #0
   11534:	9801      	ldr	r0, [sp, #4]
   11536:	f000 f8c9 	bl	116cc <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = kDefaultIRCFrequency;
   1153a:	4b0c      	ldr	r3, [pc, #48]	; (1156c <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   1153c:	4a0c      	ldr	r2, [pc, #48]	; (11570 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x8c>)
   1153e:	601a      	str	r2, [r3, #0]
    }
    SetCpuClockDivider(kDivideInputBy1);
   11540:	2101      	movs	r1, #1
   11542:	9801      	ldr	r0, [sp, #4]
   11544:	f000 fa4a 	bl	119dc <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>
    SetPeripheralClockDivider(kDivideInputBy1);
   11548:	9b01      	ldr	r3, [sp, #4]
   1154a:	681b      	ldr	r3, [r3, #0]
   1154c:	3304      	adds	r3, #4
   1154e:	681b      	ldr	r3, [r3, #0]
   11550:	2101      	movs	r1, #1
   11552:	9801      	ldr	r0, [sp, #4]
   11554:	4798      	blx	r3
    SetEmcClockDivider(EmcDivider::kSameSpeedAsCpu);
   11556:	2100      	movs	r1, #0
   11558:	9801      	ldr	r0, [sp, #4]
   1155a:	f000 fa73 	bl	11a44 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>
    return offset;
   1155e:	9b03      	ldr	r3, [sp, #12]
  }
   11560:	4618      	mov	r0, r3
   11562:	b005      	add	sp, #20
   11564:	f85d fb04 	ldr.w	pc, [sp], #4
   11568:	000f4240 	.word	0x000f4240
   1156c:	1000004c 	.word	0x1000004c
   11570:	00b71b00 	.word	0x00b71b00

00011574 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>:

  void SetPeripheralClockDivider(uint8_t peripheral_divider) override
   11574:	b500      	push	{lr}
   11576:	b083      	sub	sp, #12
   11578:	9001      	str	r0, [sp, #4]
   1157a:	460b      	mov	r3, r1
   1157c:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(peripheral_divider <= 4, "Divider mustn't exceed 32");
   11580:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11584:	2b04      	cmp	r3, #4
   11586:	d90d      	bls.n	115a4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x30>
   11588:	23ae      	movs	r3, #174	; 0xae
   1158a:	4a0b      	ldr	r2, [pc, #44]	; (115b8 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x44>)
   1158c:	490b      	ldr	r1, [pc, #44]	; (115bc <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x48>)
   1158e:	480c      	ldr	r0, [pc, #48]	; (115c0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x4c>)
   11590:	f006 fc5e 	bl	17e50 <printf>
   11594:	480b      	ldr	r0, [pc, #44]	; (115c4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x50>)
   11596:	f004 f847 	bl	15628 <puts>
   1159a:	2100      	movs	r1, #0
   1159c:	2001      	movs	r0, #1
   1159e:	f7ff fa1b 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   115a2:	e7fe      	b.n	115a2 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x2e>
    system_controller->PCLKSEL = peripheral_divider;
   115a4:	4b08      	ldr	r3, [pc, #32]	; (115c8 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x54>)
   115a6:	681b      	ldr	r3, [r3, #0]
   115a8:	f89d 2003 	ldrb.w	r2, [sp, #3]
   115ac:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  }
   115b0:	bf00      	nop
   115b2:	b003      	add	sp, #12
   115b4:	f85d fb04 	ldr.w	pc, [sp], #4
   115b8:	0001a3d8 	.word	0x0001a3d8
   115bc:	0001a0ec 	.word	0x0001a0ec
   115c0:	00019d14 	.word	0x00019d14
   115c4:	00019db4 	.word	0x00019db4
   115c8:	10000048 	.word	0x10000048

000115cc <Lpc40xxSystemController::GetPeripheralClockDivider() const>:

  uint32_t GetPeripheralClockDivider() const override
   115cc:	b082      	sub	sp, #8
   115ce:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return 1;
#else
    return system_controller->PCLKSEL;
   115d0:	4b03      	ldr	r3, [pc, #12]	; (115e0 <Lpc40xxSystemController::GetPeripheralClockDivider() const+0x14>)
   115d2:	681b      	ldr	r3, [r3, #0]
   115d4:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
#endif
  }
   115d8:	4618      	mov	r0, r3
   115da:	b002      	add	sp, #8
   115dc:	4770      	bx	lr
   115de:	bf00      	nop
   115e0:	10000048 	.word	0x10000048

000115e4 <Lpc40xxSystemController::GetSystemFrequency() const>:

  uint32_t GetSystemFrequency() const override
   115e4:	b082      	sub	sp, #8
   115e6:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return config::kSystemClockRate;
#else
    return speed_in_hertz;
   115e8:	4b02      	ldr	r3, [pc, #8]	; (115f4 <Lpc40xxSystemController::GetSystemFrequency() const+0x10>)
   115ea:	681b      	ldr	r3, [r3, #0]
#endif
  }
   115ec:	4618      	mov	r0, r3
   115ee:	b002      	add	sp, #8
   115f0:	4770      	bx	lr
   115f2:	bf00      	nop
   115f4:	1000004c 	.word	0x1000004c

000115f8 <Lpc40xxSystemController::GetPeripheralFrequency() const>:

  uint32_t GetPeripheralFrequency() const override
   115f8:	b500      	push	{lr}
   115fa:	b085      	sub	sp, #20
   115fc:	9001      	str	r0, [sp, #4]
  {
    uint32_t peripheral_clock_divider = GetPeripheralClockDivider();
   115fe:	9b01      	ldr	r3, [sp, #4]
   11600:	681b      	ldr	r3, [r3, #0]
   11602:	3308      	adds	r3, #8
   11604:	681b      	ldr	r3, [r3, #0]
   11606:	9801      	ldr	r0, [sp, #4]
   11608:	4798      	blx	r3
   1160a:	9002      	str	r0, [sp, #8]
    uint32_t result = 0;  // return 0 if peripheral_clock_divider == 0
   1160c:	2300      	movs	r3, #0
   1160e:	9303      	str	r3, [sp, #12]
    if (peripheral_clock_divider != 0)
   11610:	9b02      	ldr	r3, [sp, #8]
   11612:	2b00      	cmp	r3, #0
   11614:	d00a      	beq.n	1162c <Lpc40xxSystemController::GetPeripheralFrequency() const+0x34>
    {
      result = GetSystemFrequency() / peripheral_clock_divider;
   11616:	9b01      	ldr	r3, [sp, #4]
   11618:	681b      	ldr	r3, [r3, #0]
   1161a:	330c      	adds	r3, #12
   1161c:	681b      	ldr	r3, [r3, #0]
   1161e:	9801      	ldr	r0, [sp, #4]
   11620:	4798      	blx	r3
   11622:	4602      	mov	r2, r0
   11624:	9b02      	ldr	r3, [sp, #8]
   11626:	fbb2 f3f3 	udiv	r3, r2, r3
   1162a:	9303      	str	r3, [sp, #12]
    }
    return result;
   1162c:	9b03      	ldr	r3, [sp, #12]
  }
   1162e:	4618      	mov	r0, r3
   11630:	b005      	add	sp, #20
   11632:	f85d fb04 	ldr.w	pc, [sp], #4
   11636:	Address 0x0000000000011636 is out of bounds.


00011638 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>:

  void PowerUpPeripheral(const PeripheralID & peripheral_select) override
   11638:	b084      	sub	sp, #16
   1163a:	9001      	str	r0, [sp, #4]
   1163c:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_with_enabled_peripheral =
        system_controller->PCONP | (1 << peripheral_select.device_id);
   1163e:	4b09      	ldr	r3, [pc, #36]	; (11664 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11640:	681b      	ldr	r3, [r3, #0]
   11642:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   11646:	9a00      	ldr	r2, [sp, #0]
   11648:	6812      	ldr	r2, [r2, #0]
   1164a:	2101      	movs	r1, #1
   1164c:	fa01 f202 	lsl.w	r2, r1, r2
   11650:	4313      	orrs	r3, r2
   11652:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_with_enabled_peripheral;
   11654:	4b03      	ldr	r3, [pc, #12]	; (11664 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11656:	681b      	ldr	r3, [r3, #0]
   11658:	9a03      	ldr	r2, [sp, #12]
   1165a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   1165e:	bf00      	nop
   11660:	b004      	add	sp, #16
   11662:	4770      	bx	lr
   11664:	10000048 	.word	0x10000048

00011668 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)>:
  void PowerDownPeripheral(const PeripheralID & peripheral_select) override
   11668:	b084      	sub	sp, #16
   1166a:	9001      	str	r0, [sp, #4]
   1166c:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_without_enabled_peripheral =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   1166e:	4b09      	ldr	r3, [pc, #36]	; (11694 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11670:	681b      	ldr	r3, [r3, #0]
   11672:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   11676:	9a00      	ldr	r2, [sp, #0]
   11678:	6812      	ldr	r2, [r2, #0]
   1167a:	2101      	movs	r1, #1
   1167c:	fa01 f202 	lsl.w	r2, r1, r2
   11680:	4013      	ands	r3, r2
   11682:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_without_enabled_peripheral;
   11684:	4b03      	ldr	r3, [pc, #12]	; (11694 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11686:	681b      	ldr	r3, [r3, #0]
   11688:	9a03      	ldr	r2, [sp, #12]
   1168a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   1168e:	bf00      	nop
   11690:	b004      	add	sp, #16
   11692:	4770      	bx	lr
   11694:	10000048 	.word	0x10000048

00011698 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>:

 private:
  void SelectOscillatorSource(OscillatorSource source)
   11698:	b084      	sub	sp, #16
   1169a:	9001      	str	r0, [sp, #4]
   1169c:	460b      	mov	r3, r1
   1169e:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    uint32_t source_bit = static_cast<uint32_t>(source);
   116a2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   116a6:	9303      	str	r3, [sp, #12]
    system_controller->CLKSRCSEL =
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   116a8:	4b07      	ldr	r3, [pc, #28]	; (116c8 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   116aa:	681b      	ldr	r3, [r3, #0]
   116ac:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   116b0:	f023 0101 	bic.w	r1, r3, #1
    system_controller->CLKSRCSEL =
   116b4:	4b04      	ldr	r3, [pc, #16]	; (116c8 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   116b6:	681b      	ldr	r3, [r3, #0]
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   116b8:	9a03      	ldr	r2, [sp, #12]
   116ba:	430a      	orrs	r2, r1
    system_controller->CLKSRCSEL =
   116bc:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  }
   116c0:	bf00      	nop
   116c2:	b004      	add	sp, #16
   116c4:	4770      	bx	lr
   116c6:	bf00      	nop
   116c8:	10000048 	.word	0x10000048

000116cc <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>:

  void SelectMainClockSource(MainClockSource source)
   116cc:	b082      	sub	sp, #8
   116ce:	9001      	str	r0, [sp, #4]
   116d0:	460b      	mov	r3, r1
   116d2:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   116d6:	4b08      	ldr	r3, [pc, #32]	; (116f8 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   116d8:	681b      	ldr	r3, [r3, #0]
   116da:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   116de:	f423 7180 	bic.w	r1, r3, #256	; 0x100
        static_cast<uint32_t>(source);
   116e2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->CCLKSEL =
   116e6:	4b04      	ldr	r3, [pc, #16]	; (116f8 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   116e8:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   116ea:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   116ec:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   116f0:	bf00      	nop
   116f2:	b002      	add	sp, #8
   116f4:	4770      	bx	lr
   116f6:	bf00      	nop
   116f8:	10000048 	.word	0x10000048

000116fc <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>:

  void SelectUsbClockSource(UsbSource usb_clock)
   116fc:	b082      	sub	sp, #8
   116fe:	9001      	str	r0, [sp, #4]
   11700:	460b      	mov	r3, r1
   11702:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->USBCLKSEL =
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11706:	4b08      	ldr	r3, [pc, #32]	; (11728 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11708:	681b      	ldr	r3, [r3, #0]
   1170a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   1170e:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(usb_clock);
   11712:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->USBCLKSEL =
   11716:	4b04      	ldr	r3, [pc, #16]	; (11728 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11718:	681b      	ldr	r3, [r3, #0]
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   1171a:	430a      	orrs	r2, r1
    system_controller->USBCLKSEL =
   1171c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
   11720:	bf00      	nop
   11722:	b002      	add	sp, #8
   11724:	4770      	bx	lr
   11726:	bf00      	nop
   11728:	10000048 	.word	0x10000048

0001172c <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>:

  void SelectSpifiClockSource(SpifiSource spifi_clock)
   1172c:	b082      	sub	sp, #8
   1172e:	9001      	str	r0, [sp, #4]
   11730:	460b      	mov	r3, r1
   11732:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->SPIFISEL =
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   11736:	4b08      	ldr	r3, [pc, #32]	; (11758 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11738:	681b      	ldr	r3, [r3, #0]
   1173a:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
   1173e:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(spifi_clock);
   11742:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->SPIFISEL =
   11746:	4b04      	ldr	r3, [pc, #16]	; (11758 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11748:	681b      	ldr	r3, [r3, #0]
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   1174a:	430a      	orrs	r2, r1
    system_controller->SPIFISEL =
   1174c:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  }
   11750:	bf00      	nop
   11752:	b002      	add	sp, #8
   11754:	4770      	bx	lr
   11756:	bf00      	nop
   11758:	10000048 	.word	0x10000048

0001175c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t CalculatePll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   1175c:	b500      	push	{lr}
   1175e:	b087      	sub	sp, #28
   11760:	9001      	str	r0, [sp, #4]
   11762:	460b      	mov	r3, r1
   11764:	f8ad 3002 	strh.w	r3, [sp, #2]
   11768:	4613      	mov	r3, r2
   1176a:	f8ad 3000 	strh.w	r3, [sp]
  {
    SJ2_ASSERT_FATAL(desired_speed_in_mhz < 384 && desired_speed_in_mhz > 12,
   1176e:	f8bd 3000 	ldrh.w	r3, [sp]
   11772:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
   11776:	d203      	bcs.n	11780 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x24>
   11778:	f8bd 3000 	ldrh.w	r3, [sp]
   1177c:	2b0c      	cmp	r3, #12
   1177e:	d80d      	bhi.n	1179c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x40>
   11780:	23ff      	movs	r3, #255	; 0xff
   11782:	4a34      	ldr	r2, [pc, #208]	; (11854 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   11784:	4934      	ldr	r1, [pc, #208]	; (11858 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xfc>)
   11786:	4835      	ldr	r0, [pc, #212]	; (1185c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x100>)
   11788:	f006 fb62 	bl	17e50 <printf>
   1178c:	4834      	ldr	r0, [pc, #208]	; (11860 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   1178e:	f003 ff4b 	bl	15628 <puts>
   11792:	2100      	movs	r1, #0
   11794:	2001      	movs	r0, #1
   11796:	f7ff f91f 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   1179a:	e7fe      	b.n	1179a <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x3e>
                     "Frequency must be lower than 384 MHz"
                     "and greater than or equal to 12 MHz");
    bool calculating = true;
   1179c:	2301      	movs	r3, #1
   1179e:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32_t multiplier_value;
    if ((desired_speed_in_mhz % static_cast<uint16_t>(input_frequency)) >= 1)
   117a2:	f8bd 3000 	ldrh.w	r3, [sp]
   117a6:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   117aa:	fbb3 f1f2 	udiv	r1, r3, r2
   117ae:	fb02 f201 	mul.w	r2, r2, r1
   117b2:	1a9b      	subs	r3, r3, r2
   117b4:	b29b      	uxth	r3, r3
   117b6:	2b00      	cmp	r3, #0
   117b8:	d009      	beq.n	117ce <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x72>
    {
      multiplier_value = static_cast<uint32_t>(
          (desired_speed_in_mhz / static_cast<uint16_t>(input_frequency)) + 1);
   117ba:	f8bd 2000 	ldrh.w	r2, [sp]
   117be:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   117c2:	fbb2 f3f3 	udiv	r3, r2, r3
   117c6:	b29b      	uxth	r3, r3
   117c8:	3301      	adds	r3, #1
      multiplier_value = static_cast<uint32_t>(
   117ca:	9304      	str	r3, [sp, #16]
   117cc:	e007      	b.n	117de <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x82>
    }
    else
    {
      multiplier_value = static_cast<uint32_t>(
          desired_speed_in_mhz / static_cast<uint16_t>(input_frequency));
   117ce:	f8bd 2000 	ldrh.w	r2, [sp]
   117d2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   117d6:	fbb2 f3f3 	udiv	r3, r2, r3
   117da:	b29b      	uxth	r3, r3
      multiplier_value = static_cast<uint32_t>(
   117dc:	9304      	str	r3, [sp, #16]
    }
    uint16_t divider_value = 1;
   117de:	2301      	movs	r3, #1
   117e0:	f8ad 300e 	strh.w	r3, [sp, #14]
    while (calculating)
   117e4:	f89d 3017 	ldrb.w	r3, [sp, #23]
   117e8:	2b00      	cmp	r3, #0
   117ea:	d02e      	beq.n	1184a <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xee>
    {
      uint16_t current_controlled_oscillator_frequency;
      current_controlled_oscillator_frequency = static_cast<uint16_t>(
   117ec:	9b04      	ldr	r3, [sp, #16]
   117ee:	b29b      	uxth	r3, r3
   117f0:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   117f4:	fb12 f303 	smulbb	r3, r2, r3
   117f8:	b29b      	uxth	r3, r3
   117fa:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   117fe:	fb12 f303 	smulbb	r3, r2, r3
   11802:	b29b      	uxth	r3, r3
   11804:	005b      	lsls	r3, r3, #1
   11806:	f8ad 300c 	strh.w	r3, [sp, #12]
          (static_cast<uint16_t>(input_frequency) * multiplier_value * 2) *
          divider_value);
      if (current_controlled_oscillator_frequency >= 156)
   1180a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1180e:	2b9b      	cmp	r3, #155	; 0x9b
   11810:	d903      	bls.n	1181a <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xbe>
      {
        calculating = false;
   11812:	2300      	movs	r3, #0
   11814:	f88d 3017 	strb.w	r3, [sp, #23]
   11818:	e7e4      	b.n	117e4 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
      }
      else
      {
        divider_value = static_cast<uint16_t>(divider_value * 2);
   1181a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1181e:	005b      	lsls	r3, r3, #1
   11820:	f8ad 300e 	strh.w	r3, [sp, #14]
        SJ2_ASSERT_FATAL(divider_value < 8,
   11824:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   11828:	2b07      	cmp	r3, #7
   1182a:	d9db      	bls.n	117e4 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
   1182c:	f240 131b 	movw	r3, #283	; 0x11b
   11830:	4a08      	ldr	r2, [pc, #32]	; (11854 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   11832:	490c      	ldr	r1, [pc, #48]	; (11864 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x108>)
   11834:	480c      	ldr	r0, [pc, #48]	; (11868 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x10c>)
   11836:	f006 fb0b 	bl	17e50 <printf>
   1183a:	4809      	ldr	r0, [pc, #36]	; (11860 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   1183c:	f003 fef4 	bl	15628 <puts>
   11840:	2100      	movs	r1, #0
   11842:	2001      	movs	r0, #1
   11844:	f7ff f8c8 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   11848:	e7fe      	b.n	11848 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xec>
                         "PLL divider value went out of bounds");
      }
    }

    return multiplier_value;
   1184a:	9b04      	ldr	r3, [sp, #16]
  }
   1184c:	4618      	mov	r0, r3
   1184e:	b007      	add	sp, #28
   11850:	f85d fb04 	ldr.w	pc, [sp], #4
   11854:	0001a480 	.word	0x0001a480
   11858:	0001a104 	.word	0x0001a104
   1185c:	00019dcc 	.word	0x00019dcc
   11860:	00019db4 	.word	0x00019db4
   11864:	0001a11c 	.word	0x0001a11c
   11868:	00019ebc 	.word	0x00019ebc

0001186c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t SetMainPll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   1186c:	b510      	push	{r4, lr}
   1186e:	b08a      	sub	sp, #40	; 0x28
   11870:	9001      	str	r0, [sp, #4]
   11872:	460b      	mov	r3, r1
   11874:	f8ad 3002 	strh.w	r3, [sp, #2]
   11878:	4613      	mov	r3, r2
   1187a:	f8ad 3000 	strh.w	r3, [sp]
  {
    uint16_t divider_value = 1;
   1187e:	2301      	movs	r3, #1
   11880:	f8ad 301a 	strh.w	r3, [sp, #26]
    uint64_t timeout_time  = Milliseconds() + kDefaultTimeout;
   11884:	f7ff f940 	bl	10b08 <Milliseconds()>
   11888:	460a      	mov	r2, r1
   1188a:	4601      	mov	r1, r0
   1188c:	f511 737a 	adds.w	r3, r1, #1000	; 0x3e8
   11890:	f142 0400 	adc.w	r4, r2, #0
   11894:	e9cd 3404 	strd	r3, r4, [sp, #16]
    uint64_t current_time  = Milliseconds();
   11898:	f7ff f936 	bl	10b08 <Milliseconds()>
   1189c:	e9cd 0108 	strd	r0, r1, [sp, #32]
    uint32_t multiplier_value =
        CalculatePll(input_frequency, desired_speed_in_mhz);
   118a0:	f8bd 2000 	ldrh.w	r2, [sp]
   118a4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   118a8:	4619      	mov	r1, r3
   118aa:	9801      	ldr	r0, [sp, #4]
   118ac:	f7ff ff56 	bl	1175c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>
   118b0:	9003      	str	r0, [sp, #12]
    uint32_t actual_speed =
        static_cast<uint32_t>(input_frequency) * multiplier_value;
   118b2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    uint32_t actual_speed =
   118b6:	9b03      	ldr	r3, [sp, #12]
   118b8:	fb02 f303 	mul.w	r3, r2, r3
   118bc:	9307      	str	r3, [sp, #28]
    // TO DO: use registers to retreive values
    SelectOscillatorSource(OscillatorSource::kIrc);
   118be:	2100      	movs	r1, #0
   118c0:	9801      	ldr	r0, [sp, #4]
   118c2:	f7ff fee9 	bl	11698 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    SelectMainClockSource(MainClockSource::kBaseClock);
   118c6:	2100      	movs	r1, #0
   118c8:	9801      	ldr	r0, [sp, #4]
   118ca:	f7ff feff 	bl	116cc <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
    SelectUsbClockSource(UsbSource::kBaseClock);
   118ce:	2100      	movs	r1, #0
   118d0:	9801      	ldr	r0, [sp, #4]
   118d2:	f7ff ff13 	bl	116fc <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>
    SelectSpifiClockSource(SpifiSource::kBaseClock);
   118d6:	2100      	movs	r1, #0
   118d8:	9801      	ldr	r0, [sp, #4]
   118da:	f7ff ff27 	bl	1172c <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>
    // must subtract 1 from multiplier value as specified in datasheet
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   118de:	4b3a      	ldr	r3, [pc, #232]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   118e0:	681b      	ldr	r3, [r3, #0]
   118e2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   118e6:	f023 011f 	bic.w	r1, r3, #31
        (multiplier_value - 1);
   118ea:	9b03      	ldr	r3, [sp, #12]
   118ec:	1e5a      	subs	r2, r3, #1
    system_controller->PLL0CFG =
   118ee:	4b36      	ldr	r3, [pc, #216]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   118f0:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   118f2:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   118f4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   118f8:	4b33      	ldr	r3, [pc, #204]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   118fa:	681b      	ldr	r3, [r3, #0]
   118fc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   11900:	f023 0260 	bic.w	r2, r3, #96	; 0x60
   11904:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   11908:	015b      	lsls	r3, r3, #5
   1190a:	4619      	mov	r1, r3
    system_controller->PLL0CFG =
   1190c:	4b2e      	ldr	r3, [pc, #184]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1190e:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   11910:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   11912:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CON |= kEnablePll;
   11916:	4b2c      	ldr	r3, [pc, #176]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11918:	681b      	ldr	r3, [r3, #0]
   1191a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   1191e:	4b2a      	ldr	r3, [pc, #168]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11920:	681b      	ldr	r3, [r3, #0]
   11922:	f042 0201 	orr.w	r2, r2, #1
   11926:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // nessecary feed sequence to ensure the changes are intentional
    system_controller->PLL0FEED = 0xAA;
   1192a:	4b27      	ldr	r3, [pc, #156]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1192c:	681b      	ldr	r3, [r3, #0]
   1192e:	22aa      	movs	r2, #170	; 0xaa
   11930:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    system_controller->PLL0FEED = 0x55;
   11934:	4b24      	ldr	r3, [pc, #144]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11936:	681b      	ldr	r3, [r3, #0]
   11938:	2255      	movs	r2, #85	; 0x55
   1193a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   1193e:	4b22      	ldr	r3, [pc, #136]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11940:	681b      	ldr	r3, [r3, #0]
   11942:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11946:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1194a:	2b00      	cmp	r3, #0
   1194c:	d109      	bne.n	11962 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   1194e:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   11952:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   11956:	42a2      	cmp	r2, r4
   11958:	bf08      	it	eq
   1195a:	4299      	cmpeq	r1, r3
   1195c:	d201      	bcs.n	11962 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   1195e:	2301      	movs	r3, #1
   11960:	e000      	b.n	11964 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>
   11962:	2300      	movs	r3, #0
   11964:	2b00      	cmp	r3, #0
   11966:	d004      	beq.n	11972 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x106>
           (current_time < timeout_time))
    {
      current_time = Milliseconds();
   11968:	f7ff f8ce 	bl	10b08 <Milliseconds()>
   1196c:	e9cd 0108 	strd	r0, r1, [sp, #32]
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11970:	e7e5      	b.n	1193e <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xd2>
    }
    if (!(system_controller->PLL0STAT >> kPlock & 1) &&
   11972:	4b15      	ldr	r3, [pc, #84]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11974:	681b      	ldr	r3, [r3, #0]
   11976:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   1197a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1197e:	2b00      	cmp	r3, #0
   11980:	d109      	bne.n	11996 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   11982:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   11986:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   1198a:	42a2      	cmp	r2, r4
   1198c:	bf08      	it	eq
   1198e:	4299      	cmpeq	r1, r3
   11990:	d301      	bcc.n	11996 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   11992:	2301      	movs	r3, #1
   11994:	e000      	b.n	11998 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12c>
   11996:	2300      	movs	r3, #0
   11998:	2b00      	cmp	r3, #0
   1199a:	d00e      	beq.n	119ba <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14e>
        (current_time >= timeout_time))
    {
      SJ2_ASSERT_FATAL(false,
   1199c:	f240 1343 	movw	r3, #323	; 0x143
   119a0:	4a0a      	ldr	r2, [pc, #40]	; (119cc <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x160>)
   119a2:	490b      	ldr	r1, [pc, #44]	; (119d0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x164>)
   119a4:	480b      	ldr	r0, [pc, #44]	; (119d4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x168>)
   119a6:	f006 fa53 	bl	17e50 <printf>
   119aa:	480b      	ldr	r0, [pc, #44]	; (119d8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x16c>)
   119ac:	f003 fe3c 	bl	15628 <puts>
   119b0:	2100      	movs	r1, #0
   119b2:	2001      	movs	r0, #1
   119b4:	f7ff f810 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   119b8:	e7fe      	b.n	119b8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14c>
                       "PLL lock could not be established before timeout");
      actual_speed = kDefaultIRCFrequency;
    }
    return (actual_speed - desired_speed_in_mhz);
   119ba:	f8bd 3000 	ldrh.w	r3, [sp]
   119be:	9a07      	ldr	r2, [sp, #28]
   119c0:	1ad3      	subs	r3, r2, r3
  }
   119c2:	4618      	mov	r0, r3
   119c4:	b00a      	add	sp, #40	; 0x28
   119c6:	bd10      	pop	{r4, pc}
   119c8:	10000048 	.word	0x10000048
   119cc:	0001a424 	.word	0x0001a424
   119d0:	0001a134 	.word	0x0001a134
   119d4:	00019f64 	.word	0x00019f64
   119d8:	00019db4 	.word	0x00019db4

000119dc <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>:
                       "PLL lock could not be established before timeout");
    }
    return (actual_speed - desired_speed_in_mhz);
  }

  void SetCpuClockDivider(uint8_t cpu_divider)
   119dc:	b500      	push	{lr}
   119de:	b083      	sub	sp, #12
   119e0:	9001      	str	r0, [sp, #4]
   119e2:	460b      	mov	r3, r1
   119e4:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(cpu_divider < 32, "Divider mustn't exceed 32");
   119e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
   119ec:	2b1f      	cmp	r3, #31
   119ee:	d90e      	bls.n	11a0e <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x32>
   119f0:	f240 136f 	movw	r3, #367	; 0x16f
   119f4:	4a0e      	ldr	r2, [pc, #56]	; (11a30 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x54>)
   119f6:	490f      	ldr	r1, [pc, #60]	; (11a34 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x58>)
   119f8:	480f      	ldr	r0, [pc, #60]	; (11a38 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x5c>)
   119fa:	f006 fa29 	bl	17e50 <printf>
   119fe:	480f      	ldr	r0, [pc, #60]	; (11a3c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x60>)
   11a00:	f003 fe12 	bl	15628 <puts>
   11a04:	2100      	movs	r1, #0
   11a06:	2001      	movs	r0, #1
   11a08:	f7fe ffe6 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   11a0c:	e7fe      	b.n	11a0c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x30>
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11a0e:	4b0c      	ldr	r3, [pc, #48]	; (11a40 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11a10:	681b      	ldr	r3, [r3, #0]
   11a12:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   11a16:	f023 011f 	bic.w	r1, r3, #31
   11a1a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->CCLKSEL =
   11a1e:	4b08      	ldr	r3, [pc, #32]	; (11a40 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11a20:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11a22:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11a24:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   11a28:	bf00      	nop
   11a2a:	b003      	add	sp, #12
   11a2c:	f85d fb04 	ldr.w	pc, [sp], #4
   11a30:	0001a4dc 	.word	0x0001a4dc
   11a34:	0001a14c 	.word	0x0001a14c
   11a38:	0001a00c 	.word	0x0001a00c
   11a3c:	00019db4 	.word	0x00019db4
   11a40:	10000048 	.word	0x10000048

00011a44 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>:

  void SetEmcClockDivider(EmcDivider emc_divider)
   11a44:	b082      	sub	sp, #8
   11a46:	9001      	str	r0, [sp, #4]
   11a48:	460b      	mov	r3, r1
   11a4a:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    system_controller->EMCCLKSEL =
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11a4e:	4b08      	ldr	r3, [pc, #32]	; (11a70 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   11a50:	681b      	ldr	r3, [r3, #0]
   11a52:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   11a56:	f023 0101 	bic.w	r1, r3, #1
        static_cast<uint8_t>(emc_divider);
   11a5a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->EMCCLKSEL =
   11a5e:	4b04      	ldr	r3, [pc, #16]	; (11a70 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   11a60:	681b      	ldr	r3, [r3, #0]
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11a62:	430a      	orrs	r2, r1
    system_controller->EMCCLKSEL =
   11a64:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
   11a68:	bf00      	nop
   11a6a:	b002      	add	sp, #8
   11a6c:	4770      	bx	lr
   11a6e:	bf00      	nop
   11a70:	10000048 	.word	0x10000048

00011a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>:
constexpr Type Value(Enum enum_type_value)
   11a74:	b530      	push	{r4, r5, lr}
   11a76:	b083      	sub	sp, #12
   11a78:	4675      	mov	r5, lr
   11a7a:	9001      	str	r0, [sp, #4]
   11a7c:	462b      	mov	r3, r5
   11a7e:	4619      	mov	r1, r3
   11a80:	4806      	ldr	r0, [pc, #24]	; (11a9c <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   11a82:	f003 fe01 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11a86:	9c01      	ldr	r4, [sp, #4]
   11a88:	462b      	mov	r3, r5
   11a8a:	4619      	mov	r1, r3
   11a8c:	4803      	ldr	r0, [pc, #12]	; (11a9c <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   11a8e:	f003 fe0f 	bl	156b0 <__cyg_profile_func_exit>
   11a92:	4623      	mov	r3, r4
}
   11a94:	4618      	mov	r0, r3
   11a96:	b003      	add	sp, #12
   11a98:	bd30      	pop	{r4, r5, pc}
   11a9a:	bf00      	nop
   11a9c:	00011a75 	.word	0x00011a75

00011aa0 <SspInterface::SspInterface()>:
#include "L0_LowLevel/system_controller.hpp"
#include "L1_Drivers/pin.hpp"
#include "utility/bit.hpp"
#include "utility/enum.hpp"

class SspInterface
   11aa0:	b530      	push	{r4, r5, lr}
   11aa2:	b083      	sub	sp, #12
   11aa4:	4675      	mov	r5, lr
   11aa6:	9001      	str	r0, [sp, #4]
   11aa8:	462b      	mov	r3, r5
   11aaa:	4619      	mov	r1, r3
   11aac:	4807      	ldr	r0, [pc, #28]	; (11acc <SspInterface::SspInterface()+0x2c>)
   11aae:	f003 fdeb 	bl	15688 <__cyg_profile_func_enter>
   11ab2:	4a07      	ldr	r2, [pc, #28]	; (11ad0 <SspInterface::SspInterface()+0x30>)
   11ab4:	9b01      	ldr	r3, [sp, #4]
   11ab6:	601a      	str	r2, [r3, #0]
   11ab8:	9c01      	ldr	r4, [sp, #4]
   11aba:	462b      	mov	r3, r5
   11abc:	4619      	mov	r1, r3
   11abe:	4803      	ldr	r0, [pc, #12]	; (11acc <SspInterface::SspInterface()+0x2c>)
   11ac0:	f003 fdf6 	bl	156b0 <__cyg_profile_func_exit>
   11ac4:	4623      	mov	r3, r4
   11ac6:	4618      	mov	r0, r3
   11ac8:	b003      	add	sp, #12
   11aca:	bd30      	pop	{r4, r5, pc}
   11acc:	00011aa1 	.word	0x00011aa1
   11ad0:	0001a268 	.word	0x0001a268

00011ad4 <PinInterface::PinInterface(PinInterface const&)>:
class PinInterface
   11ad4:	b530      	push	{r4, r5, lr}
   11ad6:	b083      	sub	sp, #12
   11ad8:	4675      	mov	r5, lr
   11ada:	9001      	str	r0, [sp, #4]
   11adc:	9100      	str	r1, [sp, #0]
   11ade:	462b      	mov	r3, r5
   11ae0:	4619      	mov	r1, r3
   11ae2:	4808      	ldr	r0, [pc, #32]	; (11b04 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   11ae4:	f003 fdd0 	bl	15688 <__cyg_profile_func_enter>
   11ae8:	4a07      	ldr	r2, [pc, #28]	; (11b08 <PinInterface::PinInterface(PinInterface const&)+0x34>)
   11aea:	9b01      	ldr	r3, [sp, #4]
   11aec:	601a      	str	r2, [r3, #0]
   11aee:	9c01      	ldr	r4, [sp, #4]
   11af0:	462b      	mov	r3, r5
   11af2:	4619      	mov	r1, r3
   11af4:	4803      	ldr	r0, [pc, #12]	; (11b04 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   11af6:	f003 fddb 	bl	156b0 <__cyg_profile_func_exit>
   11afa:	4623      	mov	r3, r4
   11afc:	4618      	mov	r0, r3
   11afe:	b003      	add	sp, #12
   11b00:	bd30      	pop	{r4, r5, pc}
   11b02:	bf00      	nop
   11b04:	00011ad5 	.word	0x00011ad5
   11b08:	0001a3a4 	.word	0x0001a3a4

00011b0c <Pin::Pin(Pin const&)>:
class Pin : public PinInterface
   11b0c:	b530      	push	{r4, r5, lr}
   11b0e:	b083      	sub	sp, #12
   11b10:	4675      	mov	r5, lr
   11b12:	9001      	str	r0, [sp, #4]
   11b14:	9100      	str	r1, [sp, #0]
   11b16:	462b      	mov	r3, r5
   11b18:	4619      	mov	r1, r3
   11b1a:	480f      	ldr	r0, [pc, #60]	; (11b58 <Pin::Pin(Pin const&)+0x4c>)
   11b1c:	f003 fdb4 	bl	15688 <__cyg_profile_func_enter>
   11b20:	9b01      	ldr	r3, [sp, #4]
   11b22:	9a00      	ldr	r2, [sp, #0]
   11b24:	4611      	mov	r1, r2
   11b26:	4618      	mov	r0, r3
   11b28:	f7ff ffd4 	bl	11ad4 <PinInterface::PinInterface(PinInterface const&)>
   11b2c:	4a0b      	ldr	r2, [pc, #44]	; (11b5c <Pin::Pin(Pin const&)+0x50>)
   11b2e:	9b01      	ldr	r3, [sp, #4]
   11b30:	601a      	str	r2, [r3, #0]
   11b32:	9b00      	ldr	r3, [sp, #0]
   11b34:	791a      	ldrb	r2, [r3, #4]
   11b36:	9b01      	ldr	r3, [sp, #4]
   11b38:	711a      	strb	r2, [r3, #4]
   11b3a:	9b00      	ldr	r3, [sp, #0]
   11b3c:	795a      	ldrb	r2, [r3, #5]
   11b3e:	9b01      	ldr	r3, [sp, #4]
   11b40:	715a      	strb	r2, [r3, #5]
   11b42:	9c01      	ldr	r4, [sp, #4]
   11b44:	462b      	mov	r3, r5
   11b46:	4619      	mov	r1, r3
   11b48:	4803      	ldr	r0, [pc, #12]	; (11b58 <Pin::Pin(Pin const&)+0x4c>)
   11b4a:	f003 fdb1 	bl	156b0 <__cyg_profile_func_exit>
   11b4e:	4623      	mov	r3, r4
   11b50:	4618      	mov	r0, r3
   11b52:	b003      	add	sp, #12
   11b54:	bd30      	pop	{r4, r5, pc}
   11b56:	bf00      	nop
   11b58:	00011b0d 	.word	0x00011b0d
   11b5c:	0001a368 	.word	0x0001a368

00011b60 <Ssp::Ssp(Ssp::Peripheral)>:
        pssp_(Peripheral::kSsp0)
  {
  }

  /// User modified constructor. Must be followed by Set functions.
  explicit constexpr Ssp(Peripheral set_pssp)
   11b60:	b530      	push	{r4, r5, lr}
   11b62:	b083      	sub	sp, #12
   11b64:	4675      	mov	r5, lr
   11b66:	9001      	str	r0, [sp, #4]
   11b68:	9100      	str	r1, [sp, #0]
   11b6a:	462b      	mov	r3, r5
   11b6c:	4619      	mov	r1, r3
   11b6e:	4831      	ldr	r0, [pc, #196]	; (11c34 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   11b70:	f003 fd8a 	bl	15688 <__cyg_profile_func_enter>
        miso_(&miso_pin_),
        sck_(&sck_pin_),
        mosi_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMosi]),
        miso_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMiso]),
        sck_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kSck]),
        pssp_(set_pssp)
   11b74:	9b01      	ldr	r3, [sp, #4]
   11b76:	4618      	mov	r0, r3
   11b78:	f7ff ff92 	bl	11aa0 <SspInterface::SspInterface()>
   11b7c:	9b01      	ldr	r3, [sp, #4]
   11b7e:	3304      	adds	r3, #4
   11b80:	4618      	mov	r0, r3
   11b82:	f7ff fc9d 	bl	114c0 <Lpc40xxSystemController::Lpc40xxSystemController()>
   11b86:	4a2c      	ldr	r2, [pc, #176]	; (11c38 <Ssp::Ssp(Ssp::Peripheral)+0xd8>)
   11b88:	9b01      	ldr	r3, [sp, #4]
   11b8a:	601a      	str	r2, [r3, #0]
   11b8c:	4a2b      	ldr	r2, [pc, #172]	; (11c3c <Ssp::Ssp(Ssp::Peripheral)+0xdc>)
   11b8e:	9b01      	ldr	r3, [sp, #4]
   11b90:	605a      	str	r2, [r3, #4]
   11b92:	9b01      	ldr	r3, [sp, #4]
   11b94:	f103 0214 	add.w	r2, r3, #20
   11b98:	9b01      	ldr	r3, [sp, #4]
   11b9a:	609a      	str	r2, [r3, #8]
   11b9c:	9b01      	ldr	r3, [sp, #4]
   11b9e:	f103 021c 	add.w	r2, r3, #28
   11ba2:	9b01      	ldr	r3, [sp, #4]
   11ba4:	60da      	str	r2, [r3, #12]
   11ba6:	9b01      	ldr	r3, [sp, #4]
   11ba8:	f103 0224 	add.w	r2, r3, #36	; 0x24
   11bac:	9b01      	ldr	r3, [sp, #4]
   11bae:	611a      	str	r2, [r3, #16]
   11bb0:	9b01      	ldr	r3, [sp, #4]
   11bb2:	f103 0414 	add.w	r4, r3, #20
        mosi_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMosi]),
   11bb6:	9800      	ldr	r0, [sp, #0]
   11bb8:	f7ff ff5c 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11bbc:	4602      	mov	r2, r0
        pssp_(set_pssp)
   11bbe:	4613      	mov	r3, r2
   11bc0:	005b      	lsls	r3, r3, #1
   11bc2:	4413      	add	r3, r2
   11bc4:	00db      	lsls	r3, r3, #3
   11bc6:	4a1e      	ldr	r2, [pc, #120]	; (11c40 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   11bc8:	4413      	add	r3, r2
   11bca:	4619      	mov	r1, r3
   11bcc:	4620      	mov	r0, r4
   11bce:	f7ff ff9d 	bl	11b0c <Pin::Pin(Pin const&)>
   11bd2:	9b01      	ldr	r3, [sp, #4]
   11bd4:	f103 041c 	add.w	r4, r3, #28
        miso_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMiso]),
   11bd8:	9800      	ldr	r0, [sp, #0]
   11bda:	f7ff ff4b 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11bde:	4602      	mov	r2, r0
        pssp_(set_pssp)
   11be0:	4613      	mov	r3, r2
   11be2:	005b      	lsls	r3, r3, #1
   11be4:	4413      	add	r3, r2
   11be6:	00db      	lsls	r3, r3, #3
   11be8:	3308      	adds	r3, #8
   11bea:	4a15      	ldr	r2, [pc, #84]	; (11c40 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   11bec:	4413      	add	r3, r2
   11bee:	4619      	mov	r1, r3
   11bf0:	4620      	mov	r0, r4
   11bf2:	f7ff ff8b 	bl	11b0c <Pin::Pin(Pin const&)>
   11bf6:	9b01      	ldr	r3, [sp, #4]
   11bf8:	f103 0424 	add.w	r4, r3, #36	; 0x24
        sck_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kSck]),
   11bfc:	9800      	ldr	r0, [sp, #0]
   11bfe:	f7ff ff39 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11c02:	4602      	mov	r2, r0
        pssp_(set_pssp)
   11c04:	4613      	mov	r3, r2
   11c06:	005b      	lsls	r3, r3, #1
   11c08:	4413      	add	r3, r2
   11c0a:	00db      	lsls	r3, r3, #3
   11c0c:	3310      	adds	r3, #16
   11c0e:	4a0c      	ldr	r2, [pc, #48]	; (11c40 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   11c10:	4413      	add	r3, r2
   11c12:	4619      	mov	r1, r3
   11c14:	4620      	mov	r0, r4
   11c16:	f7ff ff79 	bl	11b0c <Pin::Pin(Pin const&)>
   11c1a:	9b01      	ldr	r3, [sp, #4]
   11c1c:	9a00      	ldr	r2, [sp, #0]
   11c1e:	62da      	str	r2, [r3, #44]	; 0x2c
  {
  }
   11c20:	9c01      	ldr	r4, [sp, #4]
   11c22:	462b      	mov	r3, r5
   11c24:	4619      	mov	r1, r3
   11c26:	4803      	ldr	r0, [pc, #12]	; (11c34 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   11c28:	f003 fd42 	bl	156b0 <__cyg_profile_func_exit>
   11c2c:	4623      	mov	r3, r4
   11c2e:	4618      	mov	r0, r3
   11c30:	b003      	add	sp, #12
   11c32:	bd30      	pop	{r4, r5, pc}
   11c34:	00011b61 	.word	0x00011b61
   11c38:	0001a21c 	.word	0x0001a21c
   11c3c:	0001a244 	.word	0x0001a244
   11c40:	0001a168 	.word	0x0001a168

00011c44 <Ssp::Initialize()>:
  }

  /// Powers on the peripheral, sets the peripheral clock, format, and data
  /// size, and enables the SSP pins for communication see and more.
  /// See page 601 of user manual UM10562 LPC408x/407x for more details.
  void Initialize() override
   11c44:	b570      	push	{r4, r5, r6, lr}
   11c46:	b086      	sub	sp, #24
   11c48:	4676      	mov	r6, lr
   11c4a:	9001      	str	r0, [sp, #4]
   11c4c:	4633      	mov	r3, r6
   11c4e:	4619      	mov	r1, r3
   11c50:	4830      	ldr	r0, [pc, #192]	; (11d14 <Ssp::Initialize()+0xd0>)
   11c52:	f003 fd19 	bl	15688 <__cyg_profile_func_enter>
  {
    uint32_t pssp = util::Value(pssp_);
   11c56:	9b01      	ldr	r3, [sp, #4]
   11c58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11c5a:	4618      	mov	r0, r3
   11c5c:	f7ff ff0a 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11c60:	4603      	mov	r3, r0
   11c62:	9305      	str	r3, [sp, #20]
    // Power up peripheral
    PowerUpPeripheral(kPowerBit[pssp]);
   11c64:	9b01      	ldr	r3, [sp, #4]
   11c66:	1d18      	adds	r0, r3, #4
   11c68:	9b01      	ldr	r3, [sp, #4]
   11c6a:	685b      	ldr	r3, [r3, #4]
   11c6c:	3314      	adds	r3, #20
   11c6e:	681b      	ldr	r3, [r3, #0]
   11c70:	9a05      	ldr	r2, [sp, #20]
   11c72:	0092      	lsls	r2, r2, #2
   11c74:	4928      	ldr	r1, [pc, #160]	; (11d18 <Ssp::Initialize()+0xd4>)
   11c76:	440a      	add	r2, r1
   11c78:	4611      	mov	r1, r2
   11c7a:	4798      	blx	r3
    // Enable SSP pins
    mosi_->SetPinFunction(kPinSelect[pssp]);
   11c7c:	9b01      	ldr	r3, [sp, #4]
   11c7e:	6898      	ldr	r0, [r3, #8]
   11c80:	9b01      	ldr	r3, [sp, #4]
   11c82:	689b      	ldr	r3, [r3, #8]
   11c84:	681b      	ldr	r3, [r3, #0]
   11c86:	681b      	ldr	r3, [r3, #0]
   11c88:	4924      	ldr	r1, [pc, #144]	; (11d1c <Ssp::Initialize()+0xd8>)
   11c8a:	9a05      	ldr	r2, [sp, #20]
   11c8c:	440a      	add	r2, r1
   11c8e:	7812      	ldrb	r2, [r2, #0]
   11c90:	4611      	mov	r1, r2
   11c92:	4798      	blx	r3
    miso_->SetPinFunction(kPinSelect[pssp]);
   11c94:	9b01      	ldr	r3, [sp, #4]
   11c96:	68d8      	ldr	r0, [r3, #12]
   11c98:	9b01      	ldr	r3, [sp, #4]
   11c9a:	68db      	ldr	r3, [r3, #12]
   11c9c:	681b      	ldr	r3, [r3, #0]
   11c9e:	681b      	ldr	r3, [r3, #0]
   11ca0:	491e      	ldr	r1, [pc, #120]	; (11d1c <Ssp::Initialize()+0xd8>)
   11ca2:	9a05      	ldr	r2, [sp, #20]
   11ca4:	440a      	add	r2, r1
   11ca6:	7812      	ldrb	r2, [r2, #0]
   11ca8:	4611      	mov	r1, r2
   11caa:	4798      	blx	r3
    sck_->SetPinFunction(kPinSelect[pssp]);
   11cac:	9b01      	ldr	r3, [sp, #4]
   11cae:	6918      	ldr	r0, [r3, #16]
   11cb0:	9b01      	ldr	r3, [sp, #4]
   11cb2:	691b      	ldr	r3, [r3, #16]
   11cb4:	681b      	ldr	r3, [r3, #0]
   11cb6:	681b      	ldr	r3, [r3, #0]
   11cb8:	4918      	ldr	r1, [pc, #96]	; (11d1c <Ssp::Initialize()+0xd8>)
   11cba:	9a05      	ldr	r2, [sp, #20]
   11cbc:	440a      	add	r2, r1
   11cbe:	7812      	ldrb	r2, [r2, #0]
   11cc0:	4611      	mov	r1, r2
   11cc2:	4798      	blx	r3
    // Enable SSP
    ssp_registers[pssp]->CR1 = bit::Set(ssp_registers[pssp]->CR1, kSspEnable);
   11cc4:	4a16      	ldr	r2, [pc, #88]	; (11d20 <Ssp::Initialize()+0xdc>)
   11cc6:	9b05      	ldr	r3, [sp, #20]
   11cc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ccc:	685b      	ldr	r3, [r3, #4]
   11cce:	4914      	ldr	r1, [pc, #80]	; (11d20 <Ssp::Initialize()+0xdc>)
   11cd0:	9a05      	ldr	r2, [sp, #20]
   11cd2:	f851 4022 	ldr.w	r4, [r1, r2, lsl #2]
   11cd6:	9304      	str	r3, [sp, #16]
   11cd8:	2301      	movs	r3, #1
   11cda:	9303      	str	r3, [sp, #12]
   11cdc:	4633      	mov	r3, r6
   11cde:	4619      	mov	r1, r3
   11ce0:	4810      	ldr	r0, [pc, #64]	; (11d24 <Ssp::Initialize()+0xe0>)
   11ce2:	f003 fcd1 	bl	15688 <__cyg_profile_func_enter>
[[gnu::always_inline]] [[nodiscard]]
constexpr T Set(T target, uint32_t position)
{
  static_assert(std::numeric_limits<T>::is_integer,
                "Set only accepts intergers.");
  return target | (1 << position);
   11ce6:	2201      	movs	r2, #1
   11ce8:	9b03      	ldr	r3, [sp, #12]
   11cea:	fa02 f303 	lsl.w	r3, r2, r3
   11cee:	461a      	mov	r2, r3
   11cf0:	9b04      	ldr	r3, [sp, #16]
   11cf2:	ea42 0503 	orr.w	r5, r2, r3
   11cf6:	4633      	mov	r3, r6
   11cf8:	4619      	mov	r1, r3
   11cfa:	480a      	ldr	r0, [pc, #40]	; (11d24 <Ssp::Initialize()+0xe0>)
   11cfc:	f003 fcd8 	bl	156b0 <__cyg_profile_func_exit>
   11d00:	6065      	str	r5, [r4, #4]
   11d02:	4633      	mov	r3, r6
   11d04:	4619      	mov	r1, r3
   11d06:	4803      	ldr	r0, [pc, #12]	; (11d14 <Ssp::Initialize()+0xd0>)
   11d08:	f003 fcd2 	bl	156b0 <__cyg_profile_func_exit>
  }
   11d0c:	bf00      	nop
   11d0e:	b006      	add	sp, #24
   11d10:	bd70      	pop	{r4, r5, r6, pc}
   11d12:	bf00      	nop
   11d14:	00011c45 	.word	0x00011c45
   11d18:	0001a1b0 	.word	0x0001a1b0
   11d1c:	0001a164 	.word	0x0001a164
   11d20:	10000050 	.word	0x10000050
   11d24:	00013719 	.word	0x00013719

00011d28 <Ssp::IsTransferRegBusy()>:

  /// Checks if the SSP controller is idle.
  /// @returns true if the controller is sending or receiving a data frame and
  /// false if it is idle.
  bool IsTransferRegBusy() override
   11d28:	b530      	push	{r4, r5, lr}
   11d2a:	b085      	sub	sp, #20
   11d2c:	4675      	mov	r5, lr
   11d2e:	9001      	str	r0, [sp, #4]
   11d30:	462b      	mov	r3, r5
   11d32:	4619      	mov	r1, r3
   11d34:	4817      	ldr	r0, [pc, #92]	; (11d94 <Ssp::IsTransferRegBusy()+0x6c>)
   11d36:	f003 fca7 	bl	15688 <__cyg_profile_func_enter>
  {
    return (bit::Read(ssp_registers[util::Value(pssp_)]->SR, kDataLineIdleBit));
   11d3a:	9b01      	ldr	r3, [sp, #4]
   11d3c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11d3e:	4618      	mov	r0, r3
   11d40:	f7ff fe98 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11d44:	4602      	mov	r2, r0
   11d46:	4b14      	ldr	r3, [pc, #80]	; (11d98 <Ssp::IsTransferRegBusy()+0x70>)
   11d48:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11d4c:	68db      	ldr	r3, [r3, #12]
   11d4e:	9303      	str	r3, [sp, #12]
   11d50:	2304      	movs	r3, #4
   11d52:	9302      	str	r3, [sp, #8]
   11d54:	462b      	mov	r3, r5
   11d56:	4619      	mov	r1, r3
   11d58:	4810      	ldr	r0, [pc, #64]	; (11d9c <Ssp::IsTransferRegBusy()+0x74>)
   11d5a:	f003 fc95 	bl	15688 <__cyg_profile_func_enter>
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
                                                        uint32_t position)
{
  static_assert(std::numeric_limits<T>::is_integer,
                "Read only accepts intergers.");
  return static_cast<bool>(target & (1 << position));
   11d5e:	2201      	movs	r2, #1
   11d60:	9b02      	ldr	r3, [sp, #8]
   11d62:	fa02 f303 	lsl.w	r3, r2, r3
   11d66:	461a      	mov	r2, r3
   11d68:	9b03      	ldr	r3, [sp, #12]
   11d6a:	4013      	ands	r3, r2
   11d6c:	2b00      	cmp	r3, #0
   11d6e:	bf14      	ite	ne
   11d70:	2301      	movne	r3, #1
   11d72:	2300      	moveq	r3, #0
   11d74:	b2dc      	uxtb	r4, r3
   11d76:	462b      	mov	r3, r5
   11d78:	4619      	mov	r1, r3
   11d7a:	4808      	ldr	r0, [pc, #32]	; (11d9c <Ssp::IsTransferRegBusy()+0x74>)
   11d7c:	f003 fc98 	bl	156b0 <__cyg_profile_func_exit>
   11d80:	462b      	mov	r3, r5
   11d82:	4619      	mov	r1, r3
   11d84:	4803      	ldr	r0, [pc, #12]	; (11d94 <Ssp::IsTransferRegBusy()+0x6c>)
   11d86:	f003 fc93 	bl	156b0 <__cyg_profile_func_exit>
   11d8a:	4623      	mov	r3, r4
  }
   11d8c:	4618      	mov	r0, r3
   11d8e:	b005      	add	sp, #20
   11d90:	bd30      	pop	{r4, r5, pc}
   11d92:	bf00      	nop
   11d94:	00011d29 	.word	0x00011d29
   11d98:	10000050 	.word	0x10000050
   11d9c:	00013755 	.word	0x00013755

00011da0 <Ssp::Transfer(unsigned short)>:
  /// data register. This functions for both transmitting and
  /// receiving data. It is recommended this region be protected
  /// by a mutex.
  /// @param data - information to be placed in data register
  /// @return - received data from external device
  uint16_t Transfer(uint16_t data) override
   11da0:	b530      	push	{r4, r5, lr}
   11da2:	b085      	sub	sp, #20
   11da4:	4675      	mov	r5, lr
   11da6:	9001      	str	r0, [sp, #4]
   11da8:	460b      	mov	r3, r1
   11daa:	f8ad 3002 	strh.w	r3, [sp, #2]
   11dae:	462b      	mov	r3, r5
   11db0:	4619      	mov	r1, r3
   11db2:	4814      	ldr	r0, [pc, #80]	; (11e04 <Ssp::Transfer(unsigned short)+0x64>)
   11db4:	f003 fc68 	bl	15688 <__cyg_profile_func_enter>
  {
    uint32_t pssp = util::Value(pssp_);
   11db8:	9b01      	ldr	r3, [sp, #4]
   11dba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11dbc:	4618      	mov	r0, r3
   11dbe:	f7ff fe59 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11dc2:	4603      	mov	r3, r0
   11dc4:	9303      	str	r3, [sp, #12]

    ssp_registers[pssp]->DR = data;
   11dc6:	4a10      	ldr	r2, [pc, #64]	; (11e08 <Ssp::Transfer(unsigned short)+0x68>)
   11dc8:	9b03      	ldr	r3, [sp, #12]
   11dca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11dce:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11dd2:	609a      	str	r2, [r3, #8]
    while (IsTransferRegBusy())
   11dd4:	9801      	ldr	r0, [sp, #4]
   11dd6:	f7ff ffa7 	bl	11d28 <Ssp::IsTransferRegBusy()>
   11dda:	4603      	mov	r3, r0
   11ddc:	2b00      	cmp	r3, #0
   11dde:	d001      	beq.n	11de4 <Ssp::Transfer(unsigned short)+0x44>
    {
      continue;
   11de0:	bf00      	nop
    while (IsTransferRegBusy())
   11de2:	e7f7      	b.n	11dd4 <Ssp::Transfer(unsigned short)+0x34>
    }
    return static_cast<uint16_t>(ssp_registers[pssp]->DR);
   11de4:	4a08      	ldr	r2, [pc, #32]	; (11e08 <Ssp::Transfer(unsigned short)+0x68>)
   11de6:	9b03      	ldr	r3, [sp, #12]
   11de8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11dec:	689b      	ldr	r3, [r3, #8]
   11dee:	b29c      	uxth	r4, r3
   11df0:	462b      	mov	r3, r5
   11df2:	4619      	mov	r1, r3
   11df4:	4803      	ldr	r0, [pc, #12]	; (11e04 <Ssp::Transfer(unsigned short)+0x64>)
   11df6:	f003 fc5b 	bl	156b0 <__cyg_profile_func_exit>
   11dfa:	4623      	mov	r3, r4
  }
   11dfc:	4618      	mov	r0, r3
   11dfe:	b005      	add	sp, #20
   11e00:	bd30      	pop	{r4, r5, pc}
   11e02:	bf00      	nop
   11e04:	00011da1 	.word	0x00011da1
   11e08:	10000050 	.word	0x10000050

00011e0c <Ssp::SetSpiMasterDefault()>:

  /// Sets up SSP peripheral as SPI master
  void SetSpiMasterDefault() override
   11e0c:	b510      	push	{r4, lr}
   11e0e:	b086      	sub	sp, #24
   11e10:	4674      	mov	r4, lr
   11e12:	9003      	str	r0, [sp, #12]
   11e14:	4623      	mov	r3, r4
   11e16:	4619      	mov	r1, r3
   11e18:	4812      	ldr	r0, [pc, #72]	; (11e64 <Ssp::SetSpiMasterDefault()+0x58>)
   11e1a:	f003 fc35 	bl	15688 <__cyg_profile_func_enter>
  {
    constexpr bool kHighPolarity  = 1;
   11e1e:	2301      	movs	r3, #1
   11e20:	f88d 3017 	strb.w	r3, [sp, #23]
    constexpr bool kPhase0        = 0;
   11e24:	2300      	movs	r3, #0
   11e26:	f88d 3016 	strb.w	r3, [sp, #22]
    constexpr uint8_t kScrDivider = 0;
   11e2a:	2300      	movs	r3, #0
   11e2c:	f88d 3015 	strb.w	r3, [sp, #21]
    constexpr uint8_t kPrescaler  = SJ2_SYSTEM_CLOCK_RATE_MHZ;
   11e30:	2330      	movs	r3, #48	; 0x30
   11e32:	f88d 3014 	strb.w	r3, [sp, #20]

    SetPeripheralMode(kMaster, kSpi, kEight);
   11e36:	2307      	movs	r3, #7
   11e38:	2200      	movs	r2, #0
   11e3a:	2100      	movs	r1, #0
   11e3c:	9803      	ldr	r0, [sp, #12]
   11e3e:	f000 f85b 	bl	11ef8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
    SetClock(kHighPolarity, kPhase0, kScrDivider, kPrescaler);
   11e42:	2330      	movs	r3, #48	; 0x30
   11e44:	9300      	str	r3, [sp, #0]
   11e46:	2300      	movs	r3, #0
   11e48:	2200      	movs	r2, #0
   11e4a:	2101      	movs	r1, #1
   11e4c:	9803      	ldr	r0, [sp, #12]
   11e4e:	f000 fa09 	bl	12264 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
   11e52:	4623      	mov	r3, r4
   11e54:	4619      	mov	r1, r3
   11e56:	4803      	ldr	r0, [pc, #12]	; (11e64 <Ssp::SetSpiMasterDefault()+0x58>)
   11e58:	f003 fc2a 	bl	156b0 <__cyg_profile_func_exit>
  }
   11e5c:	bf00      	nop
   11e5e:	b006      	add	sp, #24
   11e60:	bd10      	pop	{r4, pc}
   11e62:	bf00      	nop
   11e64:	00011e0d 	.word	0x00011e0d

00011e68 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>:
constexpr Type Value(Enum enum_type_value)
   11e68:	b530      	push	{r4, r5, lr}
   11e6a:	b083      	sub	sp, #12
   11e6c:	4675      	mov	r5, lr
   11e6e:	4603      	mov	r3, r0
   11e70:	f88d 3007 	strb.w	r3, [sp, #7]
   11e74:	462b      	mov	r3, r5
   11e76:	4619      	mov	r1, r3
   11e78:	4806      	ldr	r0, [pc, #24]	; (11e94 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   11e7a:	f003 fc05 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11e7e:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11e82:	462b      	mov	r3, r5
   11e84:	4619      	mov	r1, r3
   11e86:	4803      	ldr	r0, [pc, #12]	; (11e94 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   11e88:	f003 fc12 	bl	156b0 <__cyg_profile_func_exit>
   11e8c:	4623      	mov	r3, r4
}
   11e8e:	4618      	mov	r0, r3
   11e90:	b003      	add	sp, #12
   11e92:	bd30      	pop	{r4, r5, pc}
   11e94:	00011e69 	.word	0x00011e69

00011e98 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>:
constexpr Type Value(Enum enum_type_value)
   11e98:	b530      	push	{r4, r5, lr}
   11e9a:	b083      	sub	sp, #12
   11e9c:	4675      	mov	r5, lr
   11e9e:	4603      	mov	r3, r0
   11ea0:	f88d 3007 	strb.w	r3, [sp, #7]
   11ea4:	462b      	mov	r3, r5
   11ea6:	4619      	mov	r1, r3
   11ea8:	4806      	ldr	r0, [pc, #24]	; (11ec4 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   11eaa:	f003 fbed 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11eae:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11eb2:	462b      	mov	r3, r5
   11eb4:	4619      	mov	r1, r3
   11eb6:	4803      	ldr	r0, [pc, #12]	; (11ec4 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   11eb8:	f003 fbfa 	bl	156b0 <__cyg_profile_func_exit>
   11ebc:	4623      	mov	r3, r4
}
   11ebe:	4618      	mov	r0, r3
   11ec0:	b003      	add	sp, #12
   11ec2:	bd30      	pop	{r4, r5, pc}
   11ec4:	00011e99 	.word	0x00011e99

00011ec8 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>:
constexpr Type Value(Enum enum_type_value)
   11ec8:	b530      	push	{r4, r5, lr}
   11eca:	b083      	sub	sp, #12
   11ecc:	4675      	mov	r5, lr
   11ece:	4603      	mov	r3, r0
   11ed0:	f88d 3007 	strb.w	r3, [sp, #7]
   11ed4:	462b      	mov	r3, r5
   11ed6:	4619      	mov	r1, r3
   11ed8:	4806      	ldr	r0, [pc, #24]	; (11ef4 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   11eda:	f003 fbd5 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11ede:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11ee2:	462b      	mov	r3, r5
   11ee4:	4619      	mov	r1, r3
   11ee6:	4803      	ldr	r0, [pc, #12]	; (11ef4 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   11ee8:	f003 fbe2 	bl	156b0 <__cyg_profile_func_exit>
   11eec:	4623      	mov	r3, r4
}
   11eee:	4618      	mov	r0, r3
   11ef0:	b003      	add	sp, #12
   11ef2:	bd30      	pop	{r4, r5, pc}
   11ef4:	00011ec9 	.word	0x00011ec9

00011ef8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>:

  /// Sets the various modes for the Peripheral
  /// @param mode - master or slave mode
  /// @param frame - format for Peripheral data to use
  /// @param size - number of bits per frame
  void SetPeripheralMode(MasterSlaveMode mode, FrameMode frame,
   11ef8:	b570      	push	{r4, r5, r6, lr}
   11efa:	b098      	sub	sp, #96	; 0x60
   11efc:	4674      	mov	r4, lr
   11efe:	9001      	str	r0, [sp, #4]
   11f00:	4608      	mov	r0, r1
   11f02:	4611      	mov	r1, r2
   11f04:	461a      	mov	r2, r3
   11f06:	4603      	mov	r3, r0
   11f08:	f88d 3003 	strb.w	r3, [sp, #3]
   11f0c:	460b      	mov	r3, r1
   11f0e:	f88d 3002 	strb.w	r3, [sp, #2]
   11f12:	4613      	mov	r3, r2
   11f14:	f88d 3001 	strb.w	r3, [sp, #1]
   11f18:	4623      	mov	r3, r4
   11f1a:	4619      	mov	r1, r3
   11f1c:	4875      	ldr	r0, [pc, #468]	; (120f4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   11f1e:	f003 fbb3 	bl	15688 <__cyg_profile_func_enter>
                         DataSize size) override
  {
    uint32_t pssp = util::Value(pssp_);
   11f22:	9b01      	ldr	r3, [sp, #4]
   11f24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11f26:	4618      	mov	r0, r3
   11f28:	f7ff fda4 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11f2c:	4603      	mov	r3, r0
   11f2e:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   11f30:	9b01      	ldr	r3, [sp, #4]
   11f32:	1d18      	adds	r0, r3, #4
   11f34:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11f36:	009b      	lsls	r3, r3, #2
   11f38:	4a6f      	ldr	r2, [pc, #444]	; (120f8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x200>)
   11f3a:	4413      	add	r3, r2
   11f3c:	4619      	mov	r1, r3
   11f3e:	f7ff fb7b 	bl	11638 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    if (frame == kMicro)
   11f42:	f89d 3002 	ldrb.w	r3, [sp, #2]
   11f46:	2b02      	cmp	r3, #2
   11f48:	d102      	bne.n	11f50 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x58>
    {
      size = kEight;
   11f4a:	2307      	movs	r3, #7
   11f4c:	f88d 3001 	strb.w	r3, [sp, #1]
    }
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(size), kDataBit, 4);
   11f50:	4a6a      	ldr	r2, [pc, #424]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11f52:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11f54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f58:	681e      	ldr	r6, [r3, #0]
   11f5a:	f89d 3001 	ldrb.w	r3, [sp, #1]
   11f5e:	4618      	mov	r0, r3
   11f60:	f7ff ff82 	bl	11e68 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>
   11f64:	4603      	mov	r3, r0
   11f66:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   11f68:	4a64      	ldr	r2, [pc, #400]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11f6a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11f6c:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   11f70:	9608      	str	r6, [sp, #32]
   11f72:	460b      	mov	r3, r1
   11f74:	f88d 301f 	strb.w	r3, [sp, #31]
   11f78:	2300      	movs	r3, #0
   11f7a:	9306      	str	r3, [sp, #24]
   11f7c:	2304      	movs	r3, #4
   11f7e:	9305      	str	r3, [sp, #20]
   11f80:	4623      	mov	r3, r4
   11f82:	4619      	mov	r1, r3
   11f84:	485e      	ldr	r0, [pc, #376]	; (12100 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   11f86:	f003 fb7f 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   11f8a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11f8e:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   11f90:	2320      	movs	r3, #32
   11f92:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   11f94:	9b05      	ldr	r3, [sp, #20]
   11f96:	f1c3 0320 	rsb	r3, r3, #32
   11f9a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11f9e:	fa22 f303 	lsr.w	r3, r2, r3
   11fa2:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   11fa4:	9a02      	ldr	r2, [sp, #8]
   11fa6:	9b06      	ldr	r3, [sp, #24]
   11fa8:	fa02 f303 	lsl.w	r3, r2, r3
   11fac:	43db      	mvns	r3, r3
   11fae:	9a08      	ldr	r2, [sp, #32]
   11fb0:	4013      	ands	r3, r2
   11fb2:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   11fb4:	f89d 201f 	ldrb.w	r2, [sp, #31]
   11fb8:	9b02      	ldr	r3, [sp, #8]
   11fba:	401a      	ands	r2, r3
   11fbc:	9b06      	ldr	r3, [sp, #24]
   11fbe:	fa02 f303 	lsl.w	r3, r2, r3
   11fc2:	9a08      	ldr	r2, [sp, #32]
   11fc4:	4313      	orrs	r3, r2
   11fc6:	9308      	str	r3, [sp, #32]
  return target;
   11fc8:	9e08      	ldr	r6, [sp, #32]
   11fca:	4623      	mov	r3, r4
   11fcc:	4619      	mov	r1, r3
   11fce:	484c      	ldr	r0, [pc, #304]	; (12100 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   11fd0:	f003 fb6e 	bl	156b0 <__cyg_profile_func_exit>
   11fd4:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(frame), kFrameBit, 2);
   11fd6:	4a49      	ldr	r2, [pc, #292]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11fd8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11fda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11fde:	681e      	ldr	r6, [r3, #0]
   11fe0:	f89d 3002 	ldrb.w	r3, [sp, #2]
   11fe4:	4618      	mov	r0, r3
   11fe6:	f7ff ff57 	bl	11e98 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>
   11fea:	4603      	mov	r3, r0
   11fec:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   11fee:	4a43      	ldr	r2, [pc, #268]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11ff0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11ff2:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   11ff6:	960f      	str	r6, [sp, #60]	; 0x3c
   11ff8:	460b      	mov	r3, r1
   11ffa:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   11ffe:	2304      	movs	r3, #4
   12000:	930d      	str	r3, [sp, #52]	; 0x34
   12002:	2302      	movs	r3, #2
   12004:	930c      	str	r3, [sp, #48]	; 0x30
   12006:	4623      	mov	r3, r4
   12008:	4619      	mov	r1, r3
   1200a:	483d      	ldr	r0, [pc, #244]	; (12100 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   1200c:	f003 fb3c 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12010:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12014:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12016:	2320      	movs	r3, #32
   12018:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1201a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1201c:	f1c3 0320 	rsb	r3, r3, #32
   12020:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12024:	fa22 f303 	lsr.w	r3, r2, r3
   12028:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   1202a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1202c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1202e:	fa02 f303 	lsl.w	r3, r2, r3
   12032:	43db      	mvns	r3, r3
   12034:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   12036:	4013      	ands	r3, r2
   12038:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   1203a:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   1203e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12040:	401a      	ands	r2, r3
   12042:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12044:	fa02 f303 	lsl.w	r3, r2, r3
   12048:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1204a:	4313      	orrs	r3, r2
   1204c:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   1204e:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   12050:	4623      	mov	r3, r4
   12052:	4619      	mov	r1, r3
   12054:	482a      	ldr	r0, [pc, #168]	; (12100 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   12056:	f003 fb2b 	bl	156b0 <__cyg_profile_func_exit>
   1205a:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR1 = bit::Insert(
        ssp_registers[pssp]->CR1, util::Value(mode), kMasterModeBit, 1);
   1205c:	4a27      	ldr	r2, [pc, #156]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   1205e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   12060:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12064:	685e      	ldr	r6, [r3, #4]
    ssp_registers[pssp]->CR1 = bit::Insert(
   12066:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1206a:	4618      	mov	r0, r3
   1206c:	f7ff ff2c 	bl	11ec8 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>
   12070:	4603      	mov	r3, r0
   12072:	4619      	mov	r1, r3
   12074:	4a21      	ldr	r2, [pc, #132]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   12076:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   12078:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   1207c:	9616      	str	r6, [sp, #88]	; 0x58
   1207e:	460b      	mov	r3, r1
   12080:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   12084:	2302      	movs	r3, #2
   12086:	9314      	str	r3, [sp, #80]	; 0x50
   12088:	2301      	movs	r3, #1
   1208a:	9313      	str	r3, [sp, #76]	; 0x4c
   1208c:	4623      	mov	r3, r4
   1208e:	4619      	mov	r1, r3
   12090:	481b      	ldr	r0, [pc, #108]	; (12100 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   12092:	f003 faf9 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12096:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1209a:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1209c:	2320      	movs	r3, #32
   1209e:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   120a0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   120a2:	f1c3 0320 	rsb	r3, r3, #32
   120a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   120aa:	fa22 f303 	lsr.w	r3, r2, r3
   120ae:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   120b0:	9a10      	ldr	r2, [sp, #64]	; 0x40
   120b2:	9b14      	ldr	r3, [sp, #80]	; 0x50
   120b4:	fa02 f303 	lsl.w	r3, r2, r3
   120b8:	43db      	mvns	r3, r3
   120ba:	9a16      	ldr	r2, [sp, #88]	; 0x58
   120bc:	4013      	ands	r3, r2
   120be:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   120c0:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   120c4:	9b10      	ldr	r3, [sp, #64]	; 0x40
   120c6:	401a      	ands	r2, r3
   120c8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   120ca:	fa02 f303 	lsl.w	r3, r2, r3
   120ce:	9a16      	ldr	r2, [sp, #88]	; 0x58
   120d0:	4313      	orrs	r3, r2
   120d2:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   120d4:	9e16      	ldr	r6, [sp, #88]	; 0x58
   120d6:	4623      	mov	r3, r4
   120d8:	4619      	mov	r1, r3
   120da:	4809      	ldr	r0, [pc, #36]	; (12100 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   120dc:	f003 fae8 	bl	156b0 <__cyg_profile_func_exit>
   120e0:	606e      	str	r6, [r5, #4]
   120e2:	4623      	mov	r3, r4
   120e4:	4619      	mov	r1, r3
   120e6:	4803      	ldr	r0, [pc, #12]	; (120f4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   120e8:	f003 fae2 	bl	156b0 <__cyg_profile_func_exit>
  }
   120ec:	bf00      	nop
   120ee:	b018      	add	sp, #96	; 0x60
   120f0:	bd70      	pop	{r4, r5, r6, pc}
   120f2:	bf00      	nop
   120f4:	00011ef9 	.word	0x00011ef9
   120f8:	0001a1b0 	.word	0x0001a1b0
   120fc:	10000050 	.word	0x10000050
   12100:	00013799 	.word	0x00013799

00012104 <Ssp::GetPeripheralMode()>:
  /// Gets the Peripheral modes from registers
  /// @return - returns a 16-bit value as follows: 0000_000x 0xx0_xxxx
  ///       MasterSlaveMode = 1-bit @ bit 8
  ///       FrameMode       = 2-bit @ bit 5
  ///       DataSize        = 4-bit @ bit 0
  uint16_t GetPeripheralMode() override
   12104:	b570      	push	{r4, r5, r6, lr}
   12106:	b096      	sub	sp, #88	; 0x58
   12108:	4674      	mov	r4, lr
   1210a:	9001      	str	r0, [sp, #4]
   1210c:	4623      	mov	r3, r4
   1210e:	4619      	mov	r1, r3
   12110:	4850      	ldr	r0, [pc, #320]	; (12254 <Ssp::GetPeripheralMode()+0x150>)
   12112:	f003 fab9 	bl	15688 <__cyg_profile_func_enter>
  {
    uint16_t return_val = 0;
   12116:	2300      	movs	r3, #0
   12118:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    uint32_t pssp       = util::Value(pssp_);
   1211c:	9b01      	ldr	r3, [sp, #4]
   1211e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12120:	4618      	mov	r0, r3
   12122:	f7ff fca7 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   12126:	4603      	mov	r3, r0
   12128:	9314      	str	r3, [sp, #80]	; 0x50
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   1212a:	9b01      	ldr	r3, [sp, #4]
   1212c:	1d18      	adds	r0, r3, #4
   1212e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   12130:	009b      	lsls	r3, r3, #2
   12132:	4a49      	ldr	r2, [pc, #292]	; (12258 <Ssp::GetPeripheralMode()+0x154>)
   12134:	4413      	add	r3, r2
   12136:	4619      	mov	r1, r3
   12138:	f7ff fa7e 	bl	11638 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val = static_cast<uint16_t>(
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   1213c:	4a47      	ldr	r2, [pc, #284]	; (1225c <Ssp::GetPeripheralMode()+0x158>)
   1213e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   12140:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12144:	681b      	ldr	r3, [r3, #0]
   12146:	9307      	str	r3, [sp, #28]
   12148:	2300      	movs	r3, #0
   1214a:	9306      	str	r3, [sp, #24]
   1214c:	2304      	movs	r3, #4
   1214e:	9305      	str	r3, [sp, #20]
   12150:	4623      	mov	r3, r4
   12152:	4619      	mov	r1, r3
   12154:	4842      	ldr	r0, [pc, #264]	; (12260 <Ssp::GetPeripheralMode()+0x15c>)
   12156:	f003 fa97 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1215a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1215e:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12160:	2320      	movs	r3, #32
   12162:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12164:	9b05      	ldr	r3, [sp, #20]
   12166:	f1c3 0320 	rsb	r3, r3, #32
   1216a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1216e:	fa22 f303 	lsr.w	r3, r2, r3
   12172:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   12174:	9a07      	ldr	r2, [sp, #28]
   12176:	9b06      	ldr	r3, [sp, #24]
   12178:	40da      	lsrs	r2, r3
   1217a:	9b02      	ldr	r3, [sp, #8]
   1217c:	ea02 0503 	and.w	r5, r2, r3
   12180:	4623      	mov	r3, r4
   12182:	4619      	mov	r1, r3
   12184:	4836      	ldr	r0, [pc, #216]	; (12260 <Ssp::GetPeripheralMode()+0x15c>)
   12186:	f003 fa93 	bl	156b0 <__cyg_profile_func_exit>
   1218a:	b2ad      	uxth	r5, r5
        ((bit::Extract(ssp_registers[pssp]->CR0, kFrameBit, 2)) << 5) +
   1218c:	4a33      	ldr	r2, [pc, #204]	; (1225c <Ssp::GetPeripheralMode()+0x158>)
   1218e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   12190:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12194:	681b      	ldr	r3, [r3, #0]
   12196:	930d      	str	r3, [sp, #52]	; 0x34
   12198:	2304      	movs	r3, #4
   1219a:	930c      	str	r3, [sp, #48]	; 0x30
   1219c:	2302      	movs	r3, #2
   1219e:	930b      	str	r3, [sp, #44]	; 0x2c
   121a0:	4623      	mov	r3, r4
   121a2:	4619      	mov	r1, r3
   121a4:	482e      	ldr	r0, [pc, #184]	; (12260 <Ssp::GetPeripheralMode()+0x15c>)
   121a6:	f003 fa6f 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   121aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   121ae:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   121b0:	2320      	movs	r3, #32
   121b2:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   121b4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   121b6:	f1c3 0320 	rsb	r3, r3, #32
   121ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   121be:	fa22 f303 	lsr.w	r3, r2, r3
   121c2:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   121c4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   121c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   121c8:	40da      	lsrs	r2, r3
   121ca:	9b08      	ldr	r3, [sp, #32]
   121cc:	ea02 0603 	and.w	r6, r2, r3
   121d0:	4623      	mov	r3, r4
   121d2:	4619      	mov	r1, r3
   121d4:	4822      	ldr	r0, [pc, #136]	; (12260 <Ssp::GetPeripheralMode()+0x15c>)
   121d6:	f003 fa6b 	bl	156b0 <__cyg_profile_func_exit>
   121da:	b2b3      	uxth	r3, r6
   121dc:	015b      	lsls	r3, r3, #5
   121de:	b29b      	uxth	r3, r3
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   121e0:	442b      	add	r3, r5
   121e2:	b29d      	uxth	r5, r3
        ((bit::Extract(ssp_registers[pssp]->CR1, kMasterModeBit)) << 8));
   121e4:	4a1d      	ldr	r2, [pc, #116]	; (1225c <Ssp::GetPeripheralMode()+0x158>)
   121e6:	9b14      	ldr	r3, [sp, #80]	; 0x50
   121e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121ec:	685b      	ldr	r3, [r3, #4]
   121ee:	9313      	str	r3, [sp, #76]	; 0x4c
   121f0:	2302      	movs	r3, #2
   121f2:	9312      	str	r3, [sp, #72]	; 0x48
   121f4:	2301      	movs	r3, #1
   121f6:	9311      	str	r3, [sp, #68]	; 0x44
   121f8:	4623      	mov	r3, r4
   121fa:	4619      	mov	r1, r3
   121fc:	4818      	ldr	r0, [pc, #96]	; (12260 <Ssp::GetPeripheralMode()+0x15c>)
   121fe:	f003 fa43 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12202:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12206:	9310      	str	r3, [sp, #64]	; 0x40
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12208:	2320      	movs	r3, #32
   1220a:	930f      	str	r3, [sp, #60]	; 0x3c
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1220c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1220e:	f1c3 0320 	rsb	r3, r3, #32
   12212:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12216:	fa22 f303 	lsr.w	r3, r2, r3
   1221a:	930e      	str	r3, [sp, #56]	; 0x38
  return (target >> position) & mask;
   1221c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1221e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   12220:	40da      	lsrs	r2, r3
   12222:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   12224:	ea02 0603 	and.w	r6, r2, r3
   12228:	4623      	mov	r3, r4
   1222a:	4619      	mov	r1, r3
   1222c:	480c      	ldr	r0, [pc, #48]	; (12260 <Ssp::GetPeripheralMode()+0x15c>)
   1222e:	f003 fa3f 	bl	156b0 <__cyg_profile_func_exit>
   12232:	b2b3      	uxth	r3, r6
   12234:	021b      	lsls	r3, r3, #8
   12236:	b29b      	uxth	r3, r3
    return_val = static_cast<uint16_t>(
   12238:	442b      	add	r3, r5
   1223a:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    return return_val;
   1223e:	f8bd 5056 	ldrh.w	r5, [sp, #86]	; 0x56
   12242:	4623      	mov	r3, r4
   12244:	4619      	mov	r1, r3
   12246:	4803      	ldr	r0, [pc, #12]	; (12254 <Ssp::GetPeripheralMode()+0x150>)
   12248:	f003 fa32 	bl	156b0 <__cyg_profile_func_exit>
   1224c:	462b      	mov	r3, r5
  }
   1224e:	4618      	mov	r0, r3
   12250:	b016      	add	sp, #88	; 0x58
   12252:	bd70      	pop	{r4, r5, r6, pc}
   12254:	00012105 	.word	0x00012105
   12258:	0001a1b0 	.word	0x0001a1b0
   1225c:	10000050 	.word	0x10000050
   12260:	0001380d 	.word	0x0001380d

00012264 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>:
  /// Sets the clock rate for the Peripheral
  /// @param polarity - maintain bus on clock 0=low or 1=high between frames
  /// @param phase - capture serial data on 0=first or 1=second clock cycle
  /// @param divider - see notes in SSP_Interface above
  /// @param prescaler - divides the PCLK, must be even value between 2-254
  void SetClock(bool polarity, bool phase, uint8_t divider,
   12264:	b570      	push	{r4, r5, r6, lr}
   12266:	b098      	sub	sp, #96	; 0x60
   12268:	4674      	mov	r4, lr
   1226a:	9001      	str	r0, [sp, #4]
   1226c:	4608      	mov	r0, r1
   1226e:	4611      	mov	r1, r2
   12270:	461a      	mov	r2, r3
   12272:	4603      	mov	r3, r0
   12274:	f88d 3003 	strb.w	r3, [sp, #3]
   12278:	460b      	mov	r3, r1
   1227a:	f88d 3002 	strb.w	r3, [sp, #2]
   1227e:	4613      	mov	r3, r2
   12280:	f88d 3001 	strb.w	r3, [sp, #1]
   12284:	4623      	mov	r3, r4
   12286:	4619      	mov	r1, r3
   12288:	486c      	ldr	r0, [pc, #432]	; (1243c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   1228a:	f003 f9fd 	bl	15688 <__cyg_profile_func_enter>
                uint8_t prescaler) override
  {
    uint32_t pssp = util::Value(pssp_);
   1228e:	9b01      	ldr	r3, [sp, #4]
   12290:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12292:	4618      	mov	r0, r3
   12294:	f7ff fbee 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   12298:	4603      	mov	r3, r0
   1229a:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   1229c:	9b01      	ldr	r3, [sp, #4]
   1229e:	1d18      	adds	r0, r3, #4
   122a0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   122a2:	009b      	lsls	r3, r3, #2
   122a4:	4a66      	ldr	r2, [pc, #408]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1dc>)
   122a6:	4413      	add	r3, r2
   122a8:	4619      	mov	r1, r3
   122aa:	f7ff f9c5 	bl	11638 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    // first clear the appropriate registers
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, polarity, kPolarityBit, 1);
   122ae:	4a65      	ldr	r2, [pc, #404]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   122b0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   122b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   122b6:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   122b8:	4962      	ldr	r1, [pc, #392]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   122ba:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   122bc:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   122c0:	9308      	str	r3, [sp, #32]
   122c2:	f89d 3003 	ldrb.w	r3, [sp, #3]
   122c6:	f88d 301f 	strb.w	r3, [sp, #31]
   122ca:	2306      	movs	r3, #6
   122cc:	9306      	str	r3, [sp, #24]
   122ce:	2301      	movs	r3, #1
   122d0:	9305      	str	r3, [sp, #20]
   122d2:	4623      	mov	r3, r4
   122d4:	4619      	mov	r1, r3
   122d6:	485c      	ldr	r0, [pc, #368]	; (12448 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   122d8:	f003 f9d6 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   122dc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   122e0:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   122e2:	2320      	movs	r3, #32
   122e4:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   122e6:	9b05      	ldr	r3, [sp, #20]
   122e8:	f1c3 0320 	rsb	r3, r3, #32
   122ec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   122f0:	fa22 f303 	lsr.w	r3, r2, r3
   122f4:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   122f6:	9a02      	ldr	r2, [sp, #8]
   122f8:	9b06      	ldr	r3, [sp, #24]
   122fa:	fa02 f303 	lsl.w	r3, r2, r3
   122fe:	43db      	mvns	r3, r3
   12300:	9a08      	ldr	r2, [sp, #32]
   12302:	4013      	ands	r3, r2
   12304:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   12306:	f89d 201f 	ldrb.w	r2, [sp, #31]
   1230a:	9b02      	ldr	r3, [sp, #8]
   1230c:	401a      	ands	r2, r3
   1230e:	9b06      	ldr	r3, [sp, #24]
   12310:	fa02 f303 	lsl.w	r3, r2, r3
   12314:	9a08      	ldr	r2, [sp, #32]
   12316:	4313      	orrs	r3, r2
   12318:	9308      	str	r3, [sp, #32]
  return target;
   1231a:	9e08      	ldr	r6, [sp, #32]
   1231c:	4623      	mov	r3, r4
   1231e:	4619      	mov	r1, r3
   12320:	4849      	ldr	r0, [pc, #292]	; (12448 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   12322:	f003 f9c5 	bl	156b0 <__cyg_profile_func_exit>
   12326:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, phase, kPhaseBit, 1);
   12328:	4a46      	ldr	r2, [pc, #280]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1232a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1232c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12330:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   12332:	4944      	ldr	r1, [pc, #272]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   12334:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   12336:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   1233a:	930f      	str	r3, [sp, #60]	; 0x3c
   1233c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   12340:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   12344:	2307      	movs	r3, #7
   12346:	930d      	str	r3, [sp, #52]	; 0x34
   12348:	2301      	movs	r3, #1
   1234a:	930c      	str	r3, [sp, #48]	; 0x30
   1234c:	4623      	mov	r3, r4
   1234e:	4619      	mov	r1, r3
   12350:	483d      	ldr	r0, [pc, #244]	; (12448 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   12352:	f003 f999 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12356:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1235a:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1235c:	2320      	movs	r3, #32
   1235e:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12360:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12362:	f1c3 0320 	rsb	r3, r3, #32
   12366:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1236a:	fa22 f303 	lsr.w	r3, r2, r3
   1236e:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   12370:	9a09      	ldr	r2, [sp, #36]	; 0x24
   12372:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12374:	fa02 f303 	lsl.w	r3, r2, r3
   12378:	43db      	mvns	r3, r3
   1237a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1237c:	4013      	ands	r3, r2
   1237e:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   12380:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   12384:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12386:	401a      	ands	r2, r3
   12388:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1238a:	fa02 f303 	lsl.w	r3, r2, r3
   1238e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   12390:	4313      	orrs	r3, r2
   12392:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   12394:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   12396:	4623      	mov	r3, r4
   12398:	4619      	mov	r1, r3
   1239a:	482b      	ldr	r0, [pc, #172]	; (12448 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   1239c:	f003 f988 	bl	156b0 <__cyg_profile_func_exit>
   123a0:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, divider, kDividerBit, 8);
   123a2:	4a28      	ldr	r2, [pc, #160]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   123a4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   123a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   123aa:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   123ac:	4925      	ldr	r1, [pc, #148]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   123ae:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   123b0:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   123b4:	9316      	str	r3, [sp, #88]	; 0x58
   123b6:	f89d 3001 	ldrb.w	r3, [sp, #1]
   123ba:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   123be:	2308      	movs	r3, #8
   123c0:	9314      	str	r3, [sp, #80]	; 0x50
   123c2:	2308      	movs	r3, #8
   123c4:	9313      	str	r3, [sp, #76]	; 0x4c
   123c6:	4623      	mov	r3, r4
   123c8:	4619      	mov	r1, r3
   123ca:	4820      	ldr	r0, [pc, #128]	; (1244c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   123cc:	f003 f95c 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   123d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   123d4:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   123d6:	2320      	movs	r3, #32
   123d8:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   123da:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   123dc:	f1c3 0320 	rsb	r3, r3, #32
   123e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   123e4:	fa22 f303 	lsr.w	r3, r2, r3
   123e8:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   123ea:	9a10      	ldr	r2, [sp, #64]	; 0x40
   123ec:	9b14      	ldr	r3, [sp, #80]	; 0x50
   123ee:	fa02 f303 	lsl.w	r3, r2, r3
   123f2:	43db      	mvns	r3, r3
   123f4:	9a16      	ldr	r2, [sp, #88]	; 0x58
   123f6:	4013      	ands	r3, r2
   123f8:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   123fa:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   123fe:	9b10      	ldr	r3, [sp, #64]	; 0x40
   12400:	401a      	ands	r2, r3
   12402:	9b14      	ldr	r3, [sp, #80]	; 0x50
   12404:	fa02 f303 	lsl.w	r3, r2, r3
   12408:	9a16      	ldr	r2, [sp, #88]	; 0x58
   1240a:	4313      	orrs	r3, r2
   1240c:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   1240e:	9e16      	ldr	r6, [sp, #88]	; 0x58
   12410:	4623      	mov	r3, r4
   12412:	4619      	mov	r1, r3
   12414:	480d      	ldr	r0, [pc, #52]	; (1244c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   12416:	f003 f94b 	bl	156b0 <__cyg_profile_func_exit>
   1241a:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CPSR = prescaler;
   1241c:	4a09      	ldr	r2, [pc, #36]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1241e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   12420:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12424:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   12428:	611a      	str	r2, [r3, #16]
   1242a:	4623      	mov	r3, r4
   1242c:	4619      	mov	r1, r3
   1242e:	4803      	ldr	r0, [pc, #12]	; (1243c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   12430:	f003 f93e 	bl	156b0 <__cyg_profile_func_exit>
  }
   12434:	bf00      	nop
   12436:	b018      	add	sp, #96	; 0x60
   12438:	bd70      	pop	{r4, r5, r6, pc}
   1243a:	bf00      	nop
   1243c:	00012265 	.word	0x00012265
   12440:	0001a1b0 	.word	0x0001a1b0
   12444:	10000050 	.word	0x10000050
   12448:	00013861 	.word	0x00013861
   1244c:	00013799 	.word	0x00013799

00012450 <Ssp::GetClock()>:
  ///   0000_0000 0000_0x0x xxxx_xxxx xxxx_xxxx
  ///       polarity    = 1-bit @ bit 18
  ///       phase       = 1-bit @ bit 16
  ///       divider     = 8-bits @ bit 8
  ///       prescaler   = 8-bits @ bit 0
  uint32_t GetClock() override
   12450:	b570      	push	{r4, r5, r6, lr}
   12452:	b094      	sub	sp, #80	; 0x50
   12454:	4674      	mov	r4, lr
   12456:	9001      	str	r0, [sp, #4]
   12458:	4623      	mov	r3, r4
   1245a:	4619      	mov	r1, r3
   1245c:	4858      	ldr	r0, [pc, #352]	; (125c0 <Ssp::GetClock()+0x170>)
   1245e:	f003 f913 	bl	15688 <__cyg_profile_func_enter>
  {
    uint32_t return_val = 0;
   12462:	2300      	movs	r3, #0
   12464:	9313      	str	r3, [sp, #76]	; 0x4c
    uint32_t pssp       = util::Value(pssp_);
   12466:	9b01      	ldr	r3, [sp, #4]
   12468:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1246a:	4618      	mov	r0, r3
   1246c:	f7ff fb02 	bl	11a74 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   12470:	4603      	mov	r3, r0
   12472:	9312      	str	r3, [sp, #72]	; 0x48
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   12474:	9b01      	ldr	r3, [sp, #4]
   12476:	1d18      	adds	r0, r3, #4
   12478:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1247a:	009b      	lsls	r3, r3, #2
   1247c:	4a51      	ldr	r2, [pc, #324]	; (125c4 <Ssp::GetClock()+0x174>)
   1247e:	4413      	add	r3, r2
   12480:	4619      	mov	r1, r3
   12482:	f7ff f8d9 	bl	11638 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val =
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   12486:	4a50      	ldr	r2, [pc, #320]	; (125c8 <Ssp::GetClock()+0x178>)
   12488:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1248a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1248e:	691b      	ldr	r3, [r3, #16]
   12490:	9307      	str	r3, [sp, #28]
   12492:	2300      	movs	r3, #0
   12494:	9306      	str	r3, [sp, #24]
   12496:	2308      	movs	r3, #8
   12498:	9305      	str	r3, [sp, #20]
   1249a:	4623      	mov	r3, r4
   1249c:	4619      	mov	r1, r3
   1249e:	484b      	ldr	r0, [pc, #300]	; (125cc <Ssp::GetClock()+0x17c>)
   124a0:	f003 f8f2 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   124a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   124a8:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   124aa:	2320      	movs	r3, #32
   124ac:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   124ae:	9b05      	ldr	r3, [sp, #20]
   124b0:	f1c3 0320 	rsb	r3, r3, #32
   124b4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   124b8:	fa22 f303 	lsr.w	r3, r2, r3
   124bc:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   124be:	9a07      	ldr	r2, [sp, #28]
   124c0:	9b06      	ldr	r3, [sp, #24]
   124c2:	40da      	lsrs	r2, r3
   124c4:	9b02      	ldr	r3, [sp, #8]
   124c6:	ea02 0503 	and.w	r5, r2, r3
   124ca:	4623      	mov	r3, r4
   124cc:	4619      	mov	r1, r3
   124ce:	483f      	ldr	r0, [pc, #252]	; (125cc <Ssp::GetClock()+0x17c>)
   124d0:	f003 f8ee 	bl	156b0 <__cyg_profile_func_exit>
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   124d4:	4a3c      	ldr	r2, [pc, #240]	; (125c8 <Ssp::GetClock()+0x178>)
   124d6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   124d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124dc:	681b      	ldr	r3, [r3, #0]
   124de:	930d      	str	r3, [sp, #52]	; 0x34
   124e0:	2308      	movs	r3, #8
   124e2:	930c      	str	r3, [sp, #48]	; 0x30
   124e4:	2308      	movs	r3, #8
   124e6:	930b      	str	r3, [sp, #44]	; 0x2c
   124e8:	4623      	mov	r3, r4
   124ea:	4619      	mov	r1, r3
   124ec:	4837      	ldr	r0, [pc, #220]	; (125cc <Ssp::GetClock()+0x17c>)
   124ee:	f003 f8cb 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   124f2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   124f6:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   124f8:	2320      	movs	r3, #32
   124fa:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   124fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   124fe:	f1c3 0320 	rsb	r3, r3, #32
   12502:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12506:	fa22 f303 	lsr.w	r3, r2, r3
   1250a:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   1250c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1250e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12510:	40da      	lsrs	r2, r3
   12512:	9b08      	ldr	r3, [sp, #32]
   12514:	ea02 0603 	and.w	r6, r2, r3
   12518:	4623      	mov	r3, r4
   1251a:	4619      	mov	r1, r3
   1251c:	482b      	ldr	r0, [pc, #172]	; (125cc <Ssp::GetClock()+0x17c>)
   1251e:	f003 f8c7 	bl	156b0 <__cyg_profile_func_exit>
   12522:	0233      	lsls	r3, r6, #8
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   12524:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPhaseBit)) << 16) +
   12526:	4a28      	ldr	r2, [pc, #160]	; (125c8 <Ssp::GetClock()+0x178>)
   12528:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1252a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1252e:	681b      	ldr	r3, [r3, #0]
   12530:	930f      	str	r3, [sp, #60]	; 0x3c
   12532:	2307      	movs	r3, #7
   12534:	930e      	str	r3, [sp, #56]	; 0x38
   12536:	4623      	mov	r3, r4
   12538:	4619      	mov	r1, r3
   1253a:	4825      	ldr	r0, [pc, #148]	; (125d0 <Ssp::GetClock()+0x180>)
   1253c:	f003 f8a4 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   12540:	2201      	movs	r2, #1
   12542:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   12544:	fa02 f303 	lsl.w	r3, r2, r3
   12548:	461a      	mov	r2, r3
   1254a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1254c:	4013      	ands	r3, r2
   1254e:	2b00      	cmp	r3, #0
   12550:	bf14      	ite	ne
   12552:	2301      	movne	r3, #1
   12554:	2300      	moveq	r3, #0
   12556:	b2de      	uxtb	r6, r3
   12558:	4623      	mov	r3, r4
   1255a:	4619      	mov	r1, r3
   1255c:	481c      	ldr	r0, [pc, #112]	; (125d0 <Ssp::GetClock()+0x180>)
   1255e:	f003 f8a7 	bl	156b0 <__cyg_profile_func_exit>
   12562:	4633      	mov	r3, r6
   12564:	041b      	lsls	r3, r3, #16
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   12566:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPolarityBit)) << 18);
   12568:	4a17      	ldr	r2, [pc, #92]	; (125c8 <Ssp::GetClock()+0x178>)
   1256a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1256c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12570:	681b      	ldr	r3, [r3, #0]
   12572:	9311      	str	r3, [sp, #68]	; 0x44
   12574:	2306      	movs	r3, #6
   12576:	9310      	str	r3, [sp, #64]	; 0x40
   12578:	4623      	mov	r3, r4
   1257a:	4619      	mov	r1, r3
   1257c:	4814      	ldr	r0, [pc, #80]	; (125d0 <Ssp::GetClock()+0x180>)
   1257e:	f003 f883 	bl	15688 <__cyg_profile_func_enter>
   12582:	2201      	movs	r2, #1
   12584:	9b10      	ldr	r3, [sp, #64]	; 0x40
   12586:	fa02 f303 	lsl.w	r3, r2, r3
   1258a:	461a      	mov	r2, r3
   1258c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1258e:	4013      	ands	r3, r2
   12590:	2b00      	cmp	r3, #0
   12592:	bf14      	ite	ne
   12594:	2301      	movne	r3, #1
   12596:	2300      	moveq	r3, #0
   12598:	b2de      	uxtb	r6, r3
   1259a:	4623      	mov	r3, r4
   1259c:	4619      	mov	r1, r3
   1259e:	480c      	ldr	r0, [pc, #48]	; (125d0 <Ssp::GetClock()+0x180>)
   125a0:	f003 f886 	bl	156b0 <__cyg_profile_func_exit>
   125a4:	4633      	mov	r3, r6
   125a6:	049b      	lsls	r3, r3, #18
    return_val =
   125a8:	442b      	add	r3, r5
   125aa:	9313      	str	r3, [sp, #76]	; 0x4c

    return return_val;
   125ac:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   125ae:	4623      	mov	r3, r4
   125b0:	4619      	mov	r1, r3
   125b2:	4803      	ldr	r0, [pc, #12]	; (125c0 <Ssp::GetClock()+0x170>)
   125b4:	f003 f87c 	bl	156b0 <__cyg_profile_func_exit>
   125b8:	462b      	mov	r3, r5
  }
   125ba:	4618      	mov	r0, r3
   125bc:	b014      	add	sp, #80	; 0x50
   125be:	bd70      	pop	{r4, r5, r6, pc}
   125c0:	00012451 	.word	0x00012451
   125c4:	0001a1b0 	.word	0x0001a1b0
   125c8:	10000050 	.word	0x10000050
   125cc:	0001380d 	.word	0x0001380d
   125d0:	00013755 	.word	0x00013755

000125d4 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>:
class PixelDisplayInterface
{
 public:
  SJ2_PACKED(struct) Color_t
  {
    Color_t(bool r, bool g, bool b, uint8_t a, uint8_t bits,
   125d4:	b530      	push	{r4, r5, lr}
   125d6:	b083      	sub	sp, #12
   125d8:	4675      	mov	r5, lr
   125da:	9001      	str	r0, [sp, #4]
   125dc:	4608      	mov	r0, r1
   125de:	4611      	mov	r1, r2
   125e0:	461a      	mov	r2, r3
   125e2:	4603      	mov	r3, r0
   125e4:	f88d 3003 	strb.w	r3, [sp, #3]
   125e8:	460b      	mov	r3, r1
   125ea:	f88d 3002 	strb.w	r3, [sp, #2]
   125ee:	4613      	mov	r3, r2
   125f0:	f88d 3001 	strb.w	r3, [sp, #1]
   125f4:	462b      	mov	r3, r5
   125f6:	4619      	mov	r1, r3
   125f8:	481a      	ldr	r0, [pc, #104]	; (12664 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)+0x90>)
   125fa:	f003 f845 	bl	15688 <__cyg_profile_func_enter>
          red(r),
          green(g),
          blue(b),
          padding(0),
          color_bits(bits),
          alpha(a)
   125fe:	9a01      	ldr	r2, [sp, #4]
   12600:	7813      	ldrb	r3, [r2, #0]
   12602:	f89d 1020 	ldrb.w	r1, [sp, #32]
   12606:	f361 0300 	bfi	r3, r1, #0, #1
   1260a:	7013      	strb	r3, [r2, #0]
   1260c:	9a01      	ldr	r2, [sp, #4]
   1260e:	7813      	ldrb	r3, [r2, #0]
   12610:	f89d 1003 	ldrb.w	r1, [sp, #3]
   12614:	f361 0341 	bfi	r3, r1, #1, #1
   12618:	7013      	strb	r3, [r2, #0]
   1261a:	9a01      	ldr	r2, [sp, #4]
   1261c:	7813      	ldrb	r3, [r2, #0]
   1261e:	f89d 1002 	ldrb.w	r1, [sp, #2]
   12622:	f361 0382 	bfi	r3, r1, #2, #1
   12626:	7013      	strb	r3, [r2, #0]
   12628:	9a01      	ldr	r2, [sp, #4]
   1262a:	7813      	ldrb	r3, [r2, #0]
   1262c:	f89d 1001 	ldrb.w	r1, [sp, #1]
   12630:	f361 03c3 	bfi	r3, r1, #3, #1
   12634:	7013      	strb	r3, [r2, #0]
   12636:	9a01      	ldr	r2, [sp, #4]
   12638:	7813      	ldrb	r3, [r2, #0]
   1263a:	f36f 1307 	bfc	r3, #4, #4
   1263e:	7013      	strb	r3, [r2, #0]
   12640:	9b01      	ldr	r3, [sp, #4]
   12642:	f89d 201c 	ldrb.w	r2, [sp, #28]
   12646:	705a      	strb	r2, [r3, #1]
   12648:	9b01      	ldr	r3, [sp, #4]
   1264a:	f89d 2018 	ldrb.w	r2, [sp, #24]
   1264e:	709a      	strb	r2, [r3, #2]
    {
    }
   12650:	9c01      	ldr	r4, [sp, #4]
   12652:	462b      	mov	r3, r5
   12654:	4619      	mov	r1, r3
   12656:	4803      	ldr	r0, [pc, #12]	; (12664 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)+0x90>)
   12658:	f003 f82a 	bl	156b0 <__cyg_profile_func_exit>
   1265c:	4623      	mov	r3, r4
   1265e:	4618      	mov	r0, r3
   12660:	b003      	add	sp, #12
   12662:	bd30      	pop	{r4, r5, pc}
   12664:	000125d5 	.word	0x000125d5

00012668 <PixelDisplayInterface::Color_t::Color_t()>:
    Color_t()
   12668:	b530      	push	{r4, r5, lr}
   1266a:	b083      	sub	sp, #12
   1266c:	4675      	mov	r5, lr
   1266e:	9001      	str	r0, [sp, #4]
   12670:	462b      	mov	r3, r5
   12672:	4619      	mov	r1, r3
   12674:	4815      	ldr	r0, [pc, #84]	; (126cc <PixelDisplayInterface::Color_t::Color_t()+0x64>)
   12676:	f003 f807 	bl	15688 <__cyg_profile_func_enter>
          red(false),
          green(false),
          blue(false),
          padding(0),
          color_bits(0),
          alpha(0)
   1267a:	9a01      	ldr	r2, [sp, #4]
   1267c:	7813      	ldrb	r3, [r2, #0]
   1267e:	f36f 0300 	bfc	r3, #0, #1
   12682:	7013      	strb	r3, [r2, #0]
   12684:	9a01      	ldr	r2, [sp, #4]
   12686:	7813      	ldrb	r3, [r2, #0]
   12688:	f36f 0341 	bfc	r3, #1, #1
   1268c:	7013      	strb	r3, [r2, #0]
   1268e:	9a01      	ldr	r2, [sp, #4]
   12690:	7813      	ldrb	r3, [r2, #0]
   12692:	f36f 0382 	bfc	r3, #2, #1
   12696:	7013      	strb	r3, [r2, #0]
   12698:	9a01      	ldr	r2, [sp, #4]
   1269a:	7813      	ldrb	r3, [r2, #0]
   1269c:	f36f 03c3 	bfc	r3, #3, #1
   126a0:	7013      	strb	r3, [r2, #0]
   126a2:	9a01      	ldr	r2, [sp, #4]
   126a4:	7813      	ldrb	r3, [r2, #0]
   126a6:	f36f 1307 	bfc	r3, #4, #4
   126aa:	7013      	strb	r3, [r2, #0]
   126ac:	9b01      	ldr	r3, [sp, #4]
   126ae:	2200      	movs	r2, #0
   126b0:	705a      	strb	r2, [r3, #1]
   126b2:	9b01      	ldr	r3, [sp, #4]
   126b4:	2200      	movs	r2, #0
   126b6:	709a      	strb	r2, [r3, #2]
    {
    }
   126b8:	9c01      	ldr	r4, [sp, #4]
   126ba:	462b      	mov	r3, r5
   126bc:	4619      	mov	r1, r3
   126be:	4803      	ldr	r0, [pc, #12]	; (126cc <PixelDisplayInterface::Color_t::Color_t()+0x64>)
   126c0:	f002 fff6 	bl	156b0 <__cyg_profile_func_exit>
   126c4:	4623      	mov	r3, r4
   126c6:	4618      	mov	r0, r3
   126c8:	b003      	add	sp, #12
   126ca:	bd30      	pop	{r4, r5, pc}
   126cc:	00012669 	.word	0x00012669

000126d0 <PixelDisplayInterface::Enable()>:
  /// @returns a color object with the available colors.
  virtual Color_t AvailableColors() = 0;
  /// Configure hardware peripherals and initialize external display hardware
  virtual void Initialize() = 0;
  /// Optional method to turn on display if applicable
  virtual void Enable() {}
   126d0:	b510      	push	{r4, lr}
   126d2:	b082      	sub	sp, #8
   126d4:	4674      	mov	r4, lr
   126d6:	9001      	str	r0, [sp, #4]
   126d8:	4623      	mov	r3, r4
   126da:	4619      	mov	r1, r3
   126dc:	4805      	ldr	r0, [pc, #20]	; (126f4 <PixelDisplayInterface::Enable()+0x24>)
   126de:	f002 ffd3 	bl	15688 <__cyg_profile_func_enter>
   126e2:	4623      	mov	r3, r4
   126e4:	4619      	mov	r1, r3
   126e6:	4803      	ldr	r0, [pc, #12]	; (126f4 <PixelDisplayInterface::Enable()+0x24>)
   126e8:	f002 ffe2 	bl	156b0 <__cyg_profile_func_exit>
   126ec:	bf00      	nop
   126ee:	b002      	add	sp, #8
   126f0:	bd10      	pop	{r4, pc}
   126f2:	bf00      	nop
   126f4:	000126d1 	.word	0x000126d1

000126f8 <PixelDisplayInterface::Disable()>:
  /// Optional method to turn off display and potentially put it into a low
  /// power mode
  virtual void Disable() {}
   126f8:	b510      	push	{r4, lr}
   126fa:	b082      	sub	sp, #8
   126fc:	4674      	mov	r4, lr
   126fe:	9001      	str	r0, [sp, #4]
   12700:	4623      	mov	r3, r4
   12702:	4619      	mov	r1, r3
   12704:	4805      	ldr	r0, [pc, #20]	; (1271c <PixelDisplayInterface::Disable()+0x24>)
   12706:	f002 ffbf 	bl	15688 <__cyg_profile_func_enter>
   1270a:	4623      	mov	r3, r4
   1270c:	4619      	mov	r1, r3
   1270e:	4803      	ldr	r0, [pc, #12]	; (1271c <PixelDisplayInterface::Disable()+0x24>)
   12710:	f002 ffce 	bl	156b0 <__cyg_profile_func_exit>
   12714:	bf00      	nop
   12716:	b002      	add	sp, #8
   12718:	bd10      	pop	{r4, pc}
   1271a:	bf00      	nop
   1271c:	000126f9 	.word	0x000126f9

00012720 <PixelDisplayInterface::Update()>:
  /// @param color the color of the pixel. May be ignored on monochrome screens.
  virtual void DrawPixel(int32_t x, int32_t y, Color_t color) = 0;
  /// Update screen to match framebuffer.
  /// Implementations of this method that do not use a framebuffer, possibly
  /// due to memory constrains, can refrain from implementing this function.
  virtual void Update() {}
   12720:	b510      	push	{r4, lr}
   12722:	b082      	sub	sp, #8
   12724:	4674      	mov	r4, lr
   12726:	9001      	str	r0, [sp, #4]
   12728:	4623      	mov	r3, r4
   1272a:	4619      	mov	r1, r3
   1272c:	4805      	ldr	r0, [pc, #20]	; (12744 <PixelDisplayInterface::Update()+0x24>)
   1272e:	f002 ffab 	bl	15688 <__cyg_profile_func_enter>
   12732:	4623      	mov	r3, r4
   12734:	4619      	mov	r1, r3
   12736:	4803      	ldr	r0, [pc, #12]	; (12744 <PixelDisplayInterface::Update()+0x24>)
   12738:	f002 ffba 	bl	156b0 <__cyg_profile_func_exit>
   1273c:	bf00      	nop
   1273e:	b002      	add	sp, #8
   12740:	bd10      	pop	{r4, pc}
   12742:	bf00      	nop
   12744:	00012721 	.word	0x00012721

00012748 <PixelDisplayInterface::PixelDisplayInterface()>:
class PixelDisplayInterface
   12748:	b530      	push	{r4, r5, lr}
   1274a:	b083      	sub	sp, #12
   1274c:	4675      	mov	r5, lr
   1274e:	9001      	str	r0, [sp, #4]
   12750:	462b      	mov	r3, r5
   12752:	4619      	mov	r1, r3
   12754:	4807      	ldr	r0, [pc, #28]	; (12774 <PixelDisplayInterface::PixelDisplayInterface()+0x2c>)
   12756:	f002 ff97 	bl	15688 <__cyg_profile_func_enter>
   1275a:	4a07      	ldr	r2, [pc, #28]	; (12778 <PixelDisplayInterface::PixelDisplayInterface()+0x30>)
   1275c:	9b01      	ldr	r3, [sp, #4]
   1275e:	601a      	str	r2, [r3, #0]
   12760:	9c01      	ldr	r4, [sp, #4]
   12762:	462b      	mov	r3, r5
   12764:	4619      	mov	r1, r3
   12766:	4803      	ldr	r0, [pc, #12]	; (12774 <PixelDisplayInterface::PixelDisplayInterface()+0x2c>)
   12768:	f002 ffa2 	bl	156b0 <__cyg_profile_func_exit>
   1276c:	4623      	mov	r3, r4
   1276e:	4618      	mov	r0, r3
   12770:	b003      	add	sp, #12
   12772:	bd30      	pop	{r4, r5, pc}
   12774:	00012749 	.word	0x00012749
   12778:	0001a1f0 	.word	0x0001a1f0

0001277c <Ssd1306::Ssd1306()>:
  {
    kCommand = 0,
    kData    = 1
  };

  constexpr Ssd1306()
   1277c:	b530      	push	{r4, r5, lr}
   1277e:	b083      	sub	sp, #12
   12780:	4675      	mov	r5, lr
   12782:	9001      	str	r0, [sp, #4]
   12784:	462b      	mov	r3, r5
   12786:	4619      	mov	r1, r3
   12788:	481f      	ldr	r0, [pc, #124]	; (12808 <Ssd1306::Ssd1306()+0x8c>)
   1278a:	f002 ff7d 	bl	15688 <__cyg_profile_func_enter>
        cs_(&cs_gpio_),
        dc_(&dc_gpio_),
        ssp1_(Ssp::Peripheral::kSsp1),
        cs_gpio_(1, 22),
        dc_gpio_(1, 25),
        bitmap_{}
   1278e:	9b01      	ldr	r3, [sp, #4]
   12790:	4618      	mov	r0, r3
   12792:	f7ff ffd9 	bl	12748 <PixelDisplayInterface::PixelDisplayInterface()>
   12796:	4a1d      	ldr	r2, [pc, #116]	; (1280c <Ssd1306::Ssd1306()+0x90>)
   12798:	9b01      	ldr	r3, [sp, #4]
   1279a:	601a      	str	r2, [r3, #0]
      : ssp_(&ssp1_),
   1279c:	9b01      	ldr	r3, [sp, #4]
   1279e:	f103 0210 	add.w	r2, r3, #16
        bitmap_{}
   127a2:	9b01      	ldr	r3, [sp, #4]
   127a4:	605a      	str	r2, [r3, #4]
        cs_(&cs_gpio_),
   127a6:	9b01      	ldr	r3, [sp, #4]
   127a8:	f103 0240 	add.w	r2, r3, #64	; 0x40
        bitmap_{}
   127ac:	9b01      	ldr	r3, [sp, #4]
   127ae:	609a      	str	r2, [r3, #8]
        dc_(&dc_gpio_),
   127b0:	9b01      	ldr	r3, [sp, #4]
   127b2:	f103 0254 	add.w	r2, r3, #84	; 0x54
        bitmap_{}
   127b6:	9b01      	ldr	r3, [sp, #4]
   127b8:	60da      	str	r2, [r3, #12]
   127ba:	9b01      	ldr	r3, [sp, #4]
   127bc:	3310      	adds	r3, #16
   127be:	2101      	movs	r1, #1
   127c0:	4618      	mov	r0, r3
   127c2:	f7ff f9cd 	bl	11b60 <Ssp::Ssp(Ssp::Peripheral)>
   127c6:	9b01      	ldr	r3, [sp, #4]
   127c8:	3340      	adds	r3, #64	; 0x40
   127ca:	2216      	movs	r2, #22
   127cc:	2101      	movs	r1, #1
   127ce:	4618      	mov	r0, r3
   127d0:	f7fe f9d6 	bl	10b80 <Gpio::Gpio(unsigned char, unsigned char)>
   127d4:	9b01      	ldr	r3, [sp, #4]
   127d6:	3354      	adds	r3, #84	; 0x54
   127d8:	2219      	movs	r2, #25
   127da:	2101      	movs	r1, #1
   127dc:	4618      	mov	r0, r3
   127de:	f7fe f9cf 	bl	10b80 <Gpio::Gpio(unsigned char, unsigned char)>
   127e2:	9b01      	ldr	r3, [sp, #4]
   127e4:	3368      	adds	r3, #104	; 0x68
   127e6:	f240 62c1 	movw	r2, #1729	; 0x6c1
   127ea:	2100      	movs	r1, #0
   127ec:	4618      	mov	r0, r3
   127ee:	f007 f874 	bl	198da <memset>
  {
  }
   127f2:	9c01      	ldr	r4, [sp, #4]
   127f4:	462b      	mov	r3, r5
   127f6:	4619      	mov	r1, r3
   127f8:	4803      	ldr	r0, [pc, #12]	; (12808 <Ssd1306::Ssd1306()+0x8c>)
   127fa:	f002 ff59 	bl	156b0 <__cyg_profile_func_exit>
   127fe:	4623      	mov	r3, r4
   12800:	4618      	mov	r0, r3
   12802:	b003      	add	sp, #12
   12804:	bd30      	pop	{r4, r5, pc}
   12806:	bf00      	nop
   12808:	0001277d 	.word	0x0001277d
   1280c:	0001a1c4 	.word	0x0001a1c4

00012810 <Ssd1306::GetWidth()>:
        dc_gpio_(1, 25),
        bitmap_{}
  {
  }

  size_t GetWidth() final override
   12810:	b530      	push	{r4, r5, lr}
   12812:	b083      	sub	sp, #12
   12814:	4675      	mov	r5, lr
   12816:	9001      	str	r0, [sp, #4]
   12818:	462b      	mov	r3, r5
   1281a:	4619      	mov	r1, r3
   1281c:	4806      	ldr	r0, [pc, #24]	; (12838 <Ssd1306::GetWidth()+0x28>)
   1281e:	f002 ff33 	bl	15688 <__cyg_profile_func_enter>
  {
    return kWidth;
   12822:	2480      	movs	r4, #128	; 0x80
   12824:	462b      	mov	r3, r5
   12826:	4619      	mov	r1, r3
   12828:	4803      	ldr	r0, [pc, #12]	; (12838 <Ssd1306::GetWidth()+0x28>)
   1282a:	f002 ff41 	bl	156b0 <__cyg_profile_func_exit>
   1282e:	4623      	mov	r3, r4
  }
   12830:	4618      	mov	r0, r3
   12832:	b003      	add	sp, #12
   12834:	bd30      	pop	{r4, r5, pc}
   12836:	bf00      	nop
   12838:	00012811 	.word	0x00012811

0001283c <Ssd1306::GetHeight()>:
  size_t GetHeight() final override
   1283c:	b530      	push	{r4, r5, lr}
   1283e:	b083      	sub	sp, #12
   12840:	4675      	mov	r5, lr
   12842:	9001      	str	r0, [sp, #4]
   12844:	462b      	mov	r3, r5
   12846:	4619      	mov	r1, r3
   12848:	4806      	ldr	r0, [pc, #24]	; (12864 <Ssd1306::GetHeight()+0x28>)
   1284a:	f002 ff1d 	bl	15688 <__cyg_profile_func_enter>
  {
    return kHeight;
   1284e:	2440      	movs	r4, #64	; 0x40
   12850:	462b      	mov	r3, r5
   12852:	4619      	mov	r1, r3
   12854:	4803      	ldr	r0, [pc, #12]	; (12864 <Ssd1306::GetHeight()+0x28>)
   12856:	f002 ff2b 	bl	156b0 <__cyg_profile_func_exit>
   1285a:	4623      	mov	r3, r4
  }
   1285c:	4618      	mov	r0, r3
   1285e:	b003      	add	sp, #12
   12860:	bd30      	pop	{r4, r5, pc}
   12862:	bf00      	nop
   12864:	0001283d 	.word	0x0001283d

00012868 <Ssd1306::AvailableColors()>:
  Color_t AvailableColors() final override
   12868:	b510      	push	{r4, lr}
   1286a:	b088      	sub	sp, #32
   1286c:	4674      	mov	r4, lr
   1286e:	9005      	str	r0, [sp, #20]
   12870:	4623      	mov	r3, r4
   12872:	4619      	mov	r1, r3
   12874:	4815      	ldr	r0, [pc, #84]	; (128cc <Ssd1306::AvailableColors()+0x64>)
   12876:	f002 ff07 	bl	15688 <__cyg_profile_func_enter>
  {
    return Color_t(/* Red        = */ 1,
   1287a:	a807      	add	r0, sp, #28
   1287c:	2301      	movs	r3, #1
   1287e:	9302      	str	r3, [sp, #8]
   12880:	2301      	movs	r3, #1
   12882:	9301      	str	r3, [sp, #4]
   12884:	2301      	movs	r3, #1
   12886:	9300      	str	r3, [sp, #0]
   12888:	2301      	movs	r3, #1
   1288a:	2201      	movs	r2, #1
   1288c:	2101      	movs	r1, #1
   1288e:	f7ff fea1 	bl	125d4 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>
                   /* Green      = */ 1,
                   /* Blue       = */ 1,
                   /* Alpha      = */ 1,
                   /* Color Bits = */ 1,
                   /* Monochrome = */ true);
   12892:	ab06      	add	r3, sp, #24
   12894:	aa07      	add	r2, sp, #28
   12896:	6812      	ldr	r2, [r2, #0]
   12898:	4611      	mov	r1, r2
   1289a:	8019      	strh	r1, [r3, #0]
   1289c:	3302      	adds	r3, #2
   1289e:	0c12      	lsrs	r2, r2, #16
   128a0:	701a      	strb	r2, [r3, #0]
   128a2:	4623      	mov	r3, r4
   128a4:	4619      	mov	r1, r3
   128a6:	4809      	ldr	r0, [pc, #36]	; (128cc <Ssd1306::AvailableColors()+0x64>)
   128a8:	f002 ff02 	bl	156b0 <__cyg_profile_func_exit>
   128ac:	2300      	movs	r3, #0
   128ae:	f89d 2018 	ldrb.w	r2, [sp, #24]
   128b2:	f362 0307 	bfi	r3, r2, #0, #8
   128b6:	f89d 2019 	ldrb.w	r2, [sp, #25]
   128ba:	f362 230f 	bfi	r3, r2, #8, #8
   128be:	f89d 201a 	ldrb.w	r2, [sp, #26]
   128c2:	f362 4317 	bfi	r3, r2, #16, #8
  }
   128c6:	4618      	mov	r0, r3
   128c8:	b008      	add	sp, #32
   128ca:	bd10      	pop	{r4, pc}
   128cc:	00012869 	.word	0x00012869

000128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>:

  void Write(uint32_t data, Transaction transaction, size_t size = 1)
   128d0:	b510      	push	{r4, lr}
   128d2:	b086      	sub	sp, #24
   128d4:	4674      	mov	r4, lr
   128d6:	9003      	str	r0, [sp, #12]
   128d8:	9102      	str	r1, [sp, #8]
   128da:	9201      	str	r2, [sp, #4]
   128dc:	9300      	str	r3, [sp, #0]
   128de:	4623      	mov	r3, r4
   128e0:	4619      	mov	r1, r3
   128e2:	481e      	ldr	r0, [pc, #120]	; (1295c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x8c>)
   128e4:	f002 fed0 	bl	15688 <__cyg_profile_func_enter>
  {
    dc_->Set(static_cast<Gpio::State>(transaction));
   128e8:	9b03      	ldr	r3, [sp, #12]
   128ea:	68db      	ldr	r3, [r3, #12]
   128ec:	9a01      	ldr	r2, [sp, #4]
   128ee:	b2d2      	uxtb	r2, r2
   128f0:	4611      	mov	r1, r2
   128f2:	4618      	mov	r0, r3
   128f4:	f7fe fa84 	bl	10e00 <Gpio::Set(GpioInterface::State)>
    cs_->SetLow();
   128f8:	9b03      	ldr	r3, [sp, #12]
   128fa:	689b      	ldr	r3, [r3, #8]
   128fc:	4618      	mov	r0, r3
   128fe:	f7fe fa4d 	bl	10d9c <Gpio::SetLow()>
    for (size_t i = 0; i < size; i++)
   12902:	2300      	movs	r3, #0
   12904:	9305      	str	r3, [sp, #20]
   12906:	9a05      	ldr	r2, [sp, #20]
   12908:	9b00      	ldr	r3, [sp, #0]
   1290a:	429a      	cmp	r2, r3
   1290c:	d218      	bcs.n	12940 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x70>
    {
      uint8_t send = static_cast<uint8_t>(data >> (((size - 1) - i) * 8));
   1290e:	9a00      	ldr	r2, [sp, #0]
   12910:	9b05      	ldr	r3, [sp, #20]
   12912:	1ad3      	subs	r3, r2, r3
   12914:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   12918:	3b01      	subs	r3, #1
   1291a:	00db      	lsls	r3, r3, #3
   1291c:	9a02      	ldr	r2, [sp, #8]
   1291e:	fa22 f303 	lsr.w	r3, r2, r3
   12922:	f88d 3013 	strb.w	r3, [sp, #19]
      if (transaction == Transaction::kCommand)
      {
        LOG_DEBUG("send = 0x%X", send);
      }
      ssp_->Transfer(send);
   12926:	9b03      	ldr	r3, [sp, #12]
   12928:	685b      	ldr	r3, [r3, #4]
   1292a:	f89d 2013 	ldrb.w	r2, [sp, #19]
   1292e:	b292      	uxth	r2, r2
   12930:	4611      	mov	r1, r2
   12932:	4618      	mov	r0, r3
   12934:	f7ff fa34 	bl	11da0 <Ssp::Transfer(unsigned short)>
    for (size_t i = 0; i < size; i++)
   12938:	9b05      	ldr	r3, [sp, #20]
   1293a:	3301      	adds	r3, #1
   1293c:	9305      	str	r3, [sp, #20]
   1293e:	e7e2      	b.n	12906 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x36>
    }
    cs_->SetHigh();
   12940:	9b03      	ldr	r3, [sp, #12]
   12942:	689b      	ldr	r3, [r3, #8]
   12944:	4618      	mov	r0, r3
   12946:	f7fe f9f7 	bl	10d38 <Gpio::SetHigh()>
   1294a:	4623      	mov	r3, r4
   1294c:	4619      	mov	r1, r3
   1294e:	4803      	ldr	r0, [pc, #12]	; (1295c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x8c>)
   12950:	f002 feae 	bl	156b0 <__cyg_profile_func_exit>
  }
   12954:	bf00      	nop
   12956:	b006      	add	sp, #24
   12958:	bd10      	pop	{r4, pc}
   1295a:	bf00      	nop
   1295c:	000128d1 	.word	0x000128d1

00012960 <Ssd1306::InitializationPanel()>:

  void InitializationPanel()
   12960:	b510      	push	{r4, lr}
   12962:	b082      	sub	sp, #8
   12964:	4674      	mov	r4, lr
   12966:	9001      	str	r0, [sp, #4]
   12968:	4623      	mov	r3, r4
   1296a:	4619      	mov	r1, r3
   1296c:	4837      	ldr	r0, [pc, #220]	; (12a4c <Ssd1306::InitializationPanel()+0xec>)
   1296e:	f002 fe8b 	bl	15688 <__cyg_profile_func_enter>
  {
    // This sequence of commands was found in:
    //   datasheets/OLED-display/ER-OLED0.96-1_Series_Datasheet.pdf, page 15

    // turn off oled panel
    Write(0xAE, Transaction::kCommand);
   12972:	2301      	movs	r3, #1
   12974:	2200      	movs	r2, #0
   12976:	21ae      	movs	r1, #174	; 0xae
   12978:	9801      	ldr	r0, [sp, #4]
   1297a:	f7ff ffa9 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set display clock divide ratio/oscillator frequency
    // set divide ratio
    Write(0xD5'80, Transaction::kCommand, 2);
   1297e:	2302      	movs	r3, #2
   12980:	2200      	movs	r2, #0
   12982:	f24d 5180 	movw	r1, #54656	; 0xd580
   12986:	9801      	ldr	r0, [sp, #4]
   12988:	f7ff ffa2 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set multiplex ratio(1 to 64)
    // 1/64 duty
    Write(0xA8'3F, Transaction::kCommand, 2);
   1298c:	2302      	movs	r3, #2
   1298e:	2200      	movs	r2, #0
   12990:	f64a 013f 	movw	r1, #43071	; 0xa83f
   12994:	9801      	ldr	r0, [sp, #4]
   12996:	f7ff ff9b 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set display offset = not offset
    Write(0xD3'00, Transaction::kCommand, 2);
   1299a:	2302      	movs	r3, #2
   1299c:	2200      	movs	r2, #0
   1299e:	f44f 4153 	mov.w	r1, #54016	; 0xd300
   129a2:	9801      	ldr	r0, [sp, #4]
   129a4:	f7ff ff94 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set display start line
    Write(0x40, Transaction::kCommand);
   129a8:	2301      	movs	r3, #1
   129aa:	2200      	movs	r2, #0
   129ac:	2140      	movs	r1, #64	; 0x40
   129ae:	9801      	ldr	r0, [sp, #4]
   129b0:	f7ff ff8e 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Disable Charge Pump
    Write(0x8D'14, Transaction::kCommand, 2);
   129b4:	2302      	movs	r3, #2
   129b6:	2200      	movs	r2, #0
   129b8:	f648 5114 	movw	r1, #36116	; 0x8d14
   129bc:	9801      	ldr	r0, [sp, #4]
   129be:	f7ff ff87 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set segment re-map 128 to 0
    Write(0xA1, Transaction::kCommand);
   129c2:	2301      	movs	r3, #1
   129c4:	2200      	movs	r2, #0
   129c6:	21a1      	movs	r1, #161	; 0xa1
   129c8:	9801      	ldr	r0, [sp, #4]
   129ca:	f7ff ff81 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set COM Output Scan Direction 64 to 0
    Write(0xC8, Transaction::kCommand);
   129ce:	2301      	movs	r3, #1
   129d0:	2200      	movs	r2, #0
   129d2:	21c8      	movs	r1, #200	; 0xc8
   129d4:	9801      	ldr	r0, [sp, #4]
   129d6:	f7ff ff7b 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set com pins hardware configuration
    Write(0xDA'12, Transaction::kCommand, 2);
   129da:	2302      	movs	r3, #2
   129dc:	2200      	movs	r2, #0
   129de:	f64d 2112 	movw	r1, #55826	; 0xda12
   129e2:	9801      	ldr	r0, [sp, #4]
   129e4:	f7ff ff74 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set contrast control register
    Write(0x81'CF, Transaction::kCommand, 2);
   129e8:	2302      	movs	r3, #2
   129ea:	2200      	movs	r2, #0
   129ec:	f248 11cf 	movw	r1, #33231	; 0x81cf
   129f0:	9801      	ldr	r0, [sp, #4]
   129f2:	f7ff ff6d 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set pre-charge period
    Write(0xD9'F1, Transaction::kCommand, 2);
   129f6:	2302      	movs	r3, #2
   129f8:	2200      	movs	r2, #0
   129fa:	f64d 11f1 	movw	r1, #55793	; 0xd9f1
   129fe:	9801      	ldr	r0, [sp, #4]
   12a00:	f7ff ff66 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set Vcomh
    Write(0xDB'40, Transaction::kCommand, 2);
   12a04:	2302      	movs	r3, #2
   12a06:	2200      	movs	r2, #0
   12a08:	f64d 3140 	movw	r1, #56128	; 0xdb40
   12a0c:	9801      	ldr	r0, [sp, #4]
   12a0e:	f7ff ff5f 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    SetHorizontalAddressMode();
   12a12:	9801      	ldr	r0, [sp, #4]
   12a14:	f000 f85e 	bl	12ad4 <Ssd1306::SetHorizontalAddressMode()>

    // Enable entire display
    Write(0xA4, Transaction::kCommand);
   12a18:	2301      	movs	r3, #1
   12a1a:	2200      	movs	r2, #0
   12a1c:	21a4      	movs	r1, #164	; 0xa4
   12a1e:	9801      	ldr	r0, [sp, #4]
   12a20:	f7ff ff56 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set display to normal colors
    Write(0xA6, Transaction::kCommand);
   12a24:	2301      	movs	r3, #1
   12a26:	2200      	movs	r2, #0
   12a28:	21a6      	movs	r1, #166	; 0xa6
   12a2a:	9801      	ldr	r0, [sp, #4]
   12a2c:	f7ff ff50 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set Display On
    Write(0xAF, Transaction::kCommand);
   12a30:	2301      	movs	r3, #1
   12a32:	2200      	movs	r2, #0
   12a34:	21af      	movs	r1, #175	; 0xaf
   12a36:	9801      	ldr	r0, [sp, #4]
   12a38:	f7ff ff4a 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
   12a3c:	4623      	mov	r3, r4
   12a3e:	4619      	mov	r1, r3
   12a40:	4802      	ldr	r0, [pc, #8]	; (12a4c <Ssd1306::InitializationPanel()+0xec>)
   12a42:	f002 fe35 	bl	156b0 <__cyg_profile_func_exit>
  }
   12a46:	bf00      	nop
   12a48:	b002      	add	sp, #8
   12a4a:	bd10      	pop	{r4, pc}
   12a4c:	00012961 	.word	0x00012961

00012a50 <Ssd1306::Initialize()>:

  void Initialize() final override
   12a50:	b510      	push	{r4, lr}
   12a52:	b084      	sub	sp, #16
   12a54:	4674      	mov	r4, lr
   12a56:	9003      	str	r0, [sp, #12]
   12a58:	4623      	mov	r3, r4
   12a5a:	4619      	mov	r1, r3
   12a5c:	481c      	ldr	r0, [pc, #112]	; (12ad0 <Ssd1306::Initialize()+0x80>)
   12a5e:	f002 fe13 	bl	15688 <__cyg_profile_func_enter>
  {
    cs_->SetAsOutput();
   12a62:	9b03      	ldr	r3, [sp, #12]
   12a64:	689b      	ldr	r3, [r3, #8]
   12a66:	4618      	mov	r0, r3
   12a68:	f7fe f906 	bl	10c78 <Gpio::SetAsOutput()>
    dc_->SetAsOutput();
   12a6c:	9b03      	ldr	r3, [sp, #12]
   12a6e:	68db      	ldr	r3, [r3, #12]
   12a70:	4618      	mov	r0, r3
   12a72:	f7fe f901 	bl	10c78 <Gpio::SetAsOutput()>
    cs_->SetHigh();
   12a76:	9b03      	ldr	r3, [sp, #12]
   12a78:	689b      	ldr	r3, [r3, #8]
   12a7a:	4618      	mov	r0, r3
   12a7c:	f7fe f95c 	bl	10d38 <Gpio::SetHigh()>
    dc_->SetHigh();
   12a80:	9b03      	ldr	r3, [sp, #12]
   12a82:	68db      	ldr	r3, [r3, #12]
   12a84:	4618      	mov	r0, r3
   12a86:	f7fe f957 	bl	10d38 <Gpio::SetHigh()>

    ssp_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster, Ssp::FrameMode::kSpi,
   12a8a:	9b03      	ldr	r3, [sp, #12]
   12a8c:	6858      	ldr	r0, [r3, #4]
   12a8e:	2307      	movs	r3, #7
   12a90:	2200      	movs	r2, #0
   12a92:	2100      	movs	r1, #0
   12a94:	f7ff fa30 	bl	11ef8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
                            Ssp::DataSize::kEight);
    // Set speed to 1Mhz by dividing by 1 * ClockFrequencyInMHz.
    ssp_->SetClock(false, false, 1, config::kSystemClockRateMhz/3);
   12a98:	9b03      	ldr	r3, [sp, #12]
   12a9a:	6858      	ldr	r0, [r3, #4]
   12a9c:	2310      	movs	r3, #16
   12a9e:	9300      	str	r3, [sp, #0]
   12aa0:	2301      	movs	r3, #1
   12aa2:	2200      	movs	r2, #0
   12aa4:	2100      	movs	r1, #0
   12aa6:	f7ff fbdd 	bl	12264 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
    ssp_->Initialize();
   12aaa:	9b03      	ldr	r3, [sp, #12]
   12aac:	685b      	ldr	r3, [r3, #4]
   12aae:	4618      	mov	r0, r3
   12ab0:	f7ff f8c8 	bl	11c44 <Ssp::Initialize()>

    Clear();
   12ab4:	9803      	ldr	r0, [sp, #12]
   12ab6:	f000 f837 	bl	12b28 <Ssd1306::Clear()>
    InitializationPanel();
   12aba:	9803      	ldr	r0, [sp, #12]
   12abc:	f7ff ff50 	bl	12960 <Ssd1306::InitializationPanel()>
   12ac0:	4623      	mov	r3, r4
   12ac2:	4619      	mov	r1, r3
   12ac4:	4802      	ldr	r0, [pc, #8]	; (12ad0 <Ssd1306::Initialize()+0x80>)
   12ac6:	f002 fdf3 	bl	156b0 <__cyg_profile_func_exit>
  }
   12aca:	bf00      	nop
   12acc:	b004      	add	sp, #16
   12ace:	bd10      	pop	{r4, pc}
   12ad0:	00012a51 	.word	0x00012a51

00012ad4 <Ssd1306::SetHorizontalAddressMode()>:

  void SetHorizontalAddressMode()
   12ad4:	b510      	push	{r4, lr}
   12ad6:	b082      	sub	sp, #8
   12ad8:	4674      	mov	r4, lr
   12ada:	9001      	str	r0, [sp, #4]
   12adc:	4623      	mov	r3, r4
   12ade:	4619      	mov	r1, r3
   12ae0:	480e      	ldr	r0, [pc, #56]	; (12b1c <Ssd1306::SetHorizontalAddressMode()+0x48>)
   12ae2:	f002 fdd1 	bl	15688 <__cyg_profile_func_enter>
  {
    // Set Addressing mode
    // Addressing mode = Horizontal Mode (0b00)
    Write(0x20'00, Transaction::kCommand, 2);
   12ae6:	2302      	movs	r3, #2
   12ae8:	2200      	movs	r2, #0
   12aea:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   12aee:	9801      	ldr	r0, [sp, #4]
   12af0:	f7ff feee 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
    // Set Column Addresses
    // Set Column Address start = Column 0
    // Set Column Address start = Column 127
    Write(0x21'00'7F, Transaction::kCommand, 3);
   12af4:	2303      	movs	r3, #3
   12af6:	2200      	movs	r2, #0
   12af8:	4909      	ldr	r1, [pc, #36]	; (12b20 <Ssd1306::SetHorizontalAddressMode()+0x4c>)
   12afa:	9801      	ldr	r0, [sp, #4]
   12afc:	f7ff fee8 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
    // Set Page Addresses
    // Set Page Address start = Page 0
    // Set Page Address start = Page 7
    Write(0x22'00'07, Transaction::kCommand, 3);
   12b00:	2303      	movs	r3, #3
   12b02:	2200      	movs	r2, #0
   12b04:	4907      	ldr	r1, [pc, #28]	; (12b24 <Ssd1306::SetHorizontalAddressMode()+0x50>)
   12b06:	9801      	ldr	r0, [sp, #4]
   12b08:	f7ff fee2 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
   12b0c:	4623      	mov	r3, r4
   12b0e:	4619      	mov	r1, r3
   12b10:	4802      	ldr	r0, [pc, #8]	; (12b1c <Ssd1306::SetHorizontalAddressMode()+0x48>)
   12b12:	f002 fdcd 	bl	156b0 <__cyg_profile_func_exit>
  }
   12b16:	bf00      	nop
   12b18:	b002      	add	sp, #8
   12b1a:	bd10      	pop	{r4, pc}
   12b1c:	00012ad5 	.word	0x00012ad5
   12b20:	0021007f 	.word	0x0021007f
   12b24:	00220007 	.word	0x00220007

00012b28 <Ssd1306::Clear()>:
  /// Clears the internal bitmap_ to zero (or a user defined clear_value)
  void Clear() final override
   12b28:	b510      	push	{r4, lr}
   12b2a:	b082      	sub	sp, #8
   12b2c:	4674      	mov	r4, lr
   12b2e:	9001      	str	r0, [sp, #4]
   12b30:	4623      	mov	r3, r4
   12b32:	4619      	mov	r1, r3
   12b34:	4809      	ldr	r0, [pc, #36]	; (12b5c <Ssd1306::Clear()+0x34>)
   12b36:	f002 fda7 	bl	15688 <__cyg_profile_func_enter>
  {
    memset(bitmap_, 0x00, sizeof(bitmap_));
   12b3a:	9b01      	ldr	r3, [sp, #4]
   12b3c:	3368      	adds	r3, #104	; 0x68
   12b3e:	f240 62c1 	movw	r2, #1729	; 0x6c1
   12b42:	2100      	movs	r1, #0
   12b44:	4618      	mov	r0, r3
   12b46:	f006 fec8 	bl	198da <memset>
   12b4a:	4623      	mov	r3, r4
   12b4c:	4619      	mov	r1, r3
   12b4e:	4803      	ldr	r0, [pc, #12]	; (12b5c <Ssd1306::Clear()+0x34>)
   12b50:	f002 fdae 	bl	156b0 <__cyg_profile_func_exit>
  }
   12b54:	bf00      	nop
   12b56:	b002      	add	sp, #8
   12b58:	bd10      	pop	{r4, pc}
   12b5a:	bf00      	nop
   12b5c:	00012b29 	.word	0x00012b29

00012b60 <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)>:
  void Fill()
  {
    memset(bitmap_, 0xFF, sizeof(bitmap_));
  }
  void DrawPixel(int32_t x, int32_t y, Color_t color) final override
   12b60:	b510      	push	{r4, lr}
   12b62:	b08c      	sub	sp, #48	; 0x30
   12b64:	4674      	mov	r4, lr
   12b66:	9003      	str	r0, [sp, #12]
   12b68:	9102      	str	r1, [sp, #8]
   12b6a:	9201      	str	r2, [sp, #4]
   12b6c:	9300      	str	r3, [sp, #0]
   12b6e:	4623      	mov	r3, r4
   12b70:	4619      	mov	r1, r3
   12b72:	481f      	ldr	r0, [pc, #124]	; (12bf0 <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)+0x90>)
   12b74:	f002 fd88 	bl	15688 <__cyg_profile_func_enter>
  {
    // The 3 least significant bits hold the bit position within the byte
    uint32_t bit_position = y & 0b111;
   12b78:	9b01      	ldr	r3, [sp, #4]
   12b7a:	f003 0307 	and.w	r3, r3, #7
   12b7e:	930b      	str	r3, [sp, #44]	; 0x2c
    // Each byte makes up a vertical column.
    // Shifting by 3, which also divides by 8 (the 8-bits of a column), will
    // be the row that we need to edit.
    uint32_t row = y >> 3;
   12b80:	9b01      	ldr	r3, [sp, #4]
   12b82:	10db      	asrs	r3, r3, #3
   12b84:	930a      	str	r3, [sp, #40]	; 0x28
    // Mask to clear the bit
    uint32_t clear_mask = ~(1 << bit_position);
   12b86:	2201      	movs	r2, #1
   12b88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12b8a:	fa02 f303 	lsl.w	r3, r2, r3
   12b8e:	43db      	mvns	r3, r3
   12b90:	9309      	str	r3, [sp, #36]	; 0x24
    // Mask to set the bit, if color.alpha != 0
    bool pixel_is_on  = (color.alpha != 0);
   12b92:	f89d 3002 	ldrb.w	r3, [sp, #2]
   12b96:	2b00      	cmp	r3, #0
   12b98:	bf14      	ite	ne
   12b9a:	2301      	movne	r3, #1
   12b9c:	2300      	moveq	r3, #0
   12b9e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint32_t set_mask = pixel_is_on << bit_position;
   12ba2:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
   12ba6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12ba8:	fa02 f303 	lsl.w	r3, r2, r3
   12bac:	9307      	str	r3, [sp, #28]
    // Address of the pixel column to edit
    uint8_t * pixel_column = &(bitmap_[row][x]);
   12bae:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   12bb0:	4613      	mov	r3, r2
   12bb2:	015b      	lsls	r3, r3, #5
   12bb4:	4413      	add	r3, r2
   12bb6:	009b      	lsls	r3, r3, #2
   12bb8:	4413      	add	r3, r2
   12bba:	9a02      	ldr	r2, [sp, #8]
   12bbc:	4413      	add	r3, r2
   12bbe:	3368      	adds	r3, #104	; 0x68
   12bc0:	9a03      	ldr	r2, [sp, #12]
   12bc2:	4413      	add	r3, r2
   12bc4:	9306      	str	r3, [sp, #24]
    // Read pixel column and update the pixel
    uint32_t result = (*pixel_column & clear_mask) | set_mask;
   12bc6:	9b06      	ldr	r3, [sp, #24]
   12bc8:	781b      	ldrb	r3, [r3, #0]
   12bca:	461a      	mov	r2, r3
   12bcc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12bce:	4013      	ands	r3, r2
   12bd0:	9a07      	ldr	r2, [sp, #28]
   12bd2:	4313      	orrs	r3, r2
   12bd4:	9305      	str	r3, [sp, #20]
    // Update pixel with the result of this operation
    *pixel_column = static_cast<uint8_t>(result);
   12bd6:	9b05      	ldr	r3, [sp, #20]
   12bd8:	b2da      	uxtb	r2, r3
   12bda:	9b06      	ldr	r3, [sp, #24]
   12bdc:	701a      	strb	r2, [r3, #0]
   12bde:	4623      	mov	r3, r4
   12be0:	4619      	mov	r1, r3
   12be2:	4803      	ldr	r0, [pc, #12]	; (12bf0 <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)+0x90>)
   12be4:	f002 fd64 	bl	156b0 <__cyg_profile_func_exit>
  }
   12be8:	bf00      	nop
   12bea:	b00c      	add	sp, #48	; 0x30
   12bec:	bd10      	pop	{r4, pc}
   12bee:	bf00      	nop
   12bf0:	00012b61 	.word	0x00012b61

00012bf4 <Ssd1306::Update()>:
  /// Writes internal bitmap_ to the screen
  void Update() final override
   12bf4:	b510      	push	{r4, lr}
   12bf6:	b084      	sub	sp, #16
   12bf8:	4674      	mov	r4, lr
   12bfa:	9001      	str	r0, [sp, #4]
   12bfc:	4623      	mov	r3, r4
   12bfe:	4619      	mov	r1, r3
   12c00:	4818      	ldr	r0, [pc, #96]	; (12c64 <Ssd1306::Update()+0x70>)
   12c02:	f002 fd41 	bl	15688 <__cyg_profile_func_enter>
  {
    SetHorizontalAddressMode();
   12c06:	9801      	ldr	r0, [sp, #4]
   12c08:	f7ff ff64 	bl	12ad4 <Ssd1306::SetHorizontalAddressMode()>
    for (size_t row = 0; row < kRows; row++)
   12c0c:	2300      	movs	r3, #0
   12c0e:	9303      	str	r3, [sp, #12]
   12c10:	9b03      	ldr	r3, [sp, #12]
   12c12:	2b07      	cmp	r3, #7
   12c14:	d81e      	bhi.n	12c54 <Ssd1306::Update()+0x60>
    {
      for (size_t column = 0; column < kColumns; column++)
   12c16:	2300      	movs	r3, #0
   12c18:	9302      	str	r3, [sp, #8]
   12c1a:	9b02      	ldr	r3, [sp, #8]
   12c1c:	2b7f      	cmp	r3, #127	; 0x7f
   12c1e:	d815      	bhi.n	12c4c <Ssd1306::Update()+0x58>
      {
        Write(bitmap_[row][column], Transaction::kData);
   12c20:	9901      	ldr	r1, [sp, #4]
   12c22:	9a03      	ldr	r2, [sp, #12]
   12c24:	4613      	mov	r3, r2
   12c26:	015b      	lsls	r3, r3, #5
   12c28:	4413      	add	r3, r2
   12c2a:	009b      	lsls	r3, r3, #2
   12c2c:	4413      	add	r3, r2
   12c2e:	18ca      	adds	r2, r1, r3
   12c30:	9b02      	ldr	r3, [sp, #8]
   12c32:	4413      	add	r3, r2
   12c34:	3368      	adds	r3, #104	; 0x68
   12c36:	781b      	ldrb	r3, [r3, #0]
   12c38:	4619      	mov	r1, r3
   12c3a:	2301      	movs	r3, #1
   12c3c:	2201      	movs	r2, #1
   12c3e:	9801      	ldr	r0, [sp, #4]
   12c40:	f7ff fe46 	bl	128d0 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
      for (size_t column = 0; column < kColumns; column++)
   12c44:	9b02      	ldr	r3, [sp, #8]
   12c46:	3301      	adds	r3, #1
   12c48:	9302      	str	r3, [sp, #8]
   12c4a:	e7e6      	b.n	12c1a <Ssd1306::Update()+0x26>
    for (size_t row = 0; row < kRows; row++)
   12c4c:	9b03      	ldr	r3, [sp, #12]
   12c4e:	3301      	adds	r3, #1
   12c50:	9303      	str	r3, [sp, #12]
   12c52:	e7dd      	b.n	12c10 <Ssd1306::Update()+0x1c>
   12c54:	4623      	mov	r3, r4
   12c56:	4619      	mov	r1, r3
   12c58:	4802      	ldr	r0, [pc, #8]	; (12c64 <Ssd1306::Update()+0x70>)
   12c5a:	f002 fd29 	bl	156b0 <__cyg_profile_func_exit>
      }
    }
  }
   12c5e:	bf00      	nop
   12c60:	b004      	add	sp, #16
   12c62:	bd10      	pop	{r4, pc}
   12c64:	00012bf5 	.word	0x00012bf5

00012c68 <Graphics::Graphics(PixelDisplayInterface*)>:
#include "utility/log.hpp"

class Graphics
{
 public:
  explicit Graphics(PixelDisplayInterface * display)
   12c68:	b530      	push	{r4, r5, lr}
   12c6a:	b083      	sub	sp, #12
   12c6c:	4675      	mov	r5, lr
   12c6e:	9001      	str	r0, [sp, #4]
   12c70:	9100      	str	r1, [sp, #0]
   12c72:	462b      	mov	r3, r5
   12c74:	4619      	mov	r1, r3
   12c76:	481e      	ldr	r0, [pc, #120]	; (12cf0 <Graphics::Graphics(PixelDisplayInterface*)+0x88>)
   12c78:	f002 fd06 	bl	15688 <__cyg_profile_func_enter>
      : display_(display), color_(), width_(0), height_(0)
   12c7c:	9b01      	ldr	r3, [sp, #4]
   12c7e:	9a00      	ldr	r2, [sp, #0]
   12c80:	601a      	str	r2, [r3, #0]
   12c82:	9b01      	ldr	r3, [sp, #4]
   12c84:	3304      	adds	r3, #4
   12c86:	4618      	mov	r0, r3
   12c88:	f7ff fcee 	bl	12668 <PixelDisplayInterface::Color_t::Color_t()>
   12c8c:	9b01      	ldr	r3, [sp, #4]
   12c8e:	2200      	movs	r2, #0
   12c90:	609a      	str	r2, [r3, #8]
   12c92:	9b01      	ldr	r3, [sp, #4]
   12c94:	2200      	movs	r2, #0
   12c96:	60da      	str	r2, [r3, #12]
  {
    width_  = display->GetWidth();
   12c98:	9b00      	ldr	r3, [sp, #0]
   12c9a:	681b      	ldr	r3, [r3, #0]
   12c9c:	681b      	ldr	r3, [r3, #0]
   12c9e:	9800      	ldr	r0, [sp, #0]
   12ca0:	4798      	blx	r3
   12ca2:	4602      	mov	r2, r0
   12ca4:	9b01      	ldr	r3, [sp, #4]
   12ca6:	609a      	str	r2, [r3, #8]
    height_ = display->GetHeight();
   12ca8:	9b00      	ldr	r3, [sp, #0]
   12caa:	681b      	ldr	r3, [r3, #0]
   12cac:	3304      	adds	r3, #4
   12cae:	681b      	ldr	r3, [r3, #0]
   12cb0:	9800      	ldr	r0, [sp, #0]
   12cb2:	4798      	blx	r3
   12cb4:	4602      	mov	r2, r0
   12cb6:	9b01      	ldr	r3, [sp, #4]
   12cb8:	60da      	str	r2, [r3, #12]
    color_  = display->AvailableColors();
   12cba:	9b00      	ldr	r3, [sp, #0]
   12cbc:	681b      	ldr	r3, [r3, #0]
   12cbe:	3308      	adds	r3, #8
   12cc0:	681b      	ldr	r3, [r3, #0]
   12cc2:	9c01      	ldr	r4, [sp, #4]
   12cc4:	9800      	ldr	r0, [sp, #0]
   12cc6:	4798      	blx	r3
   12cc8:	4603      	mov	r3, r0
   12cca:	461a      	mov	r2, r3
   12ccc:	7122      	strb	r2, [r4, #4]
   12cce:	f3c3 2207 	ubfx	r2, r3, #8, #8
   12cd2:	7162      	strb	r2, [r4, #5]
   12cd4:	f3c3 4307 	ubfx	r3, r3, #16, #8
   12cd8:	71a3      	strb	r3, [r4, #6]
  }
   12cda:	9c01      	ldr	r4, [sp, #4]
   12cdc:	462b      	mov	r3, r5
   12cde:	4619      	mov	r1, r3
   12ce0:	4803      	ldr	r0, [pc, #12]	; (12cf0 <Graphics::Graphics(PixelDisplayInterface*)+0x88>)
   12ce2:	f002 fce5 	bl	156b0 <__cyg_profile_func_exit>
   12ce6:	4623      	mov	r3, r4
   12ce8:	4618      	mov	r0, r3
   12cea:	b003      	add	sp, #12
   12cec:	bd30      	pop	{r4, r5, pc}
   12cee:	bf00      	nop
   12cf0:	00012c69 	.word	0x00012c69

00012cf4 <Graphics::Initialize()>:
  void SetColor(PixelDisplayInterface::Color_t color)
  {
    color_ = color;
  }

  void Initialize()
   12cf4:	b510      	push	{r4, lr}
   12cf6:	b082      	sub	sp, #8
   12cf8:	4674      	mov	r4, lr
   12cfa:	9001      	str	r0, [sp, #4]
   12cfc:	4623      	mov	r3, r4
   12cfe:	4619      	mov	r1, r3
   12d00:	480e      	ldr	r0, [pc, #56]	; (12d3c <Graphics::Initialize()+0x48>)
   12d02:	f002 fcc1 	bl	15688 <__cyg_profile_func_enter>
  {
    display_->Initialize();
   12d06:	9b01      	ldr	r3, [sp, #4]
   12d08:	681a      	ldr	r2, [r3, #0]
   12d0a:	9b01      	ldr	r3, [sp, #4]
   12d0c:	681b      	ldr	r3, [r3, #0]
   12d0e:	681b      	ldr	r3, [r3, #0]
   12d10:	330c      	adds	r3, #12
   12d12:	681b      	ldr	r3, [r3, #0]
   12d14:	4610      	mov	r0, r2
   12d16:	4798      	blx	r3
    display_->Enable();
   12d18:	9b01      	ldr	r3, [sp, #4]
   12d1a:	681a      	ldr	r2, [r3, #0]
   12d1c:	9b01      	ldr	r3, [sp, #4]
   12d1e:	681b      	ldr	r3, [r3, #0]
   12d20:	681b      	ldr	r3, [r3, #0]
   12d22:	3310      	adds	r3, #16
   12d24:	681b      	ldr	r3, [r3, #0]
   12d26:	4610      	mov	r0, r2
   12d28:	4798      	blx	r3
   12d2a:	4623      	mov	r3, r4
   12d2c:	4619      	mov	r1, r3
   12d2e:	4803      	ldr	r0, [pc, #12]	; (12d3c <Graphics::Initialize()+0x48>)
   12d30:	f002 fcbe 	bl	156b0 <__cyg_profile_func_exit>
  }
   12d34:	bf00      	nop
   12d36:	b002      	add	sp, #8
   12d38:	bd10      	pop	{r4, pc}
   12d3a:	bf00      	nop
   12d3c:	00012cf5 	.word	0x00012cf5

00012d40 <Graphics::DrawCharacter(long, long, char, bool)>:
    // |                    |
    // ----------------------
    DrawVerticalLine(x + width, y, height);
  }

  void DrawCharacter(int32_t x0, int32_t y0, char letter,
   12d40:	b510      	push	{r4, lr}
   12d42:	b08e      	sub	sp, #56	; 0x38
   12d44:	4674      	mov	r4, lr
   12d46:	9007      	str	r0, [sp, #28]
   12d48:	9106      	str	r1, [sp, #24]
   12d4a:	9205      	str	r2, [sp, #20]
   12d4c:	f88d 3013 	strb.w	r3, [sp, #19]
   12d50:	4623      	mov	r3, r4
   12d52:	4619      	mov	r1, r3
   12d54:	4837      	ldr	r0, [pc, #220]	; (12e34 <Graphics::DrawCharacter(long, long, char, bool)+0xf4>)
   12d56:	f002 fc97 	bl	15688 <__cyg_profile_func_enter>
                     bool fill_background = true)
  {
    int32_t letter_position = static_cast<int32_t>(letter);
   12d5a:	f89d 3013 	ldrb.w	r3, [sp, #19]
   12d5e:	930b      	str	r3, [sp, #44]	; 0x2c

    PixelDisplayInterface::Color_t foreground = color_;
   12d60:	9a07      	ldr	r2, [sp, #28]
   12d62:	ab0a      	add	r3, sp, #40	; 0x28
   12d64:	3204      	adds	r2, #4
   12d66:	6812      	ldr	r2, [r2, #0]
   12d68:	4611      	mov	r1, r2
   12d6a:	8019      	strh	r1, [r3, #0]
   12d6c:	3302      	adds	r3, #2
   12d6e:	0c12      	lsrs	r2, r2, #16
   12d70:	701a      	strb	r2, [r3, #0]
    PixelDisplayInterface::Color_t background =
        PixelDisplayInterface::Color_t(0, 0, 0, 0, 1, true);
   12d72:	a809      	add	r0, sp, #36	; 0x24
   12d74:	2301      	movs	r3, #1
   12d76:	9302      	str	r3, [sp, #8]
   12d78:	2301      	movs	r3, #1
   12d7a:	9301      	str	r3, [sp, #4]
   12d7c:	2300      	movs	r3, #0
   12d7e:	9300      	str	r3, [sp, #0]
   12d80:	2300      	movs	r3, #0
   12d82:	2200      	movs	r2, #0
   12d84:	2100      	movs	r1, #0
   12d86:	f7ff fc25 	bl	125d4 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>

    for (int32_t y = 0; y < 8; y++)
   12d8a:	2300      	movs	r3, #0
   12d8c:	930d      	str	r3, [sp, #52]	; 0x34
   12d8e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12d90:	2b07      	cmp	r3, #7
   12d92:	dc3d      	bgt.n	12e10 <Graphics::DrawCharacter(long, long, char, bool)+0xd0>
    {
      for (int32_t x = 0; x < 8; x++)
   12d94:	2300      	movs	r3, #0
   12d96:	930c      	str	r3, [sp, #48]	; 0x30
   12d98:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12d9a:	2b07      	cmp	r3, #7
   12d9c:	dc34      	bgt.n	12e08 <Graphics::DrawCharacter(long, long, char, bool)+0xc8>
      {
        if (font8x8_basic[letter_position][y] & (1 << x))
   12d9e:	4a26      	ldr	r2, [pc, #152]	; (12e38 <Graphics::DrawCharacter(long, long, char, bool)+0xf8>)
   12da0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12da2:	00db      	lsls	r3, r3, #3
   12da4:	441a      	add	r2, r3
   12da6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12da8:	4413      	add	r3, r2
   12daa:	781b      	ldrb	r3, [r3, #0]
   12dac:	461a      	mov	r2, r3
   12dae:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12db0:	fa42 f303 	asr.w	r3, r2, r3
   12db4:	f003 0301 	and.w	r3, r3, #1
   12db8:	2b00      	cmp	r3, #0
   12dba:	d009      	beq.n	12dd0 <Graphics::DrawCharacter(long, long, char, bool)+0x90>
        {
          color_ = foreground;
   12dbc:	9b07      	ldr	r3, [sp, #28]
   12dbe:	3304      	adds	r3, #4
   12dc0:	aa0a      	add	r2, sp, #40	; 0x28
   12dc2:	6812      	ldr	r2, [r2, #0]
   12dc4:	4611      	mov	r1, r2
   12dc6:	8019      	strh	r1, [r3, #0]
   12dc8:	3302      	adds	r3, #2
   12dca:	0c12      	lsrs	r2, r2, #16
   12dcc:	701a      	strb	r2, [r3, #0]
   12dce:	e00c      	b.n	12dea <Graphics::DrawCharacter(long, long, char, bool)+0xaa>
        }
        else if (fill_background)
   12dd0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   12dd4:	2b00      	cmp	r3, #0
   12dd6:	d008      	beq.n	12dea <Graphics::DrawCharacter(long, long, char, bool)+0xaa>
        {
          color_ = background;
   12dd8:	9b07      	ldr	r3, [sp, #28]
   12dda:	3304      	adds	r3, #4
   12ddc:	aa09      	add	r2, sp, #36	; 0x24
   12dde:	6812      	ldr	r2, [r2, #0]
   12de0:	4611      	mov	r1, r2
   12de2:	8019      	strh	r1, [r3, #0]
   12de4:	3302      	adds	r3, #2
   12de6:	0c12      	lsrs	r2, r2, #16
   12de8:	701a      	strb	r2, [r3, #0]
        }
        DrawPixel(x0 + x, y0 + y);
   12dea:	9a06      	ldr	r2, [sp, #24]
   12dec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12dee:	4413      	add	r3, r2
   12df0:	4619      	mov	r1, r3
   12df2:	9a05      	ldr	r2, [sp, #20]
   12df4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12df6:	4413      	add	r3, r2
   12df8:	461a      	mov	r2, r3
   12dfa:	9807      	ldr	r0, [sp, #28]
   12dfc:	f000 f81e 	bl	12e3c <Graphics::DrawPixel(unsigned long, unsigned long)>
      for (int32_t x = 0; x < 8; x++)
   12e00:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12e02:	3301      	adds	r3, #1
   12e04:	930c      	str	r3, [sp, #48]	; 0x30
   12e06:	e7c7      	b.n	12d98 <Graphics::DrawCharacter(long, long, char, bool)+0x58>
    for (int32_t y = 0; y < 8; y++)
   12e08:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12e0a:	3301      	adds	r3, #1
   12e0c:	930d      	str	r3, [sp, #52]	; 0x34
   12e0e:	e7be      	b.n	12d8e <Graphics::DrawCharacter(long, long, char, bool)+0x4e>
      }
    }
    color_ = foreground;
   12e10:	9b07      	ldr	r3, [sp, #28]
   12e12:	3304      	adds	r3, #4
   12e14:	aa0a      	add	r2, sp, #40	; 0x28
   12e16:	6812      	ldr	r2, [r2, #0]
   12e18:	4611      	mov	r1, r2
   12e1a:	8019      	strh	r1, [r3, #0]
   12e1c:	3302      	adds	r3, #2
   12e1e:	0c12      	lsrs	r2, r2, #16
   12e20:	701a      	strb	r2, [r3, #0]
   12e22:	4623      	mov	r3, r4
   12e24:	4619      	mov	r1, r3
   12e26:	4803      	ldr	r0, [pc, #12]	; (12e34 <Graphics::DrawCharacter(long, long, char, bool)+0xf4>)
   12e28:	f002 fc42 	bl	156b0 <__cyg_profile_func_exit>
  }
   12e2c:	bf00      	nop
   12e2e:	b00e      	add	sp, #56	; 0x38
   12e30:	bd10      	pop	{r4, pc}
   12e32:	bf00      	nop
   12e34:	00012d41 	.word	0x00012d41
   12e38:	1000005c 	.word	0x1000005c

00012e3c <Graphics::DrawPixel(unsigned long, unsigned long)>:

  void DrawPixel(uint32_t x, uint32_t y)
   12e3c:	b530      	push	{r4, r5, lr}
   12e3e:	b085      	sub	sp, #20
   12e40:	4675      	mov	r5, lr
   12e42:	9003      	str	r0, [sp, #12]
   12e44:	9102      	str	r1, [sp, #8]
   12e46:	9201      	str	r2, [sp, #4]
   12e48:	462b      	mov	r3, r5
   12e4a:	4619      	mov	r1, r3
   12e4c:	4810      	ldr	r0, [pc, #64]	; (12e90 <Graphics::DrawPixel(unsigned long, unsigned long)+0x54>)
   12e4e:	f002 fc1b 	bl	15688 <__cyg_profile_func_enter>
  {
    // Pixels outside of the bounds of the screen will not be drawn.
    if (x <= width_ && y <= height_)
   12e52:	9b03      	ldr	r3, [sp, #12]
   12e54:	689b      	ldr	r3, [r3, #8]
   12e56:	9a02      	ldr	r2, [sp, #8]
   12e58:	429a      	cmp	r2, r3
   12e5a:	d810      	bhi.n	12e7e <Graphics::DrawPixel(unsigned long, unsigned long)+0x42>
   12e5c:	9b03      	ldr	r3, [sp, #12]
   12e5e:	68db      	ldr	r3, [r3, #12]
   12e60:	9a01      	ldr	r2, [sp, #4]
   12e62:	429a      	cmp	r2, r3
   12e64:	d80b      	bhi.n	12e7e <Graphics::DrawPixel(unsigned long, unsigned long)+0x42>
    {
      display_->DrawPixel(x, y, color_);
   12e66:	9b03      	ldr	r3, [sp, #12]
   12e68:	6818      	ldr	r0, [r3, #0]
   12e6a:	9b03      	ldr	r3, [sp, #12]
   12e6c:	681b      	ldr	r3, [r3, #0]
   12e6e:	681b      	ldr	r3, [r3, #0]
   12e70:	331c      	adds	r3, #28
   12e72:	681c      	ldr	r4, [r3, #0]
   12e74:	9902      	ldr	r1, [sp, #8]
   12e76:	9a01      	ldr	r2, [sp, #4]
   12e78:	9b03      	ldr	r3, [sp, #12]
   12e7a:	685b      	ldr	r3, [r3, #4]
   12e7c:	47a0      	blx	r4
   12e7e:	462b      	mov	r3, r5
   12e80:	4619      	mov	r1, r3
   12e82:	4803      	ldr	r0, [pc, #12]	; (12e90 <Graphics::DrawPixel(unsigned long, unsigned long)+0x54>)
   12e84:	f002 fc14 	bl	156b0 <__cyg_profile_func_exit>
    }
  }
   12e88:	bf00      	nop
   12e8a:	b005      	add	sp, #20
   12e8c:	bd30      	pop	{r4, r5, pc}
   12e8e:	bf00      	nop
   12e90:	00012e3d 	.word	0x00012e3d

00012e94 <Graphics::Update()>:
  void Update()
   12e94:	b510      	push	{r4, lr}
   12e96:	b082      	sub	sp, #8
   12e98:	4674      	mov	r4, lr
   12e9a:	9001      	str	r0, [sp, #4]
   12e9c:	4623      	mov	r3, r4
   12e9e:	4619      	mov	r1, r3
   12ea0:	4809      	ldr	r0, [pc, #36]	; (12ec8 <Graphics::Update()+0x34>)
   12ea2:	f002 fbf1 	bl	15688 <__cyg_profile_func_enter>
  {
    display_->Update();
   12ea6:	9b01      	ldr	r3, [sp, #4]
   12ea8:	681a      	ldr	r2, [r3, #0]
   12eaa:	9b01      	ldr	r3, [sp, #4]
   12eac:	681b      	ldr	r3, [r3, #0]
   12eae:	681b      	ldr	r3, [r3, #0]
   12eb0:	3320      	adds	r3, #32
   12eb2:	681b      	ldr	r3, [r3, #0]
   12eb4:	4610      	mov	r0, r2
   12eb6:	4798      	blx	r3
   12eb8:	4623      	mov	r3, r4
   12eba:	4619      	mov	r1, r3
   12ebc:	4802      	ldr	r0, [pc, #8]	; (12ec8 <Graphics::Update()+0x34>)
   12ebe:	f002 fbf7 	bl	156b0 <__cyg_profile_func_exit>
  }
   12ec2:	bf00      	nop
   12ec4:	b002      	add	sp, #8
   12ec6:	bd10      	pop	{r4, pc}
   12ec8:	00012e95 	.word	0x00012e95

00012ecc <Graphics::Clear()>:
  void Clear()
   12ecc:	b510      	push	{r4, lr}
   12ece:	b082      	sub	sp, #8
   12ed0:	4674      	mov	r4, lr
   12ed2:	9001      	str	r0, [sp, #4]
   12ed4:	4623      	mov	r3, r4
   12ed6:	4619      	mov	r1, r3
   12ed8:	4809      	ldr	r0, [pc, #36]	; (12f00 <Graphics::Clear()+0x34>)
   12eda:	f002 fbd5 	bl	15688 <__cyg_profile_func_enter>
  {
    display_->Clear();
   12ede:	9b01      	ldr	r3, [sp, #4]
   12ee0:	681a      	ldr	r2, [r3, #0]
   12ee2:	9b01      	ldr	r3, [sp, #4]
   12ee4:	681b      	ldr	r3, [r3, #0]
   12ee6:	681b      	ldr	r3, [r3, #0]
   12ee8:	3318      	adds	r3, #24
   12eea:	681b      	ldr	r3, [r3, #0]
   12eec:	4610      	mov	r0, r2
   12eee:	4798      	blx	r3
   12ef0:	4623      	mov	r3, r4
   12ef2:	4619      	mov	r1, r3
   12ef4:	4802      	ldr	r0, [pc, #8]	; (12f00 <Graphics::Clear()+0x34>)
   12ef6:	f002 fbdb 	bl	156b0 <__cyg_profile_func_exit>
  }
   12efa:	bf00      	nop
   12efc:	b002      	add	sp, #8
   12efe:	bd10      	pop	{r4, pc}
   12f00:	00012ecd 	.word	0x00012ecd

00012f04 <OledTerminal::Initialize()>:
  static constexpr size_t kCharacterHeight = 8;
  static constexpr size_t kCharacterWidth  = 8;
  static constexpr size_t kMaxColumns      = Ssd1306::kWidth / kCharacterWidth;
  static constexpr size_t kMaxRows = Ssd1306::kHeight / kCharacterHeight;

  void Initialize()
   12f04:	b510      	push	{r4, lr}
   12f06:	b082      	sub	sp, #8
   12f08:	4674      	mov	r4, lr
   12f0a:	9001      	str	r0, [sp, #4]
   12f0c:	4623      	mov	r3, r4
   12f0e:	4619      	mov	r1, r3
   12f10:	480e      	ldr	r0, [pc, #56]	; (12f4c <OledTerminal::Initialize()+0x48>)
   12f12:	f002 fbb9 	bl	15688 <__cyg_profile_func_enter>
  {
    graphics_.Initialize();
   12f16:	9b01      	ldr	r3, [sp, #4]
   12f18:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   12f1c:	4618      	mov	r0, r3
   12f1e:	f7ff fee9 	bl	12cf4 <Graphics::Initialize()>
    graphics_.Clear();
   12f22:	9b01      	ldr	r3, [sp, #4]
   12f24:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   12f28:	4618      	mov	r0, r3
   12f2a:	f7ff ffcf 	bl	12ecc <Graphics::Clear()>
    graphics_.Update();
   12f2e:	9b01      	ldr	r3, [sp, #4]
   12f30:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   12f34:	4618      	mov	r0, r3
   12f36:	f7ff ffad 	bl	12e94 <Graphics::Update()>
   12f3a:	4623      	mov	r3, r4
   12f3c:	4619      	mov	r1, r3
   12f3e:	4803      	ldr	r0, [pc, #12]	; (12f4c <OledTerminal::Initialize()+0x48>)
   12f40:	f002 fbb6 	bl	156b0 <__cyg_profile_func_exit>
  }
   12f44:	bf00      	nop
   12f46:	b002      	add	sp, #8
   12f48:	bd10      	pop	{r4, pc}
   12f4a:	bf00      	nop
   12f4c:	00012f05 	.word	0x00012f05

00012f50 <OledTerminal::printf(char const*, ...)>:

  int printf(const char * format, ...)  // NOLINT
   12f50:	b40e      	push	{r1, r2, r3}
   12f52:	b530      	push	{r4, r5, lr}
   12f54:	b0c6      	sub	sp, #280	; 0x118
   12f56:	4675      	mov	r5, lr
   12f58:	ab01      	add	r3, sp, #4
   12f5a:	6018      	str	r0, [r3, #0]
   12f5c:	462b      	mov	r3, r5
   12f5e:	4619      	mov	r1, r3
   12f60:	4850      	ldr	r0, [pc, #320]	; (130a4 <OledTerminal::printf(char const*, ...)+0x154>)
   12f62:	f002 fb91 	bl	15688 <__cyg_profile_func_enter>
  {
    char buffer[256];

    va_list args;
    va_start(args, format);
   12f66:	aa4a      	add	r2, sp, #296	; 0x128
   12f68:	ab02      	add	r3, sp, #8
   12f6a:	601a      	str	r2, [r3, #0]
    size_t characters = vsnprintf(buffer, sizeof(buffer), format, args);
   12f6c:	ab02      	add	r3, sp, #8
   12f6e:	a803      	add	r0, sp, #12
   12f70:	681b      	ldr	r3, [r3, #0]
   12f72:	9a49      	ldr	r2, [sp, #292]	; 0x124
   12f74:	f44f 7180 	mov.w	r1, #256	; 0x100
   12f78:	f004 ff90 	bl	17e9c <vsnprintf>
   12f7c:	4603      	mov	r3, r0
   12f7e:	9344      	str	r3, [sp, #272]	; 0x110
    va_end(args);

    size_t pos = 0;
   12f80:	2300      	movs	r3, #0
   12f82:	9345      	str	r3, [sp, #276]	; 0x114
    for (; pos < characters; pos++)
   12f84:	9a45      	ldr	r2, [sp, #276]	; 0x114
   12f86:	9b44      	ldr	r3, [sp, #272]	; 0x110
   12f88:	429a      	cmp	r2, r3
   12f8a:	d253      	bcs.n	13034 <OledTerminal::printf(char const*, ...)+0xe4>
    {
      char character = buffer[pos];
   12f8c:	aa03      	add	r2, sp, #12
   12f8e:	9b45      	ldr	r3, [sp, #276]	; 0x114
   12f90:	4413      	add	r3, r2
   12f92:	781b      	ldrb	r3, [r3, #0]
   12f94:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
      switch (character)
   12f98:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   12f9c:	2b0a      	cmp	r3, #10
   12f9e:	d10e      	bne.n	12fbe <OledTerminal::printf(char const*, ...)+0x6e>
      {
        case '\n':
          column_ = 0;
   12fa0:	ab01      	add	r3, sp, #4
   12fa2:	681b      	ldr	r3, [r3, #0]
   12fa4:	2200      	movs	r2, #0
   12fa6:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
          row_++;
   12faa:	ab01      	add	r3, sp, #4
   12fac:	681b      	ldr	r3, [r3, #0]
   12fae:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   12fb2:	1c5a      	adds	r2, r3, #1
   12fb4:	ab01      	add	r3, sp, #4
   12fb6:	681b      	ldr	r3, [r3, #0]
   12fb8:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
          break;
   12fbc:	e036      	b.n	1302c <OledTerminal::printf(char const*, ...)+0xdc>
        default:
          terminal_[(row_ + row_start_) % kMaxRows][column_] = character;
   12fbe:	ab01      	add	r3, sp, #4
   12fc0:	681b      	ldr	r3, [r3, #0]
   12fc2:	f8d3 273c 	ldr.w	r2, [r3, #1852]	; 0x73c
   12fc6:	ab01      	add	r3, sp, #4
   12fc8:	681b      	ldr	r3, [r3, #0]
   12fca:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   12fce:	4413      	add	r3, r2
   12fd0:	f003 0207 	and.w	r2, r3, #7
   12fd4:	ab01      	add	r3, sp, #4
   12fd6:	681b      	ldr	r3, [r3, #0]
   12fd8:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   12fdc:	a901      	add	r1, sp, #4
   12fde:	6809      	ldr	r1, [r1, #0]
   12fe0:	0112      	lsls	r2, r2, #4
   12fe2:	440a      	add	r2, r1
   12fe4:	4413      	add	r3, r2
   12fe6:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   12fea:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
   12fee:	701a      	strb	r2, [r3, #0]
          column_++;
   12ff0:	ab01      	add	r3, sp, #4
   12ff2:	681b      	ldr	r3, [r3, #0]
   12ff4:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   12ff8:	1c5a      	adds	r2, r3, #1
   12ffa:	ab01      	add	r3, sp, #4
   12ffc:	681b      	ldr	r3, [r3, #0]
   12ffe:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
          if (column_ >= kMaxColumns)
   13002:	ab01      	add	r3, sp, #4
   13004:	681b      	ldr	r3, [r3, #0]
   13006:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   1300a:	2b0f      	cmp	r3, #15
   1300c:	d90d      	bls.n	1302a <OledTerminal::printf(char const*, ...)+0xda>
          {
            column_ = 0;
   1300e:	ab01      	add	r3, sp, #4
   13010:	681b      	ldr	r3, [r3, #0]
   13012:	2200      	movs	r2, #0
   13014:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
            row_++;
   13018:	ab01      	add	r3, sp, #4
   1301a:	681b      	ldr	r3, [r3, #0]
   1301c:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   13020:	1c5a      	adds	r2, r3, #1
   13022:	ab01      	add	r3, sp, #4
   13024:	681b      	ldr	r3, [r3, #0]
   13026:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
          }
          break;
   1302a:	bf00      	nop
    for (; pos < characters; pos++)
   1302c:	9b45      	ldr	r3, [sp, #276]	; 0x114
   1302e:	3301      	adds	r3, #1
   13030:	9345      	str	r3, [sp, #276]	; 0x114
   13032:	e7a7      	b.n	12f84 <OledTerminal::printf(char const*, ...)+0x34>
      }
    }
    Update();
   13034:	ab01      	add	r3, sp, #4
   13036:	6818      	ldr	r0, [r3, #0]
   13038:	f000 f836 	bl	130a8 <OledTerminal::Update()>
    if (row_ >= kMaxRows)
   1303c:	ab01      	add	r3, sp, #4
   1303e:	681b      	ldr	r3, [r3, #0]
   13040:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   13044:	2b07      	cmp	r3, #7
   13046:	d91f      	bls.n	13088 <OledTerminal::printf(char const*, ...)+0x138>
    {
      row_start_ = (row_start_ + 1) % kMaxRows;
   13048:	ab01      	add	r3, sp, #4
   1304a:	681b      	ldr	r3, [r3, #0]
   1304c:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   13050:	3301      	adds	r3, #1
   13052:	f003 0207 	and.w	r2, r3, #7
   13056:	ab01      	add	r3, sp, #4
   13058:	681b      	ldr	r3, [r3, #0]
   1305a:	f8c3 2744 	str.w	r2, [r3, #1860]	; 0x744
      row_       = kMaxRows - 1;
   1305e:	ab01      	add	r3, sp, #4
   13060:	681b      	ldr	r3, [r3, #0]
   13062:	2207      	movs	r2, #7
   13064:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
      ClearRow((row_ + row_start_) % kMaxRows);
   13068:	ab01      	add	r3, sp, #4
   1306a:	681b      	ldr	r3, [r3, #0]
   1306c:	f8d3 273c 	ldr.w	r2, [r3, #1852]	; 0x73c
   13070:	ab01      	add	r3, sp, #4
   13072:	681b      	ldr	r3, [r3, #0]
   13074:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   13078:	4413      	add	r3, r2
   1307a:	f003 0207 	and.w	r2, r3, #7
   1307e:	ab01      	add	r3, sp, #4
   13080:	4611      	mov	r1, r2
   13082:	6818      	ldr	r0, [r3, #0]
   13084:	f000 f85e 	bl	13144 <OledTerminal::ClearRow(unsigned int)>
    }
    return pos;
   13088:	9c45      	ldr	r4, [sp, #276]	; 0x114
   1308a:	462b      	mov	r3, r5
   1308c:	4619      	mov	r1, r3
   1308e:	4805      	ldr	r0, [pc, #20]	; (130a4 <OledTerminal::printf(char const*, ...)+0x154>)
   13090:	f002 fb0e 	bl	156b0 <__cyg_profile_func_exit>
   13094:	4623      	mov	r3, r4
  }
   13096:	4618      	mov	r0, r3
   13098:	b046      	add	sp, #280	; 0x118
   1309a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1309e:	b003      	add	sp, #12
   130a0:	4770      	bx	lr
   130a2:	bf00      	nop
   130a4:	00012f51 	.word	0x00012f51

000130a8 <OledTerminal::Update()>:
  OledTerminal & MoveToLineStart()
  {
    column_ = 0;
    return *this;
  }
  OledTerminal & Update()
   130a8:	b530      	push	{r4, r5, lr}
   130aa:	b089      	sub	sp, #36	; 0x24
   130ac:	4675      	mov	r5, lr
   130ae:	9003      	str	r0, [sp, #12]
   130b0:	462b      	mov	r3, r5
   130b2:	4619      	mov	r1, r3
   130b4:	4822      	ldr	r0, [pc, #136]	; (13140 <OledTerminal::Update()+0x98>)
   130b6:	f002 fae7 	bl	15688 <__cyg_profile_func_enter>
  {
    for (size_t i = 0; i < kMaxRows; i++)
   130ba:	2300      	movs	r3, #0
   130bc:	9307      	str	r3, [sp, #28]
   130be:	9b07      	ldr	r3, [sp, #28]
   130c0:	2b07      	cmp	r3, #7
   130c2:	d82c      	bhi.n	1311e <OledTerminal::Update()+0x76>
    {
      for (size_t j = 0; j < kMaxColumns; j++)
   130c4:	2300      	movs	r3, #0
   130c6:	9306      	str	r3, [sp, #24]
   130c8:	9b06      	ldr	r3, [sp, #24]
   130ca:	2b0f      	cmp	r3, #15
   130cc:	d823      	bhi.n	13116 <OledTerminal::Update()+0x6e>
      {
        size_t x = j * kCharacterWidth;
   130ce:	9b06      	ldr	r3, [sp, #24]
   130d0:	00db      	lsls	r3, r3, #3
   130d2:	9305      	str	r3, [sp, #20]
        size_t y = i * kCharacterHeight;
   130d4:	9b07      	ldr	r3, [sp, #28]
   130d6:	00db      	lsls	r3, r3, #3
   130d8:	9304      	str	r3, [sp, #16]
        graphics_.DrawCharacter(x, y,
   130da:	9b03      	ldr	r3, [sp, #12]
   130dc:	f203 702c 	addw	r0, r3, #1836	; 0x72c
   130e0:	9905      	ldr	r1, [sp, #20]
   130e2:	9c04      	ldr	r4, [sp, #16]
                                terminal_[(i + row_start_) % kMaxRows][j]);
   130e4:	9b03      	ldr	r3, [sp, #12]
   130e6:	f8d3 2744 	ldr.w	r2, [r3, #1860]	; 0x744
   130ea:	9b07      	ldr	r3, [sp, #28]
   130ec:	4413      	add	r3, r2
   130ee:	f003 0307 	and.w	r3, r3, #7
        graphics_.DrawCharacter(x, y,
   130f2:	9a03      	ldr	r2, [sp, #12]
   130f4:	011b      	lsls	r3, r3, #4
   130f6:	441a      	add	r2, r3
   130f8:	9b06      	ldr	r3, [sp, #24]
   130fa:	4413      	add	r3, r2
   130fc:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   13100:	781a      	ldrb	r2, [r3, #0]
   13102:	2301      	movs	r3, #1
   13104:	9300      	str	r3, [sp, #0]
   13106:	4613      	mov	r3, r2
   13108:	4622      	mov	r2, r4
   1310a:	f7ff fe19 	bl	12d40 <Graphics::DrawCharacter(long, long, char, bool)>
      for (size_t j = 0; j < kMaxColumns; j++)
   1310e:	9b06      	ldr	r3, [sp, #24]
   13110:	3301      	adds	r3, #1
   13112:	9306      	str	r3, [sp, #24]
   13114:	e7d8      	b.n	130c8 <OledTerminal::Update()+0x20>
    for (size_t i = 0; i < kMaxRows; i++)
   13116:	9b07      	ldr	r3, [sp, #28]
   13118:	3301      	adds	r3, #1
   1311a:	9307      	str	r3, [sp, #28]
   1311c:	e7cf      	b.n	130be <OledTerminal::Update()+0x16>
      }
    }
    graphics_.Update();
   1311e:	9b03      	ldr	r3, [sp, #12]
   13120:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   13124:	4618      	mov	r0, r3
   13126:	f7ff feb5 	bl	12e94 <Graphics::Update()>
    return *this;
   1312a:	9c03      	ldr	r4, [sp, #12]
   1312c:	462b      	mov	r3, r5
   1312e:	4619      	mov	r1, r3
   13130:	4803      	ldr	r0, [pc, #12]	; (13140 <OledTerminal::Update()+0x98>)
   13132:	f002 fabd 	bl	156b0 <__cyg_profile_func_exit>
   13136:	4623      	mov	r3, r4
  }
   13138:	4618      	mov	r0, r3
   1313a:	b009      	add	sp, #36	; 0x24
   1313c:	bd30      	pop	{r4, r5, pc}
   1313e:	bf00      	nop
   13140:	000130a9 	.word	0x000130a9

00013144 <OledTerminal::ClearRow(unsigned int)>:
  void ClearRow(size_t row_location)
   13144:	b510      	push	{r4, lr}
   13146:	b084      	sub	sp, #16
   13148:	4674      	mov	r4, lr
   1314a:	9001      	str	r0, [sp, #4]
   1314c:	9100      	str	r1, [sp, #0]
   1314e:	4623      	mov	r3, r4
   13150:	4619      	mov	r1, r3
   13152:	480f      	ldr	r0, [pc, #60]	; (13190 <OledTerminal::ClearRow(unsigned int)+0x4c>)
   13154:	f002 fa98 	bl	15688 <__cyg_profile_func_enter>
  {
    for (size_t i = 0; i < kMaxColumns; i++)
   13158:	2300      	movs	r3, #0
   1315a:	9303      	str	r3, [sp, #12]
   1315c:	9b03      	ldr	r3, [sp, #12]
   1315e:	2b0f      	cmp	r3, #15
   13160:	d80d      	bhi.n	1317e <OledTerminal::ClearRow(unsigned int)+0x3a>
    {
      terminal_[row_location][i] = ' ';
   13162:	9a01      	ldr	r2, [sp, #4]
   13164:	9b00      	ldr	r3, [sp, #0]
   13166:	011b      	lsls	r3, r3, #4
   13168:	441a      	add	r2, r3
   1316a:	9b03      	ldr	r3, [sp, #12]
   1316c:	4413      	add	r3, r2
   1316e:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   13172:	2220      	movs	r2, #32
   13174:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < kMaxColumns; i++)
   13176:	9b03      	ldr	r3, [sp, #12]
   13178:	3301      	adds	r3, #1
   1317a:	9303      	str	r3, [sp, #12]
   1317c:	e7ee      	b.n	1315c <OledTerminal::ClearRow(unsigned int)+0x18>
   1317e:	4623      	mov	r3, r4
   13180:	4619      	mov	r1, r3
   13182:	4803      	ldr	r0, [pc, #12]	; (13190 <OledTerminal::ClearRow(unsigned int)+0x4c>)
   13184:	f002 fa94 	bl	156b0 <__cyg_profile_func_exit>
    }
  }
   13188:	bf00      	nop
   1318a:	b004      	add	sp, #16
   1318c:	bd10      	pop	{r4, pc}
   1318e:	bf00      	nop
   13190:	00013145 	.word	0x00013145

00013194 <OledTerminal::OledTerminal()>:
class OledTerminal
   13194:	b530      	push	{r4, r5, lr}
   13196:	b083      	sub	sp, #12
   13198:	4675      	mov	r5, lr
   1319a:	9001      	str	r0, [sp, #4]
   1319c:	462b      	mov	r3, r5
   1319e:	4619      	mov	r1, r3
   131a0:	4816      	ldr	r0, [pc, #88]	; (131fc <OledTerminal::OledTerminal()+0x68>)
   131a2:	f002 fa71 	bl	15688 <__cyg_profile_func_enter>
   131a6:	9b01      	ldr	r3, [sp, #4]
   131a8:	4618      	mov	r0, r3
   131aa:	f7ff fae7 	bl	1277c <Ssd1306::Ssd1306()>
   131ae:	9b01      	ldr	r3, [sp, #4]
   131b0:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   131b4:	9a01      	ldr	r2, [sp, #4]
   131b6:	4611      	mov	r1, r2
   131b8:	4618      	mov	r0, r3
   131ba:	f7ff fd55 	bl	12c68 <Graphics::Graphics(PixelDisplayInterface*)>
   131be:	9b01      	ldr	r3, [sp, #4]
   131c0:	2200      	movs	r2, #0
   131c2:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
   131c6:	9b01      	ldr	r3, [sp, #4]
   131c8:	2200      	movs	r2, #0
   131ca:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
   131ce:	9b01      	ldr	r3, [sp, #4]
   131d0:	2200      	movs	r2, #0
   131d2:	f8c3 2744 	str.w	r2, [r3, #1860]	; 0x744
   131d6:	9b01      	ldr	r3, [sp, #4]
   131d8:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   131dc:	2280      	movs	r2, #128	; 0x80
   131de:	2100      	movs	r1, #0
   131e0:	4618      	mov	r0, r3
   131e2:	f006 fb7a 	bl	198da <memset>
   131e6:	9c01      	ldr	r4, [sp, #4]
   131e8:	462b      	mov	r3, r5
   131ea:	4619      	mov	r1, r3
   131ec:	4803      	ldr	r0, [pc, #12]	; (131fc <OledTerminal::OledTerminal()+0x68>)
   131ee:	f002 fa5f 	bl	156b0 <__cyg_profile_func_exit>
   131f2:	4623      	mov	r3, r4
   131f4:	4618      	mov	r0, r3
   131f6:	b003      	add	sp, #12
   131f8:	bd30      	pop	{r4, r5, pc}
   131fa:	bf00      	nop
   131fc:	00013195 	.word	0x00013195

00013200 <LabUART::LabUART(unsigned char)>:
#include "LabUART.hpp"
QueueHandle_t LabUART::Global_Queue_Handle;

inline static LPC_UART_TypeDef * UART[2] = {LPC_UART2, LPC_UART3};

LabUART::LabUART(uint8_t Uart){
   13200:	b530      	push	{r4, r5, lr}
   13202:	b083      	sub	sp, #12
   13204:	4675      	mov	r5, lr
   13206:	9001      	str	r0, [sp, #4]
   13208:	460b      	mov	r3, r1
   1320a:	f88d 3003 	strb.w	r3, [sp, #3]
   1320e:	462b      	mov	r3, r5
   13210:	4619      	mov	r1, r3
   13212:	4809      	ldr	r0, [pc, #36]	; (13238 <LabUART::LabUART(unsigned char)+0x38>)
   13214:	f002 fa38 	bl	15688 <__cyg_profile_func_enter>
    selUart = Uart-2;
   13218:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1321c:	3b02      	subs	r3, #2
   1321e:	b2da      	uxtb	r2, r3
   13220:	4b06      	ldr	r3, [pc, #24]	; (1323c <LabUART::LabUART(unsigned char)+0x3c>)
   13222:	701a      	strb	r2, [r3, #0]
}
   13224:	9c01      	ldr	r4, [sp, #4]
   13226:	462b      	mov	r3, r5
   13228:	4619      	mov	r1, r3
   1322a:	4803      	ldr	r0, [pc, #12]	; (13238 <LabUART::LabUART(unsigned char)+0x38>)
   1322c:	f002 fa40 	bl	156b0 <__cyg_profile_func_exit>
   13230:	4623      	mov	r3, r4
   13232:	4618      	mov	r0, r3
   13234:	b003      	add	sp, #12
   13236:	bd30      	pop	{r4, r5, pc}
   13238:	00013201 	.word	0x00013201
   1323c:	10000a78 	.word	0x10000a78

00013240 <LabUART::InitializeUart()>:

void LabUART::InitializeUart(){
   13240:	b510      	push	{r4, lr}
   13242:	4674      	mov	r4, lr
   13244:	4623      	mov	r3, r4
   13246:	4619      	mov	r1, r3
   13248:	486d      	ldr	r0, [pc, #436]	; (13400 <LabUART::InitializeUart()+0x1c0>)
   1324a:	f002 fa1d 	bl	15688 <__cyg_profile_func_enter>
    switch(selUart)
   1324e:	4b6d      	ldr	r3, [pc, #436]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13250:	781b      	ldrb	r3, [r3, #0]
   13252:	2b00      	cmp	r3, #0
   13254:	d002      	beq.n	1325c <LabUART::InitializeUart()+0x1c>
   13256:	2b01      	cmp	r3, #1
   13258:	d01a      	beq.n	13290 <LabUART::InitializeUart()+0x50>
   1325a:	e033      	b.n	132c4 <LabUART::InitializeUart()+0x84>
   {
       case 0:
       LPC_SC->PCONP |= (1<<24); 
   1325c:	4b6a      	ldr	r3, [pc, #424]	; (13408 <LabUART::InitializeUart()+0x1c8>)
   1325e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   13262:	4a69      	ldr	r2, [pc, #420]	; (13408 <LabUART::InitializeUart()+0x1c8>)
   13264:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   13268:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
        pc.uart2_txd(2,8);
   1326c:	2208      	movs	r2, #8
   1326e:	2102      	movs	r1, #2
   13270:	4866      	ldr	r0, [pc, #408]	; (1340c <LabUART::InitializeUart()+0x1cc>)
   13272:	f000 fc29 	bl	13ac8 <pinconn::uart2_txd(unsigned char, unsigned char)>
        pc.uart2_rxd(2,9);
   13276:	2209      	movs	r2, #9
   13278:	2102      	movs	r1, #2
   1327a:	4864      	ldr	r0, [pc, #400]	; (1340c <LabUART::InitializeUart()+0x1cc>)
   1327c:	f000 fc84 	bl	13b88 <pinconn::uart2_rxd(unsigned char, unsigned char)>
        RegisterIsr(UART2_IRQn,RX_Int);
   13280:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13284:	2201      	movs	r2, #1
   13286:	4962      	ldr	r1, [pc, #392]	; (13410 <LabUART::InitializeUart()+0x1d0>)
   13288:	2007      	movs	r0, #7
   1328a:	f002 f8a9 	bl	153e0 <RegisterIsr(IRQn, void (*)(), bool, long)>
        break;
   1328e:	e019      	b.n	132c4 <LabUART::InitializeUart()+0x84>
       case 1:
       LPC_SC->PCONP |= (1<<25); 
   13290:	4b5d      	ldr	r3, [pc, #372]	; (13408 <LabUART::InitializeUart()+0x1c8>)
   13292:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   13296:	4a5c      	ldr	r2, [pc, #368]	; (13408 <LabUART::InitializeUart()+0x1c8>)
   13298:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   1329c:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
        pc.uart3_txd(2,8);
   132a0:	2208      	movs	r2, #8
   132a2:	2102      	movs	r1, #2
   132a4:	4859      	ldr	r0, [pc, #356]	; (1340c <LabUART::InitializeUart()+0x1cc>)
   132a6:	f000 fccf 	bl	13c48 <pinconn::uart3_txd(unsigned char, unsigned char)>
        pc.uart3_rxd(2,9);
   132aa:	2209      	movs	r2, #9
   132ac:	2102      	movs	r1, #2
   132ae:	4857      	ldr	r0, [pc, #348]	; (1340c <LabUART::InitializeUart()+0x1cc>)
   132b0:	f000 fd2a 	bl	13d08 <pinconn::uart3_rxd(unsigned char, unsigned char)>
        RegisterIsr(UART3_IRQn, RX_Int);
   132b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   132b8:	2201      	movs	r2, #1
   132ba:	4955      	ldr	r1, [pc, #340]	; (13410 <LabUART::InitializeUart()+0x1d0>)
   132bc:	2008      	movs	r0, #8
   132be:	f002 f88f 	bl	153e0 <RegisterIsr(IRQn, void (*)(), bool, long)>
        break;
   132c2:	bf00      	nop
   }
    oled_terminal.Initialize();
   132c4:	4853      	ldr	r0, [pc, #332]	; (13414 <LabUART::InitializeUart()+0x1d4>)
   132c6:	f7ff fe1d 	bl	12f04 <OledTerminal::Initialize()>
    UART[selUart]->LCR |= (1<<7);
   132ca:	4b4e      	ldr	r3, [pc, #312]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   132cc:	781b      	ldrb	r3, [r3, #0]
   132ce:	461a      	mov	r2, r3
   132d0:	4b51      	ldr	r3, [pc, #324]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   132d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   132d6:	7b1b      	ldrb	r3, [r3, #12]
   132d8:	b2da      	uxtb	r2, r3
   132da:	4b4a      	ldr	r3, [pc, #296]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   132dc:	781b      	ldrb	r3, [r3, #0]
   132de:	4619      	mov	r1, r3
   132e0:	4b4d      	ldr	r3, [pc, #308]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   132e2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   132e6:	f062 027f 	orn	r2, r2, #127	; 0x7f
   132ea:	b2d2      	uxtb	r2, r2
   132ec:	731a      	strb	r2, [r3, #12]
    UART[selUart]->FCR |= (1<<0);
   132ee:	4b45      	ldr	r3, [pc, #276]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   132f0:	781b      	ldrb	r3, [r3, #0]
   132f2:	461a      	mov	r2, r3
   132f4:	4b48      	ldr	r3, [pc, #288]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   132f6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   132fa:	7a1b      	ldrb	r3, [r3, #8]
   132fc:	b2da      	uxtb	r2, r3
   132fe:	4b41      	ldr	r3, [pc, #260]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13300:	781b      	ldrb	r3, [r3, #0]
   13302:	4619      	mov	r1, r3
   13304:	4b44      	ldr	r3, [pc, #272]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   13306:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1330a:	f042 0201 	orr.w	r2, r2, #1
   1330e:	b2d2      	uxtb	r2, r2
   13310:	721a      	strb	r2, [r3, #8]
    setBaudrate9600();
   13312:	f000 f883 	bl	1341c <LabUART::setBaudrate9600()>
    UART[selUart]->LCR &= ~(0b11 <<2);
   13316:	4b3b      	ldr	r3, [pc, #236]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13318:	781b      	ldrb	r3, [r3, #0]
   1331a:	461a      	mov	r2, r3
   1331c:	4b3e      	ldr	r3, [pc, #248]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   1331e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13322:	7b1b      	ldrb	r3, [r3, #12]
   13324:	b2da      	uxtb	r2, r3
   13326:	4b37      	ldr	r3, [pc, #220]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13328:	781b      	ldrb	r3, [r3, #0]
   1332a:	4619      	mov	r1, r3
   1332c:	4b3a      	ldr	r3, [pc, #232]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   1332e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   13332:	f022 020c 	bic.w	r2, r2, #12
   13336:	b2d2      	uxtb	r2, r2
   13338:	731a      	strb	r2, [r3, #12]
    UART[selUart]->LCR |= (0b11<<0);
   1333a:	4b32      	ldr	r3, [pc, #200]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   1333c:	781b      	ldrb	r3, [r3, #0]
   1333e:	461a      	mov	r2, r3
   13340:	4b35      	ldr	r3, [pc, #212]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   13342:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13346:	7b1b      	ldrb	r3, [r3, #12]
   13348:	b2da      	uxtb	r2, r3
   1334a:	4b2e      	ldr	r3, [pc, #184]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   1334c:	781b      	ldrb	r3, [r3, #0]
   1334e:	4619      	mov	r1, r3
   13350:	4b31      	ldr	r3, [pc, #196]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   13352:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   13356:	f042 0203 	orr.w	r2, r2, #3
   1335a:	b2d2      	uxtb	r2, r2
   1335c:	731a      	strb	r2, [r3, #12]
    UART[selUart]->LCR &= ~(1<<7);
   1335e:	4b29      	ldr	r3, [pc, #164]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13360:	781b      	ldrb	r3, [r3, #0]
   13362:	461a      	mov	r2, r3
   13364:	4b2c      	ldr	r3, [pc, #176]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   13366:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1336a:	7b1b      	ldrb	r3, [r3, #12]
   1336c:	b2da      	uxtb	r2, r3
   1336e:	4b25      	ldr	r3, [pc, #148]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13370:	781b      	ldrb	r3, [r3, #0]
   13372:	4619      	mov	r1, r3
   13374:	4b28      	ldr	r3, [pc, #160]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   13376:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1337a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   1337e:	b2d2      	uxtb	r2, r2
   13380:	731a      	strb	r2, [r3, #12]
    UART[selUart]->FCR |= (0b11 << 1);
   13382:	4b20      	ldr	r3, [pc, #128]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13384:	781b      	ldrb	r3, [r3, #0]
   13386:	461a      	mov	r2, r3
   13388:	4b23      	ldr	r3, [pc, #140]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   1338a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1338e:	7a1b      	ldrb	r3, [r3, #8]
   13390:	b2da      	uxtb	r2, r3
   13392:	4b1c      	ldr	r3, [pc, #112]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   13394:	781b      	ldrb	r3, [r3, #0]
   13396:	4619      	mov	r1, r3
   13398:	4b1f      	ldr	r3, [pc, #124]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   1339a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1339e:	f042 0206 	orr.w	r2, r2, #6
   133a2:	b2d2      	uxtb	r2, r2
   133a4:	721a      	strb	r2, [r3, #8]
    UART[selUart]->TER |= (0b1<<7);
   133a6:	4b17      	ldr	r3, [pc, #92]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   133a8:	781b      	ldrb	r3, [r3, #0]
   133aa:	461a      	mov	r2, r3
   133ac:	4b1a      	ldr	r3, [pc, #104]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   133ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   133b2:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   133b6:	b2da      	uxtb	r2, r3
   133b8:	4b12      	ldr	r3, [pc, #72]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   133ba:	781b      	ldrb	r3, [r3, #0]
   133bc:	4619      	mov	r1, r3
   133be:	4b16      	ldr	r3, [pc, #88]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   133c0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   133c4:	f062 027f 	orn	r2, r2, #127	; 0x7f
   133c8:	b2d2      	uxtb	r2, r2
   133ca:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    UART[selUart]->IER |= (1 << 0);
   133ce:	4b0d      	ldr	r3, [pc, #52]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   133d0:	781b      	ldrb	r3, [r3, #0]
   133d2:	461a      	mov	r2, r3
   133d4:	4b10      	ldr	r3, [pc, #64]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   133d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   133da:	685a      	ldr	r2, [r3, #4]
   133dc:	4b09      	ldr	r3, [pc, #36]	; (13404 <LabUART::InitializeUart()+0x1c4>)
   133de:	781b      	ldrb	r3, [r3, #0]
   133e0:	4619      	mov	r1, r3
   133e2:	4b0d      	ldr	r3, [pc, #52]	; (13418 <LabUART::InitializeUart()+0x1d8>)
   133e4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   133e8:	f042 0201 	orr.w	r2, r2, #1
   133ec:	605a      	str	r2, [r3, #4]
    Uqueue();
   133ee:	f000 f979 	bl	136e4 <LabUART::Uqueue()>
   133f2:	4623      	mov	r3, r4
   133f4:	4619      	mov	r1, r3
   133f6:	4802      	ldr	r0, [pc, #8]	; (13400 <LabUART::InitializeUart()+0x1c0>)
   133f8:	f002 f95a 	bl	156b0 <__cyg_profile_func_exit>
   
  }
   133fc:	bf00      	nop
   133fe:	bd10      	pop	{r4, pc}
   13400:	00013241 	.word	0x00013241
   13404:	10000a78 	.word	0x10000a78
   13408:	400fc000 	.word	0x400fc000
   1340c:	10000a7c 	.word	0x10000a7c
   13410:	00013625 	.word	0x00013625
   13414:	10000a80 	.word	0x10000a80
   13418:	1000045c 	.word	0x1000045c

0001341c <LabUART::setBaudrate9600()>:
void LabUART::setBaudrate9600(){
   1341c:	b510      	push	{r4, lr}
   1341e:	b082      	sub	sp, #8
   13420:	4674      	mov	r4, lr
   13422:	4623      	mov	r3, r4
   13424:	4619      	mov	r1, r3
   13426:	481e      	ldr	r0, [pc, #120]	; (134a0 <LabUART::setBaudrate9600()+0x84>)
   13428:	f002 f92e 	bl	15688 <__cyg_profile_func_enter>
     const uint32_t baudrate=9600;
   1342c:	f44f 5316 	mov.w	r3, #9600	; 0x2580
   13430:	9301      	str	r3, [sp, #4]
     uint16_t divisor = 48000000 / (16*baudrate);
   13432:	f44f 739c 	mov.w	r3, #312	; 0x138
   13436:	f8ad 3002 	strh.w	r3, [sp, #2]
       //SetBaud Rate
    UART[selUart]->DLL |= divisor;
   1343a:	4b1a      	ldr	r3, [pc, #104]	; (134a4 <LabUART::setBaudrate9600()+0x88>)
   1343c:	781b      	ldrb	r3, [r3, #0]
   1343e:	461a      	mov	r2, r3
   13440:	4b19      	ldr	r3, [pc, #100]	; (134a8 <LabUART::setBaudrate9600()+0x8c>)
   13442:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13446:	781b      	ldrb	r3, [r3, #0]
   13448:	b2d9      	uxtb	r1, r3
   1344a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   1344e:	b2da      	uxtb	r2, r3
   13450:	4b14      	ldr	r3, [pc, #80]	; (134a4 <LabUART::setBaudrate9600()+0x88>)
   13452:	781b      	ldrb	r3, [r3, #0]
   13454:	4618      	mov	r0, r3
   13456:	4b14      	ldr	r3, [pc, #80]	; (134a8 <LabUART::setBaudrate9600()+0x8c>)
   13458:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   1345c:	430a      	orrs	r2, r1
   1345e:	b2d2      	uxtb	r2, r2
   13460:	701a      	strb	r2, [r3, #0]
    UART[selUart]->DLM |= (divisor>>8);
   13462:	4b10      	ldr	r3, [pc, #64]	; (134a4 <LabUART::setBaudrate9600()+0x88>)
   13464:	781b      	ldrb	r3, [r3, #0]
   13466:	461a      	mov	r2, r3
   13468:	4b0f      	ldr	r3, [pc, #60]	; (134a8 <LabUART::setBaudrate9600()+0x8c>)
   1346a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1346e:	791b      	ldrb	r3, [r3, #4]
   13470:	b2db      	uxtb	r3, r3
   13472:	b25a      	sxtb	r2, r3
   13474:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   13478:	121b      	asrs	r3, r3, #8
   1347a:	b25b      	sxtb	r3, r3
   1347c:	4313      	orrs	r3, r2
   1347e:	b25a      	sxtb	r2, r3
   13480:	4b08      	ldr	r3, [pc, #32]	; (134a4 <LabUART::setBaudrate9600()+0x88>)
   13482:	781b      	ldrb	r3, [r3, #0]
   13484:	4619      	mov	r1, r3
   13486:	4b08      	ldr	r3, [pc, #32]	; (134a8 <LabUART::setBaudrate9600()+0x8c>)
   13488:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1348c:	b2d2      	uxtb	r2, r2
   1348e:	711a      	strb	r2, [r3, #4]
   13490:	4623      	mov	r3, r4
   13492:	4619      	mov	r1, r3
   13494:	4802      	ldr	r0, [pc, #8]	; (134a0 <LabUART::setBaudrate9600()+0x84>)
   13496:	f002 f90b 	bl	156b0 <__cyg_profile_func_exit>
}
   1349a:	bf00      	nop
   1349c:	b002      	add	sp, #8
   1349e:	bd10      	pop	{r4, pc}
   134a0:	0001341d 	.word	0x0001341d
   134a4:	10000a78 	.word	0x10000a78
   134a8:	1000045c 	.word	0x1000045c

000134ac <LabUART::UartSend(int)>:
void LabUART::UartSend(int data){
   134ac:	b510      	push	{r4, lr}
   134ae:	b082      	sub	sp, #8
   134b0:	4674      	mov	r4, lr
   134b2:	9001      	str	r0, [sp, #4]
   134b4:	4623      	mov	r3, r4
   134b6:	4619      	mov	r1, r3
   134b8:	4812      	ldr	r0, [pc, #72]	; (13504 <LabUART::UartSend(int)+0x58>)
   134ba:	f002 f8e5 	bl	15688 <__cyg_profile_func_enter>
        while(!(UART[selUart]->LSR & (1 << 5) ) );
   134be:	4b12      	ldr	r3, [pc, #72]	; (13508 <LabUART::UartSend(int)+0x5c>)
   134c0:	781b      	ldrb	r3, [r3, #0]
   134c2:	461a      	mov	r2, r3
   134c4:	4b11      	ldr	r3, [pc, #68]	; (1350c <LabUART::UartSend(int)+0x60>)
   134c6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   134ca:	7d1b      	ldrb	r3, [r3, #20]
   134cc:	b2db      	uxtb	r3, r3
   134ce:	f003 0320 	and.w	r3, r3, #32
   134d2:	2b00      	cmp	r3, #0
   134d4:	bf0c      	ite	eq
   134d6:	2301      	moveq	r3, #1
   134d8:	2300      	movne	r3, #0
   134da:	b2db      	uxtb	r3, r3
   134dc:	2b00      	cmp	r3, #0
   134de:	d000      	beq.n	134e2 <LabUART::UartSend(int)+0x36>
   134e0:	e7ed      	b.n	134be <LabUART::UartSend(int)+0x12>
        UART[selUart]->THR = data;
   134e2:	4b09      	ldr	r3, [pc, #36]	; (13508 <LabUART::UartSend(int)+0x5c>)
   134e4:	781b      	ldrb	r3, [r3, #0]
   134e6:	461a      	mov	r2, r3
   134e8:	4b08      	ldr	r3, [pc, #32]	; (1350c <LabUART::UartSend(int)+0x60>)
   134ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   134ee:	9a01      	ldr	r2, [sp, #4]
   134f0:	b2d2      	uxtb	r2, r2
   134f2:	701a      	strb	r2, [r3, #0]
   134f4:	4623      	mov	r3, r4
   134f6:	4619      	mov	r1, r3
   134f8:	4802      	ldr	r0, [pc, #8]	; (13504 <LabUART::UartSend(int)+0x58>)
   134fa:	f002 f8d9 	bl	156b0 <__cyg_profile_func_exit>
}
   134fe:	bf00      	nop
   13500:	b002      	add	sp, #8
   13502:	bd10      	pop	{r4, pc}
   13504:	000134ad 	.word	0x000134ad
   13508:	10000a78 	.word	0x10000a78
   1350c:	1000045c 	.word	0x1000045c

00013510 <LabUART::UartReceive()>:
uint8_t LabUART::UartReceive(){
   13510:	b530      	push	{r4, r5, lr}
   13512:	b083      	sub	sp, #12
   13514:	4675      	mov	r5, lr
   13516:	462b      	mov	r3, r5
   13518:	4619      	mov	r1, r3
   1351a:	4815      	ldr	r0, [pc, #84]	; (13570 <LabUART::UartReceive()+0x60>)
   1351c:	f002 f8b4 	bl	15688 <__cyg_profile_func_enter>
    uint8_t Rdata =0;
   13520:	2300      	movs	r3, #0
   13522:	f88d 3007 	strb.w	r3, [sp, #7]
    if(UART[selUart]->LSR & (1<<0))
   13526:	4b13      	ldr	r3, [pc, #76]	; (13574 <LabUART::UartReceive()+0x64>)
   13528:	781b      	ldrb	r3, [r3, #0]
   1352a:	461a      	mov	r2, r3
   1352c:	4b12      	ldr	r3, [pc, #72]	; (13578 <LabUART::UartReceive()+0x68>)
   1352e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13532:	7d1b      	ldrb	r3, [r3, #20]
   13534:	b2db      	uxtb	r3, r3
   13536:	f003 0301 	and.w	r3, r3, #1
   1353a:	2b00      	cmp	r3, #0
   1353c:	bf14      	ite	ne
   1353e:	2301      	movne	r3, #1
   13540:	2300      	moveq	r3, #0
   13542:	b2db      	uxtb	r3, r3
   13544:	2b00      	cmp	r3, #0
   13546:	d008      	beq.n	1355a <LabUART::UartReceive()+0x4a>
    {
        Rdata= UART[selUart]->RBR;
   13548:	4b0a      	ldr	r3, [pc, #40]	; (13574 <LabUART::UartReceive()+0x64>)
   1354a:	781b      	ldrb	r3, [r3, #0]
   1354c:	461a      	mov	r2, r3
   1354e:	4b0a      	ldr	r3, [pc, #40]	; (13578 <LabUART::UartReceive()+0x68>)
   13550:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13554:	781b      	ldrb	r3, [r3, #0]
   13556:	f88d 3007 	strb.w	r3, [sp, #7]
    }
    return Rdata;
   1355a:	f89d 4007 	ldrb.w	r4, [sp, #7]
   1355e:	462b      	mov	r3, r5
   13560:	4619      	mov	r1, r3
   13562:	4803      	ldr	r0, [pc, #12]	; (13570 <LabUART::UartReceive()+0x60>)
   13564:	f002 f8a4 	bl	156b0 <__cyg_profile_func_exit>
   13568:	4623      	mov	r3, r4
    
}
   1356a:	4618      	mov	r0, r3
   1356c:	b003      	add	sp, #12
   1356e:	bd30      	pop	{r4, r5, pc}
   13570:	00013511 	.word	0x00013511
   13574:	10000a78 	.word	0x10000a78
   13578:	1000045c 	.word	0x1000045c

0001357c <LabUART::vReceiveByteOverUartTask(void*)>:
void LabUART::vReceiveByteOverUartTask(void * pvParamater){
   1357c:	b500      	push	{lr}
   1357e:	b089      	sub	sp, #36	; 0x24
   13580:	4673      	mov	r3, lr
   13582:	9001      	str	r0, [sp, #4]
   13584:	4619      	mov	r1, r3
   13586:	4822      	ldr	r0, [pc, #136]	; (13610 <LabUART::vReceiveByteOverUartTask(void*)+0x94>)
   13588:	f002 f87e 	bl	15688 <__cyg_profile_func_enter>
     oled_terminal.Initialize();
   1358c:	4821      	ldr	r0, [pc, #132]	; (13614 <LabUART::vReceiveByteOverUartTask(void*)+0x98>)
   1358e:	f7ff fcb9 	bl	12f04 <OledTerminal::Initialize()>
uint8_t data = 0;
   13592:	2300      	movs	r3, #0
   13594:	f88d 3017 	strb.w	r3, [sp, #23]
  int Rx_x[3];
  int res=0;
   13598:	2300      	movs	r3, #0
   1359a:	9306      	str	r3, [sp, #24]
  int index = 0;
   1359c:	2300      	movs	r3, #0
   1359e:	9307      	str	r3, [sp, #28]
  while (true) 
  {
    if (xQueueReceive(Global_Queue_Handle,&data, portMAX_DELAY)) 
   135a0:	4b1d      	ldr	r3, [pc, #116]	; (13618 <LabUART::vReceiveByteOverUartTask(void*)+0x9c>)
   135a2:	681b      	ldr	r3, [r3, #0]
   135a4:	f10d 0117 	add.w	r1, sp, #23
   135a8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   135ac:	4618      	mov	r0, r3
   135ae:	f002 ffeb 	bl	16588 <xQueueReceive>
   135b2:	4603      	mov	r3, r0
   135b4:	2b00      	cmp	r3, #0
   135b6:	bf14      	ite	ne
   135b8:	2301      	movne	r3, #1
   135ba:	2300      	moveq	r3, #0
   135bc:	b2db      	uxtb	r3, r3
   135be:	2b00      	cmp	r3, #0
   135c0:	d016      	beq.n	135f0 <LabUART::vReceiveByteOverUartTask(void*)+0x74>
    {
      Rx_x[index] = data;
   135c2:	f89d 3017 	ldrb.w	r3, [sp, #23]
   135c6:	461a      	mov	r2, r3
   135c8:	9b07      	ldr	r3, [sp, #28]
   135ca:	009b      	lsls	r3, r3, #2
   135cc:	a908      	add	r1, sp, #32
   135ce:	440b      	add	r3, r1
   135d0:	f843 2c18 	str.w	r2, [r3, #-24]
      oled_terminal.printf("Data Received: %i\n", Rx_x[index]);
   135d4:	9b07      	ldr	r3, [sp, #28]
   135d6:	009b      	lsls	r3, r3, #2
   135d8:	aa08      	add	r2, sp, #32
   135da:	4413      	add	r3, r2
   135dc:	f853 3c18 	ldr.w	r3, [r3, #-24]
   135e0:	461a      	mov	r2, r3
   135e2:	490e      	ldr	r1, [pc, #56]	; (1361c <LabUART::vReceiveByteOverUartTask(void*)+0xa0>)
   135e4:	480b      	ldr	r0, [pc, #44]	; (13614 <LabUART::vReceiveByteOverUartTask(void*)+0x98>)
   135e6:	f7ff fcb3 	bl	12f50 <OledTerminal::printf(char const*, ...)>
      index++; 
   135ea:	9b07      	ldr	r3, [sp, #28]
   135ec:	3301      	adds	r3, #1
   135ee:	9307      	str	r3, [sp, #28]
    }
    if(index == 3)
   135f0:	9b07      	ldr	r3, [sp, #28]
   135f2:	2b03      	cmp	r3, #3
   135f4:	d1d4      	bne.n	135a0 <LabUART::vReceiveByteOverUartTask(void*)+0x24>
    {
       res = ALU(Rx_x);
   135f6:	ab02      	add	r3, sp, #8
   135f8:	4618      	mov	r0, r3
   135fa:	f000 f837 	bl	1366c <LabUART::ALU(int*)>
   135fe:	9006      	str	r0, [sp, #24]
       oled_terminal.printf("Result: %i\n", res);
   13600:	9a06      	ldr	r2, [sp, #24]
   13602:	4907      	ldr	r1, [pc, #28]	; (13620 <LabUART::vReceiveByteOverUartTask(void*)+0xa4>)
   13604:	4803      	ldr	r0, [pc, #12]	; (13614 <LabUART::vReceiveByteOverUartTask(void*)+0x98>)
   13606:	f7ff fca3 	bl	12f50 <OledTerminal::printf(char const*, ...)>
       index = 0;
   1360a:	2300      	movs	r3, #0
   1360c:	9307      	str	r3, [sp, #28]
    if (xQueueReceive(Global_Queue_Handle,&data, portMAX_DELAY)) 
   1360e:	e7c7      	b.n	135a0 <LabUART::vReceiveByteOverUartTask(void*)+0x24>
   13610:	0001357d 	.word	0x0001357d
   13614:	10000a80 	.word	0x10000a80
   13618:	10001248 	.word	0x10001248
   1361c:	0001a0a8 	.word	0x0001a0a8
   13620:	0001a0bc 	.word	0x0001a0bc

00013624 <LabUART::RX_Int()>:
    }
  }
}
void LabUART::RX_Int(){
   13624:	b510      	push	{r4, lr}
   13626:	b082      	sub	sp, #8
   13628:	4674      	mov	r4, lr
   1362a:	4623      	mov	r3, r4
   1362c:	4619      	mov	r1, r3
   1362e:	480d      	ldr	r0, [pc, #52]	; (13664 <LabUART::RX_Int()+0x40>)
   13630:	f002 f82a 	bl	15688 <__cyg_profile_func_enter>
  
  uint8_t idata = 0;
   13634:	2300      	movs	r3, #0
   13636:	f88d 3007 	strb.w	r3, [sp, #7]
  idata = UartReceive();
   1363a:	f7ff ff69 	bl	13510 <LabUART::UartReceive()>
   1363e:	4603      	mov	r3, r0
   13640:	f88d 3007 	strb.w	r3, [sp, #7]
  xQueueSendFromISR(Global_Queue_Handle, &idata, NULL);
   13644:	4b08      	ldr	r3, [pc, #32]	; (13668 <LabUART::RX_Int()+0x44>)
   13646:	6818      	ldr	r0, [r3, #0]
   13648:	f10d 0107 	add.w	r1, sp, #7
   1364c:	2300      	movs	r3, #0
   1364e:	2200      	movs	r2, #0
   13650:	f002 ff41 	bl	164d6 <xQueueGenericSendFromISR>
   13654:	4623      	mov	r3, r4
   13656:	4619      	mov	r1, r3
   13658:	4802      	ldr	r0, [pc, #8]	; (13664 <LabUART::RX_Int()+0x40>)
   1365a:	f002 f829 	bl	156b0 <__cyg_profile_func_exit>
  
}
   1365e:	bf00      	nop
   13660:	b002      	add	sp, #8
   13662:	bd10      	pop	{r4, pc}
   13664:	00013625 	.word	0x00013625
   13668:	10001248 	.word	0x10001248

0001366c <LabUART::ALU(int*)>:
int LabUART::ALU(int *array){
   1366c:	b530      	push	{r4, r5, lr}
   1366e:	b087      	sub	sp, #28
   13670:	4675      	mov	r5, lr
   13672:	9001      	str	r0, [sp, #4]
   13674:	462b      	mov	r3, r5
   13676:	4619      	mov	r1, r3
   13678:	4819      	ldr	r0, [pc, #100]	; (136e0 <LabUART::ALU(int*)+0x74>)
   1367a:	f002 f805 	bl	15688 <__cyg_profile_func_enter>
    int num1, num2;
    int result = 0;
   1367e:	2300      	movs	r3, #0
   13680:	9305      	str	r3, [sp, #20]
    num1 = array[0];
   13682:	9b01      	ldr	r3, [sp, #4]
   13684:	681b      	ldr	r3, [r3, #0]
   13686:	9304      	str	r3, [sp, #16]
    num2 = array[1];
   13688:	9b01      	ldr	r3, [sp, #4]
   1368a:	685b      	ldr	r3, [r3, #4]
   1368c:	9303      	str	r3, [sp, #12]
    switch(static_cast<char>(array[2]))
   1368e:	9b01      	ldr	r3, [sp, #4]
   13690:	3308      	adds	r3, #8
   13692:	681b      	ldr	r3, [r3, #0]
   13694:	b2db      	uxtb	r3, r3
   13696:	2b2b      	cmp	r3, #43	; 0x2b
   13698:	d004      	beq.n	136a4 <LabUART::ALU(int*)+0x38>
   1369a:	2b2d      	cmp	r3, #45	; 0x2d
   1369c:	d007      	beq.n	136ae <LabUART::ALU(int*)+0x42>
   1369e:	2b2a      	cmp	r3, #42	; 0x2a
   136a0:	d00a      	beq.n	136b8 <LabUART::ALU(int*)+0x4c>
   136a2:	e00f      	b.n	136c4 <LabUART::ALU(int*)+0x58>
    {
        case '+':
        result = num1 + num2;
   136a4:	9a04      	ldr	r2, [sp, #16]
   136a6:	9b03      	ldr	r3, [sp, #12]
   136a8:	4413      	add	r3, r2
   136aa:	9305      	str	r3, [sp, #20]
        break;
   136ac:	e00a      	b.n	136c4 <LabUART::ALU(int*)+0x58>
        
        case '-':
        result = num2 - num1;
   136ae:	9a03      	ldr	r2, [sp, #12]
   136b0:	9b04      	ldr	r3, [sp, #16]
   136b2:	1ad3      	subs	r3, r2, r3
   136b4:	9305      	str	r3, [sp, #20]
        break;
   136b6:	e005      	b.n	136c4 <LabUART::ALU(int*)+0x58>
        
        case '*':
        result = num1 * num2;
   136b8:	9b04      	ldr	r3, [sp, #16]
   136ba:	9a03      	ldr	r2, [sp, #12]
   136bc:	fb02 f303 	mul.w	r3, r2, r3
   136c0:	9305      	str	r3, [sp, #20]
        break;
   136c2:	bf00      	nop
    }
  
    UartSend(result);
   136c4:	9805      	ldr	r0, [sp, #20]
   136c6:	f7ff fef1 	bl	134ac <LabUART::UartSend(int)>
    return result;
   136ca:	9c05      	ldr	r4, [sp, #20]
   136cc:	462b      	mov	r3, r5
   136ce:	4619      	mov	r1, r3
   136d0:	4803      	ldr	r0, [pc, #12]	; (136e0 <LabUART::ALU(int*)+0x74>)
   136d2:	f001 ffed 	bl	156b0 <__cyg_profile_func_exit>
   136d6:	4623      	mov	r3, r4
}
   136d8:	4618      	mov	r0, r3
   136da:	b007      	add	sp, #28
   136dc:	bd30      	pop	{r4, r5, pc}
   136de:	bf00      	nop
   136e0:	0001366d 	.word	0x0001366d

000136e4 <LabUART::Uqueue()>:
void LabUART::Uqueue(){
   136e4:	b510      	push	{r4, lr}
   136e6:	4674      	mov	r4, lr
   136e8:	4623      	mov	r3, r4
   136ea:	4619      	mov	r1, r3
   136ec:	4808      	ldr	r0, [pc, #32]	; (13710 <LabUART::Uqueue()+0x2c>)
   136ee:	f001 ffcb 	bl	15688 <__cyg_profile_func_enter>
      Global_Queue_Handle = xQueueCreate(10,sizeof(10));
   136f2:	2200      	movs	r2, #0
   136f4:	2104      	movs	r1, #4
   136f6:	200a      	movs	r0, #10
   136f8:	f002 fe98 	bl	1642c <xQueueGenericCreate>
   136fc:	4602      	mov	r2, r0
   136fe:	4b05      	ldr	r3, [pc, #20]	; (13714 <LabUART::Uqueue()+0x30>)
   13700:	601a      	str	r2, [r3, #0]
   13702:	4623      	mov	r3, r4
   13704:	4619      	mov	r1, r3
   13706:	4802      	ldr	r0, [pc, #8]	; (13710 <LabUART::Uqueue()+0x2c>)
   13708:	f001 ffd2 	bl	156b0 <__cyg_profile_func_exit>
   1370c:	bf00      	nop
   1370e:	bd10      	pop	{r4, pc}
   13710:	000136e5 	.word	0x000136e5
   13714:	10001248 	.word	0x10001248

00013718 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)>:
constexpr T Set(T target, uint32_t position)
   13718:	b530      	push	{r4, r5, lr}
   1371a:	b083      	sub	sp, #12
   1371c:	4675      	mov	r5, lr
   1371e:	9001      	str	r0, [sp, #4]
   13720:	9100      	str	r1, [sp, #0]
   13722:	462b      	mov	r3, r5
   13724:	4619      	mov	r1, r3
   13726:	480a      	ldr	r0, [pc, #40]	; (13750 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   13728:	f001 ffae 	bl	15688 <__cyg_profile_func_enter>
  return target | (1 << position);
   1372c:	2201      	movs	r2, #1
   1372e:	9b00      	ldr	r3, [sp, #0]
   13730:	fa02 f303 	lsl.w	r3, r2, r3
   13734:	461a      	mov	r2, r3
   13736:	9b01      	ldr	r3, [sp, #4]
   13738:	ea42 0403 	orr.w	r4, r2, r3
   1373c:	462b      	mov	r3, r5
   1373e:	4619      	mov	r1, r3
   13740:	4803      	ldr	r0, [pc, #12]	; (13750 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   13742:	f001 ffb5 	bl	156b0 <__cyg_profile_func_exit>
   13746:	4623      	mov	r3, r4
}
   13748:	4618      	mov	r0, r3
   1374a:	b003      	add	sp, #12
   1374c:	bd30      	pop	{r4, r5, pc}
   1374e:	bf00      	nop
   13750:	00013719 	.word	0x00013719

00013754 <bool bit::Read<unsigned long>(unsigned long, unsigned long)>:
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
   13754:	b530      	push	{r4, r5, lr}
   13756:	b083      	sub	sp, #12
   13758:	4675      	mov	r5, lr
   1375a:	9001      	str	r0, [sp, #4]
   1375c:	9100      	str	r1, [sp, #0]
   1375e:	462b      	mov	r3, r5
   13760:	4619      	mov	r1, r3
   13762:	480c      	ldr	r0, [pc, #48]	; (13794 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   13764:	f001 ff90 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   13768:	2201      	movs	r2, #1
   1376a:	9b00      	ldr	r3, [sp, #0]
   1376c:	fa02 f303 	lsl.w	r3, r2, r3
   13770:	461a      	mov	r2, r3
   13772:	9b01      	ldr	r3, [sp, #4]
   13774:	4013      	ands	r3, r2
   13776:	2b00      	cmp	r3, #0
   13778:	bf14      	ite	ne
   1377a:	2301      	movne	r3, #1
   1377c:	2300      	moveq	r3, #0
   1377e:	b2dc      	uxtb	r4, r3
   13780:	462b      	mov	r3, r5
   13782:	4619      	mov	r1, r3
   13784:	4803      	ldr	r0, [pc, #12]	; (13794 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   13786:	f001 ff93 	bl	156b0 <__cyg_profile_func_exit>
   1378a:	4623      	mov	r3, r4
}
   1378c:	4618      	mov	r0, r3
   1378e:	b003      	add	sp, #12
   13790:	bd30      	pop	{r4, r5, pc}
   13792:	bf00      	nop
   13794:	00013755 	.word	0x00013755

00013798 <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   13798:	b530      	push	{r4, r5, lr}
   1379a:	b089      	sub	sp, #36	; 0x24
   1379c:	4675      	mov	r5, lr
   1379e:	9003      	str	r0, [sp, #12]
   137a0:	9201      	str	r2, [sp, #4]
   137a2:	9300      	str	r3, [sp, #0]
   137a4:	460b      	mov	r3, r1
   137a6:	f88d 300b 	strb.w	r3, [sp, #11]
   137aa:	462b      	mov	r3, r5
   137ac:	4619      	mov	r1, r3
   137ae:	4816      	ldr	r0, [pc, #88]	; (13808 <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   137b0:	f001 ff6a 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   137b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   137b8:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   137ba:	2320      	movs	r3, #32
   137bc:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   137be:	9b00      	ldr	r3, [sp, #0]
   137c0:	f1c3 0320 	rsb	r3, r3, #32
   137c4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   137c8:	fa22 f303 	lsr.w	r3, r2, r3
   137cc:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   137ce:	9a05      	ldr	r2, [sp, #20]
   137d0:	9b01      	ldr	r3, [sp, #4]
   137d2:	fa02 f303 	lsl.w	r3, r2, r3
   137d6:	43db      	mvns	r3, r3
   137d8:	9a03      	ldr	r2, [sp, #12]
   137da:	4013      	ands	r3, r2
   137dc:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   137de:	f89d 200b 	ldrb.w	r2, [sp, #11]
   137e2:	9b05      	ldr	r3, [sp, #20]
   137e4:	401a      	ands	r2, r3
   137e6:	9b01      	ldr	r3, [sp, #4]
   137e8:	fa02 f303 	lsl.w	r3, r2, r3
   137ec:	9a03      	ldr	r2, [sp, #12]
   137ee:	4313      	orrs	r3, r2
   137f0:	9303      	str	r3, [sp, #12]
  return target;
   137f2:	9c03      	ldr	r4, [sp, #12]
   137f4:	462b      	mov	r3, r5
   137f6:	4619      	mov	r1, r3
   137f8:	4803      	ldr	r0, [pc, #12]	; (13808 <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   137fa:	f001 ff59 	bl	156b0 <__cyg_profile_func_exit>
   137fe:	4623      	mov	r3, r4
}
   13800:	4618      	mov	r0, r3
   13802:	b009      	add	sp, #36	; 0x24
   13804:	bd30      	pop	{r4, r5, pc}
   13806:	bf00      	nop
   13808:	00013799 	.word	0x00013799

0001380c <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)>:
constexpr T Extract(T target, uint32_t position, uint32_t width = 1)
   1380c:	b530      	push	{r4, r5, lr}
   1380e:	b089      	sub	sp, #36	; 0x24
   13810:	4675      	mov	r5, lr
   13812:	9003      	str	r0, [sp, #12]
   13814:	9102      	str	r1, [sp, #8]
   13816:	9201      	str	r2, [sp, #4]
   13818:	462b      	mov	r3, r5
   1381a:	4619      	mov	r1, r3
   1381c:	480f      	ldr	r0, [pc, #60]	; (1385c <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   1381e:	f001 ff33 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   13822:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13826:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   13828:	2320      	movs	r3, #32
   1382a:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1382c:	9b01      	ldr	r3, [sp, #4]
   1382e:	f1c3 0320 	rsb	r3, r3, #32
   13832:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13836:	fa22 f303 	lsr.w	r3, r2, r3
   1383a:	9305      	str	r3, [sp, #20]
  return (target >> position) & mask;
   1383c:	9a03      	ldr	r2, [sp, #12]
   1383e:	9b02      	ldr	r3, [sp, #8]
   13840:	40da      	lsrs	r2, r3
   13842:	9b05      	ldr	r3, [sp, #20]
   13844:	ea02 0403 	and.w	r4, r2, r3
   13848:	462b      	mov	r3, r5
   1384a:	4619      	mov	r1, r3
   1384c:	4803      	ldr	r0, [pc, #12]	; (1385c <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   1384e:	f001 ff2f 	bl	156b0 <__cyg_profile_func_exit>
   13852:	4623      	mov	r3, r4
}
   13854:	4618      	mov	r0, r3
   13856:	b009      	add	sp, #36	; 0x24
   13858:	bd30      	pop	{r4, r5, pc}
   1385a:	bf00      	nop
   1385c:	0001380d 	.word	0x0001380d

00013860 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   13860:	b530      	push	{r4, r5, lr}
   13862:	b089      	sub	sp, #36	; 0x24
   13864:	4675      	mov	r5, lr
   13866:	9003      	str	r0, [sp, #12]
   13868:	9201      	str	r2, [sp, #4]
   1386a:	9300      	str	r3, [sp, #0]
   1386c:	460b      	mov	r3, r1
   1386e:	f88d 300b 	strb.w	r3, [sp, #11]
   13872:	462b      	mov	r3, r5
   13874:	4619      	mov	r1, r3
   13876:	4816      	ldr	r0, [pc, #88]	; (138d0 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   13878:	f001 ff06 	bl	15688 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1387c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13880:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   13882:	2320      	movs	r3, #32
   13884:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   13886:	9b00      	ldr	r3, [sp, #0]
   13888:	f1c3 0320 	rsb	r3, r3, #32
   1388c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13890:	fa22 f303 	lsr.w	r3, r2, r3
   13894:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   13896:	9a05      	ldr	r2, [sp, #20]
   13898:	9b01      	ldr	r3, [sp, #4]
   1389a:	fa02 f303 	lsl.w	r3, r2, r3
   1389e:	43db      	mvns	r3, r3
   138a0:	9a03      	ldr	r2, [sp, #12]
   138a2:	4013      	ands	r3, r2
   138a4:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   138a6:	f89d 200b 	ldrb.w	r2, [sp, #11]
   138aa:	9b05      	ldr	r3, [sp, #20]
   138ac:	401a      	ands	r2, r3
   138ae:	9b01      	ldr	r3, [sp, #4]
   138b0:	fa02 f303 	lsl.w	r3, r2, r3
   138b4:	9a03      	ldr	r2, [sp, #12]
   138b6:	4313      	orrs	r3, r2
   138b8:	9303      	str	r3, [sp, #12]
  return target;
   138ba:	9c03      	ldr	r4, [sp, #12]
   138bc:	462b      	mov	r3, r5
   138be:	4619      	mov	r1, r3
   138c0:	4803      	ldr	r0, [pc, #12]	; (138d0 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   138c2:	f001 fef5 	bl	156b0 <__cyg_profile_func_exit>
   138c6:	4623      	mov	r3, r4
}
   138c8:	4618      	mov	r0, r3
   138ca:	b009      	add	sp, #36	; 0x24
   138cc:	bd30      	pop	{r4, r5, pc}
   138ce:	bf00      	nop
   138d0:	00013861 	.word	0x00013861

000138d4 <__static_initialization_and_destruction_0(int, int)>:
   138d4:	b510      	push	{r4, lr}
   138d6:	b082      	sub	sp, #8
   138d8:	4674      	mov	r4, lr
   138da:	9001      	str	r0, [sp, #4]
   138dc:	9100      	str	r1, [sp, #0]
   138de:	4623      	mov	r3, r4
   138e0:	4619      	mov	r1, r3
   138e2:	480f      	ldr	r0, [pc, #60]	; (13920 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   138e4:	f001 fed0 	bl	15688 <__cyg_profile_func_enter>
   138e8:	9b01      	ldr	r3, [sp, #4]
   138ea:	2b01      	cmp	r3, #1
   138ec:	d110      	bne.n	13910 <__static_initialization_and_destruction_0(int, int)+0x3c>
   138ee:	9b00      	ldr	r3, [sp, #0]
   138f0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   138f4:	4293      	cmp	r3, r2
   138f6:	d10b      	bne.n	13910 <__static_initialization_and_destruction_0(int, int)+0x3c>
        static void Uqueue();
     
     private:
    inline static uint8_t selUart;
     inline static pinconn pc;
     inline static OledTerminal oled_terminal;
   138f8:	4b0a      	ldr	r3, [pc, #40]	; (13924 <__static_initialization_and_destruction_0(int, int)+0x50>)
   138fa:	681b      	ldr	r3, [r3, #0]
   138fc:	f003 0301 	and.w	r3, r3, #1
   13900:	2b00      	cmp	r3, #0
   13902:	d105      	bne.n	13910 <__static_initialization_and_destruction_0(int, int)+0x3c>
   13904:	4b07      	ldr	r3, [pc, #28]	; (13924 <__static_initialization_and_destruction_0(int, int)+0x50>)
   13906:	2201      	movs	r2, #1
   13908:	601a      	str	r2, [r3, #0]
   1390a:	4807      	ldr	r0, [pc, #28]	; (13928 <__static_initialization_and_destruction_0(int, int)+0x54>)
   1390c:	f7ff fc42 	bl	13194 <OledTerminal::OledTerminal()>
   13910:	4623      	mov	r3, r4
   13912:	4619      	mov	r1, r3
   13914:	4802      	ldr	r0, [pc, #8]	; (13920 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   13916:	f001 fecb 	bl	156b0 <__cyg_profile_func_exit>
   1391a:	bf00      	nop
   1391c:	b002      	add	sp, #8
   1391e:	bd10      	pop	{r4, pc}
   13920:	000138d5 	.word	0x000138d5
   13924:	1000124c 	.word	0x1000124c
   13928:	10000a80 	.word	0x10000a80

0001392c <_GLOBAL__sub_I__ZN7LabUART19Global_Queue_HandleE>:
   1392c:	b510      	push	{r4, lr}
   1392e:	4674      	mov	r4, lr
   13930:	4623      	mov	r3, r4
   13932:	4619      	mov	r1, r3
   13934:	4806      	ldr	r0, [pc, #24]	; (13950 <_GLOBAL__sub_I__ZN7LabUART19Global_Queue_HandleE+0x24>)
   13936:	f001 fea7 	bl	15688 <__cyg_profile_func_enter>
   1393a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1393e:	2001      	movs	r0, #1
   13940:	f7ff ffc8 	bl	138d4 <__static_initialization_and_destruction_0(int, int)>
   13944:	4623      	mov	r3, r4
   13946:	4619      	mov	r1, r3
   13948:	4801      	ldr	r0, [pc, #4]	; (13950 <_GLOBAL__sub_I__ZN7LabUART19Global_Queue_HandleE+0x24>)
   1394a:	f001 feb1 	bl	156b0 <__cyg_profile_func_exit>
   1394e:	bd10      	pop	{r4, pc}
   13950:	0001392d 	.word	0x0001392d

00013954 <main>:
int ALU(int *array);
*/
LabUART uart_rx(2);

int main() 
{   
   13954:	b530      	push	{r4, r5, lr}
   13956:	b085      	sub	sp, #20
   13958:	4675      	mov	r5, lr
   1395a:	462b      	mov	r3, r5
   1395c:	4619      	mov	r1, r3
   1395e:	4818      	ldr	r0, [pc, #96]	; (139c0 <main+0x6c>)
   13960:	f001 fe92 	bl	15688 <__cyg_profile_func_enter>
  char hold = '*';
   13964:	232a      	movs	r3, #42	; 0x2a
   13966:	f88d 300f 	strb.w	r3, [sp, #15]
  LOG_INFO("Start\n");
   1396a:	2324      	movs	r3, #36	; 0x24
   1396c:	4a15      	ldr	r2, [pc, #84]	; (139c4 <main+0x70>)
   1396e:	4916      	ldr	r1, [pc, #88]	; (139c8 <main+0x74>)
   13970:	4816      	ldr	r0, [pc, #88]	; (139cc <main+0x78>)
   13972:	f004 fa6d 	bl	17e50 <printf>
  //Global_Queue_Handle = xQueueCreate(10,sizeof(10));
  xTaskCreate(LabUART::vReceiveByteOverUartTask,(const char*) "receive", 4096, NULL, 1 , NULL);
   13976:	2300      	movs	r3, #0
   13978:	9301      	str	r3, [sp, #4]
   1397a:	2301      	movs	r3, #1
   1397c:	9300      	str	r3, [sp, #0]
   1397e:	2300      	movs	r3, #0
   13980:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   13984:	4912      	ldr	r1, [pc, #72]	; (139d0 <main+0x7c>)
   13986:	4813      	ldr	r0, [pc, #76]	; (139d4 <main+0x80>)
   13988:	f001 ff93 	bl	158b2 <xTaskCreate>
  //oled_terminal.Initialize();
  //InitializeUart2();
  uart_rx.InitializeUart();
   1398c:	f7ff fc58 	bl	13240 <LabUART::InitializeUart()>
  uart_rx.UartSend(2);
   13990:	2002      	movs	r0, #2
   13992:	f7ff fd8b 	bl	134ac <LabUART::UartSend(int)>
  uart_rx.UartSend(5);
   13996:	2005      	movs	r0, #5
   13998:	f7ff fd88 	bl	134ac <LabUART::UartSend(int)>
  uart_rx.UartSend(hold);
   1399c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   139a0:	4618      	mov	r0, r3
   139a2:	f7ff fd83 	bl	134ac <LabUART::UartSend(int)>
  vTaskStartScheduler();
   139a6:	f002 f8b3 	bl	15b10 <vTaskStartScheduler>
  //Uart2Receive();
  
}
   139aa:	2400      	movs	r4, #0
   139ac:	462b      	mov	r3, r5
   139ae:	4619      	mov	r1, r3
   139b0:	4803      	ldr	r0, [pc, #12]	; (139c0 <main+0x6c>)
   139b2:	f001 fe7d 	bl	156b0 <__cyg_profile_func_exit>
   139b6:	4623      	mov	r3, r4
   139b8:	4618      	mov	r0, r3
   139ba:	b005      	add	sp, #20
   139bc:	bd30      	pop	{r4, r5, pc}
   139be:	bf00      	nop
   139c0:	00013955 	.word	0x00013955
   139c4:	0001abc0 	.word	0x0001abc0
   139c8:	0001abb4 	.word	0x0001abb4
   139cc:	0001ab6c 	.word	0x0001ab6c
   139d0:	0001abac 	.word	0x0001abac
   139d4:	0001357d 	.word	0x0001357d

000139d8 <__static_initialization_and_destruction_0(int, int)>:
   139d8:	b510      	push	{r4, lr}
   139da:	b082      	sub	sp, #8
   139dc:	4674      	mov	r4, lr
   139de:	9001      	str	r0, [sp, #4]
   139e0:	9100      	str	r1, [sp, #0]
   139e2:	4623      	mov	r3, r4
   139e4:	4619      	mov	r1, r3
   139e6:	4811      	ldr	r0, [pc, #68]	; (13a2c <__static_initialization_and_destruction_0(int, int)+0x54>)
   139e8:	f001 fe4e 	bl	15688 <__cyg_profile_func_enter>
   139ec:	9b01      	ldr	r3, [sp, #4]
   139ee:	2b01      	cmp	r3, #1
   139f0:	d114      	bne.n	13a1c <__static_initialization_and_destruction_0(int, int)+0x44>
   139f2:	9b00      	ldr	r3, [sp, #0]
   139f4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   139f8:	4293      	cmp	r3, r2
   139fa:	d10f      	bne.n	13a1c <__static_initialization_and_destruction_0(int, int)+0x44>
   139fc:	4b0c      	ldr	r3, [pc, #48]	; (13a30 <__static_initialization_and_destruction_0(int, int)+0x58>)
   139fe:	681b      	ldr	r3, [r3, #0]
   13a00:	f003 0301 	and.w	r3, r3, #1
   13a04:	2b00      	cmp	r3, #0
   13a06:	d105      	bne.n	13a14 <__static_initialization_and_destruction_0(int, int)+0x3c>
   13a08:	4b09      	ldr	r3, [pc, #36]	; (13a30 <__static_initialization_and_destruction_0(int, int)+0x58>)
   13a0a:	2201      	movs	r2, #1
   13a0c:	601a      	str	r2, [r3, #0]
   13a0e:	4809      	ldr	r0, [pc, #36]	; (13a34 <__static_initialization_and_destruction_0(int, int)+0x5c>)
   13a10:	f7ff fbc0 	bl	13194 <OledTerminal::OledTerminal()>
LabUART uart_rx(2);
   13a14:	2102      	movs	r1, #2
   13a16:	4808      	ldr	r0, [pc, #32]	; (13a38 <__static_initialization_and_destruction_0(int, int)+0x60>)
   13a18:	f7ff fbf2 	bl	13200 <LabUART::LabUART(unsigned char)>
   13a1c:	4623      	mov	r3, r4
   13a1e:	4619      	mov	r1, r3
   13a20:	4802      	ldr	r0, [pc, #8]	; (13a2c <__static_initialization_and_destruction_0(int, int)+0x54>)
   13a22:	f001 fe45 	bl	156b0 <__cyg_profile_func_exit>
}
   13a26:	bf00      	nop
   13a28:	b002      	add	sp, #8
   13a2a:	bd10      	pop	{r4, pc}
   13a2c:	000139d9 	.word	0x000139d9
   13a30:	1000124c 	.word	0x1000124c
   13a34:	10000a80 	.word	0x10000a80
   13a38:	10001250 	.word	0x10001250

00013a3c <_GLOBAL__sub_I_uart_rx>:
   13a3c:	b510      	push	{r4, lr}
   13a3e:	4674      	mov	r4, lr
   13a40:	4623      	mov	r3, r4
   13a42:	4619      	mov	r1, r3
   13a44:	4806      	ldr	r0, [pc, #24]	; (13a60 <_GLOBAL__sub_I_uart_rx+0x24>)
   13a46:	f001 fe1f 	bl	15688 <__cyg_profile_func_enter>
   13a4a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   13a4e:	2001      	movs	r0, #1
   13a50:	f7ff ffc2 	bl	139d8 <__static_initialization_and_destruction_0(int, int)>
   13a54:	4623      	mov	r3, r4
   13a56:	4619      	mov	r1, r3
   13a58:	4801      	ldr	r0, [pc, #4]	; (13a60 <_GLOBAL__sub_I_uart_rx+0x24>)
   13a5a:	f001 fe29 	bl	156b0 <__cyg_profile_func_exit>
   13a5e:	bd10      	pop	{r4, pc}
   13a60:	00013a3d 	.word	0x00013a3d

00013a64 <pinconn::clear7(unsigned char, unsigned char)>:
    else
    {
        printf("Not a MOSI port");
    }
}
void pinconn::clear7(uint8_t port, uint8_t pin){
   13a64:	b510      	push	{r4, lr}
   13a66:	b082      	sub	sp, #8
   13a68:	4674      	mov	r4, lr
   13a6a:	9001      	str	r0, [sp, #4]
   13a6c:	460b      	mov	r3, r1
   13a6e:	f88d 3003 	strb.w	r3, [sp, #3]
   13a72:	4613      	mov	r3, r2
   13a74:	f88d 3002 	strb.w	r3, [sp, #2]
   13a78:	4623      	mov	r3, r4
   13a7a:	4619      	mov	r1, r3
   13a7c:	4810      	ldr	r0, [pc, #64]	; (13ac0 <pinconn::clear7(unsigned char, unsigned char)+0x5c>)
   13a7e:	f001 fe03 	bl	15688 <__cyg_profile_func_enter>
    *pincon[port][pin] &= ~(0x7F<<0);
   13a82:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13a86:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13a8a:	490e      	ldr	r1, [pc, #56]	; (13ac4 <pinconn::clear7(unsigned char, unsigned char)+0x60>)
   13a8c:	0152      	lsls	r2, r2, #5
   13a8e:	4413      	add	r3, r2
   13a90:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13a94:	681a      	ldr	r2, [r3, #0]
   13a96:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13a9a:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13a9e:	4809      	ldr	r0, [pc, #36]	; (13ac4 <pinconn::clear7(unsigned char, unsigned char)+0x60>)
   13aa0:	0149      	lsls	r1, r1, #5
   13aa2:	440b      	add	r3, r1
   13aa4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13aa8:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   13aac:	601a      	str	r2, [r3, #0]
   13aae:	4623      	mov	r3, r4
   13ab0:	4619      	mov	r1, r3
   13ab2:	4803      	ldr	r0, [pc, #12]	; (13ac0 <pinconn::clear7(unsigned char, unsigned char)+0x5c>)
   13ab4:	f001 fdfc 	bl	156b0 <__cyg_profile_func_exit>
}
   13ab8:	bf00      	nop
   13aba:	b002      	add	sp, #8
   13abc:	bd10      	pop	{r4, pc}
   13abe:	bf00      	nop
   13ac0:	00013a65 	.word	0x00013a65
   13ac4:	10000464 	.word	0x10000464

00013ac8 <pinconn::uart2_txd(unsigned char, unsigned char)>:
void pinconn::uart2_txd(uint8_t port, uint8_t pin){ 
   13ac8:	b510      	push	{r4, lr}
   13aca:	b082      	sub	sp, #8
   13acc:	4674      	mov	r4, lr
   13ace:	9001      	str	r0, [sp, #4]
   13ad0:	460b      	mov	r3, r1
   13ad2:	f88d 3003 	strb.w	r3, [sp, #3]
   13ad6:	4613      	mov	r3, r2
   13ad8:	f88d 3002 	strb.w	r3, [sp, #2]
   13adc:	4623      	mov	r3, r4
   13ade:	4619      	mov	r1, r3
   13ae0:	4827      	ldr	r0, [pc, #156]	; (13b80 <pinconn::uart2_txd(unsigned char, unsigned char)+0xb8>)
   13ae2:	f001 fdd1 	bl	15688 <__cyg_profile_func_enter>
    clear7(port,pin);
   13ae6:	f89d 2002 	ldrb.w	r2, [sp, #2]
   13aea:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13aee:	4619      	mov	r1, r3
   13af0:	9801      	ldr	r0, [sp, #4]
   13af2:	f7ff ffb7 	bl	13a64 <pinconn::clear7(unsigned char, unsigned char)>
    if(((port == 0) && (pin==10))){
   13af6:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13afa:	2b00      	cmp	r3, #0
   13afc:	d11a      	bne.n	13b34 <pinconn::uart2_txd(unsigned char, unsigned char)+0x6c>
   13afe:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13b02:	2b0a      	cmp	r3, #10
   13b04:	d116      	bne.n	13b34 <pinconn::uart2_txd(unsigned char, unsigned char)+0x6c>
        *pincon[port][pin] |= (1<<1);
   13b06:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13b0a:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13b0e:	491d      	ldr	r1, [pc, #116]	; (13b84 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   13b10:	0152      	lsls	r2, r2, #5
   13b12:	4413      	add	r3, r2
   13b14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13b18:	681a      	ldr	r2, [r3, #0]
   13b1a:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13b1e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13b22:	4818      	ldr	r0, [pc, #96]	; (13b84 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   13b24:	0149      	lsls	r1, r1, #5
   13b26:	440b      	add	r3, r1
   13b28:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13b2c:	f042 0202 	orr.w	r2, r2, #2
   13b30:	601a      	str	r2, [r3, #0]
   13b32:	e01d      	b.n	13b70 <pinconn::uart2_txd(unsigned char, unsigned char)+0xa8>
    }
    else if ((port == 2) && (pin==8))
   13b34:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13b38:	2b02      	cmp	r3, #2
   13b3a:	d119      	bne.n	13b70 <pinconn::uart2_txd(unsigned char, unsigned char)+0xa8>
   13b3c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13b40:	2b08      	cmp	r3, #8
   13b42:	d115      	bne.n	13b70 <pinconn::uart2_txd(unsigned char, unsigned char)+0xa8>
    {
        *pincon[port][pin] |= (0b010);
   13b44:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13b48:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13b4c:	490d      	ldr	r1, [pc, #52]	; (13b84 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   13b4e:	0152      	lsls	r2, r2, #5
   13b50:	4413      	add	r3, r2
   13b52:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13b56:	681a      	ldr	r2, [r3, #0]
   13b58:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13b5c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13b60:	4808      	ldr	r0, [pc, #32]	; (13b84 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   13b62:	0149      	lsls	r1, r1, #5
   13b64:	440b      	add	r3, r1
   13b66:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13b6a:	f042 0202 	orr.w	r2, r2, #2
   13b6e:	601a      	str	r2, [r3, #0]
   13b70:	4623      	mov	r3, r4
   13b72:	4619      	mov	r1, r3
   13b74:	4802      	ldr	r0, [pc, #8]	; (13b80 <pinconn::uart2_txd(unsigned char, unsigned char)+0xb8>)
   13b76:	f001 fd9b 	bl	156b0 <__cyg_profile_func_exit>
    }
 }    
   13b7a:	bf00      	nop
   13b7c:	b002      	add	sp, #8
   13b7e:	bd10      	pop	{r4, pc}
   13b80:	00013ac9 	.word	0x00013ac9
   13b84:	10000464 	.word	0x10000464

00013b88 <pinconn::uart2_rxd(unsigned char, unsigned char)>:
 void pinconn::uart2_rxd(uint8_t port, uint8_t pin){
   13b88:	b510      	push	{r4, lr}
   13b8a:	b082      	sub	sp, #8
   13b8c:	4674      	mov	r4, lr
   13b8e:	9001      	str	r0, [sp, #4]
   13b90:	460b      	mov	r3, r1
   13b92:	f88d 3003 	strb.w	r3, [sp, #3]
   13b96:	4613      	mov	r3, r2
   13b98:	f88d 3002 	strb.w	r3, [sp, #2]
   13b9c:	4623      	mov	r3, r4
   13b9e:	4619      	mov	r1, r3
   13ba0:	4827      	ldr	r0, [pc, #156]	; (13c40 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xb8>)
   13ba2:	f001 fd71 	bl	15688 <__cyg_profile_func_enter>
    clear7(port,pin);
   13ba6:	f89d 2002 	ldrb.w	r2, [sp, #2]
   13baa:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13bae:	4619      	mov	r1, r3
   13bb0:	9801      	ldr	r0, [sp, #4]
   13bb2:	f7ff ff57 	bl	13a64 <pinconn::clear7(unsigned char, unsigned char)>
    if(((port == 0) && (pin==11))){
   13bb6:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13bba:	2b00      	cmp	r3, #0
   13bbc:	d11a      	bne.n	13bf4 <pinconn::uart2_rxd(unsigned char, unsigned char)+0x6c>
   13bbe:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13bc2:	2b0b      	cmp	r3, #11
   13bc4:	d116      	bne.n	13bf4 <pinconn::uart2_rxd(unsigned char, unsigned char)+0x6c>
    *pincon[port][pin] |= (1<<1);
   13bc6:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13bca:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13bce:	491d      	ldr	r1, [pc, #116]	; (13c44 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   13bd0:	0152      	lsls	r2, r2, #5
   13bd2:	4413      	add	r3, r2
   13bd4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13bd8:	681a      	ldr	r2, [r3, #0]
   13bda:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13bde:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13be2:	4818      	ldr	r0, [pc, #96]	; (13c44 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   13be4:	0149      	lsls	r1, r1, #5
   13be6:	440b      	add	r3, r1
   13be8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13bec:	f042 0202 	orr.w	r2, r2, #2
   13bf0:	601a      	str	r2, [r3, #0]
   13bf2:	e01d      	b.n	13c30 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xa8>
    }
    else if ((port == 2) && (pin==9))
   13bf4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13bf8:	2b02      	cmp	r3, #2
   13bfa:	d119      	bne.n	13c30 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xa8>
   13bfc:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13c00:	2b09      	cmp	r3, #9
   13c02:	d115      	bne.n	13c30 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xa8>
    {
        *pincon[port][pin] |= (0b010);
   13c04:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13c08:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13c0c:	490d      	ldr	r1, [pc, #52]	; (13c44 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   13c0e:	0152      	lsls	r2, r2, #5
   13c10:	4413      	add	r3, r2
   13c12:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13c16:	681a      	ldr	r2, [r3, #0]
   13c18:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13c1c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13c20:	4808      	ldr	r0, [pc, #32]	; (13c44 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   13c22:	0149      	lsls	r1, r1, #5
   13c24:	440b      	add	r3, r1
   13c26:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13c2a:	f042 0202 	orr.w	r2, r2, #2
   13c2e:	601a      	str	r2, [r3, #0]
   13c30:	4623      	mov	r3, r4
   13c32:	4619      	mov	r1, r3
   13c34:	4802      	ldr	r0, [pc, #8]	; (13c40 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xb8>)
   13c36:	f001 fd3b 	bl	156b0 <__cyg_profile_func_exit>
    }
 }
   13c3a:	bf00      	nop
   13c3c:	b002      	add	sp, #8
   13c3e:	bd10      	pop	{r4, pc}
   13c40:	00013b89 	.word	0x00013b89
   13c44:	10000464 	.word	0x10000464

00013c48 <pinconn::uart3_txd(unsigned char, unsigned char)>:
    else if ((port == 2) && (pin==6))
    {
        *pincon[port][pin] |= (1<<4);
    }
 }
 void pinconn::uart3_txd(uint8_t port, uint8_t pin){ 
   13c48:	b510      	push	{r4, lr}
   13c4a:	b082      	sub	sp, #8
   13c4c:	4674      	mov	r4, lr
   13c4e:	9001      	str	r0, [sp, #4]
   13c50:	460b      	mov	r3, r1
   13c52:	f88d 3003 	strb.w	r3, [sp, #3]
   13c56:	4613      	mov	r3, r2
   13c58:	f88d 3002 	strb.w	r3, [sp, #2]
   13c5c:	4623      	mov	r3, r4
   13c5e:	4619      	mov	r1, r3
   13c60:	4827      	ldr	r0, [pc, #156]	; (13d00 <pinconn::uart3_txd(unsigned char, unsigned char)+0xb8>)
   13c62:	f001 fd11 	bl	15688 <__cyg_profile_func_enter>
    clear7(port,pin);
   13c66:	f89d 2002 	ldrb.w	r2, [sp, #2]
   13c6a:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13c6e:	4619      	mov	r1, r3
   13c70:	9801      	ldr	r0, [sp, #4]
   13c72:	f7ff fef7 	bl	13a64 <pinconn::clear7(unsigned char, unsigned char)>
    if(((port == 0) && (pin==0))){
   13c76:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13c7a:	2b00      	cmp	r3, #0
   13c7c:	d11a      	bne.n	13cb4 <pinconn::uart3_txd(unsigned char, unsigned char)+0x6c>
   13c7e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13c82:	2b00      	cmp	r3, #0
   13c84:	d116      	bne.n	13cb4 <pinconn::uart3_txd(unsigned char, unsigned char)+0x6c>
        *pincon[port][pin] |= (0b010);
   13c86:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13c8a:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13c8e:	491d      	ldr	r1, [pc, #116]	; (13d04 <pinconn::uart3_txd(unsigned char, unsigned char)+0xbc>)
   13c90:	0152      	lsls	r2, r2, #5
   13c92:	4413      	add	r3, r2
   13c94:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13c98:	681a      	ldr	r2, [r3, #0]
   13c9a:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13c9e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13ca2:	4818      	ldr	r0, [pc, #96]	; (13d04 <pinconn::uart3_txd(unsigned char, unsigned char)+0xbc>)
   13ca4:	0149      	lsls	r1, r1, #5
   13ca6:	440b      	add	r3, r1
   13ca8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13cac:	f042 0202 	orr.w	r2, r2, #2
   13cb0:	601a      	str	r2, [r3, #0]
   13cb2:	e01d      	b.n	13cf0 <pinconn::uart3_txd(unsigned char, unsigned char)+0xa8>
    }
    else if ((port == 4) && (pin==28))
   13cb4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13cb8:	2b04      	cmp	r3, #4
   13cba:	d119      	bne.n	13cf0 <pinconn::uart3_txd(unsigned char, unsigned char)+0xa8>
   13cbc:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13cc0:	2b1c      	cmp	r3, #28
   13cc2:	d115      	bne.n	13cf0 <pinconn::uart3_txd(unsigned char, unsigned char)+0xa8>
    {
        *pincon[port][pin] |= (0b010);
   13cc4:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13cc8:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13ccc:	490d      	ldr	r1, [pc, #52]	; (13d04 <pinconn::uart3_txd(unsigned char, unsigned char)+0xbc>)
   13cce:	0152      	lsls	r2, r2, #5
   13cd0:	4413      	add	r3, r2
   13cd2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13cd6:	681a      	ldr	r2, [r3, #0]
   13cd8:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13cdc:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13ce0:	4808      	ldr	r0, [pc, #32]	; (13d04 <pinconn::uart3_txd(unsigned char, unsigned char)+0xbc>)
   13ce2:	0149      	lsls	r1, r1, #5
   13ce4:	440b      	add	r3, r1
   13ce6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13cea:	f042 0202 	orr.w	r2, r2, #2
   13cee:	601a      	str	r2, [r3, #0]
   13cf0:	4623      	mov	r3, r4
   13cf2:	4619      	mov	r1, r3
   13cf4:	4802      	ldr	r0, [pc, #8]	; (13d00 <pinconn::uart3_txd(unsigned char, unsigned char)+0xb8>)
   13cf6:	f001 fcdb 	bl	156b0 <__cyg_profile_func_exit>
    }
 }    
   13cfa:	bf00      	nop
   13cfc:	b002      	add	sp, #8
   13cfe:	bd10      	pop	{r4, pc}
   13d00:	00013c49 	.word	0x00013c49
   13d04:	10000464 	.word	0x10000464

00013d08 <pinconn::uart3_rxd(unsigned char, unsigned char)>:
 void pinconn::uart3_rxd(uint8_t port, uint8_t pin){
   13d08:	b510      	push	{r4, lr}
   13d0a:	b082      	sub	sp, #8
   13d0c:	4674      	mov	r4, lr
   13d0e:	9001      	str	r0, [sp, #4]
   13d10:	460b      	mov	r3, r1
   13d12:	f88d 3003 	strb.w	r3, [sp, #3]
   13d16:	4613      	mov	r3, r2
   13d18:	f88d 3002 	strb.w	r3, [sp, #2]
   13d1c:	4623      	mov	r3, r4
   13d1e:	4619      	mov	r1, r3
   13d20:	4827      	ldr	r0, [pc, #156]	; (13dc0 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xb8>)
   13d22:	f001 fcb1 	bl	15688 <__cyg_profile_func_enter>
    clear7(port,pin);
   13d26:	f89d 2002 	ldrb.w	r2, [sp, #2]
   13d2a:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13d2e:	4619      	mov	r1, r3
   13d30:	9801      	ldr	r0, [sp, #4]
   13d32:	f7ff fe97 	bl	13a64 <pinconn::clear7(unsigned char, unsigned char)>
    if(((port == 0) && (pin==1))){
   13d36:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13d3a:	2b00      	cmp	r3, #0
   13d3c:	d11a      	bne.n	13d74 <pinconn::uart3_rxd(unsigned char, unsigned char)+0x6c>
   13d3e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13d42:	2b01      	cmp	r3, #1
   13d44:	d116      	bne.n	13d74 <pinconn::uart3_rxd(unsigned char, unsigned char)+0x6c>
    *pincon[port][pin] |= (0b010);
   13d46:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13d4a:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13d4e:	491d      	ldr	r1, [pc, #116]	; (13dc4 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xbc>)
   13d50:	0152      	lsls	r2, r2, #5
   13d52:	4413      	add	r3, r2
   13d54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13d58:	681a      	ldr	r2, [r3, #0]
   13d5a:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13d5e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13d62:	4818      	ldr	r0, [pc, #96]	; (13dc4 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xbc>)
   13d64:	0149      	lsls	r1, r1, #5
   13d66:	440b      	add	r3, r1
   13d68:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13d6c:	f042 0202 	orr.w	r2, r2, #2
   13d70:	601a      	str	r2, [r3, #0]
   13d72:	e01d      	b.n	13db0 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xa8>
    }
    else if ((port == 4) && (pin==29))
   13d74:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13d78:	2b04      	cmp	r3, #4
   13d7a:	d119      	bne.n	13db0 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xa8>
   13d7c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13d80:	2b1d      	cmp	r3, #29
   13d82:	d115      	bne.n	13db0 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xa8>
    {
        *pincon[port][pin] |= (0b010);
   13d84:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13d88:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13d8c:	490d      	ldr	r1, [pc, #52]	; (13dc4 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xbc>)
   13d8e:	0152      	lsls	r2, r2, #5
   13d90:	4413      	add	r3, r2
   13d92:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13d96:	681a      	ldr	r2, [r3, #0]
   13d98:	f89d 1003 	ldrb.w	r1, [sp, #3]
   13d9c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13da0:	4808      	ldr	r0, [pc, #32]	; (13dc4 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xbc>)
   13da2:	0149      	lsls	r1, r1, #5
   13da4:	440b      	add	r3, r1
   13da6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13daa:	f042 0202 	orr.w	r2, r2, #2
   13dae:	601a      	str	r2, [r3, #0]
   13db0:	4623      	mov	r3, r4
   13db2:	4619      	mov	r1, r3
   13db4:	4802      	ldr	r0, [pc, #8]	; (13dc0 <pinconn::uart3_rxd(unsigned char, unsigned char)+0xb8>)
   13db6:	f001 fc7b 	bl	156b0 <__cyg_profile_func_exit>
    }
   13dba:	bf00      	nop
   13dbc:	b002      	add	sp, #8
   13dbe:	bd10      	pop	{r4, pc}
   13dc0:	00013d09 	.word	0x00013d09
   13dc4:	10000464 	.word	0x10000464

00013dc8 <SetUptimeFunction(unsigned long long (*)())>:
{
   13dc8:	b510      	push	{r4, lr}
   13dca:	b082      	sub	sp, #8
   13dcc:	4674      	mov	r4, lr
   13dce:	9001      	str	r0, [sp, #4]
   13dd0:	4623      	mov	r3, r4
   13dd2:	4619      	mov	r1, r3
   13dd4:	4806      	ldr	r0, [pc, #24]	; (13df0 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   13dd6:	f001 fc57 	bl	15688 <__cyg_profile_func_enter>
  Uptime = uptime_function;
   13dda:	4a06      	ldr	r2, [pc, #24]	; (13df4 <SetUptimeFunction(unsigned long long (*)())+0x2c>)
   13ddc:	9b01      	ldr	r3, [sp, #4]
   13dde:	6013      	str	r3, [r2, #0]
   13de0:	4623      	mov	r3, r4
   13de2:	4619      	mov	r1, r3
   13de4:	4802      	ldr	r0, [pc, #8]	; (13df0 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   13de6:	f001 fc63 	bl	156b0 <__cyg_profile_func_exit>
}
   13dea:	bf00      	nop
   13dec:	b002      	add	sp, #8
   13dee:	bd10      	pop	{r4, pc}
   13df0:	00013dc9 	.word	0x00013dc9
   13df4:	10000004 	.word	0x10000004

00013df8 <SystemTimer::DisableTimer()>:
  /// system_timer_isr defaults to nullptr. The actual SystemTickHandler should
  /// check if the isr is set to nullptr, and if it is, turn off the timer, if
  /// set a proper function then execute it.
  inline static IsrPointer system_timer_isr = nullptr;
  /// WARNING: Doing so will most likely disable FreeRTOS
  static void DisableTimer()
   13df8:	b510      	push	{r4, lr}
   13dfa:	4674      	mov	r4, lr
   13dfc:	4623      	mov	r3, r4
   13dfe:	4619      	mov	r1, r3
   13e00:	480a      	ldr	r0, [pc, #40]	; (13e2c <SystemTimer::DisableTimer()+0x34>)
   13e02:	f001 fc41 	bl	15688 <__cyg_profile_func_enter>
  {
    sys_tick->LOAD = 0;
   13e06:	4b0a      	ldr	r3, [pc, #40]	; (13e30 <SystemTimer::DisableTimer()+0x38>)
   13e08:	681b      	ldr	r3, [r3, #0]
   13e0a:	2200      	movs	r2, #0
   13e0c:	605a      	str	r2, [r3, #4]
    sys_tick->VAL  = 0;
   13e0e:	4b08      	ldr	r3, [pc, #32]	; (13e30 <SystemTimer::DisableTimer()+0x38>)
   13e10:	681b      	ldr	r3, [r3, #0]
   13e12:	2200      	movs	r2, #0
   13e14:	609a      	str	r2, [r3, #8]
    sys_tick->CTRL = 0;
   13e16:	4b06      	ldr	r3, [pc, #24]	; (13e30 <SystemTimer::DisableTimer()+0x38>)
   13e18:	681b      	ldr	r3, [r3, #0]
   13e1a:	2200      	movs	r2, #0
   13e1c:	601a      	str	r2, [r3, #0]
   13e1e:	4623      	mov	r3, r4
   13e20:	4619      	mov	r1, r3
   13e22:	4802      	ldr	r0, [pc, #8]	; (13e2c <SystemTimer::DisableTimer()+0x34>)
   13e24:	f001 fc44 	bl	156b0 <__cyg_profile_func_exit>
  }
   13e28:	bf00      	nop
   13e2a:	bd10      	pop	{r4, pc}
   13e2c:	00013df9 	.word	0x00013df9
   13e30:	10000764 	.word	0x10000764

00013e34 <SystemTimer::SystemTimerHandler()>:
  static void SystemTimerHandler()
   13e34:	b510      	push	{r4, lr}
   13e36:	4674      	mov	r4, lr
   13e38:	4623      	mov	r3, r4
   13e3a:	4619      	mov	r1, r3
   13e3c:	4808      	ldr	r0, [pc, #32]	; (13e60 <SystemTimer::SystemTimerHandler()+0x2c>)
   13e3e:	f001 fc23 	bl	15688 <__cyg_profile_func_enter>
  {
    // This assumes that SysTickHandler is called every millisecond.
    // Changing that frequency will distort the milliseconds time.
    if (system_timer_isr != nullptr)
   13e42:	4b08      	ldr	r3, [pc, #32]	; (13e64 <SystemTimer::SystemTimerHandler()+0x30>)
   13e44:	681b      	ldr	r3, [r3, #0]
   13e46:	2b00      	cmp	r3, #0
   13e48:	d002      	beq.n	13e50 <SystemTimer::SystemTimerHandler()+0x1c>
    {
      system_timer_isr();
   13e4a:	4b06      	ldr	r3, [pc, #24]	; (13e64 <SystemTimer::SystemTimerHandler()+0x30>)
   13e4c:	681b      	ldr	r3, [r3, #0]
   13e4e:	4798      	blx	r3
   13e50:	4623      	mov	r3, r4
   13e52:	4619      	mov	r1, r3
   13e54:	4802      	ldr	r0, [pc, #8]	; (13e60 <SystemTimer::SystemTimerHandler()+0x2c>)
   13e56:	f001 fc2b 	bl	156b0 <__cyg_profile_func_exit>
    }
  }
   13e5a:	bf00      	nop
   13e5c:	bd10      	pop	{r4, pc}
   13e5e:	bf00      	nop
   13e60:	00013e35 	.word	0x00013e35
   13e64:	10001254 	.word	0x10001254

00013e68 <SystemTimer::SetIsrFunction(void (*)())>:
  constexpr SystemTimer() {}
  void SetIsrFunction(IsrPointer isr) override
   13e68:	b510      	push	{r4, lr}
   13e6a:	b082      	sub	sp, #8
   13e6c:	4674      	mov	r4, lr
   13e6e:	9001      	str	r0, [sp, #4]
   13e70:	9100      	str	r1, [sp, #0]
   13e72:	4623      	mov	r3, r4
   13e74:	4619      	mov	r1, r3
   13e76:	4807      	ldr	r0, [pc, #28]	; (13e94 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   13e78:	f001 fc06 	bl	15688 <__cyg_profile_func_enter>
  {
    system_timer_isr = isr;
   13e7c:	4a06      	ldr	r2, [pc, #24]	; (13e98 <SystemTimer::SetIsrFunction(void (*)())+0x30>)
   13e7e:	9b00      	ldr	r3, [sp, #0]
   13e80:	6013      	str	r3, [r2, #0]
   13e82:	4623      	mov	r3, r4
   13e84:	4619      	mov	r1, r3
   13e86:	4803      	ldr	r0, [pc, #12]	; (13e94 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   13e88:	f001 fc12 	bl	156b0 <__cyg_profile_func_exit>
  }
   13e8c:	bf00      	nop
   13e8e:	b002      	add	sp, #8
   13e90:	bd10      	pop	{r4, pc}
   13e92:	bf00      	nop
   13e94:	00013e69 	.word	0x00013e69
   13e98:	10001254 	.word	0x10001254

00013e9c <SystemTimer::StartTimer()>:
  bool StartTimer() override
   13e9c:	b530      	push	{r4, r5, lr}
   13e9e:	b085      	sub	sp, #20
   13ea0:	4675      	mov	r5, lr
   13ea2:	9001      	str	r0, [sp, #4]
   13ea4:	462b      	mov	r3, r5
   13ea6:	4619      	mov	r1, r3
   13ea8:	4820      	ldr	r0, [pc, #128]	; (13f2c <SystemTimer::StartTimer()+0x90>)
   13eaa:	f001 fbed 	bl	15688 <__cyg_profile_func_enter>
  {
    bool successful = false;
   13eae:	2300      	movs	r3, #0
   13eb0:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sys_tick->LOAD != 0)
   13eb4:	4b1e      	ldr	r3, [pc, #120]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13eb6:	681b      	ldr	r3, [r3, #0]
   13eb8:	685b      	ldr	r3, [r3, #4]
   13eba:	2b00      	cmp	r3, #0
   13ebc:	bf14      	ite	ne
   13ebe:	2301      	movne	r3, #1
   13ec0:	2300      	moveq	r3, #0
   13ec2:	b2db      	uxtb	r3, r3
   13ec4:	2b00      	cmp	r3, #0
   13ec6:	d01e      	beq.n	13f06 <SystemTimer::StartTimer()+0x6a>
    {
      sys_tick->VAL = 0;
   13ec8:	4b19      	ldr	r3, [pc, #100]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13eca:	681b      	ldr	r3, [r3, #0]
   13ecc:	2200      	movs	r2, #0
   13ece:	609a      	str	r2, [r3, #8]
      sys_tick->CTRL |= (1 << ControlBitMap::kTickInterupt);
   13ed0:	4b17      	ldr	r3, [pc, #92]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13ed2:	681b      	ldr	r3, [r3, #0]
   13ed4:	681a      	ldr	r2, [r3, #0]
   13ed6:	4b16      	ldr	r3, [pc, #88]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13ed8:	681b      	ldr	r3, [r3, #0]
   13eda:	f042 0202 	orr.w	r2, r2, #2
   13ede:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kEnableCounter);
   13ee0:	4b13      	ldr	r3, [pc, #76]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13ee2:	681b      	ldr	r3, [r3, #0]
   13ee4:	681a      	ldr	r2, [r3, #0]
   13ee6:	4b12      	ldr	r3, [pc, #72]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13ee8:	681b      	ldr	r3, [r3, #0]
   13eea:	f042 0201 	orr.w	r2, r2, #1
   13eee:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kClkSource);
   13ef0:	4b0f      	ldr	r3, [pc, #60]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13ef2:	681b      	ldr	r3, [r3, #0]
   13ef4:	681a      	ldr	r2, [r3, #0]
   13ef6:	4b0e      	ldr	r3, [pc, #56]	; (13f30 <SystemTimer::StartTimer()+0x94>)
   13ef8:	681b      	ldr	r3, [r3, #0]
   13efa:	f042 0204 	orr.w	r2, r2, #4
   13efe:	601a      	str	r2, [r3, #0]
      successful = true;
   13f00:	2301      	movs	r3, #1
   13f02:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    RegisterIsr(SysTick_IRQn, SystemTimerHandler);
   13f06:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13f0a:	2201      	movs	r2, #1
   13f0c:	4909      	ldr	r1, [pc, #36]	; (13f34 <SystemTimer::StartTimer()+0x98>)
   13f0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13f12:	f001 fa65 	bl	153e0 <RegisterIsr(IRQn, void (*)(), bool, long)>
    return successful;
   13f16:	f89d 400f 	ldrb.w	r4, [sp, #15]
   13f1a:	462b      	mov	r3, r5
   13f1c:	4619      	mov	r1, r3
   13f1e:	4803      	ldr	r0, [pc, #12]	; (13f2c <SystemTimer::StartTimer()+0x90>)
   13f20:	f001 fbc6 	bl	156b0 <__cyg_profile_func_exit>
   13f24:	4623      	mov	r3, r4
  }
   13f26:	4618      	mov	r0, r3
   13f28:	b005      	add	sp, #20
   13f2a:	bd30      	pop	{r4, r5, pc}
   13f2c:	00013e9d 	.word	0x00013e9d
   13f30:	10000764 	.word	0x10000764
   13f34:	00013e35 	.word	0x00013e35

00013f38 <SystemTimer::SetTickFrequency(unsigned long)>:
  ///          remainder will be returned.
  ///          If the freqency supplied is less then 2Hz, the function will
  ///          return without changing any hardware.
  ///          If the reload value exceeds the SysTick_LOAD_RELOAD_Msk, the
  ///          returned value is the SysTick_LOAD_RELOAD_Msk.
  uint32_t SetTickFrequency(uint32_t frequency) override
   13f38:	b530      	push	{r4, r5, lr}
   13f3a:	b085      	sub	sp, #20
   13f3c:	4675      	mov	r5, lr
   13f3e:	9001      	str	r0, [sp, #4]
   13f40:	9100      	str	r1, [sp, #0]
   13f42:	462b      	mov	r3, r5
   13f44:	4619      	mov	r1, r3
   13f46:	481f      	ldr	r0, [pc, #124]	; (13fc4 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   13f48:	f001 fb9e 	bl	15688 <__cyg_profile_func_enter>
  {
    if (frequency <= 1)
   13f4c:	9b00      	ldr	r3, [sp, #0]
   13f4e:	2b01      	cmp	r3, #1
   13f50:	d801      	bhi.n	13f56 <SystemTimer::SetTickFrequency(unsigned long)+0x1e>
    {
      return 0;
   13f52:	2400      	movs	r4, #0
   13f54:	e02d      	b.n	13fb2 <SystemTimer::SetTickFrequency(unsigned long)+0x7a>
    }
    uint32_t reload_value = (GetSystemFrequency() / frequency) - 1;
   13f56:	9b01      	ldr	r3, [sp, #4]
   13f58:	1d1a      	adds	r2, r3, #4
   13f5a:	9b01      	ldr	r3, [sp, #4]
   13f5c:	685b      	ldr	r3, [r3, #4]
   13f5e:	330c      	adds	r3, #12
   13f60:	681b      	ldr	r3, [r3, #0]
   13f62:	4610      	mov	r0, r2
   13f64:	4798      	blx	r3
   13f66:	4602      	mov	r2, r0
   13f68:	9b00      	ldr	r3, [sp, #0]
   13f6a:	fbb2 f3f3 	udiv	r3, r2, r3
   13f6e:	3b01      	subs	r3, #1
   13f70:	9303      	str	r3, [sp, #12]
    int remainder         = (GetSystemFrequency() % frequency);
   13f72:	9b01      	ldr	r3, [sp, #4]
   13f74:	1d1a      	adds	r2, r3, #4
   13f76:	9b01      	ldr	r3, [sp, #4]
   13f78:	685b      	ldr	r3, [r3, #4]
   13f7a:	330c      	adds	r3, #12
   13f7c:	681b      	ldr	r3, [r3, #0]
   13f7e:	4610      	mov	r0, r2
   13f80:	4798      	blx	r3
   13f82:	4603      	mov	r3, r0
   13f84:	9a00      	ldr	r2, [sp, #0]
   13f86:	fbb3 f2f2 	udiv	r2, r3, r2
   13f8a:	9900      	ldr	r1, [sp, #0]
   13f8c:	fb01 f202 	mul.w	r2, r1, r2
   13f90:	1a9b      	subs	r3, r3, r2
   13f92:	9302      	str	r3, [sp, #8]
    if (reload_value > SysTick_LOAD_RELOAD_Msk)
   13f94:	9b03      	ldr	r3, [sp, #12]
   13f96:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   13f9a:	d305      	bcc.n	13fa8 <SystemTimer::SetTickFrequency(unsigned long)+0x70>
    {
      reload_value = SysTick_LOAD_RELOAD_Msk;
   13f9c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   13fa0:	9303      	str	r3, [sp, #12]
      remainder    = SysTick_LOAD_RELOAD_Msk;
   13fa2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   13fa6:	9302      	str	r3, [sp, #8]
    }
    sys_tick->LOAD = reload_value;
   13fa8:	4b07      	ldr	r3, [pc, #28]	; (13fc8 <SystemTimer::SetTickFrequency(unsigned long)+0x90>)
   13faa:	681b      	ldr	r3, [r3, #0]
   13fac:	9a03      	ldr	r2, [sp, #12]
   13fae:	605a      	str	r2, [r3, #4]
    return remainder;
   13fb0:	9c02      	ldr	r4, [sp, #8]
   13fb2:	462b      	mov	r3, r5
   13fb4:	4619      	mov	r1, r3
   13fb6:	4803      	ldr	r0, [pc, #12]	; (13fc4 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   13fb8:	f001 fb7a 	bl	156b0 <__cyg_profile_func_exit>
   13fbc:	4623      	mov	r3, r4
  }
   13fbe:	4618      	mov	r0, r3
   13fc0:	b005      	add	sp, #20
   13fc2:	bd30      	pop	{r4, r5, pc}
   13fc4:	00013f39 	.word	0x00013f39
   13fc8:	10000764 	.word	0x10000764

00013fcc <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>:
constexpr Type Value(Enum enum_type_value)
   13fcc:	b530      	push	{r4, r5, lr}
   13fce:	b083      	sub	sp, #12
   13fd0:	4675      	mov	r5, lr
   13fd2:	4603      	mov	r3, r0
   13fd4:	f88d 3007 	strb.w	r3, [sp, #7]
   13fd8:	462b      	mov	r3, r5
   13fda:	4619      	mov	r1, r3
   13fdc:	4806      	ldr	r0, [pc, #24]	; (13ff8 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   13fde:	f001 fb53 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   13fe2:	f89d 4007 	ldrb.w	r4, [sp, #7]
   13fe6:	462b      	mov	r3, r5
   13fe8:	4619      	mov	r1, r3
   13fea:	4803      	ldr	r0, [pc, #12]	; (13ff8 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   13fec:	f001 fb60 	bl	156b0 <__cyg_profile_func_exit>
   13ff0:	4623      	mov	r3, r4
}
   13ff2:	4618      	mov	r0, r3
   13ff4:	b003      	add	sp, #12
   13ff6:	bd30      	pop	{r4, r5, pc}
   13ff8:	00013fcd 	.word	0x00013fcd

00013ffc <Timer::DoNothingIsr()>:
    Lpc40xxSystemController::Peripherals::kTimer3
  };

  static constexpr IRQn kTimerIrq[] = { IRQn::TIMER0_IRQn, IRQn::TIMER1_IRQn,
                                        IRQn::TIMER2_IRQn, IRQn::TIMER3_IRQn };
  static void DoNothingIsr() {}
   13ffc:	b510      	push	{r4, lr}
   13ffe:	4674      	mov	r4, lr
   14000:	4623      	mov	r3, r4
   14002:	4619      	mov	r1, r3
   14004:	4804      	ldr	r0, [pc, #16]	; (14018 <Timer::DoNothingIsr()+0x1c>)
   14006:	f001 fb3f 	bl	15688 <__cyg_profile_func_enter>
   1400a:	4623      	mov	r3, r4
   1400c:	4619      	mov	r1, r3
   1400e:	4802      	ldr	r0, [pc, #8]	; (14018 <Timer::DoNothingIsr()+0x1c>)
   14010:	f001 fb4e 	bl	156b0 <__cyg_profile_func_exit>
   14014:	bf00      	nop
   14016:	bd10      	pop	{r4, pc}
   14018:	00013ffd 	.word	0x00013ffd

0001401c <Timer::Initialize(unsigned long, void (*)(), long)>:
  ///                  register will be 10 ms.
  /// @param isr an ISR that will fire when the condition set by SetTimer
  ///            method is achieved.
  /// @param priority sets the Timer interrupt's priority level, defaults to -1
  ///                 which uses the platforms default priority.
  void Initialize(uint32_t frequency, IsrPointer isr = DoNothingIsr,
   1401c:	b510      	push	{r4, lr}
   1401e:	b086      	sub	sp, #24
   14020:	4674      	mov	r4, lr
   14022:	9003      	str	r0, [sp, #12]
   14024:	9102      	str	r1, [sp, #8]
   14026:	9201      	str	r2, [sp, #4]
   14028:	9300      	str	r3, [sp, #0]
   1402a:	4623      	mov	r3, r4
   1402c:	4619      	mov	r1, r3
   1402e:	483e      	ldr	r0, [pc, #248]	; (14128 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   14030:	f001 fb2a 	bl	15688 <__cyg_profile_func_enter>
                  int32_t priority = -1) override final
  {
    PowerUpPeripheral(kPowerbit[channel_]);
   14034:	9b03      	ldr	r3, [sp, #12]
   14036:	1d18      	adds	r0, r3, #4
   14038:	9b03      	ldr	r3, [sp, #12]
   1403a:	685b      	ldr	r3, [r3, #4]
   1403c:	3314      	adds	r3, #20
   1403e:	681b      	ldr	r3, [r3, #0]
   14040:	9a03      	ldr	r2, [sp, #12]
   14042:	7a12      	ldrb	r2, [r2, #8]
   14044:	0092      	lsls	r2, r2, #2
   14046:	4939      	ldr	r1, [pc, #228]	; (1412c <Timer::Initialize(unsigned long, void (*)(), long)+0x110>)
   14048:	440a      	add	r2, r1
   1404a:	4611      	mov	r1, r2
   1404c:	4798      	blx	r3
    SJ2_ASSERT_FATAL(
   1404e:	9b02      	ldr	r3, [sp, #8]
   14050:	2b00      	cmp	r3, #0
   14052:	d10d      	bne.n	14070 <Timer::Initialize(unsigned long, void (*)(), long)+0x54>
   14054:	2384      	movs	r3, #132	; 0x84
   14056:	4a36      	ldr	r2, [pc, #216]	; (14130 <Timer::Initialize(unsigned long, void (*)(), long)+0x114>)
   14058:	4936      	ldr	r1, [pc, #216]	; (14134 <Timer::Initialize(unsigned long, void (*)(), long)+0x118>)
   1405a:	4837      	ldr	r0, [pc, #220]	; (14138 <Timer::Initialize(unsigned long, void (*)(), long)+0x11c>)
   1405c:	f003 fef8 	bl	17e50 <printf>
   14060:	4836      	ldr	r0, [pc, #216]	; (1413c <Timer::Initialize(unsigned long, void (*)(), long)+0x120>)
   14062:	f001 fae1 	bl	15628 <puts>
   14066:	2100      	movs	r1, #0
   14068:	2001      	movs	r0, #1
   1406a:	f7fc fcb5 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   1406e:	e7fe      	b.n	1406e <Timer::Initialize(unsigned long, void (*)(), long)+0x52>
        frequency != 0,
        "Cannot have zero ticks per microsecond, please choose 1 or more.");
    // Set Prescale register for Prescale Counter to milliseconds
    uint32_t prescaler = GetPeripheralFrequency() / frequency;
   14070:	9b03      	ldr	r3, [sp, #12]
   14072:	1d1a      	adds	r2, r3, #4
   14074:	9b03      	ldr	r3, [sp, #12]
   14076:	685b      	ldr	r3, [r3, #4]
   14078:	3310      	adds	r3, #16
   1407a:	681b      	ldr	r3, [r3, #0]
   1407c:	4610      	mov	r0, r2
   1407e:	4798      	blx	r3
   14080:	4602      	mov	r2, r0
   14082:	9b02      	ldr	r3, [sp, #8]
   14084:	fbb2 f3f3 	udiv	r3, r2, r3
   14088:	9305      	str	r3, [sp, #20]
    tim_register[channel_]->PR &= ~(kClear << 1);
   1408a:	9b03      	ldr	r3, [sp, #12]
   1408c:	7a1b      	ldrb	r3, [r3, #8]
   1408e:	461a      	mov	r2, r3
   14090:	4b2b      	ldr	r3, [pc, #172]	; (14140 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   14092:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14096:	68da      	ldr	r2, [r3, #12]
   14098:	9b03      	ldr	r3, [sp, #12]
   1409a:	7a1b      	ldrb	r3, [r3, #8]
   1409c:	4619      	mov	r1, r3
   1409e:	4b28      	ldr	r3, [pc, #160]	; (14140 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   140a0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   140a4:	f002 0201 	and.w	r2, r2, #1
   140a8:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->PR |= (prescaler << 1);
   140aa:	9b03      	ldr	r3, [sp, #12]
   140ac:	7a1b      	ldrb	r3, [r3, #8]
   140ae:	461a      	mov	r2, r3
   140b0:	4b23      	ldr	r3, [pc, #140]	; (14140 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   140b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   140b6:	68d9      	ldr	r1, [r3, #12]
   140b8:	9b05      	ldr	r3, [sp, #20]
   140ba:	005a      	lsls	r2, r3, #1
   140bc:	9b03      	ldr	r3, [sp, #12]
   140be:	7a1b      	ldrb	r3, [r3, #8]
   140c0:	4618      	mov	r0, r3
   140c2:	4b1f      	ldr	r3, [pc, #124]	; (14140 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   140c4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   140c8:	430a      	orrs	r2, r1
   140ca:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->TCR |= (1 << 0);
   140cc:	9b03      	ldr	r3, [sp, #12]
   140ce:	7a1b      	ldrb	r3, [r3, #8]
   140d0:	461a      	mov	r2, r3
   140d2:	4b1b      	ldr	r3, [pc, #108]	; (14140 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   140d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   140d8:	685a      	ldr	r2, [r3, #4]
   140da:	9b03      	ldr	r3, [sp, #12]
   140dc:	7a1b      	ldrb	r3, [r3, #8]
   140de:	4619      	mov	r1, r3
   140e0:	4b17      	ldr	r3, [pc, #92]	; (14140 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   140e2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   140e6:	f042 0201 	orr.w	r2, r2, #1
   140ea:	605a      	str	r2, [r3, #4]
    user_timer_isr[channel_] = isr;
   140ec:	9b03      	ldr	r3, [sp, #12]
   140ee:	7a1b      	ldrb	r3, [r3, #8]
   140f0:	4619      	mov	r1, r3
   140f2:	4a14      	ldr	r2, [pc, #80]	; (14144 <Timer::Initialize(unsigned long, void (*)(), long)+0x128>)
   140f4:	9b01      	ldr	r3, [sp, #4]
   140f6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    RegisterIsr(kTimerIrq[channel_], kTimerIsr[channel_], true, priority);
   140fa:	9b03      	ldr	r3, [sp, #12]
   140fc:	7a1b      	ldrb	r3, [r3, #8]
   140fe:	461a      	mov	r2, r3
   14100:	4b11      	ldr	r3, [pc, #68]	; (14148 <Timer::Initialize(unsigned long, void (*)(), long)+0x12c>)
   14102:	5698      	ldrsb	r0, [r3, r2]
   14104:	9b03      	ldr	r3, [sp, #12]
   14106:	7a1b      	ldrb	r3, [r3, #8]
   14108:	461a      	mov	r2, r3
   1410a:	4b10      	ldr	r3, [pc, #64]	; (1414c <Timer::Initialize(unsigned long, void (*)(), long)+0x130>)
   1410c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   14110:	9b00      	ldr	r3, [sp, #0]
   14112:	2201      	movs	r2, #1
   14114:	f001 f964 	bl	153e0 <RegisterIsr(IRQn, void (*)(), bool, long)>
   14118:	4623      	mov	r3, r4
   1411a:	4619      	mov	r1, r3
   1411c:	4802      	ldr	r0, [pc, #8]	; (14128 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   1411e:	f001 fac7 	bl	156b0 <__cyg_profile_func_exit>
  }
   14122:	bf00      	nop
   14124:	b006      	add	sp, #24
   14126:	bd10      	pop	{r4, pc}
   14128:	0001401d 	.word	0x0001401d
   1412c:	0001b17c 	.word	0x0001b17c
   14130:	0001b27c 	.word	0x0001b27c
   14134:	0001b1a0 	.word	0x0001b1a0
   14138:	0001b05c 	.word	0x0001b05c
   1413c:	0001ad68 	.word	0x0001ad68
   14140:	10000768 	.word	0x10000768
   14144:	10001298 	.word	0x10001298
   14148:	0001b18c 	.word	0x0001b18c
   1414c:	0001b190 	.word	0x0001b190

00014150 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>:
constexpr Type Value(Enum enum_type_value)
   14150:	b530      	push	{r4, r5, lr}
   14152:	b083      	sub	sp, #12
   14154:	4675      	mov	r5, lr
   14156:	4603      	mov	r3, r0
   14158:	f88d 3007 	strb.w	r3, [sp, #7]
   1415c:	462b      	mov	r3, r5
   1415e:	4619      	mov	r1, r3
   14160:	4806      	ldr	r0, [pc, #24]	; (1417c <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   14162:	f001 fa91 	bl	15688 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   14166:	f89d 4007 	ldrb.w	r4, [sp, #7]
   1416a:	462b      	mov	r3, r5
   1416c:	4619      	mov	r1, r3
   1416e:	4803      	ldr	r0, [pc, #12]	; (1417c <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   14170:	f001 fa9e 	bl	156b0 <__cyg_profile_func_exit>
   14174:	4623      	mov	r3, r4
}
   14176:	4618      	mov	r0, r3
   14178:	b003      	add	sp, #12
   1417a:	bd30      	pop	{r4, r5, pc}
   1417c:	00014151 	.word	0x00014151

00014180 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)>:
  ///
  /// @param ticks the count of the timer register (TC) to have an ISR fire
  /// @param condition the condition for which a timer interrupt will occur
  /// @param match_register which match register (from 0 to 3) should be used
  ///                       for holding the ticks for the condition.
  void SetTimer(uint32_t ticks, TimerIsrCondition condition,
   14180:	b570      	push	{r4, r5, r6, lr}
   14182:	b086      	sub	sp, #24
   14184:	4676      	mov	r6, lr
   14186:	9003      	str	r0, [sp, #12]
   14188:	9102      	str	r1, [sp, #8]
   1418a:	4611      	mov	r1, r2
   1418c:	461a      	mov	r2, r3
   1418e:	460b      	mov	r3, r1
   14190:	f88d 3007 	strb.w	r3, [sp, #7]
   14194:	4613      	mov	r3, r2
   14196:	f88d 3006 	strb.w	r3, [sp, #6]
   1419a:	4633      	mov	r3, r6
   1419c:	4619      	mov	r1, r3
   1419e:	4832      	ldr	r0, [pc, #200]	; (14268 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   141a0:	f001 fa72 	bl	15688 <__cyg_profile_func_enter>
                MatchControlRegister match_register = kMat0) override final
  {
    static constexpr uint8_t kClearMode = 0b0111;

    uint8_t match_value = util::Value(match_register);
   141a4:	f89d 3006 	ldrb.w	r3, [sp, #6]
   141a8:	4618      	mov	r0, r3
   141aa:	f7ff ffd1 	bl	14150 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>
   141ae:	4603      	mov	r3, r0
   141b0:	f88d 3017 	strb.w	r3, [sp, #23]
    tim_register[channel_]->MCR &= ~(kClearMode << match_value);
   141b4:	9b03      	ldr	r3, [sp, #12]
   141b6:	7a1b      	ldrb	r3, [r3, #8]
   141b8:	461a      	mov	r2, r3
   141ba:	4b2c      	ldr	r3, [pc, #176]	; (1426c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   141bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   141c0:	695a      	ldr	r2, [r3, #20]
   141c2:	f89d 3017 	ldrb.w	r3, [sp, #23]
   141c6:	2107      	movs	r1, #7
   141c8:	fa01 f303 	lsl.w	r3, r1, r3
   141cc:	43db      	mvns	r3, r3
   141ce:	4619      	mov	r1, r3
   141d0:	9b03      	ldr	r3, [sp, #12]
   141d2:	7a1b      	ldrb	r3, [r3, #8]
   141d4:	4618      	mov	r0, r3
   141d6:	4b25      	ldr	r3, [pc, #148]	; (1426c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   141d8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   141dc:	400a      	ands	r2, r1
   141de:	615a      	str	r2, [r3, #20]
    tim_register[channel_]->MCR |= condition << match_value;
   141e0:	9b03      	ldr	r3, [sp, #12]
   141e2:	7a1b      	ldrb	r3, [r3, #8]
   141e4:	461a      	mov	r2, r3
   141e6:	4b21      	ldr	r3, [pc, #132]	; (1426c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   141e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   141ec:	695a      	ldr	r2, [r3, #20]
   141ee:	f89d 1007 	ldrb.w	r1, [sp, #7]
   141f2:	f89d 3017 	ldrb.w	r3, [sp, #23]
   141f6:	fa01 f303 	lsl.w	r3, r1, r3
   141fa:	4619      	mov	r1, r3
   141fc:	9b03      	ldr	r3, [sp, #12]
   141fe:	7a1b      	ldrb	r3, [r3, #8]
   14200:	4618      	mov	r0, r3
   14202:	4b1a      	ldr	r3, [pc, #104]	; (1426c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   14204:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   14208:	430a      	orrs	r2, r1
   1420a:	615a      	str	r2, [r3, #20]
    *match[channel_][match_value / 3] |= (((ticks / 2)) << 0);
   1420c:	9b03      	ldr	r3, [sp, #12]
   1420e:	7a1b      	ldrb	r3, [r3, #8]
   14210:	4618      	mov	r0, r3
   14212:	f89d 3017 	ldrb.w	r3, [sp, #23]
   14216:	4a16      	ldr	r2, [pc, #88]	; (14270 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   14218:	fba2 2303 	umull	r2, r3, r2, r3
   1421c:	085b      	lsrs	r3, r3, #1
   1421e:	b2db      	uxtb	r3, r3
   14220:	4619      	mov	r1, r3
   14222:	4a14      	ldr	r2, [pc, #80]	; (14274 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   14224:	0083      	lsls	r3, r0, #2
   14226:	440b      	add	r3, r1
   14228:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1422c:	6819      	ldr	r1, [r3, #0]
   1422e:	9b02      	ldr	r3, [sp, #8]
   14230:	085a      	lsrs	r2, r3, #1
   14232:	9b03      	ldr	r3, [sp, #12]
   14234:	7a1b      	ldrb	r3, [r3, #8]
   14236:	461d      	mov	r5, r3
   14238:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1423c:	480c      	ldr	r0, [pc, #48]	; (14270 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   1423e:	fba0 0303 	umull	r0, r3, r0, r3
   14242:	085b      	lsrs	r3, r3, #1
   14244:	b2db      	uxtb	r3, r3
   14246:	461c      	mov	r4, r3
   14248:	480a      	ldr	r0, [pc, #40]	; (14274 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   1424a:	00ab      	lsls	r3, r5, #2
   1424c:	4423      	add	r3, r4
   1424e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   14252:	430a      	orrs	r2, r1
   14254:	601a      	str	r2, [r3, #0]
   14256:	4633      	mov	r3, r6
   14258:	4619      	mov	r1, r3
   1425a:	4803      	ldr	r0, [pc, #12]	; (14268 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   1425c:	f001 fa28 	bl	156b0 <__cyg_profile_func_exit>
  }
   14260:	bf00      	nop
   14262:	b006      	add	sp, #24
   14264:	bd70      	pop	{r4, r5, r6, pc}
   14266:	bf00      	nop
   14268:	00014181 	.word	0x00014181
   1426c:	10000768 	.word	0x10000768
   14270:	aaaaaaab 	.word	0xaaaaaaab
   14274:	10001258 	.word	0x10001258

00014278 <Timer::GetTimer()>:

  [[gnu::always_inline]] uint32_t GetTimer() override final {
   14278:	b530      	push	{r4, r5, lr}
   1427a:	b083      	sub	sp, #12
   1427c:	4675      	mov	r5, lr
   1427e:	9001      	str	r0, [sp, #4]
   14280:	462b      	mov	r3, r5
   14282:	4619      	mov	r1, r3
   14284:	4809      	ldr	r0, [pc, #36]	; (142ac <Timer::GetTimer()+0x34>)
   14286:	f001 f9ff 	bl	15688 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   1428a:	9b01      	ldr	r3, [sp, #4]
   1428c:	7a1b      	ldrb	r3, [r3, #8]
   1428e:	461a      	mov	r2, r3
   14290:	4b07      	ldr	r3, [pc, #28]	; (142b0 <Timer::GetTimer()+0x38>)
   14292:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14296:	689c      	ldr	r4, [r3, #8]
   14298:	462b      	mov	r3, r5
   1429a:	4619      	mov	r1, r3
   1429c:	4803      	ldr	r0, [pc, #12]	; (142ac <Timer::GetTimer()+0x34>)
   1429e:	f001 fa07 	bl	156b0 <__cyg_profile_func_exit>
   142a2:	4623      	mov	r3, r4
  }
   142a4:	4618      	mov	r0, r3
   142a6:	b003      	add	sp, #12
   142a8:	bd30      	pop	{r4, r5, pc}
   142aa:	bf00      	nop
   142ac:	00014279 	.word	0x00014279
   142b0:	10000768 	.word	0x10000768

000142b4 <Uart::SetBaudRate(unsigned long)>:
  constexpr Uart(Channels mode, PinInterface * tx_pin, PinInterface * rx_pin)
      : channel_(static_cast<uint8_t>(mode)), tx_(tx_pin), rx_(rx_pin)
  {
  }

  void SetBaudRate(uint32_t baud_rate) override
   142b4:	b510      	push	{r4, lr}
   142b6:	b088      	sub	sp, #32
   142b8:	4674      	mov	r4, lr
   142ba:	9001      	str	r0, [sp, #4]
   142bc:	9100      	str	r1, [sp, #0]
   142be:	4623      	mov	r3, r4
   142c0:	4619      	mov	r1, r3
   142c2:	482d      	ldr	r0, [pc, #180]	; (14378 <Uart::SetBaudRate(unsigned long)+0xc4>)
   142c4:	f001 f9e0 	bl	15688 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kDlabBit = (1 << 7);
   142c8:	2380      	movs	r3, #128	; 0x80
   142ca:	f88d 301f 	strb.w	r3, [sp, #31]
    float baudrate             = static_cast<float>(baud_rate);
   142ce:	9b00      	ldr	r3, [sp, #0]
   142d0:	ee07 3a90 	vmov	s15, r3
   142d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   142d8:	edcd 7a06 	vstr	s15, [sp, #24]
    UartCalibration_t dividers = GenerateUartCalibration(baudrate);
   142dc:	ab02      	add	r3, sp, #8
   142de:	ed9d 0a06 	vldr	s0, [sp, #24]
   142e2:	9901      	ldr	r1, [sp, #4]
   142e4:	4618      	mov	r0, r3
   142e6:	f000 fb2d 	bl	14944 <Uart::GenerateUartCalibration(float)>

    uint8_t dlm = static_cast<uint8_t>((dividers.divide_latch >> 8) & 0xFF);
   142ea:	9b02      	ldr	r3, [sp, #8]
   142ec:	0a1b      	lsrs	r3, r3, #8
   142ee:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8_t dll = static_cast<uint8_t>(dividers.divide_latch & 0xFF);
   142f2:	9b02      	ldr	r3, [sp, #8]
   142f4:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   142f8:	9b04      	ldr	r3, [sp, #16]
   142fa:	b2db      	uxtb	r3, r3
   142fc:	011b      	lsls	r3, r3, #4
   142fe:	b2da      	uxtb	r2, r3
                                       (dividers.divide_add & 0xF));
   14300:	9b03      	ldr	r3, [sp, #12]
   14302:	b2db      	uxtb	r3, r3
   14304:	f003 030f 	and.w	r3, r3, #15
   14308:	b2db      	uxtb	r3, r3
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   1430a:	4313      	orrs	r3, r2
   1430c:	f88d 3015 	strb.w	r3, [sp, #21]

    // Set baud rate
    uart[channel_]->LCR = kDlabBit;
   14310:	9b01      	ldr	r3, [sp, #4]
   14312:	7a1b      	ldrb	r3, [r3, #8]
   14314:	461a      	mov	r2, r3
   14316:	4b19      	ldr	r3, [pc, #100]	; (1437c <Uart::SetBaudRate(unsigned long)+0xc8>)
   14318:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1431c:	2280      	movs	r2, #128	; 0x80
   1431e:	731a      	strb	r2, [r3, #12]
    uart[channel_]->DLM = dlm;
   14320:	9b01      	ldr	r3, [sp, #4]
   14322:	7a1b      	ldrb	r3, [r3, #8]
   14324:	461a      	mov	r2, r3
   14326:	4b15      	ldr	r3, [pc, #84]	; (1437c <Uart::SetBaudRate(unsigned long)+0xc8>)
   14328:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1432c:	f89d 2017 	ldrb.w	r2, [sp, #23]
   14330:	711a      	strb	r2, [r3, #4]
    uart[channel_]->DLL = dll;
   14332:	9b01      	ldr	r3, [sp, #4]
   14334:	7a1b      	ldrb	r3, [r3, #8]
   14336:	461a      	mov	r2, r3
   14338:	4b10      	ldr	r3, [pc, #64]	; (1437c <Uart::SetBaudRate(unsigned long)+0xc8>)
   1433a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1433e:	f89d 2016 	ldrb.w	r2, [sp, #22]
   14342:	701a      	strb	r2, [r3, #0]
    uart[channel_]->FDR = fdr;
   14344:	9b01      	ldr	r3, [sp, #4]
   14346:	7a1b      	ldrb	r3, [r3, #8]
   14348:	461a      	mov	r2, r3
   1434a:	4b0c      	ldr	r3, [pc, #48]	; (1437c <Uart::SetBaudRate(unsigned long)+0xc8>)
   1434c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14350:	f89d 2015 	ldrb.w	r2, [sp, #21]
   14354:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    uart[channel_]->LCR = kStandardUart;
   14358:	9b01      	ldr	r3, [sp, #4]
   1435a:	7a1b      	ldrb	r3, [r3, #8]
   1435c:	461a      	mov	r2, r3
   1435e:	4b07      	ldr	r3, [pc, #28]	; (1437c <Uart::SetBaudRate(unsigned long)+0xc8>)
   14360:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14364:	2203      	movs	r2, #3
   14366:	731a      	strb	r2, [r3, #12]
   14368:	4623      	mov	r3, r4
   1436a:	4619      	mov	r1, r3
   1436c:	4802      	ldr	r0, [pc, #8]	; (14378 <Uart::SetBaudRate(unsigned long)+0xc4>)
   1436e:	f001 f99f 	bl	156b0 <__cyg_profile_func_exit>
  }
   14372:	bf00      	nop
   14374:	b008      	add	sp, #32
   14376:	bd10      	pop	{r4, pc}
   14378:	000142b5 	.word	0x000142b5
   1437c:	10000778 	.word	0x10000778

00014380 <Uart::Initialize(unsigned long)>:

  bool Initialize(uint32_t baud_rate) override
   14380:	b530      	push	{r4, r5, lr}
   14382:	b085      	sub	sp, #20
   14384:	4675      	mov	r5, lr
   14386:	9001      	str	r0, [sp, #4]
   14388:	9100      	str	r1, [sp, #0]
   1438a:	462b      	mov	r3, r5
   1438c:	4619      	mov	r1, r3
   1438e:	4830      	ldr	r0, [pc, #192]	; (14450 <Uart::Initialize(unsigned long)+0xd0>)
   14390:	f001 f97a 	bl	15688 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kFIFOEnableAndReset = 0b111;
   14394:	2307      	movs	r3, #7
   14396:	f88d 300f 	strb.w	r3, [sp, #15]
    // Powering the port
    PowerUpPeripheral(kPowerbit[channel_]);
   1439a:	9b01      	ldr	r3, [sp, #4]
   1439c:	1d18      	adds	r0, r3, #4
   1439e:	9b01      	ldr	r3, [sp, #4]
   143a0:	685b      	ldr	r3, [r3, #4]
   143a2:	3314      	adds	r3, #20
   143a4:	681b      	ldr	r3, [r3, #0]
   143a6:	9a01      	ldr	r2, [sp, #4]
   143a8:	7a12      	ldrb	r2, [r2, #8]
   143aa:	0092      	lsls	r2, r2, #2
   143ac:	4929      	ldr	r1, [pc, #164]	; (14454 <Uart::Initialize(unsigned long)+0xd4>)
   143ae:	440a      	add	r2, r1
   143b0:	4611      	mov	r1, r2
   143b2:	4798      	blx	r3
    // Setting the pin functions and modes
    rx_->SetPinFunction(kRxUartPortFunction[channel_]);
   143b4:	9b01      	ldr	r3, [sp, #4]
   143b6:	6918      	ldr	r0, [r3, #16]
   143b8:	9b01      	ldr	r3, [sp, #4]
   143ba:	691b      	ldr	r3, [r3, #16]
   143bc:	681b      	ldr	r3, [r3, #0]
   143be:	681b      	ldr	r3, [r3, #0]
   143c0:	9a01      	ldr	r2, [sp, #4]
   143c2:	7a12      	ldrb	r2, [r2, #8]
   143c4:	4611      	mov	r1, r2
   143c6:	4a24      	ldr	r2, [pc, #144]	; (14458 <Uart::Initialize(unsigned long)+0xd8>)
   143c8:	5c52      	ldrb	r2, [r2, r1]
   143ca:	4611      	mov	r1, r2
   143cc:	4798      	blx	r3
    tx_->SetPinFunction(kTxUartPortFunction[channel_]);
   143ce:	9b01      	ldr	r3, [sp, #4]
   143d0:	68d8      	ldr	r0, [r3, #12]
   143d2:	9b01      	ldr	r3, [sp, #4]
   143d4:	68db      	ldr	r3, [r3, #12]
   143d6:	681b      	ldr	r3, [r3, #0]
   143d8:	681b      	ldr	r3, [r3, #0]
   143da:	9a01      	ldr	r2, [sp, #4]
   143dc:	7a12      	ldrb	r2, [r2, #8]
   143de:	4611      	mov	r1, r2
   143e0:	4a1e      	ldr	r2, [pc, #120]	; (1445c <Uart::Initialize(unsigned long)+0xdc>)
   143e2:	5c52      	ldrb	r2, [r2, r1]
   143e4:	4611      	mov	r1, r2
   143e6:	4798      	blx	r3
    rx_->SetMode(PinInterface::Mode::kPullUp);
   143e8:	9b01      	ldr	r3, [sp, #4]
   143ea:	691a      	ldr	r2, [r3, #16]
   143ec:	9b01      	ldr	r3, [sp, #4]
   143ee:	691b      	ldr	r3, [r3, #16]
   143f0:	681b      	ldr	r3, [r3, #0]
   143f2:	3304      	adds	r3, #4
   143f4:	681b      	ldr	r3, [r3, #0]
   143f6:	2102      	movs	r1, #2
   143f8:	4610      	mov	r0, r2
   143fa:	4798      	blx	r3
    tx_->SetMode(PinInterface::Mode::kPullUp);
   143fc:	9b01      	ldr	r3, [sp, #4]
   143fe:	68da      	ldr	r2, [r3, #12]
   14400:	9b01      	ldr	r3, [sp, #4]
   14402:	68db      	ldr	r3, [r3, #12]
   14404:	681b      	ldr	r3, [r3, #0]
   14406:	3304      	adds	r3, #4
   14408:	681b      	ldr	r3, [r3, #0]
   1440a:	2102      	movs	r1, #2
   1440c:	4610      	mov	r0, r2
   1440e:	4798      	blx	r3
    // Baud rate setting
    SetBaudRate(baud_rate);
   14410:	9900      	ldr	r1, [sp, #0]
   14412:	9801      	ldr	r0, [sp, #4]
   14414:	f7ff ff4e 	bl	142b4 <Uart::SetBaudRate(unsigned long)>
    uart[channel_]->FCR |= kFIFOEnableAndReset;
   14418:	9b01      	ldr	r3, [sp, #4]
   1441a:	7a1b      	ldrb	r3, [r3, #8]
   1441c:	461a      	mov	r2, r3
   1441e:	4b10      	ldr	r3, [pc, #64]	; (14460 <Uart::Initialize(unsigned long)+0xe0>)
   14420:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14424:	7a1b      	ldrb	r3, [r3, #8]
   14426:	b2da      	uxtb	r2, r3
   14428:	9b01      	ldr	r3, [sp, #4]
   1442a:	7a1b      	ldrb	r3, [r3, #8]
   1442c:	4619      	mov	r1, r3
   1442e:	4b0c      	ldr	r3, [pc, #48]	; (14460 <Uart::Initialize(unsigned long)+0xe0>)
   14430:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   14434:	f042 0207 	orr.w	r2, r2, #7
   14438:	b2d2      	uxtb	r2, r2
   1443a:	721a      	strb	r2, [r3, #8]
    return true;
   1443c:	2401      	movs	r4, #1
   1443e:	462b      	mov	r3, r5
   14440:	4619      	mov	r1, r3
   14442:	4803      	ldr	r0, [pc, #12]	; (14450 <Uart::Initialize(unsigned long)+0xd0>)
   14444:	f001 f934 	bl	156b0 <__cyg_profile_func_exit>
   14448:	4623      	mov	r3, r4
  }
   1444a:	4618      	mov	r0, r3
   1444c:	b005      	add	sp, #20
   1444e:	bd30      	pop	{r4, r5, pc}
   14450:	00014381 	.word	0x00014381
   14454:	0001b1b4 	.word	0x0001b1b4
   14458:	0001b1b0 	.word	0x0001b1b0
   1445c:	0001b1ac 	.word	0x0001b1ac
   14460:	10000778 	.word	0x10000778

00014464 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>:

  void Send(uint8_t data) override
  {
    uart[channel_]->THR              = data;
    auto wait_for_transfer_to_finish = [this]() -> bool {
   14464:	b530      	push	{r4, r5, lr}
   14466:	b083      	sub	sp, #12
   14468:	4675      	mov	r5, lr
   1446a:	9001      	str	r0, [sp, #4]
   1446c:	462b      	mov	r3, r5
   1446e:	4619      	mov	r1, r3
   14470:	480d      	ldr	r0, [pc, #52]	; (144a8 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   14472:	f001 f909 	bl	15688 <__cyg_profile_func_enter>
   14476:	9b01      	ldr	r3, [sp, #4]
   14478:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 5));
   1447a:	7a1b      	ldrb	r3, [r3, #8]
   1447c:	461a      	mov	r2, r3
   1447e:	4b0b      	ldr	r3, [pc, #44]	; (144ac <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x48>)
   14480:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14484:	7d1b      	ldrb	r3, [r3, #20]
   14486:	b2db      	uxtb	r3, r3
   14488:	f003 0320 	and.w	r3, r3, #32
   1448c:	2b00      	cmp	r3, #0
   1448e:	bf14      	ite	ne
   14490:	2301      	movne	r3, #1
   14492:	2300      	moveq	r3, #0
   14494:	b2dc      	uxtb	r4, r3
   14496:	462b      	mov	r3, r5
   14498:	4619      	mov	r1, r3
   1449a:	4803      	ldr	r0, [pc, #12]	; (144a8 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   1449c:	f001 f908 	bl	156b0 <__cyg_profile_func_exit>
   144a0:	4623      	mov	r3, r4
    };
   144a2:	4618      	mov	r0, r3
   144a4:	b003      	add	sp, #12
   144a6:	bd30      	pop	{r4, r5, pc}
   144a8:	00014465 	.word	0x00014465
   144ac:	10000778 	.word	0x10000778

000144b0 <Uart::Send(unsigned char)>:
  void Send(uint8_t data) override
   144b0:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   144b4:	b08a      	sub	sp, #40	; 0x28
   144b6:	4675      	mov	r5, lr
   144b8:	9001      	str	r0, [sp, #4]
   144ba:	460b      	mov	r3, r1
   144bc:	f88d 3003 	strb.w	r3, [sp, #3]
   144c0:	462b      	mov	r3, r5
   144c2:	4619      	mov	r1, r3
   144c4:	4831      	ldr	r0, [pc, #196]	; (1458c <Uart::Send(unsigned char)+0xdc>)
   144c6:	f001 f8df 	bl	15688 <__cyg_profile_func_enter>
    uart[channel_]->THR              = data;
   144ca:	9b01      	ldr	r3, [sp, #4]
   144cc:	7a1b      	ldrb	r3, [r3, #8]
   144ce:	461a      	mov	r2, r3
   144d0:	4b2f      	ldr	r3, [pc, #188]	; (14590 <Uart::Send(unsigned char)+0xe0>)
   144d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   144d6:	f89d 2003 	ldrb.w	r2, [sp, #3]
   144da:	701a      	strb	r2, [r3, #0]
    };
   144dc:	9b01      	ldr	r3, [sp, #4]
   144de:	9304      	str	r3, [sp, #16]
   144e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   144e4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   144e8:	e9cd 3408 	strd	r3, r4, [sp, #32]
   144ec:	9b04      	ldr	r3, [sp, #16]
   144ee:	9303      	str	r3, [sp, #12]
   144f0:	462b      	mov	r3, r5
   144f2:	4619      	mov	r1, r3
   144f4:	4827      	ldr	r0, [pc, #156]	; (14594 <Uart::Send(unsigned char)+0xe4>)
   144f6:	f001 f8c7 	bl	15688 <__cyg_profile_func_enter>
template <typename F>
[[gnu::always_inline]] inline Status Wait(uint64_t timeout, F is_done);
template <typename F>
inline Status Wait(uint64_t timeout, F is_done)
{
  uint64_t timeout_time = 0;
   144fa:	f04f 0300 	mov.w	r3, #0
   144fe:	f04f 0400 	mov.w	r4, #0
   14502:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   14506:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   1450a:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   1450e:	bf08      	it	eq
   14510:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   14514:	d106      	bne.n	14524 <Uart::Send(unsigned char)+0x74>
  {
    timeout_time = kMaxWait;
   14516:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1451a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1451e:	e9cd 3406 	strd	r3, r4, [sp, #24]
   14522:	e00b      	b.n	1453c <Uart::Send(unsigned char)+0x8c>
  }
  else
  {
    timeout_time = Milliseconds() + timeout;
   14524:	f7fc faf0 	bl	10b08 <Milliseconds()>
   14528:	460a      	mov	r2, r1
   1452a:	4601      	mov	r1, r0
   1452c:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   14530:	eb13 0b01 	adds.w	fp, r3, r1
   14534:	eb44 0c02 	adc.w	ip, r4, r2
   14538:	e9cd bc06 	strd	fp, ip, [sp, #24]
  }

  Status status = Status::kTimedOut;
   1453c:	2301      	movs	r3, #1
   1453e:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   14540:	f7fc fae2 	bl	10b08 <Milliseconds()>
   14544:	460a      	mov	r2, r1
   14546:	4601      	mov	r1, r0
   14548:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   1454c:	42a2      	cmp	r2, r4
   1454e:	bf08      	it	eq
   14550:	4299      	cmpeq	r1, r3
   14552:	bf34      	ite	cc
   14554:	2301      	movcc	r3, #1
   14556:	2300      	movcs	r3, #0
   14558:	b2db      	uxtb	r3, r3
   1455a:	2b00      	cmp	r3, #0
   1455c:	d008      	beq.n	14570 <Uart::Send(unsigned char)+0xc0>
  {
    if (is_done())
   1455e:	ab03      	add	r3, sp, #12
   14560:	4618      	mov	r0, r3
   14562:	f7ff ff7f 	bl	14464 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   14566:	4603      	mov	r3, r0
   14568:	2b00      	cmp	r3, #0
   1456a:	d0e9      	beq.n	14540 <Uart::Send(unsigned char)+0x90>
    {
      status = Status::kSuccess;
   1456c:	2300      	movs	r3, #0
   1456e:	9305      	str	r3, [sp, #20]
   14570:	462b      	mov	r3, r5
   14572:	4619      	mov	r1, r3
   14574:	4807      	ldr	r0, [pc, #28]	; (14594 <Uart::Send(unsigned char)+0xe4>)
   14576:	f001 f89b 	bl	156b0 <__cyg_profile_func_exit>
   1457a:	462b      	mov	r3, r5
   1457c:	4619      	mov	r1, r3
   1457e:	4803      	ldr	r0, [pc, #12]	; (1458c <Uart::Send(unsigned char)+0xdc>)
   14580:	f001 f896 	bl	156b0 <__cyg_profile_func_exit>
    Wait(kMaxWait, wait_for_transfer_to_finish);
  }
   14584:	bf00      	nop
   14586:	b00a      	add	sp, #40	; 0x28
   14588:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   1458c:	000144b1 	.word	0x000144b1
   14590:	10000778 	.word	0x10000778
   14594:	00014e39 	.word	0x00014e39

00014598 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>:

  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
  {
    uint8_t receiver   = '\xFF';
    auto byte_recieved = [this]() -> bool {
   14598:	b530      	push	{r4, r5, lr}
   1459a:	b083      	sub	sp, #12
   1459c:	4675      	mov	r5, lr
   1459e:	9001      	str	r0, [sp, #4]
   145a0:	462b      	mov	r3, r5
   145a2:	4619      	mov	r1, r3
   145a4:	480d      	ldr	r0, [pc, #52]	; (145dc <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   145a6:	f001 f86f 	bl	15688 <__cyg_profile_func_enter>
   145aa:	9b01      	ldr	r3, [sp, #4]
   145ac:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 0));
   145ae:	7a1b      	ldrb	r3, [r3, #8]
   145b0:	461a      	mov	r2, r3
   145b2:	4b0b      	ldr	r3, [pc, #44]	; (145e0 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x48>)
   145b4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   145b8:	7d1b      	ldrb	r3, [r3, #20]
   145ba:	b2db      	uxtb	r3, r3
   145bc:	f003 0301 	and.w	r3, r3, #1
   145c0:	2b00      	cmp	r3, #0
   145c2:	bf14      	ite	ne
   145c4:	2301      	movne	r3, #1
   145c6:	2300      	moveq	r3, #0
   145c8:	b2dc      	uxtb	r4, r3
   145ca:	462b      	mov	r3, r5
   145cc:	4619      	mov	r1, r3
   145ce:	4803      	ldr	r0, [pc, #12]	; (145dc <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   145d0:	f001 f86e 	bl	156b0 <__cyg_profile_func_exit>
   145d4:	4623      	mov	r3, r4
    };
   145d6:	4618      	mov	r0, r3
   145d8:	b003      	add	sp, #12
   145da:	bd30      	pop	{r4, r5, pc}
   145dc:	00014599 	.word	0x00014599
   145e0:	10000778 	.word	0x10000778

000145e4 <Uart::Receive(unsigned long)>:
  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
   145e4:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   145e8:	b08c      	sub	sp, #48	; 0x30
   145ea:	4675      	mov	r5, lr
   145ec:	9001      	str	r0, [sp, #4]
   145ee:	9100      	str	r1, [sp, #0]
   145f0:	462b      	mov	r3, r5
   145f2:	4619      	mov	r1, r3
   145f4:	4836      	ldr	r0, [pc, #216]	; (146d0 <Uart::Receive(unsigned long)+0xec>)
   145f6:	f001 f847 	bl	15688 <__cyg_profile_func_enter>
    uint8_t receiver   = '\xFF';
   145fa:	23ff      	movs	r3, #255	; 0xff
   145fc:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    };
   14600:	9b01      	ldr	r3, [sp, #4]
   14602:	9304      	str	r3, [sp, #16]

    Status status = Wait(timeout, byte_recieved);
   14604:	9b00      	ldr	r3, [sp, #0]
   14606:	f04f 0400 	mov.w	r4, #0
   1460a:	e9cd 3408 	strd	r3, r4, [sp, #32]
   1460e:	9b04      	ldr	r3, [sp, #16]
   14610:	9303      	str	r3, [sp, #12]
   14612:	462b      	mov	r3, r5
   14614:	4619      	mov	r1, r3
   14616:	482f      	ldr	r0, [pc, #188]	; (146d4 <Uart::Receive(unsigned long)+0xf0>)
   14618:	f001 f836 	bl	15688 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   1461c:	f04f 0300 	mov.w	r3, #0
   14620:	f04f 0400 	mov.w	r4, #0
   14624:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   14628:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   1462c:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   14630:	bf08      	it	eq
   14632:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   14636:	d106      	bne.n	14646 <Uart::Receive(unsigned long)+0x62>
    timeout_time = kMaxWait;
   14638:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1463c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   14640:	e9cd 3406 	strd	r3, r4, [sp, #24]
   14644:	e00b      	b.n	1465e <Uart::Receive(unsigned long)+0x7a>
    timeout_time = Milliseconds() + timeout;
   14646:	f7fc fa5f 	bl	10b08 <Milliseconds()>
   1464a:	460a      	mov	r2, r1
   1464c:	4601      	mov	r1, r0
   1464e:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   14652:	eb13 0b01 	adds.w	fp, r3, r1
   14656:	eb44 0c02 	adc.w	ip, r4, r2
   1465a:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   1465e:	2301      	movs	r3, #1
   14660:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   14662:	f7fc fa51 	bl	10b08 <Milliseconds()>
   14666:	460a      	mov	r2, r1
   14668:	4601      	mov	r1, r0
   1466a:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   1466e:	42a2      	cmp	r2, r4
   14670:	bf08      	it	eq
   14672:	4299      	cmpeq	r1, r3
   14674:	bf34      	ite	cc
   14676:	2301      	movcc	r3, #1
   14678:	2300      	movcs	r3, #0
   1467a:	b2db      	uxtb	r3, r3
   1467c:	2b00      	cmp	r3, #0
   1467e:	d008      	beq.n	14692 <Uart::Receive(unsigned long)+0xae>
    if (is_done())
   14680:	ab03      	add	r3, sp, #12
   14682:	4618      	mov	r0, r3
   14684:	f7ff ff88 	bl	14598 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   14688:	4603      	mov	r3, r0
   1468a:	2b00      	cmp	r3, #0
   1468c:	d0e9      	beq.n	14662 <Uart::Receive(unsigned long)+0x7e>
      status = Status::kSuccess;
   1468e:	2300      	movs	r3, #0
   14690:	9305      	str	r3, [sp, #20]
      break;
    }
  }
  return status;
   14692:	9c05      	ldr	r4, [sp, #20]
   14694:	462b      	mov	r3, r5
   14696:	4619      	mov	r1, r3
   14698:	480e      	ldr	r0, [pc, #56]	; (146d4 <Uart::Receive(unsigned long)+0xf0>)
   1469a:	f001 f809 	bl	156b0 <__cyg_profile_func_exit>
   1469e:	940a      	str	r4, [sp, #40]	; 0x28

    if (status == Status::kSuccess)
   146a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   146a2:	2b00      	cmp	r3, #0
   146a4:	d108      	bne.n	146b8 <Uart::Receive(unsigned long)+0xd4>
    {
      receiver = static_cast<uint8_t>(uart[channel_]->RBR);
   146a6:	9b01      	ldr	r3, [sp, #4]
   146a8:	7a1b      	ldrb	r3, [r3, #8]
   146aa:	461a      	mov	r2, r3
   146ac:	4b0a      	ldr	r3, [pc, #40]	; (146d8 <Uart::Receive(unsigned long)+0xf4>)
   146ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   146b2:	781b      	ldrb	r3, [r3, #0]
   146b4:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    }
    return receiver;
   146b8:	f89d 402f 	ldrb.w	r4, [sp, #47]	; 0x2f
   146bc:	462b      	mov	r3, r5
   146be:	4619      	mov	r1, r3
   146c0:	4803      	ldr	r0, [pc, #12]	; (146d0 <Uart::Receive(unsigned long)+0xec>)
   146c2:	f000 fff5 	bl	156b0 <__cyg_profile_func_exit>
   146c6:	4623      	mov	r3, r4
  }
   146c8:	4618      	mov	r0, r3
   146ca:	b00c      	add	sp, #48	; 0x30
   146cc:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   146d0:	000145e5 	.word	0x000145e5
   146d4:	00014ee1 	.word	0x00014ee1
   146d8:	10000778 	.word	0x10000778

000146dc <Uart::FindClosestFractional(float)>:

 private:
  UartCalibration_t FindClosestFractional(float decimal)
   146dc:	b510      	push	{r4, lr}
   146de:	b08a      	sub	sp, #40	; 0x28
   146e0:	4674      	mov	r4, lr
   146e2:	9003      	str	r0, [sp, #12]
   146e4:	9102      	str	r1, [sp, #8]
   146e6:	ed8d 0a01 	vstr	s0, [sp, #4]
   146ea:	4623      	mov	r3, r4
   146ec:	4619      	mov	r1, r3
   146ee:	4838      	ldr	r0, [pc, #224]	; (147d0 <Uart::FindClosestFractional(float)+0xf4>)
   146f0:	f000 ffca 	bl	15688 <__cyg_profile_func_enter>
  {
    UartCalibration_t result;
   146f4:	9b03      	ldr	r3, [sp, #12]
   146f6:	2200      	movs	r2, #0
   146f8:	601a      	str	r2, [r3, #0]
   146fa:	9b03      	ldr	r3, [sp, #12]
   146fc:	2200      	movs	r2, #0
   146fe:	605a      	str	r2, [r3, #4]
   14700:	9b03      	ldr	r3, [sp, #12]
   14702:	2201      	movs	r2, #1
   14704:	609a      	str	r2, [r3, #8]
    bool finished = false;
   14706:	2300      	movs	r3, #0
   14708:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (int div = 0; div < 15 && !finished; div++)
   1470c:	2300      	movs	r3, #0
   1470e:	9308      	str	r3, [sp, #32]
   14710:	9b08      	ldr	r3, [sp, #32]
   14712:	2b0e      	cmp	r3, #14
   14714:	dc52      	bgt.n	147bc <Uart::FindClosestFractional(float)+0xe0>
   14716:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1471a:	2b00      	cmp	r3, #0
   1471c:	d14e      	bne.n	147bc <Uart::FindClosestFractional(float)+0xe0>
    {
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   1471e:	9b08      	ldr	r3, [sp, #32]
   14720:	3301      	adds	r3, #1
   14722:	9307      	str	r3, [sp, #28]
   14724:	9b07      	ldr	r3, [sp, #28]
   14726:	2b0e      	cmp	r3, #14
   14728:	dc44      	bgt.n	147b4 <Uart::FindClosestFractional(float)+0xd8>
   1472a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1472e:	2b00      	cmp	r3, #0
   14730:	d140      	bne.n	147b4 <Uart::FindClosestFractional(float)+0xd8>
      {
        float divf         = static_cast<float>(div);
   14732:	9b08      	ldr	r3, [sp, #32]
   14734:	ee07 3a90 	vmov	s15, r3
   14738:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1473c:	edcd 7a06 	vstr	s15, [sp, #24]
        float mulf         = static_cast<float>(mul);
   14740:	9b07      	ldr	r3, [sp, #28]
   14742:	ee07 3a90 	vmov	s15, r3
   14746:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1474a:	edcd 7a05 	vstr	s15, [sp, #20]
        float test_decimal = 1.0f + divf / mulf;
   1474e:	eddd 6a06 	vldr	s13, [sp, #24]
   14752:	ed9d 7a05 	vldr	s14, [sp, #20]
   14756:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1475a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1475e:	ee77 7a87 	vadd.f32	s15, s15, s14
   14762:	edcd 7a04 	vstr	s15, [sp, #16]
        if (decimal <= test_decimal + kThreshold &&
   14766:	eddd 7a04 	vldr	s15, [sp, #16]
   1476a:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 147d4 <Uart::FindClosestFractional(float)+0xf8>
   1476e:	ee77 7a87 	vadd.f32	s15, s15, s14
   14772:	ed9d 7a01 	vldr	s14, [sp, #4]
   14776:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1477a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1477e:	d815      	bhi.n	147ac <Uart::FindClosestFractional(float)+0xd0>
            decimal >= test_decimal - kThreshold)
   14780:	eddd 7a04 	vldr	s15, [sp, #16]
   14784:	ed9f 7a13 	vldr	s14, [pc, #76]	; 147d4 <Uart::FindClosestFractional(float)+0xf8>
   14788:	ee77 7ac7 	vsub.f32	s15, s15, s14
        if (decimal <= test_decimal + kThreshold &&
   1478c:	ed9d 7a01 	vldr	s14, [sp, #4]
   14790:	eeb4 7ae7 	vcmpe.f32	s14, s15
   14794:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14798:	db08      	blt.n	147ac <Uart::FindClosestFractional(float)+0xd0>
        {
          result.divide_add = div;
   1479a:	9a08      	ldr	r2, [sp, #32]
   1479c:	9b03      	ldr	r3, [sp, #12]
   1479e:	605a      	str	r2, [r3, #4]
          result.multiply   = mul;
   147a0:	9a07      	ldr	r2, [sp, #28]
   147a2:	9b03      	ldr	r3, [sp, #12]
   147a4:	609a      	str	r2, [r3, #8]
          finished          = true;
   147a6:	2301      	movs	r3, #1
   147a8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   147ac:	9b07      	ldr	r3, [sp, #28]
   147ae:	3301      	adds	r3, #1
   147b0:	9307      	str	r3, [sp, #28]
   147b2:	e7b7      	b.n	14724 <Uart::FindClosestFractional(float)+0x48>
    for (int div = 0; div < 15 && !finished; div++)
   147b4:	9b08      	ldr	r3, [sp, #32]
   147b6:	3301      	adds	r3, #1
   147b8:	9308      	str	r3, [sp, #32]
   147ba:	e7a9      	b.n	14710 <Uart::FindClosestFractional(float)+0x34>
        }
      }
    }
    return result;
   147bc:	bf00      	nop
   147be:	4623      	mov	r3, r4
   147c0:	4619      	mov	r1, r3
   147c2:	4803      	ldr	r0, [pc, #12]	; (147d0 <Uart::FindClosestFractional(float)+0xf4>)
   147c4:	f000 ff74 	bl	156b0 <__cyg_profile_func_exit>
   147c8:	bf00      	nop
  }
   147ca:	9803      	ldr	r0, [sp, #12]
   147cc:	b00a      	add	sp, #40	; 0x28
   147ce:	bd10      	pop	{r4, pc}
   147d0:	000146dd 	.word	0x000146dd
   147d4:	3d4ccccd 	.word	0x3d4ccccd

000147d8 <Uart::DividerEstimate(float, float)>:

  float DividerEstimate(float baud_rate, float fraction_estimate = 1)
   147d8:	b510      	push	{r4, lr}
   147da:	ed2d 8b02 	vpush	{d8}
   147de:	b086      	sub	sp, #24
   147e0:	4674      	mov	r4, lr
   147e2:	9003      	str	r0, [sp, #12]
   147e4:	ed8d 0a02 	vstr	s0, [sp, #8]
   147e8:	edcd 0a01 	vstr	s1, [sp, #4]
   147ec:	4623      	mov	r3, r4
   147ee:	4619      	mov	r1, r3
   147f0:	4815      	ldr	r0, [pc, #84]	; (14848 <Uart::DividerEstimate(float, float)+0x70>)
   147f2:	f000 ff49 	bl	15688 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   147f6:	9b03      	ldr	r3, [sp, #12]
   147f8:	1d1a      	adds	r2, r3, #4
   147fa:	9b03      	ldr	r3, [sp, #12]
   147fc:	685b      	ldr	r3, [r3, #4]
   147fe:	3310      	adds	r3, #16
   14800:	681b      	ldr	r3, [r3, #0]
   14802:	4610      	mov	r0, r2
   14804:	4798      	blx	r3
   14806:	ee07 0a90 	vmov	s15, r0
   1480a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1480e:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * fraction_estimate);
   14812:	eddd 7a02 	vldr	s15, [sp, #8]
   14816:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   1481a:	ee27 7a87 	vmul.f32	s14, s15, s14
   1481e:	eddd 7a01 	vldr	s15, [sp, #4]
   14822:	ee67 7a27 	vmul.f32	s15, s14, s15
   14826:	ed9d 7a05 	vldr	s14, [sp, #20]
   1482a:	ee87 8a27 	vdiv.f32	s16, s14, s15
   1482e:	4623      	mov	r3, r4
   14830:	4619      	mov	r1, r3
   14832:	4805      	ldr	r0, [pc, #20]	; (14848 <Uart::DividerEstimate(float, float)+0x70>)
   14834:	f000 ff3c 	bl	156b0 <__cyg_profile_func_exit>
   14838:	eef0 7a48 	vmov.f32	s15, s16
  }
   1483c:	eeb0 0a67 	vmov.f32	s0, s15
   14840:	b006      	add	sp, #24
   14842:	ecbd 8b02 	vpop	{d8}
   14846:	bd10      	pop	{r4, pc}
   14848:	000147d9 	.word	0x000147d9

0001484c <Uart::FractionalEstimate(float, float)>:

  float FractionalEstimate(float baud_rate, float divider)
   1484c:	b510      	push	{r4, lr}
   1484e:	ed2d 8b02 	vpush	{d8}
   14852:	b086      	sub	sp, #24
   14854:	4674      	mov	r4, lr
   14856:	9003      	str	r0, [sp, #12]
   14858:	ed8d 0a02 	vstr	s0, [sp, #8]
   1485c:	edcd 0a01 	vstr	s1, [sp, #4]
   14860:	4623      	mov	r3, r4
   14862:	4619      	mov	r1, r3
   14864:	4815      	ldr	r0, [pc, #84]	; (148bc <Uart::FractionalEstimate(float, float)+0x70>)
   14866:	f000 ff0f 	bl	15688 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   1486a:	9b03      	ldr	r3, [sp, #12]
   1486c:	1d1a      	adds	r2, r3, #4
   1486e:	9b03      	ldr	r3, [sp, #12]
   14870:	685b      	ldr	r3, [r3, #4]
   14872:	3310      	adds	r3, #16
   14874:	681b      	ldr	r3, [r3, #0]
   14876:	4610      	mov	r0, r2
   14878:	4798      	blx	r3
   1487a:	ee07 0a90 	vmov	s15, r0
   1487e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   14882:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * divider);
   14886:	eddd 7a02 	vldr	s15, [sp, #8]
   1488a:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   1488e:	ee27 7a87 	vmul.f32	s14, s15, s14
   14892:	eddd 7a01 	vldr	s15, [sp, #4]
   14896:	ee67 7a27 	vmul.f32	s15, s14, s15
   1489a:	ed9d 7a05 	vldr	s14, [sp, #20]
   1489e:	ee87 8a27 	vdiv.f32	s16, s14, s15
   148a2:	4623      	mov	r3, r4
   148a4:	4619      	mov	r1, r3
   148a6:	4805      	ldr	r0, [pc, #20]	; (148bc <Uart::FractionalEstimate(float, float)+0x70>)
   148a8:	f000 ff02 	bl	156b0 <__cyg_profile_func_exit>
   148ac:	eef0 7a48 	vmov.f32	s15, s16
  }
   148b0:	eeb0 0a67 	vmov.f32	s0, s15
   148b4:	b006      	add	sp, #24
   148b6:	ecbd 8b02 	vpop	{d8}
   148ba:	bd10      	pop	{r4, pc}
   148bc:	0001484d 	.word	0x0001484d

000148c0 <Uart::IsDecmial(float)>:

  bool IsDecmial(float value)
   148c0:	b530      	push	{r4, r5, lr}
   148c2:	b087      	sub	sp, #28
   148c4:	4675      	mov	r5, lr
   148c6:	9001      	str	r0, [sp, #4]
   148c8:	ed8d 0a00 	vstr	s0, [sp]
   148cc:	462b      	mov	r3, r5
   148ce:	4619      	mov	r1, r3
   148d0:	4819      	ldr	r0, [pc, #100]	; (14938 <Uart::IsDecmial(float)+0x78>)
   148d2:	f000 fed9 	bl	15688 <__cyg_profile_func_enter>
  {
    bool result         = false;
   148d6:	2300      	movs	r3, #0
   148d8:	f88d 3017 	strb.w	r3, [sp, #23]
    float rounded_value = roundf(value);
   148dc:	ed9d 0a00 	vldr	s0, [sp]
   148e0:	f004 fdb4 	bl	1944c <roundf>
   148e4:	ed8d 0a04 	vstr	s0, [sp, #16]
    float error         = value - rounded_value;
   148e8:	ed9d 7a00 	vldr	s14, [sp]
   148ec:	eddd 7a04 	vldr	s15, [sp, #16]
   148f0:	ee77 7a67 	vsub.f32	s15, s14, s15
   148f4:	edcd 7a03 	vstr	s15, [sp, #12]
    if (-kThreshold <= error && error <= kThreshold)
   148f8:	eddd 7a03 	vldr	s15, [sp, #12]
   148fc:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 1493c <Uart::IsDecmial(float)+0x7c>
   14900:	eef4 7ac7 	vcmpe.f32	s15, s14
   14904:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14908:	db0b      	blt.n	14922 <Uart::IsDecmial(float)+0x62>
   1490a:	eddd 7a03 	vldr	s15, [sp, #12]
   1490e:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 14940 <Uart::IsDecmial(float)+0x80>
   14912:	eef4 7ac7 	vcmpe.f32	s15, s14
   14916:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1491a:	d802      	bhi.n	14922 <Uart::IsDecmial(float)+0x62>
    {
      result = true;
   1491c:	2301      	movs	r3, #1
   1491e:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return result;
   14922:	f89d 4017 	ldrb.w	r4, [sp, #23]
   14926:	462b      	mov	r3, r5
   14928:	4619      	mov	r1, r3
   1492a:	4803      	ldr	r0, [pc, #12]	; (14938 <Uart::IsDecmial(float)+0x78>)
   1492c:	f000 fec0 	bl	156b0 <__cyg_profile_func_exit>
   14930:	4623      	mov	r3, r4
  }
   14932:	4618      	mov	r0, r3
   14934:	b007      	add	sp, #28
   14936:	bd30      	pop	{r4, r5, pc}
   14938:	000148c1 	.word	0x000148c1
   1493c:	bd4ccccd 	.word	0xbd4ccccd
   14940:	3d4ccccd 	.word	0x3d4ccccd

00014944 <Uart::GenerateUartCalibration(float)>:

  UartCalibration_t GenerateUartCalibration(float baud_rate)
   14944:	b530      	push	{r4, r5, lr}
   14946:	b08f      	sub	sp, #60	; 0x3c
   14948:	4675      	mov	r5, lr
   1494a:	9007      	str	r0, [sp, #28]
   1494c:	9106      	str	r1, [sp, #24]
   1494e:	ed8d 0a05 	vstr	s0, [sp, #20]
   14952:	462b      	mov	r3, r5
   14954:	4619      	mov	r1, r3
   14956:	4874      	ldr	r0, [pc, #464]	; (14b28 <Uart::GenerateUartCalibration(float)+0x1e4>)
   14958:	f000 fe96 	bl	15688 <__cyg_profile_func_enter>
  {
    States state = States::kCalculateIntegerDivideLatch;
   1495c:	2300      	movs	r3, #0
   1495e:	930d      	str	r3, [sp, #52]	; 0x34
    UartCalibration_t uart_calibration;
   14960:	9b07      	ldr	r3, [sp, #28]
   14962:	2200      	movs	r2, #0
   14964:	601a      	str	r2, [r3, #0]
   14966:	9b07      	ldr	r3, [sp, #28]
   14968:	2200      	movs	r2, #0
   1496a:	605a      	str	r2, [r3, #4]
   1496c:	9b07      	ldr	r3, [sp, #28]
   1496e:	2201      	movs	r2, #1
   14970:	609a      	str	r2, [r3, #8]
    float divide_estimate = 0;
   14972:	f04f 0300 	mov.w	r3, #0
   14976:	930c      	str	r3, [sp, #48]	; 0x30
    float decimal         = 1.5;
   14978:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
   1497c:	930b      	str	r3, [sp, #44]	; 0x2c
    float div             = 1;
   1497e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   14982:	930a      	str	r3, [sp, #40]	; 0x28
    float mul             = 2;
   14984:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   14988:	9309      	str	r3, [sp, #36]	; 0x24
    while (state != States::kDone)
   1498a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1498c:	2b04      	cmp	r3, #4
   1498e:	f000 80c1 	beq.w	14b14 <Uart::GenerateUartCalibration(float)+0x1d0>
    {
      switch (state)
   14992:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14994:	2b04      	cmp	r3, #4
   14996:	f200 80bb 	bhi.w	14b10 <Uart::GenerateUartCalibration(float)+0x1cc>
   1499a:	a201      	add	r2, pc, #4	; (adr r2, 149a0 <Uart::GenerateUartCalibration(float)+0x5c>)
   1499c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   149a0:	000149b5 	.word	0x000149b5
   149a4:	00014a11 	.word	0x00014a11
   149a8:	00014a71 	.word	0x00014a71
   149ac:	00014ae1 	.word	0x00014ae1
   149b0:	00014b11 	.word	0x00014b11
      {
        case States::kCalculateIntegerDivideLatch:
        {
          divide_estimate = DividerEstimate(baud_rate);
   149b4:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   149b8:	ed9d 0a05 	vldr	s0, [sp, #20]
   149bc:	9806      	ldr	r0, [sp, #24]
   149be:	f7ff ff0b 	bl	147d8 <Uart::DividerEstimate(float, float)>
   149c2:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          if (divide_estimate < 1.0f)
   149c6:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   149ca:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   149ce:	eef4 7ac7 	vcmpe.f32	s15, s14
   149d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   149d6:	d505      	bpl.n	149e4 <Uart::GenerateUartCalibration(float)+0xa0>
          {
            uart_calibration.divide_latch = 0;
   149d8:	9b07      	ldr	r3, [sp, #28]
   149da:	2200      	movs	r2, #0
   149dc:	601a      	str	r2, [r3, #0]
            state                         = States::kDone;
   149de:	2304      	movs	r3, #4
   149e0:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kCalculateDivideLatchWithDecimal;
          }
          break;
   149e2:	e096      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
          else if (IsDecmial(divide_estimate))
   149e4:	ed9d 0a0c 	vldr	s0, [sp, #48]	; 0x30
   149e8:	9806      	ldr	r0, [sp, #24]
   149ea:	f7ff ff69 	bl	148c0 <Uart::IsDecmial(float)>
   149ee:	4603      	mov	r3, r0
   149f0:	2b00      	cmp	r3, #0
   149f2:	d00a      	beq.n	14a0a <Uart::GenerateUartCalibration(float)+0xc6>
                static_cast<uint32_t>(divide_estimate);
   149f4:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   149f8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   149fc:	ee17 2a90 	vmov	r2, s15
            uart_calibration.divide_latch =
   14a00:	9b07      	ldr	r3, [sp, #28]
   14a02:	601a      	str	r2, [r3, #0]
            state = States::kDone;
   14a04:	2304      	movs	r3, #4
   14a06:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   14a08:	e083      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kCalculateDivideLatchWithDecimal;
   14a0a:	2301      	movs	r3, #1
   14a0c:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   14a0e:	e080      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kCalculateDivideLatchWithDecimal:
        {
          divide_estimate = roundf(DividerEstimate(baud_rate, decimal));
   14a10:	eddd 0a0b 	vldr	s1, [sp, #44]	; 0x2c
   14a14:	ed9d 0a05 	vldr	s0, [sp, #20]
   14a18:	9806      	ldr	r0, [sp, #24]
   14a1a:	f7ff fedd 	bl	147d8 <Uart::DividerEstimate(float, float)>
   14a1e:	eef0 7a40 	vmov.f32	s15, s0
   14a22:	eeb0 0a67 	vmov.f32	s0, s15
   14a26:	f004 fd11 	bl	1944c <roundf>
   14a2a:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          decimal         = FractionalEstimate(baud_rate, divide_estimate);
   14a2e:	eddd 0a0c 	vldr	s1, [sp, #48]	; 0x30
   14a32:	ed9d 0a05 	vldr	s0, [sp, #20]
   14a36:	9806      	ldr	r0, [sp, #24]
   14a38:	f7ff ff08 	bl	1484c <Uart::FractionalEstimate(float, float)>
   14a3c:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
          if (1.1f <= decimal && decimal <= 1.9f)
   14a40:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   14a44:	ed9f 7a39 	vldr	s14, [pc, #228]	; 14b2c <Uart::GenerateUartCalibration(float)+0x1e8>
   14a48:	eef4 7ac7 	vcmpe.f32	s15, s14
   14a4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14a50:	db0b      	blt.n	14a6a <Uart::GenerateUartCalibration(float)+0x126>
   14a52:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   14a56:	ed9f 7a36 	vldr	s14, [pc, #216]	; 14b30 <Uart::GenerateUartCalibration(float)+0x1ec>
   14a5a:	eef4 7ac7 	vcmpe.f32	s15, s14
   14a5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14a62:	d802      	bhi.n	14a6a <Uart::GenerateUartCalibration(float)+0x126>
          {
            state = States::kGenerateFractionFromDecimal;
   14a64:	2303      	movs	r3, #3
   14a66:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kDecimalFailedGenerateNewDecimal;
          }
          break;
   14a68:	e053      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kDecimalFailedGenerateNewDecimal;
   14a6a:	2302      	movs	r3, #2
   14a6c:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   14a6e:	e050      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDecimalFailedGenerateNewDecimal:
        {
          mul += 1;
   14a70:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   14a74:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   14a78:	ee77 7a87 	vadd.f32	s15, s15, s14
   14a7c:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24

          if (div > 15)
   14a80:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   14a84:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   14a88:	eef4 7ac7 	vcmpe.f32	s15, s14
   14a8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14a90:	dd02      	ble.n	14a98 <Uart::GenerateUartCalibration(float)+0x154>
          {
            state = States::kDone;
   14a92:	2304      	movs	r3, #4
   14a94:	930d      	str	r3, [sp, #52]	; 0x34
            break;
   14a96:	e03c      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
          }
          else if (mul > 15)
   14a98:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   14a9c:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   14aa0:	eef4 7ac7 	vcmpe.f32	s15, s14
   14aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14aa8:	dd0f      	ble.n	14aca <Uart::GenerateUartCalibration(float)+0x186>
          {
            div += 1;
   14aaa:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   14aae:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   14ab2:	ee77 7a87 	vadd.f32	s15, s15, s14
   14ab6:	edcd 7a0a 	vstr	s15, [sp, #40]	; 0x28
            mul = div + 1;
   14aba:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   14abe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   14ac2:	ee77 7a87 	vadd.f32	s15, s15, s14
   14ac6:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
          }
          decimal = div / mul;
   14aca:	eddd 6a0a 	vldr	s13, [sp, #40]	; 0x28
   14ace:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
   14ad2:	eec6 7a87 	vdiv.f32	s15, s13, s14
   14ad6:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
          state   = States::kCalculateDivideLatchWithDecimal;
   14ada:	2301      	movs	r3, #1
   14adc:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   14ade:	e018      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kGenerateFractionFromDecimal:
        {
          uart_calibration = FindClosestFractional(decimal);
   14ae0:	9c07      	ldr	r4, [sp, #28]
   14ae2:	466b      	mov	r3, sp
   14ae4:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
   14ae8:	9906      	ldr	r1, [sp, #24]
   14aea:	4618      	mov	r0, r3
   14aec:	f7ff fdf6 	bl	146dc <Uart::FindClosestFractional(float)>
   14af0:	466b      	mov	r3, sp
   14af2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   14af6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
          uart_calibration.divide_latch =
              static_cast<uint32_t>(divide_estimate);
   14afa:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   14afe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   14b02:	ee17 2a90 	vmov	r2, s15
          uart_calibration.divide_latch =
   14b06:	9b07      	ldr	r3, [sp, #28]
   14b08:	601a      	str	r2, [r3, #0]
          state = States::kDone;
   14b0a:	2304      	movs	r3, #4
   14b0c:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   14b0e:	e000      	b.n	14b12 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDone: { break;
        }
        default: { break;
   14b10:	bf00      	nop
    while (state != States::kDone)
   14b12:	e73a      	b.n	1498a <Uart::GenerateUartCalibration(float)+0x46>
        }
      }
    }
    return uart_calibration;
   14b14:	bf00      	nop
   14b16:	462b      	mov	r3, r5
   14b18:	4619      	mov	r1, r3
   14b1a:	4803      	ldr	r0, [pc, #12]	; (14b28 <Uart::GenerateUartCalibration(float)+0x1e4>)
   14b1c:	f000 fdc8 	bl	156b0 <__cyg_profile_func_exit>
   14b20:	bf00      	nop
  }
   14b22:	9807      	ldr	r0, [sp, #28]
   14b24:	b00f      	add	sp, #60	; 0x3c
   14b26:	bd30      	pop	{r4, r5, pc}
   14b28:	00014945 	.word	0x00014945
   14b2c:	3f8ccccd 	.word	0x3f8ccccd
   14b30:	3ff33333 	.word	0x3ff33333

00014b34 <(anonymous namespace)::Lpc40xxUptime()>:
{
   14b34:	b538      	push	{r3, r4, r5, lr}
   14b36:	4675      	mov	r5, lr
   14b38:	462b      	mov	r3, r5
   14b3a:	4619      	mov	r1, r3
   14b3c:	480a      	ldr	r0, [pc, #40]	; (14b68 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   14b3e:	f000 fda3 	bl	15688 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   14b42:	4b0a      	ldr	r3, [pc, #40]	; (14b6c <(anonymous namespace)::Lpc40xxUptime()+0x38>)
   14b44:	7a1b      	ldrb	r3, [r3, #8]
   14b46:	461a      	mov	r2, r3
   14b48:	4b09      	ldr	r3, [pc, #36]	; (14b70 <(anonymous namespace)::Lpc40xxUptime()+0x3c>)
   14b4a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14b4e:	689c      	ldr	r4, [r3, #8]
   14b50:	462b      	mov	r3, r5
   14b52:	4619      	mov	r1, r3
   14b54:	4804      	ldr	r0, [pc, #16]	; (14b68 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   14b56:	f000 fdab 	bl	156b0 <__cyg_profile_func_exit>
  return timer0.GetTimer();
   14b5a:	4623      	mov	r3, r4
   14b5c:	f04f 0400 	mov.w	r4, #0
}
   14b60:	4618      	mov	r0, r3
   14b62:	4621      	mov	r1, r4
   14b64:	bd38      	pop	{r3, r4, r5, pc}
   14b66:	bf00      	nop
   14b68:	00014279 	.word	0x00014279
   14b6c:	100007e8 	.word	0x100007e8
   14b70:	10000768 	.word	0x10000768

00014b74 <UptimeRTOS>:
{
   14b74:	b538      	push	{r3, r4, r5, lr}
   14b76:	4675      	mov	r5, lr
   14b78:	462b      	mov	r3, r5
   14b7a:	4619      	mov	r1, r3
   14b7c:	480a      	ldr	r0, [pc, #40]	; (14ba8 <UptimeRTOS+0x34>)
   14b7e:	f000 fd83 	bl	15688 <__cyg_profile_func_enter>
   14b82:	4b0a      	ldr	r3, [pc, #40]	; (14bac <UptimeRTOS+0x38>)
   14b84:	7a1b      	ldrb	r3, [r3, #8]
   14b86:	461a      	mov	r2, r3
   14b88:	4b09      	ldr	r3, [pc, #36]	; (14bb0 <UptimeRTOS+0x3c>)
   14b8a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14b8e:	689c      	ldr	r4, [r3, #8]
   14b90:	462b      	mov	r3, r5
   14b92:	4619      	mov	r1, r3
   14b94:	4804      	ldr	r0, [pc, #16]	; (14ba8 <UptimeRTOS+0x34>)
   14b96:	f000 fd8b 	bl	156b0 <__cyg_profile_func_exit>
  return timer0.GetTimer();
   14b9a:	4623      	mov	r3, r4
   14b9c:	f04f 0400 	mov.w	r4, #0
}
   14ba0:	4618      	mov	r0, r3
   14ba2:	4621      	mov	r1, r4
   14ba4:	bd38      	pop	{r3, r4, r5, pc}
   14ba6:	bf00      	nop
   14ba8:	00014279 	.word	0x00014279
   14bac:	100007e8 	.word	0x100007e8
   14bb0:	10000768 	.word	0x10000768

00014bb4 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>:
   *  @brief  Return the size of an array.
   *  @param  __array  Array.
   */
  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (&/*__array*/)[_Nm]) noexcept
   14bb4:	b530      	push	{r4, r5, lr}
   14bb6:	b083      	sub	sp, #12
   14bb8:	4675      	mov	r5, lr
   14bba:	9001      	str	r0, [sp, #4]
   14bbc:	462b      	mov	r3, r5
   14bbe:	4619      	mov	r1, r3
   14bc0:	4806      	ldr	r0, [pc, #24]	; (14bdc <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   14bc2:	f000 fd61 	bl	15688 <__cyg_profile_func_enter>
    { return _Nm; }
   14bc6:	2450      	movs	r4, #80	; 0x50
   14bc8:	462b      	mov	r3, r5
   14bca:	4619      	mov	r1, r3
   14bcc:	4803      	ldr	r0, [pc, #12]	; (14bdc <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   14bce:	f000 fd6f 	bl	156b0 <__cyg_profile_func_exit>
   14bd2:	4623      	mov	r3, r4
   14bd4:	4618      	mov	r0, r3
   14bd6:	b003      	add	sp, #12
   14bd8:	bd30      	pop	{r4, r5, pc}
   14bda:	bf00      	nop
   14bdc:	00014bb5 	.word	0x00014bb5

00014be0 <vApplicationGetIdleTaskMemory>:
  {
   14be0:	b500      	push	{lr}
   14be2:	b085      	sub	sp, #20
   14be4:	9003      	str	r0, [sp, #12]
   14be6:	9102      	str	r1, [sp, #8]
   14be8:	9201      	str	r2, [sp, #4]
    *ppx_idle_task_tcb_buffer   = &idle_task_tcb;
   14bea:	9b03      	ldr	r3, [sp, #12]
   14bec:	4a07      	ldr	r2, [pc, #28]	; (14c0c <vApplicationGetIdleTaskMemory+0x2c>)
   14bee:	601a      	str	r2, [r3, #0]
    *ppx_idle_task_stack_buffer = idle_task_stack;
   14bf0:	9b02      	ldr	r3, [sp, #8]
   14bf2:	4a07      	ldr	r2, [pc, #28]	; (14c10 <vApplicationGetIdleTaskMemory+0x30>)
   14bf4:	601a      	str	r2, [r3, #0]
    *pul_idle_task_stack_size   = std::size(idle_task_stack);
   14bf6:	4806      	ldr	r0, [pc, #24]	; (14c10 <vApplicationGetIdleTaskMemory+0x30>)
   14bf8:	f7ff ffdc 	bl	14bb4 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>
   14bfc:	4602      	mov	r2, r0
   14bfe:	9b01      	ldr	r3, [sp, #4]
   14c00:	601a      	str	r2, [r3, #0]
  }
   14c02:	bf00      	nop
   14c04:	b005      	add	sp, #20
   14c06:	f85d fb04 	ldr.w	pc, [sp], #4
   14c0a:	bf00      	nop
   14c0c:	100012a8 	.word	0x100012a8
   14c10:	10001308 	.word	0x10001308

00014c14 <vPortSetupTimerInterrupt>:
  {
   14c14:	b508      	push	{r3, lr}
    system_timer.DisableTimer();
   14c16:	f7ff f8ef 	bl	13df8 <SystemTimer::DisableTimer()>
    system_timer.SetTickFrequency(config::kRtosFrequency);
   14c1a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   14c1e:	4806      	ldr	r0, [pc, #24]	; (14c38 <vPortSetupTimerInterrupt+0x24>)
   14c20:	f7ff f98a 	bl	13f38 <SystemTimer::SetTickFrequency(unsigned long)>
    system_timer.SetIsrFunction(xPortSysTickHandler);
   14c24:	4905      	ldr	r1, [pc, #20]	; (14c3c <vPortSetupTimerInterrupt+0x28>)
   14c26:	4804      	ldr	r0, [pc, #16]	; (14c38 <vPortSetupTimerInterrupt+0x24>)
   14c28:	f7ff f91e 	bl	13e68 <SystemTimer::SetIsrFunction(void (*)())>
    system_timer.StartTimer();
   14c2c:	4802      	ldr	r0, [pc, #8]	; (14c38 <vPortSetupTimerInterrupt+0x24>)
   14c2e:	f7ff f935 	bl	13e9c <SystemTimer::StartTimer()>
  }
   14c32:	bf00      	nop
   14c34:	bd08      	pop	{r3, pc}
   14c36:	bf00      	nop
   14c38:	100007dc 	.word	0x100007dc
   14c3c:	00016ab9 	.word	0x00016ab9

00014c40 <LowLevelInit()>:

void LowLevelInit()
{
   14c40:	b500      	push	{lr}
   14c42:	b083      	sub	sp, #12
  // Set the SystemTick frequency to the RTOS tick frequency
  // It is critical that this happens before you set the system_clock, since
  // The system_timer keeps the time that the system_clock uses to delay itself.
  system_timer.SetTickFrequency(config::kRtosFrequency);
   14c44:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   14c48:	4822      	ldr	r0, [pc, #136]	; (14cd4 <LowLevelInit()+0x94>)
   14c4a:	f7ff f975 	bl	13f38 <SystemTimer::SetTickFrequency(unsigned long)>
  bool timer_started_successfully = system_timer.StartTimer();
   14c4e:	4821      	ldr	r0, [pc, #132]	; (14cd4 <LowLevelInit()+0x94>)
   14c50:	f7ff f924 	bl	13e9c <SystemTimer::StartTimer()>
   14c54:	4603      	mov	r3, r0
   14c56:	f88d 3007 	strb.w	r3, [sp, #7]
  SJ2_ASSERT_WARNING(timer_started_successfully,
   14c5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c5e:	f083 0301 	eor.w	r3, r3, #1
   14c62:	b2db      	uxtb	r3, r3
   14c64:	2b00      	cmp	r3, #0
   14c66:	d005      	beq.n	14c74 <LowLevelInit()+0x34>
   14c68:	23ad      	movs	r3, #173	; 0xad
   14c6a:	4a1b      	ldr	r2, [pc, #108]	; (14cd8 <LowLevelInit()+0x98>)
   14c6c:	491b      	ldr	r1, [pc, #108]	; (14cdc <LowLevelInit()+0x9c>)
   14c6e:	481c      	ldr	r0, [pc, #112]	; (14ce0 <LowLevelInit()+0xa0>)
   14c70:	f003 f8ee 	bl	17e50 <printf>
                     "System Timer has FAILED to start!");
  // Set Clock Speed
  // SetClockFrequency will timeout return the offset between desire clockspeed
  // and actual clockspeed if the PLL doesn't get a frequency fix within a
  // defined timeout (see L1/system_clock.hpp:kDefaultTimeout)
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   14c74:	2130      	movs	r1, #48	; 0x30
   14c76:	481b      	ldr	r0, [pc, #108]	; (14ce4 <LowLevelInit()+0xa4>)
   14c78:	f7fc fc34 	bl	114e4 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>
   14c7c:	4603      	mov	r3, r0
   14c7e:	2b00      	cmp	r3, #0
   14c80:	bf14      	ite	ne
   14c82:	2301      	movne	r3, #1
   14c84:	2300      	moveq	r3, #0
   14c86:	b2db      	uxtb	r3, r3
   14c88:	2b00      	cmp	r3, #0
   14c8a:	d001      	beq.n	14c90 <LowLevelInit()+0x50>
  {
    // Continually attempt to set the clock frequency to the desired until the
    // delta between desired and actual are 0.
    continue;
   14c8c:	bf00      	nop
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   14c8e:	e7f1      	b.n	14c74 <LowLevelInit()+0x34>
  }
  // Enable Peripheral Clock and set its divider to 1 meaning the clock speed
  // fed to all peripherals will be 48Mhz.
  system_controller.SetPeripheralClockDivider(1);
   14c90:	2101      	movs	r1, #1
   14c92:	4814      	ldr	r0, [pc, #80]	; (14ce4 <LowLevelInit()+0xa4>)
   14c94:	f7fc fc6e 	bl	11574 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>
  // Set System Timer frequency again, since the clock speed has changed since
  // the last time we ran this.
  system_timer.DisableTimer();
   14c98:	f7ff f8ae 	bl	13df8 <SystemTimer::DisableTimer()>
  system_timer.SetTickFrequency(config::kRtosFrequency);
   14c9c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   14ca0:	480c      	ldr	r0, [pc, #48]	; (14cd4 <LowLevelInit()+0x94>)
   14ca2:	f7ff f949 	bl	13f38 <SystemTimer::SetTickFrequency(unsigned long)>
  system_timer.StartTimer();
   14ca6:	480b      	ldr	r0, [pc, #44]	; (14cd4 <LowLevelInit()+0x94>)
   14ca8:	f7ff f8f8 	bl	13e9c <SystemTimer::StartTimer()>
  // Set timer0 to 1 MHz (1,000,000 Hz) so that the timer increments every 1
  // micro second.
  timer0.Initialize(1'000'000);
   14cac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14cb0:	4a0d      	ldr	r2, [pc, #52]	; (14ce8 <LowLevelInit()+0xa8>)
   14cb2:	490e      	ldr	r1, [pc, #56]	; (14cec <LowLevelInit()+0xac>)
   14cb4:	480e      	ldr	r0, [pc, #56]	; (14cf0 <LowLevelInit()+0xb0>)
   14cb6:	f7ff f9b1 	bl	1401c <Timer::Initialize(unsigned long, void (*)(), long)>
  SetUptimeFunction(Lpc40xxUptime);
   14cba:	480e      	ldr	r0, [pc, #56]	; (14cf4 <LowLevelInit()+0xb4>)
   14cbc:	f7ff f884 	bl	13dc8 <SetUptimeFunction(unsigned long long (*)())>
  // Set UART0 baudrate, which is required for printf and scanf to work properly
  uart0.Initialize(config::kBaudRate);
   14cc0:	f44f 4116 	mov.w	r1, #38400	; 0x9600
   14cc4:	480c      	ldr	r0, [pc, #48]	; (14cf8 <LowLevelInit()+0xb8>)
   14cc6:	f7ff fb5b 	bl	14380 <Uart::Initialize(unsigned long)>
}
   14cca:	bf00      	nop
   14ccc:	b003      	add	sp, #12
   14cce:	f85d fb04 	ldr.w	pc, [sp], #4
   14cd2:	bf00      	nop
   14cd4:	100007dc 	.word	0x100007dc
   14cd8:	0001b2bc 	.word	0x0001b2bc
   14cdc:	0001b1c4 	.word	0x0001b1c4
   14ce0:	0001b11c 	.word	0x0001b11c
   14ce4:	100007e4 	.word	0x100007e4
   14ce8:	00013ffd 	.word	0x00013ffd
   14cec:	000f4240 	.word	0x000f4240
   14cf0:	100007e8 	.word	0x100007e8
   14cf4:	00014b35 	.word	0x00014b35
   14cf8:	100007c8 	.word	0x100007c8

00014cfc <SystemInit>:

void SystemInit()
{
   14cfc:	b508      	push	{r3, lr}
  // Transfer data section values from flash to RAM
  InitDataSection();
   14cfe:	f7fb fa05 	bl	1010c <InitDataSection()>
  // Clear BSS section of RAM
  // This is required because the nano implementation of the standard C/C++
  // libraries assumes that the BSS section is initialized to 0.
  InitBssSection();
   14d02:	f7fb fa4b 	bl	1019c <InitBssSection()>
  // Enable FPU (F.loating P.oint U.nit)
  // System will crash if floating point operations occur without
  // Initializing the FPU.
  InitFpu();
   14d06:	f7fb fa79 	bl	101fc <InitFpu()>
  // Initialisation C++ libraries
  __libc_init_array();
   14d0a:	f004 fda7 	bl	1985c <__libc_init_array>
  // Run LowLevel System Initialization
  LowLevelInit();
   14d0e:	f7ff ff97 	bl	14c40 <LowLevelInit()>
}
   14d12:	bf00      	nop
   14d14:	bd08      	pop	{r3, pc}
   14d16:	Address 0x0000000000014d16 is out of bounds.


00014d18 <ResetIsr>:
// Sets up a simple runtime environment and initializes the C/C++ library.

extern "C"
{
  void ResetIsr(void)
  {
   14d18:	b580      	push	{r7, lr}
   14d1a:	b084      	sub	sp, #16
   14d1c:	af00      	add	r7, sp, #0
    // The Hyperload bootloader takes up stack space to execute. The Hyperload
    // bootloader function launches this ISR manually, but it never returns thus
    // it never cleans up the memory it uses. To get that memory back, we have
    // to manually move the stack pointers back to the top of stack.
    const uint32_t kTopOfStack = reinterpret_cast<intptr_t>(&StackTop);
   14d1e:	4b09      	ldr	r3, [pc, #36]	; (14d44 <ResetIsr+0x2c>)
   14d20:	60fb      	str	r3, [r7, #12]
   14d22:	68fb      	ldr	r3, [r7, #12]
   14d24:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
   14d26:	683b      	ldr	r3, [r7, #0]
   14d28:	f383 8809 	msr	PSP, r3
   14d2c:	68fb      	ldr	r3, [r7, #12]
   14d2e:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
   14d30:	687b      	ldr	r3, [r7, #4]
   14d32:	f383 8808 	msr	MSP, r3
    __set_PSP(kTopOfStack);
    __set_MSP(kTopOfStack);

    SystemInit();
   14d36:	f7ff ffe1 	bl	14cfc <SystemInit>
// #pragma ignored "-Wpedantic" to suppress main function call warning
#pragma GCC diagnostic push ignored "-Wpedantic"
    [[maybe_unused]] int32_t result = main();
   14d3a:	f7fe fe0b 	bl	13954 <main>
   14d3e:	60b8      	str	r0, [r7, #8]
   14d40:	e7fe      	b.n	14d40 <ResetIsr+0x28>
   14d42:	bf00      	nop
   14d44:	10010000 	.word	0x10010000

00014d48 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()>:
  static void TimerHandler()
   14d48:	b510      	push	{r4, lr}
   14d4a:	4674      	mov	r4, lr
   14d4c:	4623      	mov	r3, r4
   14d4e:	4619      	mov	r1, r3
   14d50:	480a      	ldr	r0, [pc, #40]	; (14d7c <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   14d52:	f000 fc99 	bl	15688 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14d56:	2000      	movs	r0, #0
   14d58:	f7ff f938 	bl	13fcc <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14d5c:	4603      	mov	r3, r0
   14d5e:	461a      	mov	r2, r3
   14d60:	4b07      	ldr	r3, [pc, #28]	; (14d80 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x38>)
   14d62:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14d66:	4798      	blx	r3
    ClearInterrupts<port>();
   14d68:	f000 f90e 	bl	14f88 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>
   14d6c:	4623      	mov	r3, r4
   14d6e:	4619      	mov	r1, r3
   14d70:	4802      	ldr	r0, [pc, #8]	; (14d7c <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   14d72:	f000 fc9d 	bl	156b0 <__cyg_profile_func_exit>
  }
   14d76:	bf00      	nop
   14d78:	bd10      	pop	{r4, pc}
   14d7a:	bf00      	nop
   14d7c:	00014d49 	.word	0x00014d49
   14d80:	10001298 	.word	0x10001298

00014d84 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()>:
  static void TimerHandler()
   14d84:	b510      	push	{r4, lr}
   14d86:	4674      	mov	r4, lr
   14d88:	4623      	mov	r3, r4
   14d8a:	4619      	mov	r1, r3
   14d8c:	480a      	ldr	r0, [pc, #40]	; (14db8 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   14d8e:	f000 fc7b 	bl	15688 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14d92:	2001      	movs	r0, #1
   14d94:	f7ff f91a 	bl	13fcc <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14d98:	4603      	mov	r3, r0
   14d9a:	461a      	mov	r2, r3
   14d9c:	4b07      	ldr	r3, [pc, #28]	; (14dbc <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x38>)
   14d9e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14da2:	4798      	blx	r3
    ClearInterrupts<port>();
   14da4:	f000 f940 	bl	15028 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>
   14da8:	4623      	mov	r3, r4
   14daa:	4619      	mov	r1, r3
   14dac:	4802      	ldr	r0, [pc, #8]	; (14db8 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   14dae:	f000 fc7f 	bl	156b0 <__cyg_profile_func_exit>
  }
   14db2:	bf00      	nop
   14db4:	bd10      	pop	{r4, pc}
   14db6:	bf00      	nop
   14db8:	00014d85 	.word	0x00014d85
   14dbc:	10001298 	.word	0x10001298

00014dc0 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()>:
  static void TimerHandler()
   14dc0:	b510      	push	{r4, lr}
   14dc2:	4674      	mov	r4, lr
   14dc4:	4623      	mov	r3, r4
   14dc6:	4619      	mov	r1, r3
   14dc8:	480a      	ldr	r0, [pc, #40]	; (14df4 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   14dca:	f000 fc5d 	bl	15688 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14dce:	2002      	movs	r0, #2
   14dd0:	f7ff f8fc 	bl	13fcc <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14dd4:	4603      	mov	r3, r0
   14dd6:	461a      	mov	r2, r3
   14dd8:	4b07      	ldr	r3, [pc, #28]	; (14df8 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x38>)
   14dda:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14dde:	4798      	blx	r3
    ClearInterrupts<port>();
   14de0:	f000 f972 	bl	150c8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>
   14de4:	4623      	mov	r3, r4
   14de6:	4619      	mov	r1, r3
   14de8:	4802      	ldr	r0, [pc, #8]	; (14df4 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   14dea:	f000 fc61 	bl	156b0 <__cyg_profile_func_exit>
  }
   14dee:	bf00      	nop
   14df0:	bd10      	pop	{r4, pc}
   14df2:	bf00      	nop
   14df4:	00014dc1 	.word	0x00014dc1
   14df8:	10001298 	.word	0x10001298

00014dfc <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()>:
  static void TimerHandler()
   14dfc:	b510      	push	{r4, lr}
   14dfe:	4674      	mov	r4, lr
   14e00:	4623      	mov	r3, r4
   14e02:	4619      	mov	r1, r3
   14e04:	480a      	ldr	r0, [pc, #40]	; (14e30 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   14e06:	f000 fc3f 	bl	15688 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14e0a:	2003      	movs	r0, #3
   14e0c:	f7ff f8de 	bl	13fcc <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14e10:	4603      	mov	r3, r0
   14e12:	461a      	mov	r2, r3
   14e14:	4b07      	ldr	r3, [pc, #28]	; (14e34 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x38>)
   14e16:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14e1a:	4798      	blx	r3
    ClearInterrupts<port>();
   14e1c:	f000 f9a4 	bl	15168 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>
   14e20:	4623      	mov	r3, r4
   14e22:	4619      	mov	r1, r3
   14e24:	4802      	ldr	r0, [pc, #8]	; (14e30 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   14e26:	f000 fc43 	bl	156b0 <__cyg_profile_func_exit>
  }
   14e2a:	bf00      	nop
   14e2c:	bd10      	pop	{r4, pc}
   14e2e:	bf00      	nop
   14e30:	00014dfd 	.word	0x00014dfd
   14e34:	10001298 	.word	0x10001298

00014e38 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   14e38:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   14e3c:	b088      	sub	sp, #32
   14e3e:	4675      	mov	r5, lr
   14e40:	e9cd 0102 	strd	r0, r1, [sp, #8]
   14e44:	9201      	str	r2, [sp, #4]
   14e46:	462b      	mov	r3, r5
   14e48:	4619      	mov	r1, r3
   14e4a:	4824      	ldr	r0, [pc, #144]	; (14edc <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   14e4c:	f000 fc1c 	bl	15688 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   14e50:	f04f 0300 	mov.w	r3, #0
   14e54:	f04f 0400 	mov.w	r4, #0
   14e58:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   14e5c:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   14e60:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   14e64:	bf08      	it	eq
   14e66:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   14e6a:	d106      	bne.n	14e7a <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   14e6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14e70:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   14e74:	e9cd 3406 	strd	r3, r4, [sp, #24]
   14e78:	e00b      	b.n	14e92 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   14e7a:	f7fb fe45 	bl	10b08 <Milliseconds()>
   14e7e:	460a      	mov	r2, r1
   14e80:	4601      	mov	r1, r0
   14e82:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   14e86:	eb13 0b01 	adds.w	fp, r3, r1
   14e8a:	eb44 0c02 	adc.w	ip, r4, r2
   14e8e:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   14e92:	2301      	movs	r3, #1
   14e94:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   14e96:	f7fb fe37 	bl	10b08 <Milliseconds()>
   14e9a:	460a      	mov	r2, r1
   14e9c:	4601      	mov	r1, r0
   14e9e:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   14ea2:	42a2      	cmp	r2, r4
   14ea4:	bf08      	it	eq
   14ea6:	4299      	cmpeq	r1, r3
   14ea8:	bf34      	ite	cc
   14eaa:	2301      	movcc	r3, #1
   14eac:	2300      	movcs	r3, #0
   14eae:	b2db      	uxtb	r3, r3
   14eb0:	2b00      	cmp	r3, #0
   14eb2:	d008      	beq.n	14ec6 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x8e>
    if (is_done())
   14eb4:	ab01      	add	r3, sp, #4
   14eb6:	4618      	mov	r0, r3
   14eb8:	f7ff fad4 	bl	14464 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   14ebc:	4603      	mov	r3, r0
   14ebe:	2b00      	cmp	r3, #0
   14ec0:	d0e9      	beq.n	14e96 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   14ec2:	2300      	movs	r3, #0
   14ec4:	9305      	str	r3, [sp, #20]
  return status;
   14ec6:	9c05      	ldr	r4, [sp, #20]
   14ec8:	462b      	mov	r3, r5
   14eca:	4619      	mov	r1, r3
   14ecc:	4803      	ldr	r0, [pc, #12]	; (14edc <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   14ece:	f000 fbef 	bl	156b0 <__cyg_profile_func_exit>
   14ed2:	4623      	mov	r3, r4
}
   14ed4:	4618      	mov	r0, r3
   14ed6:	b008      	add	sp, #32
   14ed8:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   14edc:	00014e39 	.word	0x00014e39

00014ee0 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   14ee0:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   14ee4:	b088      	sub	sp, #32
   14ee6:	4675      	mov	r5, lr
   14ee8:	e9cd 0102 	strd	r0, r1, [sp, #8]
   14eec:	9201      	str	r2, [sp, #4]
   14eee:	462b      	mov	r3, r5
   14ef0:	4619      	mov	r1, r3
   14ef2:	4824      	ldr	r0, [pc, #144]	; (14f84 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   14ef4:	f000 fbc8 	bl	15688 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   14ef8:	f04f 0300 	mov.w	r3, #0
   14efc:	f04f 0400 	mov.w	r4, #0
   14f00:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   14f04:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   14f08:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   14f0c:	bf08      	it	eq
   14f0e:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   14f12:	d106      	bne.n	14f22 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   14f14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14f18:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   14f1c:	e9cd 3406 	strd	r3, r4, [sp, #24]
   14f20:	e00b      	b.n	14f3a <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   14f22:	f7fb fdf1 	bl	10b08 <Milliseconds()>
   14f26:	460a      	mov	r2, r1
   14f28:	4601      	mov	r1, r0
   14f2a:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   14f2e:	eb13 0b01 	adds.w	fp, r3, r1
   14f32:	eb44 0c02 	adc.w	ip, r4, r2
   14f36:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   14f3a:	2301      	movs	r3, #1
   14f3c:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   14f3e:	f7fb fde3 	bl	10b08 <Milliseconds()>
   14f42:	460a      	mov	r2, r1
   14f44:	4601      	mov	r1, r0
   14f46:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   14f4a:	42a2      	cmp	r2, r4
   14f4c:	bf08      	it	eq
   14f4e:	4299      	cmpeq	r1, r3
   14f50:	bf34      	ite	cc
   14f52:	2301      	movcc	r3, #1
   14f54:	2300      	movcs	r3, #0
   14f56:	b2db      	uxtb	r3, r3
   14f58:	2b00      	cmp	r3, #0
   14f5a:	d008      	beq.n	14f6e <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x8e>
    if (is_done())
   14f5c:	ab01      	add	r3, sp, #4
   14f5e:	4618      	mov	r0, r3
   14f60:	f7ff fb1a 	bl	14598 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   14f64:	4603      	mov	r3, r0
   14f66:	2b00      	cmp	r3, #0
   14f68:	d0e9      	beq.n	14f3e <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   14f6a:	2300      	movs	r3, #0
   14f6c:	9305      	str	r3, [sp, #20]
  return status;
   14f6e:	9c05      	ldr	r4, [sp, #20]
   14f70:	462b      	mov	r3, r5
   14f72:	4619      	mov	r1, r3
   14f74:	4803      	ldr	r0, [pc, #12]	; (14f84 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   14f76:	f000 fb9b 	bl	156b0 <__cyg_profile_func_exit>
   14f7a:	4623      	mov	r3, r4
}
   14f7c:	4618      	mov	r0, r3
   14f7e:	b008      	add	sp, #32
   14f80:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   14f84:	00014ee1 	.word	0x00014ee1

00014f88 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>:
  static void ClearInterrupts()
   14f88:	b510      	push	{r4, lr}
   14f8a:	b082      	sub	sp, #8
   14f8c:	4674      	mov	r4, lr
   14f8e:	4623      	mov	r3, r4
   14f90:	4619      	mov	r1, r3
   14f92:	4823      	ldr	r0, [pc, #140]	; (15020 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   14f94:	f000 fb78 	bl	15688 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14f98:	2300      	movs	r3, #0
   14f9a:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14f9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fa2:	4a20      	ldr	r2, [pc, #128]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14fa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fa8:	681a      	ldr	r2, [r3, #0]
   14faa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fae:	491d      	ldr	r1, [pc, #116]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14fb0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14fb4:	f042 0201 	orr.w	r2, r2, #1
   14fb8:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14fba:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fbe:	4a19      	ldr	r2, [pc, #100]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14fc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fc4:	681a      	ldr	r2, [r3, #0]
   14fc6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fca:	4916      	ldr	r1, [pc, #88]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14fcc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14fd0:	f042 0202 	orr.w	r2, r2, #2
   14fd4:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14fd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fda:	4a12      	ldr	r2, [pc, #72]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14fdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fe0:	681a      	ldr	r2, [r3, #0]
   14fe2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14fe6:	490f      	ldr	r1, [pc, #60]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14fe8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14fec:	f042 0204 	orr.w	r2, r2, #4
   14ff0:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14ff2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14ff6:	4a0b      	ldr	r2, [pc, #44]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14ff8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ffc:	681a      	ldr	r2, [r3, #0]
   14ffe:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15002:	4908      	ldr	r1, [pc, #32]	; (15024 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   15004:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15008:	f042 0208 	orr.w	r2, r2, #8
   1500c:	601a      	str	r2, [r3, #0]
   1500e:	4623      	mov	r3, r4
   15010:	4619      	mov	r1, r3
   15012:	4803      	ldr	r0, [pc, #12]	; (15020 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   15014:	f000 fb4c 	bl	156b0 <__cyg_profile_func_exit>
  }
   15018:	bf00      	nop
   1501a:	b002      	add	sp, #8
   1501c:	bd10      	pop	{r4, pc}
   1501e:	bf00      	nop
   15020:	00014f89 	.word	0x00014f89
   15024:	10000768 	.word	0x10000768

00015028 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>:
  static void ClearInterrupts()
   15028:	b510      	push	{r4, lr}
   1502a:	b082      	sub	sp, #8
   1502c:	4674      	mov	r4, lr
   1502e:	4623      	mov	r3, r4
   15030:	4619      	mov	r1, r3
   15032:	4823      	ldr	r0, [pc, #140]	; (150c0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   15034:	f000 fb28 	bl	15688 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   15038:	2301      	movs	r3, #1
   1503a:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   1503e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15042:	4a20      	ldr	r2, [pc, #128]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   15044:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15048:	681a      	ldr	r2, [r3, #0]
   1504a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1504e:	491d      	ldr	r1, [pc, #116]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   15050:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15054:	f042 0201 	orr.w	r2, r2, #1
   15058:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   1505a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1505e:	4a19      	ldr	r2, [pc, #100]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   15060:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15064:	681a      	ldr	r2, [r3, #0]
   15066:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1506a:	4916      	ldr	r1, [pc, #88]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   1506c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15070:	f042 0202 	orr.w	r2, r2, #2
   15074:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   15076:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1507a:	4a12      	ldr	r2, [pc, #72]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   1507c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15080:	681a      	ldr	r2, [r3, #0]
   15082:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15086:	490f      	ldr	r1, [pc, #60]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   15088:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   1508c:	f042 0204 	orr.w	r2, r2, #4
   15090:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   15092:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15096:	4a0b      	ldr	r2, [pc, #44]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   15098:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1509c:	681a      	ldr	r2, [r3, #0]
   1509e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   150a2:	4908      	ldr	r1, [pc, #32]	; (150c4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   150a4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   150a8:	f042 0208 	orr.w	r2, r2, #8
   150ac:	601a      	str	r2, [r3, #0]
   150ae:	4623      	mov	r3, r4
   150b0:	4619      	mov	r1, r3
   150b2:	4803      	ldr	r0, [pc, #12]	; (150c0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   150b4:	f000 fafc 	bl	156b0 <__cyg_profile_func_exit>
  }
   150b8:	bf00      	nop
   150ba:	b002      	add	sp, #8
   150bc:	bd10      	pop	{r4, pc}
   150be:	bf00      	nop
   150c0:	00015029 	.word	0x00015029
   150c4:	10000768 	.word	0x10000768

000150c8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>:
  static void ClearInterrupts()
   150c8:	b510      	push	{r4, lr}
   150ca:	b082      	sub	sp, #8
   150cc:	4674      	mov	r4, lr
   150ce:	4623      	mov	r3, r4
   150d0:	4619      	mov	r1, r3
   150d2:	4823      	ldr	r0, [pc, #140]	; (15160 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   150d4:	f000 fad8 	bl	15688 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   150d8:	2302      	movs	r3, #2
   150da:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   150de:	f89d 3007 	ldrb.w	r3, [sp, #7]
   150e2:	4a20      	ldr	r2, [pc, #128]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   150e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   150e8:	681a      	ldr	r2, [r3, #0]
   150ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
   150ee:	491d      	ldr	r1, [pc, #116]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   150f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   150f4:	f042 0201 	orr.w	r2, r2, #1
   150f8:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   150fa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   150fe:	4a19      	ldr	r2, [pc, #100]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   15100:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15104:	681a      	ldr	r2, [r3, #0]
   15106:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1510a:	4916      	ldr	r1, [pc, #88]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   1510c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15110:	f042 0202 	orr.w	r2, r2, #2
   15114:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   15116:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1511a:	4a12      	ldr	r2, [pc, #72]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   1511c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15120:	681a      	ldr	r2, [r3, #0]
   15122:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15126:	490f      	ldr	r1, [pc, #60]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   15128:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   1512c:	f042 0204 	orr.w	r2, r2, #4
   15130:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   15132:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15136:	4a0b      	ldr	r2, [pc, #44]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   15138:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1513c:	681a      	ldr	r2, [r3, #0]
   1513e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15142:	4908      	ldr	r1, [pc, #32]	; (15164 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   15144:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15148:	f042 0208 	orr.w	r2, r2, #8
   1514c:	601a      	str	r2, [r3, #0]
   1514e:	4623      	mov	r3, r4
   15150:	4619      	mov	r1, r3
   15152:	4803      	ldr	r0, [pc, #12]	; (15160 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   15154:	f000 faac 	bl	156b0 <__cyg_profile_func_exit>
  }
   15158:	bf00      	nop
   1515a:	b002      	add	sp, #8
   1515c:	bd10      	pop	{r4, pc}
   1515e:	bf00      	nop
   15160:	000150c9 	.word	0x000150c9
   15164:	10000768 	.word	0x10000768

00015168 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>:
  static void ClearInterrupts()
   15168:	b510      	push	{r4, lr}
   1516a:	b082      	sub	sp, #8
   1516c:	4674      	mov	r4, lr
   1516e:	4623      	mov	r3, r4
   15170:	4619      	mov	r1, r3
   15172:	4823      	ldr	r0, [pc, #140]	; (15200 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   15174:	f000 fa88 	bl	15688 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   15178:	2303      	movs	r3, #3
   1517a:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   1517e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   15182:	4a20      	ldr	r2, [pc, #128]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   15184:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15188:	681a      	ldr	r2, [r3, #0]
   1518a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1518e:	491d      	ldr	r1, [pc, #116]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   15190:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   15194:	f042 0201 	orr.w	r2, r2, #1
   15198:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   1519a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1519e:	4a19      	ldr	r2, [pc, #100]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   151a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   151a4:	681a      	ldr	r2, [r3, #0]
   151a6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   151aa:	4916      	ldr	r1, [pc, #88]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   151ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   151b0:	f042 0202 	orr.w	r2, r2, #2
   151b4:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   151b6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   151ba:	4a12      	ldr	r2, [pc, #72]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   151bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   151c0:	681a      	ldr	r2, [r3, #0]
   151c2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   151c6:	490f      	ldr	r1, [pc, #60]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   151c8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   151cc:	f042 0204 	orr.w	r2, r2, #4
   151d0:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   151d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   151d6:	4a0b      	ldr	r2, [pc, #44]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   151d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   151dc:	681a      	ldr	r2, [r3, #0]
   151de:	f89d 3007 	ldrb.w	r3, [sp, #7]
   151e2:	4908      	ldr	r1, [pc, #32]	; (15204 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   151e4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   151e8:	f042 0208 	orr.w	r2, r2, #8
   151ec:	601a      	str	r2, [r3, #0]
   151ee:	4623      	mov	r3, r4
   151f0:	4619      	mov	r1, r3
   151f2:	4803      	ldr	r0, [pc, #12]	; (15200 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   151f4:	f000 fa5c 	bl	156b0 <__cyg_profile_func_exit>
  }
   151f8:	bf00      	nop
   151fa:	b002      	add	sp, #8
   151fc:	bd10      	pop	{r4, pc}
   151fe:	bf00      	nop
   15200:	00015169 	.word	0x00015169
   15204:	10000768 	.word	0x10000768

00015208 <__static_initialization_and_destruction_0(int, int)>:
#pragma GCC diagnostic pop
    // main() shouldn't return, but if it does, we'll just enter an infinite
    // loop
    Halt();
  }
}
   15208:	b082      	sub	sp, #8
   1520a:	9001      	str	r0, [sp, #4]
   1520c:	9100      	str	r1, [sp, #0]
   1520e:	9b01      	ldr	r3, [sp, #4]
   15210:	2b01      	cmp	r3, #1
   15212:	d15d      	bne.n	152d0 <__static_initialization_and_destruction_0(int, int)+0xc8>
   15214:	9b00      	ldr	r3, [sp, #0]
   15216:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1521a:	4293      	cmp	r3, r2
   1521c:	d158      	bne.n	152d0 <__static_initialization_and_destruction_0(int, int)+0xc8>
  inline static volatile uint32_t * match[4][4] = {
   1521e:	4b2e      	ldr	r3, [pc, #184]	; (152d8 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   15220:	681b      	ldr	r3, [r3, #0]
   15222:	f003 0301 	and.w	r3, r3, #1
   15226:	2b00      	cmp	r3, #0
   15228:	d152      	bne.n	152d0 <__static_initialization_and_destruction_0(int, int)+0xc8>
   1522a:	4b2b      	ldr	r3, [pc, #172]	; (152d8 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   1522c:	2201      	movs	r2, #1
   1522e:	601a      	str	r2, [r3, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   15230:	4b2a      	ldr	r3, [pc, #168]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   15232:	681b      	ldr	r3, [r3, #0]
   15234:	3318      	adds	r3, #24
  };
   15236:	4a2a      	ldr	r2, [pc, #168]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   15238:	6013      	str	r3, [r2, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   1523a:	4b28      	ldr	r3, [pc, #160]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1523c:	681b      	ldr	r3, [r3, #0]
   1523e:	331c      	adds	r3, #28
  };
   15240:	4a27      	ldr	r2, [pc, #156]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   15242:	6053      	str	r3, [r2, #4]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   15244:	4b25      	ldr	r3, [pc, #148]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   15246:	681b      	ldr	r3, [r3, #0]
   15248:	3320      	adds	r3, #32
  };
   1524a:	4a25      	ldr	r2, [pc, #148]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1524c:	6093      	str	r3, [r2, #8]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   1524e:	4b23      	ldr	r3, [pc, #140]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   15250:	681b      	ldr	r3, [r3, #0]
   15252:	3324      	adds	r3, #36	; 0x24
  };
   15254:	4a22      	ldr	r2, [pc, #136]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   15256:	60d3      	str	r3, [r2, #12]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   15258:	4b20      	ldr	r3, [pc, #128]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1525a:	685b      	ldr	r3, [r3, #4]
   1525c:	3318      	adds	r3, #24
  };
   1525e:	4a20      	ldr	r2, [pc, #128]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   15260:	6113      	str	r3, [r2, #16]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   15262:	4b1e      	ldr	r3, [pc, #120]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   15264:	685b      	ldr	r3, [r3, #4]
   15266:	331c      	adds	r3, #28
  };
   15268:	4a1d      	ldr	r2, [pc, #116]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1526a:	6153      	str	r3, [r2, #20]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   1526c:	4b1b      	ldr	r3, [pc, #108]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1526e:	685b      	ldr	r3, [r3, #4]
   15270:	3320      	adds	r3, #32
  };
   15272:	4a1b      	ldr	r2, [pc, #108]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   15274:	6193      	str	r3, [r2, #24]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   15276:	4b19      	ldr	r3, [pc, #100]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   15278:	685b      	ldr	r3, [r3, #4]
   1527a:	3324      	adds	r3, #36	; 0x24
  };
   1527c:	4a18      	ldr	r2, [pc, #96]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1527e:	61d3      	str	r3, [r2, #28]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   15280:	4b16      	ldr	r3, [pc, #88]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   15282:	689b      	ldr	r3, [r3, #8]
   15284:	3318      	adds	r3, #24
  };
   15286:	4a16      	ldr	r2, [pc, #88]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   15288:	6213      	str	r3, [r2, #32]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   1528a:	4b14      	ldr	r3, [pc, #80]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1528c:	689b      	ldr	r3, [r3, #8]
   1528e:	331c      	adds	r3, #28
  };
   15290:	4a13      	ldr	r2, [pc, #76]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   15292:	6253      	str	r3, [r2, #36]	; 0x24
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   15294:	4b11      	ldr	r3, [pc, #68]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   15296:	689b      	ldr	r3, [r3, #8]
   15298:	3320      	adds	r3, #32
  };
   1529a:	4a11      	ldr	r2, [pc, #68]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1529c:	6293      	str	r3, [r2, #40]	; 0x28
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   1529e:	4b0f      	ldr	r3, [pc, #60]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   152a0:	689b      	ldr	r3, [r3, #8]
   152a2:	3324      	adds	r3, #36	; 0x24
  };
   152a4:	4a0e      	ldr	r2, [pc, #56]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   152a6:	62d3      	str	r3, [r2, #44]	; 0x2c
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   152a8:	4b0c      	ldr	r3, [pc, #48]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   152aa:	68db      	ldr	r3, [r3, #12]
   152ac:	3318      	adds	r3, #24
  };
   152ae:	4a0c      	ldr	r2, [pc, #48]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   152b0:	6313      	str	r3, [r2, #48]	; 0x30
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   152b2:	4b0a      	ldr	r3, [pc, #40]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   152b4:	68db      	ldr	r3, [r3, #12]
   152b6:	331c      	adds	r3, #28
  };
   152b8:	4a09      	ldr	r2, [pc, #36]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   152ba:	6353      	str	r3, [r2, #52]	; 0x34
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   152bc:	4b07      	ldr	r3, [pc, #28]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   152be:	68db      	ldr	r3, [r3, #12]
   152c0:	3320      	adds	r3, #32
  };
   152c2:	4a07      	ldr	r2, [pc, #28]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   152c4:	6393      	str	r3, [r2, #56]	; 0x38
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   152c6:	4b05      	ldr	r3, [pc, #20]	; (152dc <__static_initialization_and_destruction_0(int, int)+0xd4>)
   152c8:	68db      	ldr	r3, [r3, #12]
   152ca:	3324      	adds	r3, #36	; 0x24
  };
   152cc:	4a04      	ldr	r2, [pc, #16]	; (152e0 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   152ce:	63d3      	str	r3, [r2, #60]	; 0x3c
   152d0:	bf00      	nop
   152d2:	b002      	add	sp, #8
   152d4:	4770      	bx	lr
   152d6:	bf00      	nop
   152d8:	10001448 	.word	0x10001448
   152dc:	10000768 	.word	0x10000768
   152e0:	10001258 	.word	0x10001258

000152e4 <_GLOBAL__sub_I_UptimeRTOS>:
   152e4:	b508      	push	{r3, lr}
   152e6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   152ea:	2001      	movs	r0, #1
   152ec:	f7ff ff8c 	bl	15208 <__static_initialization_and_destruction_0(int, int)>
   152f0:	bd08      	pop	{r3, pc}
   152f2:	Address 0x00000000000152f2 is out of bounds.


000152f4 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   152f4:	b082      	sub	sp, #8
   152f6:	4603      	mov	r3, r0
   152f8:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   152fc:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   15300:	f003 021f 	and.w	r2, r3, #31
   15304:	4905      	ldr	r1, [pc, #20]	; (1531c <NVIC_EnableIRQ+0x28>)
   15306:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   1530a:	095b      	lsrs	r3, r3, #5
   1530c:	2001      	movs	r0, #1
   1530e:	fa00 f202 	lsl.w	r2, r0, r2
   15312:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15316:	bf00      	nop
   15318:	b002      	add	sp, #8
   1531a:	4770      	bx	lr
   1531c:	e000e100 	.word	0xe000e100

00015320 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   15320:	b082      	sub	sp, #8
   15322:	4603      	mov	r3, r0
   15324:	9100      	str	r1, [sp, #0]
   15326:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) < 0)
   1532a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   1532e:	2b00      	cmp	r3, #0
   15330:	da0c      	bge.n	1534c <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   15332:	9b00      	ldr	r3, [sp, #0]
   15334:	b2da      	uxtb	r2, r3
   15336:	490d      	ldr	r1, [pc, #52]	; (1536c <NVIC_SetPriority+0x4c>)
   15338:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   1533c:	f003 030f 	and.w	r3, r3, #15
   15340:	3b04      	subs	r3, #4
   15342:	0152      	lsls	r2, r2, #5
   15344:	b2d2      	uxtb	r2, r2
   15346:	440b      	add	r3, r1
   15348:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   1534a:	e00b      	b.n	15364 <NVIC_SetPriority+0x44>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1534c:	9b00      	ldr	r3, [sp, #0]
   1534e:	b2db      	uxtb	r3, r3
   15350:	4a07      	ldr	r2, [pc, #28]	; (15370 <NVIC_SetPriority+0x50>)
   15352:	f99d 1007 	ldrsb.w	r1, [sp, #7]
   15356:	4608      	mov	r0, r1
   15358:	015b      	lsls	r3, r3, #5
   1535a:	b2d9      	uxtb	r1, r3
   1535c:	1813      	adds	r3, r2, r0
   1535e:	460a      	mov	r2, r1
   15360:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   15364:	bf00      	nop
   15366:	b002      	add	sp, #8
   15368:	4770      	bx	lr
   1536a:	bf00      	nop
   1536c:	e000ed00 	.word	0xe000ed00
   15370:	e000e100 	.word	0xe000e100

00015374 <InterruptLookupHandler>:
{
   15374:	b500      	push	{lr}
   15376:	b085      	sub	sp, #20
  uint8_t active_isr = (SCB->ICSR & 0xFF);
   15378:	4b12      	ldr	r3, [pc, #72]	; (153c4 <InterruptLookupHandler+0x50>)
   1537a:	685b      	ldr	r3, [r3, #4]
   1537c:	f88d 300f 	strb.w	r3, [sp, #15]
  IsrPointer isr     = dynamic_isr_vector_table[active_isr];
   15380:	f89d 300f 	ldrb.w	r3, [sp, #15]
   15384:	4a10      	ldr	r2, [pc, #64]	; (153c8 <InterruptLookupHandler+0x54>)
   15386:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1538a:	9302      	str	r3, [sp, #8]
  SJ2_ASSERT_FATAL(isr != InterruptLookupHandler,
   1538c:	9b02      	ldr	r3, [sp, #8]
   1538e:	4a0f      	ldr	r2, [pc, #60]	; (153cc <InterruptLookupHandler+0x58>)
   15390:	4293      	cmp	r3, r2
   15392:	d110      	bne.n	153b6 <InterruptLookupHandler+0x42>
   15394:	f89d 300f 	ldrb.w	r3, [sp, #15]
   15398:	9300      	str	r3, [sp, #0]
   1539a:	23dd      	movs	r3, #221	; 0xdd
   1539c:	4a0c      	ldr	r2, [pc, #48]	; (153d0 <InterruptLookupHandler+0x5c>)
   1539e:	490d      	ldr	r1, [pc, #52]	; (153d4 <InterruptLookupHandler+0x60>)
   153a0:	480d      	ldr	r0, [pc, #52]	; (153d8 <InterruptLookupHandler+0x64>)
   153a2:	f002 fd55 	bl	17e50 <printf>
   153a6:	480d      	ldr	r0, [pc, #52]	; (153dc <InterruptLookupHandler+0x68>)
   153a8:	f000 f93e 	bl	15628 <puts>
   153ac:	2100      	movs	r1, #0
   153ae:	2001      	movs	r0, #1
   153b0:	f7fb fb12 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   153b4:	e7fe      	b.n	153b4 <InterruptLookupHandler+0x40>
  isr();
   153b6:	9b02      	ldr	r3, [sp, #8]
   153b8:	4798      	blx	r3
}
   153ba:	bf00      	nop
   153bc:	b005      	add	sp, #20
   153be:	f85d fb04 	ldr.w	pc, [sp], #4
   153c2:	bf00      	nop
   153c4:	e000ed00 	.word	0xe000ed00
   153c8:	100007f4 	.word	0x100007f4
   153cc:	00015375 	.word	0x00015375
   153d0:	0001b538 	.word	0x0001b538
   153d4:	0001b528 	.word	0x0001b528
   153d8:	0001b3cc 	.word	0x0001b3cc
   153dc:	0001b478 	.word	0x0001b478

000153e0 <RegisterIsr(IRQn, void (*)(), bool, long)>:
{
   153e0:	b500      	push	{lr}
   153e2:	b085      	sub	sp, #20
   153e4:	9102      	str	r1, [sp, #8]
   153e6:	9301      	str	r3, [sp, #4]
   153e8:	4603      	mov	r3, r0
   153ea:	f88d 300f 	strb.w	r3, [sp, #15]
   153ee:	4613      	mov	r3, r2
   153f0:	f88d 300e 	strb.w	r3, [sp, #14]
  dynamic_isr_vector_table[irq + kIrqOffset] = isr;
   153f4:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   153f8:	3310      	adds	r3, #16
   153fa:	490f      	ldr	r1, [pc, #60]	; (15438 <RegisterIsr(IRQn, void (*)(), bool, long)+0x58>)
   153fc:	9a02      	ldr	r2, [sp, #8]
   153fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  if (enable_interrupt && irq >= 0)
   15402:	f89d 300e 	ldrb.w	r3, [sp, #14]
   15406:	2b00      	cmp	r3, #0
   15408:	d008      	beq.n	1541c <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
   1540a:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   1540e:	2b00      	cmp	r3, #0
   15410:	db04      	blt.n	1541c <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
    NVIC_EnableIRQ(irq);
   15412:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   15416:	4618      	mov	r0, r3
   15418:	f7ff ff6c 	bl	152f4 <NVIC_EnableIRQ>
  if (priority > -1)
   1541c:	9b01      	ldr	r3, [sp, #4]
   1541e:	2b00      	cmp	r3, #0
   15420:	db06      	blt.n	15430 <RegisterIsr(IRQn, void (*)(), bool, long)+0x50>
    NVIC_SetPriority(irq, priority);
   15422:	9a01      	ldr	r2, [sp, #4]
   15424:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   15428:	4611      	mov	r1, r2
   1542a:	4618      	mov	r0, r3
   1542c:	f7ff ff78 	bl	15320 <NVIC_SetPriority>
}
   15430:	bf00      	nop
   15432:	b005      	add	sp, #20
   15434:	f85d fb04 	ldr.w	pc, [sp], #4
   15438:	100007f4 	.word	0x100007f4

0001543c <GetRegistersFromStack>:
{
   1543c:	b500      	push	{lr}
   1543e:	b08d      	sub	sp, #52	; 0x34
   15440:	9003      	str	r0, [sp, #12]
  volatile uint32_t r0  = fault_stack_address[0];
   15442:	9b03      	ldr	r3, [sp, #12]
   15444:	681b      	ldr	r3, [r3, #0]
   15446:	930b      	str	r3, [sp, #44]	; 0x2c
  volatile uint32_t r1  = fault_stack_address[1];
   15448:	9b03      	ldr	r3, [sp, #12]
   1544a:	685b      	ldr	r3, [r3, #4]
   1544c:	930a      	str	r3, [sp, #40]	; 0x28
  volatile uint32_t r2  = fault_stack_address[2];
   1544e:	9b03      	ldr	r3, [sp, #12]
   15450:	689b      	ldr	r3, [r3, #8]
   15452:	9309      	str	r3, [sp, #36]	; 0x24
  volatile uint32_t r3  = fault_stack_address[3];
   15454:	9b03      	ldr	r3, [sp, #12]
   15456:	68db      	ldr	r3, [r3, #12]
   15458:	9308      	str	r3, [sp, #32]
  volatile uint32_t r12 = fault_stack_address[4];
   1545a:	9b03      	ldr	r3, [sp, #12]
   1545c:	691b      	ldr	r3, [r3, #16]
   1545e:	9307      	str	r3, [sp, #28]
  volatile uint32_t lr = fault_stack_address[5];
   15460:	9b03      	ldr	r3, [sp, #12]
   15462:	695b      	ldr	r3, [r3, #20]
   15464:	9306      	str	r3, [sp, #24]
  volatile uint32_t pc = fault_stack_address[6];
   15466:	9b03      	ldr	r3, [sp, #12]
   15468:	699b      	ldr	r3, [r3, #24]
   1546a:	9305      	str	r3, [sp, #20]
  volatile uint32_t psr = fault_stack_address[7];
   1546c:	9b03      	ldr	r3, [sp, #12]
   1546e:	69db      	ldr	r3, [r3, #28]
   15470:	9304      	str	r3, [sp, #16]
  printf(SJ2_BACKGROUND_RED "Hard Fault Exception Occurred!\n" SJ2_COLOR_RESET);
   15472:	480d      	ldr	r0, [pc, #52]	; (154a8 <GetRegistersFromStack+0x6c>)
   15474:	f002 fcec 	bl	17e50 <printf>
  printf("r0: 0x%08" PRIX32 ", r1: 0x%08" PRIX32
   15478:	990b      	ldr	r1, [sp, #44]	; 0x2c
   1547a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1547c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1547e:	9b08      	ldr	r3, [sp, #32]
   15480:	9300      	str	r3, [sp, #0]
   15482:	4603      	mov	r3, r0
   15484:	4809      	ldr	r0, [pc, #36]	; (154ac <GetRegistersFromStack+0x70>)
   15486:	f002 fce3 	bl	17e50 <printf>
  printf("r12: 0x%08" PRIX32 ", lr: 0x%08" PRIX32
   1548a:	9907      	ldr	r1, [sp, #28]
   1548c:	9a06      	ldr	r2, [sp, #24]
   1548e:	9805      	ldr	r0, [sp, #20]
   15490:	9b04      	ldr	r3, [sp, #16]
   15492:	9300      	str	r3, [sp, #0]
   15494:	4603      	mov	r3, r0
   15496:	4806      	ldr	r0, [pc, #24]	; (154b0 <GetRegistersFromStack+0x74>)
   15498:	f002 fcda 	bl	17e50 <printf>
  debug::PrintBacktrace(true, reinterpret_cast<void *>(pc));
   1549c:	9b05      	ldr	r3, [sp, #20]
   1549e:	4619      	mov	r1, r3
   154a0:	2001      	movs	r0, #1
   154a2:	f7fb fa99 	bl	109d8 <debug::PrintBacktrace(bool, void*)>
   154a6:	e7fe      	b.n	154a6 <GetRegistersFromStack+0x6a>
   154a8:	0001b490 	.word	0x0001b490
   154ac:	0001b4bc 	.word	0x0001b4bc
   154b0:	0001b4f0 	.word	0x0001b4f0

000154b4 <FirmwareStdOut(int)>:
}
Stdout out = HostWrite;
Stdin in   = HostRead;
#else
int FirmwareStdOut(int data)
{
   154b4:	b530      	push	{r4, r5, lr}
   154b6:	b083      	sub	sp, #12
   154b8:	4675      	mov	r5, lr
   154ba:	9001      	str	r0, [sp, #4]
   154bc:	462b      	mov	r3, r5
   154be:	4619      	mov	r1, r3
   154c0:	4809      	ldr	r0, [pc, #36]	; (154e8 <FirmwareStdOut(int)+0x34>)
   154c2:	f000 f8e1 	bl	15688 <__cyg_profile_func_enter>
  uart0.Send(static_cast<uint8_t>(data));
   154c6:	9b01      	ldr	r3, [sp, #4]
   154c8:	b2db      	uxtb	r3, r3
   154ca:	4619      	mov	r1, r3
   154cc:	4807      	ldr	r0, [pc, #28]	; (154ec <FirmwareStdOut(int)+0x38>)
   154ce:	f7fe ffef 	bl	144b0 <Uart::Send(unsigned char)>
  return 1;
   154d2:	2401      	movs	r4, #1
   154d4:	462b      	mov	r3, r5
   154d6:	4619      	mov	r1, r3
   154d8:	4803      	ldr	r0, [pc, #12]	; (154e8 <FirmwareStdOut(int)+0x34>)
   154da:	f000 f8e9 	bl	156b0 <__cyg_profile_func_exit>
   154de:	4623      	mov	r3, r4
}
   154e0:	4618      	mov	r0, r3
   154e2:	b003      	add	sp, #12
   154e4:	bd30      	pop	{r4, r5, pc}
   154e6:	bf00      	nop
   154e8:	000154b5 	.word	0x000154b5
   154ec:	100007c8 	.word	0x100007c8

000154f0 <_exit>:
  }
  // Dummy implementation of exit with return code placed into
  // Arm register r3
  // NOLINTNEXTLINE(readability-identifier-naming)
  void _exit([[maybe_unused]] int rc)
  {
   154f0:	b500      	push	{lr}
   154f2:	b083      	sub	sp, #12
   154f4:	4673      	mov	r3, lr
   154f6:	9001      	str	r0, [sp, #4]
   154f8:	4619      	mov	r1, r3
   154fa:	4802      	ldr	r0, [pc, #8]	; (15504 <_exit+0x14>)
   154fc:	f000 f8c4 	bl	15688 <__cyg_profile_func_enter>
    while (1)
    {
      continue;
   15500:	bf00      	nop
    while (1)
   15502:	e7fd      	b.n	15500 <_exit+0x10>
   15504:	000154f1 	.word	0x000154f1

00015508 <_getpid>:
    }
  }
  // Dummy implementation of getpid
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _getpid()
  {
   15508:	b538      	push	{r3, r4, r5, lr}
   1550a:	4675      	mov	r5, lr
   1550c:	462b      	mov	r3, r5
   1550e:	4619      	mov	r1, r3
   15510:	4805      	ldr	r0, [pc, #20]	; (15528 <_getpid+0x20>)
   15512:	f000 f8b9 	bl	15688 <__cyg_profile_func_enter>
    return 1;
   15516:	2401      	movs	r4, #1
   15518:	462b      	mov	r3, r5
   1551a:	4619      	mov	r1, r3
   1551c:	4802      	ldr	r0, [pc, #8]	; (15528 <_getpid+0x20>)
   1551e:	f000 f8c7 	bl	156b0 <__cyg_profile_func_exit>
   15522:	4623      	mov	r3, r4
  }
   15524:	4618      	mov	r0, r3
   15526:	bd38      	pop	{r3, r4, r5, pc}
   15528:	00015509 	.word	0x00015509

0001552c <_kill>:
  // Dummy implementation of kill
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _kill(int, int)
  {
   1552c:	b530      	push	{r4, r5, lr}
   1552e:	b083      	sub	sp, #12
   15530:	4675      	mov	r5, lr
   15532:	9001      	str	r0, [sp, #4]
   15534:	9100      	str	r1, [sp, #0]
   15536:	462b      	mov	r3, r5
   15538:	4619      	mov	r1, r3
   1553a:	4807      	ldr	r0, [pc, #28]	; (15558 <_kill+0x2c>)
   1553c:	f000 f8a4 	bl	15688 <__cyg_profile_func_enter>
    return -1;
   15540:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   15544:	462b      	mov	r3, r5
   15546:	4619      	mov	r1, r3
   15548:	4803      	ldr	r0, [pc, #12]	; (15558 <_kill+0x2c>)
   1554a:	f000 f8b1 	bl	156b0 <__cyg_profile_func_exit>
   1554e:	4623      	mov	r3, r4
  }
   15550:	4618      	mov	r0, r3
   15552:	b003      	add	sp, #12
   15554:	bd30      	pop	{r4, r5, pc}
   15556:	bf00      	nop
   15558:	0001552d 	.word	0x0001552d

0001555c <_sbrk>:
    return 0;
  }
  // Implementation of sbrk for allocating and deallocating space for malloc.
  // NOLINTNEXTLINE(readability-identifier-naming)
  void * _sbrk(int increment)
  {
   1555c:	b530      	push	{r4, r5, lr}
   1555e:	b085      	sub	sp, #20
   15560:	4675      	mov	r5, lr
   15562:	9001      	str	r0, [sp, #4]
   15564:	462b      	mov	r3, r5
   15566:	4619      	mov	r1, r3
   15568:	480f      	ldr	r0, [pc, #60]	; (155a8 <_sbrk+0x4c>)
   1556a:	f000 f88d 	bl	15688 <__cyg_profile_func_enter>
    void * previous_heap_position  = static_cast<void *>(heap_position);
   1556e:	4b0f      	ldr	r3, [pc, #60]	; (155ac <_sbrk+0x50>)
   15570:	681b      	ldr	r3, [r3, #0]
   15572:	9303      	str	r3, [sp, #12]
    // Check that by allocating this space, we do not exceed the heap area.
    if ((heap_position + increment) > &heap_end)
   15574:	4b0d      	ldr	r3, [pc, #52]	; (155ac <_sbrk+0x50>)
   15576:	681a      	ldr	r2, [r3, #0]
   15578:	9b01      	ldr	r3, [sp, #4]
   1557a:	4413      	add	r3, r2
   1557c:	4a0c      	ldr	r2, [pc, #48]	; (155b0 <_sbrk+0x54>)
   1557e:	4293      	cmp	r3, r2
   15580:	d901      	bls.n	15586 <_sbrk+0x2a>
    {
      previous_heap_position = nullptr;
   15582:	2300      	movs	r3, #0
   15584:	9303      	str	r3, [sp, #12]
    }
    heap_position += increment;
   15586:	4b09      	ldr	r3, [pc, #36]	; (155ac <_sbrk+0x50>)
   15588:	681a      	ldr	r2, [r3, #0]
   1558a:	9b01      	ldr	r3, [sp, #4]
   1558c:	4413      	add	r3, r2
   1558e:	4a07      	ldr	r2, [pc, #28]	; (155ac <_sbrk+0x50>)
   15590:	6013      	str	r3, [r2, #0]
    return previous_heap_position;
   15592:	9c03      	ldr	r4, [sp, #12]
   15594:	462b      	mov	r3, r5
   15596:	4619      	mov	r1, r3
   15598:	4803      	ldr	r0, [pc, #12]	; (155a8 <_sbrk+0x4c>)
   1559a:	f000 f889 	bl	156b0 <__cyg_profile_func_exit>
   1559e:	4623      	mov	r3, r4
  }
   155a0:	4618      	mov	r0, r3
   155a2:	b005      	add	sp, #20
   155a4:	bd30      	pop	{r4, r5, pc}
   155a6:	bf00      	nop
   155a8:	0001555d 	.word	0x0001555d
   155ac:	100008d8 	.word	0x100008d8
   155b0:	20008000 	.word	0x20008000

000155b4 <_putchar>:
    }
    return length;
  }
  // Needed by third party printf library
  void _putchar(char character)  // NOLINT
  {
   155b4:	b510      	push	{r4, lr}
   155b6:	b082      	sub	sp, #8
   155b8:	4674      	mov	r4, lr
   155ba:	4603      	mov	r3, r0
   155bc:	f88d 3007 	strb.w	r3, [sp, #7]
   155c0:	4623      	mov	r3, r4
   155c2:	4619      	mov	r1, r3
   155c4:	4808      	ldr	r0, [pc, #32]	; (155e8 <_putchar+0x34>)
   155c6:	f000 f85f 	bl	15688 <__cyg_profile_func_enter>
    out(character);
   155ca:	4b08      	ldr	r3, [pc, #32]	; (155ec <_putchar+0x38>)
   155cc:	681b      	ldr	r3, [r3, #0]
   155ce:	f89d 2007 	ldrb.w	r2, [sp, #7]
   155d2:	4610      	mov	r0, r2
   155d4:	4798      	blx	r3
   155d6:	4623      	mov	r3, r4
   155d8:	4619      	mov	r1, r3
   155da:	4803      	ldr	r0, [pc, #12]	; (155e8 <_putchar+0x34>)
   155dc:	f000 f868 	bl	156b0 <__cyg_profile_func_exit>
  }
   155e0:	bf00      	nop
   155e2:	b002      	add	sp, #8
   155e4:	bd10      	pop	{r4, pc}
   155e6:	bf00      	nop
   155e8:	000155b5 	.word	0x000155b5
   155ec:	100008dc 	.word	0x100008dc

000155f0 <putchar>:

  // Overload default libnano putchar() with a more optimal version that does
  // not use dynamic memory
  int putchar(int character)  // NOLINT
  {
   155f0:	b530      	push	{r4, r5, lr}
   155f2:	b083      	sub	sp, #12
   155f4:	4674      	mov	r4, lr
   155f6:	9001      	str	r0, [sp, #4]
   155f8:	4623      	mov	r3, r4
   155fa:	4619      	mov	r1, r3
   155fc:	4808      	ldr	r0, [pc, #32]	; (15620 <putchar+0x30>)
   155fe:	f000 f843 	bl	15688 <__cyg_profile_func_enter>
    return out(character);
   15602:	4b08      	ldr	r3, [pc, #32]	; (15624 <putchar+0x34>)
   15604:	681b      	ldr	r3, [r3, #0]
   15606:	9801      	ldr	r0, [sp, #4]
   15608:	4798      	blx	r3
   1560a:	4605      	mov	r5, r0
   1560c:	4623      	mov	r3, r4
   1560e:	4619      	mov	r1, r3
   15610:	4803      	ldr	r0, [pc, #12]	; (15620 <putchar+0x30>)
   15612:	f000 f84d 	bl	156b0 <__cyg_profile_func_exit>
   15616:	462b      	mov	r3, r5
  }
   15618:	4618      	mov	r0, r3
   1561a:	b003      	add	sp, #12
   1561c:	bd30      	pop	{r4, r5, pc}
   1561e:	bf00      	nop
   15620:	000155f1 	.word	0x000155f1
   15624:	100008dc 	.word	0x100008dc

00015628 <puts>:

  // Overload default libnano puts() with a more optimal version that does
  // not use dynamic memory
  int puts(const char * str)  // NOLINT
  {
   15628:	b530      	push	{r4, r5, lr}
   1562a:	b085      	sub	sp, #20
   1562c:	4675      	mov	r5, lr
   1562e:	9001      	str	r0, [sp, #4]
   15630:	462b      	mov	r3, r5
   15632:	4619      	mov	r1, r3
   15634:	4812      	ldr	r0, [pc, #72]	; (15680 <puts+0x58>)
   15636:	f000 f827 	bl	15688 <__cyg_profile_func_enter>
    int i;
    for (i = 0; str[i] != '\0'; i++)
   1563a:	2300      	movs	r3, #0
   1563c:	9303      	str	r3, [sp, #12]
   1563e:	9b03      	ldr	r3, [sp, #12]
   15640:	9a01      	ldr	r2, [sp, #4]
   15642:	4413      	add	r3, r2
   15644:	781b      	ldrb	r3, [r3, #0]
   15646:	2b00      	cmp	r3, #0
   15648:	d00b      	beq.n	15662 <puts+0x3a>
    {
      out(str[i]);
   1564a:	4b0e      	ldr	r3, [pc, #56]	; (15684 <puts+0x5c>)
   1564c:	681b      	ldr	r3, [r3, #0]
   1564e:	9a03      	ldr	r2, [sp, #12]
   15650:	9901      	ldr	r1, [sp, #4]
   15652:	440a      	add	r2, r1
   15654:	7812      	ldrb	r2, [r2, #0]
   15656:	4610      	mov	r0, r2
   15658:	4798      	blx	r3
    for (i = 0; str[i] != '\0'; i++)
   1565a:	9b03      	ldr	r3, [sp, #12]
   1565c:	3301      	adds	r3, #1
   1565e:	9303      	str	r3, [sp, #12]
   15660:	e7ed      	b.n	1563e <puts+0x16>
    }
    out('\n');
   15662:	4b08      	ldr	r3, [pc, #32]	; (15684 <puts+0x5c>)
   15664:	681b      	ldr	r3, [r3, #0]
   15666:	200a      	movs	r0, #10
   15668:	4798      	blx	r3
    return i;
   1566a:	9c03      	ldr	r4, [sp, #12]
   1566c:	462b      	mov	r3, r5
   1566e:	4619      	mov	r1, r3
   15670:	4803      	ldr	r0, [pc, #12]	; (15680 <puts+0x58>)
   15672:	f000 f81d 	bl	156b0 <__cyg_profile_func_exit>
   15676:	4623      	mov	r3, r4
  }
   15678:	4618      	mov	r0, r3
   1567a:	b005      	add	sp, #20
   1567c:	bd30      	pop	{r4, r5, pc}
   1567e:	bf00      	nop
   15680:	00015629 	.word	0x00015629
   15684:	100008dc 	.word	0x100008dc

00015688 <__cyg_profile_func_enter>:
  // =============================
  void * stack_trace[config::kBacktraceDepth] = { nullptr };
  size_t stack_depth = 0;

  void __cyg_profile_func_enter(void *, void * call_site)  // NOLINT
  {
   15688:	b082      	sub	sp, #8
   1568a:	9001      	str	r0, [sp, #4]
   1568c:	9100      	str	r1, [sp, #0]
    stack_trace[stack_depth++] = call_site;
   1568e:	9a00      	ldr	r2, [sp, #0]
   15690:	4b05      	ldr	r3, [pc, #20]	; (156a8 <__cyg_profile_func_enter+0x20>)
   15692:	681b      	ldr	r3, [r3, #0]
   15694:	1c59      	adds	r1, r3, #1
   15696:	4804      	ldr	r0, [pc, #16]	; (156a8 <__cyg_profile_func_enter+0x20>)
   15698:	6001      	str	r1, [r0, #0]
   1569a:	4904      	ldr	r1, [pc, #16]	; (156ac <__cyg_profile_func_enter+0x24>)
   1569c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
   156a0:	bf00      	nop
   156a2:	b002      	add	sp, #8
   156a4:	4770      	bx	lr
   156a6:	bf00      	nop
   156a8:	1000154c 	.word	0x1000154c
   156ac:	1000144c 	.word	0x1000144c

000156b0 <__cyg_profile_func_exit>:

  void __cyg_profile_func_exit(void *, void *)  // NOLINT
  {
   156b0:	b082      	sub	sp, #8
   156b2:	9001      	str	r0, [sp, #4]
   156b4:	9100      	str	r1, [sp, #0]
    stack_depth--;
   156b6:	4b04      	ldr	r3, [pc, #16]	; (156c8 <__cyg_profile_func_exit+0x18>)
   156b8:	681b      	ldr	r3, [r3, #0]
   156ba:	3b01      	subs	r3, #1
   156bc:	4a02      	ldr	r2, [pc, #8]	; (156c8 <__cyg_profile_func_exit+0x18>)
   156be:	6013      	str	r3, [r2, #0]
  }
   156c0:	bf00      	nop
   156c2:	b002      	add	sp, #8
   156c4:	4770      	bx	lr
   156c6:	bf00      	nop
   156c8:	1000154c 	.word	0x1000154c

000156cc <GetStackTrace()>:
}

void ** GetStackTrace()
{
   156cc:	b538      	push	{r3, r4, r5, lr}
   156ce:	4675      	mov	r5, lr
   156d0:	462b      	mov	r3, r5
   156d2:	4619      	mov	r1, r3
   156d4:	4805      	ldr	r0, [pc, #20]	; (156ec <GetStackTrace()+0x20>)
   156d6:	f7ff ffd7 	bl	15688 <__cyg_profile_func_enter>
  return stack_trace;
   156da:	4c05      	ldr	r4, [pc, #20]	; (156f0 <GetStackTrace()+0x24>)
   156dc:	462b      	mov	r3, r5
   156de:	4619      	mov	r1, r3
   156e0:	4802      	ldr	r0, [pc, #8]	; (156ec <GetStackTrace()+0x20>)
   156e2:	f7ff ffe5 	bl	156b0 <__cyg_profile_func_exit>
   156e6:	4623      	mov	r3, r4
}
   156e8:	4618      	mov	r0, r3
   156ea:	bd38      	pop	{r3, r4, r5, pc}
   156ec:	000156cd 	.word	0x000156cd
   156f0:	1000144c 	.word	0x1000144c

000156f4 <GetStackDepth()>:

size_t GetStackDepth()
{
   156f4:	b538      	push	{r3, r4, r5, lr}
   156f6:	4675      	mov	r5, lr
   156f8:	462b      	mov	r3, r5
   156fa:	4619      	mov	r1, r3
   156fc:	4806      	ldr	r0, [pc, #24]	; (15718 <GetStackDepth()+0x24>)
   156fe:	f7ff ffc3 	bl	15688 <__cyg_profile_func_enter>
  return stack_depth;
   15702:	4b06      	ldr	r3, [pc, #24]	; (1571c <GetStackDepth()+0x28>)
   15704:	681c      	ldr	r4, [r3, #0]
   15706:	462b      	mov	r3, r5
   15708:	4619      	mov	r1, r3
   1570a:	4803      	ldr	r0, [pc, #12]	; (15718 <GetStackDepth()+0x24>)
   1570c:	f7ff ffd0 	bl	156b0 <__cyg_profile_func_exit>
   15710:	4623      	mov	r3, r4
}
   15712:	4618      	mov	r0, r3
   15714:	bd38      	pop	{r3, r4, r5, pc}
   15716:	bf00      	nop
   15718:	000156f5 	.word	0x000156f5
   1571c:	1000154c 	.word	0x1000154c

00015720 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   15720:	b082      	sub	sp, #8
   15722:	9001      	str	r0, [sp, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   15724:	9b01      	ldr	r3, [sp, #4]
   15726:	f103 0208 	add.w	r2, r3, #8
   1572a:	9b01      	ldr	r3, [sp, #4]
   1572c:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   1572e:	9b01      	ldr	r3, [sp, #4]
   15730:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15734:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   15736:	9b01      	ldr	r3, [sp, #4]
   15738:	f103 0208 	add.w	r2, r3, #8
   1573c:	9b01      	ldr	r3, [sp, #4]
   1573e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   15740:	9b01      	ldr	r3, [sp, #4]
   15742:	f103 0208 	add.w	r2, r3, #8
   15746:	9b01      	ldr	r3, [sp, #4]
   15748:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   1574a:	9b01      	ldr	r3, [sp, #4]
   1574c:	2200      	movs	r2, #0
   1574e:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   15750:	bf00      	nop
   15752:	b002      	add	sp, #8
   15754:	4770      	bx	lr

00015756 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   15756:	b082      	sub	sp, #8
   15758:	9001      	str	r0, [sp, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   1575a:	9b01      	ldr	r3, [sp, #4]
   1575c:	2200      	movs	r2, #0
   1575e:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   15760:	bf00      	nop
   15762:	b002      	add	sp, #8
   15764:	4770      	bx	lr

00015766 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   15766:	b084      	sub	sp, #16
   15768:	9001      	str	r0, [sp, #4]
   1576a:	9100      	str	r1, [sp, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   1576c:	9b01      	ldr	r3, [sp, #4]
   1576e:	685b      	ldr	r3, [r3, #4]
   15770:	9303      	str	r3, [sp, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   15772:	9b00      	ldr	r3, [sp, #0]
   15774:	9a03      	ldr	r2, [sp, #12]
   15776:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   15778:	9b03      	ldr	r3, [sp, #12]
   1577a:	689a      	ldr	r2, [r3, #8]
   1577c:	9b00      	ldr	r3, [sp, #0]
   1577e:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   15780:	9b03      	ldr	r3, [sp, #12]
   15782:	689b      	ldr	r3, [r3, #8]
   15784:	9a00      	ldr	r2, [sp, #0]
   15786:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   15788:	9b03      	ldr	r3, [sp, #12]
   1578a:	9a00      	ldr	r2, [sp, #0]
   1578c:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   1578e:	9b00      	ldr	r3, [sp, #0]
   15790:	9a01      	ldr	r2, [sp, #4]
   15792:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   15794:	9b01      	ldr	r3, [sp, #4]
   15796:	681b      	ldr	r3, [r3, #0]
   15798:	1c5a      	adds	r2, r3, #1
   1579a:	9b01      	ldr	r3, [sp, #4]
   1579c:	601a      	str	r2, [r3, #0]
}
   1579e:	bf00      	nop
   157a0:	b004      	add	sp, #16
   157a2:	4770      	bx	lr

000157a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   157a4:	b084      	sub	sp, #16
   157a6:	9001      	str	r0, [sp, #4]
   157a8:	9100      	str	r1, [sp, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   157aa:	9b00      	ldr	r3, [sp, #0]
   157ac:	681b      	ldr	r3, [r3, #0]
   157ae:	9302      	str	r3, [sp, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   157b0:	9b02      	ldr	r3, [sp, #8]
   157b2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   157b6:	d103      	bne.n	157c0 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   157b8:	9b01      	ldr	r3, [sp, #4]
   157ba:	691b      	ldr	r3, [r3, #16]
   157bc:	9303      	str	r3, [sp, #12]
   157be:	e00c      	b.n	157da <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   157c0:	9b01      	ldr	r3, [sp, #4]
   157c2:	3308      	adds	r3, #8
   157c4:	9303      	str	r3, [sp, #12]
   157c6:	e002      	b.n	157ce <vListInsert+0x2a>
   157c8:	9b03      	ldr	r3, [sp, #12]
   157ca:	685b      	ldr	r3, [r3, #4]
   157cc:	9303      	str	r3, [sp, #12]
   157ce:	9b03      	ldr	r3, [sp, #12]
   157d0:	685b      	ldr	r3, [r3, #4]
   157d2:	681b      	ldr	r3, [r3, #0]
   157d4:	9a02      	ldr	r2, [sp, #8]
   157d6:	429a      	cmp	r2, r3
   157d8:	d2f6      	bcs.n	157c8 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   157da:	9b03      	ldr	r3, [sp, #12]
   157dc:	685a      	ldr	r2, [r3, #4]
   157de:	9b00      	ldr	r3, [sp, #0]
   157e0:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   157e2:	9b00      	ldr	r3, [sp, #0]
   157e4:	685b      	ldr	r3, [r3, #4]
   157e6:	9a00      	ldr	r2, [sp, #0]
   157e8:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   157ea:	9b00      	ldr	r3, [sp, #0]
   157ec:	9a03      	ldr	r2, [sp, #12]
   157ee:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   157f0:	9b03      	ldr	r3, [sp, #12]
   157f2:	9a00      	ldr	r2, [sp, #0]
   157f4:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   157f6:	9b00      	ldr	r3, [sp, #0]
   157f8:	9a01      	ldr	r2, [sp, #4]
   157fa:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   157fc:	9b01      	ldr	r3, [sp, #4]
   157fe:	681b      	ldr	r3, [r3, #0]
   15800:	1c5a      	adds	r2, r3, #1
   15802:	9b01      	ldr	r3, [sp, #4]
   15804:	601a      	str	r2, [r3, #0]
}
   15806:	bf00      	nop
   15808:	b004      	add	sp, #16
   1580a:	4770      	bx	lr

0001580c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   1580c:	b084      	sub	sp, #16
   1580e:	9001      	str	r0, [sp, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   15810:	9b01      	ldr	r3, [sp, #4]
   15812:	691b      	ldr	r3, [r3, #16]
   15814:	9303      	str	r3, [sp, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   15816:	9b01      	ldr	r3, [sp, #4]
   15818:	685b      	ldr	r3, [r3, #4]
   1581a:	9a01      	ldr	r2, [sp, #4]
   1581c:	6892      	ldr	r2, [r2, #8]
   1581e:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   15820:	9b01      	ldr	r3, [sp, #4]
   15822:	689b      	ldr	r3, [r3, #8]
   15824:	9a01      	ldr	r2, [sp, #4]
   15826:	6852      	ldr	r2, [r2, #4]
   15828:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   1582a:	9b03      	ldr	r3, [sp, #12]
   1582c:	685b      	ldr	r3, [r3, #4]
   1582e:	9a01      	ldr	r2, [sp, #4]
   15830:	429a      	cmp	r2, r3
   15832:	d103      	bne.n	1583c <uxListRemove+0x30>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   15834:	9b01      	ldr	r3, [sp, #4]
   15836:	689a      	ldr	r2, [r3, #8]
   15838:	9b03      	ldr	r3, [sp, #12]
   1583a:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   1583c:	9b01      	ldr	r3, [sp, #4]
   1583e:	2200      	movs	r2, #0
   15840:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   15842:	9b03      	ldr	r3, [sp, #12]
   15844:	681b      	ldr	r3, [r3, #0]
   15846:	1e5a      	subs	r2, r3, #1
   15848:	9b03      	ldr	r3, [sp, #12]
   1584a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   1584c:	9b03      	ldr	r3, [sp, #12]
   1584e:	681b      	ldr	r3, [r3, #0]
}
   15850:	4618      	mov	r0, r3
   15852:	b004      	add	sp, #16
   15854:	4770      	bx	lr

00015856 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
   15856:	b500      	push	{lr}
   15858:	b08b      	sub	sp, #44	; 0x2c
   1585a:	9007      	str	r0, [sp, #28]
   1585c:	9106      	str	r1, [sp, #24]
   1585e:	9205      	str	r2, [sp, #20]
   15860:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
   15862:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   15864:	2b00      	cmp	r3, #0
   15866:	d01d      	beq.n	158a4 <xTaskCreateStatic+0x4e>
   15868:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1586a:	2b00      	cmp	r3, #0
   1586c:	d01a      	beq.n	158a4 <xTaskCreateStatic+0x4e>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
   1586e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   15870:	9309      	str	r3, [sp, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
   15872:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15874:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   15876:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
   15878:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1587a:	2202      	movs	r2, #2
   1587c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
   15880:	2300      	movs	r3, #0
   15882:	9303      	str	r3, [sp, #12]
   15884:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15886:	9302      	str	r3, [sp, #8]
   15888:	ab08      	add	r3, sp, #32
   1588a:	9301      	str	r3, [sp, #4]
   1588c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1588e:	9300      	str	r3, [sp, #0]
   15890:	9b04      	ldr	r3, [sp, #16]
   15892:	9a05      	ldr	r2, [sp, #20]
   15894:	9906      	ldr	r1, [sp, #24]
   15896:	9807      	ldr	r0, [sp, #28]
   15898:	f000 f852 	bl	15940 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   1589c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1589e:	f000 f8c9 	bl	15a34 <prvAddNewTaskToReadyList>
   158a2:	e001      	b.n	158a8 <xTaskCreateStatic+0x52>
		}
		else
		{
			xReturn = NULL;
   158a4:	2300      	movs	r3, #0
   158a6:	9308      	str	r3, [sp, #32]
		}

		return xReturn;
   158a8:	9b08      	ldr	r3, [sp, #32]
	}
   158aa:	4618      	mov	r0, r3
   158ac:	b00b      	add	sp, #44	; 0x2c
   158ae:	f85d fb04 	ldr.w	pc, [sp], #4

000158b2 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   158b2:	b500      	push	{lr}
   158b4:	b08d      	sub	sp, #52	; 0x34
   158b6:	9007      	str	r0, [sp, #28]
   158b8:	9106      	str	r1, [sp, #24]
   158ba:	9304      	str	r3, [sp, #16]
   158bc:	4613      	mov	r3, r2
   158be:	f8ad 3016 	strh.w	r3, [sp, #22]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   158c2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   158c6:	009b      	lsls	r3, r3, #2
   158c8:	4618      	mov	r0, r3
   158ca:	f001 f91f 	bl	16b0c <pvPortMalloc>
   158ce:	9009      	str	r0, [sp, #36]	; 0x24

			if( pxStack != NULL )
   158d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   158d2:	2b00      	cmp	r3, #0
   158d4:	d00e      	beq.n	158f4 <xTaskCreate+0x42>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   158d6:	2060      	movs	r0, #96	; 0x60
   158d8:	f001 f918 	bl	16b0c <pvPortMalloc>
   158dc:	900b      	str	r0, [sp, #44]	; 0x2c

				if( pxNewTCB != NULL )
   158de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   158e0:	2b00      	cmp	r3, #0
   158e2:	d003      	beq.n	158ec <xTaskCreate+0x3a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   158e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   158e6:	9a09      	ldr	r2, [sp, #36]	; 0x24
   158e8:	631a      	str	r2, [r3, #48]	; 0x30
   158ea:	e005      	b.n	158f8 <xTaskCreate+0x46>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   158ec:	9809      	ldr	r0, [sp, #36]	; 0x24
   158ee:	f001 f91e 	bl	16b2e <vPortFree>
   158f2:	e001      	b.n	158f8 <xTaskCreate+0x46>
				}
			}
			else
			{
				pxNewTCB = NULL;
   158f4:	2300      	movs	r3, #0
   158f6:	930b      	str	r3, [sp, #44]	; 0x2c
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   158f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   158fa:	2b00      	cmp	r3, #0
   158fc:	d018      	beq.n	15930 <xTaskCreate+0x7e>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
   158fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15900:	2200      	movs	r2, #0
   15902:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   15906:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   1590a:	2300      	movs	r3, #0
   1590c:	9303      	str	r3, [sp, #12]
   1590e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15910:	9302      	str	r3, [sp, #8]
   15912:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   15914:	9301      	str	r3, [sp, #4]
   15916:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   15918:	9300      	str	r3, [sp, #0]
   1591a:	9b04      	ldr	r3, [sp, #16]
   1591c:	9906      	ldr	r1, [sp, #24]
   1591e:	9807      	ldr	r0, [sp, #28]
   15920:	f000 f80e 	bl	15940 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   15924:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15926:	f000 f885 	bl	15a34 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   1592a:	2301      	movs	r3, #1
   1592c:	930a      	str	r3, [sp, #40]	; 0x28
   1592e:	e002      	b.n	15936 <xTaskCreate+0x84>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   15930:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   15934:	930a      	str	r3, [sp, #40]	; 0x28
		}

		return xReturn;
   15936:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	}
   15938:	4618      	mov	r0, r3
   1593a:	b00d      	add	sp, #52	; 0x34
   1593c:	f85d fb04 	ldr.w	pc, [sp], #4

00015940 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   15940:	b500      	push	{lr}
   15942:	b087      	sub	sp, #28
   15944:	9003      	str	r0, [sp, #12]
   15946:	9102      	str	r1, [sp, #8]
   15948:	9201      	str	r2, [sp, #4]
   1594a:	9300      	str	r3, [sp, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   1594c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1594e:	6b18      	ldr	r0, [r3, #48]	; 0x30
   15950:	9b01      	ldr	r3, [sp, #4]
   15952:	009b      	lsls	r3, r3, #2
   15954:	461a      	mov	r2, r3
   15956:	21a5      	movs	r1, #165	; 0xa5
   15958:	f003 ffbf 	bl	198da <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   1595c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1595e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   15960:	9b01      	ldr	r3, [sp, #4]
   15962:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   15966:	3b01      	subs	r3, #1
   15968:	009b      	lsls	r3, r3, #2
   1596a:	4413      	add	r3, r2
   1596c:	9304      	str	r3, [sp, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   1596e:	9b04      	ldr	r3, [sp, #16]
   15970:	f023 0307 	bic.w	r3, r3, #7
   15974:	9304      	str	r3, [sp, #16]
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   15976:	2300      	movs	r3, #0
   15978:	9305      	str	r3, [sp, #20]
   1597a:	e012      	b.n	159a2 <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   1597c:	9a02      	ldr	r2, [sp, #8]
   1597e:	9b05      	ldr	r3, [sp, #20]
   15980:	4413      	add	r3, r2
   15982:	7819      	ldrb	r1, [r3, #0]
   15984:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   15986:	9b05      	ldr	r3, [sp, #20]
   15988:	4413      	add	r3, r2
   1598a:	3334      	adds	r3, #52	; 0x34
   1598c:	460a      	mov	r2, r1
   1598e:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   15990:	9a02      	ldr	r2, [sp, #8]
   15992:	9b05      	ldr	r3, [sp, #20]
   15994:	4413      	add	r3, r2
   15996:	781b      	ldrb	r3, [r3, #0]
   15998:	2b00      	cmp	r3, #0
   1599a:	d006      	beq.n	159aa <prvInitialiseNewTask+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   1599c:	9b05      	ldr	r3, [sp, #20]
   1599e:	3301      	adds	r3, #1
   159a0:	9305      	str	r3, [sp, #20]
   159a2:	9b05      	ldr	r3, [sp, #20]
   159a4:	2b0f      	cmp	r3, #15
   159a6:	d9e9      	bls.n	1597c <prvInitialiseNewTask+0x3c>
   159a8:	e000      	b.n	159ac <prvInitialiseNewTask+0x6c>
		{
			break;
   159aa:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   159ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159ae:	2200      	movs	r2, #0
   159b0:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   159b4:	9b08      	ldr	r3, [sp, #32]
   159b6:	2b04      	cmp	r3, #4
   159b8:	d901      	bls.n	159be <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   159ba:	2304      	movs	r3, #4
   159bc:	9308      	str	r3, [sp, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   159be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159c0:	9a08      	ldr	r2, [sp, #32]
   159c2:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   159c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159c6:	9a08      	ldr	r2, [sp, #32]
   159c8:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
   159ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159cc:	2200      	movs	r2, #0
   159ce:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   159d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159d2:	3304      	adds	r3, #4
   159d4:	4618      	mov	r0, r3
   159d6:	f7ff febe 	bl	15756 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   159da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159dc:	3318      	adds	r3, #24
   159de:	4618      	mov	r0, r3
   159e0:	f7ff feb9 	bl	15756 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   159e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159e6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   159e8:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   159ea:	9b08      	ldr	r3, [sp, #32]
   159ec:	f1c3 0205 	rsb	r2, r3, #5
   159f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159f2:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   159f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159f6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   159f8:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
   159fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159fc:	2200      	movs	r2, #0
   159fe:	655a      	str	r2, [r3, #84]	; 0x54
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   15a00:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a02:	2200      	movs	r2, #0
   15a04:	659a      	str	r2, [r3, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   15a06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a08:	2200      	movs	r2, #0
   15a0a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   15a0e:	9a00      	ldr	r2, [sp, #0]
   15a10:	9903      	ldr	r1, [sp, #12]
   15a12:	9804      	ldr	r0, [sp, #16]
   15a14:	f000 ff52 	bl	168bc <pxPortInitialiseStack>
   15a18:	4602      	mov	r2, r0
   15a1a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a1c:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   15a1e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15a20:	2b00      	cmp	r3, #0
   15a22:	d002      	beq.n	15a2a <prvInitialiseNewTask+0xea>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   15a24:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15a26:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   15a28:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   15a2a:	bf00      	nop
   15a2c:	b007      	add	sp, #28
   15a2e:	f85d fb04 	ldr.w	pc, [sp], #4
   15a32:	Address 0x0000000000015a32 is out of bounds.


00015a34 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   15a34:	b500      	push	{lr}
   15a36:	b083      	sub	sp, #12
   15a38:	9001      	str	r0, [sp, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   15a3a:	f000 ffdb 	bl	169f4 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   15a3e:	4b2d      	ldr	r3, [pc, #180]	; (15af4 <prvAddNewTaskToReadyList+0xc0>)
   15a40:	681b      	ldr	r3, [r3, #0]
   15a42:	3301      	adds	r3, #1
   15a44:	4a2b      	ldr	r2, [pc, #172]	; (15af4 <prvAddNewTaskToReadyList+0xc0>)
   15a46:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   15a48:	4b2b      	ldr	r3, [pc, #172]	; (15af8 <prvAddNewTaskToReadyList+0xc4>)
   15a4a:	681b      	ldr	r3, [r3, #0]
   15a4c:	2b00      	cmp	r3, #0
   15a4e:	d109      	bne.n	15a64 <prvAddNewTaskToReadyList+0x30>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   15a50:	4a29      	ldr	r2, [pc, #164]	; (15af8 <prvAddNewTaskToReadyList+0xc4>)
   15a52:	9b01      	ldr	r3, [sp, #4]
   15a54:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   15a56:	4b27      	ldr	r3, [pc, #156]	; (15af4 <prvAddNewTaskToReadyList+0xc0>)
   15a58:	681b      	ldr	r3, [r3, #0]
   15a5a:	2b01      	cmp	r3, #1
   15a5c:	d110      	bne.n	15a80 <prvAddNewTaskToReadyList+0x4c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   15a5e:	f000 fb1b 	bl	16098 <prvInitialiseTaskLists>
   15a62:	e00d      	b.n	15a80 <prvAddNewTaskToReadyList+0x4c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   15a64:	4b25      	ldr	r3, [pc, #148]	; (15afc <prvAddNewTaskToReadyList+0xc8>)
   15a66:	681b      	ldr	r3, [r3, #0]
   15a68:	2b00      	cmp	r3, #0
   15a6a:	d109      	bne.n	15a80 <prvAddNewTaskToReadyList+0x4c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   15a6c:	4b22      	ldr	r3, [pc, #136]	; (15af8 <prvAddNewTaskToReadyList+0xc4>)
   15a6e:	681b      	ldr	r3, [r3, #0]
   15a70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15a72:	9b01      	ldr	r3, [sp, #4]
   15a74:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15a76:	429a      	cmp	r2, r3
   15a78:	d802      	bhi.n	15a80 <prvAddNewTaskToReadyList+0x4c>
				{
					pxCurrentTCB = pxNewTCB;
   15a7a:	4a1f      	ldr	r2, [pc, #124]	; (15af8 <prvAddNewTaskToReadyList+0xc4>)
   15a7c:	9b01      	ldr	r3, [sp, #4]
   15a7e:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   15a80:	4b1f      	ldr	r3, [pc, #124]	; (15b00 <prvAddNewTaskToReadyList+0xcc>)
   15a82:	681b      	ldr	r3, [r3, #0]
   15a84:	3301      	adds	r3, #1
   15a86:	4a1e      	ldr	r2, [pc, #120]	; (15b00 <prvAddNewTaskToReadyList+0xcc>)
   15a88:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   15a8a:	4b1d      	ldr	r3, [pc, #116]	; (15b00 <prvAddNewTaskToReadyList+0xcc>)
   15a8c:	681a      	ldr	r2, [r3, #0]
   15a8e:	9b01      	ldr	r3, [sp, #4]
   15a90:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   15a92:	9b01      	ldr	r3, [sp, #4]
   15a94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15a96:	2201      	movs	r2, #1
   15a98:	409a      	lsls	r2, r3
   15a9a:	4b1a      	ldr	r3, [pc, #104]	; (15b04 <prvAddNewTaskToReadyList+0xd0>)
   15a9c:	681b      	ldr	r3, [r3, #0]
   15a9e:	4313      	orrs	r3, r2
   15aa0:	4a18      	ldr	r2, [pc, #96]	; (15b04 <prvAddNewTaskToReadyList+0xd0>)
   15aa2:	6013      	str	r3, [r2, #0]
   15aa4:	9b01      	ldr	r3, [sp, #4]
   15aa6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15aa8:	4613      	mov	r3, r2
   15aaa:	009b      	lsls	r3, r3, #2
   15aac:	4413      	add	r3, r2
   15aae:	009b      	lsls	r3, r3, #2
   15ab0:	4a15      	ldr	r2, [pc, #84]	; (15b08 <prvAddNewTaskToReadyList+0xd4>)
   15ab2:	441a      	add	r2, r3
   15ab4:	9b01      	ldr	r3, [sp, #4]
   15ab6:	3304      	adds	r3, #4
   15ab8:	4619      	mov	r1, r3
   15aba:	4610      	mov	r0, r2
   15abc:	f7ff fe53 	bl	15766 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   15ac0:	f000 ffac 	bl	16a1c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   15ac4:	4b0d      	ldr	r3, [pc, #52]	; (15afc <prvAddNewTaskToReadyList+0xc8>)
   15ac6:	681b      	ldr	r3, [r3, #0]
   15ac8:	2b00      	cmp	r3, #0
   15aca:	d00e      	beq.n	15aea <prvAddNewTaskToReadyList+0xb6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   15acc:	4b0a      	ldr	r3, [pc, #40]	; (15af8 <prvAddNewTaskToReadyList+0xc4>)
   15ace:	681b      	ldr	r3, [r3, #0]
   15ad0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15ad2:	9b01      	ldr	r3, [sp, #4]
   15ad4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15ad6:	429a      	cmp	r2, r3
   15ad8:	d207      	bcs.n	15aea <prvAddNewTaskToReadyList+0xb6>
		{
			taskYIELD_IF_USING_PREEMPTION();
   15ada:	4b0c      	ldr	r3, [pc, #48]	; (15b0c <prvAddNewTaskToReadyList+0xd8>)
   15adc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   15ae0:	601a      	str	r2, [r3, #0]
   15ae2:	f3bf 8f4f 	dsb	sy
   15ae6:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   15aea:	bf00      	nop
   15aec:	b003      	add	sp, #12
   15aee:	f85d fb04 	ldr.w	pc, [sp], #4
   15af2:	bf00      	nop
   15af4:	10001628 	.word	0x10001628
   15af8:	10001550 	.word	0x10001550
   15afc:	10001634 	.word	0x10001634
   15b00:	10001644 	.word	0x10001644
   15b04:	10001630 	.word	0x10001630
   15b08:	10001554 	.word	0x10001554
   15b0c:	e000ed04 	.word	0xe000ed04

00015b10 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   15b10:	b500      	push	{lr}
   15b12:	b08b      	sub	sp, #44	; 0x2c
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   15b14:	2300      	movs	r3, #0
   15b16:	9307      	str	r3, [sp, #28]
		StackType_t *pxIdleTaskStackBuffer = NULL;
   15b18:	2300      	movs	r3, #0
   15b1a:	9306      	str	r3, [sp, #24]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   15b1c:	aa05      	add	r2, sp, #20
   15b1e:	a906      	add	r1, sp, #24
   15b20:	ab07      	add	r3, sp, #28
   15b22:	4618      	mov	r0, r3
   15b24:	f7ff f85c 	bl	14be0 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   15b28:	9905      	ldr	r1, [sp, #20]
   15b2a:	9b06      	ldr	r3, [sp, #24]
   15b2c:	9a07      	ldr	r2, [sp, #28]
   15b2e:	9202      	str	r2, [sp, #8]
   15b30:	9301      	str	r3, [sp, #4]
   15b32:	2300      	movs	r3, #0
   15b34:	9300      	str	r3, [sp, #0]
   15b36:	2300      	movs	r3, #0
   15b38:	460a      	mov	r2, r1
   15b3a:	4916      	ldr	r1, [pc, #88]	; (15b94 <vTaskStartScheduler+0x84>)
   15b3c:	4816      	ldr	r0, [pc, #88]	; (15b98 <vTaskStartScheduler+0x88>)
   15b3e:	f7ff fe8a 	bl	15856 <xTaskCreateStatic>
   15b42:	4602      	mov	r2, r0
   15b44:	4b15      	ldr	r3, [pc, #84]	; (15b9c <vTaskStartScheduler+0x8c>)
   15b46:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
   15b48:	4b14      	ldr	r3, [pc, #80]	; (15b9c <vTaskStartScheduler+0x8c>)
   15b4a:	681b      	ldr	r3, [r3, #0]
   15b4c:	2b00      	cmp	r3, #0
   15b4e:	d002      	beq.n	15b56 <vTaskStartScheduler+0x46>
		{
			xReturn = pdPASS;
   15b50:	2301      	movs	r3, #1
   15b52:	9309      	str	r3, [sp, #36]	; 0x24
   15b54:	e001      	b.n	15b5a <vTaskStartScheduler+0x4a>
		}
		else
		{
			xReturn = pdFAIL;
   15b56:	2300      	movs	r3, #0
   15b58:	9309      	str	r3, [sp, #36]	; 0x24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   15b5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15b5c:	2b01      	cmp	r3, #1
   15b5e:	d114      	bne.n	15b8a <vTaskStartScheduler+0x7a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   15b60:	f04f 0328 	mov.w	r3, #40	; 0x28
   15b64:	f383 8811 	msr	BASEPRI, r3
   15b68:	f3bf 8f6f 	isb	sy
   15b6c:	f3bf 8f4f 	dsb	sy
   15b70:	9308      	str	r3, [sp, #32]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   15b72:	4b0b      	ldr	r3, [pc, #44]	; (15ba0 <vTaskStartScheduler+0x90>)
   15b74:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15b78:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   15b7a:	4b0a      	ldr	r3, [pc, #40]	; (15ba4 <vTaskStartScheduler+0x94>)
   15b7c:	2201      	movs	r2, #1
   15b7e:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   15b80:	4b09      	ldr	r3, [pc, #36]	; (15ba8 <vTaskStartScheduler+0x98>)
   15b82:	2200      	movs	r2, #0
   15b84:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   15b86:	f000 ff0b 	bl	169a0 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   15b8a:	bf00      	nop
   15b8c:	b00b      	add	sp, #44	; 0x2c
   15b8e:	f85d fb04 	ldr.w	pc, [sp], #4
   15b92:	bf00      	nop
   15b94:	0001b558 	.word	0x0001b558
   15b98:	0001608d 	.word	0x0001608d
   15b9c:	1000164c 	.word	0x1000164c
   15ba0:	10001648 	.word	0x10001648
   15ba4:	10001634 	.word	0x10001634
   15ba8:	1000162c 	.word	0x1000162c

00015bac <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   15bac:	4b03      	ldr	r3, [pc, #12]	; (15bbc <vTaskSuspendAll+0x10>)
   15bae:	681b      	ldr	r3, [r3, #0]
   15bb0:	3301      	adds	r3, #1
   15bb2:	4a02      	ldr	r2, [pc, #8]	; (15bbc <vTaskSuspendAll+0x10>)
   15bb4:	6013      	str	r3, [r2, #0]
}
   15bb6:	bf00      	nop
   15bb8:	4770      	bx	lr
   15bba:	bf00      	nop
   15bbc:	10001650 	.word	0x10001650

00015bc0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   15bc0:	b500      	push	{lr}
   15bc2:	b085      	sub	sp, #20
TCB_t *pxTCB = NULL;
   15bc4:	2300      	movs	r3, #0
   15bc6:	9303      	str	r3, [sp, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   15bc8:	2300      	movs	r3, #0
   15bca:	9302      	str	r3, [sp, #8]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   15bcc:	f000 ff12 	bl	169f4 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   15bd0:	4b38      	ldr	r3, [pc, #224]	; (15cb4 <xTaskResumeAll+0xf4>)
   15bd2:	681b      	ldr	r3, [r3, #0]
   15bd4:	3b01      	subs	r3, #1
   15bd6:	4a37      	ldr	r2, [pc, #220]	; (15cb4 <xTaskResumeAll+0xf4>)
   15bd8:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   15bda:	4b36      	ldr	r3, [pc, #216]	; (15cb4 <xTaskResumeAll+0xf4>)
   15bdc:	681b      	ldr	r3, [r3, #0]
   15bde:	2b00      	cmp	r3, #0
   15be0:	d161      	bne.n	15ca6 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   15be2:	4b35      	ldr	r3, [pc, #212]	; (15cb8 <xTaskResumeAll+0xf8>)
   15be4:	681b      	ldr	r3, [r3, #0]
   15be6:	2b00      	cmp	r3, #0
   15be8:	d05d      	beq.n	15ca6 <xTaskResumeAll+0xe6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   15bea:	e02e      	b.n	15c4a <xTaskResumeAll+0x8a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   15bec:	4b33      	ldr	r3, [pc, #204]	; (15cbc <xTaskResumeAll+0xfc>)
   15bee:	68db      	ldr	r3, [r3, #12]
   15bf0:	68db      	ldr	r3, [r3, #12]
   15bf2:	9303      	str	r3, [sp, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   15bf4:	9b03      	ldr	r3, [sp, #12]
   15bf6:	3318      	adds	r3, #24
   15bf8:	4618      	mov	r0, r3
   15bfa:	f7ff fe07 	bl	1580c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   15bfe:	9b03      	ldr	r3, [sp, #12]
   15c00:	3304      	adds	r3, #4
   15c02:	4618      	mov	r0, r3
   15c04:	f7ff fe02 	bl	1580c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   15c08:	9b03      	ldr	r3, [sp, #12]
   15c0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15c0c:	2201      	movs	r2, #1
   15c0e:	409a      	lsls	r2, r3
   15c10:	4b2b      	ldr	r3, [pc, #172]	; (15cc0 <xTaskResumeAll+0x100>)
   15c12:	681b      	ldr	r3, [r3, #0]
   15c14:	4313      	orrs	r3, r2
   15c16:	4a2a      	ldr	r2, [pc, #168]	; (15cc0 <xTaskResumeAll+0x100>)
   15c18:	6013      	str	r3, [r2, #0]
   15c1a:	9b03      	ldr	r3, [sp, #12]
   15c1c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15c1e:	4613      	mov	r3, r2
   15c20:	009b      	lsls	r3, r3, #2
   15c22:	4413      	add	r3, r2
   15c24:	009b      	lsls	r3, r3, #2
   15c26:	4a27      	ldr	r2, [pc, #156]	; (15cc4 <xTaskResumeAll+0x104>)
   15c28:	441a      	add	r2, r3
   15c2a:	9b03      	ldr	r3, [sp, #12]
   15c2c:	3304      	adds	r3, #4
   15c2e:	4619      	mov	r1, r3
   15c30:	4610      	mov	r0, r2
   15c32:	f7ff fd98 	bl	15766 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   15c36:	9b03      	ldr	r3, [sp, #12]
   15c38:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15c3a:	4b23      	ldr	r3, [pc, #140]	; (15cc8 <xTaskResumeAll+0x108>)
   15c3c:	681b      	ldr	r3, [r3, #0]
   15c3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15c40:	429a      	cmp	r2, r3
   15c42:	d302      	bcc.n	15c4a <xTaskResumeAll+0x8a>
					{
						xYieldPending = pdTRUE;
   15c44:	4b21      	ldr	r3, [pc, #132]	; (15ccc <xTaskResumeAll+0x10c>)
   15c46:	2201      	movs	r2, #1
   15c48:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   15c4a:	4b1c      	ldr	r3, [pc, #112]	; (15cbc <xTaskResumeAll+0xfc>)
   15c4c:	681b      	ldr	r3, [r3, #0]
   15c4e:	2b00      	cmp	r3, #0
   15c50:	d1cc      	bne.n	15bec <xTaskResumeAll+0x2c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   15c52:	9b03      	ldr	r3, [sp, #12]
   15c54:	2b00      	cmp	r3, #0
   15c56:	d001      	beq.n	15c5c <xTaskResumeAll+0x9c>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   15c58:	f000 faa6 	bl	161a8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   15c5c:	4b1c      	ldr	r3, [pc, #112]	; (15cd0 <xTaskResumeAll+0x110>)
   15c5e:	681b      	ldr	r3, [r3, #0]
   15c60:	9301      	str	r3, [sp, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   15c62:	9b01      	ldr	r3, [sp, #4]
   15c64:	2b00      	cmp	r3, #0
   15c66:	d010      	beq.n	15c8a <xTaskResumeAll+0xca>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   15c68:	f000 f836 	bl	15cd8 <xTaskIncrementTick>
   15c6c:	4603      	mov	r3, r0
   15c6e:	2b00      	cmp	r3, #0
   15c70:	d002      	beq.n	15c78 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
   15c72:	4b16      	ldr	r3, [pc, #88]	; (15ccc <xTaskResumeAll+0x10c>)
   15c74:	2201      	movs	r2, #1
   15c76:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   15c78:	9b01      	ldr	r3, [sp, #4]
   15c7a:	3b01      	subs	r3, #1
   15c7c:	9301      	str	r3, [sp, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   15c7e:	9b01      	ldr	r3, [sp, #4]
   15c80:	2b00      	cmp	r3, #0
   15c82:	d1f1      	bne.n	15c68 <xTaskResumeAll+0xa8>

						uxPendedTicks = 0;
   15c84:	4b12      	ldr	r3, [pc, #72]	; (15cd0 <xTaskResumeAll+0x110>)
   15c86:	2200      	movs	r2, #0
   15c88:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   15c8a:	4b10      	ldr	r3, [pc, #64]	; (15ccc <xTaskResumeAll+0x10c>)
   15c8c:	681b      	ldr	r3, [r3, #0]
   15c8e:	2b00      	cmp	r3, #0
   15c90:	d009      	beq.n	15ca6 <xTaskResumeAll+0xe6>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   15c92:	2301      	movs	r3, #1
   15c94:	9302      	str	r3, [sp, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   15c96:	4b0f      	ldr	r3, [pc, #60]	; (15cd4 <xTaskResumeAll+0x114>)
   15c98:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   15c9c:	601a      	str	r2, [r3, #0]
   15c9e:	f3bf 8f4f 	dsb	sy
   15ca2:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   15ca6:	f000 feb9 	bl	16a1c <vPortExitCritical>

	return xAlreadyYielded;
   15caa:	9b02      	ldr	r3, [sp, #8]
}
   15cac:	4618      	mov	r0, r3
   15cae:	b005      	add	sp, #20
   15cb0:	f85d fb04 	ldr.w	pc, [sp], #4
   15cb4:	10001650 	.word	0x10001650
   15cb8:	10001628 	.word	0x10001628
   15cbc:	100015e8 	.word	0x100015e8
   15cc0:	10001630 	.word	0x10001630
   15cc4:	10001554 	.word	0x10001554
   15cc8:	10001550 	.word	0x10001550
   15ccc:	1000163c 	.word	0x1000163c
   15cd0:	10001638 	.word	0x10001638
   15cd4:	e000ed04 	.word	0xe000ed04

00015cd8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   15cd8:	b500      	push	{lr}
   15cda:	b087      	sub	sp, #28
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   15cdc:	2300      	movs	r3, #0
   15cde:	9305      	str	r3, [sp, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   15ce0:	4b48      	ldr	r3, [pc, #288]	; (15e04 <xTaskIncrementTick+0x12c>)
   15ce2:	681b      	ldr	r3, [r3, #0]
   15ce4:	2b00      	cmp	r3, #0
   15ce6:	d17c      	bne.n	15de2 <xTaskIncrementTick+0x10a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   15ce8:	4b47      	ldr	r3, [pc, #284]	; (15e08 <xTaskIncrementTick+0x130>)
   15cea:	681b      	ldr	r3, [r3, #0]
   15cec:	3301      	adds	r3, #1
   15cee:	9304      	str	r3, [sp, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   15cf0:	4a45      	ldr	r2, [pc, #276]	; (15e08 <xTaskIncrementTick+0x130>)
   15cf2:	9b04      	ldr	r3, [sp, #16]
   15cf4:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   15cf6:	9b04      	ldr	r3, [sp, #16]
   15cf8:	2b00      	cmp	r3, #0
   15cfa:	d110      	bne.n	15d1e <xTaskIncrementTick+0x46>
		{
			taskSWITCH_DELAYED_LISTS();
   15cfc:	4b43      	ldr	r3, [pc, #268]	; (15e0c <xTaskIncrementTick+0x134>)
   15cfe:	681b      	ldr	r3, [r3, #0]
   15d00:	9303      	str	r3, [sp, #12]
   15d02:	4b43      	ldr	r3, [pc, #268]	; (15e10 <xTaskIncrementTick+0x138>)
   15d04:	681b      	ldr	r3, [r3, #0]
   15d06:	4a41      	ldr	r2, [pc, #260]	; (15e0c <xTaskIncrementTick+0x134>)
   15d08:	6013      	str	r3, [r2, #0]
   15d0a:	4a41      	ldr	r2, [pc, #260]	; (15e10 <xTaskIncrementTick+0x138>)
   15d0c:	9b03      	ldr	r3, [sp, #12]
   15d0e:	6013      	str	r3, [r2, #0]
   15d10:	4b40      	ldr	r3, [pc, #256]	; (15e14 <xTaskIncrementTick+0x13c>)
   15d12:	681b      	ldr	r3, [r3, #0]
   15d14:	3301      	adds	r3, #1
   15d16:	4a3f      	ldr	r2, [pc, #252]	; (15e14 <xTaskIncrementTick+0x13c>)
   15d18:	6013      	str	r3, [r2, #0]
   15d1a:	f000 fa45 	bl	161a8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   15d1e:	4b3e      	ldr	r3, [pc, #248]	; (15e18 <xTaskIncrementTick+0x140>)
   15d20:	681b      	ldr	r3, [r3, #0]
   15d22:	9a04      	ldr	r2, [sp, #16]
   15d24:	429a      	cmp	r2, r3
   15d26:	d34d      	bcc.n	15dc4 <xTaskIncrementTick+0xec>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   15d28:	4b38      	ldr	r3, [pc, #224]	; (15e0c <xTaskIncrementTick+0x134>)
   15d2a:	681b      	ldr	r3, [r3, #0]
   15d2c:	681b      	ldr	r3, [r3, #0]
   15d2e:	2b00      	cmp	r3, #0
   15d30:	d101      	bne.n	15d36 <xTaskIncrementTick+0x5e>
   15d32:	2301      	movs	r3, #1
   15d34:	e000      	b.n	15d38 <xTaskIncrementTick+0x60>
   15d36:	2300      	movs	r3, #0
   15d38:	2b00      	cmp	r3, #0
   15d3a:	d004      	beq.n	15d46 <xTaskIncrementTick+0x6e>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   15d3c:	4b36      	ldr	r3, [pc, #216]	; (15e18 <xTaskIncrementTick+0x140>)
   15d3e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15d42:	601a      	str	r2, [r3, #0]
					break;
   15d44:	e03e      	b.n	15dc4 <xTaskIncrementTick+0xec>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   15d46:	4b31      	ldr	r3, [pc, #196]	; (15e0c <xTaskIncrementTick+0x134>)
   15d48:	681b      	ldr	r3, [r3, #0]
   15d4a:	68db      	ldr	r3, [r3, #12]
   15d4c:	68db      	ldr	r3, [r3, #12]
   15d4e:	9302      	str	r3, [sp, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   15d50:	9b02      	ldr	r3, [sp, #8]
   15d52:	685b      	ldr	r3, [r3, #4]
   15d54:	9301      	str	r3, [sp, #4]

					if( xConstTickCount < xItemValue )
   15d56:	9a04      	ldr	r2, [sp, #16]
   15d58:	9b01      	ldr	r3, [sp, #4]
   15d5a:	429a      	cmp	r2, r3
   15d5c:	d203      	bcs.n	15d66 <xTaskIncrementTick+0x8e>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   15d5e:	4a2e      	ldr	r2, [pc, #184]	; (15e18 <xTaskIncrementTick+0x140>)
   15d60:	9b01      	ldr	r3, [sp, #4]
   15d62:	6013      	str	r3, [r2, #0]
						break;
   15d64:	e02e      	b.n	15dc4 <xTaskIncrementTick+0xec>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   15d66:	9b02      	ldr	r3, [sp, #8]
   15d68:	3304      	adds	r3, #4
   15d6a:	4618      	mov	r0, r3
   15d6c:	f7ff fd4e 	bl	1580c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   15d70:	9b02      	ldr	r3, [sp, #8]
   15d72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   15d74:	2b00      	cmp	r3, #0
   15d76:	d004      	beq.n	15d82 <xTaskIncrementTick+0xaa>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   15d78:	9b02      	ldr	r3, [sp, #8]
   15d7a:	3318      	adds	r3, #24
   15d7c:	4618      	mov	r0, r3
   15d7e:	f7ff fd45 	bl	1580c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   15d82:	9b02      	ldr	r3, [sp, #8]
   15d84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15d86:	2201      	movs	r2, #1
   15d88:	409a      	lsls	r2, r3
   15d8a:	4b24      	ldr	r3, [pc, #144]	; (15e1c <xTaskIncrementTick+0x144>)
   15d8c:	681b      	ldr	r3, [r3, #0]
   15d8e:	4313      	orrs	r3, r2
   15d90:	4a22      	ldr	r2, [pc, #136]	; (15e1c <xTaskIncrementTick+0x144>)
   15d92:	6013      	str	r3, [r2, #0]
   15d94:	9b02      	ldr	r3, [sp, #8]
   15d96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15d98:	4613      	mov	r3, r2
   15d9a:	009b      	lsls	r3, r3, #2
   15d9c:	4413      	add	r3, r2
   15d9e:	009b      	lsls	r3, r3, #2
   15da0:	4a1f      	ldr	r2, [pc, #124]	; (15e20 <xTaskIncrementTick+0x148>)
   15da2:	441a      	add	r2, r3
   15da4:	9b02      	ldr	r3, [sp, #8]
   15da6:	3304      	adds	r3, #4
   15da8:	4619      	mov	r1, r3
   15daa:	4610      	mov	r0, r2
   15dac:	f7ff fcdb 	bl	15766 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   15db0:	9b02      	ldr	r3, [sp, #8]
   15db2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15db4:	4b1b      	ldr	r3, [pc, #108]	; (15e24 <xTaskIncrementTick+0x14c>)
   15db6:	681b      	ldr	r3, [r3, #0]
   15db8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15dba:	429a      	cmp	r2, r3
   15dbc:	d3b4      	bcc.n	15d28 <xTaskIncrementTick+0x50>
						{
							xSwitchRequired = pdTRUE;
   15dbe:	2301      	movs	r3, #1
   15dc0:	9305      	str	r3, [sp, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   15dc2:	e7b1      	b.n	15d28 <xTaskIncrementTick+0x50>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   15dc4:	4b17      	ldr	r3, [pc, #92]	; (15e24 <xTaskIncrementTick+0x14c>)
   15dc6:	681b      	ldr	r3, [r3, #0]
   15dc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15dca:	4915      	ldr	r1, [pc, #84]	; (15e20 <xTaskIncrementTick+0x148>)
   15dcc:	4613      	mov	r3, r2
   15dce:	009b      	lsls	r3, r3, #2
   15dd0:	4413      	add	r3, r2
   15dd2:	009b      	lsls	r3, r3, #2
   15dd4:	440b      	add	r3, r1
   15dd6:	681b      	ldr	r3, [r3, #0]
   15dd8:	2b01      	cmp	r3, #1
   15dda:	d907      	bls.n	15dec <xTaskIncrementTick+0x114>
			{
				xSwitchRequired = pdTRUE;
   15ddc:	2301      	movs	r3, #1
   15dde:	9305      	str	r3, [sp, #20]
   15de0:	e004      	b.n	15dec <xTaskIncrementTick+0x114>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   15de2:	4b11      	ldr	r3, [pc, #68]	; (15e28 <xTaskIncrementTick+0x150>)
   15de4:	681b      	ldr	r3, [r3, #0]
   15de6:	3301      	adds	r3, #1
   15de8:	4a0f      	ldr	r2, [pc, #60]	; (15e28 <xTaskIncrementTick+0x150>)
   15dea:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   15dec:	4b0f      	ldr	r3, [pc, #60]	; (15e2c <xTaskIncrementTick+0x154>)
   15dee:	681b      	ldr	r3, [r3, #0]
   15df0:	2b00      	cmp	r3, #0
   15df2:	d001      	beq.n	15df8 <xTaskIncrementTick+0x120>
		{
			xSwitchRequired = pdTRUE;
   15df4:	2301      	movs	r3, #1
   15df6:	9305      	str	r3, [sp, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   15df8:	9b05      	ldr	r3, [sp, #20]
}
   15dfa:	4618      	mov	r0, r3
   15dfc:	b007      	add	sp, #28
   15dfe:	f85d fb04 	ldr.w	pc, [sp], #4
   15e02:	bf00      	nop
   15e04:	10001650 	.word	0x10001650
   15e08:	1000162c 	.word	0x1000162c
   15e0c:	100015e0 	.word	0x100015e0
   15e10:	100015e4 	.word	0x100015e4
   15e14:	10001640 	.word	0x10001640
   15e18:	10001648 	.word	0x10001648
   15e1c:	10001630 	.word	0x10001630
   15e20:	10001554 	.word	0x10001554
   15e24:	10001550 	.word	0x10001550
   15e28:	10001638 	.word	0x10001638
   15e2c:	1000163c 	.word	0x1000163c

00015e30 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   15e30:	b510      	push	{r4, lr}
   15e32:	b084      	sub	sp, #16
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   15e34:	4b29      	ldr	r3, [pc, #164]	; (15edc <vTaskSwitchContext+0xac>)
   15e36:	681b      	ldr	r3, [r3, #0]
   15e38:	2b00      	cmp	r3, #0
   15e3a:	d003      	beq.n	15e44 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   15e3c:	4b28      	ldr	r3, [pc, #160]	; (15ee0 <vTaskSwitchContext+0xb0>)
   15e3e:	2201      	movs	r2, #1
   15e40:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   15e42:	e047      	b.n	15ed4 <vTaskSwitchContext+0xa4>
		xYieldPending = pdFALSE;
   15e44:	4b26      	ldr	r3, [pc, #152]	; (15ee0 <vTaskSwitchContext+0xb0>)
   15e46:	2200      	movs	r2, #0
   15e48:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   15e4a:	f7fe fe93 	bl	14b74 <UptimeRTOS>
   15e4e:	4603      	mov	r3, r0
   15e50:	460c      	mov	r4, r1
   15e52:	461a      	mov	r2, r3
   15e54:	4b23      	ldr	r3, [pc, #140]	; (15ee4 <vTaskSwitchContext+0xb4>)
   15e56:	601a      	str	r2, [r3, #0]
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   15e58:	4b22      	ldr	r3, [pc, #136]	; (15ee4 <vTaskSwitchContext+0xb4>)
   15e5a:	681a      	ldr	r2, [r3, #0]
   15e5c:	4b22      	ldr	r3, [pc, #136]	; (15ee8 <vTaskSwitchContext+0xb8>)
   15e5e:	681b      	ldr	r3, [r3, #0]
   15e60:	429a      	cmp	r2, r3
   15e62:	d909      	bls.n	15e78 <vTaskSwitchContext+0x48>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   15e64:	4b21      	ldr	r3, [pc, #132]	; (15eec <vTaskSwitchContext+0xbc>)
   15e66:	681b      	ldr	r3, [r3, #0]
   15e68:	6d59      	ldr	r1, [r3, #84]	; 0x54
   15e6a:	4a1e      	ldr	r2, [pc, #120]	; (15ee4 <vTaskSwitchContext+0xb4>)
   15e6c:	6810      	ldr	r0, [r2, #0]
   15e6e:	4a1e      	ldr	r2, [pc, #120]	; (15ee8 <vTaskSwitchContext+0xb8>)
   15e70:	6812      	ldr	r2, [r2, #0]
   15e72:	1a82      	subs	r2, r0, r2
   15e74:	440a      	add	r2, r1
   15e76:	655a      	str	r2, [r3, #84]	; 0x54
				ulTaskSwitchedInTime = ulTotalRunTime;
   15e78:	4b1a      	ldr	r3, [pc, #104]	; (15ee4 <vTaskSwitchContext+0xb4>)
   15e7a:	681b      	ldr	r3, [r3, #0]
   15e7c:	4a1a      	ldr	r2, [pc, #104]	; (15ee8 <vTaskSwitchContext+0xb8>)
   15e7e:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   15e80:	4b1b      	ldr	r3, [pc, #108]	; (15ef0 <vTaskSwitchContext+0xc0>)
   15e82:	681b      	ldr	r3, [r3, #0]
   15e84:	9301      	str	r3, [sp, #4]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   15e86:	9b01      	ldr	r3, [sp, #4]
   15e88:	fab3 f383 	clz	r3, r3
   15e8c:	f88d 3003 	strb.w	r3, [sp, #3]
		return ucReturn;
   15e90:	f89d 3003 	ldrb.w	r3, [sp, #3]
   15e94:	f1c3 031f 	rsb	r3, r3, #31
   15e98:	9303      	str	r3, [sp, #12]
   15e9a:	9a03      	ldr	r2, [sp, #12]
   15e9c:	4613      	mov	r3, r2
   15e9e:	009b      	lsls	r3, r3, #2
   15ea0:	4413      	add	r3, r2
   15ea2:	009b      	lsls	r3, r3, #2
   15ea4:	4a13      	ldr	r2, [pc, #76]	; (15ef4 <vTaskSwitchContext+0xc4>)
   15ea6:	4413      	add	r3, r2
   15ea8:	9302      	str	r3, [sp, #8]
   15eaa:	9b02      	ldr	r3, [sp, #8]
   15eac:	685b      	ldr	r3, [r3, #4]
   15eae:	685a      	ldr	r2, [r3, #4]
   15eb0:	9b02      	ldr	r3, [sp, #8]
   15eb2:	605a      	str	r2, [r3, #4]
   15eb4:	9b02      	ldr	r3, [sp, #8]
   15eb6:	685a      	ldr	r2, [r3, #4]
   15eb8:	9b02      	ldr	r3, [sp, #8]
   15eba:	3308      	adds	r3, #8
   15ebc:	429a      	cmp	r2, r3
   15ebe:	d104      	bne.n	15eca <vTaskSwitchContext+0x9a>
   15ec0:	9b02      	ldr	r3, [sp, #8]
   15ec2:	685b      	ldr	r3, [r3, #4]
   15ec4:	685a      	ldr	r2, [r3, #4]
   15ec6:	9b02      	ldr	r3, [sp, #8]
   15ec8:	605a      	str	r2, [r3, #4]
   15eca:	9b02      	ldr	r3, [sp, #8]
   15ecc:	685b      	ldr	r3, [r3, #4]
   15ece:	68db      	ldr	r3, [r3, #12]
   15ed0:	4a06      	ldr	r2, [pc, #24]	; (15eec <vTaskSwitchContext+0xbc>)
   15ed2:	6013      	str	r3, [r2, #0]
}
   15ed4:	bf00      	nop
   15ed6:	b004      	add	sp, #16
   15ed8:	bd10      	pop	{r4, pc}
   15eda:	bf00      	nop
   15edc:	10001650 	.word	0x10001650
   15ee0:	1000163c 	.word	0x1000163c
   15ee4:	10001658 	.word	0x10001658
   15ee8:	10001654 	.word	0x10001654
   15eec:	10001550 	.word	0x10001550
   15ef0:	10001630 	.word	0x10001630
   15ef4:	10001554 	.word	0x10001554

00015ef8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   15ef8:	b500      	push	{lr}
   15efa:	b083      	sub	sp, #12
   15efc:	9001      	str	r0, [sp, #4]
   15efe:	9100      	str	r1, [sp, #0]

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   15f00:	4b07      	ldr	r3, [pc, #28]	; (15f20 <vTaskPlaceOnEventList+0x28>)
   15f02:	681b      	ldr	r3, [r3, #0]
   15f04:	3318      	adds	r3, #24
   15f06:	4619      	mov	r1, r3
   15f08:	9801      	ldr	r0, [sp, #4]
   15f0a:	f7ff fc4b 	bl	157a4 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   15f0e:	2101      	movs	r1, #1
   15f10:	9800      	ldr	r0, [sp, #0]
   15f12:	f000 f9cd 	bl	162b0 <prvAddCurrentTaskToDelayedList>
}
   15f16:	bf00      	nop
   15f18:	b003      	add	sp, #12
   15f1a:	f85d fb04 	ldr.w	pc, [sp], #4
   15f1e:	bf00      	nop
   15f20:	10001550 	.word	0x10001550

00015f24 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   15f24:	b500      	push	{lr}
   15f26:	b085      	sub	sp, #20
   15f28:	9001      	str	r0, [sp, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   15f2a:	9b01      	ldr	r3, [sp, #4]
   15f2c:	68db      	ldr	r3, [r3, #12]
   15f2e:	68db      	ldr	r3, [r3, #12]
   15f30:	9302      	str	r3, [sp, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   15f32:	9b02      	ldr	r3, [sp, #8]
   15f34:	3318      	adds	r3, #24
   15f36:	4618      	mov	r0, r3
   15f38:	f7ff fc68 	bl	1580c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   15f3c:	4b1d      	ldr	r3, [pc, #116]	; (15fb4 <xTaskRemoveFromEventList+0x90>)
   15f3e:	681b      	ldr	r3, [r3, #0]
   15f40:	2b00      	cmp	r3, #0
   15f42:	d11c      	bne.n	15f7e <xTaskRemoveFromEventList+0x5a>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   15f44:	9b02      	ldr	r3, [sp, #8]
   15f46:	3304      	adds	r3, #4
   15f48:	4618      	mov	r0, r3
   15f4a:	f7ff fc5f 	bl	1580c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   15f4e:	9b02      	ldr	r3, [sp, #8]
   15f50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15f52:	2201      	movs	r2, #1
   15f54:	409a      	lsls	r2, r3
   15f56:	4b18      	ldr	r3, [pc, #96]	; (15fb8 <xTaskRemoveFromEventList+0x94>)
   15f58:	681b      	ldr	r3, [r3, #0]
   15f5a:	4313      	orrs	r3, r2
   15f5c:	4a16      	ldr	r2, [pc, #88]	; (15fb8 <xTaskRemoveFromEventList+0x94>)
   15f5e:	6013      	str	r3, [r2, #0]
   15f60:	9b02      	ldr	r3, [sp, #8]
   15f62:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15f64:	4613      	mov	r3, r2
   15f66:	009b      	lsls	r3, r3, #2
   15f68:	4413      	add	r3, r2
   15f6a:	009b      	lsls	r3, r3, #2
   15f6c:	4a13      	ldr	r2, [pc, #76]	; (15fbc <xTaskRemoveFromEventList+0x98>)
   15f6e:	441a      	add	r2, r3
   15f70:	9b02      	ldr	r3, [sp, #8]
   15f72:	3304      	adds	r3, #4
   15f74:	4619      	mov	r1, r3
   15f76:	4610      	mov	r0, r2
   15f78:	f7ff fbf5 	bl	15766 <vListInsertEnd>
   15f7c:	e005      	b.n	15f8a <xTaskRemoveFromEventList+0x66>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   15f7e:	9b02      	ldr	r3, [sp, #8]
   15f80:	3318      	adds	r3, #24
   15f82:	4619      	mov	r1, r3
   15f84:	480e      	ldr	r0, [pc, #56]	; (15fc0 <xTaskRemoveFromEventList+0x9c>)
   15f86:	f7ff fbee 	bl	15766 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   15f8a:	9b02      	ldr	r3, [sp, #8]
   15f8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15f8e:	4b0d      	ldr	r3, [pc, #52]	; (15fc4 <xTaskRemoveFromEventList+0xa0>)
   15f90:	681b      	ldr	r3, [r3, #0]
   15f92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15f94:	429a      	cmp	r2, r3
   15f96:	d905      	bls.n	15fa4 <xTaskRemoveFromEventList+0x80>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   15f98:	2301      	movs	r3, #1
   15f9a:	9303      	str	r3, [sp, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   15f9c:	4b0a      	ldr	r3, [pc, #40]	; (15fc8 <xTaskRemoveFromEventList+0xa4>)
   15f9e:	2201      	movs	r2, #1
   15fa0:	601a      	str	r2, [r3, #0]
   15fa2:	e001      	b.n	15fa8 <xTaskRemoveFromEventList+0x84>
	}
	else
	{
		xReturn = pdFALSE;
   15fa4:	2300      	movs	r3, #0
   15fa6:	9303      	str	r3, [sp, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   15fa8:	9b03      	ldr	r3, [sp, #12]
}
   15faa:	4618      	mov	r0, r3
   15fac:	b005      	add	sp, #20
   15fae:	f85d fb04 	ldr.w	pc, [sp], #4
   15fb2:	bf00      	nop
   15fb4:	10001650 	.word	0x10001650
   15fb8:	10001630 	.word	0x10001630
   15fbc:	10001554 	.word	0x10001554
   15fc0:	100015e8 	.word	0x100015e8
   15fc4:	10001550 	.word	0x10001550
   15fc8:	1000163c 	.word	0x1000163c

00015fcc <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   15fcc:	b082      	sub	sp, #8
   15fce:	9001      	str	r0, [sp, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   15fd0:	4b05      	ldr	r3, [pc, #20]	; (15fe8 <vTaskInternalSetTimeOutState+0x1c>)
   15fd2:	681a      	ldr	r2, [r3, #0]
   15fd4:	9b01      	ldr	r3, [sp, #4]
   15fd6:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   15fd8:	4b04      	ldr	r3, [pc, #16]	; (15fec <vTaskInternalSetTimeOutState+0x20>)
   15fda:	681a      	ldr	r2, [r3, #0]
   15fdc:	9b01      	ldr	r3, [sp, #4]
   15fde:	605a      	str	r2, [r3, #4]
}
   15fe0:	bf00      	nop
   15fe2:	b002      	add	sp, #8
   15fe4:	4770      	bx	lr
   15fe6:	bf00      	nop
   15fe8:	10001640 	.word	0x10001640
   15fec:	1000162c 	.word	0x1000162c

00015ff0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   15ff0:	b500      	push	{lr}
   15ff2:	b087      	sub	sp, #28
   15ff4:	9001      	str	r0, [sp, #4]
   15ff6:	9100      	str	r1, [sp, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   15ff8:	f000 fcfc 	bl	169f4 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   15ffc:	4b1d      	ldr	r3, [pc, #116]	; (16074 <xTaskCheckForTimeOut+0x84>)
   15ffe:	681b      	ldr	r3, [r3, #0]
   16000:	9304      	str	r3, [sp, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   16002:	9b01      	ldr	r3, [sp, #4]
   16004:	685b      	ldr	r3, [r3, #4]
   16006:	9a04      	ldr	r2, [sp, #16]
   16008:	1ad3      	subs	r3, r2, r3
   1600a:	9303      	str	r3, [sp, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   1600c:	9b00      	ldr	r3, [sp, #0]
   1600e:	681b      	ldr	r3, [r3, #0]
   16010:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   16014:	d102      	bne.n	1601c <xTaskCheckForTimeOut+0x2c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   16016:	2300      	movs	r3, #0
   16018:	9305      	str	r3, [sp, #20]
   1601a:	e023      	b.n	16064 <xTaskCheckForTimeOut+0x74>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   1601c:	9b01      	ldr	r3, [sp, #4]
   1601e:	681a      	ldr	r2, [r3, #0]
   16020:	4b15      	ldr	r3, [pc, #84]	; (16078 <xTaskCheckForTimeOut+0x88>)
   16022:	681b      	ldr	r3, [r3, #0]
   16024:	429a      	cmp	r2, r3
   16026:	d007      	beq.n	16038 <xTaskCheckForTimeOut+0x48>
   16028:	9b01      	ldr	r3, [sp, #4]
   1602a:	685b      	ldr	r3, [r3, #4]
   1602c:	9a04      	ldr	r2, [sp, #16]
   1602e:	429a      	cmp	r2, r3
   16030:	d302      	bcc.n	16038 <xTaskCheckForTimeOut+0x48>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   16032:	2301      	movs	r3, #1
   16034:	9305      	str	r3, [sp, #20]
   16036:	e015      	b.n	16064 <xTaskCheckForTimeOut+0x74>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   16038:	9b00      	ldr	r3, [sp, #0]
   1603a:	681b      	ldr	r3, [r3, #0]
   1603c:	9a03      	ldr	r2, [sp, #12]
   1603e:	429a      	cmp	r2, r3
   16040:	d20b      	bcs.n	1605a <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   16042:	9b00      	ldr	r3, [sp, #0]
   16044:	681a      	ldr	r2, [r3, #0]
   16046:	9b03      	ldr	r3, [sp, #12]
   16048:	1ad2      	subs	r2, r2, r3
   1604a:	9b00      	ldr	r3, [sp, #0]
   1604c:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   1604e:	9801      	ldr	r0, [sp, #4]
   16050:	f7ff ffbc 	bl	15fcc <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   16054:	2300      	movs	r3, #0
   16056:	9305      	str	r3, [sp, #20]
   16058:	e004      	b.n	16064 <xTaskCheckForTimeOut+0x74>
		}
		else
		{
			*pxTicksToWait = 0;
   1605a:	9b00      	ldr	r3, [sp, #0]
   1605c:	2200      	movs	r2, #0
   1605e:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   16060:	2301      	movs	r3, #1
   16062:	9305      	str	r3, [sp, #20]
		}
	}
	taskEXIT_CRITICAL();
   16064:	f000 fcda 	bl	16a1c <vPortExitCritical>

	return xReturn;
   16068:	9b05      	ldr	r3, [sp, #20]
}
   1606a:	4618      	mov	r0, r3
   1606c:	b007      	add	sp, #28
   1606e:	f85d fb04 	ldr.w	pc, [sp], #4
   16072:	bf00      	nop
   16074:	1000162c 	.word	0x1000162c
   16078:	10001640 	.word	0x10001640

0001607c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
   1607c:	4b02      	ldr	r3, [pc, #8]	; (16088 <vTaskMissedYield+0xc>)
   1607e:	2201      	movs	r2, #1
   16080:	601a      	str	r2, [r3, #0]
}
   16082:	bf00      	nop
   16084:	4770      	bx	lr
   16086:	bf00      	nop
   16088:	1000163c 	.word	0x1000163c

0001608c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   1608c:	b500      	push	{lr}
   1608e:	b083      	sub	sp, #12
   16090:	9001      	str	r0, [sp, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   16092:	f000 f83f 	bl	16114 <prvCheckTasksWaitingTermination>
   16096:	e7fc      	b.n	16092 <prvIdleTask+0x6>

00016098 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   16098:	b500      	push	{lr}
   1609a:	b083      	sub	sp, #12
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   1609c:	2300      	movs	r3, #0
   1609e:	9301      	str	r3, [sp, #4]
   160a0:	e00c      	b.n	160bc <prvInitialiseTaskLists+0x24>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   160a2:	9a01      	ldr	r2, [sp, #4]
   160a4:	4613      	mov	r3, r2
   160a6:	009b      	lsls	r3, r3, #2
   160a8:	4413      	add	r3, r2
   160aa:	009b      	lsls	r3, r3, #2
   160ac:	4a11      	ldr	r2, [pc, #68]	; (160f4 <prvInitialiseTaskLists+0x5c>)
   160ae:	4413      	add	r3, r2
   160b0:	4618      	mov	r0, r3
   160b2:	f7ff fb35 	bl	15720 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   160b6:	9b01      	ldr	r3, [sp, #4]
   160b8:	3301      	adds	r3, #1
   160ba:	9301      	str	r3, [sp, #4]
   160bc:	9b01      	ldr	r3, [sp, #4]
   160be:	2b04      	cmp	r3, #4
   160c0:	d9ef      	bls.n	160a2 <prvInitialiseTaskLists+0xa>
	}

	vListInitialise( &xDelayedTaskList1 );
   160c2:	480d      	ldr	r0, [pc, #52]	; (160f8 <prvInitialiseTaskLists+0x60>)
   160c4:	f7ff fb2c 	bl	15720 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   160c8:	480c      	ldr	r0, [pc, #48]	; (160fc <prvInitialiseTaskLists+0x64>)
   160ca:	f7ff fb29 	bl	15720 <vListInitialise>
	vListInitialise( &xPendingReadyList );
   160ce:	480c      	ldr	r0, [pc, #48]	; (16100 <prvInitialiseTaskLists+0x68>)
   160d0:	f7ff fb26 	bl	15720 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   160d4:	480b      	ldr	r0, [pc, #44]	; (16104 <prvInitialiseTaskLists+0x6c>)
   160d6:	f7ff fb23 	bl	15720 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   160da:	480b      	ldr	r0, [pc, #44]	; (16108 <prvInitialiseTaskLists+0x70>)
   160dc:	f7ff fb20 	bl	15720 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   160e0:	4b0a      	ldr	r3, [pc, #40]	; (1610c <prvInitialiseTaskLists+0x74>)
   160e2:	4a05      	ldr	r2, [pc, #20]	; (160f8 <prvInitialiseTaskLists+0x60>)
   160e4:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   160e6:	4b0a      	ldr	r3, [pc, #40]	; (16110 <prvInitialiseTaskLists+0x78>)
   160e8:	4a04      	ldr	r2, [pc, #16]	; (160fc <prvInitialiseTaskLists+0x64>)
   160ea:	601a      	str	r2, [r3, #0]
}
   160ec:	bf00      	nop
   160ee:	b003      	add	sp, #12
   160f0:	f85d fb04 	ldr.w	pc, [sp], #4
   160f4:	10001554 	.word	0x10001554
   160f8:	100015b8 	.word	0x100015b8
   160fc:	100015cc 	.word	0x100015cc
   16100:	100015e8 	.word	0x100015e8
   16104:	100015fc 	.word	0x100015fc
   16108:	10001614 	.word	0x10001614
   1610c:	100015e0 	.word	0x100015e0
   16110:	100015e4 	.word	0x100015e4

00016114 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   16114:	b500      	push	{lr}
   16116:	b083      	sub	sp, #12
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   16118:	e019      	b.n	1614e <prvCheckTasksWaitingTermination+0x3a>
		{
			taskENTER_CRITICAL();
   1611a:	f000 fc6b 	bl	169f4 <vPortEnterCritical>
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   1611e:	4b10      	ldr	r3, [pc, #64]	; (16160 <prvCheckTasksWaitingTermination+0x4c>)
   16120:	68db      	ldr	r3, [r3, #12]
   16122:	68db      	ldr	r3, [r3, #12]
   16124:	9301      	str	r3, [sp, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   16126:	9b01      	ldr	r3, [sp, #4]
   16128:	3304      	adds	r3, #4
   1612a:	4618      	mov	r0, r3
   1612c:	f7ff fb6e 	bl	1580c <uxListRemove>
				--uxCurrentNumberOfTasks;
   16130:	4b0c      	ldr	r3, [pc, #48]	; (16164 <prvCheckTasksWaitingTermination+0x50>)
   16132:	681b      	ldr	r3, [r3, #0]
   16134:	3b01      	subs	r3, #1
   16136:	4a0b      	ldr	r2, [pc, #44]	; (16164 <prvCheckTasksWaitingTermination+0x50>)
   16138:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
   1613a:	4b0b      	ldr	r3, [pc, #44]	; (16168 <prvCheckTasksWaitingTermination+0x54>)
   1613c:	681b      	ldr	r3, [r3, #0]
   1613e:	3b01      	subs	r3, #1
   16140:	4a09      	ldr	r2, [pc, #36]	; (16168 <prvCheckTasksWaitingTermination+0x54>)
   16142:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
   16144:	f000 fc6a 	bl	16a1c <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   16148:	9801      	ldr	r0, [sp, #4]
   1614a:	f000 f80f 	bl	1616c <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   1614e:	4b06      	ldr	r3, [pc, #24]	; (16168 <prvCheckTasksWaitingTermination+0x54>)
   16150:	681b      	ldr	r3, [r3, #0]
   16152:	2b00      	cmp	r3, #0
   16154:	d1e1      	bne.n	1611a <prvCheckTasksWaitingTermination+0x6>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   16156:	bf00      	nop
   16158:	b003      	add	sp, #12
   1615a:	f85d fb04 	ldr.w	pc, [sp], #4
   1615e:	bf00      	nop
   16160:	100015fc 	.word	0x100015fc
   16164:	10001628 	.word	0x10001628
   16168:	10001610 	.word	0x10001610

0001616c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   1616c:	b500      	push	{lr}
   1616e:	b083      	sub	sp, #12
   16170:	9001      	str	r0, [sp, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   16172:	9b01      	ldr	r3, [sp, #4]
   16174:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   16178:	2b00      	cmp	r3, #0
   1617a:	d108      	bne.n	1618e <prvDeleteTCB+0x22>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
   1617c:	9b01      	ldr	r3, [sp, #4]
   1617e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   16180:	4618      	mov	r0, r3
   16182:	f000 fcd4 	bl	16b2e <vPortFree>
				vPortFree( pxTCB );
   16186:	9801      	ldr	r0, [sp, #4]
   16188:	f000 fcd1 	bl	16b2e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   1618c:	e007      	b.n	1619e <prvDeleteTCB+0x32>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   1618e:	9b01      	ldr	r3, [sp, #4]
   16190:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   16194:	2b01      	cmp	r3, #1
   16196:	d102      	bne.n	1619e <prvDeleteTCB+0x32>
				vPortFree( pxTCB );
   16198:	9801      	ldr	r0, [sp, #4]
   1619a:	f000 fcc8 	bl	16b2e <vPortFree>
	}
   1619e:	bf00      	nop
   161a0:	b003      	add	sp, #12
   161a2:	f85d fb04 	ldr.w	pc, [sp], #4
   161a6:	Address 0x00000000000161a6 is out of bounds.


000161a8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   161a8:	b082      	sub	sp, #8
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   161aa:	4b0d      	ldr	r3, [pc, #52]	; (161e0 <prvResetNextTaskUnblockTime+0x38>)
   161ac:	681b      	ldr	r3, [r3, #0]
   161ae:	681b      	ldr	r3, [r3, #0]
   161b0:	2b00      	cmp	r3, #0
   161b2:	d101      	bne.n	161b8 <prvResetNextTaskUnblockTime+0x10>
   161b4:	2301      	movs	r3, #1
   161b6:	e000      	b.n	161ba <prvResetNextTaskUnblockTime+0x12>
   161b8:	2300      	movs	r3, #0
   161ba:	2b00      	cmp	r3, #0
   161bc:	d004      	beq.n	161c8 <prvResetNextTaskUnblockTime+0x20>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   161be:	4b09      	ldr	r3, [pc, #36]	; (161e4 <prvResetNextTaskUnblockTime+0x3c>)
   161c0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   161c4:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   161c6:	e008      	b.n	161da <prvResetNextTaskUnblockTime+0x32>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   161c8:	4b05      	ldr	r3, [pc, #20]	; (161e0 <prvResetNextTaskUnblockTime+0x38>)
   161ca:	681b      	ldr	r3, [r3, #0]
   161cc:	68db      	ldr	r3, [r3, #12]
   161ce:	68db      	ldr	r3, [r3, #12]
   161d0:	9301      	str	r3, [sp, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   161d2:	9b01      	ldr	r3, [sp, #4]
   161d4:	685b      	ldr	r3, [r3, #4]
   161d6:	4a03      	ldr	r2, [pc, #12]	; (161e4 <prvResetNextTaskUnblockTime+0x3c>)
   161d8:	6013      	str	r3, [r2, #0]
}
   161da:	bf00      	nop
   161dc:	b002      	add	sp, #8
   161de:	4770      	bx	lr
   161e0:	100015e0 	.word	0x100015e0
   161e4:	10001648 	.word	0x10001648

000161e8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   161e8:	b500      	push	{lr}
   161ea:	b085      	sub	sp, #20
   161ec:	9001      	str	r0, [sp, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   161ee:	9b01      	ldr	r3, [sp, #4]
   161f0:	9302      	str	r3, [sp, #8]
	BaseType_t xReturn = pdFALSE;
   161f2:	2300      	movs	r3, #0
   161f4:	9303      	str	r3, [sp, #12]

		if( pxMutexHolder != NULL )
   161f6:	9b01      	ldr	r3, [sp, #4]
   161f8:	2b00      	cmp	r3, #0
   161fa:	d04f      	beq.n	1629c <xTaskPriorityDisinherit+0xb4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
   161fc:	9b02      	ldr	r3, [sp, #8]
   161fe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   16200:	1e5a      	subs	r2, r3, #1
   16202:	9b02      	ldr	r3, [sp, #8]
   16204:	651a      	str	r2, [r3, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   16206:	9b02      	ldr	r3, [sp, #8]
   16208:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1620a:	9b02      	ldr	r3, [sp, #8]
   1620c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   1620e:	429a      	cmp	r2, r3
   16210:	d044      	beq.n	1629c <xTaskPriorityDisinherit+0xb4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   16212:	9b02      	ldr	r3, [sp, #8]
   16214:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   16216:	2b00      	cmp	r3, #0
   16218:	d140      	bne.n	1629c <xTaskPriorityDisinherit+0xb4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1621a:	9b02      	ldr	r3, [sp, #8]
   1621c:	3304      	adds	r3, #4
   1621e:	4618      	mov	r0, r3
   16220:	f7ff faf4 	bl	1580c <uxListRemove>
   16224:	4603      	mov	r3, r0
   16226:	2b00      	cmp	r3, #0
   16228:	d115      	bne.n	16256 <xTaskPriorityDisinherit+0x6e>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1622a:	9b02      	ldr	r3, [sp, #8]
   1622c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1622e:	491e      	ldr	r1, [pc, #120]	; (162a8 <xTaskPriorityDisinherit+0xc0>)
   16230:	4613      	mov	r3, r2
   16232:	009b      	lsls	r3, r3, #2
   16234:	4413      	add	r3, r2
   16236:	009b      	lsls	r3, r3, #2
   16238:	440b      	add	r3, r1
   1623a:	681b      	ldr	r3, [r3, #0]
   1623c:	2b00      	cmp	r3, #0
   1623e:	d10a      	bne.n	16256 <xTaskPriorityDisinherit+0x6e>
   16240:	9b02      	ldr	r3, [sp, #8]
   16242:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16244:	2201      	movs	r2, #1
   16246:	fa02 f303 	lsl.w	r3, r2, r3
   1624a:	43da      	mvns	r2, r3
   1624c:	4b17      	ldr	r3, [pc, #92]	; (162ac <xTaskPriorityDisinherit+0xc4>)
   1624e:	681b      	ldr	r3, [r3, #0]
   16250:	4013      	ands	r3, r2
   16252:	4a16      	ldr	r2, [pc, #88]	; (162ac <xTaskPriorityDisinherit+0xc4>)
   16254:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   16256:	9b02      	ldr	r3, [sp, #8]
   16258:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   1625a:	9b02      	ldr	r3, [sp, #8]
   1625c:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1625e:	9b02      	ldr	r3, [sp, #8]
   16260:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16262:	f1c3 0205 	rsb	r2, r3, #5
   16266:	9b02      	ldr	r3, [sp, #8]
   16268:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   1626a:	9b02      	ldr	r3, [sp, #8]
   1626c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1626e:	2201      	movs	r2, #1
   16270:	409a      	lsls	r2, r3
   16272:	4b0e      	ldr	r3, [pc, #56]	; (162ac <xTaskPriorityDisinherit+0xc4>)
   16274:	681b      	ldr	r3, [r3, #0]
   16276:	4313      	orrs	r3, r2
   16278:	4a0c      	ldr	r2, [pc, #48]	; (162ac <xTaskPriorityDisinherit+0xc4>)
   1627a:	6013      	str	r3, [r2, #0]
   1627c:	9b02      	ldr	r3, [sp, #8]
   1627e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   16280:	4613      	mov	r3, r2
   16282:	009b      	lsls	r3, r3, #2
   16284:	4413      	add	r3, r2
   16286:	009b      	lsls	r3, r3, #2
   16288:	4a07      	ldr	r2, [pc, #28]	; (162a8 <xTaskPriorityDisinherit+0xc0>)
   1628a:	441a      	add	r2, r3
   1628c:	9b02      	ldr	r3, [sp, #8]
   1628e:	3304      	adds	r3, #4
   16290:	4619      	mov	r1, r3
   16292:	4610      	mov	r0, r2
   16294:	f7ff fa67 	bl	15766 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
   16298:	2301      	movs	r3, #1
   1629a:	9303      	str	r3, [sp, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   1629c:	9b03      	ldr	r3, [sp, #12]
	}
   1629e:	4618      	mov	r0, r3
   162a0:	b005      	add	sp, #20
   162a2:	f85d fb04 	ldr.w	pc, [sp], #4
   162a6:	bf00      	nop
   162a8:	10001554 	.word	0x10001554
   162ac:	10001630 	.word	0x10001630

000162b0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   162b0:	b500      	push	{lr}
   162b2:	b085      	sub	sp, #20
   162b4:	9001      	str	r0, [sp, #4]
   162b6:	9100      	str	r1, [sp, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   162b8:	4b28      	ldr	r3, [pc, #160]	; (1635c <prvAddCurrentTaskToDelayedList+0xac>)
   162ba:	681b      	ldr	r3, [r3, #0]
   162bc:	9303      	str	r3, [sp, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   162be:	4b28      	ldr	r3, [pc, #160]	; (16360 <prvAddCurrentTaskToDelayedList+0xb0>)
   162c0:	681b      	ldr	r3, [r3, #0]
   162c2:	3304      	adds	r3, #4
   162c4:	4618      	mov	r0, r3
   162c6:	f7ff faa1 	bl	1580c <uxListRemove>
   162ca:	4603      	mov	r3, r0
   162cc:	2b00      	cmp	r3, #0
   162ce:	d10b      	bne.n	162e8 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   162d0:	4b23      	ldr	r3, [pc, #140]	; (16360 <prvAddCurrentTaskToDelayedList+0xb0>)
   162d2:	681b      	ldr	r3, [r3, #0]
   162d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   162d6:	2201      	movs	r2, #1
   162d8:	fa02 f303 	lsl.w	r3, r2, r3
   162dc:	43da      	mvns	r2, r3
   162de:	4b21      	ldr	r3, [pc, #132]	; (16364 <prvAddCurrentTaskToDelayedList+0xb4>)
   162e0:	681b      	ldr	r3, [r3, #0]
   162e2:	4013      	ands	r3, r2
   162e4:	4a1f      	ldr	r2, [pc, #124]	; (16364 <prvAddCurrentTaskToDelayedList+0xb4>)
   162e6:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   162e8:	9b01      	ldr	r3, [sp, #4]
   162ea:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   162ee:	d10a      	bne.n	16306 <prvAddCurrentTaskToDelayedList+0x56>
   162f0:	9b00      	ldr	r3, [sp, #0]
   162f2:	2b00      	cmp	r3, #0
   162f4:	d007      	beq.n	16306 <prvAddCurrentTaskToDelayedList+0x56>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   162f6:	4b1a      	ldr	r3, [pc, #104]	; (16360 <prvAddCurrentTaskToDelayedList+0xb0>)
   162f8:	681b      	ldr	r3, [r3, #0]
   162fa:	3304      	adds	r3, #4
   162fc:	4619      	mov	r1, r3
   162fe:	481a      	ldr	r0, [pc, #104]	; (16368 <prvAddCurrentTaskToDelayedList+0xb8>)
   16300:	f7ff fa31 	bl	15766 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   16304:	e026      	b.n	16354 <prvAddCurrentTaskToDelayedList+0xa4>
			xTimeToWake = xConstTickCount + xTicksToWait;
   16306:	9a03      	ldr	r2, [sp, #12]
   16308:	9b01      	ldr	r3, [sp, #4]
   1630a:	4413      	add	r3, r2
   1630c:	9302      	str	r3, [sp, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   1630e:	4b14      	ldr	r3, [pc, #80]	; (16360 <prvAddCurrentTaskToDelayedList+0xb0>)
   16310:	681b      	ldr	r3, [r3, #0]
   16312:	9a02      	ldr	r2, [sp, #8]
   16314:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
   16316:	9a02      	ldr	r2, [sp, #8]
   16318:	9b03      	ldr	r3, [sp, #12]
   1631a:	429a      	cmp	r2, r3
   1631c:	d209      	bcs.n	16332 <prvAddCurrentTaskToDelayedList+0x82>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   1631e:	4b13      	ldr	r3, [pc, #76]	; (1636c <prvAddCurrentTaskToDelayedList+0xbc>)
   16320:	681a      	ldr	r2, [r3, #0]
   16322:	4b0f      	ldr	r3, [pc, #60]	; (16360 <prvAddCurrentTaskToDelayedList+0xb0>)
   16324:	681b      	ldr	r3, [r3, #0]
   16326:	3304      	adds	r3, #4
   16328:	4619      	mov	r1, r3
   1632a:	4610      	mov	r0, r2
   1632c:	f7ff fa3a 	bl	157a4 <vListInsert>
}
   16330:	e010      	b.n	16354 <prvAddCurrentTaskToDelayedList+0xa4>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   16332:	4b0f      	ldr	r3, [pc, #60]	; (16370 <prvAddCurrentTaskToDelayedList+0xc0>)
   16334:	681a      	ldr	r2, [r3, #0]
   16336:	4b0a      	ldr	r3, [pc, #40]	; (16360 <prvAddCurrentTaskToDelayedList+0xb0>)
   16338:	681b      	ldr	r3, [r3, #0]
   1633a:	3304      	adds	r3, #4
   1633c:	4619      	mov	r1, r3
   1633e:	4610      	mov	r0, r2
   16340:	f7ff fa30 	bl	157a4 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   16344:	4b0b      	ldr	r3, [pc, #44]	; (16374 <prvAddCurrentTaskToDelayedList+0xc4>)
   16346:	681b      	ldr	r3, [r3, #0]
   16348:	9a02      	ldr	r2, [sp, #8]
   1634a:	429a      	cmp	r2, r3
   1634c:	d202      	bcs.n	16354 <prvAddCurrentTaskToDelayedList+0xa4>
					xNextTaskUnblockTime = xTimeToWake;
   1634e:	4a09      	ldr	r2, [pc, #36]	; (16374 <prvAddCurrentTaskToDelayedList+0xc4>)
   16350:	9b02      	ldr	r3, [sp, #8]
   16352:	6013      	str	r3, [r2, #0]
}
   16354:	bf00      	nop
   16356:	b005      	add	sp, #20
   16358:	f85d fb04 	ldr.w	pc, [sp], #4
   1635c:	1000162c 	.word	0x1000162c
   16360:	10001550 	.word	0x10001550
   16364:	10001630 	.word	0x10001630
   16368:	10001614 	.word	0x10001614
   1636c:	100015e4 	.word	0x100015e4
   16370:	100015e0 	.word	0x100015e0
   16374:	10001648 	.word	0x10001648

00016378 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   16378:	b500      	push	{lr}
   1637a:	b085      	sub	sp, #20
   1637c:	9001      	str	r0, [sp, #4]
   1637e:	9100      	str	r1, [sp, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   16380:	9b01      	ldr	r3, [sp, #4]
   16382:	9303      	str	r3, [sp, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   16384:	f000 fb36 	bl	169f4 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   16388:	9b03      	ldr	r3, [sp, #12]
   1638a:	681a      	ldr	r2, [r3, #0]
   1638c:	9b03      	ldr	r3, [sp, #12]
   1638e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   16390:	9903      	ldr	r1, [sp, #12]
   16392:	6c09      	ldr	r1, [r1, #64]	; 0x40
   16394:	fb01 f303 	mul.w	r3, r1, r3
   16398:	441a      	add	r2, r3
   1639a:	9b03      	ldr	r3, [sp, #12]
   1639c:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   1639e:	9b03      	ldr	r3, [sp, #12]
   163a0:	2200      	movs	r2, #0
   163a2:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   163a4:	9b03      	ldr	r3, [sp, #12]
   163a6:	681a      	ldr	r2, [r3, #0]
   163a8:	9b03      	ldr	r3, [sp, #12]
   163aa:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   163ac:	9b03      	ldr	r3, [sp, #12]
   163ae:	681a      	ldr	r2, [r3, #0]
   163b0:	9b03      	ldr	r3, [sp, #12]
   163b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   163b4:	3b01      	subs	r3, #1
   163b6:	9903      	ldr	r1, [sp, #12]
   163b8:	6c09      	ldr	r1, [r1, #64]	; 0x40
   163ba:	fb01 f303 	mul.w	r3, r1, r3
   163be:	441a      	add	r2, r3
   163c0:	9b03      	ldr	r3, [sp, #12]
   163c2:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   163c4:	9b03      	ldr	r3, [sp, #12]
   163c6:	22ff      	movs	r2, #255	; 0xff
   163c8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   163cc:	9b03      	ldr	r3, [sp, #12]
   163ce:	22ff      	movs	r2, #255	; 0xff
   163d0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
   163d4:	9b00      	ldr	r3, [sp, #0]
   163d6:	2b00      	cmp	r3, #0
   163d8:	d114      	bne.n	16404 <xQueueGenericReset+0x8c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   163da:	9b03      	ldr	r3, [sp, #12]
   163dc:	691b      	ldr	r3, [r3, #16]
   163de:	2b00      	cmp	r3, #0
   163e0:	d01a      	beq.n	16418 <xQueueGenericReset+0xa0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   163e2:	9b03      	ldr	r3, [sp, #12]
   163e4:	3310      	adds	r3, #16
   163e6:	4618      	mov	r0, r3
   163e8:	f7ff fd9c 	bl	15f24 <xTaskRemoveFromEventList>
   163ec:	4603      	mov	r3, r0
   163ee:	2b00      	cmp	r3, #0
   163f0:	d012      	beq.n	16418 <xQueueGenericReset+0xa0>
				{
					queueYIELD_IF_USING_PREEMPTION();
   163f2:	4b0d      	ldr	r3, [pc, #52]	; (16428 <xQueueGenericReset+0xb0>)
   163f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   163f8:	601a      	str	r2, [r3, #0]
   163fa:	f3bf 8f4f 	dsb	sy
   163fe:	f3bf 8f6f 	isb	sy
   16402:	e009      	b.n	16418 <xQueueGenericReset+0xa0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   16404:	9b03      	ldr	r3, [sp, #12]
   16406:	3310      	adds	r3, #16
   16408:	4618      	mov	r0, r3
   1640a:	f7ff f989 	bl	15720 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   1640e:	9b03      	ldr	r3, [sp, #12]
   16410:	3324      	adds	r3, #36	; 0x24
   16412:	4618      	mov	r0, r3
   16414:	f7ff f984 	bl	15720 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   16418:	f000 fb00 	bl	16a1c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   1641c:	2301      	movs	r3, #1
}
   1641e:	4618      	mov	r0, r3
   16420:	b005      	add	sp, #20
   16422:	f85d fb04 	ldr.w	pc, [sp], #4
   16426:	bf00      	nop
   16428:	e000ed04 	.word	0xe000ed04

0001642c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
   1642c:	b500      	push	{lr}
   1642e:	b08b      	sub	sp, #44	; 0x2c
   16430:	9005      	str	r0, [sp, #20]
   16432:	9104      	str	r1, [sp, #16]
   16434:	4613      	mov	r3, r2
   16436:	f88d 300f 	strb.w	r3, [sp, #15]
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
   1643a:	9b04      	ldr	r3, [sp, #16]
   1643c:	2b00      	cmp	r3, #0
   1643e:	d102      	bne.n	16446 <xQueueGenericCreate+0x1a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
   16440:	2300      	movs	r3, #0
   16442:	9309      	str	r3, [sp, #36]	; 0x24
   16444:	e004      	b.n	16450 <xQueueGenericCreate+0x24>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   16446:	9b05      	ldr	r3, [sp, #20]
   16448:	9a04      	ldr	r2, [sp, #16]
   1644a:	fb02 f303 	mul.w	r3, r2, r3
   1644e:	9309      	str	r3, [sp, #36]	; 0x24
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   16450:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16452:	3350      	adds	r3, #80	; 0x50
   16454:	4618      	mov	r0, r3
   16456:	f000 fb59 	bl	16b0c <pvPortMalloc>
   1645a:	9008      	str	r0, [sp, #32]

		if( pxNewQueue != NULL )
   1645c:	9b08      	ldr	r3, [sp, #32]
   1645e:	2b00      	cmp	r3, #0
   16460:	d010      	beq.n	16484 <xQueueGenericCreate+0x58>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   16462:	9b08      	ldr	r3, [sp, #32]
   16464:	3350      	adds	r3, #80	; 0x50
   16466:	9307      	str	r3, [sp, #28]
			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
   16468:	9b08      	ldr	r3, [sp, #32]
   1646a:	2200      	movs	r2, #0
   1646c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   16470:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16474:	9b08      	ldr	r3, [sp, #32]
   16476:	9300      	str	r3, [sp, #0]
   16478:	4613      	mov	r3, r2
   1647a:	9a07      	ldr	r2, [sp, #28]
   1647c:	9904      	ldr	r1, [sp, #16]
   1647e:	9805      	ldr	r0, [sp, #20]
   16480:	f000 f805 	bl	1648e <prvInitialiseNewQueue>
		else
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
   16484:	9b08      	ldr	r3, [sp, #32]
	}
   16486:	4618      	mov	r0, r3
   16488:	b00b      	add	sp, #44	; 0x2c
   1648a:	f85d fb04 	ldr.w	pc, [sp], #4

0001648e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
   1648e:	b500      	push	{lr}
   16490:	b085      	sub	sp, #20
   16492:	9003      	str	r0, [sp, #12]
   16494:	9102      	str	r1, [sp, #8]
   16496:	9201      	str	r2, [sp, #4]
   16498:	f88d 3003 	strb.w	r3, [sp, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
   1649c:	9b02      	ldr	r3, [sp, #8]
   1649e:	2b00      	cmp	r3, #0
   164a0:	d103      	bne.n	164aa <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   164a2:	9b06      	ldr	r3, [sp, #24]
   164a4:	9a06      	ldr	r2, [sp, #24]
   164a6:	601a      	str	r2, [r3, #0]
   164a8:	e002      	b.n	164b0 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   164aa:	9b06      	ldr	r3, [sp, #24]
   164ac:	9a01      	ldr	r2, [sp, #4]
   164ae:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
   164b0:	9b06      	ldr	r3, [sp, #24]
   164b2:	9a03      	ldr	r2, [sp, #12]
   164b4:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   164b6:	9b06      	ldr	r3, [sp, #24]
   164b8:	9a02      	ldr	r2, [sp, #8]
   164ba:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   164bc:	2101      	movs	r1, #1
   164be:	9806      	ldr	r0, [sp, #24]
   164c0:	f7ff ff5a 	bl	16378 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
   164c4:	9b06      	ldr	r3, [sp, #24]
   164c6:	f89d 2003 	ldrb.w	r2, [sp, #3]
   164ca:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
   164ce:	bf00      	nop
   164d0:	b005      	add	sp, #20
   164d2:	f85d fb04 	ldr.w	pc, [sp], #4

000164d6 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
   164d6:	b500      	push	{lr}
   164d8:	b08d      	sub	sp, #52	; 0x34
   164da:	9003      	str	r0, [sp, #12]
   164dc:	9102      	str	r1, [sp, #8]
   164de:	9201      	str	r2, [sp, #4]
   164e0:	9300      	str	r3, [sp, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   164e2:	9b03      	ldr	r3, [sp, #12]
   164e4:	930a      	str	r3, [sp, #40]	; 0x28

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   164e6:	f3ef 8211 	mrs	r2, BASEPRI
   164ea:	f04f 0328 	mov.w	r3, #40	; 0x28
   164ee:	f383 8811 	msr	BASEPRI, r3
   164f2:	f3bf 8f6f 	isb	sy
   164f6:	f3bf 8f4f 	dsb	sy
   164fa:	9207      	str	r2, [sp, #28]
   164fc:	9306      	str	r3, [sp, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   164fe:	9b07      	ldr	r3, [sp, #28]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   16500:	9309      	str	r3, [sp, #36]	; 0x24
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   16502:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16504:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   16506:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16508:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1650a:	429a      	cmp	r2, r3
   1650c:	d302      	bcc.n	16514 <xQueueGenericSendFromISR+0x3e>
   1650e:	9b00      	ldr	r3, [sp, #0]
   16510:	2b02      	cmp	r3, #2
   16512:	d12c      	bne.n	1656e <xQueueGenericSendFromISR+0x98>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   16514:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16516:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   1651a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   1651e:	9a00      	ldr	r2, [sp, #0]
   16520:	9902      	ldr	r1, [sp, #8]
   16522:	980a      	ldr	r0, [sp, #40]	; 0x28
   16524:	f000 f8d0 	bl	166c8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   16528:	f99d 3023 	ldrsb.w	r3, [sp, #35]	; 0x23
   1652c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   16530:	d112      	bne.n	16558 <xQueueGenericSendFromISR+0x82>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   16532:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16534:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   16536:	2b00      	cmp	r3, #0
   16538:	d016      	beq.n	16568 <xQueueGenericSendFromISR+0x92>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1653a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1653c:	3324      	adds	r3, #36	; 0x24
   1653e:	4618      	mov	r0, r3
   16540:	f7ff fcf0 	bl	15f24 <xTaskRemoveFromEventList>
   16544:	4603      	mov	r3, r0
   16546:	2b00      	cmp	r3, #0
   16548:	d00e      	beq.n	16568 <xQueueGenericSendFromISR+0x92>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   1654a:	9b01      	ldr	r3, [sp, #4]
   1654c:	2b00      	cmp	r3, #0
   1654e:	d00b      	beq.n	16568 <xQueueGenericSendFromISR+0x92>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   16550:	9b01      	ldr	r3, [sp, #4]
   16552:	2201      	movs	r2, #1
   16554:	601a      	str	r2, [r3, #0]
   16556:	e007      	b.n	16568 <xQueueGenericSendFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   16558:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   1655c:	3301      	adds	r3, #1
   1655e:	b2db      	uxtb	r3, r3
   16560:	b25a      	sxtb	r2, r3
   16562:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16564:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
   16568:	2301      	movs	r3, #1
   1656a:	930b      	str	r3, [sp, #44]	; 0x2c
		{
   1656c:	e001      	b.n	16572 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   1656e:	2300      	movs	r3, #0
   16570:	930b      	str	r3, [sp, #44]	; 0x2c
   16572:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16574:	9305      	str	r3, [sp, #20]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   16576:	9b05      	ldr	r3, [sp, #20]
   16578:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   1657c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
   1657e:	4618      	mov	r0, r3
   16580:	b00d      	add	sp, #52	; 0x34
   16582:	f85d fb04 	ldr.w	pc, [sp], #4
   16586:	Address 0x0000000000016586 is out of bounds.


00016588 <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
   16588:	b500      	push	{lr}
   1658a:	b08b      	sub	sp, #44	; 0x2c
   1658c:	9003      	str	r0, [sp, #12]
   1658e:	9102      	str	r1, [sp, #8]
   16590:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
   16592:	2300      	movs	r3, #0
   16594:	9309      	str	r3, [sp, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   16596:	9b03      	ldr	r3, [sp, #12]
   16598:	9308      	str	r3, [sp, #32]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   1659a:	f000 fa2b 	bl	169f4 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1659e:	9b08      	ldr	r3, [sp, #32]
   165a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   165a2:	9307      	str	r3, [sp, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   165a4:	9b07      	ldr	r3, [sp, #28]
   165a6:	2b00      	cmp	r3, #0
   165a8:	d01f      	beq.n	165ea <xQueueReceive+0x62>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
   165aa:	9902      	ldr	r1, [sp, #8]
   165ac:	9808      	ldr	r0, [sp, #32]
   165ae:	f000 f8f4 	bl	1679a <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   165b2:	9b07      	ldr	r3, [sp, #28]
   165b4:	1e5a      	subs	r2, r3, #1
   165b6:	9b08      	ldr	r3, [sp, #32]
   165b8:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   165ba:	9b08      	ldr	r3, [sp, #32]
   165bc:	691b      	ldr	r3, [r3, #16]
   165be:	2b00      	cmp	r3, #0
   165c0:	d00f      	beq.n	165e2 <xQueueReceive+0x5a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   165c2:	9b08      	ldr	r3, [sp, #32]
   165c4:	3310      	adds	r3, #16
   165c6:	4618      	mov	r0, r3
   165c8:	f7ff fcac 	bl	15f24 <xTaskRemoveFromEventList>
   165cc:	4603      	mov	r3, r0
   165ce:	2b00      	cmp	r3, #0
   165d0:	d007      	beq.n	165e2 <xQueueReceive+0x5a>
					{
						queueYIELD_IF_USING_PREEMPTION();
   165d2:	4b3c      	ldr	r3, [pc, #240]	; (166c4 <xQueueReceive+0x13c>)
   165d4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   165d8:	601a      	str	r2, [r3, #0]
   165da:	f3bf 8f4f 	dsb	sy
   165de:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   165e2:	f000 fa1b 	bl	16a1c <vPortExitCritical>
				return pdPASS;
   165e6:	2301      	movs	r3, #1
   165e8:	e067      	b.n	166ba <xQueueReceive+0x132>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   165ea:	9b01      	ldr	r3, [sp, #4]
   165ec:	2b00      	cmp	r3, #0
   165ee:	d103      	bne.n	165f8 <xQueueReceive+0x70>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   165f0:	f000 fa14 	bl	16a1c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   165f4:	2300      	movs	r3, #0
   165f6:	e060      	b.n	166ba <xQueueReceive+0x132>
				}
				else if( xEntryTimeSet == pdFALSE )
   165f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   165fa:	2b00      	cmp	r3, #0
   165fc:	d105      	bne.n	1660a <xQueueReceive+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   165fe:	ab05      	add	r3, sp, #20
   16600:	4618      	mov	r0, r3
   16602:	f7ff fce3 	bl	15fcc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   16606:	2301      	movs	r3, #1
   16608:	9309      	str	r3, [sp, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   1660a:	f000 fa07 	bl	16a1c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   1660e:	f7ff facd 	bl	15bac <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   16612:	f000 f9ef 	bl	169f4 <vPortEnterCritical>
   16616:	9b08      	ldr	r3, [sp, #32]
   16618:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   1661c:	b25b      	sxtb	r3, r3
   1661e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   16622:	d103      	bne.n	1662c <xQueueReceive+0xa4>
   16624:	9b08      	ldr	r3, [sp, #32]
   16626:	2200      	movs	r2, #0
   16628:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   1662c:	9b08      	ldr	r3, [sp, #32]
   1662e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   16632:	b25b      	sxtb	r3, r3
   16634:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   16638:	d103      	bne.n	16642 <xQueueReceive+0xba>
   1663a:	9b08      	ldr	r3, [sp, #32]
   1663c:	2200      	movs	r2, #0
   1663e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   16642:	f000 f9eb 	bl	16a1c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   16646:	aa01      	add	r2, sp, #4
   16648:	ab05      	add	r3, sp, #20
   1664a:	4611      	mov	r1, r2
   1664c:	4618      	mov	r0, r3
   1664e:	f7ff fccf 	bl	15ff0 <xTaskCheckForTimeOut>
   16652:	4603      	mov	r3, r0
   16654:	2b00      	cmp	r3, #0
   16656:	d123      	bne.n	166a0 <xQueueReceive+0x118>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   16658:	9808      	ldr	r0, [sp, #32]
   1665a:	f000 f91a 	bl	16892 <prvIsQueueEmpty>
   1665e:	4603      	mov	r3, r0
   16660:	2b00      	cmp	r3, #0
   16662:	d017      	beq.n	16694 <xQueueReceive+0x10c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   16664:	9b08      	ldr	r3, [sp, #32]
   16666:	3324      	adds	r3, #36	; 0x24
   16668:	9a01      	ldr	r2, [sp, #4]
   1666a:	4611      	mov	r1, r2
   1666c:	4618      	mov	r0, r3
   1666e:	f7ff fc43 	bl	15ef8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   16672:	9808      	ldr	r0, [sp, #32]
   16674:	f000 f8b6 	bl	167e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   16678:	f7ff faa2 	bl	15bc0 <xTaskResumeAll>
   1667c:	4603      	mov	r3, r0
   1667e:	2b00      	cmp	r3, #0
   16680:	d18b      	bne.n	1659a <xQueueReceive+0x12>
				{
					portYIELD_WITHIN_API();
   16682:	4b10      	ldr	r3, [pc, #64]	; (166c4 <xQueueReceive+0x13c>)
   16684:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   16688:	601a      	str	r2, [r3, #0]
   1668a:	f3bf 8f4f 	dsb	sy
   1668e:	f3bf 8f6f 	isb	sy
   16692:	e782      	b.n	1659a <xQueueReceive+0x12>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
   16694:	9808      	ldr	r0, [sp, #32]
   16696:	f000 f8a5 	bl	167e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   1669a:	f7ff fa91 	bl	15bc0 <xTaskResumeAll>
   1669e:	e77c      	b.n	1659a <xQueueReceive+0x12>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
   166a0:	9808      	ldr	r0, [sp, #32]
   166a2:	f000 f89f 	bl	167e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   166a6:	f7ff fa8b 	bl	15bc0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   166aa:	9808      	ldr	r0, [sp, #32]
   166ac:	f000 f8f1 	bl	16892 <prvIsQueueEmpty>
   166b0:	4603      	mov	r3, r0
   166b2:	2b00      	cmp	r3, #0
   166b4:	f43f af71 	beq.w	1659a <xQueueReceive+0x12>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   166b8:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
   166ba:	4618      	mov	r0, r3
   166bc:	b00b      	add	sp, #44	; 0x2c
   166be:	f85d fb04 	ldr.w	pc, [sp], #4
   166c2:	bf00      	nop
   166c4:	e000ed04 	.word	0xe000ed04

000166c8 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   166c8:	b500      	push	{lr}
   166ca:	b087      	sub	sp, #28
   166cc:	9003      	str	r0, [sp, #12]
   166ce:	9102      	str	r1, [sp, #8]
   166d0:	9201      	str	r2, [sp, #4]
BaseType_t xReturn = pdFALSE;
   166d2:	2300      	movs	r3, #0
   166d4:	9305      	str	r3, [sp, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   166d6:	9b03      	ldr	r3, [sp, #12]
   166d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   166da:	9304      	str	r3, [sp, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   166dc:	9b03      	ldr	r3, [sp, #12]
   166de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   166e0:	2b00      	cmp	r3, #0
   166e2:	d10d      	bne.n	16700 <prvCopyDataToQueue+0x38>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   166e4:	9b03      	ldr	r3, [sp, #12]
   166e6:	681b      	ldr	r3, [r3, #0]
   166e8:	2b00      	cmp	r3, #0
   166ea:	d14d      	bne.n	16788 <prvCopyDataToQueue+0xc0>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   166ec:	9b03      	ldr	r3, [sp, #12]
   166ee:	685b      	ldr	r3, [r3, #4]
   166f0:	4618      	mov	r0, r3
   166f2:	f7ff fd79 	bl	161e8 <xTaskPriorityDisinherit>
   166f6:	9005      	str	r0, [sp, #20]
				pxQueue->pxMutexHolder = NULL;
   166f8:	9b03      	ldr	r3, [sp, #12]
   166fa:	2200      	movs	r2, #0
   166fc:	605a      	str	r2, [r3, #4]
   166fe:	e043      	b.n	16788 <prvCopyDataToQueue+0xc0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   16700:	9b01      	ldr	r3, [sp, #4]
   16702:	2b00      	cmp	r3, #0
   16704:	d119      	bne.n	1673a <prvCopyDataToQueue+0x72>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   16706:	9b03      	ldr	r3, [sp, #12]
   16708:	6898      	ldr	r0, [r3, #8]
   1670a:	9b03      	ldr	r3, [sp, #12]
   1670c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1670e:	461a      	mov	r2, r3
   16710:	9902      	ldr	r1, [sp, #8]
   16712:	f003 f8d7 	bl	198c4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   16716:	9b03      	ldr	r3, [sp, #12]
   16718:	689a      	ldr	r2, [r3, #8]
   1671a:	9b03      	ldr	r3, [sp, #12]
   1671c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1671e:	441a      	add	r2, r3
   16720:	9b03      	ldr	r3, [sp, #12]
   16722:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   16724:	9b03      	ldr	r3, [sp, #12]
   16726:	689a      	ldr	r2, [r3, #8]
   16728:	9b03      	ldr	r3, [sp, #12]
   1672a:	685b      	ldr	r3, [r3, #4]
   1672c:	429a      	cmp	r2, r3
   1672e:	d32b      	bcc.n	16788 <prvCopyDataToQueue+0xc0>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   16730:	9b03      	ldr	r3, [sp, #12]
   16732:	681a      	ldr	r2, [r3, #0]
   16734:	9b03      	ldr	r3, [sp, #12]
   16736:	609a      	str	r2, [r3, #8]
   16738:	e026      	b.n	16788 <prvCopyDataToQueue+0xc0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1673a:	9b03      	ldr	r3, [sp, #12]
   1673c:	68d8      	ldr	r0, [r3, #12]
   1673e:	9b03      	ldr	r3, [sp, #12]
   16740:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   16742:	461a      	mov	r2, r3
   16744:	9902      	ldr	r1, [sp, #8]
   16746:	f003 f8bd 	bl	198c4 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   1674a:	9b03      	ldr	r3, [sp, #12]
   1674c:	68da      	ldr	r2, [r3, #12]
   1674e:	9b03      	ldr	r3, [sp, #12]
   16750:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   16752:	425b      	negs	r3, r3
   16754:	441a      	add	r2, r3
   16756:	9b03      	ldr	r3, [sp, #12]
   16758:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1675a:	9b03      	ldr	r3, [sp, #12]
   1675c:	68da      	ldr	r2, [r3, #12]
   1675e:	9b03      	ldr	r3, [sp, #12]
   16760:	681b      	ldr	r3, [r3, #0]
   16762:	429a      	cmp	r2, r3
   16764:	d207      	bcs.n	16776 <prvCopyDataToQueue+0xae>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   16766:	9b03      	ldr	r3, [sp, #12]
   16768:	685a      	ldr	r2, [r3, #4]
   1676a:	9b03      	ldr	r3, [sp, #12]
   1676c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1676e:	425b      	negs	r3, r3
   16770:	441a      	add	r2, r3
   16772:	9b03      	ldr	r3, [sp, #12]
   16774:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   16776:	9b01      	ldr	r3, [sp, #4]
   16778:	2b02      	cmp	r3, #2
   1677a:	d105      	bne.n	16788 <prvCopyDataToQueue+0xc0>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1677c:	9b04      	ldr	r3, [sp, #16]
   1677e:	2b00      	cmp	r3, #0
   16780:	d002      	beq.n	16788 <prvCopyDataToQueue+0xc0>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   16782:	9b04      	ldr	r3, [sp, #16]
   16784:	3b01      	subs	r3, #1
   16786:	9304      	str	r3, [sp, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   16788:	9b04      	ldr	r3, [sp, #16]
   1678a:	1c5a      	adds	r2, r3, #1
   1678c:	9b03      	ldr	r3, [sp, #12]
   1678e:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   16790:	9b05      	ldr	r3, [sp, #20]
}
   16792:	4618      	mov	r0, r3
   16794:	b007      	add	sp, #28
   16796:	f85d fb04 	ldr.w	pc, [sp], #4

0001679a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   1679a:	b500      	push	{lr}
   1679c:	b083      	sub	sp, #12
   1679e:	9001      	str	r0, [sp, #4]
   167a0:	9100      	str	r1, [sp, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   167a2:	9b01      	ldr	r3, [sp, #4]
   167a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   167a6:	2b00      	cmp	r3, #0
   167a8:	d018      	beq.n	167dc <prvCopyDataFromQueue+0x42>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   167aa:	9b01      	ldr	r3, [sp, #4]
   167ac:	68da      	ldr	r2, [r3, #12]
   167ae:	9b01      	ldr	r3, [sp, #4]
   167b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   167b2:	441a      	add	r2, r3
   167b4:	9b01      	ldr	r3, [sp, #4]
   167b6:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   167b8:	9b01      	ldr	r3, [sp, #4]
   167ba:	68da      	ldr	r2, [r3, #12]
   167bc:	9b01      	ldr	r3, [sp, #4]
   167be:	685b      	ldr	r3, [r3, #4]
   167c0:	429a      	cmp	r2, r3
   167c2:	d303      	bcc.n	167cc <prvCopyDataFromQueue+0x32>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   167c4:	9b01      	ldr	r3, [sp, #4]
   167c6:	681a      	ldr	r2, [r3, #0]
   167c8:	9b01      	ldr	r3, [sp, #4]
   167ca:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   167cc:	9b01      	ldr	r3, [sp, #4]
   167ce:	68d9      	ldr	r1, [r3, #12]
   167d0:	9b01      	ldr	r3, [sp, #4]
   167d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   167d4:	461a      	mov	r2, r3
   167d6:	9800      	ldr	r0, [sp, #0]
   167d8:	f003 f874 	bl	198c4 <memcpy>
	}
}
   167dc:	bf00      	nop
   167de:	b003      	add	sp, #12
   167e0:	f85d fb04 	ldr.w	pc, [sp], #4

000167e4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   167e4:	b500      	push	{lr}
   167e6:	b085      	sub	sp, #20
   167e8:	9001      	str	r0, [sp, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   167ea:	f000 f903 	bl	169f4 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   167ee:	9b01      	ldr	r3, [sp, #4]
   167f0:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   167f4:	f88d 300f 	strb.w	r3, [sp, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   167f8:	e013      	b.n	16822 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   167fa:	9b01      	ldr	r3, [sp, #4]
   167fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   167fe:	2b00      	cmp	r3, #0
   16800:	d014      	beq.n	1682c <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   16802:	9b01      	ldr	r3, [sp, #4]
   16804:	3324      	adds	r3, #36	; 0x24
   16806:	4618      	mov	r0, r3
   16808:	f7ff fb8c 	bl	15f24 <xTaskRemoveFromEventList>
   1680c:	4603      	mov	r3, r0
   1680e:	2b00      	cmp	r3, #0
   16810:	d001      	beq.n	16816 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   16812:	f7ff fc33 	bl	1607c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   16816:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1681a:	3b01      	subs	r3, #1
   1681c:	b2db      	uxtb	r3, r3
   1681e:	f88d 300f 	strb.w	r3, [sp, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
   16822:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   16826:	2b00      	cmp	r3, #0
   16828:	dce7      	bgt.n	167fa <prvUnlockQueue+0x16>
   1682a:	e000      	b.n	1682e <prvUnlockQueue+0x4a>
					break;
   1682c:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
   1682e:	9b01      	ldr	r3, [sp, #4]
   16830:	22ff      	movs	r2, #255	; 0xff
   16832:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
   16836:	f000 f8f1 	bl	16a1c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   1683a:	f000 f8db 	bl	169f4 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   1683e:	9b01      	ldr	r3, [sp, #4]
   16840:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   16844:	f88d 300e 	strb.w	r3, [sp, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   16848:	e013      	b.n	16872 <prvUnlockQueue+0x8e>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1684a:	9b01      	ldr	r3, [sp, #4]
   1684c:	691b      	ldr	r3, [r3, #16]
   1684e:	2b00      	cmp	r3, #0
   16850:	d014      	beq.n	1687c <prvUnlockQueue+0x98>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   16852:	9b01      	ldr	r3, [sp, #4]
   16854:	3310      	adds	r3, #16
   16856:	4618      	mov	r0, r3
   16858:	f7ff fb64 	bl	15f24 <xTaskRemoveFromEventList>
   1685c:	4603      	mov	r3, r0
   1685e:	2b00      	cmp	r3, #0
   16860:	d001      	beq.n	16866 <prvUnlockQueue+0x82>
				{
					vTaskMissedYield();
   16862:	f7ff fc0b 	bl	1607c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   16866:	f89d 300e 	ldrb.w	r3, [sp, #14]
   1686a:	3b01      	subs	r3, #1
   1686c:	b2db      	uxtb	r3, r3
   1686e:	f88d 300e 	strb.w	r3, [sp, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
   16872:	f99d 300e 	ldrsb.w	r3, [sp, #14]
   16876:	2b00      	cmp	r3, #0
   16878:	dce7      	bgt.n	1684a <prvUnlockQueue+0x66>
   1687a:	e000      	b.n	1687e <prvUnlockQueue+0x9a>
			}
			else
			{
				break;
   1687c:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   1687e:	9b01      	ldr	r3, [sp, #4]
   16880:	22ff      	movs	r2, #255	; 0xff
   16882:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   16886:	f000 f8c9 	bl	16a1c <vPortExitCritical>
}
   1688a:	bf00      	nop
   1688c:	b005      	add	sp, #20
   1688e:	f85d fb04 	ldr.w	pc, [sp], #4

00016892 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   16892:	b500      	push	{lr}
   16894:	b085      	sub	sp, #20
   16896:	9001      	str	r0, [sp, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   16898:	f000 f8ac 	bl	169f4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   1689c:	9b01      	ldr	r3, [sp, #4]
   1689e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   168a0:	2b00      	cmp	r3, #0
   168a2:	d102      	bne.n	168aa <prvIsQueueEmpty+0x18>
		{
			xReturn = pdTRUE;
   168a4:	2301      	movs	r3, #1
   168a6:	9303      	str	r3, [sp, #12]
   168a8:	e001      	b.n	168ae <prvIsQueueEmpty+0x1c>
		}
		else
		{
			xReturn = pdFALSE;
   168aa:	2300      	movs	r3, #0
   168ac:	9303      	str	r3, [sp, #12]
		}
	}
	taskEXIT_CRITICAL();
   168ae:	f000 f8b5 	bl	16a1c <vPortExitCritical>

	return xReturn;
   168b2:	9b03      	ldr	r3, [sp, #12]
}
   168b4:	4618      	mov	r0, r3
   168b6:	b005      	add	sp, #20
   168b8:	f85d fb04 	ldr.w	pc, [sp], #4

000168bc <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   168bc:	b084      	sub	sp, #16
   168be:	9003      	str	r0, [sp, #12]
   168c0:	9102      	str	r1, [sp, #8]
   168c2:	9201      	str	r2, [sp, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
   168c4:	9b03      	ldr	r3, [sp, #12]
   168c6:	3b04      	subs	r3, #4
   168c8:	9303      	str	r3, [sp, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   168ca:	9b03      	ldr	r3, [sp, #12]
   168cc:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   168d0:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   168d2:	9b03      	ldr	r3, [sp, #12]
   168d4:	3b04      	subs	r3, #4
   168d6:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   168d8:	9b02      	ldr	r3, [sp, #8]
   168da:	f023 0201 	bic.w	r2, r3, #1
   168de:	9b03      	ldr	r3, [sp, #12]
   168e0:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   168e2:	9b03      	ldr	r3, [sp, #12]
   168e4:	3b04      	subs	r3, #4
   168e6:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   168e8:	4a0b      	ldr	r2, [pc, #44]	; (16918 <pxPortInitialiseStack+0x5c>)
   168ea:	9b03      	ldr	r3, [sp, #12]
   168ec:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   168ee:	9b03      	ldr	r3, [sp, #12]
   168f0:	3b14      	subs	r3, #20
   168f2:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   168f4:	9a01      	ldr	r2, [sp, #4]
   168f6:	9b03      	ldr	r3, [sp, #12]
   168f8:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
   168fa:	9b03      	ldr	r3, [sp, #12]
   168fc:	3b04      	subs	r3, #4
   168fe:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   16900:	9b03      	ldr	r3, [sp, #12]
   16902:	f06f 0202 	mvn.w	r2, #2
   16906:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   16908:	9b03      	ldr	r3, [sp, #12]
   1690a:	3b20      	subs	r3, #32
   1690c:	9303      	str	r3, [sp, #12]

	return pxTopOfStack;
   1690e:	9b03      	ldr	r3, [sp, #12]
}
   16910:	4618      	mov	r0, r3
   16912:	b004      	add	sp, #16
   16914:	4770      	bx	lr
   16916:	bf00      	nop
   16918:	0001691d 	.word	0x0001691d

0001691c <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   1691c:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   1691e:	2300      	movs	r3, #0
   16920:	9300      	str	r3, [sp, #0]
	__asm volatile
   16922:	f04f 0328 	mov.w	r3, #40	; 0x28
   16926:	f383 8811 	msr	BASEPRI, r3
   1692a:	f3bf 8f6f 	isb	sy
   1692e:	f3bf 8f4f 	dsb	sy
   16932:	9301      	str	r3, [sp, #4]

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   16934:	bf00      	nop
   16936:	9b00      	ldr	r3, [sp, #0]
   16938:	2b00      	cmp	r3, #0
   1693a:	d0fc      	beq.n	16936 <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   1693c:	bf00      	nop
   1693e:	b002      	add	sp, #8
   16940:	4770      	bx	lr
   16942:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   16946:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1694a:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1694e:	Address 0x000000000001694e is out of bounds.


00016950 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   16950:	4b07      	ldr	r3, [pc, #28]	; (16970 <pxCurrentTCBConst2>)
   16952:	6819      	ldr	r1, [r3, #0]
   16954:	6808      	ldr	r0, [r1, #0]
   16956:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1695a:	f380 8809 	msr	PSP, r0
   1695e:	f3bf 8f6f 	isb	sy
   16962:	f04f 0000 	mov.w	r0, #0
   16966:	f380 8811 	msr	BASEPRI, r0
   1696a:	4770      	bx	lr
   1696c:	f3af 8000 	nop.w

00016970 <pxCurrentTCBConst2>:
   16970:	10001550 	.word	0x10001550
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   16974:	bf00      	nop
   16976:	bf00      	nop

00016978 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
   16978:	4808      	ldr	r0, [pc, #32]	; (1699c <prvPortStartFirstTask+0x24>)
   1697a:	6800      	ldr	r0, [r0, #0]
   1697c:	6800      	ldr	r0, [r0, #0]
   1697e:	f380 8808 	msr	MSP, r0
   16982:	f04f 0000 	mov.w	r0, #0
   16986:	f380 8814 	msr	CONTROL, r0
   1698a:	b662      	cpsie	i
   1698c:	b661      	cpsie	f
   1698e:	f3bf 8f4f 	dsb	sy
   16992:	f3bf 8f6f 	isb	sy
   16996:	df00      	svc	0
   16998:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
   1699a:	bf00      	nop
   1699c:	e000ed08 	.word	0xe000ed08

000169a0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   169a0:	b508      	push	{r3, lr}
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   169a2:	4b11      	ldr	r3, [pc, #68]	; (169e8 <xPortStartScheduler+0x48>)
   169a4:	681b      	ldr	r3, [r3, #0]
   169a6:	4a10      	ldr	r2, [pc, #64]	; (169e8 <xPortStartScheduler+0x48>)
   169a8:	f443 0378 	orr.w	r3, r3, #16252928	; 0xf80000
   169ac:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   169ae:	4b0e      	ldr	r3, [pc, #56]	; (169e8 <xPortStartScheduler+0x48>)
   169b0:	681b      	ldr	r3, [r3, #0]
   169b2:	4a0d      	ldr	r2, [pc, #52]	; (169e8 <xPortStartScheduler+0x48>)
   169b4:	f043 4378 	orr.w	r3, r3, #4160749568	; 0xf8000000
   169b8:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   169ba:	f7fe f92b 	bl	14c14 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   169be:	4b0b      	ldr	r3, [pc, #44]	; (169ec <xPortStartScheduler+0x4c>)
   169c0:	2200      	movs	r2, #0
   169c2:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
   169c4:	f000 f898 	bl	16af8 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   169c8:	4b09      	ldr	r3, [pc, #36]	; (169f0 <xPortStartScheduler+0x50>)
   169ca:	681b      	ldr	r3, [r3, #0]
   169cc:	4a08      	ldr	r2, [pc, #32]	; (169f0 <xPortStartScheduler+0x50>)
   169ce:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   169d2:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   169d4:	f7ff ffd0 	bl	16978 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   169d8:	f7ff fa2a 	bl	15e30 <vTaskSwitchContext>
	prvTaskExitError();
   169dc:	f7ff ff9e 	bl	1691c <prvTaskExitError>

	/* Should not get here! */
	return 0;
   169e0:	2300      	movs	r3, #0
}
   169e2:	4618      	mov	r0, r3
   169e4:	bd08      	pop	{r3, pc}
   169e6:	bf00      	nop
   169e8:	e000ed20 	.word	0xe000ed20
   169ec:	100008e0 	.word	0x100008e0
   169f0:	e000ef34 	.word	0xe000ef34

000169f4 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   169f4:	b082      	sub	sp, #8
   169f6:	f04f 0328 	mov.w	r3, #40	; 0x28
   169fa:	f383 8811 	msr	BASEPRI, r3
   169fe:	f3bf 8f6f 	isb	sy
   16a02:	f3bf 8f4f 	dsb	sy
   16a06:	9301      	str	r3, [sp, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   16a08:	4b03      	ldr	r3, [pc, #12]	; (16a18 <vPortEnterCritical+0x24>)
   16a0a:	681b      	ldr	r3, [r3, #0]
   16a0c:	3301      	adds	r3, #1
   16a0e:	4a02      	ldr	r2, [pc, #8]	; (16a18 <vPortEnterCritical+0x24>)
   16a10:	6013      	str	r3, [r2, #0]
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
   16a12:	bf00      	nop
   16a14:	b002      	add	sp, #8
   16a16:	4770      	bx	lr
   16a18:	100008e0 	.word	0x100008e0

00016a1c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   16a1c:	b082      	sub	sp, #8
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
   16a1e:	4b08      	ldr	r3, [pc, #32]	; (16a40 <vPortExitCritical+0x24>)
   16a20:	681b      	ldr	r3, [r3, #0]
   16a22:	3b01      	subs	r3, #1
   16a24:	4a06      	ldr	r2, [pc, #24]	; (16a40 <vPortExitCritical+0x24>)
   16a26:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   16a28:	4b05      	ldr	r3, [pc, #20]	; (16a40 <vPortExitCritical+0x24>)
   16a2a:	681b      	ldr	r3, [r3, #0]
   16a2c:	2b00      	cmp	r3, #0
   16a2e:	d104      	bne.n	16a3a <vPortExitCritical+0x1e>
   16a30:	2300      	movs	r3, #0
   16a32:	9301      	str	r3, [sp, #4]
	__asm volatile
   16a34:	9b01      	ldr	r3, [sp, #4]
   16a36:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   16a3a:	bf00      	nop
   16a3c:	b002      	add	sp, #8
   16a3e:	4770      	bx	lr
   16a40:	100008e0 	.word	0x100008e0
   16a44:	ffffffff 	.word	0xffffffff
   16a48:	ffffffff 	.word	0xffffffff
   16a4c:	ffffffff 	.word	0xffffffff

00016a50 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   16a50:	f3ef 8009 	mrs	r0, PSP
   16a54:	f3bf 8f6f 	isb	sy
   16a58:	4b15      	ldr	r3, [pc, #84]	; (16ab0 <pxCurrentTCBConst>)
   16a5a:	681a      	ldr	r2, [r3, #0]
   16a5c:	f01e 0f10 	tst.w	lr, #16
   16a60:	bf08      	it	eq
   16a62:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   16a66:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16a6a:	6010      	str	r0, [r2, #0]
   16a6c:	e92d 0009 	stmdb	sp!, {r0, r3}
   16a70:	f04f 0028 	mov.w	r0, #40	; 0x28
   16a74:	f380 8811 	msr	BASEPRI, r0
   16a78:	f3bf 8f4f 	dsb	sy
   16a7c:	f3bf 8f6f 	isb	sy
   16a80:	f7ff f9d6 	bl	15e30 <vTaskSwitchContext>
   16a84:	f04f 0000 	mov.w	r0, #0
   16a88:	f380 8811 	msr	BASEPRI, r0
   16a8c:	bc09      	pop	{r0, r3}
   16a8e:	6819      	ldr	r1, [r3, #0]
   16a90:	6808      	ldr	r0, [r1, #0]
   16a92:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16a96:	f01e 0f10 	tst.w	lr, #16
   16a9a:	bf08      	it	eq
   16a9c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   16aa0:	f380 8809 	msr	PSP, r0
   16aa4:	f3bf 8f6f 	isb	sy
   16aa8:	4770      	bx	lr
   16aaa:	bf00      	nop
   16aac:	f3af 8000 	nop.w

00016ab0 <pxCurrentTCBConst>:
   16ab0:	10001550 	.word	0x10001550
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   16ab4:	bf00      	nop
   16ab6:	bf00      	nop

00016ab8 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   16ab8:	b500      	push	{lr}
   16aba:	b083      	sub	sp, #12
	__asm volatile
   16abc:	f04f 0328 	mov.w	r3, #40	; 0x28
   16ac0:	f383 8811 	msr	BASEPRI, r3
   16ac4:	f3bf 8f6f 	isb	sy
   16ac8:	f3bf 8f4f 	dsb	sy
   16acc:	9301      	str	r3, [sp, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   16ace:	f7ff f903 	bl	15cd8 <xTaskIncrementTick>
   16ad2:	4603      	mov	r3, r0
   16ad4:	2b00      	cmp	r3, #0
   16ad6:	d003      	beq.n	16ae0 <xPortSysTickHandler+0x28>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   16ad8:	4b06      	ldr	r3, [pc, #24]	; (16af4 <xPortSysTickHandler+0x3c>)
   16ada:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   16ade:	601a      	str	r2, [r3, #0]
   16ae0:	2300      	movs	r3, #0
   16ae2:	9300      	str	r3, [sp, #0]
	__asm volatile
   16ae4:	9b00      	ldr	r3, [sp, #0]
   16ae6:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   16aea:	bf00      	nop
   16aec:	b003      	add	sp, #12
   16aee:	f85d fb04 	ldr.w	pc, [sp], #4
   16af2:	bf00      	nop
   16af4:	e000ed04 	.word	0xe000ed04

00016af8 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   16af8:	f8df 000c 	ldr.w	r0, [pc, #12]	; 16b08 <vPortEnableVFP+0x10>
   16afc:	6801      	ldr	r1, [r0, #0]
   16afe:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   16b02:	6001      	str	r1, [r0, #0]
   16b04:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   16b06:	bf00      	nop
   16b08:	e000ed88 	.word	0xe000ed88

00016b0c <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   16b0c:	b500      	push	{lr}
   16b0e:	b085      	sub	sp, #20
   16b10:	9001      	str	r0, [sp, #4]
void *pvReturn;

	vTaskSuspendAll();
   16b12:	f7ff f84b 	bl	15bac <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
   16b16:	9801      	ldr	r0, [sp, #4]
   16b18:	f002 fec4 	bl	198a4 <malloc>
   16b1c:	4603      	mov	r3, r0
   16b1e:	9303      	str	r3, [sp, #12]
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   16b20:	f7ff f84e 	bl	15bc0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
   16b24:	9b03      	ldr	r3, [sp, #12]
}
   16b26:	4618      	mov	r0, r3
   16b28:	b005      	add	sp, #20
   16b2a:	f85d fb04 	ldr.w	pc, [sp], #4

00016b2e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   16b2e:	b500      	push	{lr}
   16b30:	b083      	sub	sp, #12
   16b32:	9001      	str	r0, [sp, #4]
	if( pv )
   16b34:	9b01      	ldr	r3, [sp, #4]
   16b36:	2b00      	cmp	r3, #0
   16b38:	d006      	beq.n	16b48 <vPortFree+0x1a>
	{
		vTaskSuspendAll();
   16b3a:	f7ff f837 	bl	15bac <vTaskSuspendAll>
		{
			free( pv );
   16b3e:	9801      	ldr	r0, [sp, #4]
   16b40:	f002 feb8 	bl	198b4 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
   16b44:	f7ff f83c 	bl	15bc0 <xTaskResumeAll>
	}
}
   16b48:	bf00      	nop
   16b4a:	b003      	add	sp, #12
   16b4c:	f85d fb04 	ldr.w	pc, [sp], #4

00016b50 <_out_buffer(char, void*, unsigned int, unsigned int)>:
} out_fct_wrap_type;


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
   16b50:	b510      	push	{r4, lr}
   16b52:	b084      	sub	sp, #16
   16b54:	4674      	mov	r4, lr
   16b56:	9102      	str	r1, [sp, #8]
   16b58:	9201      	str	r2, [sp, #4]
   16b5a:	9300      	str	r3, [sp, #0]
   16b5c:	4603      	mov	r3, r0
   16b5e:	f88d 300f 	strb.w	r3, [sp, #15]
   16b62:	4623      	mov	r3, r4
   16b64:	4619      	mov	r1, r3
   16b66:	480a      	ldr	r0, [pc, #40]	; (16b90 <_out_buffer(char, void*, unsigned int, unsigned int)+0x40>)
   16b68:	f7fe fd8e 	bl	15688 <__cyg_profile_func_enter>
  if (idx < maxlen) {
   16b6c:	9a01      	ldr	r2, [sp, #4]
   16b6e:	9b00      	ldr	r3, [sp, #0]
   16b70:	429a      	cmp	r2, r3
   16b72:	d205      	bcs.n	16b80 <_out_buffer(char, void*, unsigned int, unsigned int)+0x30>
    ((char*)buffer)[idx] = character;
   16b74:	9a02      	ldr	r2, [sp, #8]
   16b76:	9b01      	ldr	r3, [sp, #4]
   16b78:	4413      	add	r3, r2
   16b7a:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16b7e:	701a      	strb	r2, [r3, #0]
   16b80:	4623      	mov	r3, r4
   16b82:	4619      	mov	r1, r3
   16b84:	4802      	ldr	r0, [pc, #8]	; (16b90 <_out_buffer(char, void*, unsigned int, unsigned int)+0x40>)
   16b86:	f7fe fd93 	bl	156b0 <__cyg_profile_func_exit>
  }
}
   16b8a:	bf00      	nop
   16b8c:	b004      	add	sp, #16
   16b8e:	bd10      	pop	{r4, pc}
   16b90:	00016b51 	.word	0x00016b51

00016b94 <_out_null(char, void*, unsigned int, unsigned int)>:


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
   16b94:	b510      	push	{r4, lr}
   16b96:	b084      	sub	sp, #16
   16b98:	4674      	mov	r4, lr
   16b9a:	9102      	str	r1, [sp, #8]
   16b9c:	9201      	str	r2, [sp, #4]
   16b9e:	9300      	str	r3, [sp, #0]
   16ba0:	4603      	mov	r3, r0
   16ba2:	f88d 300f 	strb.w	r3, [sp, #15]
   16ba6:	4623      	mov	r3, r4
   16ba8:	4619      	mov	r1, r3
   16baa:	4805      	ldr	r0, [pc, #20]	; (16bc0 <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   16bac:	f7fe fd6c 	bl	15688 <__cyg_profile_func_enter>
   16bb0:	4623      	mov	r3, r4
   16bb2:	4619      	mov	r1, r3
   16bb4:	4802      	ldr	r0, [pc, #8]	; (16bc0 <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   16bb6:	f7fe fd7b 	bl	156b0 <__cyg_profile_func_exit>
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
   16bba:	bf00      	nop
   16bbc:	b004      	add	sp, #16
   16bbe:	bd10      	pop	{r4, pc}
   16bc0:	00016b95 	.word	0x00016b95

00016bc4 <_out_char(char, void*, unsigned int, unsigned int)>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
   16bc4:	b510      	push	{r4, lr}
   16bc6:	b084      	sub	sp, #16
   16bc8:	4674      	mov	r4, lr
   16bca:	9102      	str	r1, [sp, #8]
   16bcc:	9201      	str	r2, [sp, #4]
   16bce:	9300      	str	r3, [sp, #0]
   16bd0:	4603      	mov	r3, r0
   16bd2:	f88d 300f 	strb.w	r3, [sp, #15]
   16bd6:	4623      	mov	r3, r4
   16bd8:	4619      	mov	r1, r3
   16bda:	480a      	ldr	r0, [pc, #40]	; (16c04 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   16bdc:	f7fe fd54 	bl	15688 <__cyg_profile_func_enter>
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
   16be0:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16be4:	2b00      	cmp	r3, #0
   16be6:	d004      	beq.n	16bf2 <_out_char(char, void*, unsigned int, unsigned int)+0x2e>
    _putchar(character);
   16be8:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16bec:	4618      	mov	r0, r3
   16bee:	f7fe fce1 	bl	155b4 <_putchar>
   16bf2:	4623      	mov	r3, r4
   16bf4:	4619      	mov	r1, r3
   16bf6:	4803      	ldr	r0, [pc, #12]	; (16c04 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   16bf8:	f7fe fd5a 	bl	156b0 <__cyg_profile_func_exit>
  }
}
   16bfc:	bf00      	nop
   16bfe:	b004      	add	sp, #16
   16c00:	bd10      	pop	{r4, pc}
   16c02:	bf00      	nop
   16c04:	00016bc5 	.word	0x00016bc5

00016c08 <_strlen(char const*)>:


// internal strlen
// \return The length of the string (excluding the terminating 0)
static inline unsigned int _strlen(const char* str)
{
   16c08:	b530      	push	{r4, r5, lr}
   16c0a:	b085      	sub	sp, #20
   16c0c:	4674      	mov	r4, lr
   16c0e:	9001      	str	r0, [sp, #4]
   16c10:	4623      	mov	r3, r4
   16c12:	4619      	mov	r1, r3
   16c14:	480c      	ldr	r0, [pc, #48]	; (16c48 <_strlen(char const*)+0x40>)
   16c16:	f7fe fd37 	bl	15688 <__cyg_profile_func_enter>
  const char* s;
  for (s = str; *s; ++s);
   16c1a:	9b01      	ldr	r3, [sp, #4]
   16c1c:	9303      	str	r3, [sp, #12]
   16c1e:	9b03      	ldr	r3, [sp, #12]
   16c20:	781b      	ldrb	r3, [r3, #0]
   16c22:	2b00      	cmp	r3, #0
   16c24:	d003      	beq.n	16c2e <_strlen(char const*)+0x26>
   16c26:	9b03      	ldr	r3, [sp, #12]
   16c28:	3301      	adds	r3, #1
   16c2a:	9303      	str	r3, [sp, #12]
   16c2c:	e7f7      	b.n	16c1e <_strlen(char const*)+0x16>
  return (unsigned int)(s - str);
   16c2e:	9a03      	ldr	r2, [sp, #12]
   16c30:	9b01      	ldr	r3, [sp, #4]
   16c32:	1ad3      	subs	r3, r2, r3
   16c34:	461d      	mov	r5, r3
   16c36:	4623      	mov	r3, r4
   16c38:	4619      	mov	r1, r3
   16c3a:	4803      	ldr	r0, [pc, #12]	; (16c48 <_strlen(char const*)+0x40>)
   16c3c:	f7fe fd38 	bl	156b0 <__cyg_profile_func_exit>
   16c40:	462b      	mov	r3, r5
}
   16c42:	4618      	mov	r0, r3
   16c44:	b005      	add	sp, #20
   16c46:	bd30      	pop	{r4, r5, pc}
   16c48:	00016c09 	.word	0x00016c09

00016c4c <_is_digit(char)>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
   16c4c:	b530      	push	{r4, r5, lr}
   16c4e:	b083      	sub	sp, #12
   16c50:	4675      	mov	r5, lr
   16c52:	4603      	mov	r3, r0
   16c54:	f88d 3007 	strb.w	r3, [sp, #7]
   16c58:	462b      	mov	r3, r5
   16c5a:	4619      	mov	r1, r3
   16c5c:	480b      	ldr	r0, [pc, #44]	; (16c8c <_is_digit(char)+0x40>)
   16c5e:	f7fe fd13 	bl	15688 <__cyg_profile_func_enter>
  return (ch >= '0') && (ch <= '9');
   16c62:	f89d 3007 	ldrb.w	r3, [sp, #7]
   16c66:	2b2f      	cmp	r3, #47	; 0x2f
   16c68:	d905      	bls.n	16c76 <_is_digit(char)+0x2a>
   16c6a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   16c6e:	2b39      	cmp	r3, #57	; 0x39
   16c70:	d801      	bhi.n	16c76 <_is_digit(char)+0x2a>
   16c72:	2401      	movs	r4, #1
   16c74:	e000      	b.n	16c78 <_is_digit(char)+0x2c>
   16c76:	2400      	movs	r4, #0
   16c78:	462b      	mov	r3, r5
   16c7a:	4619      	mov	r1, r3
   16c7c:	4803      	ldr	r0, [pc, #12]	; (16c8c <_is_digit(char)+0x40>)
   16c7e:	f7fe fd17 	bl	156b0 <__cyg_profile_func_exit>
   16c82:	4623      	mov	r3, r4
}
   16c84:	4618      	mov	r0, r3
   16c86:	b003      	add	sp, #12
   16c88:	bd30      	pop	{r4, r5, pc}
   16c8a:	bf00      	nop
   16c8c:	00016c4d 	.word	0x00016c4d

00016c90 <_atoi(char const**)>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
   16c90:	b530      	push	{r4, r5, lr}
   16c92:	b085      	sub	sp, #20
   16c94:	4675      	mov	r5, lr
   16c96:	9001      	str	r0, [sp, #4]
   16c98:	462b      	mov	r3, r5
   16c9a:	4619      	mov	r1, r3
   16c9c:	4813      	ldr	r0, [pc, #76]	; (16cec <_atoi(char const**)+0x5c>)
   16c9e:	f7fe fcf3 	bl	15688 <__cyg_profile_func_enter>
  unsigned int i = 0U;
   16ca2:	2300      	movs	r3, #0
   16ca4:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   16ca6:	9b01      	ldr	r3, [sp, #4]
   16ca8:	681b      	ldr	r3, [r3, #0]
   16caa:	781b      	ldrb	r3, [r3, #0]
   16cac:	4618      	mov	r0, r3
   16cae:	f7ff ffcd 	bl	16c4c <_is_digit(char)>
   16cb2:	4603      	mov	r3, r0
   16cb4:	2b00      	cmp	r3, #0
   16cb6:	d00f      	beq.n	16cd8 <_atoi(char const**)+0x48>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
   16cb8:	9a03      	ldr	r2, [sp, #12]
   16cba:	4613      	mov	r3, r2
   16cbc:	009b      	lsls	r3, r3, #2
   16cbe:	4413      	add	r3, r2
   16cc0:	005b      	lsls	r3, r3, #1
   16cc2:	4618      	mov	r0, r3
   16cc4:	9b01      	ldr	r3, [sp, #4]
   16cc6:	681b      	ldr	r3, [r3, #0]
   16cc8:	1c59      	adds	r1, r3, #1
   16cca:	9a01      	ldr	r2, [sp, #4]
   16ccc:	6011      	str	r1, [r2, #0]
   16cce:	781b      	ldrb	r3, [r3, #0]
   16cd0:	4403      	add	r3, r0
   16cd2:	3b30      	subs	r3, #48	; 0x30
   16cd4:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   16cd6:	e7e6      	b.n	16ca6 <_atoi(char const**)+0x16>
  }
  return i;
   16cd8:	9c03      	ldr	r4, [sp, #12]
   16cda:	462b      	mov	r3, r5
   16cdc:	4619      	mov	r1, r3
   16cde:	4803      	ldr	r0, [pc, #12]	; (16cec <_atoi(char const**)+0x5c>)
   16ce0:	f7fe fce6 	bl	156b0 <__cyg_profile_func_exit>
   16ce4:	4623      	mov	r3, r4
}
   16ce6:	4618      	mov	r0, r3
   16ce8:	b005      	add	sp, #20
   16cea:	bd30      	pop	{r4, r5, pc}
   16cec:	00016c91 	.word	0x00016c91

00016cf0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
   16cf0:	b530      	push	{r4, r5, lr}
   16cf2:	b089      	sub	sp, #36	; 0x24
   16cf4:	4675      	mov	r5, lr
   16cf6:	9003      	str	r0, [sp, #12]
   16cf8:	9102      	str	r1, [sp, #8]
   16cfa:	9201      	str	r2, [sp, #4]
   16cfc:	9300      	str	r3, [sp, #0]
   16cfe:	462b      	mov	r3, r5
   16d00:	4619      	mov	r1, r3
   16d02:	4891      	ldr	r0, [pc, #580]	; (16f48 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   16d04:	f7fe fcc0 	bl	15688 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   16d08:	9b01      	ldr	r3, [sp, #4]
   16d0a:	9305      	str	r3, [sp, #20]

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16d0c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16d0e:	f003 0302 	and.w	r3, r3, #2
   16d12:	2b00      	cmp	r3, #0
   16d14:	d10e      	bne.n	16d34 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   16d16:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16d18:	9b10      	ldr	r3, [sp, #64]	; 0x40
   16d1a:	429a      	cmp	r2, r3
   16d1c:	d20a      	bcs.n	16d34 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   16d1e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16d20:	2b1f      	cmp	r3, #31
   16d22:	d807      	bhi.n	16d34 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
    buf[len++] = '0';
   16d24:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16d26:	1c5a      	adds	r2, r3, #1
   16d28:	920d      	str	r2, [sp, #52]	; 0x34
   16d2a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16d2c:	4413      	add	r3, r2
   16d2e:	2230      	movs	r2, #48	; 0x30
   16d30:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16d32:	e7eb      	b.n	16d0c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1c>
  }
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16d34:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16d36:	f003 0302 	and.w	r3, r3, #2
   16d3a:	2b00      	cmp	r3, #0
   16d3c:	d113      	bne.n	16d66 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   16d3e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16d40:	f003 0301 	and.w	r3, r3, #1
   16d44:	2b00      	cmp	r3, #0
   16d46:	d00e      	beq.n	16d66 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   16d48:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16d4a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16d4c:	429a      	cmp	r2, r3
   16d4e:	d20a      	bcs.n	16d66 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   16d50:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16d52:	2b1f      	cmp	r3, #31
   16d54:	d807      	bhi.n	16d66 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
    buf[len++] = '0';
   16d56:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16d58:	1c5a      	adds	r2, r3, #1
   16d5a:	920d      	str	r2, [sp, #52]	; 0x34
   16d5c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16d5e:	4413      	add	r3, r2
   16d60:	2230      	movs	r2, #48	; 0x30
   16d62:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16d64:	e7e6      	b.n	16d34 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
  }

  // handle hash
  if (flags & FLAGS_HASH) {
   16d66:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16d68:	f003 0310 	and.w	r3, r3, #16
   16d6c:	2b00      	cmp	r3, #0
   16d6e:	d058      	beq.n	16e22 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   16d70:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16d72:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   16d76:	2b00      	cmp	r3, #0
   16d78:	d116      	bne.n	16da8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   16d7a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16d7c:	2b00      	cmp	r3, #0
   16d7e:	d013      	beq.n	16da8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   16d80:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16d82:	9b10      	ldr	r3, [sp, #64]	; 0x40
   16d84:	429a      	cmp	r2, r3
   16d86:	d003      	beq.n	16d90 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xa0>
   16d88:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16d8a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16d8c:	429a      	cmp	r2, r3
   16d8e:	d10b      	bne.n	16da8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
      len--;
   16d90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16d92:	3b01      	subs	r3, #1
   16d94:	930d      	str	r3, [sp, #52]	; 0x34
      if (len && (base == 16U)) {
   16d96:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16d98:	2b00      	cmp	r3, #0
   16d9a:	d005      	beq.n	16da8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   16d9c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16d9e:	2b10      	cmp	r3, #16
   16da0:	d102      	bne.n	16da8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
        len--;
   16da2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16da4:	3b01      	subs	r3, #1
   16da6:	930d      	str	r3, [sp, #52]	; 0x34
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16da8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16daa:	2b10      	cmp	r3, #16
   16dac:	d10f      	bne.n	16dce <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   16dae:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16db0:	f003 0320 	and.w	r3, r3, #32
   16db4:	2b00      	cmp	r3, #0
   16db6:	d10a      	bne.n	16dce <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   16db8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16dba:	2b1f      	cmp	r3, #31
   16dbc:	d807      	bhi.n	16dce <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
      buf[len++] = 'x';
   16dbe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16dc0:	1c5a      	adds	r2, r3, #1
   16dc2:	920d      	str	r2, [sp, #52]	; 0x34
   16dc4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16dc6:	4413      	add	r3, r2
   16dc8:	2278      	movs	r2, #120	; 0x78
   16dca:	701a      	strb	r2, [r3, #0]
   16dcc:	e01f      	b.n	16e0e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16dce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16dd0:	2b10      	cmp	r3, #16
   16dd2:	d10f      	bne.n	16df4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   16dd4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16dd6:	f003 0320 	and.w	r3, r3, #32
   16dda:	2b00      	cmp	r3, #0
   16ddc:	d00a      	beq.n	16df4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   16dde:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16de0:	2b1f      	cmp	r3, #31
   16de2:	d807      	bhi.n	16df4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
      buf[len++] = 'X';
   16de4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16de6:	1c5a      	adds	r2, r3, #1
   16de8:	920d      	str	r2, [sp, #52]	; 0x34
   16dea:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16dec:	4413      	add	r3, r2
   16dee:	2258      	movs	r2, #88	; 0x58
   16df0:	701a      	strb	r2, [r3, #0]
   16df2:	e00c      	b.n	16e0e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16df4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16df6:	2b02      	cmp	r3, #2
   16df8:	d109      	bne.n	16e0e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
   16dfa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16dfc:	2b1f      	cmp	r3, #31
   16dfe:	d806      	bhi.n	16e0e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
      buf[len++] = 'b';
   16e00:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e02:	1c5a      	adds	r2, r3, #1
   16e04:	920d      	str	r2, [sp, #52]	; 0x34
   16e06:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16e08:	4413      	add	r3, r2
   16e0a:	2262      	movs	r2, #98	; 0x62
   16e0c:	701a      	strb	r2, [r3, #0]
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
   16e0e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e10:	2b1f      	cmp	r3, #31
   16e12:	d806      	bhi.n	16e22 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
      buf[len++] = '0';
   16e14:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e16:	1c5a      	adds	r2, r3, #1
   16e18:	920d      	str	r2, [sp, #52]	; 0x34
   16e1a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16e1c:	4413      	add	r3, r2
   16e1e:	2230      	movs	r2, #48	; 0x30
   16e20:	701a      	strb	r2, [r3, #0]
    }
  }

  // handle sign
  if (len && (len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   16e22:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e24:	2b00      	cmp	r3, #0
   16e26:	d014      	beq.n	16e52 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   16e28:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16e2a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16e2c:	429a      	cmp	r2, r3
   16e2e:	d110      	bne.n	16e52 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   16e30:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   16e34:	2b00      	cmp	r3, #0
   16e36:	d109      	bne.n	16e4c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   16e38:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16e3a:	f003 0304 	and.w	r3, r3, #4
   16e3e:	2b00      	cmp	r3, #0
   16e40:	d104      	bne.n	16e4c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   16e42:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16e44:	f003 0308 	and.w	r3, r3, #8
   16e48:	2b00      	cmp	r3, #0
   16e4a:	d002      	beq.n	16e52 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
    len--;
   16e4c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e4e:	3b01      	subs	r3, #1
   16e50:	930d      	str	r3, [sp, #52]	; 0x34
  }
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
   16e52:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e54:	2b1f      	cmp	r3, #31
   16e56:	d824      	bhi.n	16ea2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    if (negative) {
   16e58:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   16e5c:	2b00      	cmp	r3, #0
   16e5e:	d007      	beq.n	16e70 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x180>
      buf[len++] = '-';
   16e60:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e62:	1c5a      	adds	r2, r3, #1
   16e64:	920d      	str	r2, [sp, #52]	; 0x34
   16e66:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16e68:	4413      	add	r3, r2
   16e6a:	222d      	movs	r2, #45	; 0x2d
   16e6c:	701a      	strb	r2, [r3, #0]
   16e6e:	e018      	b.n	16ea2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_PLUS) {
   16e70:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16e72:	f003 0304 	and.w	r3, r3, #4
   16e76:	2b00      	cmp	r3, #0
   16e78:	d007      	beq.n	16e8a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x19a>
      buf[len++] = '+';  // ignore the space if the '+' exists
   16e7a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e7c:	1c5a      	adds	r2, r3, #1
   16e7e:	920d      	str	r2, [sp, #52]	; 0x34
   16e80:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16e82:	4413      	add	r3, r2
   16e84:	222b      	movs	r2, #43	; 0x2b
   16e86:	701a      	strb	r2, [r3, #0]
   16e88:	e00b      	b.n	16ea2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_SPACE) {
   16e8a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16e8c:	f003 0308 	and.w	r3, r3, #8
   16e90:	2b00      	cmp	r3, #0
   16e92:	d006      	beq.n	16ea2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
      buf[len++] = ' ';
   16e94:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e96:	1c5a      	adds	r2, r3, #1
   16e98:	920d      	str	r2, [sp, #52]	; 0x34
   16e9a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16e9c:	4413      	add	r3, r2
   16e9e:	2220      	movs	r2, #32
   16ea0:	701a      	strb	r2, [r3, #0]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   16ea2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16ea4:	f003 0302 	and.w	r3, r3, #2
   16ea8:	2b00      	cmp	r3, #0
   16eaa:	d116      	bne.n	16eda <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
   16eac:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16eae:	f003 0301 	and.w	r3, r3, #1
   16eb2:	2b00      	cmp	r3, #0
   16eb4:	d111      	bne.n	16eda <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
    for (size_t i = len; i < width; i++) {
   16eb6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16eb8:	9307      	str	r3, [sp, #28]
   16eba:	9a07      	ldr	r2, [sp, #28]
   16ebc:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16ebe:	429a      	cmp	r2, r3
   16ec0:	d20b      	bcs.n	16eda <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
      out(' ', buffer, idx++, maxlen);
   16ec2:	9a01      	ldr	r2, [sp, #4]
   16ec4:	1c53      	adds	r3, r2, #1
   16ec6:	9301      	str	r3, [sp, #4]
   16ec8:	9c03      	ldr	r4, [sp, #12]
   16eca:	9b00      	ldr	r3, [sp, #0]
   16ecc:	9902      	ldr	r1, [sp, #8]
   16ece:	2020      	movs	r0, #32
   16ed0:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   16ed2:	9b07      	ldr	r3, [sp, #28]
   16ed4:	3301      	adds	r3, #1
   16ed6:	9307      	str	r3, [sp, #28]
   16ed8:	e7ef      	b.n	16eba <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ca>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   16eda:	2300      	movs	r3, #0
   16edc:	9306      	str	r3, [sp, #24]
   16ede:	9a06      	ldr	r2, [sp, #24]
   16ee0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16ee2:	429a      	cmp	r2, r3
   16ee4:	d211      	bcs.n	16f0a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x21a>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   16ee6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16ee8:	9b06      	ldr	r3, [sp, #24]
   16eea:	1ad3      	subs	r3, r2, r3
   16eec:	3b01      	subs	r3, #1
   16eee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16ef0:	4413      	add	r3, r2
   16ef2:	7818      	ldrb	r0, [r3, #0]
   16ef4:	9a01      	ldr	r2, [sp, #4]
   16ef6:	1c53      	adds	r3, r2, #1
   16ef8:	9301      	str	r3, [sp, #4]
   16efa:	9c03      	ldr	r4, [sp, #12]
   16efc:	9b00      	ldr	r3, [sp, #0]
   16efe:	9902      	ldr	r1, [sp, #8]
   16f00:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   16f02:	9b06      	ldr	r3, [sp, #24]
   16f04:	3301      	adds	r3, #1
   16f06:	9306      	str	r3, [sp, #24]
   16f08:	e7e9      	b.n	16ede <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ee>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   16f0a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16f0c:	f003 0302 	and.w	r3, r3, #2
   16f10:	2b00      	cmp	r3, #0
   16f12:	d00e      	beq.n	16f32 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
    while (idx - start_idx < width) {
   16f14:	9a01      	ldr	r2, [sp, #4]
   16f16:	9b05      	ldr	r3, [sp, #20]
   16f18:	1ad3      	subs	r3, r2, r3
   16f1a:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16f1c:	429a      	cmp	r2, r3
   16f1e:	d908      	bls.n	16f32 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
      out(' ', buffer, idx++, maxlen);
   16f20:	9a01      	ldr	r2, [sp, #4]
   16f22:	1c53      	adds	r3, r2, #1
   16f24:	9301      	str	r3, [sp, #4]
   16f26:	9c03      	ldr	r4, [sp, #12]
   16f28:	9b00      	ldr	r3, [sp, #0]
   16f2a:	9902      	ldr	r1, [sp, #8]
   16f2c:	2020      	movs	r0, #32
   16f2e:	47a0      	blx	r4
    while (idx - start_idx < width) {
   16f30:	e7f0      	b.n	16f14 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x224>
    }
  }

  return idx;
   16f32:	9c01      	ldr	r4, [sp, #4]
   16f34:	462b      	mov	r3, r5
   16f36:	4619      	mov	r1, r3
   16f38:	4803      	ldr	r0, [pc, #12]	; (16f48 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   16f3a:	f7fe fbb9 	bl	156b0 <__cyg_profile_func_exit>
   16f3e:	4623      	mov	r3, r4
}
   16f40:	4618      	mov	r0, r3
   16f42:	b009      	add	sp, #36	; 0x24
   16f44:	bd30      	pop	{r4, r5, pc}
   16f46:	bf00      	nop
   16f48:	00016cf1 	.word	0x00016cf1

00016f4c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   16f4c:	b530      	push	{r4, r5, lr}
   16f4e:	b097      	sub	sp, #92	; 0x5c
   16f50:	4674      	mov	r4, lr
   16f52:	900b      	str	r0, [sp, #44]	; 0x2c
   16f54:	910a      	str	r1, [sp, #40]	; 0x28
   16f56:	9209      	str	r2, [sp, #36]	; 0x24
   16f58:	9308      	str	r3, [sp, #32]
   16f5a:	4623      	mov	r3, r4
   16f5c:	4619      	mov	r1, r3
   16f5e:	4833      	ldr	r0, [pc, #204]	; (1702c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   16f60:	f7fe fb92 	bl	15688 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   16f64:	2300      	movs	r3, #0
   16f66:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   16f68:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16f6a:	2b00      	cmp	r3, #0
   16f6c:	d103      	bne.n	16f76 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x2a>
    flags &= ~FLAGS_HASH;
   16f6e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16f70:	f023 0310 	bic.w	r3, r3, #16
   16f74:	931f      	str	r3, [sp, #124]	; 0x7c
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   16f76:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16f78:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   16f7c:	2b00      	cmp	r3, #0
   16f7e:	d002      	beq.n	16f86 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
   16f80:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16f82:	2b00      	cmp	r3, #0
   16f84:	d033      	beq.n	16fee <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
      const char digit = (char)(value % base);
   16f86:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16f88:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   16f8a:	fbb3 f2f2 	udiv	r2, r3, r2
   16f8e:	991c      	ldr	r1, [sp, #112]	; 0x70
   16f90:	fb01 f202 	mul.w	r2, r1, r2
   16f94:	1a9b      	subs	r3, r3, r2
   16f96:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   16f9a:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16f9e:	2b09      	cmp	r3, #9
   16fa0:	d804      	bhi.n	16fac <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x60>
   16fa2:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16fa6:	3330      	adds	r3, #48	; 0x30
   16fa8:	b2da      	uxtb	r2, r3
   16faa:	e00d      	b.n	16fc8 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x7c>
   16fac:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16fae:	f003 0320 	and.w	r3, r3, #32
   16fb2:	2b00      	cmp	r3, #0
   16fb4:	d001      	beq.n	16fba <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x6e>
   16fb6:	2241      	movs	r2, #65	; 0x41
   16fb8:	e000      	b.n	16fbc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x70>
   16fba:	2261      	movs	r2, #97	; 0x61
   16fbc:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16fc0:	4413      	add	r3, r2
   16fc2:	b2db      	uxtb	r3, r3
   16fc4:	3b0a      	subs	r3, #10
   16fc6:	b2da      	uxtb	r2, r3
   16fc8:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16fca:	1c59      	adds	r1, r3, #1
   16fcc:	9115      	str	r1, [sp, #84]	; 0x54
   16fce:	a916      	add	r1, sp, #88	; 0x58
   16fd0:	440b      	add	r3, r1
   16fd2:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   16fd6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   16fd8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   16fda:	fbb2 f3f3 	udiv	r3, r2, r3
   16fde:	931a      	str	r3, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   16fe0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16fe2:	2b00      	cmp	r3, #0
   16fe4:	d003      	beq.n	16fee <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
   16fe6:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16fe8:	2b1f      	cmp	r3, #31
   16fea:	d800      	bhi.n	16fee <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
   16fec:	e7cb      	b.n	16f86 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   16fee:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16ff0:	9306      	str	r3, [sp, #24]
   16ff2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16ff4:	9305      	str	r3, [sp, #20]
   16ff6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   16ff8:	9304      	str	r3, [sp, #16]
   16ffa:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   16ffc:	9303      	str	r3, [sp, #12]
   16ffe:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
   17002:	9302      	str	r3, [sp, #8]
   17004:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17006:	9301      	str	r3, [sp, #4]
   17008:	ab0c      	add	r3, sp, #48	; 0x30
   1700a:	9300      	str	r3, [sp, #0]
   1700c:	9b08      	ldr	r3, [sp, #32]
   1700e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17010:	990a      	ldr	r1, [sp, #40]	; 0x28
   17012:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17014:	f7ff fe6c 	bl	16cf0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   17018:	4605      	mov	r5, r0
   1701a:	4623      	mov	r3, r4
   1701c:	4619      	mov	r1, r3
   1701e:	4803      	ldr	r0, [pc, #12]	; (1702c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   17020:	f7fe fb46 	bl	156b0 <__cyg_profile_func_exit>
   17024:	462b      	mov	r3, r5
}
   17026:	4618      	mov	r0, r3
   17028:	b017      	add	sp, #92	; 0x5c
   1702a:	bd30      	pop	{r4, r5, pc}
   1702c:	00016f4d 	.word	0x00016f4d

00017030 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   17030:	b530      	push	{r4, r5, lr}
   17032:	b097      	sub	sp, #92	; 0x5c
   17034:	4675      	mov	r5, lr
   17036:	900b      	str	r0, [sp, #44]	; 0x2c
   17038:	910a      	str	r1, [sp, #40]	; 0x28
   1703a:	9209      	str	r2, [sp, #36]	; 0x24
   1703c:	9308      	str	r3, [sp, #32]
   1703e:	462b      	mov	r3, r5
   17040:	4619      	mov	r1, r3
   17042:	4837      	ldr	r0, [pc, #220]	; (17120 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   17044:	f7fe fb20 	bl	15688 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   17048:	2300      	movs	r3, #0
   1704a:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   1704c:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   17050:	4323      	orrs	r3, r4
   17052:	d103      	bne.n	1705c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x2c>
    flags &= ~FLAGS_HASH;
   17054:	9b22      	ldr	r3, [sp, #136]	; 0x88
   17056:	f023 0310 	bic.w	r3, r3, #16
   1705a:	9322      	str	r3, [sp, #136]	; 0x88
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   1705c:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1705e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17062:	2b00      	cmp	r3, #0
   17064:	d003      	beq.n	1706e <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
   17066:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   1706a:	4323      	orrs	r3, r4
   1706c:	d039      	beq.n	170e2 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
      const char digit = (char)(value % base);
   1706e:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   17072:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   17076:	f002 fa69 	bl	1954c <__aeabi_uldivmod>
   1707a:	461c      	mov	r4, r3
   1707c:	4613      	mov	r3, r2
   1707e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   17082:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   17086:	2b09      	cmp	r3, #9
   17088:	d804      	bhi.n	17094 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x64>
   1708a:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   1708e:	3330      	adds	r3, #48	; 0x30
   17090:	b2da      	uxtb	r2, r3
   17092:	e00d      	b.n	170b0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x80>
   17094:	9b22      	ldr	r3, [sp, #136]	; 0x88
   17096:	f003 0320 	and.w	r3, r3, #32
   1709a:	2b00      	cmp	r3, #0
   1709c:	d001      	beq.n	170a2 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x72>
   1709e:	2241      	movs	r2, #65	; 0x41
   170a0:	e000      	b.n	170a4 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x74>
   170a2:	2261      	movs	r2, #97	; 0x61
   170a4:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   170a8:	4413      	add	r3, r2
   170aa:	b2db      	uxtb	r3, r3
   170ac:	3b0a      	subs	r3, #10
   170ae:	b2da      	uxtb	r2, r3
   170b0:	9b15      	ldr	r3, [sp, #84]	; 0x54
   170b2:	1c59      	adds	r1, r3, #1
   170b4:	9115      	str	r1, [sp, #84]	; 0x54
   170b6:	a916      	add	r1, sp, #88	; 0x58
   170b8:	440b      	add	r3, r1
   170ba:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   170be:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   170c2:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   170c6:	f002 fa41 	bl	1954c <__aeabi_uldivmod>
   170ca:	4603      	mov	r3, r0
   170cc:	460c      	mov	r4, r1
   170ce:	e9cd 341a 	strd	r3, r4, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   170d2:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   170d6:	4323      	orrs	r3, r4
   170d8:	d003      	beq.n	170e2 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
   170da:	9b15      	ldr	r3, [sp, #84]	; 0x54
   170dc:	2b1f      	cmp	r3, #31
   170de:	d800      	bhi.n	170e2 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
   170e0:	e7c5      	b.n	1706e <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   170e2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   170e4:	9a22      	ldr	r2, [sp, #136]	; 0x88
   170e6:	9206      	str	r2, [sp, #24]
   170e8:	9a21      	ldr	r2, [sp, #132]	; 0x84
   170ea:	9205      	str	r2, [sp, #20]
   170ec:	9a20      	ldr	r2, [sp, #128]	; 0x80
   170ee:	9204      	str	r2, [sp, #16]
   170f0:	9303      	str	r3, [sp, #12]
   170f2:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
   170f6:	9302      	str	r3, [sp, #8]
   170f8:	9b15      	ldr	r3, [sp, #84]	; 0x54
   170fa:	9301      	str	r3, [sp, #4]
   170fc:	ab0c      	add	r3, sp, #48	; 0x30
   170fe:	9300      	str	r3, [sp, #0]
   17100:	9b08      	ldr	r3, [sp, #32]
   17102:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17104:	990a      	ldr	r1, [sp, #40]	; 0x28
   17106:	980b      	ldr	r0, [sp, #44]	; 0x2c
   17108:	f7ff fdf2 	bl	16cf0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   1710c:	4604      	mov	r4, r0
   1710e:	462b      	mov	r3, r5
   17110:	4619      	mov	r1, r3
   17112:	4803      	ldr	r0, [pc, #12]	; (17120 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   17114:	f7fe facc 	bl	156b0 <__cyg_profile_func_exit>
   17118:	4623      	mov	r3, r4
}
   1711a:	4618      	mov	r0, r3
   1711c:	b017      	add	sp, #92	; 0x5c
   1711e:	bd30      	pop	{r4, r5, pc}
   17120:	00017031 	.word	0x00017031

00017124 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>:
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value_param, unsigned int prec, unsigned int width, unsigned int flags)
{
   17124:	b530      	push	{r4, r5, lr}
   17126:	b09b      	sub	sp, #108	; 0x6c
   17128:	4675      	mov	r5, lr
   1712a:	9005      	str	r0, [sp, #20]
   1712c:	9104      	str	r1, [sp, #16]
   1712e:	9203      	str	r2, [sp, #12]
   17130:	9302      	str	r3, [sp, #8]
   17132:	ed8d 0b00 	vstr	d0, [sp]
   17136:	462b      	mov	r3, r5
   17138:	4619      	mov	r1, r3
   1713a:	48b7      	ldr	r0, [pc, #732]	; (17418 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f4>)
   1713c:	f7fe faa4 	bl	15688 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   17140:	9b03      	ldr	r3, [sp, #12]
   17142:	9311      	str	r3, [sp, #68]	; 0x44

  float value = static_cast<float>(value_param);
   17144:	e9dd 0100 	ldrd	r0, r1, [sp]
   17148:	f002 f9b0 	bl	194ac <__aeabi_d2f>
   1714c:	4603      	mov	r3, r0
   1714e:	9319      	str	r3, [sp, #100]	; 0x64

  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
   17150:	2300      	movs	r3, #0
   17152:	9318      	str	r3, [sp, #96]	; 0x60
  float diff = 0.0;
   17154:	f04f 0300 	mov.w	r3, #0
   17158:	9310      	str	r3, [sp, #64]	; 0x40

  // if input is larger than thres_max, revert to exponential
  const float thres_max = (float)0x7FFFFFFF;
   1715a:	f04f 439e 	mov.w	r3, #1325400064	; 0x4f000000
   1715e:	930f      	str	r3, [sp, #60]	; 0x3c

  // powers of 10
  static const float pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for negative
  bool negative = false;
   17160:	2300      	movs	r3, #0
   17162:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
  if (value < 0) {
   17166:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   1716a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1716e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17172:	d50a      	bpl.n	1718a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x66>
    negative = true;
   17174:	2301      	movs	r3, #1
   17176:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    value = 0 - value;
   1717a:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 1741c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f8>
   1717e:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   17182:	ee77 7a67 	vsub.f32	s15, s14, s15
   17186:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
  }

  // set default precision to 6, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
   1718a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1718c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17190:	2b00      	cmp	r3, #0
   17192:	d101      	bne.n	17198 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
    prec = 6U;
   17194:	2306      	movs	r3, #6
   17196:	931e      	str	r3, [sp, #120]	; 0x78
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   17198:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1719a:	2b1f      	cmp	r3, #31
   1719c:	d80e      	bhi.n	171bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
   1719e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   171a0:	2b09      	cmp	r3, #9
   171a2:	d90b      	bls.n	171bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
    buf[len++] = '0';
   171a4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   171a6:	1c5a      	adds	r2, r3, #1
   171a8:	9218      	str	r2, [sp, #96]	; 0x60
   171aa:	aa1a      	add	r2, sp, #104	; 0x68
   171ac:	4413      	add	r3, r2
   171ae:	2230      	movs	r2, #48	; 0x30
   171b0:	f803 2c50 	strb.w	r2, [r3, #-80]
    prec--;
   171b4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   171b6:	3b01      	subs	r3, #1
   171b8:	931e      	str	r3, [sp, #120]	; 0x78
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   171ba:	e7ed      	b.n	17198 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
  }

  int whole = (int)value;
   171bc:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   171c0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   171c4:	ee17 3a90 	vmov	r3, s15
   171c8:	9316      	str	r3, [sp, #88]	; 0x58
  float tmp = (value - whole) * pow10[prec];
   171ca:	9b16      	ldr	r3, [sp, #88]	; 0x58
   171cc:	ee07 3a90 	vmov	s15, r3
   171d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   171d4:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   171d8:	ee37 7a67 	vsub.f32	s14, s14, s15
   171dc:	4a90      	ldr	r2, [pc, #576]	; (17420 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   171de:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   171e0:	009b      	lsls	r3, r3, #2
   171e2:	4413      	add	r3, r2
   171e4:	edd3 7a00 	vldr	s15, [r3]
   171e8:	ee67 7a27 	vmul.f32	s15, s14, s15
   171ec:	edcd 7a0e 	vstr	s15, [sp, #56]	; 0x38
  unsigned long frac = (unsigned long)tmp;
   171f0:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   171f4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   171f8:	ee17 3a90 	vmov	r3, s15
   171fc:	9315      	str	r3, [sp, #84]	; 0x54
  diff = tmp - frac;
   171fe:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17200:	ee07 3a90 	vmov	s15, r3
   17204:	eef8 7a67 	vcvt.f32.u32	s15, s15
   17208:	ed9d 7a0e 	vldr	s14, [sp, #56]	; 0x38
   1720c:	ee77 7a67 	vsub.f32	s15, s14, s15
   17210:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40

  if (diff > 0.5) {
   17214:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   17218:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   1721c:	eef4 7ac7 	vcmpe.f32	s15, s14
   17220:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17224:	dd18      	ble.n	17258 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x134>
    ++frac;
   17226:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17228:	3301      	adds	r3, #1
   1722a:	9315      	str	r3, [sp, #84]	; 0x54
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
   1722c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1722e:	ee07 3a90 	vmov	s15, r3
   17232:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   17236:	4a7a      	ldr	r2, [pc, #488]	; (17420 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   17238:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1723a:	009b      	lsls	r3, r3, #2
   1723c:	4413      	add	r3, r2
   1723e:	edd3 7a00 	vldr	s15, [r3]
   17242:	eeb4 7ae7 	vcmpe.f32	s14, s15
   17246:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1724a:	db19      	blt.n	17280 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
      frac = 0;
   1724c:	2300      	movs	r3, #0
   1724e:	9315      	str	r3, [sp, #84]	; 0x54
      ++whole;
   17250:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17252:	3301      	adds	r3, #1
   17254:	9316      	str	r3, [sp, #88]	; 0x58
   17256:	e013      	b.n	17280 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    }
  }
  else if ((diff == 0.5) && ((frac == 0U) || (frac & 1U))) {
   17258:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   1725c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   17260:	eef4 7a47 	vcmp.f32	s15, s14
   17264:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17268:	d10a      	bne.n	17280 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
   1726a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1726c:	2b00      	cmp	r3, #0
   1726e:	d004      	beq.n	1727a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
   17270:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17272:	f003 0301 	and.w	r3, r3, #1
   17276:	2b00      	cmp	r3, #0
   17278:	d002      	beq.n	17280 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    // if halfway, round up if odd, OR if last digit is 0
    ++frac;
   1727a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1727c:	3301      	adds	r3, #1
   1727e:	9315      	str	r3, [sp, #84]	; 0x54
  }

  // TBD: for very large numbers switch back to native sprintf for exponentials. Anyone want to write code to replace this?
  // Normal printf behavior is to print EVERY whole number digit which can be 100s of characters overflowing your buffers == bad
  if (value > thres_max) {
   17280:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   17284:	ed9f 7a67 	vldr	s14, [pc, #412]	; 17424 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>
   17288:	eef4 7ac7 	vcmpe.f32	s15, s14
   1728c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   17290:	dd01      	ble.n	17296 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x172>
    return 0U;
   17292:	2400      	movs	r4, #0
   17294:	e156      	b.n	17544 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x420>
  }

  if (prec == 0U) {
   17296:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17298:	2b00      	cmp	r3, #0
   1729a:	d129      	bne.n	172f0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1cc>
    diff = value - (float)whole;
   1729c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1729e:	ee07 3a90 	vmov	s15, r3
   172a2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   172a6:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   172aa:	ee77 7a67 	vsub.f32	s15, s14, s15
   172ae:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
    if (diff > 0.5) {
   172b2:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   172b6:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   172ba:	eef4 7ac7 	vcmpe.f32	s15, s14
   172be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   172c2:	dd03      	ble.n	172cc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1a8>
      // greater than 0.5, round up, e.g. 1.6 -> 2
      ++whole;
   172c4:	9b16      	ldr	r3, [sp, #88]	; 0x58
   172c6:	3301      	adds	r3, #1
   172c8:	9316      	str	r3, [sp, #88]	; 0x58
   172ca:	e05f      	b.n	1738c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
    else if ((diff == 0.5) && (whole & 1)) {
   172cc:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   172d0:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   172d4:	eef4 7a47 	vcmp.f32	s15, s14
   172d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   172dc:	d156      	bne.n	1738c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
   172de:	9b16      	ldr	r3, [sp, #88]	; 0x58
   172e0:	f003 0301 	and.w	r3, r3, #1
   172e4:	2b00      	cmp	r3, #0
   172e6:	d051      	beq.n	1738c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
   172e8:	9b16      	ldr	r3, [sp, #88]	; 0x58
   172ea:	3301      	adds	r3, #1
   172ec:	9316      	str	r3, [sp, #88]	; 0x58
   172ee:	e04d      	b.n	1738c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
  }
  else {
    unsigned int count = prec;
   172f0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   172f2:	9314      	str	r3, [sp, #80]	; 0x50
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   172f4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   172f6:	2b1f      	cmp	r3, #31
   172f8:	d827      	bhi.n	1734a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
      --count;
   172fa:	9b14      	ldr	r3, [sp, #80]	; 0x50
   172fc:	3b01      	subs	r3, #1
   172fe:	9314      	str	r3, [sp, #80]	; 0x50
      buf[len++] = (char)(48U + (frac % 10U));
   17300:	9915      	ldr	r1, [sp, #84]	; 0x54
   17302:	4b49      	ldr	r3, [pc, #292]	; (17428 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   17304:	fba3 2301 	umull	r2, r3, r3, r1
   17308:	08da      	lsrs	r2, r3, #3
   1730a:	4613      	mov	r3, r2
   1730c:	009b      	lsls	r3, r3, #2
   1730e:	4413      	add	r3, r2
   17310:	005b      	lsls	r3, r3, #1
   17312:	1aca      	subs	r2, r1, r3
   17314:	b2d3      	uxtb	r3, r2
   17316:	3330      	adds	r3, #48	; 0x30
   17318:	b2d9      	uxtb	r1, r3
   1731a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1731c:	1c5a      	adds	r2, r3, #1
   1731e:	9218      	str	r2, [sp, #96]	; 0x60
   17320:	aa1a      	add	r2, sp, #104	; 0x68
   17322:	4413      	add	r3, r2
   17324:	460a      	mov	r2, r1
   17326:	f803 2c50 	strb.w	r2, [r3, #-80]
      if (!(frac /= 10U)) {
   1732a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1732c:	4a3e      	ldr	r2, [pc, #248]	; (17428 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   1732e:	fba2 2303 	umull	r2, r3, r2, r3
   17332:	08db      	lsrs	r3, r3, #3
   17334:	9315      	str	r3, [sp, #84]	; 0x54
   17336:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17338:	2b00      	cmp	r3, #0
   1733a:	bf0c      	ite	eq
   1733c:	2301      	moveq	r3, #1
   1733e:	2300      	movne	r3, #0
   17340:	b2db      	uxtb	r3, r3
   17342:	2b00      	cmp	r3, #0
   17344:	d100      	bne.n	17348 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x224>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   17346:	e7d5      	b.n	172f4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1d0>
        break;
   17348:	bf00      	nop
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   1734a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1734c:	2b1f      	cmp	r3, #31
   1734e:	d806      	bhi.n	1735e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   17350:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17352:	1e5a      	subs	r2, r3, #1
   17354:	9214      	str	r2, [sp, #80]	; 0x50
   17356:	2b00      	cmp	r3, #0
   17358:	d001      	beq.n	1735e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   1735a:	2301      	movs	r3, #1
   1735c:	e000      	b.n	17360 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23c>
   1735e:	2300      	movs	r3, #0
   17360:	2b00      	cmp	r3, #0
   17362:	d008      	beq.n	17376 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x252>
      buf[len++] = '0';
   17364:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17366:	1c5a      	adds	r2, r3, #1
   17368:	9218      	str	r2, [sp, #96]	; 0x60
   1736a:	aa1a      	add	r2, sp, #104	; 0x68
   1736c:	4413      	add	r3, r2
   1736e:	2230      	movs	r2, #48	; 0x30
   17370:	f803 2c50 	strb.w	r2, [r3, #-80]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   17374:	e7e9      	b.n	1734a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
   17376:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17378:	2b1f      	cmp	r3, #31
   1737a:	d807      	bhi.n	1738c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // add decimal
      buf[len++] = '.';
   1737c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1737e:	1c5a      	adds	r2, r3, #1
   17380:	9218      	str	r2, [sp, #96]	; 0x60
   17382:	aa1a      	add	r2, sp, #104	; 0x68
   17384:	4413      	add	r3, r2
   17386:	222e      	movs	r2, #46	; 0x2e
   17388:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   1738c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1738e:	2b1f      	cmp	r3, #31
   17390:	d828      	bhi.n	173e4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
    buf[len++] = (char)(48 + (whole % 10));
   17392:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17394:	4b25      	ldr	r3, [pc, #148]	; (1742c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   17396:	fb83 1302 	smull	r1, r3, r3, r2
   1739a:	1099      	asrs	r1, r3, #2
   1739c:	17d3      	asrs	r3, r2, #31
   1739e:	1ac9      	subs	r1, r1, r3
   173a0:	460b      	mov	r3, r1
   173a2:	009b      	lsls	r3, r3, #2
   173a4:	440b      	add	r3, r1
   173a6:	005b      	lsls	r3, r3, #1
   173a8:	1ad1      	subs	r1, r2, r3
   173aa:	b2cb      	uxtb	r3, r1
   173ac:	3330      	adds	r3, #48	; 0x30
   173ae:	b2d9      	uxtb	r1, r3
   173b0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   173b2:	1c5a      	adds	r2, r3, #1
   173b4:	9218      	str	r2, [sp, #96]	; 0x60
   173b6:	aa1a      	add	r2, sp, #104	; 0x68
   173b8:	4413      	add	r3, r2
   173ba:	460a      	mov	r2, r1
   173bc:	f803 2c50 	strb.w	r2, [r3, #-80]
    if (!(whole /= 10)) {
   173c0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   173c2:	4a1a      	ldr	r2, [pc, #104]	; (1742c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   173c4:	fb82 1203 	smull	r1, r2, r2, r3
   173c8:	1092      	asrs	r2, r2, #2
   173ca:	17db      	asrs	r3, r3, #31
   173cc:	1ad3      	subs	r3, r2, r3
   173ce:	9316      	str	r3, [sp, #88]	; 0x58
   173d0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   173d2:	2b00      	cmp	r3, #0
   173d4:	bf0c      	ite	eq
   173d6:	2301      	moveq	r3, #1
   173d8:	2300      	movne	r3, #0
   173da:	b2db      	uxtb	r3, r3
   173dc:	2b00      	cmp	r3, #0
   173de:	d100      	bne.n	173e2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2be>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   173e0:	e7d4      	b.n	1738c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      break;
   173e2:	bf00      	nop
    }
  }

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   173e4:	9b20      	ldr	r3, [sp, #128]	; 0x80
   173e6:	f003 0302 	and.w	r3, r3, #2
   173ea:	2b00      	cmp	r3, #0
   173ec:	d120      	bne.n	17430 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   173ee:	9b20      	ldr	r3, [sp, #128]	; 0x80
   173f0:	f003 0301 	and.w	r3, r3, #1
   173f4:	2b00      	cmp	r3, #0
   173f6:	d01b      	beq.n	17430 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   173f8:	9a18      	ldr	r2, [sp, #96]	; 0x60
   173fa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   173fc:	429a      	cmp	r2, r3
   173fe:	d217      	bcs.n	17430 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   17400:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17402:	2b1f      	cmp	r3, #31
   17404:	d814      	bhi.n	17430 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
    buf[len++] = '0';
   17406:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17408:	1c5a      	adds	r2, r3, #1
   1740a:	9218      	str	r2, [sp, #96]	; 0x60
   1740c:	aa1a      	add	r2, sp, #104	; 0x68
   1740e:	4413      	add	r3, r2
   17410:	2230      	movs	r2, #48	; 0x30
   17412:	f803 2c50 	strb.w	r2, [r3, #-80]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   17416:	e7e5      	b.n	173e4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
   17418:	00017125 	.word	0x00017125
   1741c:	00000000 	.word	0x00000000
   17420:	0001b588 	.word	0x0001b588
   17424:	4f000000 	.word	0x4f000000
   17428:	cccccccd 	.word	0xcccccccd
   1742c:	66666667 	.word	0x66666667
  }

  // handle sign
  if ((len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   17430:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17432:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17434:	429a      	cmp	r2, r3
   17436:	d110      	bne.n	1745a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
   17438:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   1743c:	2b00      	cmp	r3, #0
   1743e:	d109      	bne.n	17454 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   17440:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17442:	f003 0304 	and.w	r3, r3, #4
   17446:	2b00      	cmp	r3, #0
   17448:	d104      	bne.n	17454 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   1744a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1744c:	f003 0308 	and.w	r3, r3, #8
   17450:	2b00      	cmp	r3, #0
   17452:	d002      	beq.n	1745a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
    len--;
   17454:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17456:	3b01      	subs	r3, #1
   17458:	9318      	str	r3, [sp, #96]	; 0x60
  }
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
   1745a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1745c:	2b1f      	cmp	r3, #31
   1745e:	d827      	bhi.n	174b0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    if (negative) {
   17460:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   17464:	2b00      	cmp	r3, #0
   17466:	d008      	beq.n	1747a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x356>
      buf[len++] = '-';
   17468:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1746a:	1c5a      	adds	r2, r3, #1
   1746c:	9218      	str	r2, [sp, #96]	; 0x60
   1746e:	aa1a      	add	r2, sp, #104	; 0x68
   17470:	4413      	add	r3, r2
   17472:	222d      	movs	r2, #45	; 0x2d
   17474:	f803 2c50 	strb.w	r2, [r3, #-80]
   17478:	e01a      	b.n	174b0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_PLUS) {
   1747a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1747c:	f003 0304 	and.w	r3, r3, #4
   17480:	2b00      	cmp	r3, #0
   17482:	d008      	beq.n	17496 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x372>
      buf[len++] = '+';  // ignore the space if the '+' exists
   17484:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17486:	1c5a      	adds	r2, r3, #1
   17488:	9218      	str	r2, [sp, #96]	; 0x60
   1748a:	aa1a      	add	r2, sp, #104	; 0x68
   1748c:	4413      	add	r3, r2
   1748e:	222b      	movs	r2, #43	; 0x2b
   17490:	f803 2c50 	strb.w	r2, [r3, #-80]
   17494:	e00c      	b.n	174b0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_SPACE) {
   17496:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17498:	f003 0308 	and.w	r3, r3, #8
   1749c:	2b00      	cmp	r3, #0
   1749e:	d007      	beq.n	174b0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
      buf[len++] = ' ';
   174a0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   174a2:	1c5a      	adds	r2, r3, #1
   174a4:	9218      	str	r2, [sp, #96]	; 0x60
   174a6:	aa1a      	add	r2, sp, #104	; 0x68
   174a8:	4413      	add	r3, r2
   174aa:	2220      	movs	r2, #32
   174ac:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   174b0:	9b20      	ldr	r3, [sp, #128]	; 0x80
   174b2:	f003 0302 	and.w	r3, r3, #2
   174b6:	2b00      	cmp	r3, #0
   174b8:	d116      	bne.n	174e8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
   174ba:	9b20      	ldr	r3, [sp, #128]	; 0x80
   174bc:	f003 0301 	and.w	r3, r3, #1
   174c0:	2b00      	cmp	r3, #0
   174c2:	d111      	bne.n	174e8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
    for (size_t i = len; i < width; i++) {
   174c4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   174c6:	9313      	str	r3, [sp, #76]	; 0x4c
   174c8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   174ca:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   174cc:	429a      	cmp	r2, r3
   174ce:	d20b      	bcs.n	174e8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
      out(' ', buffer, idx++, maxlen);
   174d0:	9a03      	ldr	r2, [sp, #12]
   174d2:	1c53      	adds	r3, r2, #1
   174d4:	9303      	str	r3, [sp, #12]
   174d6:	9c05      	ldr	r4, [sp, #20]
   174d8:	9b02      	ldr	r3, [sp, #8]
   174da:	9904      	ldr	r1, [sp, #16]
   174dc:	2020      	movs	r0, #32
   174de:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   174e0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   174e2:	3301      	adds	r3, #1
   174e4:	9313      	str	r3, [sp, #76]	; 0x4c
   174e6:	e7ef      	b.n	174c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3a4>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   174e8:	2300      	movs	r3, #0
   174ea:	9312      	str	r3, [sp, #72]	; 0x48
   174ec:	9a12      	ldr	r2, [sp, #72]	; 0x48
   174ee:	9b18      	ldr	r3, [sp, #96]	; 0x60
   174f0:	429a      	cmp	r2, r3
   174f2:	d212      	bcs.n	1751a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3f6>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   174f4:	9a18      	ldr	r2, [sp, #96]	; 0x60
   174f6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   174f8:	1ad3      	subs	r3, r2, r3
   174fa:	3b01      	subs	r3, #1
   174fc:	aa1a      	add	r2, sp, #104	; 0x68
   174fe:	4413      	add	r3, r2
   17500:	f813 0c50 	ldrb.w	r0, [r3, #-80]
   17504:	9a03      	ldr	r2, [sp, #12]
   17506:	1c53      	adds	r3, r2, #1
   17508:	9303      	str	r3, [sp, #12]
   1750a:	9c05      	ldr	r4, [sp, #20]
   1750c:	9b02      	ldr	r3, [sp, #8]
   1750e:	9904      	ldr	r1, [sp, #16]
   17510:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   17512:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17514:	3301      	adds	r3, #1
   17516:	9312      	str	r3, [sp, #72]	; 0x48
   17518:	e7e8      	b.n	174ec <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c8>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   1751a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1751c:	f003 0302 	and.w	r3, r3, #2
   17520:	2b00      	cmp	r3, #0
   17522:	d00e      	beq.n	17542 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
    while (idx - start_idx < width) {
   17524:	9a03      	ldr	r2, [sp, #12]
   17526:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17528:	1ad3      	subs	r3, r2, r3
   1752a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   1752c:	429a      	cmp	r2, r3
   1752e:	d908      	bls.n	17542 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
      out(' ', buffer, idx++, maxlen);
   17530:	9a03      	ldr	r2, [sp, #12]
   17532:	1c53      	adds	r3, r2, #1
   17534:	9303      	str	r3, [sp, #12]
   17536:	9c05      	ldr	r4, [sp, #20]
   17538:	9b02      	ldr	r3, [sp, #8]
   1753a:	9904      	ldr	r1, [sp, #16]
   1753c:	2020      	movs	r0, #32
   1753e:	47a0      	blx	r4
    while (idx - start_idx < width) {
   17540:	e7f0      	b.n	17524 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x400>
    }
  }

  return idx;
   17542:	9c03      	ldr	r4, [sp, #12]
   17544:	462b      	mov	r3, r5
   17546:	4619      	mov	r1, r3
   17548:	4803      	ldr	r0, [pc, #12]	; (17558 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x434>)
   1754a:	f7fe f8b1 	bl	156b0 <__cyg_profile_func_exit>
   1754e:	4623      	mov	r3, r4
}
   17550:	4618      	mov	r0, r3
   17552:	b01b      	add	sp, #108	; 0x6c
   17554:	bd30      	pop	{r4, r5, pc}
   17556:	bf00      	nop
   17558:	00017125 	.word	0x00017125

0001755c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
   1755c:	b570      	push	{r4, r5, r6, lr}
   1755e:	b0a0      	sub	sp, #128	; 0x80
   17560:	4676      	mov	r6, lr
   17562:	900d      	str	r0, [sp, #52]	; 0x34
   17564:	910c      	str	r1, [sp, #48]	; 0x30
   17566:	920b      	str	r2, [sp, #44]	; 0x2c
   17568:	930a      	str	r3, [sp, #40]	; 0x28
   1756a:	4633      	mov	r3, r6
   1756c:	4619      	mov	r1, r3
   1756e:	48a7      	ldr	r0, [pc, #668]	; (1780c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b0>)
   17570:	f7fe f88a 	bl	15688 <__cyg_profile_func_enter>
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
   17574:	2300      	movs	r3, #0
   17576:	931b      	str	r3, [sp, #108]	; 0x6c

  if (!buffer) {
   17578:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1757a:	2b00      	cmp	r3, #0
   1757c:	d101      	bne.n	17582 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    // use null output function
    out = _out_null;
   1757e:	4ba4      	ldr	r3, [pc, #656]	; (17810 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b4>)
   17580:	930d      	str	r3, [sp, #52]	; 0x34
  }

  while (*format)
   17582:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17584:	781b      	ldrb	r3, [r3, #0]
   17586:	2b00      	cmp	r3, #0
   17588:	f000 8448 	beq.w	17e1c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8c0>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
   1758c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1758e:	781b      	ldrb	r3, [r3, #0]
   17590:	2b25      	cmp	r3, #37	; 0x25
   17592:	d00d      	beq.n	175b0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x54>
      // no
      out(*format, buffer, idx++, maxlen);
   17594:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17596:	7818      	ldrb	r0, [r3, #0]
   17598:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1759a:	1c53      	adds	r3, r2, #1
   1759c:	931b      	str	r3, [sp, #108]	; 0x6c
   1759e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   175a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   175a2:	990c      	ldr	r1, [sp, #48]	; 0x30
   175a4:	47a0      	blx	r4
      format++;
   175a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   175a8:	3301      	adds	r3, #1
   175aa:	930a      	str	r3, [sp, #40]	; 0x28
      continue;
   175ac:	f000 bc34 	b.w	17e18 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
    }
    else {
      // yes, evaluate it
      format++;
   175b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   175b2:	3301      	adds	r3, #1
   175b4:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate flags
    flags = 0U;
   175b6:	2300      	movs	r3, #0
   175b8:	931f      	str	r3, [sp, #124]	; 0x7c
    do {
      switch (*format) {
   175ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   175bc:	781b      	ldrb	r3, [r3, #0]
   175be:	3b20      	subs	r3, #32
   175c0:	2b10      	cmp	r3, #16
   175c2:	d857      	bhi.n	17674 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x118>
   175c4:	a201      	add	r2, pc, #4	; (adr r2, 175cc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70>)
   175c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   175ca:	bf00      	nop
   175cc:	0001764d 	.word	0x0001764d
   175d0:	00017675 	.word	0x00017675
   175d4:	00017675 	.word	0x00017675
   175d8:	00017661 	.word	0x00017661
   175dc:	00017675 	.word	0x00017675
   175e0:	00017675 	.word	0x00017675
   175e4:	00017675 	.word	0x00017675
   175e8:	00017675 	.word	0x00017675
   175ec:	00017675 	.word	0x00017675
   175f0:	00017675 	.word	0x00017675
   175f4:	00017675 	.word	0x00017675
   175f8:	00017639 	.word	0x00017639
   175fc:	00017675 	.word	0x00017675
   17600:	00017625 	.word	0x00017625
   17604:	00017675 	.word	0x00017675
   17608:	00017675 	.word	0x00017675
   1760c:	00017611 	.word	0x00017611
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   17610:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17612:	f043 0301 	orr.w	r3, r3, #1
   17616:	931f      	str	r3, [sp, #124]	; 0x7c
   17618:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1761a:	3301      	adds	r3, #1
   1761c:	930a      	str	r3, [sp, #40]	; 0x28
   1761e:	2301      	movs	r3, #1
   17620:	931c      	str	r3, [sp, #112]	; 0x70
   17622:	e02a      	b.n	1767a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   17624:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17626:	f043 0302 	orr.w	r3, r3, #2
   1762a:	931f      	str	r3, [sp, #124]	; 0x7c
   1762c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1762e:	3301      	adds	r3, #1
   17630:	930a      	str	r3, [sp, #40]	; 0x28
   17632:	2301      	movs	r3, #1
   17634:	931c      	str	r3, [sp, #112]	; 0x70
   17636:	e020      	b.n	1767a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   17638:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1763a:	f043 0304 	orr.w	r3, r3, #4
   1763e:	931f      	str	r3, [sp, #124]	; 0x7c
   17640:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17642:	3301      	adds	r3, #1
   17644:	930a      	str	r3, [sp, #40]	; 0x28
   17646:	2301      	movs	r3, #1
   17648:	931c      	str	r3, [sp, #112]	; 0x70
   1764a:	e016      	b.n	1767a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   1764c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1764e:	f043 0308 	orr.w	r3, r3, #8
   17652:	931f      	str	r3, [sp, #124]	; 0x7c
   17654:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17656:	3301      	adds	r3, #1
   17658:	930a      	str	r3, [sp, #40]	; 0x28
   1765a:	2301      	movs	r3, #1
   1765c:	931c      	str	r3, [sp, #112]	; 0x70
   1765e:	e00c      	b.n	1767a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   17660:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17662:	f043 0310 	orr.w	r3, r3, #16
   17666:	931f      	str	r3, [sp, #124]	; 0x7c
   17668:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1766a:	3301      	adds	r3, #1
   1766c:	930a      	str	r3, [sp, #40]	; 0x28
   1766e:	2301      	movs	r3, #1
   17670:	931c      	str	r3, [sp, #112]	; 0x70
   17672:	e002      	b.n	1767a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        default :                                   n = 0U; break;
   17674:	2300      	movs	r3, #0
   17676:	931c      	str	r3, [sp, #112]	; 0x70
   17678:	bf00      	nop
      }
    } while (n);
   1767a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   1767c:	2b00      	cmp	r3, #0
   1767e:	d000      	beq.n	17682 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x126>
    do {
   17680:	e79b      	b.n	175ba <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5e>

    // evaluate width field
    width = 0U;
   17682:	2300      	movs	r3, #0
   17684:	931e      	str	r3, [sp, #120]	; 0x78
    if (_is_digit(*format)) {
   17686:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17688:	781b      	ldrb	r3, [r3, #0]
   1768a:	4618      	mov	r0, r3
   1768c:	f7ff fade 	bl	16c4c <_is_digit(char)>
   17690:	4603      	mov	r3, r0
   17692:	2b00      	cmp	r3, #0
   17694:	d005      	beq.n	176a2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x146>
      width = _atoi(&format);
   17696:	ab0a      	add	r3, sp, #40	; 0x28
   17698:	4618      	mov	r0, r3
   1769a:	f7ff faf9 	bl	16c90 <_atoi(char const**)>
   1769e:	901e      	str	r0, [sp, #120]	; 0x78
   176a0:	e018      	b.n	176d4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
    }
    else if (*format == '*') {
   176a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   176a4:	781b      	ldrb	r3, [r3, #0]
   176a6:	2b2a      	cmp	r3, #42	; 0x2a
   176a8:	d114      	bne.n	176d4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
      const int w = va_arg(va, int);
   176aa:	9b24      	ldr	r3, [sp, #144]	; 0x90
   176ac:	1d1a      	adds	r2, r3, #4
   176ae:	9224      	str	r2, [sp, #144]	; 0x90
   176b0:	681b      	ldr	r3, [r3, #0]
   176b2:	9316      	str	r3, [sp, #88]	; 0x58
      if (w < 0) {
   176b4:	9b16      	ldr	r3, [sp, #88]	; 0x58
   176b6:	2b00      	cmp	r3, #0
   176b8:	da07      	bge.n	176ca <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16e>
        flags |= FLAGS_LEFT;    // reverse padding
   176ba:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   176bc:	f043 0302 	orr.w	r3, r3, #2
   176c0:	931f      	str	r3, [sp, #124]	; 0x7c
        width = (unsigned int)-w;
   176c2:	9b16      	ldr	r3, [sp, #88]	; 0x58
   176c4:	425b      	negs	r3, r3
   176c6:	931e      	str	r3, [sp, #120]	; 0x78
   176c8:	e001      	b.n	176ce <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x172>
      }
      else {
        width = (unsigned int)w;
   176ca:	9b16      	ldr	r3, [sp, #88]	; 0x58
   176cc:	931e      	str	r3, [sp, #120]	; 0x78
      }
      format++;
   176ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   176d0:	3301      	adds	r3, #1
   176d2:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate precision field
    precision = 0U;
   176d4:	2300      	movs	r3, #0
   176d6:	931d      	str	r3, [sp, #116]	; 0x74
    if (*format == '.') {
   176d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   176da:	781b      	ldrb	r3, [r3, #0]
   176dc:	2b2e      	cmp	r3, #46	; 0x2e
   176de:	d124      	bne.n	1772a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      flags |= FLAGS_PRECISION;
   176e0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   176e2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   176e6:	931f      	str	r3, [sp, #124]	; 0x7c
      format++;
   176e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   176ea:	3301      	adds	r3, #1
   176ec:	930a      	str	r3, [sp, #40]	; 0x28
      if (_is_digit(*format)) {
   176ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   176f0:	781b      	ldrb	r3, [r3, #0]
   176f2:	4618      	mov	r0, r3
   176f4:	f7ff faaa 	bl	16c4c <_is_digit(char)>
   176f8:	4603      	mov	r3, r0
   176fa:	2b00      	cmp	r3, #0
   176fc:	d005      	beq.n	1770a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ae>
        precision = _atoi(&format);
   176fe:	ab0a      	add	r3, sp, #40	; 0x28
   17700:	4618      	mov	r0, r3
   17702:	f7ff fac5 	bl	16c90 <_atoi(char const**)>
   17706:	901d      	str	r0, [sp, #116]	; 0x74
   17708:	e00f      	b.n	1772a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      }
      else if (*format == '*') {
   1770a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1770c:	781b      	ldrb	r3, [r3, #0]
   1770e:	2b2a      	cmp	r3, #42	; 0x2a
   17710:	d10b      	bne.n	1772a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
        const int prec = (int)va_arg(va, int);
   17712:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17714:	1d1a      	adds	r2, r3, #4
   17716:	9224      	str	r2, [sp, #144]	; 0x90
   17718:	681b      	ldr	r3, [r3, #0]
   1771a:	9315      	str	r3, [sp, #84]	; 0x54
        precision = prec > 0 ? (unsigned int)prec : 0U;
   1771c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1771e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   17722:	931d      	str	r3, [sp, #116]	; 0x74
        format++;
   17724:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17726:	3301      	adds	r3, #1
   17728:	930a      	str	r3, [sp, #40]	; 0x28
      }
    }

    // evaluate length field
    switch (*format) {
   1772a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1772c:	781b      	ldrb	r3, [r3, #0]
   1772e:	3b68      	subs	r3, #104	; 0x68
   17730:	2b12      	cmp	r3, #18
   17732:	d867      	bhi.n	17804 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
   17734:	a201      	add	r2, pc, #4	; (adr r2, 1773c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1e0>)
   17736:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1773a:	bf00      	nop
   1773c:	000177af 	.word	0x000177af
   17740:	00017805 	.word	0x00017805
   17744:	000177e5 	.word	0x000177e5
   17748:	00017805 	.word	0x00017805
   1774c:	00017789 	.word	0x00017789
   17750:	00017805 	.word	0x00017805
   17754:	00017805 	.word	0x00017805
   17758:	00017805 	.word	0x00017805
   1775c:	00017805 	.word	0x00017805
   17760:	00017805 	.word	0x00017805
   17764:	00017805 	.word	0x00017805
   17768:	00017805 	.word	0x00017805
   1776c:	000177d5 	.word	0x000177d5
   17770:	00017805 	.word	0x00017805
   17774:	00017805 	.word	0x00017805
   17778:	00017805 	.word	0x00017805
   1777c:	00017805 	.word	0x00017805
   17780:	00017805 	.word	0x00017805
   17784:	000177f5 	.word	0x000177f5
      case 'l' :
        flags |= FLAGS_LONG;
   17788:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1778a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1778e:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   17790:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17792:	3301      	adds	r3, #1
   17794:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'l') {
   17796:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17798:	781b      	ldrb	r3, [r3, #0]
   1779a:	2b6c      	cmp	r3, #108	; 0x6c
   1779c:	d134      	bne.n	17808 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
          flags |= FLAGS_LONG_LONG;
   1779e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   177a0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   177a4:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   177a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177a8:	3301      	adds	r3, #1
   177aa:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   177ac:	e02c      	b.n	17808 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
      case 'h' :
        flags |= FLAGS_SHORT;
   177ae:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   177b0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   177b4:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   177b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177b8:	3301      	adds	r3, #1
   177ba:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'h') {
   177bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177be:	781b      	ldrb	r3, [r3, #0]
   177c0:	2b68      	cmp	r3, #104	; 0x68
   177c2:	d127      	bne.n	17814 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
          flags |= FLAGS_CHAR;
   177c4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   177c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   177ca:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   177cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177ce:	3301      	adds	r3, #1
   177d0:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   177d2:	e01f      	b.n	17814 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   177d4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   177d6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   177da:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   177dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177de:	3301      	adds	r3, #1
   177e0:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   177e2:	e018      	b.n	17816 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   177e4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   177e6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   177ea:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   177ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177ee:	3301      	adds	r3, #1
   177f0:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   177f2:	e010      	b.n	17816 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   177f4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   177f6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   177fa:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   177fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177fe:	3301      	adds	r3, #1
   17800:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17802:	e008      	b.n	17816 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      default :
        break;
   17804:	bf00      	nop
   17806:	e006      	b.n	17816 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
        break;
   17808:	bf00      	nop
   1780a:	e004      	b.n	17816 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
   1780c:	0001755d 	.word	0x0001755d
   17810:	00016b95 	.word	0x00016b95
        break;
   17814:	bf00      	nop
    }

    // evaluate specifier
    switch (*format) {
   17816:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17818:	781b      	ldrb	r3, [r3, #0]
   1781a:	3b25      	subs	r3, #37	; 0x25
   1781c:	2b53      	cmp	r3, #83	; 0x53
   1781e:	f200 82ee 	bhi.w	17dfe <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8a2>
   17822:	a201      	add	r2, pc, #4	; (adr r2, 17828 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2cc>)
   17824:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   17828:	00017de7 	.word	0x00017de7
   1782c:	00017dff 	.word	0x00017dff
   17830:	00017dff 	.word	0x00017dff
   17834:	00017dff 	.word	0x00017dff
   17838:	00017dff 	.word	0x00017dff
   1783c:	00017dff 	.word	0x00017dff
   17840:	00017dff 	.word	0x00017dff
   17844:	00017dff 	.word	0x00017dff
   17848:	00017dff 	.word	0x00017dff
   1784c:	00017dff 	.word	0x00017dff
   17850:	00017dff 	.word	0x00017dff
   17854:	00017dff 	.word	0x00017dff
   17858:	00017dff 	.word	0x00017dff
   1785c:	00017dff 	.word	0x00017dff
   17860:	00017dff 	.word	0x00017dff
   17864:	00017dff 	.word	0x00017dff
   17868:	00017dff 	.word	0x00017dff
   1786c:	00017dff 	.word	0x00017dff
   17870:	00017dff 	.word	0x00017dff
   17874:	00017dff 	.word	0x00017dff
   17878:	00017dff 	.word	0x00017dff
   1787c:	00017dff 	.word	0x00017dff
   17880:	00017dff 	.word	0x00017dff
   17884:	00017dff 	.word	0x00017dff
   17888:	00017dff 	.word	0x00017dff
   1788c:	00017dff 	.word	0x00017dff
   17890:	00017dff 	.word	0x00017dff
   17894:	00017dff 	.word	0x00017dff
   17898:	00017dff 	.word	0x00017dff
   1789c:	00017dff 	.word	0x00017dff
   178a0:	00017dff 	.word	0x00017dff
   178a4:	00017dff 	.word	0x00017dff
   178a8:	00017dff 	.word	0x00017dff
   178ac:	00017c05 	.word	0x00017c05
   178b0:	00017dff 	.word	0x00017dff
   178b4:	00017dff 	.word	0x00017dff
   178b8:	00017dff 	.word	0x00017dff
   178bc:	00017dff 	.word	0x00017dff
   178c0:	00017dff 	.word	0x00017dff
   178c4:	00017dff 	.word	0x00017dff
   178c8:	00017dff 	.word	0x00017dff
   178cc:	00017dff 	.word	0x00017dff
   178d0:	00017dff 	.word	0x00017dff
   178d4:	00017dff 	.word	0x00017dff
   178d8:	00017dff 	.word	0x00017dff
   178dc:	00017dff 	.word	0x00017dff
   178e0:	00017dff 	.word	0x00017dff
   178e4:	00017dff 	.word	0x00017dff
   178e8:	00017dff 	.word	0x00017dff
   178ec:	00017dff 	.word	0x00017dff
   178f0:	00017dff 	.word	0x00017dff
   178f4:	00017979 	.word	0x00017979
   178f8:	00017dff 	.word	0x00017dff
   178fc:	00017dff 	.word	0x00017dff
   17900:	00017dff 	.word	0x00017dff
   17904:	00017dff 	.word	0x00017dff
   17908:	00017dff 	.word	0x00017dff
   1790c:	00017dff 	.word	0x00017dff
   17910:	00017dff 	.word	0x00017dff
   17914:	00017dff 	.word	0x00017dff
   17918:	00017dff 	.word	0x00017dff
   1791c:	00017979 	.word	0x00017979
   17920:	00017c41 	.word	0x00017c41
   17924:	00017979 	.word	0x00017979
   17928:	00017dff 	.word	0x00017dff
   1792c:	00017c05 	.word	0x00017c05
   17930:	00017dff 	.word	0x00017dff
   17934:	00017dff 	.word	0x00017dff
   17938:	00017979 	.word	0x00017979
   1793c:	00017dff 	.word	0x00017dff
   17940:	00017dff 	.word	0x00017dff
   17944:	00017dff 	.word	0x00017dff
   17948:	00017dff 	.word	0x00017dff
   1794c:	00017dff 	.word	0x00017dff
   17950:	00017979 	.word	0x00017979
   17954:	00017d9f 	.word	0x00017d9f
   17958:	00017dff 	.word	0x00017dff
   1795c:	00017dff 	.word	0x00017dff
   17960:	00017cc9 	.word	0x00017cc9
   17964:	00017dff 	.word	0x00017dff
   17968:	00017979 	.word	0x00017979
   1796c:	00017dff 	.word	0x00017dff
   17970:	00017dff 	.word	0x00017dff
   17974:	00017979 	.word	0x00017979
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
   17978:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1797a:	781b      	ldrb	r3, [r3, #0]
   1797c:	2b78      	cmp	r3, #120	; 0x78
   1797e:	d003      	beq.n	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x42c>
   17980:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17982:	781b      	ldrb	r3, [r3, #0]
   17984:	2b58      	cmp	r3, #88	; 0x58
   17986:	d102      	bne.n	1798e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x432>
          base = 16U;
   17988:	2310      	movs	r3, #16
   1798a:	931a      	str	r3, [sp, #104]	; 0x68
   1798c:	e013      	b.n	179b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'o') {
   1798e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17990:	781b      	ldrb	r3, [r3, #0]
   17992:	2b6f      	cmp	r3, #111	; 0x6f
   17994:	d102      	bne.n	1799c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x440>
          base =  8U;
   17996:	2308      	movs	r3, #8
   17998:	931a      	str	r3, [sp, #104]	; 0x68
   1799a:	e00c      	b.n	179b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'b') {
   1799c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1799e:	781b      	ldrb	r3, [r3, #0]
   179a0:	2b62      	cmp	r3, #98	; 0x62
   179a2:	d102      	bne.n	179aa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44e>
          base =  2U;
   179a4:	2302      	movs	r3, #2
   179a6:	931a      	str	r3, [sp, #104]	; 0x68
   179a8:	e005      	b.n	179b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else {
          base = 10U;
   179aa:	230a      	movs	r3, #10
   179ac:	931a      	str	r3, [sp, #104]	; 0x68
          flags &= ~FLAGS_HASH;   // no hash for dec format
   179ae:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   179b0:	f023 0310 	bic.w	r3, r3, #16
   179b4:	931f      	str	r3, [sp, #124]	; 0x7c
        }
        // uppercase
        if (*format == 'X') {
   179b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   179b8:	781b      	ldrb	r3, [r3, #0]
   179ba:	2b58      	cmp	r3, #88	; 0x58
   179bc:	d103      	bne.n	179c6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x46a>
          flags |= FLAGS_UPPERCASE;
   179be:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   179c0:	f043 0320 	orr.w	r3, r3, #32
   179c4:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
   179c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   179c8:	781b      	ldrb	r3, [r3, #0]
   179ca:	2b69      	cmp	r3, #105	; 0x69
   179cc:	d007      	beq.n	179de <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
   179ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   179d0:	781b      	ldrb	r3, [r3, #0]
   179d2:	2b64      	cmp	r3, #100	; 0x64
   179d4:	d003      	beq.n	179de <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   179d6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   179d8:	f023 030c 	bic.w	r3, r3, #12
   179dc:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
   179de:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   179e0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   179e4:	2b00      	cmp	r3, #0
   179e6:	d003      	beq.n	179f0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x494>
          flags &= ~FLAGS_ZEROPAD;
   179e8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   179ea:	f023 0301 	bic.w	r3, r3, #1
   179ee:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
   179f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   179f2:	781b      	ldrb	r3, [r3, #0]
   179f4:	2b69      	cmp	r3, #105	; 0x69
   179f6:	d004      	beq.n	17a02 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4a6>
   179f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   179fa:	781b      	ldrb	r3, [r3, #0]
   179fc:	2b64      	cmp	r3, #100	; 0x64
   179fe:	f040 808d 	bne.w	17b1c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5c0>
          // signed
          if (flags & FLAGS_LONG_LONG) {
   17a02:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17a04:	f403 7300 	and.w	r3, r3, #512	; 0x200
   17a08:	2b00      	cmp	r3, #0
   17a0a:	d02e      	beq.n	17a6a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x50e>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
   17a0c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17a0e:	3307      	adds	r3, #7
   17a10:	f023 0307 	bic.w	r3, r3, #7
   17a14:	f103 0208 	add.w	r2, r3, #8
   17a18:	9224      	str	r2, [sp, #144]	; 0x90
   17a1a:	e9d3 3400 	ldrd	r3, r4, [r3]
   17a1e:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   17a22:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   17a26:	2b00      	cmp	r3, #0
   17a28:	f174 0200 	sbcs.w	r2, r4, #0
   17a2c:	da02      	bge.n	17a34 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4d8>
   17a2e:	425b      	negs	r3, r3
   17a30:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
   17a34:	4619      	mov	r1, r3
   17a36:	4622      	mov	r2, r4
   17a38:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   17a3a:	0fdb      	lsrs	r3, r3, #31
   17a3c:	b2d8      	uxtb	r0, r3
   17a3e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17a40:	f04f 0400 	mov.w	r4, #0
   17a44:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
   17a46:	9508      	str	r5, [sp, #32]
   17a48:	9d1e      	ldr	r5, [sp, #120]	; 0x78
   17a4a:	9507      	str	r5, [sp, #28]
   17a4c:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   17a4e:	9506      	str	r5, [sp, #24]
   17a50:	e9cd 3404 	strd	r3, r4, [sp, #16]
   17a54:	9002      	str	r0, [sp, #8]
   17a56:	e9cd 1200 	strd	r1, r2, [sp]
   17a5a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17a5c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17a5e:	990c      	ldr	r1, [sp, #48]	; 0x30
   17a60:	980d      	ldr	r0, [sp, #52]	; 0x34
   17a62:	f7ff fae5 	bl	17030 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   17a66:	901b      	str	r0, [sp, #108]	; 0x6c
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
   17a68:	e0c8      	b.n	17bfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          else if (flags & FLAGS_LONG) {
   17a6a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17a6c:	f403 7380 	and.w	r3, r3, #256	; 0x100
   17a70:	2b00      	cmp	r3, #0
   17a72:	d01e      	beq.n	17ab2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x556>
            const long value = va_arg(va, long);
   17a74:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17a76:	1d1a      	adds	r2, r3, #4
   17a78:	9224      	str	r2, [sp, #144]	; 0x90
   17a7a:	681b      	ldr	r3, [r3, #0]
   17a7c:	9311      	str	r3, [sp, #68]	; 0x44
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   17a7e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17a80:	2b00      	cmp	r3, #0
   17a82:	bfb8      	it	lt
   17a84:	425b      	neglt	r3, r3
   17a86:	4619      	mov	r1, r3
   17a88:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17a8a:	0fdb      	lsrs	r3, r3, #31
   17a8c:	b2db      	uxtb	r3, r3
   17a8e:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   17a90:	9205      	str	r2, [sp, #20]
   17a92:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17a94:	9204      	str	r2, [sp, #16]
   17a96:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   17a98:	9203      	str	r2, [sp, #12]
   17a9a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   17a9c:	9202      	str	r2, [sp, #8]
   17a9e:	9301      	str	r3, [sp, #4]
   17aa0:	9100      	str	r1, [sp, #0]
   17aa2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17aa4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17aa6:	990c      	ldr	r1, [sp, #48]	; 0x30
   17aa8:	980d      	ldr	r0, [sp, #52]	; 0x34
   17aaa:	f7ff fa4f 	bl	16f4c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   17aae:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   17ab0:	e0a4      	b.n	17bfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   17ab2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17ab4:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17ab8:	2b00      	cmp	r3, #0
   17aba:	d005      	beq.n	17ac8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x56c>
   17abc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17abe:	1d1a      	adds	r2, r3, #4
   17ac0:	9224      	str	r2, [sp, #144]	; 0x90
   17ac2:	681b      	ldr	r3, [r3, #0]
   17ac4:	b2db      	uxtb	r3, r3
   17ac6:	e00e      	b.n	17ae6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   17ac8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17aca:	f003 0380 	and.w	r3, r3, #128	; 0x80
   17ace:	2b00      	cmp	r3, #0
   17ad0:	d005      	beq.n	17ade <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x582>
   17ad2:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17ad4:	1d1a      	adds	r2, r3, #4
   17ad6:	9224      	str	r2, [sp, #144]	; 0x90
   17ad8:	681b      	ldr	r3, [r3, #0]
   17ada:	b21b      	sxth	r3, r3
   17adc:	e003      	b.n	17ae6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   17ade:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17ae0:	1d1a      	adds	r2, r3, #4
   17ae2:	9224      	str	r2, [sp, #144]	; 0x90
   17ae4:	681b      	ldr	r3, [r3, #0]
   17ae6:	9312      	str	r3, [sp, #72]	; 0x48
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   17ae8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17aea:	2b00      	cmp	r3, #0
   17aec:	bfb8      	it	lt
   17aee:	425b      	neglt	r3, r3
   17af0:	4619      	mov	r1, r3
   17af2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17af4:	0fdb      	lsrs	r3, r3, #31
   17af6:	b2db      	uxtb	r3, r3
   17af8:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   17afa:	9205      	str	r2, [sp, #20]
   17afc:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17afe:	9204      	str	r2, [sp, #16]
   17b00:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   17b02:	9203      	str	r2, [sp, #12]
   17b04:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   17b06:	9202      	str	r2, [sp, #8]
   17b08:	9301      	str	r3, [sp, #4]
   17b0a:	9100      	str	r1, [sp, #0]
   17b0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17b0e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17b10:	990c      	ldr	r1, [sp, #48]	; 0x30
   17b12:	980d      	ldr	r0, [sp, #52]	; 0x34
   17b14:	f7ff fa1a 	bl	16f4c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   17b18:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   17b1a:	e06f      	b.n	17bfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
   17b1c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17b1e:	f403 7300 	and.w	r3, r3, #512	; 0x200
   17b22:	2b00      	cmp	r3, #0
   17b24:	d020      	beq.n	17b68 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x60c>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   17b26:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17b28:	3307      	adds	r3, #7
   17b2a:	f023 0307 	bic.w	r3, r3, #7
   17b2e:	f103 0208 	add.w	r2, r3, #8
   17b32:	9224      	str	r2, [sp, #144]	; 0x90
   17b34:	e9d3 3400 	ldrd	r3, r4, [r3]
   17b38:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   17b3a:	4611      	mov	r1, r2
   17b3c:	f04f 0200 	mov.w	r2, #0
   17b40:	981f      	ldr	r0, [sp, #124]	; 0x7c
   17b42:	9008      	str	r0, [sp, #32]
   17b44:	981e      	ldr	r0, [sp, #120]	; 0x78
   17b46:	9007      	str	r0, [sp, #28]
   17b48:	981d      	ldr	r0, [sp, #116]	; 0x74
   17b4a:	9006      	str	r0, [sp, #24]
   17b4c:	e9cd 1204 	strd	r1, r2, [sp, #16]
   17b50:	2200      	movs	r2, #0
   17b52:	9202      	str	r2, [sp, #8]
   17b54:	e9cd 3400 	strd	r3, r4, [sp]
   17b58:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17b5a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17b5c:	990c      	ldr	r1, [sp, #48]	; 0x30
   17b5e:	980d      	ldr	r0, [sp, #52]	; 0x34
   17b60:	f7ff fa66 	bl	17030 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   17b64:	901b      	str	r0, [sp, #108]	; 0x6c
   17b66:	e049      	b.n	17bfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
#endif
          }
          else if (flags & FLAGS_LONG) {
   17b68:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17b6a:	f403 7380 	and.w	r3, r3, #256	; 0x100
   17b6e:	2b00      	cmp	r3, #0
   17b70:	d016      	beq.n	17ba0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x644>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   17b72:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17b74:	1d1a      	adds	r2, r3, #4
   17b76:	9224      	str	r2, [sp, #144]	; 0x90
   17b78:	681b      	ldr	r3, [r3, #0]
   17b7a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   17b7c:	9205      	str	r2, [sp, #20]
   17b7e:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17b80:	9204      	str	r2, [sp, #16]
   17b82:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   17b84:	9203      	str	r2, [sp, #12]
   17b86:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   17b88:	9202      	str	r2, [sp, #8]
   17b8a:	2200      	movs	r2, #0
   17b8c:	9201      	str	r2, [sp, #4]
   17b8e:	9300      	str	r3, [sp, #0]
   17b90:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17b92:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17b94:	990c      	ldr	r1, [sp, #48]	; 0x30
   17b96:	980d      	ldr	r0, [sp, #52]	; 0x34
   17b98:	f7ff f9d8 	bl	16f4c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   17b9c:	901b      	str	r0, [sp, #108]	; 0x6c
   17b9e:	e02d      	b.n	17bfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   17ba0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17ba2:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17ba6:	2b00      	cmp	r3, #0
   17ba8:	d005      	beq.n	17bb6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x65a>
   17baa:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17bac:	1d1a      	adds	r2, r3, #4
   17bae:	9224      	str	r2, [sp, #144]	; 0x90
   17bb0:	681b      	ldr	r3, [r3, #0]
   17bb2:	b2db      	uxtb	r3, r3
   17bb4:	e00e      	b.n	17bd4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   17bb6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17bb8:	f003 0380 	and.w	r3, r3, #128	; 0x80
   17bbc:	2b00      	cmp	r3, #0
   17bbe:	d005      	beq.n	17bcc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x670>
   17bc0:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17bc2:	1d1a      	adds	r2, r3, #4
   17bc4:	9224      	str	r2, [sp, #144]	; 0x90
   17bc6:	681b      	ldr	r3, [r3, #0]
   17bc8:	b29b      	uxth	r3, r3
   17bca:	e003      	b.n	17bd4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   17bcc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17bce:	1d1a      	adds	r2, r3, #4
   17bd0:	9224      	str	r2, [sp, #144]	; 0x90
   17bd2:	681b      	ldr	r3, [r3, #0]
   17bd4:	9313      	str	r3, [sp, #76]	; 0x4c
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   17bd6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17bd8:	9305      	str	r3, [sp, #20]
   17bda:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17bdc:	9304      	str	r3, [sp, #16]
   17bde:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17be0:	9303      	str	r3, [sp, #12]
   17be2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17be4:	9302      	str	r3, [sp, #8]
   17be6:	2300      	movs	r3, #0
   17be8:	9301      	str	r3, [sp, #4]
   17bea:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17bec:	9300      	str	r3, [sp, #0]
   17bee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17bf0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17bf2:	990c      	ldr	r1, [sp, #48]	; 0x30
   17bf4:	980d      	ldr	r0, [sp, #52]	; 0x34
   17bf6:	f7ff f9a9 	bl	16f4c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   17bfa:	901b      	str	r0, [sp, #108]	; 0x6c
          }
        }
        format++;
   17bfc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17bfe:	3301      	adds	r3, #1
   17c00:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17c02:	e109      	b.n	17e18 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   17c04:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17c06:	3307      	adds	r3, #7
   17c08:	f023 0307 	bic.w	r3, r3, #7
   17c0c:	f103 0208 	add.w	r2, r3, #8
   17c10:	9224      	str	r2, [sp, #144]	; 0x90
   17c12:	ed93 7b00 	vldr	d7, [r3]
   17c16:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17c18:	9302      	str	r3, [sp, #8]
   17c1a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17c1c:	9301      	str	r3, [sp, #4]
   17c1e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17c20:	9300      	str	r3, [sp, #0]
   17c22:	eeb0 0a47 	vmov.f32	s0, s14
   17c26:	eef0 0a67 	vmov.f32	s1, s15
   17c2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17c2c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17c2e:	990c      	ldr	r1, [sp, #48]	; 0x30
   17c30:	980d      	ldr	r0, [sp, #52]	; 0x34
   17c32:	f7ff fa77 	bl	17124 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>
   17c36:	901b      	str	r0, [sp, #108]	; 0x6c
        format++;
   17c38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17c3a:	3301      	adds	r3, #1
   17c3c:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17c3e:	e0eb      	b.n	17e18 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
   17c40:	2301      	movs	r3, #1
   17c42:	9319      	str	r3, [sp, #100]	; 0x64
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
   17c44:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17c46:	f003 0302 	and.w	r3, r3, #2
   17c4a:	2b00      	cmp	r3, #0
   17c4c:	d113      	bne.n	17c76 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
          while (l++ < width) {
   17c4e:	9b19      	ldr	r3, [sp, #100]	; 0x64
   17c50:	1c5a      	adds	r2, r3, #1
   17c52:	9219      	str	r2, [sp, #100]	; 0x64
   17c54:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17c56:	429a      	cmp	r2, r3
   17c58:	bf8c      	ite	hi
   17c5a:	2301      	movhi	r3, #1
   17c5c:	2300      	movls	r3, #0
   17c5e:	b2db      	uxtb	r3, r3
   17c60:	2b00      	cmp	r3, #0
   17c62:	d008      	beq.n	17c76 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
            out(' ', buffer, idx++, maxlen);
   17c64:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17c66:	1c53      	adds	r3, r2, #1
   17c68:	931b      	str	r3, [sp, #108]	; 0x6c
   17c6a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17c6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17c6e:	990c      	ldr	r1, [sp, #48]	; 0x30
   17c70:	2020      	movs	r0, #32
   17c72:	47a0      	blx	r4
          while (l++ < width) {
   17c74:	e7eb      	b.n	17c4e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6f2>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
   17c76:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17c78:	1d1a      	adds	r2, r3, #4
   17c7a:	9224      	str	r2, [sp, #144]	; 0x90
   17c7c:	681b      	ldr	r3, [r3, #0]
   17c7e:	b2d8      	uxtb	r0, r3
   17c80:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17c82:	1c53      	adds	r3, r2, #1
   17c84:	931b      	str	r3, [sp, #108]	; 0x6c
   17c86:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17c88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17c8a:	990c      	ldr	r1, [sp, #48]	; 0x30
   17c8c:	47a0      	blx	r4
        // post padding
        if (flags & FLAGS_LEFT) {
   17c8e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17c90:	f003 0302 	and.w	r3, r3, #2
   17c94:	2b00      	cmp	r3, #0
   17c96:	d013      	beq.n	17cc0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
          while (l++ < width) {
   17c98:	9b19      	ldr	r3, [sp, #100]	; 0x64
   17c9a:	1c5a      	adds	r2, r3, #1
   17c9c:	9219      	str	r2, [sp, #100]	; 0x64
   17c9e:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17ca0:	429a      	cmp	r2, r3
   17ca2:	bf8c      	ite	hi
   17ca4:	2301      	movhi	r3, #1
   17ca6:	2300      	movls	r3, #0
   17ca8:	b2db      	uxtb	r3, r3
   17caa:	2b00      	cmp	r3, #0
   17cac:	d008      	beq.n	17cc0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
            out(' ', buffer, idx++, maxlen);
   17cae:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17cb0:	1c53      	adds	r3, r2, #1
   17cb2:	931b      	str	r3, [sp, #108]	; 0x6c
   17cb4:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17cb6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17cb8:	990c      	ldr	r1, [sp, #48]	; 0x30
   17cba:	2020      	movs	r0, #32
   17cbc:	47a0      	blx	r4
          while (l++ < width) {
   17cbe:	e7eb      	b.n	17c98 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x73c>
          }
        }
        format++;
   17cc0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17cc2:	3301      	adds	r3, #1
   17cc4:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17cc6:	e0a7      	b.n	17e18 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 's' : {
        char* p = va_arg(va, char*);
   17cc8:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17cca:	1d1a      	adds	r2, r3, #4
   17ccc:	9224      	str	r2, [sp, #144]	; 0x90
   17cce:	681b      	ldr	r3, [r3, #0]
   17cd0:	9318      	str	r3, [sp, #96]	; 0x60
        unsigned int l = _strlen(p);
   17cd2:	9818      	ldr	r0, [sp, #96]	; 0x60
   17cd4:	f7fe ff98 	bl	16c08 <_strlen(char const*)>
   17cd8:	9017      	str	r0, [sp, #92]	; 0x5c
        // pre padding
        if (flags & FLAGS_PRECISION) {
   17cda:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17cdc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17ce0:	2b00      	cmp	r3, #0
   17ce2:	d007      	beq.n	17cf4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x798>
          l = (l < precision ? l : precision);
   17ce4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   17ce6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17ce8:	429a      	cmp	r2, r3
   17cea:	d201      	bcs.n	17cf0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x794>
   17cec:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17cee:	e000      	b.n	17cf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x796>
   17cf0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17cf2:	9317      	str	r3, [sp, #92]	; 0x5c
        }
        if (!(flags & FLAGS_LEFT)) {
   17cf4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17cf6:	f003 0302 	and.w	r3, r3, #2
   17cfa:	2b00      	cmp	r3, #0
   17cfc:	d113      	bne.n	17d26 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
          while (l++ < width) {
   17cfe:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17d00:	1c5a      	adds	r2, r3, #1
   17d02:	9217      	str	r2, [sp, #92]	; 0x5c
   17d04:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17d06:	429a      	cmp	r2, r3
   17d08:	bf8c      	ite	hi
   17d0a:	2301      	movhi	r3, #1
   17d0c:	2300      	movls	r3, #0
   17d0e:	b2db      	uxtb	r3, r3
   17d10:	2b00      	cmp	r3, #0
   17d12:	d008      	beq.n	17d26 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
            out(' ', buffer, idx++, maxlen);
   17d14:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17d16:	1c53      	adds	r3, r2, #1
   17d18:	931b      	str	r3, [sp, #108]	; 0x6c
   17d1a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17d1c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17d1e:	990c      	ldr	r1, [sp, #48]	; 0x30
   17d20:	2020      	movs	r0, #32
   17d22:	47a0      	blx	r4
          while (l++ < width) {
   17d24:	e7eb      	b.n	17cfe <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7a2>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   17d26:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d28:	781b      	ldrb	r3, [r3, #0]
   17d2a:	2b00      	cmp	r3, #0
   17d2c:	d00b      	beq.n	17d46 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   17d2e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17d30:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17d34:	2b00      	cmp	r3, #0
   17d36:	d004      	beq.n	17d42 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7e6>
   17d38:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17d3a:	1e5a      	subs	r2, r3, #1
   17d3c:	921d      	str	r2, [sp, #116]	; 0x74
   17d3e:	2b00      	cmp	r3, #0
   17d40:	d001      	beq.n	17d46 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   17d42:	2301      	movs	r3, #1
   17d44:	e000      	b.n	17d48 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ec>
   17d46:	2300      	movs	r3, #0
   17d48:	2b00      	cmp	r3, #0
   17d4a:	d00b      	beq.n	17d64 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x808>
          out(*(p++), buffer, idx++, maxlen);
   17d4c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17d4e:	1c5a      	adds	r2, r3, #1
   17d50:	9218      	str	r2, [sp, #96]	; 0x60
   17d52:	7818      	ldrb	r0, [r3, #0]
   17d54:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17d56:	1c53      	adds	r3, r2, #1
   17d58:	931b      	str	r3, [sp, #108]	; 0x6c
   17d5a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17d5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17d5e:	990c      	ldr	r1, [sp, #48]	; 0x30
   17d60:	47a0      	blx	r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   17d62:	e7e0      	b.n	17d26 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
   17d64:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17d66:	f003 0302 	and.w	r3, r3, #2
   17d6a:	2b00      	cmp	r3, #0
   17d6c:	d013      	beq.n	17d96 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
          while (l++ < width) {
   17d6e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17d70:	1c5a      	adds	r2, r3, #1
   17d72:	9217      	str	r2, [sp, #92]	; 0x5c
   17d74:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17d76:	429a      	cmp	r2, r3
   17d78:	bf8c      	ite	hi
   17d7a:	2301      	movhi	r3, #1
   17d7c:	2300      	movls	r3, #0
   17d7e:	b2db      	uxtb	r3, r3
   17d80:	2b00      	cmp	r3, #0
   17d82:	d008      	beq.n	17d96 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
            out(' ', buffer, idx++, maxlen);
   17d84:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17d86:	1c53      	adds	r3, r2, #1
   17d88:	931b      	str	r3, [sp, #108]	; 0x6c
   17d8a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17d8c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17d8e:	990c      	ldr	r1, [sp, #48]	; 0x30
   17d90:	2020      	movs	r0, #32
   17d92:	47a0      	blx	r4
          while (l++ < width) {
   17d94:	e7eb      	b.n	17d6e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x812>
          }
        }
        format++;
   17d96:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17d98:	3301      	adds	r3, #1
   17d9a:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17d9c:	e03c      	b.n	17e18 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
   17d9e:	2308      	movs	r3, #8
   17da0:	931e      	str	r3, [sp, #120]	; 0x78
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   17da2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17da4:	f043 0321 	orr.w	r3, r3, #33	; 0x21
   17da8:	931f      	str	r3, [sp, #124]	; 0x7c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   17daa:	2300      	movs	r3, #0
   17dac:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   17db0:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17db2:	1d1a      	adds	r2, r3, #4
   17db4:	9224      	str	r2, [sp, #144]	; 0x90
   17db6:	681b      	ldr	r3, [r3, #0]
   17db8:	461a      	mov	r2, r3
   17dba:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17dbc:	9305      	str	r3, [sp, #20]
   17dbe:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17dc0:	9304      	str	r3, [sp, #16]
   17dc2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17dc4:	9303      	str	r3, [sp, #12]
   17dc6:	2310      	movs	r3, #16
   17dc8:	9302      	str	r3, [sp, #8]
   17dca:	2300      	movs	r3, #0
   17dcc:	9301      	str	r3, [sp, #4]
   17dce:	9200      	str	r2, [sp, #0]
   17dd0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17dd2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17dd4:	990c      	ldr	r1, [sp, #48]	; 0x30
   17dd6:	980d      	ldr	r0, [sp, #52]	; 0x34
   17dd8:	f7ff f8b8 	bl	16f4c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   17ddc:	901b      	str	r0, [sp, #108]	; 0x6c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
   17dde:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17de0:	3301      	adds	r3, #1
   17de2:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17de4:	e018      	b.n	17e18 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
   17de6:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17de8:	1c53      	adds	r3, r2, #1
   17dea:	931b      	str	r3, [sp, #108]	; 0x6c
   17dec:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17dee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17df0:	990c      	ldr	r1, [sp, #48]	; 0x30
   17df2:	2025      	movs	r0, #37	; 0x25
   17df4:	47a0      	blx	r4
        format++;
   17df6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17df8:	3301      	adds	r3, #1
   17dfa:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17dfc:	e00c      	b.n	17e18 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>

      default :
        out(*format, buffer, idx++, maxlen);
   17dfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17e00:	7818      	ldrb	r0, [r3, #0]
   17e02:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17e04:	1c53      	adds	r3, r2, #1
   17e06:	931b      	str	r3, [sp, #108]	; 0x6c
   17e08:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17e0a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17e0c:	990c      	ldr	r1, [sp, #48]	; 0x30
   17e0e:	47a0      	blx	r4
        format++;
   17e10:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17e12:	3301      	adds	r3, #1
   17e14:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17e16:	bf00      	nop
  while (*format)
   17e18:	f7ff bbb3 	b.w	17582 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   17e1c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17e1e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17e20:	429a      	cmp	r2, r3
   17e22:	d302      	bcc.n	17e2a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ce>
   17e24:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17e26:	1e5a      	subs	r2, r3, #1
   17e28:	e000      	b.n	17e2c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8d0>
   17e2a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17e2c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17e2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17e30:	990c      	ldr	r1, [sp, #48]	; 0x30
   17e32:	2000      	movs	r0, #0
   17e34:	47a0      	blx	r4

  // return written chars without terminating \0
  return (int)idx;
   17e36:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   17e38:	4633      	mov	r3, r6
   17e3a:	4619      	mov	r1, r3
   17e3c:	4803      	ldr	r0, [pc, #12]	; (17e4c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8f0>)
   17e3e:	f7fd fc37 	bl	156b0 <__cyg_profile_func_exit>
   17e42:	4623      	mov	r3, r4
}
   17e44:	4618      	mov	r0, r3
   17e46:	b020      	add	sp, #128	; 0x80
   17e48:	bd70      	pop	{r4, r5, r6, pc}
   17e4a:	bf00      	nop
   17e4c:	0001755d 	.word	0x0001755d

00017e50 <printf>:

///////////////////////////////////////////////////////////////////////////////


int printf(const char* format, ...)
{
   17e50:	b40f      	push	{r0, r1, r2, r3}
   17e52:	b530      	push	{r4, r5, lr}
   17e54:	b087      	sub	sp, #28
   17e56:	4675      	mov	r5, lr
   17e58:	462b      	mov	r3, r5
   17e5a:	4619      	mov	r1, r3
   17e5c:	480d      	ldr	r0, [pc, #52]	; (17e94 <printf+0x44>)
   17e5e:	f7fd fc13 	bl	15688 <__cyg_profile_func_enter>
  va_list va;
  va_start(va, format);
   17e62:	ab0b      	add	r3, sp, #44	; 0x2c
   17e64:	9304      	str	r3, [sp, #16]
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   17e66:	a903      	add	r1, sp, #12
   17e68:	9b04      	ldr	r3, [sp, #16]
   17e6a:	9300      	str	r3, [sp, #0]
   17e6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17e6e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17e72:	4809      	ldr	r0, [pc, #36]	; (17e98 <printf+0x48>)
   17e74:	f7ff fb72 	bl	1755c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   17e78:	9005      	str	r0, [sp, #20]
  va_end(va);
  return ret;
   17e7a:	9c05      	ldr	r4, [sp, #20]
   17e7c:	462b      	mov	r3, r5
   17e7e:	4619      	mov	r1, r3
   17e80:	4804      	ldr	r0, [pc, #16]	; (17e94 <printf+0x44>)
   17e82:	f7fd fc15 	bl	156b0 <__cyg_profile_func_exit>
   17e86:	4623      	mov	r3, r4
}
   17e88:	4618      	mov	r0, r3
   17e8a:	b007      	add	sp, #28
   17e8c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   17e90:	b004      	add	sp, #16
   17e92:	4770      	bx	lr
   17e94:	00017e51 	.word	0x00017e51
   17e98:	00016bc5 	.word	0x00016bc5

00017e9c <vsnprintf>:
  return ret;
}


int vsnprintf(char* buffer, size_t count, const char* format, va_list va)
{
   17e9c:	b530      	push	{r4, r5, lr}
   17e9e:	b087      	sub	sp, #28
   17ea0:	4674      	mov	r4, lr
   17ea2:	9005      	str	r0, [sp, #20]
   17ea4:	9104      	str	r1, [sp, #16]
   17ea6:	9203      	str	r2, [sp, #12]
   17ea8:	9302      	str	r3, [sp, #8]
   17eaa:	4623      	mov	r3, r4
   17eac:	4619      	mov	r1, r3
   17eae:	480a      	ldr	r0, [pc, #40]	; (17ed8 <vsnprintf+0x3c>)
   17eb0:	f7fd fbea 	bl	15688 <__cyg_profile_func_enter>
  return _vsnprintf(_out_buffer, buffer, count, format, va);
   17eb4:	9b02      	ldr	r3, [sp, #8]
   17eb6:	9300      	str	r3, [sp, #0]
   17eb8:	9b03      	ldr	r3, [sp, #12]
   17eba:	9a04      	ldr	r2, [sp, #16]
   17ebc:	9905      	ldr	r1, [sp, #20]
   17ebe:	4807      	ldr	r0, [pc, #28]	; (17edc <vsnprintf+0x40>)
   17ec0:	f7ff fb4c 	bl	1755c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   17ec4:	4605      	mov	r5, r0
   17ec6:	4623      	mov	r3, r4
   17ec8:	4619      	mov	r1, r3
   17eca:	4803      	ldr	r0, [pc, #12]	; (17ed8 <vsnprintf+0x3c>)
   17ecc:	f7fd fbf0 	bl	156b0 <__cyg_profile_func_exit>
   17ed0:	462b      	mov	r3, r5
}
   17ed2:	4618      	mov	r0, r3
   17ed4:	b007      	add	sp, #28
   17ed6:	bd30      	pop	{r4, r5, pc}
   17ed8:	00017e9d 	.word	0x00017e9d
   17edc:	00016b51 	.word	0x00016b51

00017ee0 <Wait(unsigned long long)::{lambda()#1}::operator()() const>:

inline Status Wait(uint64_t timeout)
{
  return Wait(timeout, []() -> bool { return false; });
   17ee0:	b530      	push	{r4, r5, lr}
   17ee2:	b083      	sub	sp, #12
   17ee4:	4675      	mov	r5, lr
   17ee6:	9001      	str	r0, [sp, #4]
   17ee8:	462b      	mov	r3, r5
   17eea:	4619      	mov	r1, r3
   17eec:	4806      	ldr	r0, [pc, #24]	; (17f08 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   17eee:	f7fd fbcb 	bl	15688 <__cyg_profile_func_enter>
   17ef2:	2400      	movs	r4, #0
   17ef4:	462b      	mov	r3, r5
   17ef6:	4619      	mov	r1, r3
   17ef8:	4803      	ldr	r0, [pc, #12]	; (17f08 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   17efa:	f7fd fbd9 	bl	156b0 <__cyg_profile_func_exit>
   17efe:	4623      	mov	r3, r4
   17f00:	4618      	mov	r0, r3
   17f02:	b003      	add	sp, #12
   17f04:	bd30      	pop	{r4, r5, pc}
   17f06:	bf00      	nop
   17f08:	00017ee1 	.word	0x00017ee1

00017f0c <Wait(unsigned long long)::{lambda()#1}::_FUN()>:
   17f0c:	b538      	push	{r3, r4, r5, lr}
   17f0e:	4674      	mov	r4, lr
   17f10:	4623      	mov	r3, r4
   17f12:	4619      	mov	r1, r3
   17f14:	4807      	ldr	r0, [pc, #28]	; (17f34 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   17f16:	f7fd fbb7 	bl	15688 <__cyg_profile_func_enter>
   17f1a:	2000      	movs	r0, #0
   17f1c:	f7ff ffe0 	bl	17ee0 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   17f20:	4603      	mov	r3, r0
   17f22:	461d      	mov	r5, r3
   17f24:	4623      	mov	r3, r4
   17f26:	4619      	mov	r1, r3
   17f28:	4802      	ldr	r0, [pc, #8]	; (17f34 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   17f2a:	f7fd fbc1 	bl	156b0 <__cyg_profile_func_exit>
   17f2e:	462b      	mov	r3, r5
   17f30:	4618      	mov	r0, r3
   17f32:	bd38      	pop	{r3, r4, r5, pc}
   17f34:	00017f0d 	.word	0x00017f0d

00017f38 <Wait(unsigned long long)>:
{
   17f38:	b5f0      	push	{r4, r5, r6, r7, lr}
   17f3a:	b089      	sub	sp, #36	; 0x24
   17f3c:	4675      	mov	r5, lr
   17f3e:	e9cd 0100 	strd	r0, r1, [sp]
   17f42:	462b      	mov	r3, r5
   17f44:	4619      	mov	r1, r3
   17f46:	482b      	ldr	r0, [pc, #172]	; (17ff4 <Wait(unsigned long long)+0xbc>)
   17f48:	f7fd fb9e 	bl	15688 <__cyg_profile_func_enter>
   17f4c:	e9dd 3400 	ldrd	r3, r4, [sp]
   17f50:	e9cd 3406 	strd	r3, r4, [sp, #24]
   17f54:	f88d 6008 	strb.w	r6, [sp, #8]
   17f58:	462b      	mov	r3, r5
   17f5a:	4619      	mov	r1, r3
   17f5c:	4826      	ldr	r0, [pc, #152]	; (17ff8 <Wait(unsigned long long)+0xc0>)
   17f5e:	f7fd fb93 	bl	15688 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   17f62:	f04f 0300 	mov.w	r3, #0
   17f66:	f04f 0400 	mov.w	r4, #0
   17f6a:	e9cd 3404 	strd	r3, r4, [sp, #16]
  if (timeout == kMaxWait)
   17f6e:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   17f72:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   17f76:	bf08      	it	eq
   17f78:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   17f7c:	d106      	bne.n	17f8c <Wait(unsigned long long)+0x54>
    timeout_time = kMaxWait;
   17f7e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17f82:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   17f86:	e9cd 3404 	strd	r3, r4, [sp, #16]
   17f8a:	e00a      	b.n	17fa2 <Wait(unsigned long long)+0x6a>
    timeout_time = Milliseconds() + timeout;
   17f8c:	f7f8 fdbc 	bl	10b08 <Milliseconds()>
   17f90:	460a      	mov	r2, r1
   17f92:	4601      	mov	r1, r0
   17f94:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   17f98:	185e      	adds	r6, r3, r1
   17f9a:	eb44 0702 	adc.w	r7, r4, r2
   17f9e:	e9cd 6704 	strd	r6, r7, [sp, #16]
  Status status = Status::kTimedOut;
   17fa2:	2301      	movs	r3, #1
   17fa4:	9303      	str	r3, [sp, #12]
  while (Milliseconds() < timeout_time)
   17fa6:	f7f8 fdaf 	bl	10b08 <Milliseconds()>
   17faa:	460a      	mov	r2, r1
   17fac:	4601      	mov	r1, r0
   17fae:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   17fb2:	42a2      	cmp	r2, r4
   17fb4:	bf08      	it	eq
   17fb6:	4299      	cmpeq	r1, r3
   17fb8:	bf34      	ite	cc
   17fba:	2301      	movcc	r3, #1
   17fbc:	2300      	movcs	r3, #0
   17fbe:	b2db      	uxtb	r3, r3
   17fc0:	2b00      	cmp	r3, #0
   17fc2:	d008      	beq.n	17fd6 <Wait(unsigned long long)+0x9e>
    if (is_done())
   17fc4:	ab02      	add	r3, sp, #8
   17fc6:	4618      	mov	r0, r3
   17fc8:	f7ff ff8a 	bl	17ee0 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   17fcc:	4603      	mov	r3, r0
   17fce:	2b00      	cmp	r3, #0
   17fd0:	d0e9      	beq.n	17fa6 <Wait(unsigned long long)+0x6e>
      status = Status::kSuccess;
   17fd2:	2300      	movs	r3, #0
   17fd4:	9303      	str	r3, [sp, #12]
  return status;
   17fd6:	9c03      	ldr	r4, [sp, #12]
   17fd8:	462b      	mov	r3, r5
   17fda:	4619      	mov	r1, r3
   17fdc:	4806      	ldr	r0, [pc, #24]	; (17ff8 <Wait(unsigned long long)+0xc0>)
   17fde:	f7fd fb67 	bl	156b0 <__cyg_profile_func_exit>
   17fe2:	462b      	mov	r3, r5
   17fe4:	4619      	mov	r1, r3
   17fe6:	4803      	ldr	r0, [pc, #12]	; (17ff4 <Wait(unsigned long long)+0xbc>)
   17fe8:	f7fd fb62 	bl	156b0 <__cyg_profile_func_exit>
  return Wait(timeout, []() -> bool { return false; });
   17fec:	4623      	mov	r3, r4
}
   17fee:	4618      	mov	r0, r3
   17ff0:	b009      	add	sp, #36	; 0x24
   17ff2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17ff4:	00017f39 	.word	0x00017f39
   17ff8:	000192fd 	.word	0x000192fd

00017ffc <Delay(unsigned long long)>:

// Delay the system for a duration of time
inline void Delay([[maybe_unused]] uint64_t delay_time_ms)
{
   17ffc:	b510      	push	{r4, lr}
   17ffe:	b082      	sub	sp, #8
   18000:	4674      	mov	r4, lr
   18002:	e9cd 0100 	strd	r0, r1, [sp]
   18006:	4623      	mov	r3, r4
   18008:	4619      	mov	r1, r3
   1800a:	4807      	ldr	r0, [pc, #28]	; (18028 <Delay(unsigned long long)+0x2c>)
   1800c:	f7fd fb3c 	bl	15688 <__cyg_profile_func_enter>
#if defined(HOST_TEST)
  return;
#else
  Wait(delay_time_ms);
   18010:	e9dd 0100 	ldrd	r0, r1, [sp]
   18014:	f7ff ff90 	bl	17f38 <Wait(unsigned long long)>
   18018:	4623      	mov	r3, r4
   1801a:	4619      	mov	r1, r3
   1801c:	4802      	ldr	r0, [pc, #8]	; (18028 <Delay(unsigned long long)+0x2c>)
   1801e:	f7fd fb47 	bl	156b0 <__cyg_profile_func_exit>
#endif  // HOST_TEST
}
   18022:	bf00      	nop
   18024:	b002      	add	sp, #8
   18026:	bd10      	pop	{r4, pc}
   18028:	00017ffd 	.word	0x00017ffd

0001802c <SdInterface::SdInterface()>:
// NOLINTNEXTLINE(readability-identifier-naming)
// Relevant Datasheet:
// https://www.sdcard.org/downloads/pls/pdf/index.php?p=Part1_Physical_Layer_Simplified_Specification_Ver6.00.jpg&f=Part1_Physical_Layer_Simplified_Specification_Ver6.00.pdf&e=EN_SS1
// TODO(#348):  Write a class to represent a single Sd Card Block to make use
//              of block-related functions easier.
class SdInterface
   1802c:	b530      	push	{r4, r5, lr}
   1802e:	b083      	sub	sp, #12
   18030:	4675      	mov	r5, lr
   18032:	9001      	str	r0, [sp, #4]
   18034:	462b      	mov	r3, r5
   18036:	4619      	mov	r1, r3
   18038:	4807      	ldr	r0, [pc, #28]	; (18058 <SdInterface::SdInterface()+0x2c>)
   1803a:	f7fd fb25 	bl	15688 <__cyg_profile_func_enter>
   1803e:	4a07      	ldr	r2, [pc, #28]	; (1805c <SdInterface::SdInterface()+0x30>)
   18040:	9b01      	ldr	r3, [sp, #4]
   18042:	601a      	str	r2, [r3, #0]
   18044:	9c01      	ldr	r4, [sp, #4]
   18046:	462b      	mov	r3, r5
   18048:	4619      	mov	r1, r3
   1804a:	4803      	ldr	r0, [pc, #12]	; (18058 <SdInterface::SdInterface()+0x2c>)
   1804c:	f7fd fb30 	bl	156b0 <__cyg_profile_func_exit>
   18050:	4623      	mov	r3, r4
   18052:	4618      	mov	r0, r3
   18054:	b003      	add	sp, #12
   18056:	bd30      	pop	{r4, r5, pc}
   18058:	0001802d 	.word	0x0001802d
   1805c:	0001c5a8 	.word	0x0001c5a8

00018060 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>:
  /// port that is broken out through the board's GPIO, allowing you to probe
  /// the chip select manually. To use this version instead of the main version,
  /// instantiate an Sd card instance like so:
  ///
  ///   Sd sdcard(Sd::DebugSdCard_t{});
  constexpr Sd(DebugSdCard_t, uint8_t port = 1, uint8_t pin = 8,
   18060:	b530      	push	{r4, r5, lr}
   18062:	b083      	sub	sp, #12
   18064:	4675      	mov	r5, lr
   18066:	9001      	str	r0, [sp, #4]
   18068:	f88d 1000 	strb.w	r1, [sp]
   1806c:	4611      	mov	r1, r2
   1806e:	461a      	mov	r2, r3
   18070:	460b      	mov	r3, r1
   18072:	f88d 3003 	strb.w	r3, [sp, #3]
   18076:	4613      	mov	r3, r2
   18078:	f88d 3002 	strb.w	r3, [sp, #2]
   1807c:	462b      	mov	r3, r5
   1807e:	4619      	mov	r1, r3
   18080:	481d      	ldr	r0, [pc, #116]	; (180f8 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   18082:	f7fd fb01 	bl	15688 <__cyg_profile_func_enter>
      : ssp_interface_(&ssp_),
        ssp_(Ssp::Peripheral::kSsp2),
        chip_select_(&chip_select_pin_),
        chip_select_external_(&chip_select_external_pin_),
        chip_select_pin_(port, pin),
        chip_select_external_pin_(extport, extpin)
   18086:	9b01      	ldr	r3, [sp, #4]
   18088:	4618      	mov	r0, r3
   1808a:	f7ff ffcf 	bl	1802c <SdInterface::SdInterface()>
   1808e:	4a1b      	ldr	r2, [pc, #108]	; (180fc <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x9c>)
   18090:	9b01      	ldr	r3, [sp, #4]
   18092:	601a      	str	r2, [r3, #0]
   18094:	9b01      	ldr	r3, [sp, #4]
   18096:	f103 0208 	add.w	r2, r3, #8
   1809a:	9b01      	ldr	r3, [sp, #4]
   1809c:	605a      	str	r2, [r3, #4]
   1809e:	9b01      	ldr	r3, [sp, #4]
   180a0:	3308      	adds	r3, #8
   180a2:	2102      	movs	r1, #2
   180a4:	4618      	mov	r0, r3
   180a6:	f7f9 fd5b 	bl	11b60 <Ssp::Ssp(Ssp::Peripheral)>
   180aa:	9b01      	ldr	r3, [sp, #4]
   180ac:	f103 0240 	add.w	r2, r3, #64	; 0x40
   180b0:	9b01      	ldr	r3, [sp, #4]
   180b2:	639a      	str	r2, [r3, #56]	; 0x38
   180b4:	9b01      	ldr	r3, [sp, #4]
   180b6:	f103 0254 	add.w	r2, r3, #84	; 0x54
   180ba:	9b01      	ldr	r3, [sp, #4]
   180bc:	63da      	str	r2, [r3, #60]	; 0x3c
   180be:	9b01      	ldr	r3, [sp, #4]
   180c0:	3340      	adds	r3, #64	; 0x40
   180c2:	f89d 2002 	ldrb.w	r2, [sp, #2]
   180c6:	f89d 1003 	ldrb.w	r1, [sp, #3]
   180ca:	4618      	mov	r0, r3
   180cc:	f7f8 fd58 	bl	10b80 <Gpio::Gpio(unsigned char, unsigned char)>
   180d0:	9b01      	ldr	r3, [sp, #4]
   180d2:	3354      	adds	r3, #84	; 0x54
   180d4:	f89d 201c 	ldrb.w	r2, [sp, #28]
   180d8:	f89d 1018 	ldrb.w	r1, [sp, #24]
   180dc:	4618      	mov	r0, r3
   180de:	f7f8 fd4f 	bl	10b80 <Gpio::Gpio(unsigned char, unsigned char)>
  {
  }
   180e2:	9c01      	ldr	r4, [sp, #4]
   180e4:	462b      	mov	r3, r5
   180e6:	4619      	mov	r1, r3
   180e8:	4803      	ldr	r0, [pc, #12]	; (180f8 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   180ea:	f7fd fae1 	bl	156b0 <__cyg_profile_func_exit>
   180ee:	4623      	mov	r3, r4
   180f0:	4618      	mov	r0, r3
   180f2:	b003      	add	sp, #12
   180f4:	bd30      	pop	{r4, r5, pc}
   180f6:	bf00      	nop
   180f8:	00018061 	.word	0x00018061
   180fc:	0001c57c 	.word	0x0001c57c

00018100 <Sd::Initialize()>:

  void Initialize() override
   18100:	b530      	push	{r4, r5, lr}
   18102:	b085      	sub	sp, #20
   18104:	4675      	mov	r5, lr
   18106:	9003      	str	r0, [sp, #12]
   18108:	462b      	mov	r3, r5
   1810a:	4619      	mov	r1, r3
   1810c:	4827      	ldr	r0, [pc, #156]	; (181ac <Sd::Initialize()+0xac>)
   1810e:	f7fd fabb 	bl	15688 <__cyg_profile_func_enter>
  {
    LOG_DEBUG("Begin initialization:");
    LOG_DEBUG("Setting CS as output...");
    chip_select_->SetAsOutput();
   18112:	9b03      	ldr	r3, [sp, #12]
   18114:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18116:	9b03      	ldr	r3, [sp, #12]
   18118:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1811a:	681b      	ldr	r3, [r3, #0]
   1811c:	3304      	adds	r3, #4
   1811e:	681b      	ldr	r3, [r3, #0]
   18120:	4610      	mov	r0, r2
   18122:	4798      	blx	r3
    chip_select_->SetHigh();
   18124:	9b03      	ldr	r3, [sp, #12]
   18126:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18128:	9b03      	ldr	r3, [sp, #12]
   1812a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1812c:	681b      	ldr	r3, [r3, #0]
   1812e:	330c      	adds	r3, #12
   18130:	681b      	ldr	r3, [r3, #0]
   18132:	4610      	mov	r0, r2
   18134:	4798      	blx	r3
    chip_select_external_->SetAsOutput();
   18136:	9b03      	ldr	r3, [sp, #12]
   18138:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   1813a:	9b03      	ldr	r3, [sp, #12]
   1813c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1813e:	681b      	ldr	r3, [r3, #0]
   18140:	3304      	adds	r3, #4
   18142:	681b      	ldr	r3, [r3, #0]
   18144:	4610      	mov	r0, r2
   18146:	4798      	blx	r3
    chip_select_external_->SetHigh();
   18148:	9b03      	ldr	r3, [sp, #12]
   1814a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   1814c:	9b03      	ldr	r3, [sp, #12]
   1814e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   18150:	681b      	ldr	r3, [r3, #0]
   18152:	330c      	adds	r3, #12
   18154:	681b      	ldr	r3, [r3, #0]
   18156:	4610      	mov	r0, r2
   18158:	4798      	blx	r3

    LOG_DEBUG("Setting SSP Clock Speed...");
    ssp_interface_->SetClock(false, false, 14, 2);  // 400kHz
   1815a:	9b03      	ldr	r3, [sp, #12]
   1815c:	6858      	ldr	r0, [r3, #4]
   1815e:	9b03      	ldr	r3, [sp, #12]
   18160:	685b      	ldr	r3, [r3, #4]
   18162:	681b      	ldr	r3, [r3, #0]
   18164:	3318      	adds	r3, #24
   18166:	681c      	ldr	r4, [r3, #0]
   18168:	2302      	movs	r3, #2
   1816a:	9300      	str	r3, [sp, #0]
   1816c:	230e      	movs	r3, #14
   1816e:	2200      	movs	r2, #0
   18170:	2100      	movs	r1, #0
   18172:	47a0      	blx	r4

    LOG_DEBUG("Setting Peripheral Mode...");
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   18174:	9b03      	ldr	r3, [sp, #12]
   18176:	6858      	ldr	r0, [r3, #4]
   18178:	9b03      	ldr	r3, [sp, #12]
   1817a:	685b      	ldr	r3, [r3, #4]
                                      Ssp::FrameMode::kSpi,
                                      Ssp::DataSize::kEight);
   1817c:	681b      	ldr	r3, [r3, #0]
   1817e:	3310      	adds	r3, #16
   18180:	681c      	ldr	r4, [r3, #0]
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   18182:	2307      	movs	r3, #7
   18184:	2200      	movs	r2, #0
   18186:	2100      	movs	r1, #0
   18188:	47a0      	blx	r4

    LOG_DEBUG("Starting SSP Peripheral...");
    ssp_interface_->Initialize();
   1818a:	9b03      	ldr	r3, [sp, #12]
   1818c:	685a      	ldr	r2, [r3, #4]
   1818e:	9b03      	ldr	r3, [sp, #12]
   18190:	685b      	ldr	r3, [r3, #4]
   18192:	681b      	ldr	r3, [r3, #0]
   18194:	681b      	ldr	r3, [r3, #0]
   18196:	4610      	mov	r0, r2
   18198:	4798      	blx	r3
   1819a:	462b      	mov	r3, r5
   1819c:	4619      	mov	r1, r3
   1819e:	4803      	ldr	r0, [pc, #12]	; (181ac <Sd::Initialize()+0xac>)
   181a0:	f7fd fa86 	bl	156b0 <__cyg_profile_func_exit>
  }
   181a4:	bf00      	nop
   181a6:	b005      	add	sp, #20
   181a8:	bd30      	pop	{r4, r5, pc}
   181aa:	bf00      	nop
   181ac:	00018101 	.word	0x00018101

000181b0 <Sd::Mount(SdInterface::CardInfo_t*)>:

  // Initialize SD Card
  // TODO(#349): Split method into smaller piece with single jobs
  bool Mount(CardInfo_t * sd) override
   181b0:	b530      	push	{r4, r5, lr}
   181b2:	b08b      	sub	sp, #44	; 0x2c
   181b4:	4675      	mov	r5, lr
   181b6:	9003      	str	r0, [sp, #12]
   181b8:	9102      	str	r1, [sp, #8]
   181ba:	462b      	mov	r3, r5
   181bc:	4619      	mov	r1, r3
   181be:	48a7      	ldr	r0, [pc, #668]	; (1845c <Sd::Mount(SdInterface::CardInfo_t*)+0x2ac>)
   181c0:	f7fd fa62 	bl	15688 <__cyg_profile_func_enter>
  {
    uint8_t tries     = 0;
   181c4:	2300      	movs	r3, #0
   181c6:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    bool card_is_idle = false;
   181ca:	2300      	movs	r3, #0
   181cc:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26

    // Reset the card and force it to go to idle state at <400kHz with a
    // CMD0 + (active-low) CS
    LOG_DEBUG("Sending SD Card to Idle State...");
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   181d0:	9b03      	ldr	r3, [sp, #12]
   181d2:	681b      	ldr	r3, [r3, #0]
   181d4:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
   181d6:	9b02      	ldr	r3, [sp, #8]
   181d8:	f103 0208 	add.w	r2, r3, #8
   181dc:	2301      	movs	r3, #1
   181de:	9301      	str	r3, [sp, #4]
   181e0:	2364      	movs	r3, #100	; 0x64
   181e2:	9300      	str	r3, [sp, #0]
   181e4:	4613      	mov	r3, r2
   181e6:	2200      	movs	r2, #0
   181e8:	2140      	movs	r1, #64	; 0x40
   181ea:	9803      	ldr	r0, [sp, #12]
   181ec:	47a0      	blx	r4
   181ee:	4602      	mov	r2, r0
   181f0:	9b02      	ldr	r3, [sp, #8]
   181f2:	611a      	str	r2, [r3, #16]

    // Reset the card again to trigger SPI mode
    LOG_DEBUG("Initializing SPI mode...");
    do
    {
      tries++;
   181f4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   181f8:	3301      	adds	r3, #1
   181fa:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      sd->response.length = SendCmd(
          Command::kReset, 0x00, sd->response.data.byte, 100, KeepAlive::kYes);
   181fe:	9b03      	ldr	r3, [sp, #12]
   18200:	681b      	ldr	r3, [r3, #0]
   18202:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(
   18204:	9b02      	ldr	r3, [sp, #8]
   18206:	f103 0208 	add.w	r2, r3, #8
   1820a:	2301      	movs	r3, #1
   1820c:	9301      	str	r3, [sp, #4]
   1820e:	2364      	movs	r3, #100	; 0x64
   18210:	9300      	str	r3, [sp, #0]
   18212:	4613      	mov	r3, r2
   18214:	2200      	movs	r2, #0
   18216:	2140      	movs	r1, #64	; 0x40
   18218:	9803      	ldr	r0, [sp, #12]
   1821a:	47a0      	blx	r4
   1821c:	4602      	mov	r2, r0
   1821e:	9b02      	ldr	r3, [sp, #8]
   18220:	611a      	str	r2, [r3, #16]

      // Check if R1 response frame's bit 1 is set (to ensure that
      // card is in idle state)
      if (sd->response.data.byte[0] != 0xFF &&
   18222:	9b02      	ldr	r3, [sp, #8]
   18224:	7a1b      	ldrb	r3, [r3, #8]
   18226:	2bff      	cmp	r3, #255	; 0xff
   18228:	d008      	beq.n	1823c <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
          (sd->response.data.byte[0] & 0x01) == 0x01)
   1822a:	9b02      	ldr	r3, [sp, #8]
   1822c:	7a1b      	ldrb	r3, [r3, #8]
   1822e:	f003 0301 	and.w	r3, r3, #1
      if (sd->response.data.byte[0] != 0xFF &&
   18232:	2b00      	cmp	r3, #0
   18234:	d002      	beq.n	1823c <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
      {
        // If it is, we can move on; otherwise, keep trying for a set
        // amount of tries
        card_is_idle = true;
   18236:	2301      	movs	r3, #1
   18238:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
      }
      Delay(10);
   1823c:	f04f 000a 	mov.w	r0, #10
   18240:	f04f 0100 	mov.w	r1, #0
   18244:	f7ff feda 	bl	17ffc <Delay(unsigned long long)>
    } while (tries < kBusTimeout && !card_is_idle);
   18248:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1824c:	2bf9      	cmp	r3, #249	; 0xf9
   1824e:	d804      	bhi.n	1825a <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
   18250:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   18254:	2b00      	cmp	r3, #0
   18256:	d100      	bne.n	1825a <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
    do
   18258:	e7cc      	b.n	181f4 <Sd::Mount(SdInterface::CardInfo_t*)+0x44>
    LOG_DEBUG("%d tries", tries);
    if (tries >= kBusTimeout)
   1825a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1825e:	2bf9      	cmp	r3, #249	; 0xf9
   18260:	d91b      	bls.n	1829a <Sd::Mount(SdInterface::CardInfo_t*)+0xea>
    {
      LOG_ERROR("Failed to initiate SPI mode within timeout. Aborting!");
   18262:	f240 13ff 	movw	r3, #511	; 0x1ff
   18266:	4a7e      	ldr	r2, [pc, #504]	; (18460 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   18268:	497e      	ldr	r1, [pc, #504]	; (18464 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b4>)
   1826a:	487f      	ldr	r0, [pc, #508]	; (18468 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b8>)
   1826c:	f7ff fdf0 	bl	17e50 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   18270:	9b03      	ldr	r3, [sp, #12]
   18272:	681b      	ldr	r3, [r3, #0]
   18274:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   18276:	9b02      	ldr	r3, [sp, #8]
   18278:	f103 0208 	add.w	r2, r3, #8
   1827c:	2300      	movs	r3, #0
   1827e:	9301      	str	r3, [sp, #4]
   18280:	2300      	movs	r3, #0
   18282:	9300      	str	r3, [sp, #0]
   18284:	4613      	mov	r3, r2
   18286:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1828a:	21ff      	movs	r1, #255	; 0xff
   1828c:	9803      	ldr	r0, [sp, #12]
   1828e:	47a0      	blx	r4
   18290:	4602      	mov	r2, r0
   18292:	9b02      	ldr	r3, [sp, #8]
   18294:	611a      	str	r2, [r3, #16]
      return false;
   18296:	2400      	movs	r4, #0
   18298:	e10c      	b.n	184b4 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Send the host's supported voltage (3.3V) and ask if the card
    // supports it
    LOG_DEBUG("Checking Current SD Card Voltage Level...");
    constexpr uint8_t kCheckPattern = 0xAB;
   1829a:	23ab      	movs	r3, #171	; 0xab
   1829c:	f88d 301f 	strb.w	r3, [sp, #31]
    uint64_t supported_voltage      = 0x00000001;
   182a0:	f04f 0301 	mov.w	r3, #1
   182a4:	f04f 0400 	mov.w	r4, #0
   182a8:	e9cd 3404 	strd	r3, r4, [sp, #16]
    sd->response.length =
        SendCmd(Command::kGetOp,
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
                sd->response.data.byte, 100, KeepAlive::kYes);
   182ac:	9b03      	ldr	r3, [sp, #12]
   182ae:	681b      	ldr	r3, [r3, #0]
   182b0:	681c      	ldr	r4, [r3, #0]
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
   182b2:	9b04      	ldr	r3, [sp, #16]
   182b4:	021b      	lsls	r3, r3, #8
        SendCmd(Command::kGetOp,
   182b6:	f043 02ab 	orr.w	r2, r3, #171	; 0xab
   182ba:	9b02      	ldr	r3, [sp, #8]
   182bc:	f103 0108 	add.w	r1, r3, #8
   182c0:	2301      	movs	r3, #1
   182c2:	9301      	str	r3, [sp, #4]
   182c4:	2364      	movs	r3, #100	; 0x64
   182c6:	9300      	str	r3, [sp, #0]
   182c8:	460b      	mov	r3, r1
   182ca:	2148      	movs	r1, #72	; 0x48
   182cc:	9803      	ldr	r0, [sp, #12]
   182ce:	47a0      	blx	r4
   182d0:	4602      	mov	r2, r0
    sd->response.length =
   182d2:	9b02      	ldr	r3, [sp, #8]
   182d4:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[4] != kCheckPattern)
   182d6:	9b02      	ldr	r3, [sp, #8]
   182d8:	7b1b      	ldrb	r3, [r3, #12]
   182da:	2bab      	cmp	r3, #171	; 0xab
   182dc:	d01b      	beq.n	18316 <Sd::Mount(SdInterface::CardInfo_t*)+0x166>
    {
      // If the last byte is not an exact echo of the LSB of the kGetOp
      // command's argument, this response is invalid
      LOG_ERROR("Response integrity check failed. Aborting!");
   182de:	f240 2312 	movw	r3, #530	; 0x212
   182e2:	4a5f      	ldr	r2, [pc, #380]	; (18460 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   182e4:	4961      	ldr	r1, [pc, #388]	; (1846c <Sd::Mount(SdInterface::CardInfo_t*)+0x2bc>)
   182e6:	4862      	ldr	r0, [pc, #392]	; (18470 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c0>)
   182e8:	f7ff fdb2 	bl	17e50 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   182ec:	9b03      	ldr	r3, [sp, #12]
   182ee:	681b      	ldr	r3, [r3, #0]
   182f0:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   182f2:	9b02      	ldr	r3, [sp, #8]
   182f4:	f103 0208 	add.w	r2, r3, #8
   182f8:	2300      	movs	r3, #0
   182fa:	9301      	str	r3, [sp, #4]
   182fc:	2300      	movs	r3, #0
   182fe:	9300      	str	r3, [sp, #0]
   18300:	4613      	mov	r3, r2
   18302:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18306:	21ff      	movs	r1, #255	; 0xff
   18308:	9803      	ldr	r0, [sp, #12]
   1830a:	47a0      	blx	r4
   1830c:	4602      	mov	r2, r0
   1830e:	9b02      	ldr	r3, [sp, #8]
   18310:	611a      	str	r2, [r3, #16]
      return false;
   18312:	2400      	movs	r4, #0
   18314:	e0ce      	b.n	184b4 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }
    else if (sd->response.data.byte[3] &
   18316:	9b02      	ldr	r3, [sp, #8]
   18318:	7adb      	ldrb	r3, [r3, #11]
   1831a:	4619      	mov	r1, r3
             (supported_voltage == static_cast<uint64_t>(0x00)))
   1831c:	9a04      	ldr	r2, [sp, #16]
   1831e:	9b05      	ldr	r3, [sp, #20]
   18320:	4313      	orrs	r3, r2
   18322:	2b00      	cmp	r3, #0
   18324:	bf0c      	ite	eq
   18326:	2301      	moveq	r3, #1
   18328:	2300      	movne	r3, #0
   1832a:	b2db      	uxtb	r3, r3
    else if (sd->response.data.byte[3] &
   1832c:	400b      	ands	r3, r1
   1832e:	2b00      	cmp	r3, #0
   18330:	d01b      	beq.n	1836a <Sd::Mount(SdInterface::CardInfo_t*)+0x1ba>
    {
      // If the 2nd-to-last byte of the reponse AND'ed with our host
      // device's supported voltage range is 0x00, the SD card doesn't
      // support our device's operating voltage
      LOG_ERROR("Unsupported voltage in use. Aborting!");
   18332:	f240 231d 	movw	r3, #541	; 0x21d
   18336:	4a4a      	ldr	r2, [pc, #296]	; (18460 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   18338:	494e      	ldr	r1, [pc, #312]	; (18474 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c4>)
   1833a:	484f      	ldr	r0, [pc, #316]	; (18478 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c8>)
   1833c:	f7ff fd88 	bl	17e50 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   18340:	9b03      	ldr	r3, [sp, #12]
   18342:	681b      	ldr	r3, [r3, #0]
   18344:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   18346:	9b02      	ldr	r3, [sp, #8]
   18348:	f103 0208 	add.w	r2, r3, #8
   1834c:	2300      	movs	r3, #0
   1834e:	9301      	str	r3, [sp, #4]
   18350:	2300      	movs	r3, #0
   18352:	9300      	str	r3, [sp, #0]
   18354:	4613      	mov	r3, r2
   18356:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1835a:	21ff      	movs	r1, #255	; 0xff
   1835c:	9803      	ldr	r0, [sp, #12]
   1835e:	47a0      	blx	r4
   18360:	4602      	mov	r2, r0
   18362:	9b02      	ldr	r3, [sp, #8]
   18364:	611a      	str	r2, [r3, #16]
      return false;
   18366:	2400      	movs	r4, #0
   18368:	e0a4      	b.n	184b4 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Indicate that the host supports SDHC/SDXC and wait for card to
    // shift out of idle state
    LOG_DEBUG("Expressing High-Capacity SD Card Support...");
    tries = 0;
   1836a:	2300      	movs	r3, #0
   1836c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    do
    {
      // Send host's operating conditions
      sd->response.length =
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
                  KeepAlive::kYes);
   18370:	9b03      	ldr	r3, [sp, #12]
   18372:	681b      	ldr	r3, [r3, #0]
   18374:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
   18376:	9b02      	ldr	r3, [sp, #8]
   18378:	f103 0208 	add.w	r2, r3, #8
   1837c:	2301      	movs	r3, #1
   1837e:	9301      	str	r3, [sp, #4]
   18380:	2364      	movs	r3, #100	; 0x64
   18382:	9300      	str	r3, [sp, #0]
   18384:	4613      	mov	r3, r2
   18386:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   1838a:	2141      	movs	r1, #65	; 0x41
   1838c:	9803      	ldr	r0, [sp, #12]
   1838e:	47a0      	blx	r4
   18390:	4602      	mov	r2, r0
      sd->response.length =
   18392:	9b02      	ldr	r3, [sp, #8]
   18394:	611a      	str	r2, [r3, #16]
      tries++;
   18396:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1839a:	3301      	adds	r3, #1
   1839c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    } while (tries < kBusTimeout && sd->response.data.byte[0] & 0x01);
   183a0:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   183a4:	2bf9      	cmp	r3, #249	; 0xf9
   183a6:	d806      	bhi.n	183b6 <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
   183a8:	9b02      	ldr	r3, [sp, #8]
   183aa:	7a1b      	ldrb	r3, [r3, #8]
   183ac:	f003 0301 	and.w	r3, r3, #1
   183b0:	2b00      	cmp	r3, #0
   183b2:	d000      	beq.n	183b6 <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
    do
   183b4:	e7dc      	b.n	18370 <Sd::Mount(SdInterface::CardInfo_t*)+0x1c0>
    if (tries == kBusTimeout)
   183b6:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   183ba:	2bfa      	cmp	r3, #250	; 0xfa
   183bc:	d11b      	bne.n	183f6 <Sd::Mount(SdInterface::CardInfo_t*)+0x246>
    {
      LOG_ERROR("SD Card timed out. Aborting!");
   183be:	f240 2331 	movw	r3, #561	; 0x231
   183c2:	4a27      	ldr	r2, [pc, #156]	; (18460 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   183c4:	492d      	ldr	r1, [pc, #180]	; (1847c <Sd::Mount(SdInterface::CardInfo_t*)+0x2cc>)
   183c6:	482e      	ldr	r0, [pc, #184]	; (18480 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d0>)
   183c8:	f7ff fd42 	bl	17e50 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   183cc:	9b03      	ldr	r3, [sp, #12]
   183ce:	681b      	ldr	r3, [r3, #0]
   183d0:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   183d2:	9b02      	ldr	r3, [sp, #8]
   183d4:	f103 0208 	add.w	r2, r3, #8
   183d8:	2300      	movs	r3, #0
   183da:	9301      	str	r3, [sp, #4]
   183dc:	2300      	movs	r3, #0
   183de:	9300      	str	r3, [sp, #0]
   183e0:	4613      	mov	r3, r2
   183e2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   183e6:	21ff      	movs	r1, #255	; 0xff
   183e8:	9803      	ldr	r0, [sp, #12]
   183ea:	47a0      	blx	r4
   183ec:	4602      	mov	r2, r0
   183ee:	9b02      	ldr	r3, [sp, #8]
   183f0:	611a      	str	r2, [r3, #16]
      return false;
   183f2:	2400      	movs	r4, #0
   183f4:	e05e      	b.n	184b4 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    // After card is ready, acquire card capacity info using kGetOcr a
    // second time
    LOG_DEBUG("Reading Card Capacity Information...");
    // Read CCS
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   183f6:	9b03      	ldr	r3, [sp, #12]
   183f8:	681b      	ldr	r3, [r3, #0]
   183fa:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
   183fc:	9b02      	ldr	r3, [sp, #8]
   183fe:	f103 0208 	add.w	r2, r3, #8
   18402:	2301      	movs	r3, #1
   18404:	9301      	str	r3, [sp, #4]
   18406:	2364      	movs	r3, #100	; 0x64
   18408:	9300      	str	r3, [sp, #0]
   1840a:	4613      	mov	r3, r2
   1840c:	2200      	movs	r2, #0
   1840e:	217a      	movs	r1, #122	; 0x7a
   18410:	9803      	ldr	r0, [sp, #12]
   18412:	47a0      	blx	r4
   18414:	4602      	mov	r2, r0
   18416:	9b02      	ldr	r3, [sp, #8]
   18418:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[1] & 0x40)
   1841a:	9b02      	ldr	r3, [sp, #8]
   1841c:	7a5b      	ldrb	r3, [r3, #9]
   1841e:	f003 0340 	and.w	r3, r3, #64	; 0x40
   18422:	2b00      	cmp	r3, #0
   18424:	d003      	beq.n	1842e <Sd::Mount(SdInterface::CardInfo_t*)+0x27e>
    {
      // The card is either high or extended capacity
      LOG_DEBUG("SD Card is HC/XC");
      sd->type = Type::kSDHC;
   18426:	9b02      	ldr	r3, [sp, #8]
   18428:	2201      	movs	r2, #1
   1842a:	605a      	str	r2, [r3, #4]
   1842c:	e002      	b.n	18434 <Sd::Mount(SdInterface::CardInfo_t*)+0x284>
    }
    else
    {
      // The card is standard capacity
      LOG_DEBUG("SD Card is SC");
      sd->type = Type::kSDSC;
   1842e:	9b02      	ldr	r3, [sp, #8]
   18430:	2200      	movs	r2, #0
   18432:	605a      	str	r2, [r3, #4]
    }

    // Store OCR information
    for (int i = 0; i < 4; i++)
   18434:	2300      	movs	r3, #0
   18436:	9308      	str	r3, [sp, #32]
   18438:	9b08      	ldr	r3, [sp, #32]
   1843a:	2b03      	cmp	r3, #3
   1843c:	dc22      	bgt.n	18484 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d4>
    {
      // ensure OCR doesn't capture the R1 section of the response
      sd->ocr.byte[i] = sd->response.data.byte[i + 1];
   1843e:	9b08      	ldr	r3, [sp, #32]
   18440:	3301      	adds	r3, #1
   18442:	9a02      	ldr	r2, [sp, #8]
   18444:	4413      	add	r3, r2
   18446:	7a19      	ldrb	r1, [r3, #8]
   18448:	9a02      	ldr	r2, [sp, #8]
   1844a:	9b08      	ldr	r3, [sp, #32]
   1844c:	4413      	add	r3, r2
   1844e:	460a      	mov	r2, r1
   18450:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < 4; i++)
   18452:	9b08      	ldr	r3, [sp, #32]
   18454:	3301      	adds	r3, #1
   18456:	9308      	str	r3, [sp, #32]
   18458:	e7ee      	b.n	18438 <Sd::Mount(SdInterface::CardInfo_t*)+0x288>
   1845a:	bf00      	nop
   1845c:	000181b1 	.word	0x000181b1
   18460:	0001c5cc 	.word	0x0001c5cc
   18464:	0001c4dc 	.word	0x0001c4dc
   18468:	0001bb70 	.word	0x0001bb70
   1846c:	0001c4e4 	.word	0x0001c4e4
   18470:	0001bbe0 	.word	0x0001bbe0
   18474:	0001c4ec 	.word	0x0001c4ec
   18478:	0001bc44 	.word	0x0001bc44
   1847c:	0001c4f4 	.word	0x0001c4f4
   18480:	0001bca4 	.word	0x0001bca4
    }

    // If card is SDSC, manually set its block size
    if (sd->type == Type::kSDSC)
   18484:	9b02      	ldr	r3, [sp, #8]
   18486:	685b      	ldr	r3, [r3, #4]
   18488:	2b00      	cmp	r3, #0
   1848a:	d112      	bne.n	184b2 <Sd::Mount(SdInterface::CardInfo_t*)+0x302>
    {
      // Send requested byte size
      sd->response.length =
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
                  sd->response.data.byte, 0, KeepAlive::kYes);
   1848c:	9b03      	ldr	r3, [sp, #12]
   1848e:	681b      	ldr	r3, [r3, #0]
   18490:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
   18492:	9b02      	ldr	r3, [sp, #8]
   18494:	f103 0208 	add.w	r2, r3, #8
   18498:	2301      	movs	r3, #1
   1849a:	9301      	str	r3, [sp, #4]
   1849c:	2300      	movs	r3, #0
   1849e:	9300      	str	r3, [sp, #0]
   184a0:	4613      	mov	r3, r2
   184a2:	f44f 7200 	mov.w	r2, #512	; 0x200
   184a6:	2150      	movs	r1, #80	; 0x50
   184a8:	9803      	ldr	r0, [sp, #12]
   184aa:	47a0      	blx	r4
   184ac:	4602      	mov	r2, r0
      sd->response.length =
   184ae:	9b02      	ldr	r3, [sp, #8]
   184b0:	611a      	str	r2, [r3, #16]
    }

    return true;
   184b2:	2401      	movs	r4, #1
   184b4:	462b      	mov	r3, r5
   184b6:	4619      	mov	r1, r3
   184b8:	4803      	ldr	r0, [pc, #12]	; (184c8 <Sd::Mount(SdInterface::CardInfo_t*)+0x318>)
   184ba:	f7fd f8f9 	bl	156b0 <__cyg_profile_func_exit>
   184be:	4623      	mov	r3, r4
  }
   184c0:	4618      	mov	r0, r3
   184c2:	b00b      	add	sp, #44	; 0x2c
   184c4:	bd30      	pop	{r4, r5, pc}
   184c6:	bf00      	nop
   184c8:	000181b1 	.word	0x000181b1

000184cc <Sd::ToBool(bool)>:

  // Returns string to represent a boolean value
  const char * ToBool(bool condition)
   184cc:	b530      	push	{r4, r5, lr}
   184ce:	b083      	sub	sp, #12
   184d0:	4675      	mov	r5, lr
   184d2:	9001      	str	r0, [sp, #4]
   184d4:	460b      	mov	r3, r1
   184d6:	f88d 3003 	strb.w	r3, [sp, #3]
   184da:	462b      	mov	r3, r5
   184dc:	4619      	mov	r1, r3
   184de:	4809      	ldr	r0, [pc, #36]	; (18504 <Sd::ToBool(bool)+0x38>)
   184e0:	f7fd f8d2 	bl	15688 <__cyg_profile_func_enter>
  {
    return (condition) ? "true" : "false";
   184e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   184e8:	2b00      	cmp	r3, #0
   184ea:	d001      	beq.n	184f0 <Sd::ToBool(bool)+0x24>
   184ec:	4c06      	ldr	r4, [pc, #24]	; (18508 <Sd::ToBool(bool)+0x3c>)
   184ee:	e000      	b.n	184f2 <Sd::ToBool(bool)+0x26>
   184f0:	4c06      	ldr	r4, [pc, #24]	; (1850c <Sd::ToBool(bool)+0x40>)
   184f2:	462b      	mov	r3, r5
   184f4:	4619      	mov	r1, r3
   184f6:	4803      	ldr	r0, [pc, #12]	; (18504 <Sd::ToBool(bool)+0x38>)
   184f8:	f7fd f8da 	bl	156b0 <__cyg_profile_func_exit>
   184fc:	4623      	mov	r3, r4
  }
   184fe:	4618      	mov	r0, r3
   18500:	b003      	add	sp, #12
   18502:	bd30      	pop	{r4, r5, pc}
   18504:	000184cd 	.word	0x000184cd
   18508:	0001bcfc 	.word	0x0001bcfc
   1850c:	0001bd04 	.word	0x0001bd04

00018510 <Sd::WaitToReadBlock()>:

  // Waits for the card to respond after a single or multi block read cmd is
  // sent.
  void WaitToReadBlock()
   18510:	b510      	push	{r4, lr}
   18512:	b084      	sub	sp, #16
   18514:	4674      	mov	r4, lr
   18516:	9001      	str	r0, [sp, #4]
   18518:	4623      	mov	r3, r4
   1851a:	4619      	mov	r1, r3
   1851c:	4814      	ldr	r0, [pc, #80]	; (18570 <Sd::WaitToReadBlock()+0x60>)
   1851e:	f7fd f8b3 	bl	15688 <__cyg_profile_func_enter>
    // Bit 4 -->  If set, card is locked
    // Bit 3 -->  If set, address is out or range
    // Bit 2 -->  If set, card ECC failed
    // Bit 1 -->  If set, CC error occurred
    // Bit 0 -->  If set, a generic error occurred
    uint8_t wait_byte = 0x00;
   18522:	2300      	movs	r3, #0
   18524:	f88d 300f 	strb.w	r3, [sp, #15]
    do
    {
      wait_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18528:	9b01      	ldr	r3, [sp, #4]
   1852a:	685a      	ldr	r2, [r3, #4]
   1852c:	9b01      	ldr	r3, [sp, #4]
   1852e:	685b      	ldr	r3, [r3, #4]
   18530:	681b      	ldr	r3, [r3, #0]
   18532:	3308      	adds	r3, #8
   18534:	681b      	ldr	r3, [r3, #0]
   18536:	21ff      	movs	r1, #255	; 0xff
   18538:	4610      	mov	r0, r2
   1853a:	4798      	blx	r3
   1853c:	4603      	mov	r3, r0
   1853e:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (wait_byte != 0xFE && (wait_byte & 0xE0) != 0x00);
   18542:	f89d 300f 	ldrb.w	r3, [sp, #15]
   18546:	2bfe      	cmp	r3, #254	; 0xfe
   18548:	d006      	beq.n	18558 <Sd::WaitToReadBlock()+0x48>
   1854a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1854e:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   18552:	2b00      	cmp	r3, #0
   18554:	d000      	beq.n	18558 <Sd::WaitToReadBlock()+0x48>
    do
   18556:	e7e7      	b.n	18528 <Sd::WaitToReadBlock()+0x18>

    // DEBUG: Check the value of the wait byte
    if (wait_byte == 0xFE)
   18558:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1855c:	2bfe      	cmp	r3, #254	; 0xfe
   1855e:	4623      	mov	r3, r4
   18560:	4619      	mov	r1, r3
   18562:	4803      	ldr	r0, [pc, #12]	; (18570 <Sd::WaitToReadBlock()+0x60>)
   18564:	f7fd f8a4 	bl	156b0 <__cyg_profile_func_exit>
      LOG_DEBUG("Addr Out of Range?: %s", ToBool(wait_byte & 0x08));
      LOG_DEBUG("Card ECC Failed?: %s", ToBool(wait_byte & 0x04));
      LOG_DEBUG("CC Error?: %s", ToBool(wait_byte & 0x02));
      LOG_DEBUG("Error?: %s", ToBool(wait_byte & 0x01));
    }
  }
   18568:	bf00      	nop
   1856a:	b004      	add	sp, #16
   1856c:	bd10      	pop	{r4, pc}
   1856e:	bf00      	nop
   18570:	00018511 	.word	0x00018511

00018574 <Sd::WaitWhileBusy()>:

  // Waits for the card to be ready to receive a new block after one has
  // been written or erased
  void WaitWhileBusy()
   18574:	b510      	push	{r4, lr}
   18576:	b084      	sub	sp, #16
   18578:	4674      	mov	r4, lr
   1857a:	9001      	str	r0, [sp, #4]
   1857c:	4623      	mov	r3, r4
   1857e:	4619      	mov	r1, r3
   18580:	480f      	ldr	r0, [pc, #60]	; (185c0 <Sd::WaitWhileBusy()+0x4c>)
   18582:	f7fd f881 	bl	15688 <__cyg_profile_func_enter>
  {
    // Wait for the card to finish programming (i.e. when the
    // bytes return to 0xFF)
    uint8_t busy_byte = 0x00;
   18586:	2300      	movs	r3, #0
   18588:	f88d 300f 	strb.w	r3, [sp, #15]
    LOG_DEBUG("Card is busy. Waiting for it to finish...");
    do
    {
      busy_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1858c:	9b01      	ldr	r3, [sp, #4]
   1858e:	685a      	ldr	r2, [r3, #4]
   18590:	9b01      	ldr	r3, [sp, #4]
   18592:	685b      	ldr	r3, [r3, #4]
   18594:	681b      	ldr	r3, [r3, #0]
   18596:	3308      	adds	r3, #8
   18598:	681b      	ldr	r3, [r3, #0]
   1859a:	21ff      	movs	r1, #255	; 0xff
   1859c:	4610      	mov	r0, r2
   1859e:	4798      	blx	r3
   185a0:	4603      	mov	r3, r0
   185a2:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (busy_byte != 0xFF);
   185a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
   185aa:	2bff      	cmp	r3, #255	; 0xff
   185ac:	d000      	beq.n	185b0 <Sd::WaitWhileBusy()+0x3c>
    do
   185ae:	e7ed      	b.n	1858c <Sd::WaitWhileBusy()+0x18>
   185b0:	4623      	mov	r3, r4
   185b2:	4619      	mov	r1, r3
   185b4:	4802      	ldr	r0, [pc, #8]	; (185c0 <Sd::WaitWhileBusy()+0x4c>)
   185b6:	f7fd f87b 	bl	156b0 <__cyg_profile_func_exit>
    LOG_DEBUG("Card finished!");
  }
   185ba:	bf00      	nop
   185bc:	b004      	add	sp, #16
   185be:	bd10      	pop	{r4, pc}
   185c0:	00018575 	.word	0x00018575

000185c4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)>:

  // Read any number of blocks from the SD card
  uint8_t ReadBlock(uint32_t address, uint8_t * array,
   185c4:	b530      	push	{r4, r5, lr}
   185c6:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
   185ca:	4675      	mov	r5, lr
   185cc:	ac05      	add	r4, sp, #20
   185ce:	6020      	str	r0, [r4, #0]
   185d0:	a804      	add	r0, sp, #16
   185d2:	6001      	str	r1, [r0, #0]
   185d4:	a903      	add	r1, sp, #12
   185d6:	600a      	str	r2, [r1, #0]
   185d8:	aa02      	add	r2, sp, #8
   185da:	6013      	str	r3, [r2, #0]
   185dc:	462b      	mov	r3, r5
   185de:	4619      	mov	r1, r3
   185e0:	487d      	ldr	r0, [pc, #500]	; (187d8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x214>)
   185e2:	f7fd f851 	bl	15688 <__cyg_profile_func_enter>
                    uint32_t blocks = 1) override
  {
    LOG_DEBUG("Block %" PRId32 " :: 0x%" PRIX32 " for %" PRId32 " blocks",
              address, address, blocks);
    // Wait for a previous command to finish
    WaitWhileBusy();
   185e6:	ab05      	add	r3, sp, #20
   185e8:	6818      	ldr	r0, [r3, #0]
   185ea:	f7ff ffc3 	bl	18574 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool payload_had_bad_crc = false;
   185ee:	2300      	movs	r3, #0
   185f0:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247

    // Create a temporary place to store blocks of 512 bytes (this is now
    // possible because the constructor enforces block size cross-
    // compatibility)
    uint8_t block_store[512] = { 0 };
   185f4:	ab06      	add	r3, sp, #24
   185f6:	4618      	mov	r0, r3
   185f8:	f44f 7300 	mov.w	r3, #512	; 0x200
   185fc:	461a      	mov	r2, r3
   185fe:	2100      	movs	r1, #0
   18600:	f001 f96b 	bl	198da <memset>

    // Determine appropriate command to send
    Command read_cmd;
    if (blocks > 1)
   18604:	ab02      	add	r3, sp, #8
   18606:	681b      	ldr	r3, [r3, #0]
   18608:	2b01      	cmp	r3, #1
   1860a:	d902      	bls.n	18612 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x4e>
    {
      read_cmd = Command::kReadMulti;
   1860c:	2352      	movs	r3, #82	; 0x52
   1860e:	9390      	str	r3, [sp, #576]	; 0x240
   18610:	e001      	b.n	18616 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x52>
    }
    else
    {
      read_cmd = Command::kReadSingle;
   18612:	2351      	movs	r3, #81	; 0x51
   18614:	9390      	str	r3, [sp, #576]	; 0x240
    }

    // Send initial read command
    sd.response.length =
        SendCmd(read_cmd, address, sd.response.data.byte, 100, KeepAlive::kYes);
   18616:	ab05      	add	r3, sp, #20
   18618:	681b      	ldr	r3, [r3, #0]
   1861a:	681b      	ldr	r3, [r3, #0]
   1861c:	681c      	ldr	r4, [r3, #0]
   1861e:	ab86      	add	r3, sp, #536	; 0x218
   18620:	f103 0108 	add.w	r1, r3, #8
   18624:	aa04      	add	r2, sp, #16
   18626:	a805      	add	r0, sp, #20
   18628:	2301      	movs	r3, #1
   1862a:	9301      	str	r3, [sp, #4]
   1862c:	2364      	movs	r3, #100	; 0x64
   1862e:	9300      	str	r3, [sp, #0]
   18630:	460b      	mov	r3, r1
   18632:	6812      	ldr	r2, [r2, #0]
   18634:	9990      	ldr	r1, [sp, #576]	; 0x240
   18636:	6800      	ldr	r0, [r0, #0]
   18638:	47a0      	blx	r4
   1863a:	4603      	mov	r3, r0
    sd.response.length =
   1863c:	938a      	str	r3, [sp, #552]	; 0x228
    LOG_DEBUG("Sent Read Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the command was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   1863e:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18642:	2b00      	cmp	r3, #0
   18644:	f040 80d8 	bne.w	187f8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x234>
    {
      // For every block requested
      uint16_t block_count;
      for (block_count = 0; block_count < blocks; block_count++)
   18648:	2300      	movs	r3, #0
   1864a:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   1864e:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   18652:	aa02      	add	r2, sp, #8
   18654:	6812      	ldr	r2, [r2, #0]
   18656:	429a      	cmp	r2, r3
   18658:	f240 8099 	bls.w	1878e <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1ca>
      {
        // Wait for the card to respond with a ready signal
        WaitToReadBlock();
   1865c:	ab05      	add	r3, sp, #20
   1865e:	6818      	ldr	r0, [r3, #0]
   18660:	f7ff ff56 	bl	18510 <Sd::WaitToReadBlock()>

        // Calculate the block address offset
        uint16_t block_addr_offset =
   18664:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   18668:	025b      	lsls	r3, r3, #9
   1866a:	f8ad 323a 	strh.w	r3, [sp, #570]	; 0x23a
            static_cast<uint16_t>(block_count * kBlockSize);

        // Read all the bytes of a single block
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   1866e:	2300      	movs	r3, #0
   18670:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   18674:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   18678:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1867c:	d22b      	bcs.n	186d6 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x112>
        {
          // Calculate the current storage index
          uint16_t storage_index =
   1867e:	f8bd 223a 	ldrh.w	r2, [sp, #570]	; 0x23a
   18682:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   18686:	4413      	add	r3, r2
   18688:	f8ad 3238 	strh.w	r3, [sp, #568]	; 0x238
              static_cast<uint16_t>(block_addr_offset + byte_count);

          // Transfer a byte to read a block from the SD card
          array[storage_index] =
              static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1868c:	ab05      	add	r3, sp, #20
   1868e:	681b      	ldr	r3, [r3, #0]
   18690:	685a      	ldr	r2, [r3, #4]
   18692:	ab05      	add	r3, sp, #20
   18694:	681b      	ldr	r3, [r3, #0]
   18696:	685b      	ldr	r3, [r3, #4]
   18698:	681b      	ldr	r3, [r3, #0]
   1869a:	3308      	adds	r3, #8
   1869c:	681b      	ldr	r3, [r3, #0]
   1869e:	21ff      	movs	r1, #255	; 0xff
   186a0:	4610      	mov	r0, r2
   186a2:	4798      	blx	r3
   186a4:	4603      	mov	r3, r0
   186a6:	4619      	mov	r1, r3
          array[storage_index] =
   186a8:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   186ac:	aa03      	add	r2, sp, #12
   186ae:	6812      	ldr	r2, [r2, #0]
   186b0:	4413      	add	r3, r2
   186b2:	b2ca      	uxtb	r2, r1
   186b4:	701a      	strb	r2, [r3, #0]

          // Copy that byte into our temporary block store
          block_store[byte_count] = array[storage_index];
   186b6:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   186ba:	aa03      	add	r2, sp, #12
   186bc:	6812      	ldr	r2, [r2, #0]
   186be:	441a      	add	r2, r3
   186c0:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   186c4:	7811      	ldrb	r1, [r2, #0]
   186c6:	aa06      	add	r2, sp, #24
   186c8:	54d1      	strb	r1, [r2, r3]
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   186ca:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   186ce:	3301      	adds	r3, #1
   186d0:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   186d4:	e7ce      	b.n	18674 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0xb0>
        }

        // Then read the block's 16-bit CRC (i.e. read two bytes)
        uint16_t block_crc =
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   186d6:	ab05      	add	r3, sp, #20
   186d8:	681b      	ldr	r3, [r3, #0]
   186da:	685a      	ldr	r2, [r3, #4]
   186dc:	ab05      	add	r3, sp, #20
   186de:	681b      	ldr	r3, [r3, #0]
   186e0:	685b      	ldr	r3, [r3, #4]
   186e2:	681b      	ldr	r3, [r3, #0]
   186e4:	3308      	adds	r3, #8
   186e6:	681b      	ldr	r3, [r3, #0]
   186e8:	21ff      	movs	r1, #255	; 0xff
   186ea:	4610      	mov	r0, r2
   186ec:	4798      	blx	r3
   186ee:	4603      	mov	r3, r0
   186f0:	021b      	lsls	r3, r3, #8
   186f2:	b21c      	sxth	r4, r3
                                  ssp_interface_->Transfer(0xFF));
   186f4:	ab05      	add	r3, sp, #20
   186f6:	681b      	ldr	r3, [r3, #0]
   186f8:	685a      	ldr	r2, [r3, #4]
   186fa:	ab05      	add	r3, sp, #20
   186fc:	681b      	ldr	r3, [r3, #0]
   186fe:	685b      	ldr	r3, [r3, #4]
   18700:	681b      	ldr	r3, [r3, #0]
   18702:	3308      	adds	r3, #8
   18704:	681b      	ldr	r3, [r3, #0]
   18706:	21ff      	movs	r1, #255	; 0xff
   18708:	4610      	mov	r0, r2
   1870a:	4798      	blx	r3
   1870c:	4603      	mov	r3, r0
   1870e:	b21b      	sxth	r3, r3
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   18710:	4323      	orrs	r3, r4
   18712:	b21b      	sxth	r3, r3
                                  ssp_interface_->Transfer(0xFF));
   18714:	f8ad 3236 	strh.w	r3, [sp, #566]	; 0x236

        // Run a CRC-16 calculation on the message to determine if the
        // received CRCs match (i.e. checks if the block data is
        // valid).
        uint16_t expected_block_crc = GetCrc16(block_store, 512);
   18718:	ab05      	add	r3, sp, #20
   1871a:	681b      	ldr	r3, [r3, #0]
   1871c:	681b      	ldr	r3, [r3, #0]
   1871e:	3320      	adds	r3, #32
   18720:	681b      	ldr	r3, [r3, #0]
   18722:	a906      	add	r1, sp, #24
   18724:	a805      	add	r0, sp, #20
   18726:	f44f 7200 	mov.w	r2, #512	; 0x200
   1872a:	6800      	ldr	r0, [r0, #0]
   1872c:	4798      	blx	r3
   1872e:	4603      	mov	r3, r0
   18730:	f8ad 3234 	strh.w	r3, [sp, #564]	; 0x234

        LOG_DEBUG("Block #%d @ 0x%" PRIX32 " acquired", block_count, address);
        LOG_DEBUG("Expecting block crc16 '0x%04X'", expected_block_crc);
        LOG_DEBUG("Got '0x%04X'", block_crc);
        if (expected_block_crc != block_crc)
   18734:	f8bd 2234 	ldrh.w	r2, [sp, #564]	; 0x234
   18738:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   1873c:	429a      	cmp	r2, r3
   1873e:	d020      	beq.n	18782 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1be>
        {
          // If they do not match, set the bad crc status
          payload_had_bad_crc = true;
   18740:	2301      	movs	r3, #1
   18742:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247
          LOG_ERROR("While Reading Block #%d CRC16:", block_count);
   18746:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   1874a:	9300      	str	r3, [sp, #0]
   1874c:	f240 23ed 	movw	r3, #749	; 0x2ed
   18750:	4a22      	ldr	r2, [pc, #136]	; (187dc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   18752:	4923      	ldr	r1, [pc, #140]	; (187e0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x21c>)
   18754:	4823      	ldr	r0, [pc, #140]	; (187e4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x220>)
   18756:	f7ff fb7b 	bl	17e50 <printf>
          LOG_ERROR("Expected '0x%04X'", expected_block_crc);
   1875a:	f8bd 3234 	ldrh.w	r3, [sp, #564]	; 0x234
   1875e:	9300      	str	r3, [sp, #0]
   18760:	f240 23ee 	movw	r3, #750	; 0x2ee
   18764:	4a1d      	ldr	r2, [pc, #116]	; (187dc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   18766:	4920      	ldr	r1, [pc, #128]	; (187e8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x224>)
   18768:	4820      	ldr	r0, [pc, #128]	; (187ec <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x228>)
   1876a:	f7ff fb71 	bl	17e50 <printf>
          LOG_ERROR("Got '0x%04X'", block_crc);
   1876e:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   18772:	9300      	str	r3, [sp, #0]
   18774:	f240 23ef 	movw	r3, #751	; 0x2ef
   18778:	4a18      	ldr	r2, [pc, #96]	; (187dc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   1877a:	491d      	ldr	r1, [pc, #116]	; (187f0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x22c>)
   1877c:	481d      	ldr	r0, [pc, #116]	; (187f4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x230>)
   1877e:	f7ff fb67 	bl	17e50 <printf>
      for (block_count = 0; block_count < blocks; block_count++)
   18782:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   18786:	3301      	adds	r3, #1
   18788:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   1878c:	e75f      	b.n	1864e <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x8a>
        }
      }

      // After reading multiple blocks, send the stop command to terminate the
      // transaction (i.e. no keep-alive)
      if (blocks > 1)
   1878e:	ab02      	add	r3, sp, #8
   18790:	681b      	ldr	r3, [r3, #0]
   18792:	2b01      	cmp	r3, #1
   18794:	d913      	bls.n	187be <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1fa>
      {
        sd.response.length =
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
                    KeepAlive::kNo);
   18796:	ab05      	add	r3, sp, #20
   18798:	681b      	ldr	r3, [r3, #0]
   1879a:	681b      	ldr	r3, [r3, #0]
   1879c:	681c      	ldr	r4, [r3, #0]
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
   1879e:	ab86      	add	r3, sp, #536	; 0x218
   187a0:	f103 0208 	add.w	r2, r3, #8
   187a4:	a805      	add	r0, sp, #20
   187a6:	2300      	movs	r3, #0
   187a8:	9301      	str	r3, [sp, #4]
   187aa:	2364      	movs	r3, #100	; 0x64
   187ac:	9300      	str	r3, [sp, #0]
   187ae:	4613      	mov	r3, r2
   187b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   187b4:	214c      	movs	r1, #76	; 0x4c
   187b6:	6800      	ldr	r0, [r0, #0]
   187b8:	47a0      	blx	r4
   187ba:	4603      	mov	r3, r0
        sd.response.length =
   187bc:	938a      	str	r3, [sp, #552]	; 0x228
      LOG_DEBUG("Response Byte");
      LOG_DEBUG("0x%02X", sd.response.data.byte[0]);

      // If there was a bad crc from the payload, manually set the
      // CRC error flag in the command response byte
      if (payload_had_bad_crc)
   187be:	f89d 3247 	ldrb.w	r3, [sp, #583]	; 0x247
   187c2:	2b00      	cmp	r3, #0
   187c4:	f000 80c0 	beq.w	18948 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
      {
        sd.response.data.byte[0] |= 0x08;
   187c8:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   187cc:	f043 0308 	orr.w	r3, r3, #8
   187d0:	b2db      	uxtb	r3, r3
   187d2:	f88d 3220 	strb.w	r3, [sp, #544]	; 0x220
   187d6:	e0b7      	b.n	18948 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
   187d8:	000185c5 	.word	0x000185c5
   187dc:	0001c600 	.word	0x0001c600
   187e0:	0001c4fc 	.word	0x0001c4fc
   187e4:	0001bd0c 	.word	0x0001bd0c
   187e8:	0001c504 	.word	0x0001c504
   187ec:	0001bd64 	.word	0x0001bd64
   187f0:	0001c50c 	.word	0x0001c50c
   187f4:	0001bdb0 	.word	0x0001bdb0
      }
    }
    else
    {
      LOG_ERROR("Read Cmd was not acknowledged properly!");
   187f8:	f240 3309 	movw	r3, #777	; 0x309
   187fc:	4a65      	ldr	r2, [pc, #404]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   187fe:	4966      	ldr	r1, [pc, #408]	; (18998 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d4>)
   18800:	4866      	ldr	r0, [pc, #408]	; (1899c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d8>)
   18802:	f7ff fb25 	bl	17e50 <printf>
      LOG_ERROR("Parameter Err: %s", ToBool(sd.response.data.byte[0] & 0x40));
   18806:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   1880a:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1880e:	2b00      	cmp	r3, #0
   18810:	bf14      	ite	ne
   18812:	2301      	movne	r3, #1
   18814:	2300      	moveq	r3, #0
   18816:	b2da      	uxtb	r2, r3
   18818:	ab05      	add	r3, sp, #20
   1881a:	4611      	mov	r1, r2
   1881c:	6818      	ldr	r0, [r3, #0]
   1881e:	f7ff fe55 	bl	184cc <Sd::ToBool(bool)>
   18822:	4603      	mov	r3, r0
   18824:	9300      	str	r3, [sp, #0]
   18826:	f240 330a 	movw	r3, #778	; 0x30a
   1882a:	4a5a      	ldr	r2, [pc, #360]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   1882c:	495c      	ldr	r1, [pc, #368]	; (189a0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3dc>)
   1882e:	485d      	ldr	r0, [pc, #372]	; (189a4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e0>)
   18830:	f7ff fb0e 	bl	17e50 <printf>
      LOG_ERROR("Addr Err: %s", ToBool(sd.response.data.byte[0] & 0x20));
   18834:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18838:	f003 0320 	and.w	r3, r3, #32
   1883c:	2b00      	cmp	r3, #0
   1883e:	bf14      	ite	ne
   18840:	2301      	movne	r3, #1
   18842:	2300      	moveq	r3, #0
   18844:	b2da      	uxtb	r2, r3
   18846:	ab05      	add	r3, sp, #20
   18848:	4611      	mov	r1, r2
   1884a:	6818      	ldr	r0, [r3, #0]
   1884c:	f7ff fe3e 	bl	184cc <Sd::ToBool(bool)>
   18850:	4603      	mov	r3, r0
   18852:	9300      	str	r3, [sp, #0]
   18854:	f240 330b 	movw	r3, #779	; 0x30b
   18858:	4a4e      	ldr	r2, [pc, #312]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   1885a:	4953      	ldr	r1, [pc, #332]	; (189a8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e4>)
   1885c:	4853      	ldr	r0, [pc, #332]	; (189ac <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e8>)
   1885e:	f7ff faf7 	bl	17e50 <printf>
      LOG_ERROR("Erase Seq Err: %s", ToBool(sd.response.data.byte[0] & 0x10));
   18862:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18866:	f003 0310 	and.w	r3, r3, #16
   1886a:	2b00      	cmp	r3, #0
   1886c:	bf14      	ite	ne
   1886e:	2301      	movne	r3, #1
   18870:	2300      	moveq	r3, #0
   18872:	b2da      	uxtb	r2, r3
   18874:	ab05      	add	r3, sp, #20
   18876:	4611      	mov	r1, r2
   18878:	6818      	ldr	r0, [r3, #0]
   1887a:	f7ff fe27 	bl	184cc <Sd::ToBool(bool)>
   1887e:	4603      	mov	r3, r0
   18880:	9300      	str	r3, [sp, #0]
   18882:	f44f 7343 	mov.w	r3, #780	; 0x30c
   18886:	4a43      	ldr	r2, [pc, #268]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   18888:	4949      	ldr	r1, [pc, #292]	; (189b0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3ec>)
   1888a:	484a      	ldr	r0, [pc, #296]	; (189b4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f0>)
   1888c:	f7ff fae0 	bl	17e50 <printf>
      LOG_ERROR("Com CRC Err: %s", ToBool(sd.response.data.byte[0] & 0x08));
   18890:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18894:	f003 0308 	and.w	r3, r3, #8
   18898:	2b00      	cmp	r3, #0
   1889a:	bf14      	ite	ne
   1889c:	2301      	movne	r3, #1
   1889e:	2300      	moveq	r3, #0
   188a0:	b2da      	uxtb	r2, r3
   188a2:	ab05      	add	r3, sp, #20
   188a4:	4611      	mov	r1, r2
   188a6:	6818      	ldr	r0, [r3, #0]
   188a8:	f7ff fe10 	bl	184cc <Sd::ToBool(bool)>
   188ac:	4603      	mov	r3, r0
   188ae:	9300      	str	r3, [sp, #0]
   188b0:	f240 330d 	movw	r3, #781	; 0x30d
   188b4:	4a37      	ldr	r2, [pc, #220]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   188b6:	4940      	ldr	r1, [pc, #256]	; (189b8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f4>)
   188b8:	4840      	ldr	r0, [pc, #256]	; (189bc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f8>)
   188ba:	f7ff fac9 	bl	17e50 <printf>
      LOG_ERROR("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
   188be:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   188c2:	f003 0304 	and.w	r3, r3, #4
   188c6:	2b00      	cmp	r3, #0
   188c8:	bf14      	ite	ne
   188ca:	2301      	movne	r3, #1
   188cc:	2300      	moveq	r3, #0
   188ce:	b2da      	uxtb	r2, r3
   188d0:	ab05      	add	r3, sp, #20
   188d2:	4611      	mov	r1, r2
   188d4:	6818      	ldr	r0, [r3, #0]
   188d6:	f7ff fdf9 	bl	184cc <Sd::ToBool(bool)>
   188da:	4603      	mov	r3, r0
   188dc:	9300      	str	r3, [sp, #0]
   188de:	f240 330e 	movw	r3, #782	; 0x30e
   188e2:	4a2c      	ldr	r2, [pc, #176]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   188e4:	4936      	ldr	r1, [pc, #216]	; (189c0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3fc>)
   188e6:	4837      	ldr	r0, [pc, #220]	; (189c4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x400>)
   188e8:	f7ff fab2 	bl	17e50 <printf>
      LOG_ERROR("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
   188ec:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   188f0:	f003 0302 	and.w	r3, r3, #2
   188f4:	2b00      	cmp	r3, #0
   188f6:	bf14      	ite	ne
   188f8:	2301      	movne	r3, #1
   188fa:	2300      	moveq	r3, #0
   188fc:	b2da      	uxtb	r2, r3
   188fe:	ab05      	add	r3, sp, #20
   18900:	4611      	mov	r1, r2
   18902:	6818      	ldr	r0, [r3, #0]
   18904:	f7ff fde2 	bl	184cc <Sd::ToBool(bool)>
   18908:	4603      	mov	r3, r0
   1890a:	9300      	str	r3, [sp, #0]
   1890c:	f240 330f 	movw	r3, #783	; 0x30f
   18910:	4a20      	ldr	r2, [pc, #128]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   18912:	492d      	ldr	r1, [pc, #180]	; (189c8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x404>)
   18914:	482d      	ldr	r0, [pc, #180]	; (189cc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x408>)
   18916:	f7ff fa9b 	bl	17e50 <printf>
      LOG_ERROR("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
   1891a:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   1891e:	f003 0301 	and.w	r3, r3, #1
   18922:	2b00      	cmp	r3, #0
   18924:	bf14      	ite	ne
   18926:	2301      	movne	r3, #1
   18928:	2300      	moveq	r3, #0
   1892a:	b2da      	uxtb	r2, r3
   1892c:	ab05      	add	r3, sp, #20
   1892e:	4611      	mov	r1, r2
   18930:	6818      	ldr	r0, [r3, #0]
   18932:	f7ff fdcb 	bl	184cc <Sd::ToBool(bool)>
   18936:	4603      	mov	r3, r0
   18938:	9300      	str	r3, [sp, #0]
   1893a:	f44f 7344 	mov.w	r3, #784	; 0x310
   1893e:	4a15      	ldr	r2, [pc, #84]	; (18994 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   18940:	4923      	ldr	r1, [pc, #140]	; (189d0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x40c>)
   18942:	4824      	ldr	r0, [pc, #144]	; (189d4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x410>)
   18944:	f7ff fa84 	bl	17e50 <printf>
    LOG_DEBUG("Now waiting for SD Card to exit Idle Mode...");
    do
    {
      // Query the status register
      sd.response.length = SendCmd(Command::kGetStatus, 32,
                                   sd.response.data.byte, 0, KeepAlive::kNo);
   18948:	ab05      	add	r3, sp, #20
   1894a:	681b      	ldr	r3, [r3, #0]
   1894c:	681b      	ldr	r3, [r3, #0]
   1894e:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kGetStatus, 32,
   18950:	ab86      	add	r3, sp, #536	; 0x218
   18952:	f103 0208 	add.w	r2, r3, #8
   18956:	a805      	add	r0, sp, #20
   18958:	2300      	movs	r3, #0
   1895a:	9301      	str	r3, [sp, #4]
   1895c:	2300      	movs	r3, #0
   1895e:	9300      	str	r3, [sp, #0]
   18960:	4613      	mov	r3, r2
   18962:	2220      	movs	r2, #32
   18964:	210d      	movs	r1, #13
   18966:	6800      	ldr	r0, [r0, #0]
   18968:	47a0      	blx	r4
   1896a:	4603      	mov	r3, r0
   1896c:	938a      	str	r3, [sp, #552]	; 0x228
    } while (sd.response.data.byte[0] & 0x01);
   1896e:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18972:	f003 0301 	and.w	r3, r3, #1
   18976:	2b00      	cmp	r3, #0
   18978:	d000      	beq.n	1897c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3b8>
    do
   1897a:	e7e5      	b.n	18948 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
    LOG_DEBUG("SD Card is out of Idle Mode!");

    // Return the status
    LOG_DEBUG("Read Complete! [R1 Response: 0x%02X]", sd.response.data.byte[0]);
    return sd.response.data.byte[0];
   1897c:	f89d 4220 	ldrb.w	r4, [sp, #544]	; 0x220
   18980:	462b      	mov	r3, r5
   18982:	4619      	mov	r1, r3
   18984:	4814      	ldr	r0, [pc, #80]	; (189d8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x414>)
   18986:	f7fc fe93 	bl	156b0 <__cyg_profile_func_exit>
   1898a:	4623      	mov	r3, r4
  }
   1898c:	4618      	mov	r0, r3
   1898e:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
   18992:	bd30      	pop	{r4, r5, pc}
   18994:	0001c600 	.word	0x0001c600
   18998:	0001c514 	.word	0x0001c514
   1899c:	0001bdf8 	.word	0x0001bdf8
   189a0:	0001c51c 	.word	0x0001c51c
   189a4:	0001be5c 	.word	0x0001be5c
   189a8:	0001c524 	.word	0x0001c524
   189ac:	0001bea8 	.word	0x0001bea8
   189b0:	0001c52c 	.word	0x0001c52c
   189b4:	0001bef0 	.word	0x0001bef0
   189b8:	0001c534 	.word	0x0001c534
   189bc:	0001bf3c 	.word	0x0001bf3c
   189c0:	0001c53c 	.word	0x0001c53c
   189c4:	0001bf88 	.word	0x0001bf88
   189c8:	0001c544 	.word	0x0001c544
   189cc:	0001bfd8 	.word	0x0001bfd8
   189d0:	0001c54c 	.word	0x0001c54c
   189d4:	0001c024 	.word	0x0001c024
   189d8:	000185c5 	.word	0x000185c5

000189dc <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)>:

  // Writes any number of 512-byte blocks to the SD Card
  uint8_t WriteBlock(uint32_t address, const uint8_t * array,
   189dc:	b530      	push	{r4, r5, lr}
   189de:	b095      	sub	sp, #84	; 0x54
   189e0:	4675      	mov	r5, lr
   189e2:	9005      	str	r0, [sp, #20]
   189e4:	9104      	str	r1, [sp, #16]
   189e6:	9203      	str	r2, [sp, #12]
   189e8:	9302      	str	r3, [sp, #8]
   189ea:	462b      	mov	r3, r5
   189ec:	4619      	mov	r1, r3
   189ee:	4865      	ldr	r0, [pc, #404]	; (18b84 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   189f0:	f7fc fe4a 	bl	15688 <__cyg_profile_func_enter>
                     uint32_t blocks = 1) override
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   189f4:	9805      	ldr	r0, [sp, #20]
   189f6:	f7ff fdbd 	bl	18574 <Sd::WaitWhileBusy()>
    Sd::CardInfo_t sd;

    // Determine appropriate command and start token to send
    Command write_cmd;
    uint8_t write_start_tkn;
    if (blocks > 1)
   189fa:	9b02      	ldr	r3, [sp, #8]
   189fc:	2b01      	cmp	r3, #1
   189fe:	d905      	bls.n	18a0c <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x30>
    {
      write_cmd       = Command::kWriteMulti;
   18a00:	2359      	movs	r3, #89	; 0x59
   18a02:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFC;
   18a04:	23fc      	movs	r3, #252	; 0xfc
   18a06:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
   18a0a:	e004      	b.n	18a16 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x3a>
    }
    else
    {
      write_cmd       = Command::kWriteSingle;
   18a0c:	2358      	movs	r3, #88	; 0x58
   18a0e:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFE;
   18a10:	23fe      	movs	r3, #254	; 0xfe
   18a12:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
    }

    // Send initial write command
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
                                 KeepAlive::kYes);
   18a16:	9b05      	ldr	r3, [sp, #20]
   18a18:	681b      	ldr	r3, [r3, #0]
   18a1a:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
   18a1c:	ab06      	add	r3, sp, #24
   18a1e:	f103 0208 	add.w	r2, r3, #8
   18a22:	2301      	movs	r3, #1
   18a24:	9301      	str	r3, [sp, #4]
   18a26:	2364      	movs	r3, #100	; 0x64
   18a28:	9300      	str	r3, [sp, #0]
   18a2a:	4613      	mov	r3, r2
   18a2c:	9a04      	ldr	r2, [sp, #16]
   18a2e:	9913      	ldr	r1, [sp, #76]	; 0x4c
   18a30:	9805      	ldr	r0, [sp, #20]
   18a32:	47a0      	blx	r4
   18a34:	4603      	mov	r3, r0
   18a36:	930a      	str	r3, [sp, #40]	; 0x28
    LOG_DEBUG("Sent Write Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the response was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   18a38:	f89d 3020 	ldrb.w	r3, [sp, #32]
   18a3c:	2b00      	cmp	r3, #0
   18a3e:	f040 8096 	bne.w	18b6e <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
    {
      // If no errors, proceed write given block(s) to SD Card
      // For each given block
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   18a42:	2300      	movs	r3, #0
   18a44:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   18a48:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   18a4c:	9a02      	ldr	r2, [sp, #8]
   18a4e:	429a      	cmp	r2, r3
   18a50:	d97a      	bls.n	18b48 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x16c>
           current_block_num++)
      {
        // Calculate array offset
        uint64_t arr_offset = current_block_num * kBlockSize;
   18a52:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   18a56:	025b      	lsls	r3, r3, #9
   18a58:	ea4f 74e3 	mov.w	r4, r3, asr #31
   18a5c:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38

        // Send the start token for the current block
        ssp_interface_->Transfer(write_start_tkn);
   18a60:	9b05      	ldr	r3, [sp, #20]
   18a62:	685a      	ldr	r2, [r3, #4]
   18a64:	9b05      	ldr	r3, [sp, #20]
   18a66:	685b      	ldr	r3, [r3, #4]
   18a68:	681b      	ldr	r3, [r3, #0]
   18a6a:	3308      	adds	r3, #8
   18a6c:	681b      	ldr	r3, [r3, #0]
   18a6e:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
   18a72:	b289      	uxth	r1, r1
   18a74:	4610      	mov	r0, r2
   18a76:	4798      	blx	r3

        // Write all 512-bytes of the given block
        LOG_DEBUG("Writing block #%d", current_block_num);
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   18a78:	2300      	movs	r3, #0
   18a7a:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   18a7e:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   18a82:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   18a86:	d216      	bcs.n	18ab6 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xda>
             current_byte++)
        {
          ssp_interface_->Transfer(array[arr_offset + current_byte]);
   18a88:	9b05      	ldr	r3, [sp, #20]
   18a8a:	6858      	ldr	r0, [r3, #4]
   18a8c:	9b05      	ldr	r3, [sp, #20]
   18a8e:	685b      	ldr	r3, [r3, #4]
   18a90:	681b      	ldr	r3, [r3, #0]
   18a92:	3308      	adds	r3, #8
   18a94:	681b      	ldr	r3, [r3, #0]
   18a96:	990e      	ldr	r1, [sp, #56]	; 0x38
   18a98:	f8bd 2046 	ldrh.w	r2, [sp, #70]	; 0x46
   18a9c:	440a      	add	r2, r1
   18a9e:	9903      	ldr	r1, [sp, #12]
   18aa0:	440a      	add	r2, r1
   18aa2:	7812      	ldrb	r2, [r2, #0]
   18aa4:	b292      	uxth	r2, r2
   18aa6:	4611      	mov	r1, r2
   18aa8:	4798      	blx	r3
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   18aaa:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   18aae:	3301      	adds	r3, #1
   18ab0:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   18ab4:	e7e3      	b.n	18a7e <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xa2>
        }

        // Read the data response token after writing the block
        uint8_t data_response_tkn =
            static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18ab6:	9b05      	ldr	r3, [sp, #20]
   18ab8:	685a      	ldr	r2, [r3, #4]
   18aba:	9b05      	ldr	r3, [sp, #20]
   18abc:	685b      	ldr	r3, [r3, #4]
   18abe:	681b      	ldr	r3, [r3, #0]
   18ac0:	3308      	adds	r3, #8
   18ac2:	681b      	ldr	r3, [r3, #0]
   18ac4:	21ff      	movs	r1, #255	; 0xff
   18ac6:	4610      	mov	r0, r2
   18ac8:	4798      	blx	r3
   18aca:	4603      	mov	r3, r0
   18acc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
                  ToBool(data_response_tkn & 0x0B));
        LOG_DEBUG("Data Rejected (write err)?: %s",
                  ToBool(data_response_tkn & 0x0D));

        // If writing multiple blocks and the previous block was rejected
        if (blocks > 1 && !(data_response_tkn & 0x05))
   18ad0:	9b02      	ldr	r3, [sp, #8]
   18ad2:	2b01      	cmp	r3, #1
   18ad4:	d92f      	bls.n	18b36 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
   18ad6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   18ada:	f003 0305 	and.w	r3, r3, #5
   18ade:	2b00      	cmp	r3, #0
   18ae0:	d129      	bne.n	18b36 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
        {
          // Send an immediate stop (CMD12)
          sd.response.length =
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
                      100, KeepAlive::kYes);
   18ae2:	9b05      	ldr	r3, [sp, #20]
   18ae4:	681b      	ldr	r3, [r3, #0]
   18ae6:	681c      	ldr	r4, [r3, #0]
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
   18ae8:	ab06      	add	r3, sp, #24
   18aea:	f103 0208 	add.w	r2, r3, #8
   18aee:	2301      	movs	r3, #1
   18af0:	9301      	str	r3, [sp, #4]
   18af2:	2364      	movs	r3, #100	; 0x64
   18af4:	9300      	str	r3, [sp, #0]
   18af6:	4613      	mov	r3, r2
   18af8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18afc:	214c      	movs	r1, #76	; 0x4c
   18afe:	9805      	ldr	r0, [sp, #20]
   18b00:	47a0      	blx	r4
   18b02:	4603      	mov	r3, r0
          sd.response.length =
   18b04:	930a      	str	r3, [sp, #40]	; 0x28
          LOG_DEBUG("Stopped Transmission due to rejection...");
          LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);

          // In the case of a write error, ask for the reason why
          if (data_response_tkn & 0x0D)
   18b06:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   18b0a:	f003 030d 	and.w	r3, r3, #13
   18b0e:	2b00      	cmp	r3, #0
   18b10:	d011      	beq.n	18b36 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
          {
            sd.response.length =
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
                        100, KeepAlive::kYes);
   18b12:	9b05      	ldr	r3, [sp, #20]
   18b14:	681b      	ldr	r3, [r3, #0]
   18b16:	681c      	ldr	r4, [r3, #0]
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
   18b18:	ab06      	add	r3, sp, #24
   18b1a:	f103 0208 	add.w	r2, r3, #8
   18b1e:	2301      	movs	r3, #1
   18b20:	9301      	str	r3, [sp, #4]
   18b22:	2364      	movs	r3, #100	; 0x64
   18b24:	9300      	str	r3, [sp, #0]
   18b26:	4613      	mov	r3, r2
   18b28:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18b2c:	210d      	movs	r1, #13
   18b2e:	9805      	ldr	r0, [sp, #20]
   18b30:	47a0      	blx	r4
   18b32:	4603      	mov	r3, r0
            sd.response.length =
   18b34:	930a      	str	r3, [sp, #40]	; 0x28
                "Checking Status Register to see cause of Write Error...");
            LOG_DEBUG("[R2 Response: 0x%04" PRIX32 "]",
                      sd.response.data.dWord.lo);
          }
        }
        WaitWhileBusy();
   18b36:	9805      	ldr	r0, [sp, #20]
   18b38:	f7ff fd1c 	bl	18574 <Sd::WaitWhileBusy()>
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   18b3c:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   18b40:	3301      	adds	r3, #1
   18b42:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   18b46:	e77f      	b.n	18a48 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x6c>
      }

      if (blocks > 1)
   18b48:	9b02      	ldr	r3, [sp, #8]
   18b4a:	2b01      	cmp	r3, #1
   18b4c:	d90f      	bls.n	18b6e <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
      {
        constexpr uint8_t kStopToken = 0xFD;
   18b4e:	23fd      	movs	r3, #253	; 0xfd
   18b50:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
        ssp_interface_->Transfer(kStopToken);
   18b54:	9b05      	ldr	r3, [sp, #20]
   18b56:	685a      	ldr	r2, [r3, #4]
   18b58:	9b05      	ldr	r3, [sp, #20]
   18b5a:	685b      	ldr	r3, [r3, #4]
   18b5c:	681b      	ldr	r3, [r3, #0]
   18b5e:	3308      	adds	r3, #8
   18b60:	681b      	ldr	r3, [r3, #0]
   18b62:	21fd      	movs	r1, #253	; 0xfd
   18b64:	4610      	mov	r0, r2
   18b66:	4798      	blx	r3

        // Wait for the card's programming to complete before
        // reselecting it (i.e. to prevent corruption)
        WaitWhileBusy();
   18b68:	9805      	ldr	r0, [sp, #20]
   18b6a:	f7ff fd03 	bl	18574 <Sd::WaitWhileBusy()>
      LOG_DEBUG("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
      LOG_DEBUG("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
      LOG_DEBUG("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
    }

    return sd.response.data.byte[0];
   18b6e:	f89d 4020 	ldrb.w	r4, [sp, #32]
   18b72:	462b      	mov	r3, r5
   18b74:	4619      	mov	r1, r3
   18b76:	4803      	ldr	r0, [pc, #12]	; (18b84 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   18b78:	f7fc fd9a 	bl	156b0 <__cyg_profile_func_exit>
   18b7c:	4623      	mov	r3, r4
  }
   18b7e:	4618      	mov	r0, r3
   18b80:	b015      	add	sp, #84	; 0x54
   18b82:	bd30      	pop	{r4, r5, pc}
   18b84:	000189dd 	.word	0x000189dd

00018b88 <Sd::DeleteBlock(unsigned long, unsigned long)>:

  // Deletes any number of blocks (inclusively) within a range of address.
  uint8_t DeleteBlock(uint32_t start, uint32_t end) override
   18b88:	b530      	push	{r4, r5, lr}
   18b8a:	b08f      	sub	sp, #60	; 0x3c
   18b8c:	4675      	mov	r5, lr
   18b8e:	9005      	str	r0, [sp, #20]
   18b90:	9104      	str	r1, [sp, #16]
   18b92:	9203      	str	r2, [sp, #12]
   18b94:	462b      	mov	r3, r5
   18b96:	4619      	mov	r1, r3
   18b98:	483d      	ldr	r0, [pc, #244]	; (18c90 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   18b9a:	f7fc fd75 	bl	15688 <__cyg_profile_func_enter>
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   18b9e:	9805      	ldr	r0, [sp, #20]
   18ba0:	f7ff fce8 	bl	18574 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool delete_failed = false;
   18ba4:	2300      	movs	r3, #0
   18ba6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37

    // Set the delete start address
    LOG_DEBUG("Setting Delete Start Address...");
    sd.response.length = SendCmd(Command::kDelFrom, start,
                                 sd.response.data.byte, 100, KeepAlive::kYes);
   18baa:	9b05      	ldr	r3, [sp, #20]
   18bac:	681b      	ldr	r3, [r3, #0]
   18bae:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(Command::kDelFrom, start,
   18bb0:	ab06      	add	r3, sp, #24
   18bb2:	f103 0208 	add.w	r2, r3, #8
   18bb6:	2301      	movs	r3, #1
   18bb8:	9301      	str	r3, [sp, #4]
   18bba:	2364      	movs	r3, #100	; 0x64
   18bbc:	9300      	str	r3, [sp, #0]
   18bbe:	4613      	mov	r3, r2
   18bc0:	9a04      	ldr	r2, [sp, #16]
   18bc2:	2160      	movs	r1, #96	; 0x60
   18bc4:	9805      	ldr	r0, [sp, #20]
   18bc6:	47a0      	blx	r4
   18bc8:	4603      	mov	r3, r0
   18bca:	930a      	str	r3, [sp, #40]	; 0x28

    // Wait while the writing the start address
    WaitWhileBusy();
   18bcc:	9805      	ldr	r0, [sp, #20]
   18bce:	f7ff fcd1 	bl	18574 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   18bd2:	f89d 3020 	ldrb.w	r3, [sp, #32]
   18bd6:	2b00      	cmp	r3, #0
   18bd8:	d009      	beq.n	18bee <Sd::DeleteBlock(unsigned long, unsigned long)+0x66>
    {
      LOG_ERROR("Failed to set Start Address!");
   18bda:	f44f 736a 	mov.w	r3, #936	; 0x3a8
   18bde:	4a2d      	ldr	r2, [pc, #180]	; (18c94 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   18be0:	492d      	ldr	r1, [pc, #180]	; (18c98 <Sd::DeleteBlock(unsigned long, unsigned long)+0x110>)
   18be2:	482e      	ldr	r0, [pc, #184]	; (18c9c <Sd::DeleteBlock(unsigned long, unsigned long)+0x114>)
   18be4:	f7ff f934 	bl	17e50 <printf>
      delete_failed = true;
   18be8:	2301      	movs	r3, #1
   18bea:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Set the delete end address
    if (!delete_failed)
   18bee:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   18bf2:	f083 0301 	eor.w	r3, r3, #1
   18bf6:	b2db      	uxtb	r3, r3
   18bf8:	2b00      	cmp	r3, #0
   18bfa:	d010      	beq.n	18c1e <Sd::DeleteBlock(unsigned long, unsigned long)+0x96>
    {
      LOG_DEBUG("Setting Delete End Address...");
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
                                   100, KeepAlive::kYes);
   18bfc:	9b05      	ldr	r3, [sp, #20]
   18bfe:	681b      	ldr	r3, [r3, #0]
   18c00:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
   18c02:	ab06      	add	r3, sp, #24
   18c04:	f103 0208 	add.w	r2, r3, #8
   18c08:	2301      	movs	r3, #1
   18c0a:	9301      	str	r3, [sp, #4]
   18c0c:	2364      	movs	r3, #100	; 0x64
   18c0e:	9300      	str	r3, [sp, #0]
   18c10:	4613      	mov	r3, r2
   18c12:	9a03      	ldr	r2, [sp, #12]
   18c14:	2161      	movs	r1, #97	; 0x61
   18c16:	9805      	ldr	r0, [sp, #20]
   18c18:	47a0      	blx	r4
   18c1a:	4603      	mov	r3, r0
   18c1c:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // Wait while the writing the end address
    WaitWhileBusy();
   18c1e:	9805      	ldr	r0, [sp, #20]
   18c20:	f7ff fca8 	bl	18574 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   18c24:	f89d 3020 	ldrb.w	r3, [sp, #32]
   18c28:	2b00      	cmp	r3, #0
   18c2a:	d009      	beq.n	18c40 <Sd::DeleteBlock(unsigned long, unsigned long)+0xb8>
    {
      LOG_ERROR("Failed to set End Address!");
   18c2c:	f240 33ba 	movw	r3, #954	; 0x3ba
   18c30:	4a18      	ldr	r2, [pc, #96]	; (18c94 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   18c32:	491b      	ldr	r1, [pc, #108]	; (18ca0 <Sd::DeleteBlock(unsigned long, unsigned long)+0x118>)
   18c34:	481b      	ldr	r0, [pc, #108]	; (18ca4 <Sd::DeleteBlock(unsigned long, unsigned long)+0x11c>)
   18c36:	f7ff f90b 	bl	17e50 <printf>
      delete_failed = true;
   18c3a:	2301      	movs	r3, #1
   18c3c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Finally, attempt a delete
    if (!delete_failed)
   18c40:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   18c44:	f083 0301 	eor.w	r3, r3, #1
   18c48:	b2db      	uxtb	r3, r3
   18c4a:	2b00      	cmp	r3, #0
   18c4c:	d014      	beq.n	18c78 <Sd::DeleteBlock(unsigned long, unsigned long)+0xf0>
    {
      // Issue the delete command to delete from our from:to range
      LOG_DEBUG("Issuing Delete Command...");
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
                                   sd.response.data.byte, 100, KeepAlive::kYes);
   18c4e:	9b05      	ldr	r3, [sp, #20]
   18c50:	681b      	ldr	r3, [r3, #0]
   18c52:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
   18c54:	ab06      	add	r3, sp, #24
   18c56:	f103 0208 	add.w	r2, r3, #8
   18c5a:	2301      	movs	r3, #1
   18c5c:	9301      	str	r3, [sp, #4]
   18c5e:	2364      	movs	r3, #100	; 0x64
   18c60:	9300      	str	r3, [sp, #0]
   18c62:	4613      	mov	r3, r2
   18c64:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18c68:	2166      	movs	r1, #102	; 0x66
   18c6a:	9805      	ldr	r0, [sp, #20]
   18c6c:	47a0      	blx	r4
   18c6e:	4603      	mov	r3, r0
   18c70:	930a      	str	r3, [sp, #40]	; 0x28

      // Wait while the deletion occurs
      WaitWhileBusy();
   18c72:	9805      	ldr	r0, [sp, #20]
   18c74:	f7ff fc7e 	bl	18574 <Sd::WaitWhileBusy()>
      LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);
      LOG_DEBUG("Deletion Complete...");
    }

    // Return status
    return sd.response.data.byte[0];
   18c78:	f89d 4020 	ldrb.w	r4, [sp, #32]
   18c7c:	462b      	mov	r3, r5
   18c7e:	4619      	mov	r1, r3
   18c80:	4803      	ldr	r0, [pc, #12]	; (18c90 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   18c82:	f7fc fd15 	bl	156b0 <__cyg_profile_func_exit>
   18c86:	4623      	mov	r3, r4
  }
   18c88:	4618      	mov	r0, r3
   18c8a:	b00f      	add	sp, #60	; 0x3c
   18c8c:	bd30      	pop	{r4, r5, pc}
   18c8e:	bf00      	nop
   18c90:	00018b89 	.word	0x00018b89
   18c94:	0001c63c 	.word	0x0001c63c
   18c98:	0001c554 	.word	0x0001c554
   18c9c:	0001c06c 	.word	0x0001c06c
   18ca0:	0001c55c 	.word	0x0001c55c
   18ca4:	0001c0c4 	.word	0x0001c0c4

00018ca8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)>:

  // Send a command
  uint32_t SendCmd(Command sdc, uint32_t arg, uint8_t response_buffer[],
   18ca8:	e92d 49f0 	stmdb	sp!, {r4, r5, r6, r7, r8, fp, lr}
   18cac:	b08f      	sub	sp, #60	; 0x3c
   18cae:	46f0      	mov	r8, lr
   18cb0:	9003      	str	r0, [sp, #12]
   18cb2:	9102      	str	r1, [sp, #8]
   18cb4:	9201      	str	r2, [sp, #4]
   18cb6:	9300      	str	r3, [sp, #0]
   18cb8:	4643      	mov	r3, r8
   18cba:	4619      	mov	r1, r3
   18cbc:	4840      	ldr	r0, [pc, #256]	; (18dc0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x118>)
   18cbe:	f7fc fce3 	bl	15688 <__cyg_profile_func_enter>
                   uint32_t delay, KeepAlive keep_alive) override
  {
    ResponseType res_type;
    uint8_t res_len    = 0;
   18cc2:	2300      	movs	r3, #0
   18cc4:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    uint8_t crc        = 0;
   18cc8:	2300      	movs	r3, #0
   18cca:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    uint8_t tries      = 0;
   18cce:	2300      	movs	r3, #0
   18cd0:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    uint8_t bit_offset = 0;  // determines the distance of the response's
   18cd4:	2300      	movs	r3, #0
   18cd6:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                             // 0 bit from the MSB place
    uint8_t temp_byte = 0;
   18cda:	2300      	movs	r3, #0
   18cdc:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f

    // Determine the response type of the set command
    switch (sdc)
   18ce0:	9b02      	ldr	r3, [sp, #8]
   18ce2:	2b58      	cmp	r3, #88	; 0x58
   18ce4:	d052      	beq.n	18d8c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xe4>
   18ce6:	2b58      	cmp	r3, #88	; 0x58
   18ce8:	dc16      	bgt.n	18d18 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x70>
   18cea:	2b48      	cmp	r3, #72	; 0x48
   18cec:	d033      	beq.n	18d56 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xae>
   18cee:	2b48      	cmp	r3, #72	; 0x48
   18cf0:	dc06      	bgt.n	18d00 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x58>
   18cf2:	2b40      	cmp	r3, #64	; 0x40
   18cf4:	d029      	beq.n	18d4a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa2>
   18cf6:	2b41      	cmp	r3, #65	; 0x41
   18cf8:	d02a      	beq.n	18d50 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa8>
   18cfa:	2b0d      	cmp	r3, #13
   18cfc:	d031      	beq.n	18d62 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xba>
   18cfe:	e054      	b.n	18daa <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18d00:	2b50      	cmp	r3, #80	; 0x50
   18d02:	d03a      	beq.n	18d7a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd2>
   18d04:	2b50      	cmp	r3, #80	; 0x50
   18d06:	dc02      	bgt.n	18d0e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x66>
   18d08:	2b4c      	cmp	r3, #76	; 0x4c
   18d0a:	d027      	beq.n	18d5c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xb4>
   18d0c:	e04d      	b.n	18daa <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18d0e:	2b51      	cmp	r3, #81	; 0x51
   18d10:	d036      	beq.n	18d80 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd8>
   18d12:	2b52      	cmp	r3, #82	; 0x52
   18d14:	d037      	beq.n	18d86 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xde>
   18d16:	e048      	b.n	18daa <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18d18:	2b66      	cmp	r3, #102	; 0x66
   18d1a:	d043      	beq.n	18da4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xfc>
   18d1c:	2b66      	cmp	r3, #102	; 0x66
   18d1e:	dc06      	bgt.n	18d2e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x86>
   18d20:	2b60      	cmp	r3, #96	; 0x60
   18d22:	d039      	beq.n	18d98 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf0>
   18d24:	2b61      	cmp	r3, #97	; 0x61
   18d26:	d03a      	beq.n	18d9e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf6>
   18d28:	2b59      	cmp	r3, #89	; 0x59
   18d2a:	d032      	beq.n	18d92 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xea>
   18d2c:	e03d      	b.n	18daa <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18d2e:	2b77      	cmp	r3, #119	; 0x77
   18d30:	d01a      	beq.n	18d68 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc0>
   18d32:	2b77      	cmp	r3, #119	; 0x77
   18d34:	dc02      	bgt.n	18d3c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x94>
   18d36:	2b69      	cmp	r3, #105	; 0x69
   18d38:	d019      	beq.n	18d6e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc6>
   18d3a:	e036      	b.n	18daa <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18d3c:	2b7a      	cmp	r3, #122	; 0x7a
   18d3e:	d019      	beq.n	18d74 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xcc>
   18d40:	2bff      	cmp	r3, #255	; 0xff
   18d42:	d132      	bne.n	18daa <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
    {
      case Command::kGarbage: res_type = ResponseType::kR1; break;
   18d44:	2300      	movs	r3, #0
   18d46:	930d      	str	r3, [sp, #52]	; 0x34
   18d48:	e042      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReset: res_type = ResponseType::kR1; break;
   18d4a:	2300      	movs	r3, #0
   18d4c:	930d      	str	r3, [sp, #52]	; 0x34
   18d4e:	e03f      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kInit: res_type = ResponseType::kR1; break;
   18d50:	2300      	movs	r3, #0
   18d52:	930d      	str	r3, [sp, #52]	; 0x34
   18d54:	e03c      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOp: res_type = ResponseType::kR7; break;
   18d56:	2307      	movs	r3, #7
   18d58:	930d      	str	r3, [sp, #52]	; 0x34
   18d5a:	e039      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kStopTrans: res_type = ResponseType::kR1; break;
   18d5c:	2300      	movs	r3, #0
   18d5e:	930d      	str	r3, [sp, #52]	; 0x34
   18d60:	e036      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetStatus: res_type = ResponseType::kR2; break;
   18d62:	2302      	movs	r3, #2
   18d64:	930d      	str	r3, [sp, #52]	; 0x34
   18d66:	e033      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcBegin: res_type = ResponseType::kR1; break;
   18d68:	2300      	movs	r3, #0
   18d6a:	930d      	str	r3, [sp, #52]	; 0x34
   18d6c:	e030      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcInit: res_type = ResponseType::kR1; break;
   18d6e:	2300      	movs	r3, #0
   18d70:	930d      	str	r3, [sp, #52]	; 0x34
   18d72:	e02d      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOcr: res_type = ResponseType::kR3; break;
   18d74:	2303      	movs	r3, #3
   18d76:	930d      	str	r3, [sp, #52]	; 0x34
   18d78:	e02a      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kChgBlkLen: res_type = ResponseType::kR1; break;
   18d7a:	2300      	movs	r3, #0
   18d7c:	930d      	str	r3, [sp, #52]	; 0x34
   18d7e:	e027      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadSingle: res_type = ResponseType::kR1; break;
   18d80:	2300      	movs	r3, #0
   18d82:	930d      	str	r3, [sp, #52]	; 0x34
   18d84:	e024      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadMulti: res_type = ResponseType::kR1; break;
   18d86:	2300      	movs	r3, #0
   18d88:	930d      	str	r3, [sp, #52]	; 0x34
   18d8a:	e021      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteSingle: res_type = ResponseType::kR1; break;
   18d8c:	2300      	movs	r3, #0
   18d8e:	930d      	str	r3, [sp, #52]	; 0x34
   18d90:	e01e      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteMulti: res_type = ResponseType::kR1; break;
   18d92:	2300      	movs	r3, #0
   18d94:	930d      	str	r3, [sp, #52]	; 0x34
   18d96:	e01b      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelFrom: res_type = ResponseType::kR1; break;
   18d98:	2300      	movs	r3, #0
   18d9a:	930d      	str	r3, [sp, #52]	; 0x34
   18d9c:	e018      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelTo: res_type = ResponseType::kR1; break;
   18d9e:	2300      	movs	r3, #0
   18da0:	930d      	str	r3, [sp, #52]	; 0x34
   18da2:	e015      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDel: res_type = ResponseType::kR1b; break;
   18da4:	2301      	movs	r3, #1
   18da6:	930d      	str	r3, [sp, #52]	; 0x34
   18da8:	e012      	b.n	18dd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      default:
        LOG_ERROR("Unknown response type. Aborting!");
   18daa:	f240 33f3 	movw	r3, #1011	; 0x3f3
   18dae:	4a05      	ldr	r2, [pc, #20]	; (18dc4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x11c>)
   18db0:	4905      	ldr	r1, [pc, #20]	; (18dc8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x120>)
   18db2:	4806      	ldr	r0, [pc, #24]	; (18dcc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x124>)
   18db4:	f7ff f84c 	bl	17e50 <printf>
        return -1;
   18db8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   18dbc:	e1b1      	b.n	19122 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
   18dbe:	bf00      	nop
   18dc0:	00018ca9 	.word	0x00018ca9
   18dc4:	0001c670 	.word	0x0001c670
   18dc8:	0001c564 	.word	0x0001c564
   18dcc:	0001c118 	.word	0x0001c118
    // algorithm
    uint8_t msg[5] = { static_cast<uint8_t>(sdc),
                       static_cast<uint8_t>(arg >> 24),
                       static_cast<uint8_t>(arg >> 16),
                       static_cast<uint8_t>(arg >> 8),
                       static_cast<uint8_t>(arg >> 0) };
   18dd0:	9b02      	ldr	r3, [sp, #8]
   18dd2:	b2db      	uxtb	r3, r3
   18dd4:	f88d 3010 	strb.w	r3, [sp, #16]
                       static_cast<uint8_t>(arg >> 24),
   18dd8:	9b01      	ldr	r3, [sp, #4]
   18dda:	0e1b      	lsrs	r3, r3, #24
                       static_cast<uint8_t>(arg >> 0) };
   18ddc:	b2db      	uxtb	r3, r3
   18dde:	f88d 3011 	strb.w	r3, [sp, #17]
                       static_cast<uint8_t>(arg >> 16),
   18de2:	9b01      	ldr	r3, [sp, #4]
   18de4:	0c1b      	lsrs	r3, r3, #16
                       static_cast<uint8_t>(arg >> 0) };
   18de6:	b2db      	uxtb	r3, r3
   18de8:	f88d 3012 	strb.w	r3, [sp, #18]
                       static_cast<uint8_t>(arg >> 8),
   18dec:	9b01      	ldr	r3, [sp, #4]
   18dee:	0a1b      	lsrs	r3, r3, #8
                       static_cast<uint8_t>(arg >> 0) };
   18df0:	b2db      	uxtb	r3, r3
   18df2:	f88d 3013 	strb.w	r3, [sp, #19]
   18df6:	9b01      	ldr	r3, [sp, #4]
   18df8:	b2db      	uxtb	r3, r3
   18dfa:	f88d 3014 	strb.w	r3, [sp, #20]

    crc = GetCrc7(msg, sizeof(msg));
   18dfe:	9b03      	ldr	r3, [sp, #12]
   18e00:	681b      	ldr	r3, [r3, #0]
   18e02:	331c      	adds	r3, #28
   18e04:	681b      	ldr	r3, [r3, #0]
   18e06:	a904      	add	r1, sp, #16
   18e08:	2205      	movs	r2, #5
   18e0a:	9803      	ldr	r0, [sp, #12]
   18e0c:	4798      	blx	r3
   18e0e:	4603      	mov	r3, r0
   18e10:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    if (sdc == Command::kGarbage)
   18e14:	9b02      	ldr	r3, [sp, #8]
   18e16:	2bff      	cmp	r3, #255	; 0xff
   18e18:	d102      	bne.n	18e20 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x178>
    {
      crc = 0xFF;
   18e1a:	23ff      	movs	r3, #255	; 0xff
   18e1c:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    }

    // Select the SD Card
    chip_select_->SetLow();
   18e20:	9b03      	ldr	r3, [sp, #12]
   18e22:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18e24:	9b03      	ldr	r3, [sp, #12]
   18e26:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   18e28:	681b      	ldr	r3, [r3, #0]
   18e2a:	3310      	adds	r3, #16
   18e2c:	681b      	ldr	r3, [r3, #0]
   18e2e:	4610      	mov	r0, r2
   18e30:	4798      	blx	r3
    chip_select_external_->SetLow();
   18e32:	9b03      	ldr	r3, [sp, #12]
   18e34:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   18e36:	9b03      	ldr	r3, [sp, #12]
   18e38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   18e3a:	681b      	ldr	r3, [r3, #0]
   18e3c:	3310      	adds	r3, #16
   18e3e:	681b      	ldr	r3, [r3, #0]
   18e40:	4610      	mov	r0, r2
   18e42:	4798      	blx	r3

    // If desired, wait a bit before talking
    if (delay > 0)
   18e44:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18e46:	2b00      	cmp	r3, #0
   18e48:	d007      	beq.n	18e5a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x1b2>
    {
      Delay(delay);
   18e4a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18e4c:	461a      	mov	r2, r3
   18e4e:	f04f 0300 	mov.w	r3, #0
   18e52:	4610      	mov	r0, r2
   18e54:	4619      	mov	r1, r3
   18e56:	f7ff f8d1 	bl	17ffc <Delay(unsigned long long)>
    }

    // Send the desired command frame to the SD card board
    // Begin by transfering the command byte
    ssp_interface_->Transfer(static_cast<uint16_t>(sdc));
   18e5a:	9b03      	ldr	r3, [sp, #12]
   18e5c:	685a      	ldr	r2, [r3, #4]
   18e5e:	9b03      	ldr	r3, [sp, #12]
   18e60:	685b      	ldr	r3, [r3, #4]
   18e62:	681b      	ldr	r3, [r3, #0]
   18e64:	3308      	adds	r3, #8
   18e66:	681b      	ldr	r3, [r3, #0]
   18e68:	9902      	ldr	r1, [sp, #8]
   18e6a:	b289      	uxth	r1, r1
   18e6c:	4610      	mov	r0, r2
   18e6e:	4798      	blx	r3
    // Send arg byte [31:24]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 24) & 0xFF);
   18e70:	9b03      	ldr	r3, [sp, #12]
   18e72:	6858      	ldr	r0, [r3, #4]
   18e74:	9b03      	ldr	r3, [sp, #12]
   18e76:	685b      	ldr	r3, [r3, #4]
   18e78:	681b      	ldr	r3, [r3, #0]
   18e7a:	3308      	adds	r3, #8
   18e7c:	681b      	ldr	r3, [r3, #0]
   18e7e:	9a01      	ldr	r2, [sp, #4]
   18e80:	0e12      	lsrs	r2, r2, #24
   18e82:	b292      	uxth	r2, r2
   18e84:	b2d2      	uxtb	r2, r2
   18e86:	b292      	uxth	r2, r2
   18e88:	4611      	mov	r1, r2
   18e8a:	4798      	blx	r3
    // Send arg byte [23:16]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 16) & 0xFF);
   18e8c:	9b03      	ldr	r3, [sp, #12]
   18e8e:	6858      	ldr	r0, [r3, #4]
   18e90:	9b03      	ldr	r3, [sp, #12]
   18e92:	685b      	ldr	r3, [r3, #4]
   18e94:	681b      	ldr	r3, [r3, #0]
   18e96:	3308      	adds	r3, #8
   18e98:	681b      	ldr	r3, [r3, #0]
   18e9a:	9a01      	ldr	r2, [sp, #4]
   18e9c:	0c12      	lsrs	r2, r2, #16
   18e9e:	b292      	uxth	r2, r2
   18ea0:	b2d2      	uxtb	r2, r2
   18ea2:	b292      	uxth	r2, r2
   18ea4:	4611      	mov	r1, r2
   18ea6:	4798      	blx	r3
    // Send arg byte [15:8]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 8) & 0xFF);
   18ea8:	9b03      	ldr	r3, [sp, #12]
   18eaa:	6858      	ldr	r0, [r3, #4]
   18eac:	9b03      	ldr	r3, [sp, #12]
   18eae:	685b      	ldr	r3, [r3, #4]
   18eb0:	681b      	ldr	r3, [r3, #0]
   18eb2:	3308      	adds	r3, #8
   18eb4:	681b      	ldr	r3, [r3, #0]
   18eb6:	9a01      	ldr	r2, [sp, #4]
   18eb8:	0a12      	lsrs	r2, r2, #8
   18eba:	b292      	uxth	r2, r2
   18ebc:	b2d2      	uxtb	r2, r2
   18ebe:	b292      	uxth	r2, r2
   18ec0:	4611      	mov	r1, r2
   18ec2:	4798      	blx	r3
    // Send arg byte [7:0]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 0) & 0xFF);
   18ec4:	9b03      	ldr	r3, [sp, #12]
   18ec6:	685a      	ldr	r2, [r3, #4]
   18ec8:	9b03      	ldr	r3, [sp, #12]
   18eca:	685b      	ldr	r3, [r3, #4]
   18ecc:	681b      	ldr	r3, [r3, #0]
   18ece:	3308      	adds	r3, #8
   18ed0:	681b      	ldr	r3, [r3, #0]
   18ed2:	9901      	ldr	r1, [sp, #4]
   18ed4:	b289      	uxth	r1, r1
   18ed6:	b2c9      	uxtb	r1, r1
   18ed8:	b289      	uxth	r1, r1
   18eda:	4610      	mov	r0, r2
   18edc:	4798      	blx	r3
    // Send 7-bit CRC and LSB stop addr (as b1)
    ssp_interface_->Transfer(static_cast<uint16_t>(crc << 1) | 0x01);
   18ede:	9b03      	ldr	r3, [sp, #12]
   18ee0:	6858      	ldr	r0, [r3, #4]
   18ee2:	9b03      	ldr	r3, [sp, #12]
   18ee4:	685b      	ldr	r3, [r3, #4]
   18ee6:	681b      	ldr	r3, [r3, #0]
   18ee8:	3308      	adds	r3, #8
   18eea:	681b      	ldr	r3, [r3, #0]
   18eec:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   18ef0:	b292      	uxth	r2, r2
   18ef2:	0052      	lsls	r2, r2, #1
   18ef4:	b292      	uxth	r2, r2
   18ef6:	f042 0201 	orr.w	r2, r2, #1
   18efa:	b292      	uxth	r2, r2
   18efc:	4611      	mov	r1, r2
   18efe:	4798      	blx	r3

    // Write garbage while waiting for a response
    // Send at least 1 byte of garbage before checking for a response
    temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18f00:	9b03      	ldr	r3, [sp, #12]
   18f02:	685a      	ldr	r2, [r3, #4]
   18f04:	9b03      	ldr	r3, [sp, #12]
   18f06:	685b      	ldr	r3, [r3, #4]
   18f08:	681b      	ldr	r3, [r3, #0]
   18f0a:	3308      	adds	r3, #8
   18f0c:	681b      	ldr	r3, [r3, #0]
   18f0e:	21ff      	movs	r1, #255	; 0xff
   18f10:	4610      	mov	r0, r2
   18f12:	4798      	blx	r3
   18f14:	4603      	mov	r3, r0
   18f16:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (tries++ < kBusTimeout)
   18f1a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   18f1e:	1c5a      	adds	r2, r3, #1
   18f20:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   18f24:	2bf9      	cmp	r3, #249	; 0xf9
   18f26:	bf94      	ite	ls
   18f28:	2301      	movls	r3, #1
   18f2a:	2300      	movhi	r3, #0
   18f2c:	b2db      	uxtb	r3, r3
   18f2e:	2b00      	cmp	r3, #0
   18f30:	d027      	beq.n	18f82 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2da>
    {
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18f32:	9b03      	ldr	r3, [sp, #12]
   18f34:	685a      	ldr	r2, [r3, #4]
   18f36:	9b03      	ldr	r3, [sp, #12]
   18f38:	685b      	ldr	r3, [r3, #4]
   18f3a:	681b      	ldr	r3, [r3, #0]
   18f3c:	3308      	adds	r3, #8
   18f3e:	681b      	ldr	r3, [r3, #0]
   18f40:	21ff      	movs	r1, #255	; 0xff
   18f42:	4610      	mov	r0, r2
   18f44:	4798      	blx	r3
   18f46:	4603      	mov	r3, r0
   18f48:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
      if (temp_byte != 0xFF)
   18f4c:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   18f50:	2bff      	cmp	r3, #255	; 0xff
   18f52:	d00f      	beq.n	18f74 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2cc>
      {
        // Determine the offset, since the first byte of a
        // response will always be 0.
        while (temp_byte & (0x80 >> bit_offset))
   18f54:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   18f58:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18f5c:	2180      	movs	r1, #128	; 0x80
   18f5e:	fa41 f303 	asr.w	r3, r1, r3
   18f62:	4013      	ands	r3, r2
   18f64:	2b00      	cmp	r3, #0
   18f66:	d00b      	beq.n	18f80 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2d8>
        {
          bit_offset++;
   18f68:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18f6c:	3301      	adds	r3, #1
   18f6e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        while (temp_byte & (0x80 >> bit_offset))
   18f72:	e7ef      	b.n	18f54 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2ac>
        }
        break;
      }
      tries++;
   18f74:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   18f78:	3301      	adds	r3, #1
   18f7a:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    while (tries++ < kBusTimeout)
   18f7e:	e7cc      	b.n	18f1a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x272>
        break;
   18f80:	bf00      	nop
    }

    // Determine response length (in bytes) based on response type
    switch (res_type)
   18f82:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18f84:	2b07      	cmp	r3, #7
   18f86:	d827      	bhi.n	18fd8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x330>
   18f88:	a201      	add	r2, pc, #4	; (adr r2, 18f90 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2e8>)
   18f8a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   18f8e:	bf00      	nop
   18f90:	00018fb1 	.word	0x00018fb1
   18f94:	00018fb9 	.word	0x00018fb9
   18f98:	00018fc1 	.word	0x00018fc1
   18f9c:	00018fc9 	.word	0x00018fc9
   18fa0:	00018fd9 	.word	0x00018fd9
   18fa4:	00018fd9 	.word	0x00018fd9
   18fa8:	00018fd9 	.word	0x00018fd9
   18fac:	00018fd1 	.word	0x00018fd1
    {
      case ResponseType::kR1: res_len = 1; break;
   18fb0:	2301      	movs	r3, #1
   18fb2:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18fb6:	e019      	b.n	18fec <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR1b: res_len = 1; break;
   18fb8:	2301      	movs	r3, #1
   18fba:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18fbe:	e015      	b.n	18fec <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR2: res_len = 2; break;
   18fc0:	2302      	movs	r3, #2
   18fc2:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18fc6:	e011      	b.n	18fec <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR3: res_len = 5; break;
   18fc8:	2305      	movs	r3, #5
   18fca:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18fce:	e00d      	b.n	18fec <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR7: res_len = 5; break;
   18fd0:	2305      	movs	r3, #5
   18fd2:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18fd6:	e009      	b.n	18fec <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      default:
        LOG_ERROR("Response unsupported in SPI mode. Aborting!");
   18fd8:	f240 433a 	movw	r3, #1082	; 0x43a
   18fdc:	4a56      	ldr	r2, [pc, #344]	; (19138 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x490>)
   18fde:	4957      	ldr	r1, [pc, #348]	; (1913c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x494>)
   18fe0:	4857      	ldr	r0, [pc, #348]	; (19140 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x498>)
   18fe2:	f7fe ff35 	bl	17e50 <printf>
        return -1;
   18fe6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   18fea:	e09a      	b.n	19122 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
        break;
    }

    // Acquire the response
    uint64_t temp_response = 0;
   18fec:	f04f 0200 	mov.w	r2, #0
   18ff0:	f04f 0300 	mov.w	r3, #0
   18ff4:	e9cd 2308 	strd	r2, r3, [sp, #32]
    // Read an extra 8 bits since the response was offset
    uint8_t bytes_to_read =
   18ff8:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18ffc:	2b00      	cmp	r3, #0
   18ffe:	d004      	beq.n	1900a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x362>
   19000:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   19004:	3301      	adds	r3, #1
   19006:	b2db      	uxtb	r3, r3
   19008:	e001      	b.n	1900e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x366>
   1900a:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   1900e:	f88d 301f 	strb.w	r3, [sp, #31]
        static_cast<uint8_t>((bit_offset > 0) ? res_len + 1 : res_len);
    while (bytes_to_read-- > 0)
   19012:	f89d 301f 	ldrb.w	r3, [sp, #31]
   19016:	1e5a      	subs	r2, r3, #1
   19018:	f88d 201f 	strb.w	r2, [sp, #31]
   1901c:	2b00      	cmp	r3, #0
   1901e:	bf14      	ite	ne
   19020:	2301      	movne	r3, #1
   19022:	2300      	moveq	r3, #0
   19024:	b2db      	uxtb	r3, r3
   19026:	2b00      	cmp	r3, #0
   19028:	d025      	beq.n	19076 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x3ce>
    {
      // Make space for the next byte
      temp_response = temp_response << 8;
   1902a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   1902e:	f04f 0200 	mov.w	r2, #0
   19032:	f04f 0300 	mov.w	r3, #0
   19036:	020b      	lsls	r3, r1, #8
   19038:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
   1903c:	0202      	lsls	r2, r0, #8
   1903e:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_response |= temp_byte;
   19042:	f89d b02f 	ldrb.w	fp, [sp, #47]	; 0x2f
   19046:	f04f 0c00 	mov.w	ip, #0
   1904a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   1904e:	ea4b 0200 	orr.w	r2, fp, r0
   19052:	ea4c 0301 	orr.w	r3, ip, r1
   19056:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1905a:	9b03      	ldr	r3, [sp, #12]
   1905c:	685a      	ldr	r2, [r3, #4]
   1905e:	9b03      	ldr	r3, [sp, #12]
   19060:	685b      	ldr	r3, [r3, #4]
   19062:	681b      	ldr	r3, [r3, #0]
   19064:	3308      	adds	r3, #8
   19066:	681b      	ldr	r3, [r3, #0]
   19068:	21ff      	movs	r1, #255	; 0xff
   1906a:	4610      	mov	r0, r2
   1906c:	4798      	blx	r3
   1906e:	4603      	mov	r3, r0
   19070:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (bytes_to_read-- > 0)
   19074:	e7cd      	b.n	19012 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x36a>
    }
    // Compensate for the bit offset
    temp_response = temp_response >> bit_offset;
   19076:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
   1907a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1907e:	f1c1 0c20 	rsb	ip, r1, #32
   19082:	f1a1 0020 	sub.w	r0, r1, #32
   19086:	fa22 f401 	lsr.w	r4, r2, r1
   1908a:	fa03 fc0c 	lsl.w	ip, r3, ip
   1908e:	ea44 040c 	orr.w	r4, r4, ip
   19092:	fa23 f000 	lsr.w	r0, r3, r0
   19096:	4304      	orrs	r4, r0
   19098:	fa23 f501 	lsr.w	r5, r3, r1
   1909c:	e9cd 4508 	strd	r4, r5, [sp, #32]

    // Only write to the response buffer if it is provided
    if (response_buffer != nullptr)
   190a0:	9b00      	ldr	r3, [sp, #0]
   190a2:	2b00      	cmp	r3, #0
   190a4:	d025      	beq.n	190f2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
    {
      for (int i = 0; i < res_len; i++)
   190a6:	2300      	movs	r3, #0
   190a8:	9306      	str	r3, [sp, #24]
   190aa:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   190ae:	9a06      	ldr	r2, [sp, #24]
   190b0:	429a      	cmp	r2, r3
   190b2:	da1e      	bge.n	190f2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
      {
        response_buffer[i] =
            static_cast<uint8_t>(temp_response >> 8 * (res_len - 1 - i));
   190b4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   190b8:	1e5a      	subs	r2, r3, #1
   190ba:	9b06      	ldr	r3, [sp, #24]
   190bc:	1ad3      	subs	r3, r2, r3
   190be:	00da      	lsls	r2, r3, #3
   190c0:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   190c4:	f1c2 0020 	rsb	r0, r2, #32
   190c8:	f1a2 0120 	sub.w	r1, r2, #32
   190cc:	fa23 f602 	lsr.w	r6, r3, r2
   190d0:	fa04 f000 	lsl.w	r0, r4, r0
   190d4:	4306      	orrs	r6, r0
   190d6:	fa24 f101 	lsr.w	r1, r4, r1
   190da:	430e      	orrs	r6, r1
   190dc:	fa24 f702 	lsr.w	r7, r4, r2
        response_buffer[i] =
   190e0:	9b06      	ldr	r3, [sp, #24]
   190e2:	9a00      	ldr	r2, [sp, #0]
   190e4:	4413      	add	r3, r2
   190e6:	b2f2      	uxtb	r2, r6
   190e8:	701a      	strb	r2, [r3, #0]
      for (int i = 0; i < res_len; i++)
   190ea:	9b06      	ldr	r3, [sp, #24]
   190ec:	3301      	adds	r3, #1
   190ee:	9306      	str	r3, [sp, #24]
   190f0:	e7db      	b.n	190aa <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x402>
      }
    }

    // Only end the transaction if keep_alive isn't requested
    if (keep_alive == KeepAlive::kNo)
   190f2:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
   190f6:	2b00      	cmp	r3, #0
   190f8:	d111      	bne.n	1911e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x476>
    {
      // Deselect the SPI comm board
      chip_select_->SetHigh();
   190fa:	9b03      	ldr	r3, [sp, #12]
   190fc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   190fe:	9b03      	ldr	r3, [sp, #12]
   19100:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   19102:	681b      	ldr	r3, [r3, #0]
   19104:	330c      	adds	r3, #12
   19106:	681b      	ldr	r3, [r3, #0]
   19108:	4610      	mov	r0, r2
   1910a:	4798      	blx	r3
      chip_select_external_->SetHigh();
   1910c:	9b03      	ldr	r3, [sp, #12]
   1910e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   19110:	9b03      	ldr	r3, [sp, #12]
   19112:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   19114:	681b      	ldr	r3, [r3, #0]
   19116:	330c      	adds	r3, #12
   19118:	681b      	ldr	r3, [r3, #0]
   1911a:	4610      	mov	r0, r2
   1911c:	4798      	blx	r3
    }
    return res_len;
   1911e:	f89d 4033 	ldrb.w	r4, [sp, #51]	; 0x33
   19122:	4643      	mov	r3, r8
   19124:	4619      	mov	r1, r3
   19126:	4807      	ldr	r0, [pc, #28]	; (19144 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x49c>)
   19128:	f7fc fac2 	bl	156b0 <__cyg_profile_func_exit>
   1912c:	4623      	mov	r3, r4
  }
   1912e:	4618      	mov	r0, r3
   19130:	b00f      	add	sp, #60	; 0x3c
   19132:	e8bd 89f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, fp, pc}
   19136:	bf00      	nop
   19138:	0001c670 	.word	0x0001c670
   1913c:	0001c56c 	.word	0x0001c56c
   19140:	0001c174 	.word	0x0001c174
   19144:	00018ca9 	.word	0x00018ca9

00019148 <Sd::Crc7Add(unsigned char, unsigned char)>:

  // Adds a message byte to the current CRC-7 to get a the new CRC-7
  uint8_t Crc7Add(uint8_t crc, uint8_t message_byte) override
   19148:	b530      	push	{r4, r5, lr}
   1914a:	b083      	sub	sp, #12
   1914c:	4675      	mov	r5, lr
   1914e:	9001      	str	r0, [sp, #4]
   19150:	460b      	mov	r3, r1
   19152:	f88d 3003 	strb.w	r3, [sp, #3]
   19156:	4613      	mov	r3, r2
   19158:	f88d 3002 	strb.w	r3, [sp, #2]
   1915c:	462b      	mov	r3, r5
   1915e:	4619      	mov	r1, r3
   19160:	4809      	ldr	r0, [pc, #36]	; (19188 <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   19162:	f7fc fa91 	bl	15688 <__cyg_profile_func_enter>
  {
    return kCrcTable8.crc_table[(crc << 1) ^ message_byte];
   19166:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1916a:	005a      	lsls	r2, r3, #1
   1916c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   19170:	4053      	eors	r3, r2
   19172:	4a06      	ldr	r2, [pc, #24]	; (1918c <Sd::Crc7Add(unsigned char, unsigned char)+0x44>)
   19174:	5cd4      	ldrb	r4, [r2, r3]
   19176:	462b      	mov	r3, r5
   19178:	4619      	mov	r1, r3
   1917a:	4803      	ldr	r0, [pc, #12]	; (19188 <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   1917c:	f7fc fa98 	bl	156b0 <__cyg_profile_func_exit>
   19180:	4623      	mov	r3, r4
  }
   19182:	4618      	mov	r0, r3
   19184:	b003      	add	sp, #12
   19186:	bd30      	pop	{r4, r5, pc}
   19188:	00019149 	.word	0x00019149
   1918c:	0001c1dc 	.word	0x0001c1dc

00019190 <Sd::GetCrc7(unsigned char*, unsigned char)>:

  // Returns the CRC-7 for a message of "length" bytes
  uint8_t GetCrc7(uint8_t * message, uint8_t length) override
   19190:	b530      	push	{r4, r5, lr}
   19192:	b087      	sub	sp, #28
   19194:	4675      	mov	r5, lr
   19196:	9003      	str	r0, [sp, #12]
   19198:	9102      	str	r1, [sp, #8]
   1919a:	4613      	mov	r3, r2
   1919c:	f88d 3007 	strb.w	r3, [sp, #7]
   191a0:	462b      	mov	r3, r5
   191a2:	4619      	mov	r1, r3
   191a4:	4815      	ldr	r0, [pc, #84]	; (191fc <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   191a6:	f7fc fa6f 	bl	15688 <__cyg_profile_func_enter>
  {
    uint8_t crc = 0;
   191aa:	2300      	movs	r3, #0
   191ac:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   191b0:	2300      	movs	r3, #0
   191b2:	9304      	str	r3, [sp, #16]
   191b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   191b8:	9a04      	ldr	r2, [sp, #16]
   191ba:	429a      	cmp	r2, r3
   191bc:	da12      	bge.n	191e4 <Sd::GetCrc7(unsigned char*, unsigned char)+0x54>
    {
      crc = Crc7Add(crc, message[i]);
   191be:	9b03      	ldr	r3, [sp, #12]
   191c0:	681b      	ldr	r3, [r3, #0]
   191c2:	3318      	adds	r3, #24
   191c4:	681b      	ldr	r3, [r3, #0]
   191c6:	9a04      	ldr	r2, [sp, #16]
   191c8:	9902      	ldr	r1, [sp, #8]
   191ca:	440a      	add	r2, r1
   191cc:	7812      	ldrb	r2, [r2, #0]
   191ce:	f89d 1017 	ldrb.w	r1, [sp, #23]
   191d2:	9803      	ldr	r0, [sp, #12]
   191d4:	4798      	blx	r3
   191d6:	4603      	mov	r3, r0
   191d8:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   191dc:	9b04      	ldr	r3, [sp, #16]
   191de:	3301      	adds	r3, #1
   191e0:	9304      	str	r3, [sp, #16]
   191e2:	e7e7      	b.n	191b4 <Sd::GetCrc7(unsigned char*, unsigned char)+0x24>
    }
    return crc;
   191e4:	f89d 4017 	ldrb.w	r4, [sp, #23]
   191e8:	462b      	mov	r3, r5
   191ea:	4619      	mov	r1, r3
   191ec:	4803      	ldr	r0, [pc, #12]	; (191fc <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   191ee:	f7fc fa5f 	bl	156b0 <__cyg_profile_func_exit>
   191f2:	4623      	mov	r3, r4
  }
   191f4:	4618      	mov	r0, r3
   191f6:	b007      	add	sp, #28
   191f8:	bd30      	pop	{r4, r5, pc}
   191fa:	bf00      	nop
   191fc:	00019191 	.word	0x00019191

00019200 <Sd::GetCrc16(unsigned char*, unsigned short)>:

  // Returns CCITT CRC-16 for a message of "length" bytes
  uint16_t GetCrc16(uint8_t * message, uint16_t length) override
   19200:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   19204:	b08c      	sub	sp, #48	; 0x30
   19206:	4677      	mov	r7, lr
   19208:	9003      	str	r0, [sp, #12]
   1920a:	9102      	str	r1, [sp, #8]
   1920c:	4613      	mov	r3, r2
   1920e:	f8ad 3006 	strh.w	r3, [sp, #6]
   19212:	463b      	mov	r3, r7
   19214:	4619      	mov	r1, r3
   19216:	4837      	ldr	r0, [pc, #220]	; (192f4 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   19218:	f7fc fa36 	bl	15688 <__cyg_profile_func_enter>
  {
    uint64_t crc = 0x0000;
   1921c:	f04f 0300 	mov.w	r3, #0
   19220:	f04f 0400 	mov.w	r4, #0
   19224:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    uint64_t temp;
    uint64_t final_value = 0;
   19228:	f04f 0300 	mov.w	r3, #0
   1922c:	f04f 0400 	mov.w	r4, #0
   19230:	e9cd 3406 	strd	r3, r4, [sp, #24]

    for (uint64_t count = 0; count < length; ++count)
   19234:	f04f 0300 	mov.w	r3, #0
   19238:	f04f 0400 	mov.w	r4, #0
   1923c:	e9cd 3408 	strd	r3, r4, [sp, #32]
   19240:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   19244:	f04f 0400 	mov.w	r4, #0
   19248:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   1924c:	42a2      	cmp	r2, r4
   1924e:	bf08      	it	eq
   19250:	4299      	cmpeq	r1, r3
   19252:	d23f      	bcs.n	192d4 <Sd::GetCrc16(unsigned char*, unsigned short)+0xd4>
    {
      temp = (*message++ ^ (crc >> 8)) & 0xff;
   19254:	9b02      	ldr	r3, [sp, #8]
   19256:	1c5a      	adds	r2, r3, #1
   19258:	9202      	str	r2, [sp, #8]
   1925a:	781b      	ldrb	r3, [r3, #0]
   1925c:	b2dd      	uxtb	r5, r3
   1925e:	f04f 0600 	mov.w	r6, #0
   19262:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   19266:	f04f 0300 	mov.w	r3, #0
   1926a:	f04f 0400 	mov.w	r4, #0
   1926e:	0a0b      	lsrs	r3, r1, #8
   19270:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   19274:	0a14      	lsrs	r4, r2, #8
   19276:	ea83 0b05 	eor.w	fp, r3, r5
   1927a:	ea84 0c06 	eor.w	ip, r4, r6
   1927e:	f04f 01ff 	mov.w	r1, #255	; 0xff
   19282:	f04f 0200 	mov.w	r2, #0
   19286:	ea0b 0301 	and.w	r3, fp, r1
   1928a:	ea0c 0402 	and.w	r4, ip, r2
   1928e:	e9cd 3404 	strd	r3, r4, [sp, #16]
      crc  = kCrcTable16.crc_table[temp] ^ (crc << 8);
   19292:	4a19      	ldr	r2, [pc, #100]	; (192f8 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf8>)
   19294:	9b04      	ldr	r3, [sp, #16]
   19296:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   1929a:	b29d      	uxth	r5, r3
   1929c:	f04f 0600 	mov.w	r6, #0
   192a0:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   192a4:	f04f 0b00 	mov.w	fp, #0
   192a8:	f04f 0c00 	mov.w	ip, #0
   192ac:	ea4f 2c02 	mov.w	ip, r2, lsl #8
   192b0:	ea4c 6c11 	orr.w	ip, ip, r1, lsr #24
   192b4:	ea4f 2b01 	mov.w	fp, r1, lsl #8
   192b8:	ea8b 0305 	eor.w	r3, fp, r5
   192bc:	ea8c 0406 	eor.w	r4, ip, r6
   192c0:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    for (uint64_t count = 0; count < length; ++count)
   192c4:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   192c8:	1c59      	adds	r1, r3, #1
   192ca:	f144 0200 	adc.w	r2, r4, #0
   192ce:	e9cd 1208 	strd	r1, r2, [sp, #32]
   192d2:	e7b5      	b.n	19240 <Sd::GetCrc16(unsigned char*, unsigned short)+0x40>
    }

    return static_cast<uint16_t>(crc ^ final_value);
   192d4:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   192d8:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   192dc:	4053      	eors	r3, r2
   192de:	b29c      	uxth	r4, r3
   192e0:	463b      	mov	r3, r7
   192e2:	4619      	mov	r1, r3
   192e4:	4803      	ldr	r0, [pc, #12]	; (192f4 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   192e6:	f7fc f9e3 	bl	156b0 <__cyg_profile_func_exit>
   192ea:	4623      	mov	r3, r4
  }
   192ec:	4618      	mov	r0, r3
   192ee:	b00c      	add	sp, #48	; 0x30
   192f0:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   192f4:	00019201 	.word	0x00019201
   192f8:	0001c2dc 	.word	0x0001c2dc

000192fc <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   192fc:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   19300:	b088      	sub	sp, #32
   19302:	4675      	mov	r5, lr
   19304:	e9cd 0102 	strd	r0, r1, [sp, #8]
   19308:	f88d 2004 	strb.w	r2, [sp, #4]
   1930c:	462b      	mov	r3, r5
   1930e:	4619      	mov	r1, r3
   19310:	4824      	ldr	r0, [pc, #144]	; (193a4 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   19312:	f7fc f9b9 	bl	15688 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   19316:	f04f 0300 	mov.w	r3, #0
   1931a:	f04f 0400 	mov.w	r4, #0
   1931e:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   19322:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   19326:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   1932a:	bf08      	it	eq
   1932c:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   19330:	d106      	bne.n	19340 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x44>
    timeout_time = kMaxWait;
   19332:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   19336:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1933a:	e9cd 3406 	strd	r3, r4, [sp, #24]
   1933e:	e00b      	b.n	19358 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x5c>
    timeout_time = Milliseconds() + timeout;
   19340:	f7f7 fbe2 	bl	10b08 <Milliseconds()>
   19344:	460a      	mov	r2, r1
   19346:	4601      	mov	r1, r0
   19348:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   1934c:	eb13 0b01 	adds.w	fp, r3, r1
   19350:	eb44 0c02 	adc.w	ip, r4, r2
   19354:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   19358:	2301      	movs	r3, #1
   1935a:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   1935c:	f7f7 fbd4 	bl	10b08 <Milliseconds()>
   19360:	460a      	mov	r2, r1
   19362:	4601      	mov	r1, r0
   19364:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   19368:	42a2      	cmp	r2, r4
   1936a:	bf08      	it	eq
   1936c:	4299      	cmpeq	r1, r3
   1936e:	bf34      	ite	cc
   19370:	2301      	movcc	r3, #1
   19372:	2300      	movcs	r3, #0
   19374:	b2db      	uxtb	r3, r3
   19376:	2b00      	cmp	r3, #0
   19378:	d008      	beq.n	1938c <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x90>
    if (is_done())
   1937a:	ab01      	add	r3, sp, #4
   1937c:	4618      	mov	r0, r3
   1937e:	f7fe fdaf 	bl	17ee0 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   19382:	4603      	mov	r3, r0
   19384:	2b00      	cmp	r3, #0
   19386:	d0e9      	beq.n	1935c <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x60>
      status = Status::kSuccess;
   19388:	2300      	movs	r3, #0
   1938a:	9305      	str	r3, [sp, #20]
  return status;
   1938c:	9c05      	ldr	r4, [sp, #20]
   1938e:	462b      	mov	r3, r5
   19390:	4619      	mov	r1, r3
   19392:	4804      	ldr	r0, [pc, #16]	; (193a4 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   19394:	f7fc f98c 	bl	156b0 <__cyg_profile_func_exit>
   19398:	4623      	mov	r3, r4
}
   1939a:	4618      	mov	r0, r3
   1939c:	b008      	add	sp, #32
   1939e:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   193a2:	bf00      	nop
   193a4:	000192fd 	.word	0x000192fd

000193a8 <__static_initialization_and_destruction_0(int, int)>:
extern "C" DRESULT disk_ioctl([[maybe_unused]] BYTE drive_number,
                              [[maybe_unused]] BYTE command,
                              [[maybe_unused]] void * buffer)
{
  return RES_PARERR;
}
   193a8:	b530      	push	{r4, r5, lr}
   193aa:	b085      	sub	sp, #20
   193ac:	4674      	mov	r4, lr
   193ae:	9003      	str	r0, [sp, #12]
   193b0:	9102      	str	r1, [sp, #8]
   193b2:	4623      	mov	r3, r4
   193b4:	4619      	mov	r1, r3
   193b6:	480e      	ldr	r0, [pc, #56]	; (193f0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   193b8:	f7fc f966 	bl	15688 <__cyg_profile_func_enter>
   193bc:	9b03      	ldr	r3, [sp, #12]
   193be:	2b01      	cmp	r3, #1
   193c0:	d10e      	bne.n	193e0 <__static_initialization_and_destruction_0(int, int)+0x38>
   193c2:	9b02      	ldr	r3, [sp, #8]
   193c4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   193c8:	4293      	cmp	r3, r2
   193ca:	d109      	bne.n	193e0 <__static_initialization_and_destruction_0(int, int)+0x38>
Sd sd_card(Sd::DebugSdCard_t{});
   193cc:	2306      	movs	r3, #6
   193ce:	9301      	str	r3, [sp, #4]
   193d0:	2300      	movs	r3, #0
   193d2:	9300      	str	r3, [sp, #0]
   193d4:	2308      	movs	r3, #8
   193d6:	2201      	movs	r2, #1
   193d8:	4629      	mov	r1, r5
   193da:	4806      	ldr	r0, [pc, #24]	; (193f4 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   193dc:	f7fe fe40 	bl	18060 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>
   193e0:	4623      	mov	r3, r4
   193e2:	4619      	mov	r1, r3
   193e4:	4802      	ldr	r0, [pc, #8]	; (193f0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   193e6:	f7fc f963 	bl	156b0 <__cyg_profile_func_exit>
}
   193ea:	bf00      	nop
   193ec:	b005      	add	sp, #20
   193ee:	bd30      	pop	{r4, r5, pc}
   193f0:	000193a9 	.word	0x000193a9
   193f4:	1000165c 	.word	0x1000165c

000193f8 <_GLOBAL__sub_I_disk_status>:
   193f8:	b510      	push	{r4, lr}
   193fa:	4674      	mov	r4, lr
   193fc:	4623      	mov	r3, r4
   193fe:	4619      	mov	r1, r3
   19400:	4806      	ldr	r0, [pc, #24]	; (1941c <_GLOBAL__sub_I_disk_status+0x24>)
   19402:	f7fc f941 	bl	15688 <__cyg_profile_func_enter>
   19406:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1940a:	2001      	movs	r0, #1
   1940c:	f7ff ffcc 	bl	193a8 <__static_initialization_and_destruction_0(int, int)>
   19410:	4623      	mov	r3, r4
   19412:	4619      	mov	r1, r3
   19414:	4801      	ldr	r0, [pc, #4]	; (1941c <_GLOBAL__sub_I_disk_status+0x24>)
   19416:	f7fc f94b 	bl	156b0 <__cyg_profile_func_exit>
   1941a:	bd10      	pop	{r4, pc}
   1941c:	000193f9 	.word	0x000193f9

00019420 <__cxa_pure_virtual>:
   19420:	b508      	push	{r3, lr}
   19422:	f000 f80d 	bl	19440 <std::terminate()>

00019426 <__cxxabiv1::__terminate(void (*)())>:
   19426:	b508      	push	{r3, lr}
   19428:	4780      	blx	r0
   1942a:	f000 fa0f 	bl	1984c <abort>
   1942e:	Address 0x000000000001942e is out of bounds.


00019430 <std::get_terminate()>:
   19430:	4b02      	ldr	r3, [pc, #8]	; (1943c <std::get_terminate()+0xc>)
   19432:	6818      	ldr	r0, [r3, #0]
   19434:	f3bf 8f5b 	dmb	ish
   19438:	4770      	bx	lr
   1943a:	bf00      	nop
   1943c:	100008e4 	.word	0x100008e4

00019440 <std::terminate()>:
   19440:	b508      	push	{r3, lr}
   19442:	f7ff fff5 	bl	19430 <std::get_terminate()>
   19446:	f7ff ffee 	bl	19426 <__cxxabiv1::__terminate(void (*)())>
   1944a:	Address 0x000000000001944a is out of bounds.


0001944c <roundf>:
   1944c:	b082      	sub	sp, #8
   1944e:	ed8d 0a01 	vstr	s0, [sp, #4]
   19452:	9901      	ldr	r1, [sp, #4]
   19454:	f3c1 53c7 	ubfx	r3, r1, #23, #8
   19458:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
   1945c:	2a16      	cmp	r2, #22
   1945e:	dc0c      	bgt.n	1947a <roundf+0x2e>
   19460:	2a00      	cmp	r2, #0
   19462:	db10      	blt.n	19486 <roundf+0x3a>
   19464:	4810      	ldr	r0, [pc, #64]	; (194a8 <roundf+0x5c>)
   19466:	4110      	asrs	r0, r2
   19468:	4201      	tst	r1, r0
   1946a:	d008      	beq.n	1947e <roundf+0x32>
   1946c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   19470:	4113      	asrs	r3, r2
   19472:	440b      	add	r3, r1
   19474:	ea23 0300 	bic.w	r3, r3, r0
   19478:	e00b      	b.n	19492 <roundf+0x46>
   1947a:	2a80      	cmp	r2, #128	; 0x80
   1947c:	d00d      	beq.n	1949a <roundf+0x4e>
   1947e:	ed9d 0a01 	vldr	s0, [sp, #4]
   19482:	b002      	add	sp, #8
   19484:	4770      	bx	lr
   19486:	3201      	adds	r2, #1
   19488:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
   1948c:	d101      	bne.n	19492 <roundf+0x46>
   1948e:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
   19492:	ee00 3a10 	vmov	s0, r3
   19496:	b002      	add	sp, #8
   19498:	4770      	bx	lr
   1949a:	eddd 7a01 	vldr	s15, [sp, #4]
   1949e:	ee37 0aa7 	vadd.f32	s0, s15, s15
   194a2:	b002      	add	sp, #8
   194a4:	4770      	bx	lr
   194a6:	bf00      	nop
   194a8:	007fffff 	.word	0x007fffff

000194ac <__aeabi_d2f>:
   194ac:	ea4f 0241 	mov.w	r2, r1, lsl #1
   194b0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   194b4:	bf24      	itt	cs
   194b6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   194ba:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   194be:	d90d      	bls.n	194dc <__aeabi_d2f+0x30>
   194c0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   194c4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   194c8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   194cc:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   194d0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   194d4:	bf08      	it	eq
   194d6:	f020 0001 	biceq.w	r0, r0, #1
   194da:	4770      	bx	lr
   194dc:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   194e0:	d121      	bne.n	19526 <__aeabi_d2f+0x7a>
   194e2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   194e6:	bfbc      	itt	lt
   194e8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   194ec:	4770      	bxlt	lr
   194ee:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   194f2:	ea4f 5252 	mov.w	r2, r2, lsr #21
   194f6:	f1c2 0218 	rsb	r2, r2, #24
   194fa:	f1c2 0c20 	rsb	ip, r2, #32
   194fe:	fa10 f30c 	lsls.w	r3, r0, ip
   19502:	fa20 f002 	lsr.w	r0, r0, r2
   19506:	bf18      	it	ne
   19508:	f040 0001 	orrne.w	r0, r0, #1
   1950c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   19510:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   19514:	fa03 fc0c 	lsl.w	ip, r3, ip
   19518:	ea40 000c 	orr.w	r0, r0, ip
   1951c:	fa23 f302 	lsr.w	r3, r3, r2
   19520:	ea4f 0343 	mov.w	r3, r3, lsl #1
   19524:	e7cc      	b.n	194c0 <__aeabi_d2f+0x14>
   19526:	ea7f 5362 	mvns.w	r3, r2, asr #21
   1952a:	d107      	bne.n	1953c <__aeabi_d2f+0x90>
   1952c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   19530:	bf1e      	ittt	ne
   19532:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   19536:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   1953a:	4770      	bxne	lr
   1953c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   19540:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   19544:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   19548:	4770      	bx	lr
   1954a:	bf00      	nop

0001954c <__aeabi_uldivmod>:
   1954c:	b953      	cbnz	r3, 19564 <__aeabi_uldivmod+0x18>
   1954e:	b94a      	cbnz	r2, 19564 <__aeabi_uldivmod+0x18>
   19550:	2900      	cmp	r1, #0
   19552:	bf08      	it	eq
   19554:	2800      	cmpeq	r0, #0
   19556:	bf1c      	itt	ne
   19558:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1955c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   19560:	f000 b972 	b.w	19848 <__aeabi_idiv0>
   19564:	f1ad 0c08 	sub.w	ip, sp, #8
   19568:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1956c:	f000 f806 	bl	1957c <__udivmoddi4>
   19570:	f8dd e004 	ldr.w	lr, [sp, #4]
   19574:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   19578:	b004      	add	sp, #16
   1957a:	4770      	bx	lr

0001957c <__udivmoddi4>:
   1957c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19580:	9e08      	ldr	r6, [sp, #32]
   19582:	4604      	mov	r4, r0
   19584:	4688      	mov	r8, r1
   19586:	2b00      	cmp	r3, #0
   19588:	d14b      	bne.n	19622 <__udivmoddi4+0xa6>
   1958a:	428a      	cmp	r2, r1
   1958c:	4615      	mov	r5, r2
   1958e:	d967      	bls.n	19660 <__udivmoddi4+0xe4>
   19590:	fab2 f282 	clz	r2, r2
   19594:	b14a      	cbz	r2, 195aa <__udivmoddi4+0x2e>
   19596:	f1c2 0720 	rsb	r7, r2, #32
   1959a:	fa01 f302 	lsl.w	r3, r1, r2
   1959e:	fa20 f707 	lsr.w	r7, r0, r7
   195a2:	4095      	lsls	r5, r2
   195a4:	ea47 0803 	orr.w	r8, r7, r3
   195a8:	4094      	lsls	r4, r2
   195aa:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   195ae:	0c23      	lsrs	r3, r4, #16
   195b0:	fbb8 f7fe 	udiv	r7, r8, lr
   195b4:	fa1f fc85 	uxth.w	ip, r5
   195b8:	fb0e 8817 	mls	r8, lr, r7, r8
   195bc:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   195c0:	fb07 f10c 	mul.w	r1, r7, ip
   195c4:	4299      	cmp	r1, r3
   195c6:	d909      	bls.n	195dc <__udivmoddi4+0x60>
   195c8:	18eb      	adds	r3, r5, r3
   195ca:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   195ce:	f080 811b 	bcs.w	19808 <__udivmoddi4+0x28c>
   195d2:	4299      	cmp	r1, r3
   195d4:	f240 8118 	bls.w	19808 <__udivmoddi4+0x28c>
   195d8:	3f02      	subs	r7, #2
   195da:	442b      	add	r3, r5
   195dc:	1a5b      	subs	r3, r3, r1
   195de:	b2a4      	uxth	r4, r4
   195e0:	fbb3 f0fe 	udiv	r0, r3, lr
   195e4:	fb0e 3310 	mls	r3, lr, r0, r3
   195e8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   195ec:	fb00 fc0c 	mul.w	ip, r0, ip
   195f0:	45a4      	cmp	ip, r4
   195f2:	d909      	bls.n	19608 <__udivmoddi4+0x8c>
   195f4:	192c      	adds	r4, r5, r4
   195f6:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   195fa:	f080 8107 	bcs.w	1980c <__udivmoddi4+0x290>
   195fe:	45a4      	cmp	ip, r4
   19600:	f240 8104 	bls.w	1980c <__udivmoddi4+0x290>
   19604:	3802      	subs	r0, #2
   19606:	442c      	add	r4, r5
   19608:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   1960c:	eba4 040c 	sub.w	r4, r4, ip
   19610:	2700      	movs	r7, #0
   19612:	b11e      	cbz	r6, 1961c <__udivmoddi4+0xa0>
   19614:	40d4      	lsrs	r4, r2
   19616:	2300      	movs	r3, #0
   19618:	e9c6 4300 	strd	r4, r3, [r6]
   1961c:	4639      	mov	r1, r7
   1961e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   19622:	428b      	cmp	r3, r1
   19624:	d909      	bls.n	1963a <__udivmoddi4+0xbe>
   19626:	2e00      	cmp	r6, #0
   19628:	f000 80eb 	beq.w	19802 <__udivmoddi4+0x286>
   1962c:	2700      	movs	r7, #0
   1962e:	e9c6 0100 	strd	r0, r1, [r6]
   19632:	4638      	mov	r0, r7
   19634:	4639      	mov	r1, r7
   19636:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1963a:	fab3 f783 	clz	r7, r3
   1963e:	2f00      	cmp	r7, #0
   19640:	d147      	bne.n	196d2 <__udivmoddi4+0x156>
   19642:	428b      	cmp	r3, r1
   19644:	d302      	bcc.n	1964c <__udivmoddi4+0xd0>
   19646:	4282      	cmp	r2, r0
   19648:	f200 80fa 	bhi.w	19840 <__udivmoddi4+0x2c4>
   1964c:	1a84      	subs	r4, r0, r2
   1964e:	eb61 0303 	sbc.w	r3, r1, r3
   19652:	2001      	movs	r0, #1
   19654:	4698      	mov	r8, r3
   19656:	2e00      	cmp	r6, #0
   19658:	d0e0      	beq.n	1961c <__udivmoddi4+0xa0>
   1965a:	e9c6 4800 	strd	r4, r8, [r6]
   1965e:	e7dd      	b.n	1961c <__udivmoddi4+0xa0>
   19660:	b902      	cbnz	r2, 19664 <__udivmoddi4+0xe8>
   19662:	deff      	udf	#255	; 0xff
   19664:	fab2 f282 	clz	r2, r2
   19668:	2a00      	cmp	r2, #0
   1966a:	f040 808f 	bne.w	1978c <__udivmoddi4+0x210>
   1966e:	1b49      	subs	r1, r1, r5
   19670:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   19674:	fa1f f885 	uxth.w	r8, r5
   19678:	2701      	movs	r7, #1
   1967a:	fbb1 fcfe 	udiv	ip, r1, lr
   1967e:	0c23      	lsrs	r3, r4, #16
   19680:	fb0e 111c 	mls	r1, lr, ip, r1
   19684:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   19688:	fb08 f10c 	mul.w	r1, r8, ip
   1968c:	4299      	cmp	r1, r3
   1968e:	d907      	bls.n	196a0 <__udivmoddi4+0x124>
   19690:	18eb      	adds	r3, r5, r3
   19692:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   19696:	d202      	bcs.n	1969e <__udivmoddi4+0x122>
   19698:	4299      	cmp	r1, r3
   1969a:	f200 80cd 	bhi.w	19838 <__udivmoddi4+0x2bc>
   1969e:	4684      	mov	ip, r0
   196a0:	1a59      	subs	r1, r3, r1
   196a2:	b2a3      	uxth	r3, r4
   196a4:	fbb1 f0fe 	udiv	r0, r1, lr
   196a8:	fb0e 1410 	mls	r4, lr, r0, r1
   196ac:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   196b0:	fb08 f800 	mul.w	r8, r8, r0
   196b4:	45a0      	cmp	r8, r4
   196b6:	d907      	bls.n	196c8 <__udivmoddi4+0x14c>
   196b8:	192c      	adds	r4, r5, r4
   196ba:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   196be:	d202      	bcs.n	196c6 <__udivmoddi4+0x14a>
   196c0:	45a0      	cmp	r8, r4
   196c2:	f200 80b6 	bhi.w	19832 <__udivmoddi4+0x2b6>
   196c6:	4618      	mov	r0, r3
   196c8:	eba4 0408 	sub.w	r4, r4, r8
   196cc:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   196d0:	e79f      	b.n	19612 <__udivmoddi4+0x96>
   196d2:	f1c7 0c20 	rsb	ip, r7, #32
   196d6:	40bb      	lsls	r3, r7
   196d8:	fa22 fe0c 	lsr.w	lr, r2, ip
   196dc:	ea4e 0e03 	orr.w	lr, lr, r3
   196e0:	fa01 f407 	lsl.w	r4, r1, r7
   196e4:	fa20 f50c 	lsr.w	r5, r0, ip
   196e8:	fa21 f30c 	lsr.w	r3, r1, ip
   196ec:	ea4f 481e 	mov.w	r8, lr, lsr #16
   196f0:	4325      	orrs	r5, r4
   196f2:	fbb3 f9f8 	udiv	r9, r3, r8
   196f6:	0c2c      	lsrs	r4, r5, #16
   196f8:	fb08 3319 	mls	r3, r8, r9, r3
   196fc:	fa1f fa8e 	uxth.w	sl, lr
   19700:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   19704:	fb09 f40a 	mul.w	r4, r9, sl
   19708:	429c      	cmp	r4, r3
   1970a:	fa02 f207 	lsl.w	r2, r2, r7
   1970e:	fa00 f107 	lsl.w	r1, r0, r7
   19712:	d90b      	bls.n	1972c <__udivmoddi4+0x1b0>
   19714:	eb1e 0303 	adds.w	r3, lr, r3
   19718:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   1971c:	f080 8087 	bcs.w	1982e <__udivmoddi4+0x2b2>
   19720:	429c      	cmp	r4, r3
   19722:	f240 8084 	bls.w	1982e <__udivmoddi4+0x2b2>
   19726:	f1a9 0902 	sub.w	r9, r9, #2
   1972a:	4473      	add	r3, lr
   1972c:	1b1b      	subs	r3, r3, r4
   1972e:	b2ad      	uxth	r5, r5
   19730:	fbb3 f0f8 	udiv	r0, r3, r8
   19734:	fb08 3310 	mls	r3, r8, r0, r3
   19738:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   1973c:	fb00 fa0a 	mul.w	sl, r0, sl
   19740:	45a2      	cmp	sl, r4
   19742:	d908      	bls.n	19756 <__udivmoddi4+0x1da>
   19744:	eb1e 0404 	adds.w	r4, lr, r4
   19748:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1974c:	d26b      	bcs.n	19826 <__udivmoddi4+0x2aa>
   1974e:	45a2      	cmp	sl, r4
   19750:	d969      	bls.n	19826 <__udivmoddi4+0x2aa>
   19752:	3802      	subs	r0, #2
   19754:	4474      	add	r4, lr
   19756:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   1975a:	fba0 8902 	umull	r8, r9, r0, r2
   1975e:	eba4 040a 	sub.w	r4, r4, sl
   19762:	454c      	cmp	r4, r9
   19764:	46c2      	mov	sl, r8
   19766:	464b      	mov	r3, r9
   19768:	d354      	bcc.n	19814 <__udivmoddi4+0x298>
   1976a:	d051      	beq.n	19810 <__udivmoddi4+0x294>
   1976c:	2e00      	cmp	r6, #0
   1976e:	d069      	beq.n	19844 <__udivmoddi4+0x2c8>
   19770:	ebb1 050a 	subs.w	r5, r1, sl
   19774:	eb64 0403 	sbc.w	r4, r4, r3
   19778:	fa04 fc0c 	lsl.w	ip, r4, ip
   1977c:	40fd      	lsrs	r5, r7
   1977e:	40fc      	lsrs	r4, r7
   19780:	ea4c 0505 	orr.w	r5, ip, r5
   19784:	e9c6 5400 	strd	r5, r4, [r6]
   19788:	2700      	movs	r7, #0
   1978a:	e747      	b.n	1961c <__udivmoddi4+0xa0>
   1978c:	f1c2 0320 	rsb	r3, r2, #32
   19790:	fa20 f703 	lsr.w	r7, r0, r3
   19794:	4095      	lsls	r5, r2
   19796:	fa01 f002 	lsl.w	r0, r1, r2
   1979a:	fa21 f303 	lsr.w	r3, r1, r3
   1979e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   197a2:	4338      	orrs	r0, r7
   197a4:	0c01      	lsrs	r1, r0, #16
   197a6:	fbb3 f7fe 	udiv	r7, r3, lr
   197aa:	fa1f f885 	uxth.w	r8, r5
   197ae:	fb0e 3317 	mls	r3, lr, r7, r3
   197b2:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   197b6:	fb07 f308 	mul.w	r3, r7, r8
   197ba:	428b      	cmp	r3, r1
   197bc:	fa04 f402 	lsl.w	r4, r4, r2
   197c0:	d907      	bls.n	197d2 <__udivmoddi4+0x256>
   197c2:	1869      	adds	r1, r5, r1
   197c4:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   197c8:	d22f      	bcs.n	1982a <__udivmoddi4+0x2ae>
   197ca:	428b      	cmp	r3, r1
   197cc:	d92d      	bls.n	1982a <__udivmoddi4+0x2ae>
   197ce:	3f02      	subs	r7, #2
   197d0:	4429      	add	r1, r5
   197d2:	1acb      	subs	r3, r1, r3
   197d4:	b281      	uxth	r1, r0
   197d6:	fbb3 f0fe 	udiv	r0, r3, lr
   197da:	fb0e 3310 	mls	r3, lr, r0, r3
   197de:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   197e2:	fb00 f308 	mul.w	r3, r0, r8
   197e6:	428b      	cmp	r3, r1
   197e8:	d907      	bls.n	197fa <__udivmoddi4+0x27e>
   197ea:	1869      	adds	r1, r5, r1
   197ec:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   197f0:	d217      	bcs.n	19822 <__udivmoddi4+0x2a6>
   197f2:	428b      	cmp	r3, r1
   197f4:	d915      	bls.n	19822 <__udivmoddi4+0x2a6>
   197f6:	3802      	subs	r0, #2
   197f8:	4429      	add	r1, r5
   197fa:	1ac9      	subs	r1, r1, r3
   197fc:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   19800:	e73b      	b.n	1967a <__udivmoddi4+0xfe>
   19802:	4637      	mov	r7, r6
   19804:	4630      	mov	r0, r6
   19806:	e709      	b.n	1961c <__udivmoddi4+0xa0>
   19808:	4607      	mov	r7, r0
   1980a:	e6e7      	b.n	195dc <__udivmoddi4+0x60>
   1980c:	4618      	mov	r0, r3
   1980e:	e6fb      	b.n	19608 <__udivmoddi4+0x8c>
   19810:	4541      	cmp	r1, r8
   19812:	d2ab      	bcs.n	1976c <__udivmoddi4+0x1f0>
   19814:	ebb8 0a02 	subs.w	sl, r8, r2
   19818:	eb69 020e 	sbc.w	r2, r9, lr
   1981c:	3801      	subs	r0, #1
   1981e:	4613      	mov	r3, r2
   19820:	e7a4      	b.n	1976c <__udivmoddi4+0x1f0>
   19822:	4660      	mov	r0, ip
   19824:	e7e9      	b.n	197fa <__udivmoddi4+0x27e>
   19826:	4618      	mov	r0, r3
   19828:	e795      	b.n	19756 <__udivmoddi4+0x1da>
   1982a:	4667      	mov	r7, ip
   1982c:	e7d1      	b.n	197d2 <__udivmoddi4+0x256>
   1982e:	4681      	mov	r9, r0
   19830:	e77c      	b.n	1972c <__udivmoddi4+0x1b0>
   19832:	3802      	subs	r0, #2
   19834:	442c      	add	r4, r5
   19836:	e747      	b.n	196c8 <__udivmoddi4+0x14c>
   19838:	f1ac 0c02 	sub.w	ip, ip, #2
   1983c:	442b      	add	r3, r5
   1983e:	e72f      	b.n	196a0 <__udivmoddi4+0x124>
   19840:	4638      	mov	r0, r7
   19842:	e708      	b.n	19656 <__udivmoddi4+0xda>
   19844:	4637      	mov	r7, r6
   19846:	e6e9      	b.n	1961c <__udivmoddi4+0xa0>

00019848 <__aeabi_idiv0>:
   19848:	4770      	bx	lr
   1984a:	bf00      	nop

0001984c <abort>:
   1984c:	b508      	push	{r3, lr}
   1984e:	2006      	movs	r0, #6
   19850:	f000 f92c 	bl	19aac <raise>
   19854:	2001      	movs	r0, #1
   19856:	f7fb fe4b 	bl	154f0 <_exit>
   1985a:	Address 0x000000000001985a is out of bounds.


0001985c <__libc_init_array>:
   1985c:	b570      	push	{r4, r5, r6, lr}
   1985e:	4e0d      	ldr	r6, [pc, #52]	; (19894 <__libc_init_array+0x38>)
   19860:	4c0d      	ldr	r4, [pc, #52]	; (19898 <__libc_init_array+0x3c>)
   19862:	1ba4      	subs	r4, r4, r6
   19864:	10a4      	asrs	r4, r4, #2
   19866:	2500      	movs	r5, #0
   19868:	42a5      	cmp	r5, r4
   1986a:	d109      	bne.n	19880 <__libc_init_array+0x24>
   1986c:	4e0b      	ldr	r6, [pc, #44]	; (1989c <__libc_init_array+0x40>)
   1986e:	4c0c      	ldr	r4, [pc, #48]	; (198a0 <__libc_init_array+0x44>)
   19870:	f7f6 fd46 	bl	10300 <_init>
   19874:	1ba4      	subs	r4, r4, r6
   19876:	10a4      	asrs	r4, r4, #2
   19878:	2500      	movs	r5, #0
   1987a:	42a5      	cmp	r5, r4
   1987c:	d105      	bne.n	1988a <__libc_init_array+0x2e>
   1987e:	bd70      	pop	{r4, r5, r6, pc}
   19880:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   19884:	4798      	blx	r3
   19886:	3501      	adds	r5, #1
   19888:	e7ee      	b.n	19868 <__libc_init_array+0xc>
   1988a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   1988e:	4798      	blx	r3
   19890:	3501      	adds	r5, #1
   19892:	e7f2      	b.n	1987a <__libc_init_array+0x1e>
   19894:	0001030c 	.word	0x0001030c
   19898:	0001030c 	.word	0x0001030c
   1989c:	0001030c 	.word	0x0001030c
   198a0:	00010320 	.word	0x00010320

000198a4 <malloc>:
   198a4:	4b02      	ldr	r3, [pc, #8]	; (198b0 <malloc+0xc>)
   198a6:	4601      	mov	r1, r0
   198a8:	6818      	ldr	r0, [r3, #0]
   198aa:	f000 b86d 	b.w	19988 <_malloc_r>
   198ae:	bf00      	nop
   198b0:	100008e8 	.word	0x100008e8

000198b4 <free>:
   198b4:	4b02      	ldr	r3, [pc, #8]	; (198c0 <free+0xc>)
   198b6:	4601      	mov	r1, r0
   198b8:	6818      	ldr	r0, [r3, #0]
   198ba:	f000 b817 	b.w	198ec <_free_r>
   198be:	bf00      	nop
   198c0:	100008e8 	.word	0x100008e8

000198c4 <memcpy>:
   198c4:	b510      	push	{r4, lr}
   198c6:	1e43      	subs	r3, r0, #1
   198c8:	440a      	add	r2, r1
   198ca:	4291      	cmp	r1, r2
   198cc:	d100      	bne.n	198d0 <memcpy+0xc>
   198ce:	bd10      	pop	{r4, pc}
   198d0:	f811 4b01 	ldrb.w	r4, [r1], #1
   198d4:	f803 4f01 	strb.w	r4, [r3, #1]!
   198d8:	e7f7      	b.n	198ca <memcpy+0x6>

000198da <memset>:
   198da:	4402      	add	r2, r0
   198dc:	4603      	mov	r3, r0
   198de:	4293      	cmp	r3, r2
   198e0:	d100      	bne.n	198e4 <memset+0xa>
   198e2:	4770      	bx	lr
   198e4:	f803 1b01 	strb.w	r1, [r3], #1
   198e8:	e7f9      	b.n	198de <memset+0x4>
   198ea:	Address 0x00000000000198ea is out of bounds.


000198ec <_free_r>:
   198ec:	b538      	push	{r3, r4, r5, lr}
   198ee:	4605      	mov	r5, r0
   198f0:	2900      	cmp	r1, #0
   198f2:	d045      	beq.n	19980 <_free_r+0x94>
   198f4:	f851 3c04 	ldr.w	r3, [r1, #-4]
   198f8:	1f0c      	subs	r4, r1, #4
   198fa:	2b00      	cmp	r3, #0
   198fc:	bfb8      	it	lt
   198fe:	18e4      	addlt	r4, r4, r3
   19900:	f000 f8f0 	bl	19ae4 <__malloc_lock>
   19904:	4a1f      	ldr	r2, [pc, #124]	; (19984 <_free_r+0x98>)
   19906:	6813      	ldr	r3, [r2, #0]
   19908:	4610      	mov	r0, r2
   1990a:	b933      	cbnz	r3, 1991a <_free_r+0x2e>
   1990c:	6063      	str	r3, [r4, #4]
   1990e:	6014      	str	r4, [r2, #0]
   19910:	4628      	mov	r0, r5
   19912:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   19916:	f000 b8e6 	b.w	19ae6 <__malloc_unlock>
   1991a:	42a3      	cmp	r3, r4
   1991c:	d90c      	bls.n	19938 <_free_r+0x4c>
   1991e:	6821      	ldr	r1, [r4, #0]
   19920:	1862      	adds	r2, r4, r1
   19922:	4293      	cmp	r3, r2
   19924:	bf04      	itt	eq
   19926:	681a      	ldreq	r2, [r3, #0]
   19928:	685b      	ldreq	r3, [r3, #4]
   1992a:	6063      	str	r3, [r4, #4]
   1992c:	bf04      	itt	eq
   1992e:	1852      	addeq	r2, r2, r1
   19930:	6022      	streq	r2, [r4, #0]
   19932:	6004      	str	r4, [r0, #0]
   19934:	e7ec      	b.n	19910 <_free_r+0x24>
   19936:	4613      	mov	r3, r2
   19938:	685a      	ldr	r2, [r3, #4]
   1993a:	b10a      	cbz	r2, 19940 <_free_r+0x54>
   1993c:	42a2      	cmp	r2, r4
   1993e:	d9fa      	bls.n	19936 <_free_r+0x4a>
   19940:	6819      	ldr	r1, [r3, #0]
   19942:	1858      	adds	r0, r3, r1
   19944:	42a0      	cmp	r0, r4
   19946:	d10b      	bne.n	19960 <_free_r+0x74>
   19948:	6820      	ldr	r0, [r4, #0]
   1994a:	4401      	add	r1, r0
   1994c:	1858      	adds	r0, r3, r1
   1994e:	4282      	cmp	r2, r0
   19950:	6019      	str	r1, [r3, #0]
   19952:	d1dd      	bne.n	19910 <_free_r+0x24>
   19954:	6810      	ldr	r0, [r2, #0]
   19956:	6852      	ldr	r2, [r2, #4]
   19958:	605a      	str	r2, [r3, #4]
   1995a:	4401      	add	r1, r0
   1995c:	6019      	str	r1, [r3, #0]
   1995e:	e7d7      	b.n	19910 <_free_r+0x24>
   19960:	d902      	bls.n	19968 <_free_r+0x7c>
   19962:	230c      	movs	r3, #12
   19964:	602b      	str	r3, [r5, #0]
   19966:	e7d3      	b.n	19910 <_free_r+0x24>
   19968:	6820      	ldr	r0, [r4, #0]
   1996a:	1821      	adds	r1, r4, r0
   1996c:	428a      	cmp	r2, r1
   1996e:	bf04      	itt	eq
   19970:	6811      	ldreq	r1, [r2, #0]
   19972:	6852      	ldreq	r2, [r2, #4]
   19974:	6062      	str	r2, [r4, #4]
   19976:	bf04      	itt	eq
   19978:	1809      	addeq	r1, r1, r0
   1997a:	6021      	streq	r1, [r4, #0]
   1997c:	605c      	str	r4, [r3, #4]
   1997e:	e7c7      	b.n	19910 <_free_r+0x24>
   19980:	bd38      	pop	{r3, r4, r5, pc}
   19982:	bf00      	nop
   19984:	100016c4 	.word	0x100016c4

00019988 <_malloc_r>:
   19988:	b570      	push	{r4, r5, r6, lr}
   1998a:	1ccd      	adds	r5, r1, #3
   1998c:	f025 0503 	bic.w	r5, r5, #3
   19990:	3508      	adds	r5, #8
   19992:	2d0c      	cmp	r5, #12
   19994:	bf38      	it	cc
   19996:	250c      	movcc	r5, #12
   19998:	2d00      	cmp	r5, #0
   1999a:	4606      	mov	r6, r0
   1999c:	db01      	blt.n	199a2 <_malloc_r+0x1a>
   1999e:	42a9      	cmp	r1, r5
   199a0:	d903      	bls.n	199aa <_malloc_r+0x22>
   199a2:	230c      	movs	r3, #12
   199a4:	6033      	str	r3, [r6, #0]
   199a6:	2000      	movs	r0, #0
   199a8:	bd70      	pop	{r4, r5, r6, pc}
   199aa:	f000 f89b 	bl	19ae4 <__malloc_lock>
   199ae:	4a21      	ldr	r2, [pc, #132]	; (19a34 <_malloc_r+0xac>)
   199b0:	6814      	ldr	r4, [r2, #0]
   199b2:	4621      	mov	r1, r4
   199b4:	b991      	cbnz	r1, 199dc <_malloc_r+0x54>
   199b6:	4c20      	ldr	r4, [pc, #128]	; (19a38 <_malloc_r+0xb0>)
   199b8:	6823      	ldr	r3, [r4, #0]
   199ba:	b91b      	cbnz	r3, 199c4 <_malloc_r+0x3c>
   199bc:	4630      	mov	r0, r6
   199be:	f000 f83d 	bl	19a3c <_sbrk_r>
   199c2:	6020      	str	r0, [r4, #0]
   199c4:	4629      	mov	r1, r5
   199c6:	4630      	mov	r0, r6
   199c8:	f000 f838 	bl	19a3c <_sbrk_r>
   199cc:	1c43      	adds	r3, r0, #1
   199ce:	d124      	bne.n	19a1a <_malloc_r+0x92>
   199d0:	230c      	movs	r3, #12
   199d2:	6033      	str	r3, [r6, #0]
   199d4:	4630      	mov	r0, r6
   199d6:	f000 f886 	bl	19ae6 <__malloc_unlock>
   199da:	e7e4      	b.n	199a6 <_malloc_r+0x1e>
   199dc:	680b      	ldr	r3, [r1, #0]
   199de:	1b5b      	subs	r3, r3, r5
   199e0:	d418      	bmi.n	19a14 <_malloc_r+0x8c>
   199e2:	2b0b      	cmp	r3, #11
   199e4:	d90f      	bls.n	19a06 <_malloc_r+0x7e>
   199e6:	600b      	str	r3, [r1, #0]
   199e8:	50cd      	str	r5, [r1, r3]
   199ea:	18cc      	adds	r4, r1, r3
   199ec:	4630      	mov	r0, r6
   199ee:	f000 f87a 	bl	19ae6 <__malloc_unlock>
   199f2:	f104 000b 	add.w	r0, r4, #11
   199f6:	1d23      	adds	r3, r4, #4
   199f8:	f020 0007 	bic.w	r0, r0, #7
   199fc:	1ac3      	subs	r3, r0, r3
   199fe:	d0d3      	beq.n	199a8 <_malloc_r+0x20>
   19a00:	425a      	negs	r2, r3
   19a02:	50e2      	str	r2, [r4, r3]
   19a04:	e7d0      	b.n	199a8 <_malloc_r+0x20>
   19a06:	428c      	cmp	r4, r1
   19a08:	684b      	ldr	r3, [r1, #4]
   19a0a:	bf16      	itet	ne
   19a0c:	6063      	strne	r3, [r4, #4]
   19a0e:	6013      	streq	r3, [r2, #0]
   19a10:	460c      	movne	r4, r1
   19a12:	e7eb      	b.n	199ec <_malloc_r+0x64>
   19a14:	460c      	mov	r4, r1
   19a16:	6849      	ldr	r1, [r1, #4]
   19a18:	e7cc      	b.n	199b4 <_malloc_r+0x2c>
   19a1a:	1cc4      	adds	r4, r0, #3
   19a1c:	f024 0403 	bic.w	r4, r4, #3
   19a20:	42a0      	cmp	r0, r4
   19a22:	d005      	beq.n	19a30 <_malloc_r+0xa8>
   19a24:	1a21      	subs	r1, r4, r0
   19a26:	4630      	mov	r0, r6
   19a28:	f000 f808 	bl	19a3c <_sbrk_r>
   19a2c:	3001      	adds	r0, #1
   19a2e:	d0cf      	beq.n	199d0 <_malloc_r+0x48>
   19a30:	6025      	str	r5, [r4, #0]
   19a32:	e7db      	b.n	199ec <_malloc_r+0x64>
   19a34:	100016c4 	.word	0x100016c4
   19a38:	100016c8 	.word	0x100016c8

00019a3c <_sbrk_r>:
   19a3c:	b538      	push	{r3, r4, r5, lr}
   19a3e:	4c06      	ldr	r4, [pc, #24]	; (19a58 <_sbrk_r+0x1c>)
   19a40:	2300      	movs	r3, #0
   19a42:	4605      	mov	r5, r0
   19a44:	4608      	mov	r0, r1
   19a46:	6023      	str	r3, [r4, #0]
   19a48:	f7fb fd88 	bl	1555c <_sbrk>
   19a4c:	1c43      	adds	r3, r0, #1
   19a4e:	d102      	bne.n	19a56 <_sbrk_r+0x1a>
   19a50:	6823      	ldr	r3, [r4, #0]
   19a52:	b103      	cbz	r3, 19a56 <_sbrk_r+0x1a>
   19a54:	602b      	str	r3, [r5, #0]
   19a56:	bd38      	pop	{r3, r4, r5, pc}
   19a58:	100016cc 	.word	0x100016cc

00019a5c <_raise_r>:
   19a5c:	291f      	cmp	r1, #31
   19a5e:	b538      	push	{r3, r4, r5, lr}
   19a60:	4604      	mov	r4, r0
   19a62:	460d      	mov	r5, r1
   19a64:	d904      	bls.n	19a70 <_raise_r+0x14>
   19a66:	2316      	movs	r3, #22
   19a68:	6003      	str	r3, [r0, #0]
   19a6a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   19a6e:	bd38      	pop	{r3, r4, r5, pc}
   19a70:	6c42      	ldr	r2, [r0, #68]	; 0x44
   19a72:	b112      	cbz	r2, 19a7a <_raise_r+0x1e>
   19a74:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   19a78:	b94b      	cbnz	r3, 19a8e <_raise_r+0x32>
   19a7a:	4620      	mov	r0, r4
   19a7c:	f000 f830 	bl	19ae0 <_getpid_r>
   19a80:	462a      	mov	r2, r5
   19a82:	4601      	mov	r1, r0
   19a84:	4620      	mov	r0, r4
   19a86:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   19a8a:	f000 b817 	b.w	19abc <_kill_r>
   19a8e:	2b01      	cmp	r3, #1
   19a90:	d00a      	beq.n	19aa8 <_raise_r+0x4c>
   19a92:	1c59      	adds	r1, r3, #1
   19a94:	d103      	bne.n	19a9e <_raise_r+0x42>
   19a96:	2316      	movs	r3, #22
   19a98:	6003      	str	r3, [r0, #0]
   19a9a:	2001      	movs	r0, #1
   19a9c:	e7e7      	b.n	19a6e <_raise_r+0x12>
   19a9e:	2400      	movs	r4, #0
   19aa0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   19aa4:	4628      	mov	r0, r5
   19aa6:	4798      	blx	r3
   19aa8:	2000      	movs	r0, #0
   19aaa:	e7e0      	b.n	19a6e <_raise_r+0x12>

00019aac <raise>:
   19aac:	4b02      	ldr	r3, [pc, #8]	; (19ab8 <raise+0xc>)
   19aae:	4601      	mov	r1, r0
   19ab0:	6818      	ldr	r0, [r3, #0]
   19ab2:	f7ff bfd3 	b.w	19a5c <_raise_r>
   19ab6:	bf00      	nop
   19ab8:	100008e8 	.word	0x100008e8

00019abc <_kill_r>:
   19abc:	b538      	push	{r3, r4, r5, lr}
   19abe:	4c07      	ldr	r4, [pc, #28]	; (19adc <_kill_r+0x20>)
   19ac0:	2300      	movs	r3, #0
   19ac2:	4605      	mov	r5, r0
   19ac4:	4608      	mov	r0, r1
   19ac6:	4611      	mov	r1, r2
   19ac8:	6023      	str	r3, [r4, #0]
   19aca:	f7fb fd2f 	bl	1552c <_kill>
   19ace:	1c43      	adds	r3, r0, #1
   19ad0:	d102      	bne.n	19ad8 <_kill_r+0x1c>
   19ad2:	6823      	ldr	r3, [r4, #0]
   19ad4:	b103      	cbz	r3, 19ad8 <_kill_r+0x1c>
   19ad6:	602b      	str	r3, [r5, #0]
   19ad8:	bd38      	pop	{r3, r4, r5, pc}
   19ada:	bf00      	nop
   19adc:	100016cc 	.word	0x100016cc

00019ae0 <_getpid_r>:
   19ae0:	f7fb bd12 	b.w	15508 <_getpid>

00019ae4 <__malloc_lock>:
   19ae4:	4770      	bx	lr

00019ae6 <__malloc_unlock>:
   19ae6:	4770      	bx	lr
   19ae8:	63617453 	.word	0x63617453
   19aec:	6544206b 	.word	0x6544206b
   19af0:	20687470 	.word	0x20687470
   19af4:	7a25203d 	.word	0x7a25203d
   19af8:	00000a64 	.word	0x00000a64
   19afc:	25232020 	.word	0x25232020
   19b00:	203a757a 	.word	0x203a757a
   19b04:	70257830 	.word	0x70257830
   19b08:	0000000a 	.word	0x0000000a
   19b0c:	6e75520a 	.word	0x6e75520a
   19b10:	6874203a 	.word	0x6874203a
   19b14:	6f662065 	.word	0x6f662065
   19b18:	776f6c6c 	.word	0x776f6c6c
   19b1c:	20676e69 	.word	0x20676e69
   19b20:	6d6d6f63 	.word	0x6d6d6f63
   19b24:	20646e61 	.word	0x20646e61
   19b28:	79206e69 	.word	0x79206e69
   19b2c:	2072756f 	.word	0x2072756f
   19b30:	6a6f7270 	.word	0x6a6f7270
   19b34:	20746365 	.word	0x20746365
   19b38:	65726964 	.word	0x65726964
   19b3c:	726f7463 	.word	0x726f7463
   19b40:	00000079 	.word	0x00000079
   19b44:	1b20200a 	.word	0x1b20200a
   19b48:	333b315b 	.word	0x333b315b
   19b4c:	616d6d37 	.word	0x616d6d37
   19b50:	7320656b 	.word	0x7320656b
   19b54:	6b636174 	.word	0x6b636174
   19b58:	63617274 	.word	0x63617274
   19b5c:	73252d65 	.word	0x73252d65
   19b60:	41525420 	.word	0x41525420
   19b64:	3d534543 	.word	0x3d534543
   19b68:	00000022 	.word	0x00000022
   19b6c:	70257830 	.word	0x70257830
   19b70:	00000000 	.word	0x00000000
   19b74:	25783020 	.word	0x25783020
   19b78:	00000070 	.word	0x00000070
   19b7c:	5b1b0a22 	.word	0x5b1b0a22
   19b80:	00006d30 	.word	0x00006d30
   19b84:	73696854 	.word	0x73696854
   19b88:	6c697720 	.word	0x6c697720
   19b8c:	6572206c 	.word	0x6572206c
   19b90:	74726f70 	.word	0x74726f70
   19b94:	65687420 	.word	0x65687420
   19b98:	6c696620 	.word	0x6c696620
   19b9c:	6e612065 	.word	0x6e612065
   19ba0:	696c2064 	.word	0x696c2064
   19ba4:	6e20656e 	.word	0x6e20656e
   19ba8:	65626d75 	.word	0x65626d75
   19bac:	68742072 	.word	0x68742072
   19bb0:	6c207461 	.word	0x6c207461
   19bb4:	74206465 	.word	0x74206465
   19bb8:	6874206f 	.word	0x6874206f
   19bbc:	66207369 	.word	0x66207369
   19bc0:	74636e75 	.word	0x74636e75
   19bc4:	206e6f69 	.word	0x206e6f69
   19bc8:	6e696562 	.word	0x6e696562
   19bcc:	61632067 	.word	0x61632067
   19bd0:	64656c6c 	.word	0x64656c6c
   19bd4:	0000002e 	.word	0x0000002e
   19bd8:	6c707061 	.word	0x6c707061
   19bdc:	74616369 	.word	0x74616369
   19be0:	006e6f69 	.word	0x006e6f69
   19be4:	33345b1b 	.word	0x33345b1b
   19be8:	4157206d 	.word	0x4157206d
   19bec:	4e494e52 	.word	0x4e494e52
   19bf0:	305b1b47 	.word	0x305b1b47
   19bf4:	6d34393b 	.word	0x6d34393b
   19bf8:	3a73253a 	.word	0x3a73253a
   19bfc:	3b305b1b 	.word	0x3b305b1b
   19c00:	256d3239 	.word	0x256d3239
   19c04:	5b1b3a73 	.word	0x5b1b3a73
   19c08:	33393b30 	.word	0x33393b30
   19c0c:	3e64256d 	.word	0x3e64256d
   19c10:	305b1b20 	.word	0x305b1b20
   19c14:	6d37333b 	.word	0x6d37333b
   19c18:	74726f50 	.word	0x74726f50
   19c1c:	20642520 	.word	0x20642520
   19c20:	6e6e6163 	.word	0x6e6e6163
   19c24:	6220746f 	.word	0x6220746f
   19c28:	73752065 	.word	0x73752065
   19c2c:	66206465 	.word	0x66206465
   19c30:	4520726f 	.word	0x4520726f
   19c34:	72657478 	.word	0x72657478
   19c38:	206c616e 	.word	0x206c616e
   19c3c:	65746e49 	.word	0x65746e49
   19c40:	70757272 	.word	0x70757272
   19c44:	202e7374 	.word	0x202e7374
   19c48:	6465654e 	.word	0x6465654e
   19c4c:	206f7420 	.word	0x206f7420
   19c50:	20657375 	.word	0x20657375
   19c54:	4f495047 	.word	0x4f495047
   19c58:	206e6f20 	.word	0x206e6f20
   19c5c:	74726f50 	.word	0x74726f50
   19c60:	6f203020 	.word	0x6f203020
   19c64:	2e322072 	.word	0x2e322072
   19c68:	6d305b1b 	.word	0x6d305b1b
   19c6c:	6d305b1b 	.word	0x6d305b1b
   19c70:	0000000a 	.word	0x0000000a
   19c74:	33345b1b 	.word	0x33345b1b
   19c78:	4157206d 	.word	0x4157206d
   19c7c:	4e494e52 	.word	0x4e494e52
   19c80:	305b1b47 	.word	0x305b1b47
   19c84:	6d34393b 	.word	0x6d34393b
   19c88:	3a73253a 	.word	0x3a73253a
   19c8c:	3b305b1b 	.word	0x3b305b1b
   19c90:	256d3239 	.word	0x256d3239
   19c94:	5b1b3a73 	.word	0x5b1b3a73
   19c98:	33393b30 	.word	0x33393b30
   19c9c:	3e64256d 	.word	0x3e64256d
   19ca0:	305b1b20 	.word	0x305b1b20
   19ca4:	6d37333b 	.word	0x6d37333b
   19ca8:	65676445 	.word	0x65676445
   19cac:	20642520 	.word	0x20642520
   19cb0:	6e6e6163 	.word	0x6e6e6163
   19cb4:	6220746f 	.word	0x6220746f
   19cb8:	73752065 	.word	0x73752065
   19cbc:	66206465 	.word	0x66206465
   19cc0:	4520726f 	.word	0x4520726f
   19cc4:	72657478 	.word	0x72657478
   19cc8:	206c616e 	.word	0x206c616e
   19ccc:	65746e49 	.word	0x65746e49
   19cd0:	70757272 	.word	0x70757272
   19cd4:	4e2e7374 	.word	0x4e2e7374
   19cd8:	20646565 	.word	0x20646565
   19cdc:	75206f74 	.word	0x75206f74
   19ce0:	61206573 	.word	0x61206573
   19ce4:	73697220 	.word	0x73697220
   19ce8:	2c676e69 	.word	0x2c676e69
   19cec:	6c616620 	.word	0x6c616620
   19cf0:	676e696c 	.word	0x676e696c
   19cf4:	726f202c 	.word	0x726f202c
   19cf8:	746f6220 	.word	0x746f6220
   19cfc:	6f632068 	.word	0x6f632068
   19d00:	6769666e 	.word	0x6769666e
   19d04:	74617275 	.word	0x74617275
   19d08:	2e6e6f69 	.word	0x2e6e6f69
   19d0c:	6d305b1b 	.word	0x6d305b1b
   19d10:	0000000a 	.word	0x0000000a
   19d14:	31345b1b 	.word	0x31345b1b
   19d18:	4952436d 	.word	0x4952436d
   19d1c:	41434954 	.word	0x41434954
   19d20:	305b1b4c 	.word	0x305b1b4c
   19d24:	6d34393b 	.word	0x6d34393b
   19d28:	3a73253a 	.word	0x3a73253a
   19d2c:	3b305b1b 	.word	0x3b305b1b
   19d30:	256d3239 	.word	0x256d3239
   19d34:	5b1b3a73 	.word	0x5b1b3a73
   19d38:	33393b30 	.word	0x33393b30
   19d3c:	3e64256d 	.word	0x3e64256d
   19d40:	305b1b20 	.word	0x305b1b20
   19d44:	6d37333b 	.word	0x6d37333b
   19d48:	65737341 	.word	0x65737341
   19d4c:	6f697472 	.word	0x6f697472
   19d50:	6146206e 	.word	0x6146206e
   19d54:	72756c69 	.word	0x72756c69
   19d58:	43202c65 	.word	0x43202c65
   19d5c:	69646e6f 	.word	0x69646e6f
   19d60:	6e6f6974 	.word	0x6e6f6974
   19d64:	73655420 	.word	0x73655420
   19d68:	3a646574 	.word	0x3a646574
   19d6c:	65702820 	.word	0x65702820
   19d70:	68706972 	.word	0x68706972
   19d74:	6c617265 	.word	0x6c617265
   19d78:	7669645f 	.word	0x7669645f
   19d7c:	72656469 	.word	0x72656469
   19d80:	203d3c20 	.word	0x203d3c20
   19d84:	200a2934 	.word	0x200a2934
   19d88:	20202020 	.word	0x20202020
   19d8c:	20202020 	.word	0x20202020
   19d90:	76694420 	.word	0x76694420
   19d94:	72656469 	.word	0x72656469
   19d98:	73756d20 	.word	0x73756d20
   19d9c:	74276e74 	.word	0x74276e74
   19da0:	63786520 	.word	0x63786520
   19da4:	20646565 	.word	0x20646565
   19da8:	5b1b3233 	.word	0x5b1b3233
   19dac:	5b1b6d30 	.word	0x5b1b6d30
   19db0:	000a6d30 	.word	0x000a6d30
   19db4:	6972500a 	.word	0x6972500a
   19db8:	6e69746e 	.word	0x6e69746e
   19dbc:	74532067 	.word	0x74532067
   19dc0:	206b6361 	.word	0x206b6361
   19dc4:	63617254 	.word	0x63617254
   19dc8:	000a3a65 	.word	0x000a3a65
   19dcc:	31345b1b 	.word	0x31345b1b
   19dd0:	4952436d 	.word	0x4952436d
   19dd4:	41434954 	.word	0x41434954
   19dd8:	305b1b4c 	.word	0x305b1b4c
   19ddc:	6d34393b 	.word	0x6d34393b
   19de0:	3a73253a 	.word	0x3a73253a
   19de4:	3b305b1b 	.word	0x3b305b1b
   19de8:	256d3239 	.word	0x256d3239
   19dec:	5b1b3a73 	.word	0x5b1b3a73
   19df0:	33393b30 	.word	0x33393b30
   19df4:	3e64256d 	.word	0x3e64256d
   19df8:	305b1b20 	.word	0x305b1b20
   19dfc:	6d37333b 	.word	0x6d37333b
   19e00:	65737341 	.word	0x65737341
   19e04:	6f697472 	.word	0x6f697472
   19e08:	6146206e 	.word	0x6146206e
   19e0c:	72756c69 	.word	0x72756c69
   19e10:	43202c65 	.word	0x43202c65
   19e14:	69646e6f 	.word	0x69646e6f
   19e18:	6e6f6974 	.word	0x6e6f6974
   19e1c:	73655420 	.word	0x73655420
   19e20:	3a646574 	.word	0x3a646574
   19e24:	65642820 	.word	0x65642820
   19e28:	65726973 	.word	0x65726973
   19e2c:	70735f64 	.word	0x70735f64
   19e30:	5f646565 	.word	0x5f646565
   19e34:	6d5f6e69 	.word	0x6d5f6e69
   19e38:	3c207a68 	.word	0x3c207a68
   19e3c:	34383320 	.word	0x34383320
   19e40:	20262620 	.word	0x20262620
   19e44:	69736564 	.word	0x69736564
   19e48:	5f646572 	.word	0x5f646572
   19e4c:	65657073 	.word	0x65657073
   19e50:	6e695f64 	.word	0x6e695f64
   19e54:	7a686d5f 	.word	0x7a686d5f
   19e58:	31203e20 	.word	0x31203e20
   19e5c:	200a2932 	.word	0x200a2932
   19e60:	20202020 	.word	0x20202020
   19e64:	20202020 	.word	0x20202020
   19e68:	65724620 	.word	0x65724620
   19e6c:	6e657571 	.word	0x6e657571
   19e70:	6d207963 	.word	0x6d207963
   19e74:	20747375 	.word	0x20747375
   19e78:	6c206562 	.word	0x6c206562
   19e7c:	7265776f 	.word	0x7265776f
   19e80:	61687420 	.word	0x61687420
   19e84:	3833206e 	.word	0x3833206e
   19e88:	484d2034 	.word	0x484d2034
   19e8c:	646e617a 	.word	0x646e617a
   19e90:	65726720 	.word	0x65726720
   19e94:	72657461 	.word	0x72657461
   19e98:	61687420 	.word	0x61687420
   19e9c:	726f206e 	.word	0x726f206e
   19ea0:	75716520 	.word	0x75716520
   19ea4:	74206c61 	.word	0x74206c61
   19ea8:	3231206f 	.word	0x3231206f
   19eac:	7a484d20 	.word	0x7a484d20
   19eb0:	6d305b1b 	.word	0x6d305b1b
   19eb4:	6d305b1b 	.word	0x6d305b1b
   19eb8:	0000000a 	.word	0x0000000a
   19ebc:	31345b1b 	.word	0x31345b1b
   19ec0:	4952436d 	.word	0x4952436d
   19ec4:	41434954 	.word	0x41434954
   19ec8:	305b1b4c 	.word	0x305b1b4c
   19ecc:	6d34393b 	.word	0x6d34393b
   19ed0:	3a73253a 	.word	0x3a73253a
   19ed4:	3b305b1b 	.word	0x3b305b1b
   19ed8:	256d3239 	.word	0x256d3239
   19edc:	5b1b3a73 	.word	0x5b1b3a73
   19ee0:	33393b30 	.word	0x33393b30
   19ee4:	3e64256d 	.word	0x3e64256d
   19ee8:	305b1b20 	.word	0x305b1b20
   19eec:	6d37333b 	.word	0x6d37333b
   19ef0:	65737341 	.word	0x65737341
   19ef4:	6f697472 	.word	0x6f697472
   19ef8:	6146206e 	.word	0x6146206e
   19efc:	72756c69 	.word	0x72756c69
   19f00:	43202c65 	.word	0x43202c65
   19f04:	69646e6f 	.word	0x69646e6f
   19f08:	6e6f6974 	.word	0x6e6f6974
   19f0c:	73655420 	.word	0x73655420
   19f10:	3a646574 	.word	0x3a646574
   19f14:	69642820 	.word	0x69642820
   19f18:	65646976 	.word	0x65646976
   19f1c:	61765f72 	.word	0x61765f72
   19f20:	2065756c 	.word	0x2065756c
   19f24:	2938203c 	.word	0x2938203c
   19f28:	2020200a 	.word	0x2020200a
   19f2c:	20202020 	.word	0x20202020
   19f30:	50202020 	.word	0x50202020
   19f34:	64204c4c 	.word	0x64204c4c
   19f38:	64697669 	.word	0x64697669
   19f3c:	76207265 	.word	0x76207265
   19f40:	65756c61 	.word	0x65756c61
   19f44:	6e657720 	.word	0x6e657720
   19f48:	756f2074 	.word	0x756f2074
   19f4c:	666f2074 	.word	0x666f2074
   19f50:	756f6220 	.word	0x756f6220
   19f54:	1b73646e 	.word	0x1b73646e
   19f58:	1b6d305b 	.word	0x1b6d305b
   19f5c:	0a6d305b 	.word	0x0a6d305b
   19f60:	00000000 	.word	0x00000000
   19f64:	31345b1b 	.word	0x31345b1b
   19f68:	4952436d 	.word	0x4952436d
   19f6c:	41434954 	.word	0x41434954
   19f70:	305b1b4c 	.word	0x305b1b4c
   19f74:	6d34393b 	.word	0x6d34393b
   19f78:	3a73253a 	.word	0x3a73253a
   19f7c:	3b305b1b 	.word	0x3b305b1b
   19f80:	256d3239 	.word	0x256d3239
   19f84:	5b1b3a73 	.word	0x5b1b3a73
   19f88:	33393b30 	.word	0x33393b30
   19f8c:	3e64256d 	.word	0x3e64256d
   19f90:	305b1b20 	.word	0x305b1b20
   19f94:	6d37333b 	.word	0x6d37333b
   19f98:	65737341 	.word	0x65737341
   19f9c:	6f697472 	.word	0x6f697472
   19fa0:	6146206e 	.word	0x6146206e
   19fa4:	72756c69 	.word	0x72756c69
   19fa8:	43202c65 	.word	0x43202c65
   19fac:	69646e6f 	.word	0x69646e6f
   19fb0:	6e6f6974 	.word	0x6e6f6974
   19fb4:	73655420 	.word	0x73655420
   19fb8:	3a646574 	.word	0x3a646574
   19fbc:	61662820 	.word	0x61662820
   19fc0:	2965736c 	.word	0x2965736c
   19fc4:	2020200a 	.word	0x2020200a
   19fc8:	20202020 	.word	0x20202020
   19fcc:	50202020 	.word	0x50202020
   19fd0:	6c204c4c 	.word	0x6c204c4c
   19fd4:	206b636f 	.word	0x206b636f
   19fd8:	6c756f63 	.word	0x6c756f63
   19fdc:	6f6e2064 	.word	0x6f6e2064
   19fe0:	65622074 	.word	0x65622074
   19fe4:	74736520 	.word	0x74736520
   19fe8:	696c6261 	.word	0x696c6261
   19fec:	64656873 	.word	0x64656873
   19ff0:	66656220 	.word	0x66656220
   19ff4:	2065726f 	.word	0x2065726f
   19ff8:	656d6974 	.word	0x656d6974
   19ffc:	1b74756f 	.word	0x1b74756f
   1a000:	1b6d305b 	.word	0x1b6d305b
   1a004:	0a6d305b 	.word	0x0a6d305b
   1a008:	00000000 	.word	0x00000000
   1a00c:	31345b1b 	.word	0x31345b1b
   1a010:	4952436d 	.word	0x4952436d
   1a014:	41434954 	.word	0x41434954
   1a018:	305b1b4c 	.word	0x305b1b4c
   1a01c:	6d34393b 	.word	0x6d34393b
   1a020:	3a73253a 	.word	0x3a73253a
   1a024:	3b305b1b 	.word	0x3b305b1b
   1a028:	256d3239 	.word	0x256d3239
   1a02c:	5b1b3a73 	.word	0x5b1b3a73
   1a030:	33393b30 	.word	0x33393b30
   1a034:	3e64256d 	.word	0x3e64256d
   1a038:	305b1b20 	.word	0x305b1b20
   1a03c:	6d37333b 	.word	0x6d37333b
   1a040:	65737341 	.word	0x65737341
   1a044:	6f697472 	.word	0x6f697472
   1a048:	6146206e 	.word	0x6146206e
   1a04c:	72756c69 	.word	0x72756c69
   1a050:	43202c65 	.word	0x43202c65
   1a054:	69646e6f 	.word	0x69646e6f
   1a058:	6e6f6974 	.word	0x6e6f6974
   1a05c:	73655420 	.word	0x73655420
   1a060:	3a646574 	.word	0x3a646574
   1a064:	70632820 	.word	0x70632820
   1a068:	69645f75 	.word	0x69645f75
   1a06c:	65646976 	.word	0x65646976
   1a070:	203c2072 	.word	0x203c2072
   1a074:	0a293233 	.word	0x0a293233
   1a078:	20202020 	.word	0x20202020
   1a07c:	20202020 	.word	0x20202020
   1a080:	69442020 	.word	0x69442020
   1a084:	65646976 	.word	0x65646976
   1a088:	756d2072 	.word	0x756d2072
   1a08c:	276e7473 	.word	0x276e7473
   1a090:	78652074 	.word	0x78652074
   1a094:	64656563 	.word	0x64656563
   1a098:	1b323320 	.word	0x1b323320
   1a09c:	1b6d305b 	.word	0x1b6d305b
   1a0a0:	0a6d305b 	.word	0x0a6d305b
   1a0a4:	00000000 	.word	0x00000000
   1a0a8:	61746144 	.word	0x61746144
   1a0ac:	63655220 	.word	0x63655220
   1a0b0:	65766965 	.word	0x65766965
   1a0b4:	25203a64 	.word	0x25203a64
   1a0b8:	00000a69 	.word	0x00000a69
   1a0bc:	75736552 	.word	0x75736552
   1a0c0:	203a746c 	.word	0x203a746c
   1a0c4:	000a6925 	.word	0x000a6925

0001a0c8 <Gpio::ValidPortCheck()::file>:
   1a0c8:	6f697067 7070682e ffffff00              gpio.hpp....

0001a0d4 <Gpio::SetInterruptEdge(GpioInterface::Edge)::file>:
   1a0d4:	6f697067 7070682e ffffff00              gpio.hpp....

0001a0e0 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::file>:
   1a0e0:	6f697067 7070682e ffffff00              gpio.hpp....

0001a0ec <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file>:
   1a0ec:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1a0fc:	70682e72 ffff0070                       r.hpp...

0001a104 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1a104:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1a114:	70682e72 ffff0070                       r.hpp...

0001a11c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1a11c:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1a12c:	70682e72 ffff0070                       r.hpp...

0001a134 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1a134:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1a144:	70682e72 ffff0070                       r.hpp...

0001a14c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file>:
   1a14c:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   1a15c:	70682e72 ffff0070                       r.hpp...

0001a164 <Ssp::kPinSelect>:
   1a164:	ff040202                                ....

0001a168 <Ssp::kSspPinMatrix>:
   1a168:	0001a368 00001200 0001a368 00001100     h.......h.......
   1a178:	0001a368 00000f00 0001a368 00000900     h.......h.......
   1a188:	0001a368 00000800 0001a368 00000700     h.......h.......
   1a198:	0001a368 00000101 0001a368 00000401     h.......h.......
   1a1a8:	0001a368 00000001                       h.......

0001a1b0 <Ssp::kPowerBit>:
   1a1b0:	00000015 0000000a 00000014              ............

0001a1bc <vtable for Ssd1306>:
	...
   1a1c4:	00012811 0001283d 00012869 00012a51     .(..=(..i(..Q*..
   1a1d4:	000126d1 000126f9 00012b29 00012b61     .&...&..)+..a+..
   1a1e4:	00012bf5                                .+..

0001a1e8 <vtable for PixelDisplayInterface>:
	...
   1a1f0:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a200:	000126d1 000126f9 00019421 00019421     .&...&..!...!...
   1a210:	00012721                                !'..

0001a214 <vtable for Ssp>:
	...
   1a21c:	00011c45 00011d29 00011da1 00011e0d     E...)...........
   1a22c:	00011ef9 00012105 00012265 00012451     .....!..e"..Q$..
   1a23c:	fffffffc 00000000 000114e5 00011575     ............u...
   1a24c:	000115cd 000115e5 000115f9 00011639     ............9...
   1a25c:	00011669                                i...

0001a260 <vtable for SspInterface>:
	...
   1a268:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a278:	00019421 00019421 00019421 00019421     !...!...!...!...

0001a288 <vtable for Lpc40xxSystemController>:
	...
   1a290:	000114e5 00011575 000115cd 000115e5     ....u...........
   1a2a0:	000115f9 00011639 00011669              ....9...i...

0001a2ac <vtable for SystemControllerInterface>:
	...
   1a2b4:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a2c4:	00019421 00019421 00019421              !...!...!...

0001a2d0 <vtable for Gpio>:
	...
   1a2d8:	00010bfd 00010c79 00010cf5 00010d39     ....y.......9...
   1a2e8:	00010d9d 00010e01 00010e45 00010eb1     ........E.......
   1a2f8:	00010f29 00010f99 00011231 00011279     ).......1...y...
   1a308:	00011041 0001109d 00011121 000111a9     A.......!.......

0001a318 <vtable for GpioInterface>:
	...
   1a320:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a330:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a340:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a350:	00019421 00019421 00019421 00019421     !...!...!...!...

0001a360 <vtable for Pin>:
	...
   1a368:	000103f9 00010471 000104f1 00010565     ....q.......e...
   1a378:	000105d9 00010655 000106d1 00010745     ....U.......E...
   1a388:	000107c1 00010835 000108a9 00010981     ....5...........
   1a398:	000109ad                                ....

0001a39c <vtable for PinInterface>:
	...
   1a3a4:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a3b4:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a3c4:	00019421 00019421 00019421 00019421     !...!...!...!...
   1a3d4:	00019421                                !...

0001a3d8 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   1a3d8:	74726976 206c6175 64696f76 63704c20     virtual void Lpc
   1a3e8:	78783034 74737953 6f436d65 6f72746e     40xxSystemContro
   1a3f8:	72656c6c 65533a3a 72655074 65687069     ller::SetPeriphe
   1a408:	436c6172 6b636f6c 69766944 28726564     ralClockDivider(
   1a418:	746e6975 29745f38 ffffff00              uint8_t)....

0001a424 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   1a424:	746e6975 745f3233 63704c20 78783034     uint32_t Lpc40xx
   1a434:	74737953 6f436d65 6f72746e 72656c6c     SystemController
   1a444:	65533a3a 69614d74 6c6c506e 63704c28     ::SetMainPll(Lpc
   1a454:	78783034 74737953 6f436d65 6f72746e     40xxSystemContro
   1a464:	72656c6c 6c503a3a 706e496c 202c7475     ller::PllInput, 
   1a474:	746e6975 745f3631 ffff0029              uint16_t)...

0001a480 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   1a480:	746e6975 745f3233 63704c20 78783034     uint32_t Lpc40xx
   1a490:	74737953 6f436d65 6f72746e 72656c6c     SystemController
   1a4a0:	61433a3a 6c75636c 50657461 4c286c6c     ::CalculatePll(L
   1a4b0:	30346370 79537878 6d657473 746e6f43     pc40xxSystemCont
   1a4c0:	6c6c6f72 3a3a7265 496c6c50 7475706e     roller::PllInput
   1a4d0:	6975202c 3631746e 0029745f              , uint16_t).

0001a4dc <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   1a4dc:	64696f76 63704c20 78783034 74737953     void Lpc40xxSyst
   1a4ec:	6f436d65 6f72746e 72656c6c 65533a3a     emController::Se
   1a4fc:	75704374 636f6c43 7669446b 72656469     tCpuClockDivider
   1a50c:	6e697528 745f3874 ffff0029              (uint8_t)...

0001a518 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1a518:	74726976 206c6175 64696f76 69704720     virtual void Gpi
   1a528:	433a3a6f 7261656c 65746e49 70757272     o::ClearInterrup
   1a538:	67644574 70472865 6e496f69 66726574     tEdge(GpioInterf
   1a548:	3a656361 6764453a ff002965              ace::Edge)..

0001a554 <Gpio::ValidPortCheck()::__PRETTY_FUNCTION__>:
   1a554:	6c6f6f62 69704720 563a3a6f 64696c61     bool Gpio::Valid
   1a564:	74726f50 63656843 0029286b              PortCheck().

0001a570 <Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1a570:	74726976 206c6175 64696f76 69704720     virtual void Gpi
   1a580:	533a3a6f 6e497465 72726574 45747075     o::SetInterruptE
   1a590:	28656764 6f697047 65746e49 63616672     dge(GpioInterfac
   1a5a0:	453a3a65 29656764 ffffff00 63617453     e::Edge)....Stac
   1a5b0:	6544206b 20687470 7a25203d 00000a64     k Depth = %zd...
   1a5c0:	25232020 203a757a 70257830 0000000a       #%zu: 0x%p....
   1a5d0:	6e75520a 6874203a 6f662065 776f6c6c     .Run: the follow
   1a5e0:	20676e69 6d6d6f63 20646e61 79206e69     ing command in y
   1a5f0:	2072756f 6a6f7270 20746365 65726964     our project dire
   1a600:	726f7463 00000079 1b20200a 333b315b     ctory....  .[1;3
   1a610:	616d6d37 7320656b 6b636174 63617274     7mmake stacktrac
   1a620:	73252d65 41525420 3d534543 00000022     e-%s TRACES="...
   1a630:	70257830 00000000 25783020 00000070     0x%p.... 0x%p...
   1a640:	5b1b0a22 00006d30 73696854 6c697720     "..[0m..This wil
   1a650:	6572206c 74726f70 65687420 6c696620     l report the fil
   1a660:	6e612065 696c2064 6e20656e 65626d75     e and line numbe
   1a670:	68742072 6c207461 74206465 6874206f     r that led to th
   1a680:	66207369 74636e75 206e6f69 6e696562     is function bein
   1a690:	61632067 64656c6c 0000002e 6c707061     g called....appl
   1a6a0:	74616369 006e6f69 33345b1b 4157206d     ication..[43m WA
   1a6b0:	4e494e52 305b1b47 6d34393b 3a73253a     RNING.[0;94m:%s:
   1a6c0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a6d0:	3e64256d 305b1b20 6d37333b 74726f50     m%d> .[0;37mPort
   1a6e0:	20642520 6e6e6163 6220746f 73752065      %d cannot be us
   1a6f0:	66206465 4520726f 72657478 206c616e     ed for External 
   1a700:	65746e49 70757272 202e7374 6465654e     Interrupts. Need
   1a710:	206f7420 20657375 4f495047 206e6f20      to use GPIO on 
   1a720:	74726f50 6f203020 2e322072 6d305b1b     Port 0 or 2..[0m
   1a730:	6d305b1b 0000000a 33345b1b 4157206d     .[0m.....[43m WA
   1a740:	4e494e52 305b1b47 6d34393b 3a73253a     RNING.[0;94m:%s:
   1a750:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a760:	3e64256d 305b1b20 6d37333b 65676445     m%d> .[0;37mEdge
   1a770:	20642520 6e6e6163 6220746f 73752065      %d cannot be us
   1a780:	66206465 4520726f 72657478 206c616e     ed for External 
   1a790:	65746e49 70757272 4e2e7374 20646565     Interrupts.Need 
   1a7a0:	75206f74 61206573 73697220 2c676e69     to use a rising,
   1a7b0:	6c616620 676e696c 726f202c 746f6220      falling, or bot
   1a7c0:	6f632068 6769666e 74617275 2e6e6f69     h configuration.
   1a7d0:	6d305b1b 0000000a 31345b1b 4952436d     .[0m.....[41mCRI
   1a7e0:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1a7f0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a800:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1a810:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1a820:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1a830:	65702820 68706972 6c617265 7669645f      (peripheral_div
   1a840:	72656469 203d3c20 200a2934 20202020     ider <= 4).     
   1a850:	20202020 76694420 72656469 73756d20          Divider mus
   1a860:	74276e74 63786520 20646565 5b1b3233     tn't exceed 32.[
   1a870:	5b1b6d30 000a6d30 6972500a 6e69746e     0m.[0m...Printin
   1a880:	74532067 206b6361 63617254 000a3a65     g Stack Trace:..
   1a890:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1a8a0:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1a8b0:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1a8c0:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1a8d0:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1a8e0:	73655420 3a646574 65642820 65726973      Tested: (desire
   1a8f0:	70735f64 5f646565 6d5f6e69 3c207a68     d_speed_in_mhz <
   1a900:	34383320 20262620 69736564 5f646572      384 && desired_
   1a910:	65657073 6e695f64 7a686d5f 31203e20     speed_in_mhz > 1
   1a920:	200a2932 20202020 20202020 65724620     2).          Fre
   1a930:	6e657571 6d207963 20747375 6c206562     quency must be l
   1a940:	7265776f 61687420 3833206e 484d2034     ower than 384 MH
   1a950:	646e617a 65726720 72657461 61687420     zand greater tha
   1a960:	726f206e 75716520 74206c61 3231206f     n or equal to 12
   1a970:	7a484d20 6d305b1b 6d305b1b 0000000a      MHz.[0m.[0m....
   1a980:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1a990:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1a9a0:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1a9b0:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1a9c0:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1a9d0:	73655420 3a646574 69642820 65646976      Tested: (divide
   1a9e0:	61765f72 2065756c 2938203c 2020200a     r_value < 8).   
   1a9f0:	20202020 50202020 64204c4c 64697669            PLL divid
   1aa00:	76207265 65756c61 6e657720 756f2074     er value went ou
   1aa10:	666f2074 756f6220 1b73646e 1b6d305b     t of bounds.[0m.
   1aa20:	0a6d305b 00000000 31345b1b 4952436d     [0m......[41mCRI
   1aa30:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1aa40:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1aa50:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1aa60:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1aa70:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1aa80:	61662820 2965736c 2020200a 20202020      (false).       
   1aa90:	50202020 6c204c4c 206b636f 6c756f63        PLL lock coul
   1aaa0:	6f6e2064 65622074 74736520 696c6261     d not be establi
   1aab0:	64656873 66656220 2065726f 656d6974     shed before time
   1aac0:	1b74756f 1b6d305b 0a6d305b 00000000     out.[0m.[0m.....
   1aad0:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1aae0:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1aaf0:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1ab00:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1ab10:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1ab20:	73655420 3a646574 70632820 69645f75      Tested: (cpu_di
   1ab30:	65646976 203c2072 0a293233 20202020     vider < 32).    
   1ab40:	20202020 69442020 65646976 756d2072           Divider mu
   1ab50:	276e7473 78652074 64656563 1b323320     stn't exceed 32.
   1ab60:	1b6d305b 0a6d305b 00000000 32345b1b     [0m.[0m......[42
   1ab70:	2020206d 464e4920 305b1b4f 6d34393b     m    INFO.[0;94m
   1ab80:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1ab90:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1aba0:	72617453 5b1b0a74 000a6d30 65636572     Start..[0m..rece
   1abb0:	00657669                                ive.

0001abb4 <main::file>:
   1abb4:	6e69616d 7070632e ffffff00              main.cpp....

0001abc0 <main::__PRETTY_FUNCTION__>:
   1abc0:	20746e69 6e69616d ff002928 63617453     int main()..Stac
   1abd0:	6544206b 20687470 7a25203d 00000a64     k Depth = %zd...
   1abe0:	25232020 203a757a 70257830 0000000a       #%zu: 0x%p....
   1abf0:	6e75520a 6874203a 6f662065 776f6c6c     .Run: the follow
   1ac00:	20676e69 6d6d6f63 20646e61 79206e69     ing command in y
   1ac10:	2072756f 6a6f7270 20746365 65726964     our project dire
   1ac20:	726f7463 00000079 1b20200a 333b315b     ctory....  .[1;3
   1ac30:	616d6d37 7320656b 6b636174 63617274     7mmake stacktrac
   1ac40:	73252d65 41525420 3d534543 00000022     e-%s TRACES="...
   1ac50:	70257830 00000000 25783020 00000070     0x%p.... 0x%p...
   1ac60:	5b1b0a22 00006d30 73696854 6c697720     "..[0m..This wil
   1ac70:	6572206c 74726f70 65687420 6c696620     l report the fil
   1ac80:	6e612065 696c2064 6e20656e 65626d75     e and line numbe
   1ac90:	68742072 6c207461 74206465 6874206f     r that led to th
   1aca0:	66207369 74636e75 206e6f69 6e696562     is function bein
   1acb0:	61632067 64656c6c 0000002e 6c707061     g called....appl
   1acc0:	74616369 006e6f69 31345b1b 4952436d     ication..[41mCRI
   1acd0:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1ace0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1acf0:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1ad00:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1ad10:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1ad20:	65702820 68706972 6c617265 7669645f      (peripheral_div
   1ad30:	72656469 203d3c20 200a2934 20202020     ider <= 4).     
   1ad40:	20202020 76694420 72656469 73756d20          Divider mus
   1ad50:	74276e74 63786520 20646565 5b1b3233     tn't exceed 32.[
   1ad60:	5b1b6d30 000a6d30 6972500a 6e69746e     0m.[0m...Printin
   1ad70:	74532067 206b6361 63617254 000a3a65     g Stack Trace:..
   1ad80:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1ad90:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ada0:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1adb0:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1adc0:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1add0:	73655420 3a646574 65642820 65726973      Tested: (desire
   1ade0:	70735f64 5f646565 6d5f6e69 3c207a68     d_speed_in_mhz <
   1adf0:	34383320 20262620 69736564 5f646572      384 && desired_
   1ae00:	65657073 6e695f64 7a686d5f 31203e20     speed_in_mhz > 1
   1ae10:	200a2932 20202020 20202020 65724620     2).          Fre
   1ae20:	6e657571 6d207963 20747375 6c206562     quency must be l
   1ae30:	7265776f 61687420 3833206e 484d2034     ower than 384 MH
   1ae40:	646e617a 65726720 72657461 61687420     zand greater tha
   1ae50:	726f206e 75716520 74206c61 3231206f     n or equal to 12
   1ae60:	7a484d20 6d305b1b 6d305b1b 0000000a      MHz.[0m.[0m....
   1ae70:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1ae80:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ae90:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1aea0:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1aeb0:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1aec0:	73655420 3a646574 69642820 65646976      Tested: (divide
   1aed0:	61765f72 2065756c 2938203c 2020200a     r_value < 8).   
   1aee0:	20202020 50202020 64204c4c 64697669            PLL divid
   1aef0:	76207265 65756c61 6e657720 756f2074     er value went ou
   1af00:	666f2074 756f6220 1b73646e 1b6d305b     t of bounds.[0m.
   1af10:	0a6d305b 00000000 31345b1b 4952436d     [0m......[41mCRI
   1af20:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1af30:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1af40:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1af50:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1af60:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1af70:	61662820 2965736c 2020200a 20202020      (false).       
   1af80:	50202020 6c204c4c 206b636f 6c756f63        PLL lock coul
   1af90:	6f6e2064 65622074 74736520 696c6261     d not be establi
   1afa0:	64656873 66656220 2065726f 656d6974     shed before time
   1afb0:	1b74756f 1b6d305b 0a6d305b 00000000     out.[0m.[0m.....
   1afc0:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1afd0:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1afe0:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1aff0:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1b000:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1b010:	73655420 3a646574 70632820 69645f75      Tested: (cpu_di
   1b020:	65646976 203c2072 0a293233 20202020     vider < 32).    
   1b030:	20202020 69442020 65646976 756d2072           Divider mu
   1b040:	276e7473 78652074 64656563 1b323320     stn't exceed 32.
   1b050:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   1b060:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1b070:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b080:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b090:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1b0a0:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1b0b0:	3a646574 72662820 65757165 2079636e     ted: (frequency 
   1b0c0:	30203d21 20200a29 20202020 20202020     != 0).          
   1b0d0:	6e6e6143 6820746f 20657661 6f72657a     Cannot have zero
   1b0e0:	63697420 7020736b 6d207265 6f726369      ticks per micro
   1b0f0:	6f636573 202c646e 61656c70 63206573     second, please c
   1b100:	736f6f68 20312065 6d20726f 2e65726f     hoose 1 or more.
   1b110:	6d305b1b 6d305b1b 0000000a 33345b1b     .[0m.[0m.....[43
   1b120:	4157206d 4e494e52 305b1b47 6d34393b     m WARNING.[0;94m
   1b130:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b140:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b150:	74737953 54206d65 72656d69 73616820     System Timer has
   1b160:	49414620 2044454c 73206f74 74726174      FAILED to start
   1b170:	305b1b21 305b1b6d ff000a6d              !.[0m.[0m...

0001b17c <Timer::kPowerbit>:
   1b17c:	00000001 00000002 00000016 00000017     ................

0001b18c <Timer::kTimerIrq>:
   1b18c:	04030201                                ....

0001b190 <Timer::kTimerIsr>:
   1b190:	00014d49 00014d85 00014dc1 00014dfd     IM...M...M...M..

0001b1a0 <Timer::Initialize(unsigned long, void (*)(), long)::file>:
   1b1a0:	656d6974 70682e72 ffff0070              timer.hpp...

0001b1ac <Uart::kTxUartPortFunction>:
   1b1ac:	05020201                                ....

0001b1b0 <Uart::kRxUartPortFunction>:
   1b1b0:	03020201                                ....

0001b1b4 <Uart::kPowerbit>:
   1b1b4:	00000003 00000018 00000019 00000008     ................

0001b1c4 <LowLevelInit()::file>:
   1b1c4:	72617473 2e707574 00707063              startup.cpp.

0001b1d0 <vtable for Uart>:
	...
   1b1d8:	000142b5 00014381 000144b1 000145e5     .B...C...D...E..
   1b1e8:	fffffffc 00000000 000114e5 00011575     ............u...
   1b1f8:	000115cd 000115e5 000115f9 00011639     ............9...
   1b208:	00011669                                i...

0001b20c <vtable for Timer>:
	...
   1b214:	0001401d 00014181 00014279 fffffffc     .@...A..yB......
   1b224:	00000000 000114e5 00011575 000115cd     ........u.......
   1b234:	000115e5 000115f9 00011639 00011669     ........9...i...

0001b244 <vtable for SystemTimer>:
	...
   1b24c:	00013e69 00013e9d 00013f39 fffffffc     i>...>..9?......
   1b25c:	00000000 000114e5 00011575 000115cd     ........u.......
   1b26c:	000115e5 000115f9 00011639 00011669     ........9...i...

0001b27c <Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__>:
   1b27c:	74726976 206c6175 64696f76 6d695420     virtual void Tim
   1b28c:	3a3a7265 74696e49 696c6169 7528657a     er::Initialize(u
   1b29c:	33746e69 2c745f32 72734920 6e696f50     int32_t, IsrPoin
   1b2ac:	2c726574 746e6920 745f3233 ffff0029     ter, int32_t)...

0001b2bc <LowLevelInit()::__PRETTY_FUNCTION__>:
   1b2bc:	64696f76 776f4c20 6576654c 696e496c     void LowLevelIni
   1b2cc:	00292874 63617453 6544206b 20687470     t().Stack Depth 
   1b2dc:	7a25203d 00000a64 25232020 203a757a     = %zd...  #%zu: 
   1b2ec:	70257830 0000000a 6e75520a 6874203a     0x%p.....Run: th
   1b2fc:	6f662065 776f6c6c 20676e69 6d6d6f63     e following comm
   1b30c:	20646e61 79206e69 2072756f 6a6f7270     and in your proj
   1b31c:	20746365 65726964 726f7463 00000079     ect directory...
   1b32c:	1b20200a 333b315b 616d6d37 7320656b     .  .[1;37mmake s
   1b33c:	6b636174 63617274 73252d65 41525420     tacktrace-%s TRA
   1b34c:	3d534543 00000022 70257830 00000000     CES="...0x%p....
   1b35c:	25783020 00000070 5b1b0a22 00006d30      0x%p..."..[0m..
   1b36c:	73696854 6c697720 6572206c 74726f70     This will report
   1b37c:	65687420 6c696620 6e612065 696c2064      the file and li
   1b38c:	6e20656e 65626d75 68742072 6c207461     ne number that l
   1b39c:	74206465 6874206f 66207369 74636e75     ed to this funct
   1b3ac:	206e6f69 6e696562 61632067 64656c6c     ion being called
   1b3bc:	0000002e 6c707061 74616369 006e6f69     ....application.
   1b3cc:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1b3dc:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1b3ec:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1b3fc:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1b40c:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1b41c:	73655420 3a646574 73692820 3d212072      Tested: (isr !=
   1b42c:	746e4920 75727265 6f4c7470 70756b6f      InterruptLookup
   1b43c:	646e6148 2972656c 2020200a 20202020     Handler).       
   1b44c:	4e202020 5349206f 6f662052 20646e75        No ISR found 
   1b45c:	20726f66 20656874 74636576 2520726f     for the vector %
   1b46c:	305b1b75 305b1b6d 00000a6d 6972500a     u.[0m.[0m....Pri
   1b47c:	6e69746e 74532067 206b6361 63617254     nting Stack Trac
   1b48c:	000a3a65 31345b1b 7261486d 61462064     e:...[41mHard Fa
   1b49c:	20746c75 65637845 6f697470 634f206e     ult Exception Oc
   1b4ac:	72727563 0a216465 6d305b1b 00000000     curred!..[0m....
   1b4bc:	203a3072 30257830 2c586c38 3a317220     r0: 0x%08lX, r1:
   1b4cc:	25783020 586c3830 3272202c 7830203a      0x%08lX, r2: 0x
   1b4dc:	6c383025 72202c58 30203a33 38302578     %08lX, r3: 0x%08
   1b4ec:	000a586c 3a323172 25783020 586c3830     lX..r12: 0x%08lX
   1b4fc:	726c202c 7830203a 6c383025 70202c58     , lr: 0x%08lX, p
   1b50c:	30203a63 38302578 202c586c 3a727370     c: 0x%08lX, psr:
   1b51c:	25783020 586c3830 ffff000a               0x%08lX....

0001b528 <InterruptLookupHandler::file>:
   1b528:	65746e69 70757272 70632e74 ffff0070     interrupt.cpp...

0001b538 <InterruptLookupHandler::__PRETTY_FUNCTION__>:
   1b538:	64696f76 746e4920 75727265 6f4c7470     void InterruptLo
   1b548:	70756b6f 646e6148 2872656c ffff0029     okupHandler()...
   1b558:	454c4449 00000000 09632509 25097525     IDLE.....%c.%u.%
   1b568:	75250975 00000a0d 09752509 25752509     u.%u.....%u..%u%
   1b578:	000a0d25 09752509 25313c09 000a0d25     %....%u..<1%%...

0001b588 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10>:
   1b588:	3f800000 41200000 42c80000 447a0000     ...?.. A...B..zD
   1b598:	461c4000 47c35000 49742400 4b189680     .@.F.P.G.$tI...K
   1b5a8:	4cbebc20 4e6e6b28 63617453 6544206b      ..L(knNStack De
   1b5b8:	20687470 7a25203d 00000a64 25232020     pth = %zd...  #%
   1b5c8:	203a757a 70257830 0000000a 6e75520a     zu: 0x%p.....Run
   1b5d8:	6874203a 6f662065 776f6c6c 20676e69     : the following 
   1b5e8:	6d6d6f63 20646e61 79206e69 2072756f     command in your 
   1b5f8:	6a6f7270 20746365 65726964 726f7463     project director
   1b608:	00000079 1b20200a 333b315b 616d6d37     y....  .[1;37mma
   1b618:	7320656b 6b636174 63617274 73252d65     ke stacktrace-%s
   1b628:	41525420 3d534543 00000022 70257830      TRACES="...0x%p
   1b638:	00000000 25783020 00000070 5b1b0a22     .... 0x%p..."..[
   1b648:	00006d30 73696854 6c697720 6572206c     0m..This will re
   1b658:	74726f70 65687420 6c696620 6e612065     port the file an
   1b668:	696c2064 6e20656e 65626d75 68742072     d line number th
   1b678:	6c207461 74206465 6874206f 66207369     at led to this f
   1b688:	74636e75 206e6f69 6e696562 61632067     unction being ca
   1b698:	64656c6c 0000002e 6c707061 74616369     lled....applicat
   1b6a8:	006e6f69 33345b1b 4157206d 4e494e52     ion..[43m WARNIN
   1b6b8:	305b1b47 6d34393b 3a73253a 3b305b1b     G.[0;94m:%s:.[0;
   1b6c8:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b6d8:	305b1b20 6d37333b 74726f50 20642520      .[0;37mPort %d 
   1b6e8:	6e6e6163 6220746f 73752065 66206465     cannot be used f
   1b6f8:	4520726f 72657478 206c616e 65746e49     or External Inte
   1b708:	70757272 202e7374 6465654e 206f7420     rrupts. Need to 
   1b718:	20657375 4f495047 206e6f20 74726f50     use GPIO on Port
   1b728:	6f203020 2e322072 6d305b1b 6d305b1b      0 or 2..[0m.[0m
   1b738:	0000000a 33345b1b 4157206d 4e494e52     .....[43m WARNIN
   1b748:	305b1b47 6d34393b 3a73253a 3b305b1b     G.[0;94m:%s:.[0;
   1b758:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b768:	305b1b20 6d37333b 65676445 20642520      .[0;37mEdge %d 
   1b778:	6e6e6163 6220746f 73752065 66206465     cannot be used f
   1b788:	4520726f 72657478 206c616e 65746e49     or External Inte
   1b798:	70757272 4e2e7374 20646565 75206f74     rrupts.Need to u
   1b7a8:	61206573 73697220 2c676e69 6c616620     se a rising, fal
   1b7b8:	676e696c 726f202c 746f6220 6f632068     ling, or both co
   1b7c8:	6769666e 74617275 2e6e6f69 6d305b1b     nfiguration..[0m
   1b7d8:	0000000a 31345b1b 4952436d 41434954     .....[41mCRITICA
   1b7e8:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1b7f8:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b808:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1b818:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1b828:	6e6f6974 73655420 3a646574 65702820     tion Tested: (pe
   1b838:	68706972 6c617265 7669645f 72656469     ripheral_divider
   1b848:	203d3c20 200a2934 20202020 20202020      <= 4).         
   1b858:	76694420 72656469 73756d20 74276e74      Divider mustn't
   1b868:	63786520 20646565 5b1b3233 5b1b6d30      exceed 32.[0m.[
   1b878:	000a6d30 6972500a 6e69746e 74532067     0m...Printing St
   1b888:	206b6361 63617254 000a3a65 31345b1b     ack Trace:...[41
   1b898:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1b8a8:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b8b8:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b8c8:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1b8d8:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1b8e8:	3a646574 65642820 65726973 70735f64     ted: (desired_sp
   1b8f8:	5f646565 6d5f6e69 3c207a68 34383320     eed_in_mhz < 384
   1b908:	20262620 69736564 5f646572 65657073      && desired_spee
   1b918:	6e695f64 7a686d5f 31203e20 200a2932     d_in_mhz > 12). 
   1b928:	20202020 20202020 65724620 6e657571              Frequen
   1b938:	6d207963 20747375 6c206562 7265776f     cy must be lower
   1b948:	61687420 3833206e 484d2034 646e617a      than 384 MHzand
   1b958:	65726720 72657461 61687420 726f206e      greater than or
   1b968:	75716520 74206c61 3231206f 7a484d20      equal to 12 MHz
   1b978:	6d305b1b 6d305b1b 0000000a 31345b1b     .[0m.[0m.....[41
   1b988:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1b998:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b9a8:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b9b8:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1b9c8:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1b9d8:	3a646574 69642820 65646976 61765f72     ted: (divider_va
   1b9e8:	2065756c 2938203c 2020200a 20202020     lue < 8).       
   1b9f8:	50202020 64204c4c 64697669 76207265        PLL divider v
   1ba08:	65756c61 6e657720 756f2074 666f2074     alue went out of
   1ba18:	756f6220 1b73646e 1b6d305b 0a6d305b      bounds.[0m.[0m.
   1ba28:	00000000 31345b1b 4952436d 41434954     .....[41mCRITICA
   1ba38:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1ba48:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1ba58:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1ba68:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1ba78:	6e6f6974 73655420 3a646574 61662820     tion Tested: (fa
   1ba88:	2965736c 2020200a 20202020 50202020     lse).          P
   1ba98:	6c204c4c 206b636f 6c756f63 6f6e2064     LL lock could no
   1baa8:	65622074 74736520 696c6261 64656873     t be established
   1bab8:	66656220 2065726f 656d6974 1b74756f      before timeout.
   1bac8:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   1bad8:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1bae8:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1baf8:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1bb08:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1bb18:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1bb28:	3a646574 70632820 69645f75 65646976     ted: (cpu_divide
   1bb38:	203c2072 0a293233 20202020 20202020     r < 32).        
   1bb48:	69442020 65646976 756d2072 276e7473       Divider mustn'
   1bb58:	78652074 64656563 1b323320 1b6d305b     t exceed 32.[0m.
   1bb68:	0a6d305b 00000000 35345b1b 2020206d     [0m......[45m   
   1bb78:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1bb88:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1bb98:	3e64256d 305b1b20 6d37333b 6c696146     m%d> .[0;37mFail
   1bba8:	74206465 6e69206f 61697469 53206574     ed to initiate S
   1bbb8:	6d204950 2065646f 68746977 74206e69     PI mode within t
   1bbc8:	6f656d69 202e7475 726f6241 676e6974     imeout. Aborting
   1bbd8:	305b1b21 00000a6d 35345b1b 2020206d     !.[0m....[45m   
   1bbe8:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1bbf8:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1bc08:	3e64256d 305b1b20 6d37333b 70736552     m%d> .[0;37mResp
   1bc18:	65736e6f 746e6920 69726765 63207974     onse integrity c
   1bc28:	6b636568 69616620 2e64656c 6f624120     heck failed. Abo
   1bc38:	6e697472 5b1b2167 000a6d30 35345b1b     rting!.[0m...[45
   1bc48:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1bc58:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1bc68:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1bc78:	75736e55 726f7070 20646574 746c6f76     Unsupported volt
   1bc88:	20656761 75206e69 202e6573 726f6241     age in use. Abor
   1bc98:	676e6974 305b1b21 00000a6d 35345b1b     ting!.[0m....[45
   1bca8:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1bcb8:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1bcc8:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1bcd8:	43204453 20647261 656d6974 756f2064     SD Card timed ou
   1bce8:	41202e74 74726f62 21676e69 6d305b1b     t. Aborting!.[0m
   1bcf8:	0000000a 65757274 00000000 736c6166     ....true....fals
   1bd08:	00000065 35345b1b 2020206d 4f525245     e....[45m   ERRO
   1bd18:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1bd28:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1bd38:	305b1b20 6d37333b 6c696857 65522065      .[0;37mWhile Re
   1bd48:	6e696461 6c422067 206b636f 20642523     ading Block #%d 
   1bd58:	31435243 5b1b3a36 000a6d30 35345b1b     CRC16:.[0m...[45
   1bd68:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1bd78:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1bd88:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1bd98:	65707845 64657463 78302720 58343025     Expected '0x%04X
   1bda8:	305b1b27 00000a6d 35345b1b 2020206d     '.[0m....[45m   
   1bdb8:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1bdc8:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1bdd8:	3e64256d 305b1b20 6d37333b 20746f47     m%d> .[0;37mGot 
   1bde8:	25783027 27583430 6d305b1b 0000000a     '0x%04X'.[0m....
   1bdf8:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1be08:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1be18:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1be28:	6d37333b 64616552 646d4320 73617720     ;37mRead Cmd was
   1be38:	746f6e20 6b636120 6c776f6e 65676465      not acknowledge
   1be48:	72702064 7265706f 1b21796c 0a6d305b     d properly!.[0m.
   1be58:	00000000 35345b1b 2020206d 4f525245     .....[45m   ERRO
   1be68:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1be78:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1be88:	305b1b20 6d37333b 61726150 6574656d      .[0;37mParamete
   1be98:	72452072 25203a72 305b1b73 00000a6d     r Err: %s.[0m...
   1bea8:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1beb8:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1bec8:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1bed8:	6d37333b 72646441 72724520 7325203a     ;37mAddr Err: %s
   1bee8:	6d305b1b 0000000a 35345b1b 2020206d     .[0m.....[45m   
   1bef8:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1bf08:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1bf18:	3e64256d 305b1b20 6d37333b 73617245     m%d> .[0;37mEras
   1bf28:	65532065 72452071 25203a72 305b1b73     e Seq Err: %s.[0
   1bf38:	00000a6d 35345b1b 2020206d 4f525245     m....[45m   ERRO
   1bf48:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1bf58:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1bf68:	305b1b20 6d37333b 206d6f43 20435243      .[0;37mCom CRC 
   1bf78:	3a727245 1b732520 0a6d305b 00000000     Err: %s.[0m.....
   1bf88:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1bf98:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1bfa8:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1bfb8:	6d37333b 656c6c49 206c6167 20646d43     ;37mIllegal Cmd 
   1bfc8:	3a727245 1b732520 0a6d305b 00000000     Err: %s.[0m.....
   1bfd8:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1bfe8:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1bff8:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1c008:	6d37333b 73617245 65522065 3a746573     ;37mErase Reset:
   1c018:	1b732520 0a6d305b 00000000 35345b1b      %s.[0m......[45
   1c028:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1c038:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1c048:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1c058:	49206e49 3a656c64 1b732520 0a6d305b     In Idle: %s.[0m.
   1c068:	00000000 35345b1b 2020206d 4f525245     .....[45m   ERRO
   1c078:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1c088:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1c098:	305b1b20 6d37333b 6c696146 74206465      .[0;37mFailed t
   1c0a8:	6573206f 74532074 20747261 72646441     o set Start Addr
   1c0b8:	21737365 6d305b1b 0000000a 35345b1b     ess!.[0m.....[45
   1c0c8:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1c0d8:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1c0e8:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1c0f8:	6c696146 74206465 6573206f 6e452074     Failed to set En
   1c108:	64412064 73657264 5b1b2173 000a6d30     d Address!.[0m..
   1c118:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1c128:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1c138:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1c148:	6d37333b 6e6b6e55 206e776f 70736572     ;37mUnknown resp
   1c158:	65736e6f 70797420 41202e65 74726f62     onse type. Abort
   1c168:	21676e69 6d305b1b 0000000a 35345b1b     ing!.[0m.....[45
   1c178:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1c188:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1c198:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1c1a8:	70736552 65736e6f 736e7520 6f707075     Response unsuppo
   1c1b8:	64657472 206e6920 20495053 65646f6d     rted in SPI mode
   1c1c8:	6241202e 6974726f 1b21676e 0a6d305b     . Aborting!.[0m.
   1c1d8:	ffffff00                                ....

0001c1dc <Sd::kCrcTable8>:
   1c1dc:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
   1c1ec:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
   1c1fc:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
   1c20c:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
   1c21c:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
   1c22c:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
   1c23c:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
   1c24c:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
   1c25c:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
   1c26c:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
   1c27c:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
   1c28c:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
   1c29c:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
   1c2ac:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
   1c2bc:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
   1c2cc:	151c070e 3138232a 5d544f46 00706b62     ....*#81FOT]bkp.

0001c2dc <Sd::kCrcTable16>:
   1c2dc:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
   1c2ec:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
   1c2fc:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
   1c30c:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
   1c31c:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
   1c32c:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
   1c33c:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
   1c34c:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
   1c35c:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
   1c36c:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
   1c37c:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
   1c38c:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
   1c39c:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
   1c3ac:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
   1c3bc:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
   1c3cc:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
   1c3dc:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
   1c3ec:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
   1c3fc:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
   1c40c:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
   1c41c:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
   1c42c:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
   1c43c:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
   1c44c:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
   1c45c:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
   1c46c:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
   1c47c:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
   1c48c:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
   1c49c:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
   1c4ac:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
   1c4bc:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
   1c4cc:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....

0001c4dc <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c4dc:	682e6473 ff007070                       sd.hpp..

0001c4e4 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c4e4:	682e6473 ff007070                       sd.hpp..

0001c4ec <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c4ec:	682e6473 ff007070                       sd.hpp..

0001c4f4 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c4f4:	682e6473 ff007070                       sd.hpp..

0001c4fc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c4fc:	682e6473 ff007070                       sd.hpp..

0001c504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c504:	682e6473 ff007070                       sd.hpp..

0001c50c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c50c:	682e6473 ff007070                       sd.hpp..

0001c514 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c514:	682e6473 ff007070                       sd.hpp..

0001c51c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c51c:	682e6473 ff007070                       sd.hpp..

0001c524 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c524:	682e6473 ff007070                       sd.hpp..

0001c52c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c52c:	682e6473 ff007070                       sd.hpp..

0001c534 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c534:	682e6473 ff007070                       sd.hpp..

0001c53c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c53c:	682e6473 ff007070                       sd.hpp..

0001c544 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c544:	682e6473 ff007070                       sd.hpp..

0001c54c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c54c:	682e6473 ff007070                       sd.hpp..

0001c554 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1c554:	682e6473 ff007070                       sd.hpp..

0001c55c <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1c55c:	682e6473 ff007070                       sd.hpp..

0001c564 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1c564:	682e6473 ff007070                       sd.hpp..

0001c56c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1c56c:	682e6473 ff007070                       sd.hpp..

0001c574 <vtable for Sd>:
	...
   1c57c:	00018ca9 00018101 000181b1 000185c5     ................
   1c58c:	000189dd 00018b89 00019149 00019191     ........I.......
   1c59c:	00019201                                ....

0001c5a0 <vtable for SdInterface>:
	...
   1c5a8:	00019421 00019421 00019421 00019421     !...!...!...!...
   1c5b8:	00019421 00019421 00019421 00019421     !...!...!...!...
   1c5c8:	00019421                                !...

0001c5cc <Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__>:
   1c5cc:	74726976 206c6175 6c6f6f62 3a645320     virtual bool Sd:
   1c5dc:	756f4d3a 5328746e 746e4964 61667265     :Mount(SdInterfa
   1c5ec:	3a3a6563 64726143 6f666e49 292a745f     ce::CardInfo_t*)
   1c5fc:	ffffff00                                ....

0001c600 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__>:
   1c600:	74726976 206c6175 746e6975 20745f38     virtual uint8_t 
   1c610:	3a3a6453 64616552 636f6c42 6975286b     Sd::ReadBlock(ui
   1c620:	3233746e 202c745f 746e6975 2a745f38     nt32_t, uint8_t*
   1c630:	6975202c 3233746e 0029745f              , uint32_t).

0001c63c <Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__>:
   1c63c:	74726976 206c6175 746e6975 20745f38     virtual uint8_t 
   1c64c:	3a3a6453 656c6544 6c426574 286b636f     Sd::DeleteBlock(
   1c65c:	746e6975 745f3233 6975202c 3233746e     uint32_t, uint32
   1c66c:	0029745f                                _t).

0001c670 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__>:
   1c670:	74726976 206c6175 746e6975 745f3233     virtual uint32_t
   1c680:	3a645320 6e65533a 646d4364 49645328      Sd::SendCmd(SdI
   1c690:	7265746e 65636166 6f433a3a 6e616d6d     nterface::Comman
   1c6a0:	75202c64 33746e69 2c745f32 6e697520     d, uint32_t, uin
   1c6b0:	745f3874 75202c2a 33746e69 2c745f32     t8_t*, uint32_t,
   1c6c0:	49645320 7265746e 65636166 654b3a3a      SdInterface::Ke
   1c6d0:	6c417065 29657669 ffffff00              epAlive)....

0001c6dc <__sf_fake_stderr>:
	...

0001c6fc <__sf_fake_stdin>:
	...

0001c71c <__sf_fake_stdout>:
	...
