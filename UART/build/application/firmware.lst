
build/application/firmware.elf:     file format elf32-littlearm
build/application/firmware.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00014889

Program Header:
0x70000001 off    0x0001c2e8 vaddr 0x0001c2e8 paddr 0x0001c2e8 align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010000 vaddr 0x00010000 paddr 0x00010000 align 2**16
         filesz 0x0000c2f0 memsz 0x0000c2f0 flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x0001c2f0 align 2**16
         filesz 0x00000944 memsz 0x00000944 flags rw-
    LOAD off    0x00020948 vaddr 0x10000948 paddr 0x10000948 align 2**16
         filesz 0x00000000 memsz 0x00000d74 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name             Size      VMA       LMA       File off  Algn  Flags
  0 .text            0000c2e8  00010000  00010000  00010000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data            00000944  10000000  0001c2f0  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2       00000000  20000000  20000000  00020944  2**2  CONTENTS
  3 .bss             00000d74  10000948  10000948  00020948  2**3  ALLOC
  4 .ARM.exidx       00000008  0001c2e8  0001c2e8  0001c2e8  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .uninit_RESERVED 00000000  10000000  10000000  00020944  2**2  CONTENTS
  6 .noinit_RAM2     00000000  20000000  20000000  00020944  2**2  CONTENTS
  7 .noinit          00000000  100016bc  100016bc  00020944  2**2  CONTENTS
  8 .ARM.attributes  00000030  00000000  00000000  00020944  2**0  CONTENTS, READONLY
  9 .comment         0000007e  00000000  00000000  00020974  2**0  CONTENTS, READONLY
 10 .debug_info      0005f2ee  00000000  00000000  000209f2  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev    00006144  00000000  00000000  0007fce0  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges   00001538  00000000  00000000  00085e24  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges    00001468  00000000  00000000  0008735c  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_line      00009b89  00000000  00000000  000887c4  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_str       0001ae60  00000000  00000000  0009234d  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame     000052a0  00000000  00000000  000ad1b0  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
20000000 l    d  .data_RAM2	00000000 .data_RAM2
10000948 l    d  .bss	00000000 .bss
0001c2e8 l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
20000000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
100016bc l    d  .noinit	00000000 .noinit
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 interrupt.cpp
00014e64 l     F .text	0000002c NVIC_EnableIRQ
00014e90 l     F .text	00000054 NVIC_SetPriority
00010000 l     O .text	000000e4 kInterruptVectorTable
0001b0d4 l     O .text	0000000e InterruptLookupHandler::file
0001b0e4 l     O .text	0000001e InterruptLookupHandler::__PRETTY_FUNCTION__
0001022c l       .text	00000000 handler2_address_const
00000000 l    df *ABS*	00000000 startup.cpp
0001ae28 l     O .text	0000003e Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__
100007d4 l     O .data	00000008 (anonymous namespace)::system_timer
100007dc l     O .data	00000004 (anonymous namespace)::system_controller
100007e0 l     O .data	0000000c (anonymous namespace)::timer0
000146a4 l     F .text	00000040 (anonymous namespace)::Lpc40xxUptime()
10001294 l     O .bss	00000060 idle_task_tcb
100012f4 l     O .bss	00000140 idle_task_stack
0001ad70 l     O .text	0000000c LowLevelInit()::file
0001ae68 l     O .text	00000014 LowLevelInit()::__PRETTY_FUNCTION__
000102fc l     O .text	00000004 kCrpWord
00014d78 l     F .text	000000dc __static_initialization_and_destruction_0(int, int)
00014e54 l     F .text	0000000e _GLOBAL__sub_I_UptimeRTOS
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crti.o
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00010328 l     F .text	00000000 __do_global_dtors_aux
10000948 l       .bss	00000001 completed.9929
0001034c l     F .text	00000000 frame_dummy
1000094c l       .bss	00000018 object.9934
0001030c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
0001a760 l     O .text	00000009 main::file
0001a76c l     O .text	0000000b main::__PRETTY_FUNCTION__
000136e8 l     F .text	00000044 __static_initialization_and_destruction_0(int, int)
0001372c l     F .text	00000028 _GLOBAL__sub_I_Global_Queue_Handle
00000000 l    df *ABS*	00000000 diskio.cpp
0001c178 l     O .text	00000031 Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__
0001c1ac l     O .text	0000003c Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__
0001c1e8 l     O .text	00000034 Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__
0001c21c l     O .text	00000069 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__
10001648 l     O .bss	00000068 (anonymous namespace)::sd_card
00018f18 l     F .text	00000050 __static_initialization_and_destruction_0(int, int)
00018f68 l     F .text	00000028 _GLOBAL__sub_I_disk_status
00000000 l    df *ABS*	00000000 LabUART.cpp
10000968 l     O .bss	00000008 (anonymous namespace)::uptime
00010ad4 l     F .text	00000030 (anonymous namespace)::DefaultUptime()
0001a0b4 l     O .text	0000001c Gpio::ValidPortCheck()::__PRETTY_FUNCTION__
0001a0d0 l     O .text	00000039 Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001a078 l     O .text	0000003b Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
00019f38 l     O .text	00000049 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__
00019fe0 l     O .text	0000005c Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
00019f84 l     O .text	0000005a Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
0001a03c l     O .text	0000003a Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 pinconn.cpp
00000000 l    df *ABS*	00000000 newlib.cpp
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 tasks.c
10001540 l     O .bss	00000064 pxReadyTasksLists
100015a4 l     O .bss	00000014 xDelayedTaskList1
100015b8 l     O .bss	00000014 xDelayedTaskList2
100015cc l     O .bss	00000004 pxDelayedTaskList
100015d0 l     O .bss	00000004 pxOverflowDelayedTaskList
100015d4 l     O .bss	00000014 xPendingReadyList
100015e8 l     O .bss	00000014 xTasksWaitingTermination
100015fc l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
10001600 l     O .bss	00000014 xSuspendedTaskList
10001614 l     O .bss	00000004 uxCurrentNumberOfTasks
10001618 l     O .bss	00000004 xTickCount
1000161c l     O .bss	00000004 uxTopReadyPriority
10001620 l     O .bss	00000004 xSchedulerRunning
10001624 l     O .bss	00000004 uxPendedTicks
10001628 l     O .bss	00000004 xYieldPending
1000162c l     O .bss	00000004 xNumOfOverflows
10001630 l     O .bss	00000004 uxTaskNumber
10001634 l     O .bss	00000004 xNextTaskUnblockTime
10001638 l     O .bss	00000004 xIdleTaskHandle
1000163c l     O .bss	00000004 uxSchedulerSuspended
10001640 l     O .bss	00000004 ulTaskSwitchedInTime
10001644 l     O .bss	00000004 ulTotalRunTime
000154b0 l     F .text	000000f2 prvInitialiseNewTask
000155a4 l     F .text	000000dc prvAddNewTaskToReadyList
00015c08 l     F .text	0000007c prvInitialiseTaskLists
00015cdc l     F .text	0000003a prvDeleteTCB
00015d18 l     F .text	00000040 prvResetNextTaskUnblockTime
00015e20 l     F .text	000000c8 prvAddCurrentTaskToDelayedList
00015bfc l     F .text	0000000c prvIdleTask
00015c84 l     F .text	00000058 prvCheckTasksWaitingTermination
00000000 l    df *ABS*	00000000 queue.c
00015ffe l     F .text	00000048 prvInitialiseNewQueue
00016238 l     F .text	000000d2 prvCopyDataToQueue
00016354 l     F .text	000000ae prvUnlockQueue
0001630a l     F .text	0000004a prvCopyDataFromQueue
00016402 l     F .text	0000002a prvIsQueueEmpty
00000000 l    df *ABS*	00000000 port.c
100008d8 l     O .data	00000004 uxCriticalNesting
0001648c l     F .text	00000026 prvTaskExitError
000164e0 l       .text	00000000 pxCurrentTCBConst2
000164e8 l     F .text	00000024 prvPortStartFirstTask
00016668 l     F .text	00000010 vPortEnableVFP
00016620 l       .text	00000000 pxCurrentTCBConst
00000000 l    df *ABS*	00000000 heap_3.c
00000000 l    df *ABS*	00000000 printf.cpp
000166c0 l     F .text	00000044 _out_buffer(char, void*, unsigned int, unsigned int)
00016704 l     F .text	00000030 _out_null(char, void*, unsigned int, unsigned int)
00016734 l     F .text	00000044 _out_char(char, void*, unsigned int, unsigned int)
00016778 l     F .text	00000044 _strlen(char const*)
000167bc l     F .text	00000044 _is_digit(char)
00016800 l     F .text	00000060 _atoi(char const**)
00016860 l     F .text	0000025c _ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)
00016abc l     F .text	000000e4 _ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)
00016ba0 l     F .text	000000f4 _ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)
0001b134 l     O .text	00000028 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10
00016c94 l     F .text	00000438 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)
000170cc l     F .text	000008f4 _vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)
00000000 l    df *ABS*	00000000 pure.cc
00000000 l    df *ABS*	00000000 eh_terminate.cc
00000000 l    df *ABS*	00000000 sf_round.c
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcpy-stub.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 findfp.c
00000000 l    df *ABS*	00000000 eh_term_handler.cc
00000000 l    df *ABS*	00000000 impure.c
100008e4 l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 reent.c
000115f4  w    F .text	0000003e Lpc40xxSystemController::GetPeripheralFrequency() const
00015160 g     F .text	00000038 putchar
00014ee4  w    F .text	0000006c Pwm0IrqHandler
00019c34  w    O .text	00000009 Gpio::SetInterruptEdge(GpioInterface::Edge)::file
00010218 g     F .text	0000001c HardFaultHandler
00015078 g     F .text	00000024 _getpid
00015124 g     F .text	0000003c _putchar
00014ee4  w    F .text	0000006c EepromIrqHandler
00014ee4  w    F .text	0000006c Timer2IrqHandler
100007c0  w    O .data	00000014 uart0
00015264 g     F .text	0000002c GetStackDepth()
0001c088  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
000114bc  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
0001ad38  w    O .text	00000004 Timer::kTimerIrq
0001658c g     F .text	00000028 vPortExitCritical
0001c0c0  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001962c g     F .text	00000024 _kill_r
0001010c g       .text	00000000 bss_section_table_end
000179c0 g     F .text	0000004c printf
1000075c  w    O .data	00000004 SystemTimer::sys_tick
00014ee4  w    F .text	0000006c I2c1IrqHandler
00014930  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)2>()
10000770  w    O .data	00000010 Uart::uart
0001c0f0  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00010000 g       *ABS*	00000000 __vectors_start__
000128cc  w    F .text	00000090 Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)
00019656 g     F .text	00000002 __malloc_unlock
00010b04  w    F .text	00000044 Milliseconds()
00011758  w    F .text	00000110 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)
00012778  w    F .text	00000094 Ssd1306::Ssd1306()
00011a9c  w    F .text	00000034 SspInterface::SspInterface()
00014ee4  w    F .text	0000006c BusFaultHandler
10001438 g     O .bss	00000100 stack_trace
10000000  w    O .data	00000004 Pin::pin_map
00013ef0  w    F .text	000000e4 Uart::Initialize(unsigned long)
20000000 g       *ABS*	00000000 __base_RAM2
00016046 g     F .text	000000b0 xQueueGenericSendFromISR
00012778  w    F .text	00000094 Ssd1306::Ssd1306()
0001c2f0 g       .ARM.exidx	00000000 __exidx_end
000113ac  w    F .text	0000007c Gpio::ClearEdgeRising()
00011a40  w    F .text	00000030 Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)
00019c28  w    O .text	00000009 Gpio::ValidPortCheck()::file
00012cf0  w    F .text	0000006c OledTerminal::OledTerminal()
1000153c g     O .bss	00000004 pxCurrentTCB
00010368  w    F .text	00000034 PinInterface::PinInterface()
00015220 g     F .text	0000001c __cyg_profile_func_exit
00018cb8  w    F .text	00000048 Sd::Crc7Add(unsigned char, unsigned char)
00017bd0  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
00014b98  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()
100016b8 g     O .bss	00000004 errno
0001c2f0 g       .ARM.exidx	00000000 _etext
10000a70 g     O .bss	00000004 Global_Queue_Handle
10000048  w    O .data	00000004 Lpc40xxSystemController::system_controller
000114e0  w    F .text	00000090 Lpc40xxSystemController::SetClockFrequency(unsigned char)
00013cc0  w    F .text	00000030 unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)
000115e0  w    F .text	00000014 Lpc40xxSystemController::GetSystemFrequency() const
000144b4  w    F .text	000001f0 Uart::GenerateUartCalibration(float)
10000008  w    O .data	00000018 Gpio::gpio_port
00013cf0  w    F .text	000000f8 Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)
000147b0  w    F .text	000000bc LowLevelInit()
00014ee4  w    F .text	0000006c LcdIrqHandler
0001c118  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
00080000 g       *ABS*	00000000 __top_MFlash512
00011d9c  w    F .text	0000006c Ssp::Transfer(unsigned short)
00015b3c g     F .text	00000024 vTaskInternalSetTimeOutState
00014154  w    F .text	000000f8 Uart::Receive(unsigned long)
000116f8  w    F .text	00000030 Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)
00017b6c  w    F .text	00000030 Delay(unsigned long long)
0001ad60  w    O .text	00000010 Uart::kPowerbit
00014ee4  w    F .text	0000006c I2c2IrqHandler
10001240  w    O .bss	00000004 SystemTimer::system_timer_isr
00011274  w    F .text	00000040 Gpio::DetachInterrupt()
00013754 g     F .text	00000064 pinconn::clear7(unsigned char, unsigned char)
00013878 g     F .text	000000c0 pinconn::uart2_rxd(unsigned char, unsigned char)
00014ee4  w    F .text	0000006c CanIrqHandler
00016510 g     F .text	00000054 xPortStartScheduler
00019434 g     F .text	00000016 memcpy
00013458 g     F .text	00000104 InitializeUart2()
00015a68 g     F .text	0000002c vTaskPlaceOnEventList
000108a4  w    F .text	00000074 Pin::EnableDac(bool)
00014784 g     F .text	0000002c vPortSetupTimerInterrupt
000105d4  w    F .text	0000007c Pin::SetAsAnalogMode(bool)
00016628 g     F .text	00000040 xPortSysTickHandler
000119d8  w    F .text	00000068 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)
00018d70  w    F .text	000000fc Sd::GetCrc16(unsigned char*, unsigned short)
000190bc g     F .text	00000000 .hidden __aeabi_uldivmod
100016bc g       .noinit	00000000 _noinit
00015198 g     F .text	00000060 puts
0001669e g     F .text	00000022 vPortFree
100007ec g     O .data	000000e4 dynamic_isr_vector_table
00010f94  w    F .text	0000002c Gpio::GetPin()
0001103c  w    F .text	0000005c Gpio::SetInterruptRoutine(void (*)())
00010b48  w    F .text	00000034 GpioInterface::GpioInterface()
00011a9c  w    F .text	00000034 SspInterface::SspInterface()
00014ee4  w    F .text	0000006c RitIrqHandler
00014ee4  w    F .text	0000006c Uart2IrqHandler
00010918  w    F .text	00000064 Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)
00019cac  w    O .text	00000016 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file
0001c0a8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00019414 g     F .text	00000010 malloc
00012100  w    F .text	00000160 Ssp::GetPeripheralMode()
00014c38  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()
00018fbc g     F .text	00000060 roundf
000195cc g     F .text	00000050 _raise_r
00017a7c  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::_FUN()
00011a70  w    F .text	0000002c int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)
00011ad0  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10010000 g       *ABS*	00000000 __top_RAM
0001ad5c  w    O .text	00000004 Uart::kRxUartPortFunction
00017aa8  w    F .text	000000c4 Wait(unsigned long long)
000165c0 g     F .text	00000066 xPortPendSVHandler
00017a0c g     F .text	00000044 vsnprintf
00017b9c  w    F .text	00000034 SdInterface::SdInterface()
00013de8  w    F .text	0000003c Timer::GetTimer()
10000000 g       *ABS*	00000000 __base_RamLoc64
0001523c g     F .text	00000028 GetStackTrace()
100008d4 g     O .data	00000004 out
000152d6 g     F .text	0000003e vListInsertEnd
1000004c  w    O .data	00000004 Lpc40xxSystemController::speed_in_hertz
0001c0f8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001c0e0  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00019650 g     F .text	00000004 _getpid_r
00000000 g       *ABS*	00000000 __base_MFlash512
00019d74  w    O .text	0000004c vtable for Ssp
10010000 g       *ABS*	00000000 StackTop
00018080  w    F .text	00000064 Sd::WaitToReadBlock()
00019cc4  w    O .text	00000003 Ssp::kPinSelect
000130f0  w    F .text	00000038 Graphics::Clear()
00012864  w    F .text	00000068 Ssd1306::AvailableColors()
000190ec g     F .text	000002cc .hidden __udivmoddi4
00014ee4  w    F .text	0000006c I2sIrqHandler
000195ac g     F .text	00000020 _sbrk_r
000100fc g       .text	00000000 bss_section_table
00013368  w    F .text	00000050 OledTerminal::ClearRow(unsigned int)
00010300 g       .text	00000000 __CRP_WORD_END__
20008000 g       *ABS*	00000000 __top_RAM2
00014888 g     F .text	00000030 ResetIsr
000152c6 g     F .text	00000010 vListInitialiseItem
00019d1c  w    O .text	0000002c vtable for Ssd1306
0001803c  w    F .text	00000044 Sd::ToBool(bool)
00019dc0  w    O .text	00000028 vtable for SspInterface
000160f8 g     F .text	00000140 xQueueReceive
00014ee4  w    F .text	0000006c PendSVHandler
1000005c  w    O .data	00000400 font8x8_basic
00011e64  w    F .text	00000030 unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)
000139d8  w    F .text	00000034 SystemTimer::SetIsrFunction(void (*)())
00012d98  w    F .text	00000044 bool bit::Read<unsigned long>(unsigned long, unsigned long)
00011d24  w    F .text	00000078 Ssp::IsTransferRegBusy()
00014ee4  w    F .text	0000006c UsageFaultHandler
20000000 g       *ABS*	00000000 __user_heap_base
00012c64  w    F .text	0000008c Graphics::Graphics(PixelDisplayInterface*)
0001c2e8 g       .text	00000000 __exidx_start
000107bc  w    F .text	00000074 Pin::EnableI2cHighCurrentDrive(bool)
00014ee4  w    F .text	0000006c Uart4IrqHandler
00011098  w    F .text	00000054 Gpio::ClearInterruptRoutine()
00010740  w    F .text	0000007c Pin::EnableI2cHighSpeedMode(bool)
000101fc g     F .text	00000018 InitFpu()
00010650  w    F .text	0000007c Pin::EnableDigitalFilter(bool)
0001280c  w    F .text	0000002c Ssd1306::GetWidth()
000193cc g     F .text	00000048 __libc_init_array
00014ee4 g     F .text	0000006c InterruptLookupHandler
00011728  w    F .text	00000030 Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)
000115c8  w    F .text	00000018 Lpc40xxSystemController::GetPeripheralClockDivider() const
10000004  w    O .data	00000004 Uptime
00019e78  w    O .text	00000048 vtable for GpioInterface
00014020  w    F .text	000000e8 Uart::Send(unsigned char)
000193bc g     F .text	0000000e abort
00014ee4  w    F .text	0000006c BodIrqHandler
0001355c g     F .text	00000098 Uart2Send(char)
000150cc g     F .text	00000058 _sbrk
0001667c g     F .text	00000022 pvPortMalloc
0001244c  w    F .text	00000184 Ssp::GetClock()
00010300 g     F .text	00000000 _init
0001010c g       .text	00000000 section_table_end
00014cd8  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()
00015290 g     F .text	00000036 vListInitialise
00018fb0 g     F .text	0000000a std::terminate()
0001901c g     F .text	0000009e .hidden __aeabi_d2f
00011428  w    F .text	0000007c Gpio::ClearEdgeFalling()
00014ee4  w    F .text	0000006c SysTickHandler
000100e4 g       .text	00000000 section_table_start
100016bc g       .bss	00000000 _ebss
00012bf0  w    F .text	00000074 Ssd1306::Update()
00011330  w    F .text	0000007c Gpio::SetEdgeFalling()
0001c0b8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00014ee4  w    F .text	0000006c RtcIrqHandler
00015d58 g     F .text	000000c8 xTaskPriorityDisinherit
00010f24  w    F .text	00000070 Gpio::Read()
00012c64  w    F .text	0000008c Graphics::Graphics(PixelDisplayInterface*)
00013650 g     F .text	00000098 vReceiveByteOverUartTask(void*)
000149a8  w    F .text	000000a8 Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})
eff779ca g       *ABS*	00000000 ValidUserCodeChecksum
00014ee4  w    F .text	0000006c Uart0IrqHandler
00014fac g     F .text	00000078 GetRegistersFromStack
00012d5c  w    F .text	0000003c unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)
00013128  w    F .text	0000004c OledTerminal::Initialize()
00015a94 g     F .text	000000a8 xTaskRemoveFromEventList
000130b8  w    F .text	00000038 Graphics::Update()
00019efc  w    O .text	0000003c vtable for PinInterface
00014ee4  w    F .text	0000006c UsbIrqHandler
00014ee4  w    F .text	0000006c AdcIrqHandler
00014108  w    F .text	0000004c Uart::Receive(unsigned long)::{lambda()#1}::operator()() const
00013938  w    F .text	00000030 SetUptimeFunction(unsigned long long (*)())
0001c288 g     O .text	00000020 __sf_fake_stderr
000125d0  w    F .text	00000094 PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)
0001bd88  w    O .text	00000100 Sd::kCrcTable8
00018fa0 g     F .text	00000010 std::get_terminate()
000143bc  w    F .text	00000074 Uart::FractionalEstimate(float, float)
0001111c  w    F .text	00000088 Gpio::SetInterruptEdge(GpioInterface::Edge)
00014ee4  w    F .text	0000006c EnetIrqHandler
00014ee4  w    F .text	0000006c DmaIrqHandler
0001010c g     F .text	00000090 InitDataSection()
00014f50 g     F .text	0000005c RegisterIsr(IRQn, void (*)(), bool, long)
00000000 g       *ABS*	00000000 __base_Flash
00014ee4  w    F .text	0000006c Eint1IrqHandler
10000050  w    O .data	0000000c Ssp::ssp_registers
00014ee4  w    F .text	0000006c SvcHandler
00013174  w    F .text	00000158 OledTerminal::printf(char const*, ...)
00015b60 g     F .text	0000008c xTaskCheckForTimeOut
00014ee4  w    F .text	0000006c GpioIrqHandler
0001945c g     F .text	0000009c _free_r
0001c108  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
00014ee4  w    F .text	0000006c SdioIrqHandler
10010000 g       *ABS*	00000000 __top_RamLoc64
10000948 g       .bss	00000000 _bss
0001c0a0  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
00014ee4  w    F .text	0000006c Pll1IrqHandler
00014ee4  w    F .text	0000006c MemManageHandler
000126f4  w    F .text	00000028 PixelDisplayInterface::Disable()
0001571c g     F .text	00000014 vTaskSuspendAll
00018f90 g     F .text	00000006 __cxa_pure_virtual
00013060  w    F .text	00000058 Graphics::DrawPixel(unsigned long, unsigned long)
00014ee4  w    F .text	0000006c Pwm1IrqHandler
0001537c g     F .text	0000004a uxListRemove
000110ec  w    F .text	00000030 unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)
00014ee4  w    F .text	0000006c Timer0IrqHandler
00014a50  w    F .text	000000a8 Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})
00012838  w    F .text	0000002c Ssd1306::GetHeight()
00080000 g       *ABS*	00000000 __top_Flash
00014430  w    F .text	00000084 Uart::IsDecmial(float)
00012260  w    F .text	000001ec Ssp::SetClock(bool, bool, unsigned char, unsigned char)
000132cc  w    F .text	0000009c OledTerminal::Update()
000153c6 g     F .text	0000005c xTaskCreateStatic
100016bc g       .noinit	00000000 _end_noinit
00013968  w    F .text	0000003c SystemTimer::DisableTimer()
000186f8  w    F .text	00000120 Sd::DeleteBlock(unsigned long, unsigned long)
000159a0 g     F .text	000000c8 vTaskSwitchContext
00012e50  w    F .text	00000054 unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)
0001039c  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
00011ec4  w    F .text	00000030 unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)
0001c0c8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001ad58  w    O .text	00000004 Uart::kTxUartPortFunction
00012f64  w    F .text	000000fc Graphics::DrawCharacter(long, long, char, bool)
00014ee4  w    F .text	0000006c Uart3IrqHandler
000114a4  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
0001c100  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
20000000 g       *ABS*	00000000 __base_RamPeriph32
00012b5c  w    F .text	00000094 Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)
00014750 g     F .text	00000034 vApplicationGetIdleTaskMemory
00019c40  w    O .text	00000009 Gpio::ClearInterruptEdge(GpioInterface::Edge)::file
10001538 g     O .bss	00000004 stack_depth
00010e40  w    F .text	0000006c Gpio::Toggle()
0001c0d8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001be88  w    O .text	00000200 Sd::kCrcTable16
10000970  w    O .bss	00000100 Gpio::interrupthandlers
000193b8  w    F .text	00000002 .hidden __aeabi_ldiv0
00014ee4  w    F .text	0000006c Timer1IrqHandler
00012664  w    F .text	00000068 PixelDisplayInterface::Color_t::Color_t()
00014348  w    F .text	00000074 Uart::DividerEstimate(float, float)
00010d34  w    F .text	00000064 Gpio::SetHigh()
0001424c  w    F .text	000000fc Uart::FindClosestFractional(float)
00011b5c  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
000100e4 g       .text	00000000 data_section_table
00019c64  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
0001046c  w    F .text	00000080 Pin::SetMode(PinInterface::Mode)
000180e4  w    F .text	00000050 Sd::WaitWhileBusy()
00019654 g     F .text	00000002 __malloc_lock
00013aa8  w    F .text	00000094 SystemTimer::SetTickFrequency(unsigned long)
0001c2a8 g     O .text	00000020 __sf_fake_stdin
00012ea4  w    F .text	00000074 unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)
000102fc g       .text	00000000 __CRP_WORD_START__
0001ad3c  w    O .text	00000010 Timer::kTimerIsr
0001295c  w    F .text	000000f0 Ssd1306::InitializationPanel()
0001122c  w    F .text	00000048 Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)
00014ee4  w    F .text	0000006c Uart1IrqHandler
00010bf8  w    F .text	0000007c Gpio::SetAsInput()
000151f8 g     F .text	00000028 __cyg_profile_func_enter
0001944a g     F .text	00000010 memset
000133b8 g     F .text	000000a0 main
00017bd0  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
10000020  w    O .data	00000028 Gpio::interrupt
00013b6c  w    F .text	00000020 Timer::DoNothingIsr()
00014ee4  w    F .text	0000006c QeiIrqHandler
20000000 g       *ABS*	00000000 heap
00015314 g     F .text	00000068 vListInsert
00014ee4  w    F .text	0000006c Ssp2IrqHandler
0001097c  w    F .text	0000002c Pin::GetPort() const
0001854c  w    F .text	000001ac Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)
0001039c  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
0001901c g     F .text	0000009e .hidden __truncdfsf2
0001031c g       .text	00000000 __init_array_end
000164c0 g     F .text	00000026 vPortSVCHandler
00015024 g     F .text	0000003c FirmwareStdOut(int)
000194f8 g     F .text	000000b4 _malloc_r
0001c120  w    O .text	0000002c vtable for Sd
000111a4  w    F .text	00000088 Gpio::ClearInterruptEdge(GpioInterface::Edge)
00014ee4  w    F .text	0000006c Ssp1IrqHandler
000148b8  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)0>()
00019d10  w    O .text	0000000c Ssp::kPowerBit
000109a8  w    F .text	0000002c Pin::GetPin() const
00015f9c g     F .text	00000062 xQueueGenericCreate
00013e24  w    F .text	000000cc Uart::SetBaudRate(unsigned long)
0001ad7c  w    O .text	0000003c vtable for Uart
00010cf0  w    F .text	00000044 Gpio::SetDirection(GpioInterface::Direction)
00010c74  w    F .text	0000007c Gpio::SetAsOutput()
0001c0e8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00011868  w    F .text	00000170 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)
00012cf0  w    F .text	0000006c OledTerminal::OledTerminal()
00010d98  w    F .text	00000064 Gpio::SetLow()
00019de8  w    O .text	00000024 vtable for Lpc40xxSystemController
00018134  w    F .text	00000418 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)
0001c110  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
00019c4c  w    O .text	00000016 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file
0001486c g     F .text	0000001a SystemInit
00013b8c  w    F .text	00000134 Timer::Initialize(unsigned long, void (*)(), long)
10000a78 g     O .bss	000007c8 oled_terminal
00011634  w    F .text	00000030 Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)
20008000 g       *ABS*	00000000 heap_end
00011c40  w    F .text	000000e4 Ssp::Initialize()
0001adb8  w    O .text	00000038 vtable for Timer
00011ad0  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10000760  w    O .data	00000010 Timer::tim_register
00014ee4  w    F .text	0000006c Ssp0IrqHandler
0001031c g     F .text	00000000 _fini
00014ee4  w    F .text	0000006c UsbactivityIrqHandler
00010dfc  w    F .text	00000044 Gpio::Set(GpioInterface::State)
00014ee4  w    F .text	0000006c Pll0IrqHandler
00015730 g     F .text	00000118 xTaskResumeAll
00011b08  w    F .text	00000054 Pin::Pin(Pin const&)
000100fc g       .text	00000000 data_section_table_end
00014ee4  w    F .text	0000006c CanactivityIrqHandler
00015680 g     F .text	0000009c vTaskStartScheduler
00014ee4  w    F .text	0000006c NmiHandler
00012664  w    F .text	00000068 PixelDisplayInterface::Color_t::Color_t()
0001271c  w    F .text	00000028 PixelDisplayInterface::Update()
00019cc8  w    O .text	00000048 Ssp::kSspPinMatrix
00012ad0  w    F .text	00000054 Ssd1306::SetHorizontalAddressMode()
00010eac  w    F .text	00000078 Gpio::ReadState()
0001c0b0  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
100008e0 g     O .data	00000004 _impure_ptr
00018e6c  w    F .text	000000ac Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
00018d00  w    F .text	00000070 Sd::GetCrc7(unsigned char*, unsigned char)
00012a4c  w    F .text	00000084 Ssd1306::Initialize()
00014ee4  w    F .text	0000006c McpwmIrqHandler
0001030c g       .text	00000000 __preinit_array_end
00014ee4  w    F .text	0000006c WdtIrqHandler
00017a50  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::operator()() const
00018818  w    F .text	000004a0 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)
000114bc  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
000135f4 g     F .text	0000005c Uart2Interrupt()
00019ec0  w    O .text	0000003c vtable for Pin
00012b24  w    F .text	00000038 Ssd1306::Clear()
10000000 g       .data	00000000 _data
00010560  w    F .text	00000074 Pin::SetAsActiveLow(bool)
000116c8  w    F .text	00000030 Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)
000112b4  w    F .text	0000007c Gpio::SetEdgeRising()
0001c090  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
00015bec g     F .text	00000010 vTaskMissedYield
00013b3c  w    F .text	00000030 unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)
1000045c g     O .data	00000300 pincon
10001284  w    O .bss	00000010 Timer::user_timer_isr
000126cc  w    F .text	00000028 PixelDisplayInterface::Enable()
00019c7c  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
10001244  w    O .bss	00000040 Timer::match
00013fd4  w    F .text	0000004c Uart::Send(unsigned char)::{lambda()#1}::operator()() const
00015848 g     F .text	00000158 xTaskIncrementTick
00019d48  w    O .text	0000002c vtable for PixelDisplayInterface
00017d20  w    F .text	0000031c Sd::Mount(SdInterface::CardInfo_t*)
100008dc g     O .data	00000004 __cxxabiv1::__terminate_handler
10000a74 g     O .bss	00000001 pc
00015ee8 g     F .text	000000b4 xQueueGenericReset
00019e0c  w    O .text	00000024 vtable for SystemControllerInterface
00019e30  w    O .text	00000048 vtable for Gpio
10000944 g       .data	00000000 _edata
0001ad28  w    O .text	00000010 Timer::kPowerbit
000148f4  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)1>()
000104ec  w    F .text	00000074 Pin::EnableHysteresis(bool)
00010b48  w    F .text	00000034 GpioInterface::GpioInterface()
000125d0  w    F .text	00000094 PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)
00014ee4  w    F .text	0000006c DebugMonHandler
00010fc0  w    F .text	0000007c Gpio::ValidPortCheck()
00015422 g     F .text	0000008e xTaskCreate
00014ee4  w    F .text	0000006c Eint2IrqHandler
20008000 g       *ABS*	00000000 __top_RamPeriph32
00011b5c  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
00014ee4  w    F .text	0000006c Timer3IrqHandler
00012744  w    F .text	00000034 PixelDisplayInterface::PixelDisplayInterface()
10000000 g       *ABS*	00000000 __base_RAM
00014ee4  w    F .text	0000006c Eint3IrqHandler
00018f96 g     F .text	00000008 __cxxabiv1::__terminate(void (*)())
00014724  w    F .text	0000002c unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])
0001509c g     F .text	00000030 _kill
00014ee4  w    F .text	0000006c I2c0IrqHandler
00011b08  w    F .text	00000054 Pin::Pin(Pin const&)
0001ad4c  w    O .text	0000000a Timer::Initialize(unsigned long, void (*)(), long)::file
000139a4  w    F .text	00000034 SystemTimer::SystemTimerHandler()
0001c098  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001c2c8 g     O .text	00000020 __sf_fake_stdout
000109d4  w    F .text	00000100 debug::PrintBacktrace(bool, void*)
0001030c g       .text	00000000 __init_array_start
000193b8  w    F .text	00000002 .hidden __aeabi_idiv0
0001c14c  w    O .text	0000002c vtable for SdInterface
00017c70  w    F .text	000000b0 Sd::Initialize()
00015060 g     F .text	00000018 _exit
000106cc  w    F .text	00000074 Pin::EnableFastMode(bool)
00014af8  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()
00014ee4  w    F .text	0000006c Eint0IrqHandler
00013a0c  w    F .text	0000009c SystemTimer::StartTimer()
00011e94  w    F .text	00000030 unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)
0001642c g     F .text	00000060 pxPortInitialiseStack
0001019c g     F .text	00000060 InitBssSection()
100016b4 g     O .bss	00000004 __malloc_sbrk_start
00010b7c  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
000146e4 g     F .text	00000040 UptimeRTOS
00012744  w    F .text	00000034 PixelDisplayInterface::PixelDisplayInterface()
00012f18  w    F .text	0000004c Graphics::Initialize()
00010830  w    F .text	00000074 Pin::SetAsOpenDrain(bool)
00016564 g     F .text	00000028 vPortEnterCritical
0001adf0  w    O .text	00000038 vtable for SystemTimer
00014ee4  w    F .text	0000006c SpiIrqHandler
0001c0d0  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
100016b0 g     O .bss	00000004 __malloc_free_list
00011e08  w    F .text	0000005c Ssp::SetSpiMasterDefault()
10000780  w    O .data	00000040 Uart::pairs
000114a4  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
00011664  w    F .text	00000030 Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)
00017b9c  w    F .text	00000034 SdInterface::SdInterface()
0001030c g       .text	00000000 __preinit_array_start
100008d0  w    O .data	00000004 heap_position
00019c94  w    O .text	00000016 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file
00011694  w    F .text	00000034 Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)
10001434  w    O .bss	00000004 guard variable for Timer::match
00011ef4  w    F .text	0000020c Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)
000103f4  w    F .text	00000078 Pin::SetPinFunction(unsigned char)
00012ddc  w    F .text	00000074 unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)
00010368  w    F .text	00000034 PinInterface::PinInterface()
00011570  w    F .text	00000058 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)
00010b7c  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
0001496c  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)3>()
0001961c g     F .text	00000010 raise
00019424 g     F .text	00000010 free
000137b8 g     F .text	000000c0 pinconn::uart2_txd(unsigned char, unsigned char)



Disassembly of section .text:

00010000 <kInterruptVectorTable>:
   10000:	00 00 01 10 89 48 01 00 e5 4e 01 00 19 02 01 00     .....H...N......
   10010:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 ca 79 f7 ef     .N...N...N...y..
	...
   1002c:	c1 64 01 00 e5 4e 01 00 00 00 00 00 c1 65 01 00     .d...N.......e..
   1003c:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   1004c:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   1005c:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   1006c:	e5 4e 01 00 e5 4e 01 00 00 00 00 00 e5 4e 01 00     .N...N.......N..
   1007c:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   1008c:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   1009c:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   100ac:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   100bc:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   100cc:	e5 4e 01 00 e5 4e 01 00 e5 4e 01 00 e5 4e 01 00     .N...N...N...N..
   100dc:	e5 4e 01 00 e5 4e 01 00                             .N...N..

000100e4 <data_section_table>:
   100e4:	0001c2f0 	.word	0x0001c2f0
   100e8:	10000000 	.word	0x10000000
   100ec:	00000944 	.word	0x00000944
   100f0:	0001c2f0 	.word	0x0001c2f0
   100f4:	20000000 	.word	0x20000000
   100f8:	00000000 	.word	0x00000000

000100fc <bss_section_table>:
   100fc:	10000948 	.word	0x10000948
   10100:	00000d74 	.word	0x00000d74
   10104:	20000000 	.word	0x20000000
   10108:	00000000 	.word	0x00000000

0001010c <InitDataSection()>:
SJ2_IGNORE_STACK_TRACE(void SystemInit());

// Functions to carry out the initialization of RW and BSS data sections.
SJ2_SECTION(".after_vectors")
void InitDataSection()
{
   1010c:	b086      	sub	sp, #24
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   1010e:	2300      	movs	r3, #0
   10110:	9305      	str	r3, [sp, #20]
   10112:	9a05      	ldr	r2, [sp, #20]
   10114:	4613      	mov	r3, r2
   10116:	005b      	lsls	r3, r3, #1
   10118:	4413      	add	r3, r2
   1011a:	009b      	lsls	r3, r3, #2
   1011c:	4a1d      	ldr	r2, [pc, #116]	; (10194 <InitDataSection()+0x88>)
   1011e:	4413      	add	r3, r2
   10120:	4a1d      	ldr	r2, [pc, #116]	; (10198 <InitDataSection()+0x8c>)
   10122:	4293      	cmp	r3, r2
   10124:	d233      	bcs.n	1018e <InitDataSection()+0x82>
  {
    uint32_t * rom_location = data_section_table[i].rom_location;
   10126:	491b      	ldr	r1, [pc, #108]	; (10194 <InitDataSection()+0x88>)
   10128:	9a05      	ldr	r2, [sp, #20]
   1012a:	4613      	mov	r3, r2
   1012c:	005b      	lsls	r3, r3, #1
   1012e:	4413      	add	r3, r2
   10130:	009b      	lsls	r3, r3, #2
   10132:	440b      	add	r3, r1
   10134:	681b      	ldr	r3, [r3, #0]
   10136:	9303      	str	r3, [sp, #12]
    uint32_t * ram_location = data_section_table[i].ram_location;
   10138:	4916      	ldr	r1, [pc, #88]	; (10194 <InitDataSection()+0x88>)
   1013a:	9a05      	ldr	r2, [sp, #20]
   1013c:	4613      	mov	r3, r2
   1013e:	005b      	lsls	r3, r3, #1
   10140:	4413      	add	r3, r2
   10142:	009b      	lsls	r3, r3, #2
   10144:	440b      	add	r3, r1
   10146:	685b      	ldr	r3, [r3, #4]
   10148:	9302      	str	r3, [sp, #8]
    uint32_t length         = data_section_table[i].length;
   1014a:	4912      	ldr	r1, [pc, #72]	; (10194 <InitDataSection()+0x88>)
   1014c:	9a05      	ldr	r2, [sp, #20]
   1014e:	4613      	mov	r3, r2
   10150:	005b      	lsls	r3, r3, #1
   10152:	4413      	add	r3, r2
   10154:	009b      	lsls	r3, r3, #2
   10156:	440b      	add	r3, r1
   10158:	3308      	adds	r3, #8
   1015a:	681b      	ldr	r3, [r3, #0]
   1015c:	9301      	str	r3, [sp, #4]
    for (size_t j = 0; j < length; j++)
   1015e:	2300      	movs	r3, #0
   10160:	9304      	str	r3, [sp, #16]
   10162:	9a04      	ldr	r2, [sp, #16]
   10164:	9b01      	ldr	r3, [sp, #4]
   10166:	429a      	cmp	r2, r3
   10168:	d20d      	bcs.n	10186 <InitDataSection()+0x7a>
    {
      ram_location[j] = rom_location[j];
   1016a:	9b04      	ldr	r3, [sp, #16]
   1016c:	009b      	lsls	r3, r3, #2
   1016e:	9a03      	ldr	r2, [sp, #12]
   10170:	441a      	add	r2, r3
   10172:	9b04      	ldr	r3, [sp, #16]
   10174:	009b      	lsls	r3, r3, #2
   10176:	9902      	ldr	r1, [sp, #8]
   10178:	440b      	add	r3, r1
   1017a:	6812      	ldr	r2, [r2, #0]
   1017c:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   1017e:	9b04      	ldr	r3, [sp, #16]
   10180:	3301      	adds	r3, #1
   10182:	9304      	str	r3, [sp, #16]
   10184:	e7ed      	b.n	10162 <InitDataSection()+0x56>
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   10186:	9b05      	ldr	r3, [sp, #20]
   10188:	3301      	adds	r3, #1
   1018a:	9305      	str	r3, [sp, #20]
   1018c:	e7c1      	b.n	10112 <InitDataSection()+0x6>
    }
  }
}
   1018e:	bf00      	nop
   10190:	b006      	add	sp, #24
   10192:	4770      	bx	lr
   10194:	000100e4 	.word	0x000100e4
   10198:	000100fc 	.word	0x000100fc

0001019c <InitBssSection()>:

// Functions to initialization BSS data sections. This is important because
// the std c libs assume that BSS is set to zero.
SJ2_SECTION(".after_vectors")
void InitBssSection()
{
   1019c:	b084      	sub	sp, #16
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   1019e:	2300      	movs	r3, #0
   101a0:	9303      	str	r3, [sp, #12]
   101a2:	9b03      	ldr	r3, [sp, #12]
   101a4:	00db      	lsls	r3, r3, #3
   101a6:	4a13      	ldr	r2, [pc, #76]	; (101f4 <InitBssSection()+0x58>)
   101a8:	4413      	add	r3, r2
   101aa:	4a13      	ldr	r2, [pc, #76]	; (101f8 <InitBssSection()+0x5c>)
   101ac:	4293      	cmp	r3, r2
   101ae:	d21e      	bcs.n	101ee <InitBssSection()+0x52>
  {
    uint32_t * ram_location = bss_section_table[i].ram_location;
   101b0:	4a10      	ldr	r2, [pc, #64]	; (101f4 <InitBssSection()+0x58>)
   101b2:	9b03      	ldr	r3, [sp, #12]
   101b4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   101b8:	9301      	str	r3, [sp, #4]
    uint32_t length         = bss_section_table[i].length;
   101ba:	4a0e      	ldr	r2, [pc, #56]	; (101f4 <InitBssSection()+0x58>)
   101bc:	9b03      	ldr	r3, [sp, #12]
   101be:	00db      	lsls	r3, r3, #3
   101c0:	4413      	add	r3, r2
   101c2:	685b      	ldr	r3, [r3, #4]
   101c4:	9300      	str	r3, [sp, #0]
    for (size_t j = 0; j < length; j++)
   101c6:	2300      	movs	r3, #0
   101c8:	9302      	str	r3, [sp, #8]
   101ca:	9a02      	ldr	r2, [sp, #8]
   101cc:	9b00      	ldr	r3, [sp, #0]
   101ce:	429a      	cmp	r2, r3
   101d0:	d209      	bcs.n	101e6 <InitBssSection()+0x4a>
    {
      ram_location[j] = 0;
   101d2:	9b02      	ldr	r3, [sp, #8]
   101d4:	009b      	lsls	r3, r3, #2
   101d6:	9a01      	ldr	r2, [sp, #4]
   101d8:	4413      	add	r3, r2
   101da:	2200      	movs	r2, #0
   101dc:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   101de:	9b02      	ldr	r3, [sp, #8]
   101e0:	3301      	adds	r3, #1
   101e2:	9302      	str	r3, [sp, #8]
   101e4:	e7f1      	b.n	101ca <InitBssSection()+0x2e>
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101e6:	9b03      	ldr	r3, [sp, #12]
   101e8:	3301      	adds	r3, #1
   101ea:	9303      	str	r3, [sp, #12]
   101ec:	e7d9      	b.n	101a2 <InitBssSection()+0x6>
    }
  }
}
   101ee:	bf00      	nop
   101f0:	b004      	add	sp, #16
   101f2:	4770      	bx	lr
   101f4:	000100fc 	.word	0x000100fc
   101f8:	0001010c 	.word	0x0001010c

000101fc <InitFpu()>:
      // Write back the modified value to the CPACR
      "STR     R1, [R0]\n"
      // Wait for store to complete
      "DSB\n"
      // reset pipeline now the FPU is enabled
      "ISB\n");
   101fc:	f8df 0014 	ldr.w	r0, [pc, #20]	; 10214 <InitFpu()+0x18>
   10200:	6801      	ldr	r1, [r0, #0]
   10202:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   10206:	6001      	str	r1, [r0, #0]
   10208:	f3bf 8f4f 	dsb	sy
   1020c:	f3bf 8f6f 	isb	sy
}
   10210:	bf00      	nop
   10212:	4770      	bx	lr
   10214:	e000ed88 	.word	0xe000ed88

00010218 <HardFaultHandler>:
      " mrseq r0, msp                                       \n"
      " mrsne r0, psp                                       \n"
      " ldr r1, [r0, #24]                                   \n"
      " ldr r2, handler2_address_const                      \n"
      " bx r2                                               \n"
      " handler2_address_const: .word GetRegistersFromStack \n");
   10218:	f01e 0f04 	tst.w	lr, #4
   1021c:	bf0c      	ite	eq
   1021e:	f3ef 8008 	mrseq	r0, MSP
   10222:	f3ef 8009 	mrsne	r0, PSP
   10226:	6981      	ldr	r1, [r0, #24]
   10228:	4a00      	ldr	r2, [pc, #0]	; (1022c <handler2_address_const>)
   1022a:	4710      	bx	r2

0001022c <handler2_address_const>:
   1022c:	00014fad 	.word	0x00014fad
#endif
}
   10230:	bf00      	nop
   10232:	4770      	bx	lr
   10234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1023c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1024c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1025c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000102fc <__CRP_WORD_START__>:
   102fc:	ffffffff 	.word	0xffffffff

00010300 <_init>:
   10300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10302:	bf00      	nop
   10304:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10306:	bc08      	pop	{r3}
   10308:	469e      	mov	lr, r3
   1030a:	4770      	bx	lr

0001030c <__init_array_start>:
   1030c:	0001034d 	.word	0x0001034d
   10310:	0001372d 	.word	0x0001372d
   10314:	00014e55 	.word	0x00014e55
   10318:	00018f69 	.word	0x00018f69

0001031c <_fini>:
   1031c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1031e:	bf00      	nop
   10320:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10322:	bc08      	pop	{r3}
   10324:	469e      	mov	lr, r3
   10326:	4770      	bx	lr

00010328 <__do_global_dtors_aux>:
   10328:	b510      	push	{r4, lr}
   1032a:	4c05      	ldr	r4, [pc, #20]	; (10340 <__do_global_dtors_aux+0x18>)
   1032c:	7823      	ldrb	r3, [r4, #0]
   1032e:	b933      	cbnz	r3, 1033e <__do_global_dtors_aux+0x16>
   10330:	4b04      	ldr	r3, [pc, #16]	; (10344 <__do_global_dtors_aux+0x1c>)
   10332:	b113      	cbz	r3, 1033a <__do_global_dtors_aux+0x12>
   10334:	4804      	ldr	r0, [pc, #16]	; (10348 <__do_global_dtors_aux+0x20>)
   10336:	f3af 8000 	nop.w
   1033a:	2301      	movs	r3, #1
   1033c:	7023      	strb	r3, [r4, #0]
   1033e:	bd10      	pop	{r4, pc}
   10340:	10000948 	.word	0x10000948
   10344:	00000000 	.word	0x00000000
   10348:	0001c2f0 	.word	0x0001c2f0

0001034c <frame_dummy>:
   1034c:	b508      	push	{r3, lr}
   1034e:	4b03      	ldr	r3, [pc, #12]	; (1035c <frame_dummy+0x10>)
   10350:	b11b      	cbz	r3, 1035a <frame_dummy+0xe>
   10352:	4903      	ldr	r1, [pc, #12]	; (10360 <frame_dummy+0x14>)
   10354:	4803      	ldr	r0, [pc, #12]	; (10364 <frame_dummy+0x18>)
   10356:	f3af 8000 	nop.w
   1035a:	bd08      	pop	{r3, pc}
   1035c:	00000000 	.word	0x00000000
   10360:	1000094c 	.word	0x1000094c
   10364:	0001c2f0 	.word	0x0001c2f0

00010368 <PinInterface::PinInterface()>:
#include <cstdio>

#include "L0_LowLevel/LPC40xx.h"
#include "utility/macros.hpp"

class PinInterface
   10368:	b530      	push	{r4, r5, lr}
   1036a:	b083      	sub	sp, #12
   1036c:	4675      	mov	r5, lr
   1036e:	9001      	str	r0, [sp, #4]
   10370:	462b      	mov	r3, r5
   10372:	4619      	mov	r1, r3
   10374:	4807      	ldr	r0, [pc, #28]	; (10394 <PinInterface::PinInterface()+0x2c>)
   10376:	f004 ff3f 	bl	151f8 <__cyg_profile_func_enter>
   1037a:	4a07      	ldr	r2, [pc, #28]	; (10398 <PinInterface::PinInterface()+0x30>)
   1037c:	9b01      	ldr	r3, [sp, #4]
   1037e:	601a      	str	r2, [r3, #0]
   10380:	9c01      	ldr	r4, [sp, #4]
   10382:	462b      	mov	r3, r5
   10384:	4619      	mov	r1, r3
   10386:	4803      	ldr	r0, [pc, #12]	; (10394 <PinInterface::PinInterface()+0x2c>)
   10388:	f004 ff4a 	bl	15220 <__cyg_profile_func_exit>
   1038c:	4623      	mov	r3, r4
   1038e:	4618      	mov	r0, r3
   10390:	b003      	add	sp, #12
   10392:	bd30      	pop	{r4, r5, pc}
   10394:	00010369 	.word	0x00010369
   10398:	00019f04 	.word	0x00019f04

0001039c <Pin::Pin(unsigned char, unsigned char)>:
  // no effect.
  static constexpr Pin CreateInactivePin()
  {
    return Pin(5, 4);
  }
  constexpr Pin(uint8_t port_number, uint8_t pin_number)
   1039c:	b530      	push	{r4, r5, lr}
   1039e:	b083      	sub	sp, #12
   103a0:	4675      	mov	r5, lr
   103a2:	9001      	str	r0, [sp, #4]
   103a4:	460b      	mov	r3, r1
   103a6:	f88d 3003 	strb.w	r3, [sp, #3]
   103aa:	4613      	mov	r3, r2
   103ac:	f88d 3002 	strb.w	r3, [sp, #2]
   103b0:	462b      	mov	r3, r5
   103b2:	4619      	mov	r1, r3
   103b4:	480d      	ldr	r0, [pc, #52]	; (103ec <Pin::Pin(unsigned char, unsigned char)+0x50>)
   103b6:	f004 ff1f 	bl	151f8 <__cyg_profile_func_enter>
      : port_(port_number), pin_(pin_number)
   103ba:	9b01      	ldr	r3, [sp, #4]
   103bc:	4618      	mov	r0, r3
   103be:	f7ff ffd3 	bl	10368 <PinInterface::PinInterface()>
   103c2:	4a0b      	ldr	r2, [pc, #44]	; (103f0 <Pin::Pin(unsigned char, unsigned char)+0x54>)
   103c4:	9b01      	ldr	r3, [sp, #4]
   103c6:	601a      	str	r2, [r3, #0]
   103c8:	9b01      	ldr	r3, [sp, #4]
   103ca:	f89d 2003 	ldrb.w	r2, [sp, #3]
   103ce:	711a      	strb	r2, [r3, #4]
   103d0:	9b01      	ldr	r3, [sp, #4]
   103d2:	f89d 2002 	ldrb.w	r2, [sp, #2]
   103d6:	715a      	strb	r2, [r3, #5]
  {
  }
   103d8:	9c01      	ldr	r4, [sp, #4]
   103da:	462b      	mov	r3, r5
   103dc:	4619      	mov	r1, r3
   103de:	4803      	ldr	r0, [pc, #12]	; (103ec <Pin::Pin(unsigned char, unsigned char)+0x50>)
   103e0:	f004 ff1e 	bl	15220 <__cyg_profile_func_exit>
   103e4:	4623      	mov	r3, r4
   103e6:	4618      	mov	r0, r3
   103e8:	b003      	add	sp, #12
   103ea:	bd30      	pop	{r4, r5, pc}
   103ec:	0001039d 	.word	0x0001039d
   103f0:	00019ec8 	.word	0x00019ec8

000103f4 <Pin::SetPinFunction(unsigned char)>:
  void SetPinFunction(uint8_t function) override
   103f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   103f6:	b085      	sub	sp, #20
   103f8:	4677      	mov	r7, lr
   103fa:	9003      	str	r0, [sp, #12]
   103fc:	460b      	mov	r3, r1
   103fe:	f88d 300b 	strb.w	r3, [sp, #11]
   10402:	463b      	mov	r3, r7
   10404:	4619      	mov	r1, r3
   10406:	4817      	ldr	r0, [pc, #92]	; (10464 <Pin::SetPinFunction(unsigned char)+0x70>)
   10408:	f004 fef6 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   1040c:	4b16      	ldr	r3, [pc, #88]	; (10468 <Pin::SetPinFunction(unsigned char)+0x74>)
   1040e:	681b      	ldr	r3, [r3, #0]
   10410:	9a03      	ldr	r2, [sp, #12]
   10412:	7912      	ldrb	r2, [r2, #4]
   10414:	4610      	mov	r0, r2
   10416:	9a03      	ldr	r2, [sp, #12]
   10418:	7952      	ldrb	r2, [r2, #5]
   1041a:	4611      	mov	r1, r2
   1041c:	0142      	lsls	r2, r0, #5
   1041e:	440a      	add	r2, r1
   10420:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 function & 0b111, 3);
   10424:	f89d 300b 	ldrb.w	r3, [sp, #11]
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   10428:	f003 0207 	and.w	r2, r3, #7
    pin_map->_register[port_][pin_] =
   1042c:	4b0e      	ldr	r3, [pc, #56]	; (10468 <Pin::SetPinFunction(unsigned char)+0x74>)
   1042e:	681c      	ldr	r4, [r3, #0]
   10430:	9b03      	ldr	r3, [sp, #12]
   10432:	791b      	ldrb	r3, [r3, #4]
   10434:	461e      	mov	r6, r3
   10436:	9b03      	ldr	r3, [sp, #12]
   10438:	795b      	ldrb	r3, [r3, #5]
   1043a:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   1043c:	2303      	movs	r3, #3
   1043e:	9300      	str	r3, [sp, #0]
   10440:	4613      	mov	r3, r2
   10442:	2200      	movs	r2, #0
   10444:	9803      	ldr	r0, [sp, #12]
   10446:	f000 fa67 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1044a:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   1044c:	0173      	lsls	r3, r6, #5
   1044e:	442b      	add	r3, r5
   10450:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10454:	463b      	mov	r3, r7
   10456:	4619      	mov	r1, r3
   10458:	4802      	ldr	r0, [pc, #8]	; (10464 <Pin::SetPinFunction(unsigned char)+0x70>)
   1045a:	f004 fee1 	bl	15220 <__cyg_profile_func_exit>
  }
   1045e:	bf00      	nop
   10460:	b005      	add	sp, #20
   10462:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10464:	000103f5 	.word	0x000103f5
   10468:	10000000 	.word	0x10000000

0001046c <Pin::SetMode(PinInterface::Mode)>:
  void SetMode(PinInterface::Mode mode) override
   1046c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1046e:	b087      	sub	sp, #28
   10470:	4677      	mov	r7, lr
   10472:	9003      	str	r0, [sp, #12]
   10474:	460b      	mov	r3, r1
   10476:	f88d 300b 	strb.w	r3, [sp, #11]
   1047a:	463b      	mov	r3, r7
   1047c:	4619      	mov	r1, r3
   1047e:	4819      	ldr	r0, [pc, #100]	; (104e4 <Pin::SetMode(PinInterface::Mode)+0x78>)
   10480:	f004 feba 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint8_t ui_mode                 = static_cast<uint8_t>(mode);
   10484:	f89d 300b 	ldrb.w	r3, [sp, #11]
   10488:	f88d 3017 	strb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   1048c:	4b16      	ldr	r3, [pc, #88]	; (104e8 <Pin::SetMode(PinInterface::Mode)+0x7c>)
   1048e:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   10490:	9a03      	ldr	r2, [sp, #12]
   10492:	7912      	ldrb	r2, [r2, #4]
   10494:	4610      	mov	r0, r2
   10496:	9a03      	ldr	r2, [sp, #12]
   10498:	7952      	ldrb	r2, [r2, #5]
   1049a:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   1049c:	0142      	lsls	r2, r0, #5
   1049e:	440a      	add	r2, r1
   104a0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   104a4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   104a8:	f003 0203 	and.w	r2, r3, #3
   104ac:	4b0e      	ldr	r3, [pc, #56]	; (104e8 <Pin::SetMode(PinInterface::Mode)+0x7c>)
   104ae:	681c      	ldr	r4, [r3, #0]
   104b0:	9b03      	ldr	r3, [sp, #12]
   104b2:	791b      	ldrb	r3, [r3, #4]
   104b4:	461e      	mov	r6, r3
   104b6:	9b03      	ldr	r3, [sp, #12]
   104b8:	795b      	ldrb	r3, [r3, #5]
   104ba:	461d      	mov	r5, r3
   104bc:	2302      	movs	r3, #2
   104be:	9300      	str	r3, [sp, #0]
   104c0:	4613      	mov	r3, r2
   104c2:	2203      	movs	r2, #3
   104c4:	9803      	ldr	r0, [sp, #12]
   104c6:	f000 fa27 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   104ca:	4602      	mov	r2, r0
   104cc:	0173      	lsls	r3, r6, #5
   104ce:	442b      	add	r3, r5
   104d0:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   104d4:	463b      	mov	r3, r7
   104d6:	4619      	mov	r1, r3
   104d8:	4802      	ldr	r0, [pc, #8]	; (104e4 <Pin::SetMode(PinInterface::Mode)+0x78>)
   104da:	f004 fea1 	bl	15220 <__cyg_profile_func_exit>
  }
   104de:	bf00      	nop
   104e0:	b007      	add	sp, #28
   104e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   104e4:	0001046d 	.word	0x0001046d
   104e8:	10000000 	.word	0x10000000

000104ec <Pin::EnableHysteresis(bool)>:
  void EnableHysteresis(bool enable_hysteresis = true) override
   104ec:	b5f0      	push	{r4, r5, r6, r7, lr}
   104ee:	b085      	sub	sp, #20
   104f0:	4677      	mov	r7, lr
   104f2:	9003      	str	r0, [sp, #12]
   104f4:	460b      	mov	r3, r1
   104f6:	f88d 300b 	strb.w	r3, [sp, #11]
   104fa:	463b      	mov	r3, r7
   104fc:	4619      	mov	r1, r3
   104fe:	4816      	ldr	r0, [pc, #88]	; (10558 <Pin::EnableHysteresis(bool)+0x6c>)
   10500:	f004 fe7a 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   10504:	4b15      	ldr	r3, [pc, #84]	; (1055c <Pin::EnableHysteresis(bool)+0x70>)
   10506:	681b      	ldr	r3, [r3, #0]
   10508:	9a03      	ldr	r2, [sp, #12]
   1050a:	7912      	ldrb	r2, [r2, #4]
   1050c:	4610      	mov	r0, r2
   1050e:	9a03      	ldr	r2, [sp, #12]
   10510:	7952      	ldrb	r2, [r2, #5]
   10512:	4611      	mov	r1, r2
   10514:	0142      	lsls	r2, r0, #5
   10516:	440a      	add	r2, r1
   10518:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   1051c:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   10520:	4b0e      	ldr	r3, [pc, #56]	; (1055c <Pin::EnableHysteresis(bool)+0x70>)
   10522:	681c      	ldr	r4, [r3, #0]
   10524:	9b03      	ldr	r3, [sp, #12]
   10526:	791b      	ldrb	r3, [r3, #4]
   10528:	461e      	mov	r6, r3
   1052a:	9b03      	ldr	r3, [sp, #12]
   1052c:	795b      	ldrb	r3, [r3, #5]
   1052e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   10530:	2301      	movs	r3, #1
   10532:	9300      	str	r3, [sp, #0]
   10534:	4613      	mov	r3, r2
   10536:	2205      	movs	r2, #5
   10538:	9803      	ldr	r0, [sp, #12]
   1053a:	f000 f9ed 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1053e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10540:	0173      	lsls	r3, r6, #5
   10542:	442b      	add	r3, r5
   10544:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10548:	463b      	mov	r3, r7
   1054a:	4619      	mov	r1, r3
   1054c:	4802      	ldr	r0, [pc, #8]	; (10558 <Pin::EnableHysteresis(bool)+0x6c>)
   1054e:	f004 fe67 	bl	15220 <__cyg_profile_func_exit>
                 enable_hysteresis, 1);
  }
   10552:	bf00      	nop
   10554:	b005      	add	sp, #20
   10556:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10558:	000104ed 	.word	0x000104ed
   1055c:	10000000 	.word	0x10000000

00010560 <Pin::SetAsActiveLow(bool)>:
  void SetAsActiveLow(bool set_as_active_low = true) override
   10560:	b5f0      	push	{r4, r5, r6, r7, lr}
   10562:	b085      	sub	sp, #20
   10564:	4677      	mov	r7, lr
   10566:	9003      	str	r0, [sp, #12]
   10568:	460b      	mov	r3, r1
   1056a:	f88d 300b 	strb.w	r3, [sp, #11]
   1056e:	463b      	mov	r3, r7
   10570:	4619      	mov	r1, r3
   10572:	4816      	ldr	r0, [pc, #88]	; (105cc <Pin::SetAsActiveLow(bool)+0x6c>)
   10574:	f004 fe40 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   10578:	4b15      	ldr	r3, [pc, #84]	; (105d0 <Pin::SetAsActiveLow(bool)+0x70>)
   1057a:	681b      	ldr	r3, [r3, #0]
   1057c:	9a03      	ldr	r2, [sp, #12]
   1057e:	7912      	ldrb	r2, [r2, #4]
   10580:	4610      	mov	r0, r2
   10582:	9a03      	ldr	r2, [sp, #12]
   10584:	7952      	ldrb	r2, [r2, #5]
   10586:	4611      	mov	r1, r2
   10588:	0142      	lsls	r2, r0, #5
   1058a:	440a      	add	r2, r1
   1058c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   10590:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   10594:	4b0e      	ldr	r3, [pc, #56]	; (105d0 <Pin::SetAsActiveLow(bool)+0x70>)
   10596:	681c      	ldr	r4, [r3, #0]
   10598:	9b03      	ldr	r3, [sp, #12]
   1059a:	791b      	ldrb	r3, [r3, #4]
   1059c:	461e      	mov	r6, r3
   1059e:	9b03      	ldr	r3, [sp, #12]
   105a0:	795b      	ldrb	r3, [r3, #5]
   105a2:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   105a4:	2301      	movs	r3, #1
   105a6:	9300      	str	r3, [sp, #0]
   105a8:	4613      	mov	r3, r2
   105aa:	2206      	movs	r2, #6
   105ac:	9803      	ldr	r0, [sp, #12]
   105ae:	f000 f9b3 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   105b2:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   105b4:	0173      	lsls	r3, r6, #5
   105b6:	442b      	add	r3, r5
   105b8:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   105bc:	463b      	mov	r3, r7
   105be:	4619      	mov	r1, r3
   105c0:	4802      	ldr	r0, [pc, #8]	; (105cc <Pin::SetAsActiveLow(bool)+0x6c>)
   105c2:	f004 fe2d 	bl	15220 <__cyg_profile_func_exit>
                 set_as_active_low, 1);
  }
   105c6:	bf00      	nop
   105c8:	b005      	add	sp, #20
   105ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
   105cc:	00010561 	.word	0x00010561
   105d0:	10000000 	.word	0x10000000

000105d4 <Pin::SetAsAnalogMode(bool)>:
  // Set bit to 0 to enable analog mode
  void SetAsAnalogMode(bool set_as_analog = true) override
   105d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   105d6:	b085      	sub	sp, #20
   105d8:	4677      	mov	r7, lr
   105da:	9003      	str	r0, [sp, #12]
   105dc:	460b      	mov	r3, r1
   105de:	f88d 300b 	strb.w	r3, [sp, #11]
   105e2:	463b      	mov	r3, r7
   105e4:	4619      	mov	r1, r3
   105e6:	4818      	ldr	r0, [pc, #96]	; (10648 <Pin::SetAsAnalogMode(bool)+0x74>)
   105e8:	f004 fe06 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   105ec:	4b17      	ldr	r3, [pc, #92]	; (1064c <Pin::SetAsAnalogMode(bool)+0x78>)
   105ee:	681b      	ldr	r3, [r3, #0]
   105f0:	9a03      	ldr	r2, [sp, #12]
   105f2:	7912      	ldrb	r2, [r2, #4]
   105f4:	4610      	mov	r0, r2
   105f6:	9a03      	ldr	r2, [sp, #12]
   105f8:	7952      	ldrb	r2, [r2, #5]
   105fa:	4611      	mov	r1, r2
   105fc:	0142      	lsls	r2, r0, #5
   105fe:	440a      	add	r2, r1
   10600:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !set_as_analog, 1);
   10604:	f89d 300b 	ldrb.w	r3, [sp, #11]
   10608:	f083 0301 	eor.w	r3, r3, #1
   1060c:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   1060e:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   10610:	4b0e      	ldr	r3, [pc, #56]	; (1064c <Pin::SetAsAnalogMode(bool)+0x78>)
   10612:	681c      	ldr	r4, [r3, #0]
   10614:	9b03      	ldr	r3, [sp, #12]
   10616:	791b      	ldrb	r3, [r3, #4]
   10618:	461e      	mov	r6, r3
   1061a:	9b03      	ldr	r3, [sp, #12]
   1061c:	795b      	ldrb	r3, [r3, #5]
   1061e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   10620:	2301      	movs	r3, #1
   10622:	9300      	str	r3, [sp, #0]
   10624:	4613      	mov	r3, r2
   10626:	2207      	movs	r2, #7
   10628:	9803      	ldr	r0, [sp, #12]
   1062a:	f000 f975 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1062e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10630:	0173      	lsls	r3, r6, #5
   10632:	442b      	add	r3, r5
   10634:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10638:	463b      	mov	r3, r7
   1063a:	4619      	mov	r1, r3
   1063c:	4802      	ldr	r0, [pc, #8]	; (10648 <Pin::SetAsAnalogMode(bool)+0x74>)
   1063e:	f004 fdef 	bl	15220 <__cyg_profile_func_exit>
  }
   10642:	bf00      	nop
   10644:	b005      	add	sp, #20
   10646:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10648:	000105d5 	.word	0x000105d5
   1064c:	10000000 	.word	0x10000000

00010650 <Pin::EnableDigitalFilter(bool)>:
  // Enable by setting bit to 0 to enable digital filter.
  void EnableDigitalFilter(bool enable_digital_filter = true) override
   10650:	b5f0      	push	{r4, r5, r6, r7, lr}
   10652:	b085      	sub	sp, #20
   10654:	4677      	mov	r7, lr
   10656:	9003      	str	r0, [sp, #12]
   10658:	460b      	mov	r3, r1
   1065a:	f88d 300b 	strb.w	r3, [sp, #11]
   1065e:	463b      	mov	r3, r7
   10660:	4619      	mov	r1, r3
   10662:	4818      	ldr	r0, [pc, #96]	; (106c4 <Pin::EnableDigitalFilter(bool)+0x74>)
   10664:	f004 fdc8 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   10668:	4b17      	ldr	r3, [pc, #92]	; (106c8 <Pin::EnableDigitalFilter(bool)+0x78>)
   1066a:	681b      	ldr	r3, [r3, #0]
   1066c:	9a03      	ldr	r2, [sp, #12]
   1066e:	7912      	ldrb	r2, [r2, #4]
   10670:	4610      	mov	r0, r2
   10672:	9a03      	ldr	r2, [sp, #12]
   10674:	7952      	ldrb	r2, [r2, #5]
   10676:	4611      	mov	r1, r2
   10678:	0142      	lsls	r2, r0, #5
   1067a:	440a      	add	r2, r1
   1067c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_digital_filter, 1);
   10680:	f89d 300b 	ldrb.w	r3, [sp, #11]
   10684:	f083 0301 	eor.w	r3, r3, #1
   10688:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   1068a:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   1068c:	4b0e      	ldr	r3, [pc, #56]	; (106c8 <Pin::EnableDigitalFilter(bool)+0x78>)
   1068e:	681c      	ldr	r4, [r3, #0]
   10690:	9b03      	ldr	r3, [sp, #12]
   10692:	791b      	ldrb	r3, [r3, #4]
   10694:	461e      	mov	r6, r3
   10696:	9b03      	ldr	r3, [sp, #12]
   10698:	795b      	ldrb	r3, [r3, #5]
   1069a:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   1069c:	2301      	movs	r3, #1
   1069e:	9300      	str	r3, [sp, #0]
   106a0:	4613      	mov	r3, r2
   106a2:	2208      	movs	r2, #8
   106a4:	9803      	ldr	r0, [sp, #12]
   106a6:	f000 f937 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   106aa:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   106ac:	0173      	lsls	r3, r6, #5
   106ae:	442b      	add	r3, r5
   106b0:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   106b4:	463b      	mov	r3, r7
   106b6:	4619      	mov	r1, r3
   106b8:	4802      	ldr	r0, [pc, #8]	; (106c4 <Pin::EnableDigitalFilter(bool)+0x74>)
   106ba:	f004 fdb1 	bl	15220 <__cyg_profile_func_exit>
  }
   106be:	bf00      	nop
   106c0:	b005      	add	sp, #20
   106c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   106c4:	00010651 	.word	0x00010651
   106c8:	10000000 	.word	0x10000000

000106cc <Pin::EnableFastMode(bool)>:
  void EnableFastMode(bool enable_fast_mode = true) override
   106cc:	b5f0      	push	{r4, r5, r6, r7, lr}
   106ce:	b085      	sub	sp, #20
   106d0:	4677      	mov	r7, lr
   106d2:	9003      	str	r0, [sp, #12]
   106d4:	460b      	mov	r3, r1
   106d6:	f88d 300b 	strb.w	r3, [sp, #11]
   106da:	463b      	mov	r3, r7
   106dc:	4619      	mov	r1, r3
   106de:	4816      	ldr	r0, [pc, #88]	; (10738 <Pin::EnableFastMode(bool)+0x6c>)
   106e0:	f004 fd8a 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   106e4:	4b15      	ldr	r3, [pc, #84]	; (1073c <Pin::EnableFastMode(bool)+0x70>)
   106e6:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kSlew, enable_fast_mode, 1);
   106e8:	9a03      	ldr	r2, [sp, #12]
   106ea:	7912      	ldrb	r2, [r2, #4]
   106ec:	4610      	mov	r0, r2
   106ee:	9a03      	ldr	r2, [sp, #12]
   106f0:	7952      	ldrb	r2, [r2, #5]
   106f2:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   106f4:	0142      	lsls	r2, r0, #5
   106f6:	440a      	add	r2, r1
   106f8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   106fc:	f89d 200b 	ldrb.w	r2, [sp, #11]
   10700:	4b0e      	ldr	r3, [pc, #56]	; (1073c <Pin::EnableFastMode(bool)+0x70>)
   10702:	681c      	ldr	r4, [r3, #0]
   10704:	9b03      	ldr	r3, [sp, #12]
   10706:	791b      	ldrb	r3, [r3, #4]
   10708:	461e      	mov	r6, r3
   1070a:	9b03      	ldr	r3, [sp, #12]
   1070c:	795b      	ldrb	r3, [r3, #5]
   1070e:	461d      	mov	r5, r3
   10710:	2301      	movs	r3, #1
   10712:	9300      	str	r3, [sp, #0]
   10714:	4613      	mov	r3, r2
   10716:	2209      	movs	r2, #9
   10718:	9803      	ldr	r0, [sp, #12]
   1071a:	f000 f8fd 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1071e:	4602      	mov	r2, r0
   10720:	0173      	lsls	r3, r6, #5
   10722:	442b      	add	r3, r5
   10724:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10728:	463b      	mov	r3, r7
   1072a:	4619      	mov	r1, r3
   1072c:	4802      	ldr	r0, [pc, #8]	; (10738 <Pin::EnableFastMode(bool)+0x6c>)
   1072e:	f004 fd77 	bl	15220 <__cyg_profile_func_exit>
  }
   10732:	bf00      	nop
   10734:	b005      	add	sp, #20
   10736:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10738:	000106cd 	.word	0x000106cd
   1073c:	10000000 	.word	0x10000000

00010740 <Pin::EnableI2cHighSpeedMode(bool)>:
  // Enable by setting bit to 0 for i2c high speed mode
  void EnableI2cHighSpeedMode(bool enable_high_speed = true) override
   10740:	b5f0      	push	{r4, r5, r6, r7, lr}
   10742:	b085      	sub	sp, #20
   10744:	4677      	mov	r7, lr
   10746:	9003      	str	r0, [sp, #12]
   10748:	460b      	mov	r3, r1
   1074a:	f88d 300b 	strb.w	r3, [sp, #11]
   1074e:	463b      	mov	r3, r7
   10750:	4619      	mov	r1, r3
   10752:	4818      	ldr	r0, [pc, #96]	; (107b4 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   10754:	f004 fd50 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   10758:	4b17      	ldr	r3, [pc, #92]	; (107b8 <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   1075a:	681b      	ldr	r3, [r3, #0]
   1075c:	9a03      	ldr	r2, [sp, #12]
   1075e:	7912      	ldrb	r2, [r2, #4]
   10760:	4610      	mov	r0, r2
   10762:	9a03      	ldr	r2, [sp, #12]
   10764:	7952      	ldrb	r2, [r2, #5]
   10766:	4611      	mov	r1, r2
   10768:	0142      	lsls	r2, r0, #5
   1076a:	440a      	add	r2, r1
   1076c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_high_speed, 1);
   10770:	f89d 300b 	ldrb.w	r3, [sp, #11]
   10774:	f083 0301 	eor.w	r3, r3, #1
   10778:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   1077a:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   1077c:	4b0e      	ldr	r3, [pc, #56]	; (107b8 <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   1077e:	681c      	ldr	r4, [r3, #0]
   10780:	9b03      	ldr	r3, [sp, #12]
   10782:	791b      	ldrb	r3, [r3, #4]
   10784:	461e      	mov	r6, r3
   10786:	9b03      	ldr	r3, [sp, #12]
   10788:	795b      	ldrb	r3, [r3, #5]
   1078a:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   1078c:	2301      	movs	r3, #1
   1078e:	9300      	str	r3, [sp, #0]
   10790:	4613      	mov	r3, r2
   10792:	2208      	movs	r2, #8
   10794:	9803      	ldr	r0, [sp, #12]
   10796:	f000 f8bf 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1079a:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   1079c:	0173      	lsls	r3, r6, #5
   1079e:	442b      	add	r3, r5
   107a0:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   107a4:	463b      	mov	r3, r7
   107a6:	4619      	mov	r1, r3
   107a8:	4802      	ldr	r0, [pc, #8]	; (107b4 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   107aa:	f004 fd39 	bl	15220 <__cyg_profile_func_exit>
  }
   107ae:	bf00      	nop
   107b0:	b005      	add	sp, #20
   107b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   107b4:	00010741 	.word	0x00010741
   107b8:	10000000 	.word	0x10000000

000107bc <Pin::EnableI2cHighCurrentDrive(bool)>:
  void EnableI2cHighCurrentDrive(bool enable_high_current = true) override
   107bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   107be:	b085      	sub	sp, #20
   107c0:	4677      	mov	r7, lr
   107c2:	9003      	str	r0, [sp, #12]
   107c4:	460b      	mov	r3, r1
   107c6:	f88d 300b 	strb.w	r3, [sp, #11]
   107ca:	463b      	mov	r3, r7
   107cc:	4619      	mov	r1, r3
   107ce:	4816      	ldr	r0, [pc, #88]	; (10828 <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   107d0:	f004 fd12 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_],
   107d4:	4b15      	ldr	r3, [pc, #84]	; (1082c <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   107d6:	681b      	ldr	r3, [r3, #0]
   107d8:	9a03      	ldr	r2, [sp, #12]
   107da:	7912      	ldrb	r2, [r2, #4]
   107dc:	4610      	mov	r0, r2
   107de:	9a03      	ldr	r2, [sp, #12]
   107e0:	7952      	ldrb	r2, [r2, #5]
   107e2:	4611      	mov	r1, r2
   107e4:	0142      	lsls	r2, r0, #5
   107e6:	440a      	add	r2, r1
   107e8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   107ec:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   107f0:	4b0e      	ldr	r3, [pc, #56]	; (1082c <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   107f2:	681c      	ldr	r4, [r3, #0]
   107f4:	9b03      	ldr	r3, [sp, #12]
   107f6:	791b      	ldrb	r3, [r3, #4]
   107f8:	461e      	mov	r6, r3
   107fa:	9b03      	ldr	r3, [sp, #12]
   107fc:	795b      	ldrb	r3, [r3, #5]
   107fe:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_],
   10800:	2301      	movs	r3, #1
   10802:	9300      	str	r3, [sp, #0]
   10804:	4613      	mov	r3, r2
   10806:	2209      	movs	r2, #9
   10808:	9803      	ldr	r0, [sp, #12]
   1080a:	f000 f885 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1080e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10810:	0173      	lsls	r3, r6, #5
   10812:	442b      	add	r3, r5
   10814:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10818:	463b      	mov	r3, r7
   1081a:	4619      	mov	r1, r3
   1081c:	4802      	ldr	r0, [pc, #8]	; (10828 <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   1081e:	f004 fcff 	bl	15220 <__cyg_profile_func_exit>
                 PinBitMap::kI2cHighCurrentDrive, enable_high_current, 1);
  }
   10822:	bf00      	nop
   10824:	b005      	add	sp, #20
   10826:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10828:	000107bd 	.word	0x000107bd
   1082c:	10000000 	.word	0x10000000

00010830 <Pin::SetAsOpenDrain(bool)>:
  void SetAsOpenDrain(bool set_as_open_drain = true) override
   10830:	b5f0      	push	{r4, r5, r6, r7, lr}
   10832:	b085      	sub	sp, #20
   10834:	4677      	mov	r7, lr
   10836:	9003      	str	r0, [sp, #12]
   10838:	460b      	mov	r3, r1
   1083a:	f88d 300b 	strb.w	r3, [sp, #11]
   1083e:	463b      	mov	r3, r7
   10840:	4619      	mov	r1, r3
   10842:	4816      	ldr	r0, [pc, #88]	; (1089c <Pin::SetAsOpenDrain(bool)+0x6c>)
   10844:	f004 fcd8 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   10848:	4b15      	ldr	r3, [pc, #84]	; (108a0 <Pin::SetAsOpenDrain(bool)+0x70>)
   1084a:	681b      	ldr	r3, [r3, #0]
   1084c:	9a03      	ldr	r2, [sp, #12]
   1084e:	7912      	ldrb	r2, [r2, #4]
   10850:	4610      	mov	r0, r2
   10852:	9a03      	ldr	r2, [sp, #12]
   10854:	7952      	ldrb	r2, [r2, #5]
   10856:	4611      	mov	r1, r2
   10858:	0142      	lsls	r2, r0, #5
   1085a:	440a      	add	r2, r1
   1085c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   10860:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   10864:	4b0e      	ldr	r3, [pc, #56]	; (108a0 <Pin::SetAsOpenDrain(bool)+0x70>)
   10866:	681c      	ldr	r4, [r3, #0]
   10868:	9b03      	ldr	r3, [sp, #12]
   1086a:	791b      	ldrb	r3, [r3, #4]
   1086c:	461e      	mov	r6, r3
   1086e:	9b03      	ldr	r3, [sp, #12]
   10870:	795b      	ldrb	r3, [r3, #5]
   10872:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   10874:	2301      	movs	r3, #1
   10876:	9300      	str	r3, [sp, #0]
   10878:	4613      	mov	r3, r2
   1087a:	220a      	movs	r2, #10
   1087c:	9803      	ldr	r0, [sp, #12]
   1087e:	f000 f84b 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   10882:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   10884:	0173      	lsls	r3, r6, #5
   10886:	442b      	add	r3, r5
   10888:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   1088c:	463b      	mov	r3, r7
   1088e:	4619      	mov	r1, r3
   10890:	4802      	ldr	r0, [pc, #8]	; (1089c <Pin::SetAsOpenDrain(bool)+0x6c>)
   10892:	f004 fcc5 	bl	15220 <__cyg_profile_func_exit>
                 set_as_open_drain, 1);
  }
   10896:	bf00      	nop
   10898:	b005      	add	sp, #20
   1089a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1089c:	00010831 	.word	0x00010831
   108a0:	10000000 	.word	0x10000000

000108a4 <Pin::EnableDac(bool)>:
  void EnableDac(bool enable_dac = true) override
   108a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   108a6:	b085      	sub	sp, #20
   108a8:	4677      	mov	r7, lr
   108aa:	9003      	str	r0, [sp, #12]
   108ac:	460b      	mov	r3, r1
   108ae:	f88d 300b 	strb.w	r3, [sp, #11]
   108b2:	463b      	mov	r3, r7
   108b4:	4619      	mov	r1, r3
   108b6:	4816      	ldr	r0, [pc, #88]	; (10910 <Pin::EnableDac(bool)+0x6c>)
   108b8:	f004 fc9e 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   108bc:	4b15      	ldr	r3, [pc, #84]	; (10914 <Pin::EnableDac(bool)+0x70>)
   108be:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kDacEnable, enable_dac, 1);
   108c0:	9a03      	ldr	r2, [sp, #12]
   108c2:	7912      	ldrb	r2, [r2, #4]
   108c4:	4610      	mov	r0, r2
   108c6:	9a03      	ldr	r2, [sp, #12]
   108c8:	7952      	ldrb	r2, [r2, #5]
   108ca:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   108cc:	0142      	lsls	r2, r0, #5
   108ce:	440a      	add	r2, r1
   108d0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   108d4:	f89d 200b 	ldrb.w	r2, [sp, #11]
   108d8:	4b0e      	ldr	r3, [pc, #56]	; (10914 <Pin::EnableDac(bool)+0x70>)
   108da:	681c      	ldr	r4, [r3, #0]
   108dc:	9b03      	ldr	r3, [sp, #12]
   108de:	791b      	ldrb	r3, [r3, #4]
   108e0:	461e      	mov	r6, r3
   108e2:	9b03      	ldr	r3, [sp, #12]
   108e4:	795b      	ldrb	r3, [r3, #5]
   108e6:	461d      	mov	r5, r3
   108e8:	2301      	movs	r3, #1
   108ea:	9300      	str	r3, [sp, #0]
   108ec:	4613      	mov	r3, r2
   108ee:	2210      	movs	r2, #16
   108f0:	9803      	ldr	r0, [sp, #12]
   108f2:	f000 f811 	bl	10918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   108f6:	4602      	mov	r2, r0
   108f8:	0173      	lsls	r3, r6, #5
   108fa:	442b      	add	r3, r5
   108fc:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   10900:	463b      	mov	r3, r7
   10902:	4619      	mov	r1, r3
   10904:	4802      	ldr	r0, [pc, #8]	; (10910 <Pin::EnableDac(bool)+0x6c>)
   10906:	f004 fc8b 	bl	15220 <__cyg_profile_func_exit>
  }
   1090a:	bf00      	nop
   1090c:	b005      	add	sp, #20
   1090e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10910:	000108a5 	.word	0x000108a5
   10914:	10000000 	.word	0x10000000

00010918 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>:
  inline uint32_t BitPlace(uint32_t target, uint32_t position, uint32_t value,
   10918:	b530      	push	{r4, r5, lr}
   1091a:	b087      	sub	sp, #28
   1091c:	4675      	mov	r5, lr
   1091e:	9003      	str	r0, [sp, #12]
   10920:	9102      	str	r1, [sp, #8]
   10922:	9201      	str	r2, [sp, #4]
   10924:	9300      	str	r3, [sp, #0]
   10926:	462b      	mov	r3, r5
   10928:	4619      	mov	r1, r3
   1092a:	4813      	ldr	r0, [pc, #76]	; (10978 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   1092c:	f004 fc64 	bl	151f8 <__cyg_profile_func_enter>
                           uint32_t value_width)
  {
    // Generate mask with all 1s
    uint32_t mask = 0xFFFFFFFF >> (32 - value_width);
   10930:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   10932:	f1c3 0320 	rsb	r3, r3, #32
   10936:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1093a:	fa22 f303 	lsr.w	r3, r2, r3
   1093e:	9305      	str	r3, [sp, #20]
    target &= ~(mask << position);
   10940:	9a05      	ldr	r2, [sp, #20]
   10942:	9b01      	ldr	r3, [sp, #4]
   10944:	fa02 f303 	lsl.w	r3, r2, r3
   10948:	43db      	mvns	r3, r3
   1094a:	9a02      	ldr	r2, [sp, #8]
   1094c:	4013      	ands	r3, r2
   1094e:	9302      	str	r3, [sp, #8]
    target |= (value & mask) << position;
   10950:	9a00      	ldr	r2, [sp, #0]
   10952:	9b05      	ldr	r3, [sp, #20]
   10954:	401a      	ands	r2, r3
   10956:	9b01      	ldr	r3, [sp, #4]
   10958:	fa02 f303 	lsl.w	r3, r2, r3
   1095c:	9a02      	ldr	r2, [sp, #8]
   1095e:	4313      	orrs	r3, r2
   10960:	9302      	str	r3, [sp, #8]
    return target;
   10962:	9c02      	ldr	r4, [sp, #8]
   10964:	462b      	mov	r3, r5
   10966:	4619      	mov	r1, r3
   10968:	4803      	ldr	r0, [pc, #12]	; (10978 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   1096a:	f004 fc59 	bl	15220 <__cyg_profile_func_exit>
   1096e:	4623      	mov	r3, r4
  }
   10970:	4618      	mov	r0, r3
   10972:	b007      	add	sp, #28
   10974:	bd30      	pop	{r4, r5, pc}
   10976:	bf00      	nop
   10978:	00010919 	.word	0x00010919

0001097c <Pin::GetPort() const>:
  uint8_t GetPort() const override
   1097c:	b530      	push	{r4, r5, lr}
   1097e:	b083      	sub	sp, #12
   10980:	4675      	mov	r5, lr
   10982:	9001      	str	r0, [sp, #4]
   10984:	462b      	mov	r3, r5
   10986:	4619      	mov	r1, r3
   10988:	4806      	ldr	r0, [pc, #24]	; (109a4 <Pin::GetPort() const+0x28>)
   1098a:	f004 fc35 	bl	151f8 <__cyg_profile_func_enter>
  {
    return port_;
   1098e:	9b01      	ldr	r3, [sp, #4]
   10990:	791c      	ldrb	r4, [r3, #4]
   10992:	462b      	mov	r3, r5
   10994:	4619      	mov	r1, r3
   10996:	4803      	ldr	r0, [pc, #12]	; (109a4 <Pin::GetPort() const+0x28>)
   10998:	f004 fc42 	bl	15220 <__cyg_profile_func_exit>
   1099c:	4623      	mov	r3, r4
  }
   1099e:	4618      	mov	r0, r3
   109a0:	b003      	add	sp, #12
   109a2:	bd30      	pop	{r4, r5, pc}
   109a4:	0001097d 	.word	0x0001097d

000109a8 <Pin::GetPin() const>:
  uint8_t GetPin() const override
   109a8:	b530      	push	{r4, r5, lr}
   109aa:	b083      	sub	sp, #12
   109ac:	4675      	mov	r5, lr
   109ae:	9001      	str	r0, [sp, #4]
   109b0:	462b      	mov	r3, r5
   109b2:	4619      	mov	r1, r3
   109b4:	4806      	ldr	r0, [pc, #24]	; (109d0 <Pin::GetPin() const+0x28>)
   109b6:	f004 fc1f 	bl	151f8 <__cyg_profile_func_enter>
  {
    return pin_;
   109ba:	9b01      	ldr	r3, [sp, #4]
   109bc:	795c      	ldrb	r4, [r3, #5]
   109be:	462b      	mov	r3, r5
   109c0:	4619      	mov	r1, r3
   109c2:	4803      	ldr	r0, [pc, #12]	; (109d0 <Pin::GetPin() const+0x28>)
   109c4:	f004 fc2c 	bl	15220 <__cyg_profile_func_exit>
   109c8:	4623      	mov	r3, r4
  }
   109ca:	4618      	mov	r0, r3
   109cc:	b003      	add	sp, #12
   109ce:	bd30      	pop	{r4, r5, pc}
   109d0:	000109a9 	.word	0x000109a9

000109d4 <debug::PrintBacktrace(bool, void*)>:
}

[[gnu::no_instrument_function]]
inline void PrintBacktrace(bool show_make_command = false,
                           void * final_address   = nullptr)
{
   109d4:	b500      	push	{lr}
   109d6:	b08b      	sub	sp, #44	; 0x2c
   109d8:	4603      	mov	r3, r0
   109da:	9100      	str	r1, [sp, #0]
   109dc:	f88d 3007 	strb.w	r3, [sp, #7]
  printf("Stack Depth = %zd\n", GetStackDepth());
   109e0:	f004 fc40 	bl	15264 <GetStackDepth()>
   109e4:	4603      	mov	r3, r0
   109e6:	4619      	mov	r1, r3
   109e8:	4831      	ldr	r0, [pc, #196]	; (10ab0 <debug::PrintBacktrace(bool, void*)+0xdc>)
   109ea:	f006 ffe9 	bl	179c0 <printf>
  // stack_depth-1 to ignore PrintBacktrace()
  // PrintBacktrace shouldn't be ignored in profiling because it causes
  // the exit to still fire, which can result in a negative stack_depth
  void ** list_of_called_functions = GetStackTrace();
   109ee:	f004 fc25 	bl	1523c <GetStackTrace()>
   109f2:	9007      	str	r0, [sp, #28]
  size_t stack_depth               = GetStackDepth();
   109f4:	f004 fc36 	bl	15264 <GetStackDepth()>
   109f8:	9006      	str	r0, [sp, #24]
  // Ignore the last function as it is the Backtrace function
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   109fa:	2300      	movs	r3, #0
   109fc:	9309      	str	r3, [sp, #36]	; 0x24
   109fe:	9b06      	ldr	r3, [sp, #24]
   10a00:	3b01      	subs	r3, #1
   10a02:	9a09      	ldr	r2, [sp, #36]	; 0x24
   10a04:	429a      	cmp	r2, r3
   10a06:	d20d      	bcs.n	10a24 <debug::PrintBacktrace(bool, void*)+0x50>
  {
    printf("  #%zu: 0x%p\n", pos, list_of_called_functions[pos]);
   10a08:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10a0a:	009b      	lsls	r3, r3, #2
   10a0c:	9a07      	ldr	r2, [sp, #28]
   10a0e:	4413      	add	r3, r2
   10a10:	681b      	ldr	r3, [r3, #0]
   10a12:	461a      	mov	r2, r3
   10a14:	9909      	ldr	r1, [sp, #36]	; 0x24
   10a16:	4827      	ldr	r0, [pc, #156]	; (10ab4 <debug::PrintBacktrace(bool, void*)+0xe0>)
   10a18:	f006 ffd2 	bl	179c0 <printf>
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10a1c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10a1e:	3301      	adds	r3, #1
   10a20:	9309      	str	r3, [sp, #36]	; 0x24
   10a22:	e7ec      	b.n	109fe <debug::PrintBacktrace(bool, void*)+0x2a>
  }
  if (final_address != nullptr)
   10a24:	9b00      	ldr	r3, [sp, #0]
   10a26:	2b00      	cmp	r3, #0
   10a28:	d006      	beq.n	10a38 <debug::PrintBacktrace(bool, void*)+0x64>
  {
    printf("  #%zu: 0x%p\n", stack_depth - 1, final_address);
   10a2a:	9b06      	ldr	r3, [sp, #24]
   10a2c:	3b01      	subs	r3, #1
   10a2e:	9a00      	ldr	r2, [sp, #0]
   10a30:	4619      	mov	r1, r3
   10a32:	4820      	ldr	r0, [pc, #128]	; (10ab4 <debug::PrintBacktrace(bool, void*)+0xe0>)
   10a34:	f006 ffc4 	bl	179c0 <printf>
  }
  if (show_make_command)
   10a38:	f89d 3007 	ldrb.w	r3, [sp, #7]
   10a3c:	2b00      	cmp	r3, #0
   10a3e:	d033      	beq.n	10aa8 <debug::PrintBacktrace(bool, void*)+0xd4>
  {
    constexpr const char kBuildType[] =
   10a40:	4a1d      	ldr	r2, [pc, #116]	; (10ab8 <debug::PrintBacktrace(bool, void*)+0xe4>)
   10a42:	ab03      	add	r3, sp, #12
   10a44:	ca07      	ldmia	r2, {r0, r1, r2}
   10a46:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#if defined(APPLICATION)
        "application";
#else
        "bootloader";
#endif
    puts("\nRun: the following command in your project directory");
   10a4a:	481c      	ldr	r0, [pc, #112]	; (10abc <debug::PrintBacktrace(bool, void*)+0xe8>)
   10a4c:	f004 fba4 	bl	15198 <puts>
    printf("\n  " SJ2_BOLD_WHITE "make stacktrace-%s TRACES=\"", kBuildType);
   10a50:	ab03      	add	r3, sp, #12
   10a52:	4619      	mov	r1, r3
   10a54:	481a      	ldr	r0, [pc, #104]	; (10ac0 <debug::PrintBacktrace(bool, void*)+0xec>)
   10a56:	f006 ffb3 	bl	179c0 <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10a5a:	2300      	movs	r3, #0
   10a5c:	9308      	str	r3, [sp, #32]
   10a5e:	9b06      	ldr	r3, [sp, #24]
   10a60:	3b01      	subs	r3, #1
   10a62:	9a08      	ldr	r2, [sp, #32]
   10a64:	429a      	cmp	r2, r3
   10a66:	d212      	bcs.n	10a8e <debug::PrintBacktrace(bool, void*)+0xba>
    {
      if (pos != 0)
   10a68:	9b08      	ldr	r3, [sp, #32]
   10a6a:	2b00      	cmp	r3, #0
   10a6c:	d002      	beq.n	10a74 <debug::PrintBacktrace(bool, void*)+0xa0>
      {
        putchar(' ');
   10a6e:	2020      	movs	r0, #32
   10a70:	f004 fb76 	bl	15160 <putchar>
      }
      printf("0x%p", list_of_called_functions[pos]);
   10a74:	9b08      	ldr	r3, [sp, #32]
   10a76:	009b      	lsls	r3, r3, #2
   10a78:	9a07      	ldr	r2, [sp, #28]
   10a7a:	4413      	add	r3, r2
   10a7c:	681b      	ldr	r3, [r3, #0]
   10a7e:	4619      	mov	r1, r3
   10a80:	4810      	ldr	r0, [pc, #64]	; (10ac4 <debug::PrintBacktrace(bool, void*)+0xf0>)
   10a82:	f006 ff9d 	bl	179c0 <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10a86:	9b08      	ldr	r3, [sp, #32]
   10a88:	3301      	adds	r3, #1
   10a8a:	9308      	str	r3, [sp, #32]
   10a8c:	e7e7      	b.n	10a5e <debug::PrintBacktrace(bool, void*)+0x8a>
    }
    if (final_address != nullptr)
   10a8e:	9b00      	ldr	r3, [sp, #0]
   10a90:	2b00      	cmp	r3, #0
   10a92:	d003      	beq.n	10a9c <debug::PrintBacktrace(bool, void*)+0xc8>
    {
      printf(" 0x%p", final_address);
   10a94:	9900      	ldr	r1, [sp, #0]
   10a96:	480c      	ldr	r0, [pc, #48]	; (10ac8 <debug::PrintBacktrace(bool, void*)+0xf4>)
   10a98:	f006 ff92 	bl	179c0 <printf>
    }
    puts("\"\n" SJ2_COLOR_RESET);
   10a9c:	480b      	ldr	r0, [pc, #44]	; (10acc <debug::PrintBacktrace(bool, void*)+0xf8>)
   10a9e:	f004 fb7b 	bl	15198 <puts>
    puts(
   10aa2:	480b      	ldr	r0, [pc, #44]	; (10ad0 <debug::PrintBacktrace(bool, void*)+0xfc>)
   10aa4:	f004 fb78 	bl	15198 <puts>
        "This will report the file and line number that led to this function "
        "being called.");
  }
}
   10aa8:	bf00      	nop
   10aaa:	b00b      	add	sp, #44	; 0x2c
   10aac:	f85d fb04 	ldr.w	pc, [sp], #4
   10ab0:	00019658 	.word	0x00019658
   10ab4:	0001966c 	.word	0x0001966c
   10ab8:	00019748 	.word	0x00019748
   10abc:	0001967c 	.word	0x0001967c
   10ac0:	000196b4 	.word	0x000196b4
   10ac4:	000196dc 	.word	0x000196dc
   10ac8:	000196e4 	.word	0x000196e4
   10acc:	000196ec 	.word	0x000196ec
   10ad0:	000196f4 	.word	0x000196f4

00010ad4 <(anonymous namespace)::DefaultUptime()>:
{
// uptime in nanoseconds
inline uint64_t uptime = 0;
// Returns the system uptime in nanoseconds, do not use this function directly
[[gnu::always_inline]] inline uint64_t DefaultUptime()
{
   10ad4:	b570      	push	{r4, r5, r6, lr}
   10ad6:	4676      	mov	r6, lr
   10ad8:	4633      	mov	r3, r6
   10ada:	4619      	mov	r1, r3
   10adc:	4807      	ldr	r0, [pc, #28]	; (10afc <(anonymous namespace)::DefaultUptime()+0x28>)
   10ade:	f004 fb8b 	bl	151f8 <__cyg_profile_func_enter>
  return uptime;
   10ae2:	4b07      	ldr	r3, [pc, #28]	; (10b00 <(anonymous namespace)::DefaultUptime()+0x2c>)
   10ae4:	e9d3 4500 	ldrd	r4, r5, [r3]
   10ae8:	4633      	mov	r3, r6
   10aea:	4619      	mov	r1, r3
   10aec:	4803      	ldr	r0, [pc, #12]	; (10afc <(anonymous namespace)::DefaultUptime()+0x28>)
   10aee:	f004 fb97 	bl	15220 <__cyg_profile_func_exit>
   10af2:	4623      	mov	r3, r4
   10af4:	462c      	mov	r4, r5
}
   10af6:	4618      	mov	r0, r3
   10af8:	4621      	mov	r1, r4
   10afa:	bd70      	pop	{r4, r5, r6, pc}
   10afc:	00010ad5 	.word	0x00010ad5
   10b00:	10000968 	.word	0x10000968

00010b04 <Milliseconds()>:
{
  Uptime = uptime_function;
}
// Get system uptime in milliseconds as a 64-bit integer
inline uint64_t Milliseconds()
{
   10b04:	b570      	push	{r4, r5, r6, lr}
   10b06:	4674      	mov	r4, lr
   10b08:	4623      	mov	r3, r4
   10b0a:	4619      	mov	r1, r3
   10b0c:	480c      	ldr	r0, [pc, #48]	; (10b40 <Milliseconds()+0x3c>)
   10b0e:	f004 fb73 	bl	151f8 <__cyg_profile_func_enter>
  return Uptime() / 1'000;
   10b12:	4b0c      	ldr	r3, [pc, #48]	; (10b44 <Milliseconds()+0x40>)
   10b14:	681b      	ldr	r3, [r3, #0]
   10b16:	4798      	blx	r3
   10b18:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10b1c:	f04f 0300 	mov.w	r3, #0
   10b20:	f008 facc 	bl	190bc <__aeabi_uldivmod>
   10b24:	4602      	mov	r2, r0
   10b26:	460b      	mov	r3, r1
   10b28:	4615      	mov	r5, r2
   10b2a:	461e      	mov	r6, r3
   10b2c:	4623      	mov	r3, r4
   10b2e:	4619      	mov	r1, r3
   10b30:	4803      	ldr	r0, [pc, #12]	; (10b40 <Milliseconds()+0x3c>)
   10b32:	f004 fb75 	bl	15220 <__cyg_profile_func_exit>
   10b36:	462b      	mov	r3, r5
   10b38:	4634      	mov	r4, r6
}
   10b3a:	4618      	mov	r0, r3
   10b3c:	4621      	mov	r1, r4
   10b3e:	bd70      	pop	{r4, r5, r6, pc}
   10b40:	00010b05 	.word	0x00010b05
   10b44:	10000004 	.word	0x10000004

00010b48 <GpioInterface::GpioInterface()>:
#include "L0_LowLevel/LPC40xx.h"
#include "L1_Drivers/pin.hpp"
#include "utility/enum.hpp"
#include "utility/log.hpp"

class GpioInterface
   10b48:	b530      	push	{r4, r5, lr}
   10b4a:	b083      	sub	sp, #12
   10b4c:	4675      	mov	r5, lr
   10b4e:	9001      	str	r0, [sp, #4]
   10b50:	462b      	mov	r3, r5
   10b52:	4619      	mov	r1, r3
   10b54:	4807      	ldr	r0, [pc, #28]	; (10b74 <GpioInterface::GpioInterface()+0x2c>)
   10b56:	f004 fb4f 	bl	151f8 <__cyg_profile_func_enter>
   10b5a:	4a07      	ldr	r2, [pc, #28]	; (10b78 <GpioInterface::GpioInterface()+0x30>)
   10b5c:	9b01      	ldr	r3, [sp, #4]
   10b5e:	601a      	str	r2, [r3, #0]
   10b60:	9c01      	ldr	r4, [sp, #4]
   10b62:	462b      	mov	r3, r5
   10b64:	4619      	mov	r1, r3
   10b66:	4803      	ldr	r0, [pc, #12]	; (10b74 <GpioInterface::GpioInterface()+0x2c>)
   10b68:	f004 fb5a 	bl	15220 <__cyg_profile_func_exit>
   10b6c:	4623      	mov	r3, r4
   10b6e:	4618      	mov	r0, r3
   10b70:	b003      	add	sp, #12
   10b72:	bd30      	pop	{r4, r5, pc}
   10b74:	00010b49 	.word	0x00010b49
   10b78:	00019e80 	.word	0x00019e80

00010b7c <Gpio::Gpio(unsigned char, unsigned char)>:
  };

  inline static volatile uint32_t * port_status = &(LPC_GPIOINT->IntStatus);

  // For port 0-4, pins 0-31 are available. Port 5 only has pins 0-4 available.
  constexpr Gpio(uint8_t port_number, uint8_t pin_number)
   10b7c:	b530      	push	{r4, r5, lr}
   10b7e:	b083      	sub	sp, #12
   10b80:	4675      	mov	r5, lr
   10b82:	9001      	str	r0, [sp, #4]
   10b84:	460b      	mov	r3, r1
   10b86:	f88d 3003 	strb.w	r3, [sp, #3]
   10b8a:	4613      	mov	r3, r2
   10b8c:	f88d 3002 	strb.w	r3, [sp, #2]
   10b90:	462b      	mov	r3, r5
   10b92:	4619      	mov	r1, r3
   10b94:	4816      	ldr	r0, [pc, #88]	; (10bf0 <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   10b96:	f004 fb2f 	bl	151f8 <__cyg_profile_func_enter>
      : interupt_port_(false),
        pin_(&lpc40xx_pin_),
        lpc40xx_pin_(port_number, pin_number)
   10b9a:	9b01      	ldr	r3, [sp, #4]
   10b9c:	4618      	mov	r0, r3
   10b9e:	f7ff ffd3 	bl	10b48 <GpioInterface::GpioInterface()>
   10ba2:	4a14      	ldr	r2, [pc, #80]	; (10bf4 <Gpio::Gpio(unsigned char, unsigned char)+0x78>)
   10ba4:	9b01      	ldr	r3, [sp, #4]
   10ba6:	601a      	str	r2, [r3, #0]
   10ba8:	9b01      	ldr	r3, [sp, #4]
   10baa:	2200      	movs	r2, #0
   10bac:	711a      	strb	r2, [r3, #4]
   10bae:	9b01      	ldr	r3, [sp, #4]
   10bb0:	f103 020c 	add.w	r2, r3, #12
   10bb4:	9b01      	ldr	r3, [sp, #4]
   10bb6:	609a      	str	r2, [r3, #8]
   10bb8:	9b01      	ldr	r3, [sp, #4]
   10bba:	330c      	adds	r3, #12
   10bbc:	f89d 2002 	ldrb.w	r2, [sp, #2]
   10bc0:	f89d 1003 	ldrb.w	r1, [sp, #3]
   10bc4:	4618      	mov	r0, r3
   10bc6:	f7ff fbe9 	bl	1039c <Pin::Pin(unsigned char, unsigned char)>
  {
    interupt_port_ = (port_number == 2) ? 1 : 0;
   10bca:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10bce:	2b02      	cmp	r3, #2
   10bd0:	d101      	bne.n	10bd6 <Gpio::Gpio(unsigned char, unsigned char)+0x5a>
   10bd2:	2201      	movs	r2, #1
   10bd4:	e000      	b.n	10bd8 <Gpio::Gpio(unsigned char, unsigned char)+0x5c>
   10bd6:	2200      	movs	r2, #0
   10bd8:	9b01      	ldr	r3, [sp, #4]
   10bda:	711a      	strb	r2, [r3, #4]
  }
   10bdc:	9c01      	ldr	r4, [sp, #4]
   10bde:	462b      	mov	r3, r5
   10be0:	4619      	mov	r1, r3
   10be2:	4803      	ldr	r0, [pc, #12]	; (10bf0 <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   10be4:	f004 fb1c 	bl	15220 <__cyg_profile_func_exit>
   10be8:	4623      	mov	r3, r4
   10bea:	4618      	mov	r0, r3
   10bec:	b003      	add	sp, #12
   10bee:	bd30      	pop	{r4, r5, pc}
   10bf0:	00010b7d 	.word	0x00010b7d
   10bf4:	00019e38 	.word	0x00019e38

00010bf8 <Gpio::SetAsInput()>:
      : interupt_port_(false), pin_(pin), lpc40xx_pin_(Pin::CreateInactivePin())
  {
    interupt_port_ = pin_->GetPort();
  }
  // Sets the GPIO pin direction as input
  void SetAsInput(void) override
   10bf8:	b530      	push	{r4, r5, lr}
   10bfa:	b083      	sub	sp, #12
   10bfc:	4675      	mov	r5, lr
   10bfe:	9001      	str	r0, [sp, #4]
   10c00:	462b      	mov	r3, r5
   10c02:	4619      	mov	r1, r3
   10c04:	4819      	ldr	r0, [pc, #100]	; (10c6c <Gpio::SetAsInput()+0x74>)
   10c06:	f004 faf7 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_->SetPinFunction(kGpioFunction);
   10c0a:	9b01      	ldr	r3, [sp, #4]
   10c0c:	689a      	ldr	r2, [r3, #8]
   10c0e:	9b01      	ldr	r3, [sp, #4]
   10c10:	689b      	ldr	r3, [r3, #8]
   10c12:	681b      	ldr	r3, [r3, #0]
   10c14:	681b      	ldr	r3, [r3, #0]
   10c16:	2100      	movs	r1, #0
   10c18:	4610      	mov	r0, r2
   10c1a:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR &= ~(1 << pin_->GetPin());
   10c1c:	9b01      	ldr	r3, [sp, #4]
   10c1e:	689a      	ldr	r2, [r3, #8]
   10c20:	9b01      	ldr	r3, [sp, #4]
   10c22:	689b      	ldr	r3, [r3, #8]
   10c24:	681b      	ldr	r3, [r3, #0]
   10c26:	3330      	adds	r3, #48	; 0x30
   10c28:	681b      	ldr	r3, [r3, #0]
   10c2a:	4610      	mov	r0, r2
   10c2c:	4798      	blx	r3
   10c2e:	4603      	mov	r3, r0
   10c30:	461a      	mov	r2, r3
   10c32:	2301      	movs	r3, #1
   10c34:	4093      	lsls	r3, r2
   10c36:	43dc      	mvns	r4, r3
   10c38:	9b01      	ldr	r3, [sp, #4]
   10c3a:	689a      	ldr	r2, [r3, #8]
   10c3c:	9b01      	ldr	r3, [sp, #4]
   10c3e:	689b      	ldr	r3, [r3, #8]
   10c40:	681b      	ldr	r3, [r3, #0]
   10c42:	332c      	adds	r3, #44	; 0x2c
   10c44:	681b      	ldr	r3, [r3, #0]
   10c46:	4610      	mov	r0, r2
   10c48:	4798      	blx	r3
   10c4a:	4603      	mov	r3, r0
   10c4c:	461a      	mov	r2, r3
   10c4e:	4b08      	ldr	r3, [pc, #32]	; (10c70 <Gpio::SetAsInput()+0x78>)
   10c50:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10c54:	681a      	ldr	r2, [r3, #0]
   10c56:	4621      	mov	r1, r4
   10c58:	400a      	ands	r2, r1
   10c5a:	601a      	str	r2, [r3, #0]
   10c5c:	462b      	mov	r3, r5
   10c5e:	4619      	mov	r1, r3
   10c60:	4802      	ldr	r0, [pc, #8]	; (10c6c <Gpio::SetAsInput()+0x74>)
   10c62:	f004 fadd 	bl	15220 <__cyg_profile_func_exit>
  }
   10c66:	bf00      	nop
   10c68:	b003      	add	sp, #12
   10c6a:	bd30      	pop	{r4, r5, pc}
   10c6c:	00010bf9 	.word	0x00010bf9
   10c70:	10000008 	.word	0x10000008

00010c74 <Gpio::SetAsOutput()>:
  // Sets the GPIO pin direction as output
  void SetAsOutput(void) override
   10c74:	b530      	push	{r4, r5, lr}
   10c76:	b083      	sub	sp, #12
   10c78:	4675      	mov	r5, lr
   10c7a:	9001      	str	r0, [sp, #4]
   10c7c:	462b      	mov	r3, r5
   10c7e:	4619      	mov	r1, r3
   10c80:	4819      	ldr	r0, [pc, #100]	; (10ce8 <Gpio::SetAsOutput()+0x74>)
   10c82:	f004 fab9 	bl	151f8 <__cyg_profile_func_enter>
  {
    pin_->SetPinFunction(kGpioFunction);
   10c86:	9b01      	ldr	r3, [sp, #4]
   10c88:	689a      	ldr	r2, [r3, #8]
   10c8a:	9b01      	ldr	r3, [sp, #4]
   10c8c:	689b      	ldr	r3, [r3, #8]
   10c8e:	681b      	ldr	r3, [r3, #0]
   10c90:	681b      	ldr	r3, [r3, #0]
   10c92:	2100      	movs	r1, #0
   10c94:	4610      	mov	r0, r2
   10c96:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR |= (1 << pin_->GetPin());
   10c98:	9b01      	ldr	r3, [sp, #4]
   10c9a:	689a      	ldr	r2, [r3, #8]
   10c9c:	9b01      	ldr	r3, [sp, #4]
   10c9e:	689b      	ldr	r3, [r3, #8]
   10ca0:	681b      	ldr	r3, [r3, #0]
   10ca2:	3330      	adds	r3, #48	; 0x30
   10ca4:	681b      	ldr	r3, [r3, #0]
   10ca6:	4610      	mov	r0, r2
   10ca8:	4798      	blx	r3
   10caa:	4603      	mov	r3, r0
   10cac:	461a      	mov	r2, r3
   10cae:	2301      	movs	r3, #1
   10cb0:	fa03 f402 	lsl.w	r4, r3, r2
   10cb4:	9b01      	ldr	r3, [sp, #4]
   10cb6:	689a      	ldr	r2, [r3, #8]
   10cb8:	9b01      	ldr	r3, [sp, #4]
   10cba:	689b      	ldr	r3, [r3, #8]
   10cbc:	681b      	ldr	r3, [r3, #0]
   10cbe:	332c      	adds	r3, #44	; 0x2c
   10cc0:	681b      	ldr	r3, [r3, #0]
   10cc2:	4610      	mov	r0, r2
   10cc4:	4798      	blx	r3
   10cc6:	4603      	mov	r3, r0
   10cc8:	461a      	mov	r2, r3
   10cca:	4b08      	ldr	r3, [pc, #32]	; (10cec <Gpio::SetAsOutput()+0x78>)
   10ccc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10cd0:	681a      	ldr	r2, [r3, #0]
   10cd2:	4621      	mov	r1, r4
   10cd4:	430a      	orrs	r2, r1
   10cd6:	601a      	str	r2, [r3, #0]
   10cd8:	462b      	mov	r3, r5
   10cda:	4619      	mov	r1, r3
   10cdc:	4802      	ldr	r0, [pc, #8]	; (10ce8 <Gpio::SetAsOutput()+0x74>)
   10cde:	f004 fa9f 	bl	15220 <__cyg_profile_func_exit>
  }
   10ce2:	bf00      	nop
   10ce4:	b003      	add	sp, #12
   10ce6:	bd30      	pop	{r4, r5, pc}
   10ce8:	00010c75 	.word	0x00010c75
   10cec:	10000008 	.word	0x10000008

00010cf0 <Gpio::SetDirection(GpioInterface::Direction)>:
  // Sets the GPIO pin direction as output or input depending on the
  // Direction enum parameter
  inline void SetDirection(Direction direction) override
   10cf0:	b510      	push	{r4, lr}
   10cf2:	b082      	sub	sp, #8
   10cf4:	4674      	mov	r4, lr
   10cf6:	9001      	str	r0, [sp, #4]
   10cf8:	460b      	mov	r3, r1
   10cfa:	f88d 3003 	strb.w	r3, [sp, #3]
   10cfe:	4623      	mov	r3, r4
   10d00:	4619      	mov	r1, r3
   10d02:	480b      	ldr	r0, [pc, #44]	; (10d30 <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   10d04:	f004 fa78 	bl	151f8 <__cyg_profile_func_enter>
  {
    (direction) ? SetAsOutput() : SetAsInput();
   10d08:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10d0c:	2b00      	cmp	r3, #0
   10d0e:	d003      	beq.n	10d18 <Gpio::SetDirection(GpioInterface::Direction)+0x28>
   10d10:	9801      	ldr	r0, [sp, #4]
   10d12:	f7ff ffaf 	bl	10c74 <Gpio::SetAsOutput()>
   10d16:	e002      	b.n	10d1e <Gpio::SetDirection(GpioInterface::Direction)+0x2e>
   10d18:	9801      	ldr	r0, [sp, #4]
   10d1a:	f7ff ff6d 	bl	10bf8 <Gpio::SetAsInput()>
   10d1e:	4623      	mov	r3, r4
   10d20:	4619      	mov	r1, r3
   10d22:	4803      	ldr	r0, [pc, #12]	; (10d30 <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   10d24:	f004 fa7c 	bl	15220 <__cyg_profile_func_exit>
  }
   10d28:	bf00      	nop
   10d2a:	b002      	add	sp, #8
   10d2c:	bd10      	pop	{r4, pc}
   10d2e:	bf00      	nop
   10d30:	00010cf1 	.word	0x00010cf1

00010d34 <Gpio::SetHigh()>:
  // Sets the GPIO output pin to high
  void SetHigh(void) override
   10d34:	b530      	push	{r4, r5, lr}
   10d36:	b083      	sub	sp, #12
   10d38:	4675      	mov	r5, lr
   10d3a:	9001      	str	r0, [sp, #4]
   10d3c:	462b      	mov	r3, r5
   10d3e:	4619      	mov	r1, r3
   10d40:	4813      	ldr	r0, [pc, #76]	; (10d90 <Gpio::SetHigh()+0x5c>)
   10d42:	f004 fa59 	bl	151f8 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->SET = (1 << pin_->GetPin());
   10d46:	9b01      	ldr	r3, [sp, #4]
   10d48:	689a      	ldr	r2, [r3, #8]
   10d4a:	9b01      	ldr	r3, [sp, #4]
   10d4c:	689b      	ldr	r3, [r3, #8]
   10d4e:	681b      	ldr	r3, [r3, #0]
   10d50:	3330      	adds	r3, #48	; 0x30
   10d52:	681b      	ldr	r3, [r3, #0]
   10d54:	4610      	mov	r0, r2
   10d56:	4798      	blx	r3
   10d58:	4603      	mov	r3, r0
   10d5a:	461a      	mov	r2, r3
   10d5c:	2301      	movs	r3, #1
   10d5e:	4093      	lsls	r3, r2
   10d60:	461c      	mov	r4, r3
   10d62:	9b01      	ldr	r3, [sp, #4]
   10d64:	689a      	ldr	r2, [r3, #8]
   10d66:	9b01      	ldr	r3, [sp, #4]
   10d68:	689b      	ldr	r3, [r3, #8]
   10d6a:	681b      	ldr	r3, [r3, #0]
   10d6c:	332c      	adds	r3, #44	; 0x2c
   10d6e:	681b      	ldr	r3, [r3, #0]
   10d70:	4610      	mov	r0, r2
   10d72:	4798      	blx	r3
   10d74:	4603      	mov	r3, r0
   10d76:	461a      	mov	r2, r3
   10d78:	4b06      	ldr	r3, [pc, #24]	; (10d94 <Gpio::SetHigh()+0x60>)
   10d7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10d7e:	619c      	str	r4, [r3, #24]
   10d80:	462b      	mov	r3, r5
   10d82:	4619      	mov	r1, r3
   10d84:	4802      	ldr	r0, [pc, #8]	; (10d90 <Gpio::SetHigh()+0x5c>)
   10d86:	f004 fa4b 	bl	15220 <__cyg_profile_func_exit>
  }
   10d8a:	bf00      	nop
   10d8c:	b003      	add	sp, #12
   10d8e:	bd30      	pop	{r4, r5, pc}
   10d90:	00010d35 	.word	0x00010d35
   10d94:	10000008 	.word	0x10000008

00010d98 <Gpio::SetLow()>:
  // Sets the GPIO output pin to low
  void SetLow(void) override
   10d98:	b530      	push	{r4, r5, lr}
   10d9a:	b083      	sub	sp, #12
   10d9c:	4675      	mov	r5, lr
   10d9e:	9001      	str	r0, [sp, #4]
   10da0:	462b      	mov	r3, r5
   10da2:	4619      	mov	r1, r3
   10da4:	4813      	ldr	r0, [pc, #76]	; (10df4 <Gpio::SetLow()+0x5c>)
   10da6:	f004 fa27 	bl	151f8 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->CLR = (1 << pin_->GetPin());
   10daa:	9b01      	ldr	r3, [sp, #4]
   10dac:	689a      	ldr	r2, [r3, #8]
   10dae:	9b01      	ldr	r3, [sp, #4]
   10db0:	689b      	ldr	r3, [r3, #8]
   10db2:	681b      	ldr	r3, [r3, #0]
   10db4:	3330      	adds	r3, #48	; 0x30
   10db6:	681b      	ldr	r3, [r3, #0]
   10db8:	4610      	mov	r0, r2
   10dba:	4798      	blx	r3
   10dbc:	4603      	mov	r3, r0
   10dbe:	461a      	mov	r2, r3
   10dc0:	2301      	movs	r3, #1
   10dc2:	4093      	lsls	r3, r2
   10dc4:	461c      	mov	r4, r3
   10dc6:	9b01      	ldr	r3, [sp, #4]
   10dc8:	689a      	ldr	r2, [r3, #8]
   10dca:	9b01      	ldr	r3, [sp, #4]
   10dcc:	689b      	ldr	r3, [r3, #8]
   10dce:	681b      	ldr	r3, [r3, #0]
   10dd0:	332c      	adds	r3, #44	; 0x2c
   10dd2:	681b      	ldr	r3, [r3, #0]
   10dd4:	4610      	mov	r0, r2
   10dd6:	4798      	blx	r3
   10dd8:	4603      	mov	r3, r0
   10dda:	461a      	mov	r2, r3
   10ddc:	4b06      	ldr	r3, [pc, #24]	; (10df8 <Gpio::SetLow()+0x60>)
   10dde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10de2:	61dc      	str	r4, [r3, #28]
   10de4:	462b      	mov	r3, r5
   10de6:	4619      	mov	r1, r3
   10de8:	4802      	ldr	r0, [pc, #8]	; (10df4 <Gpio::SetLow()+0x5c>)
   10dea:	f004 fa19 	bl	15220 <__cyg_profile_func_exit>
  }
   10dee:	bf00      	nop
   10df0:	b003      	add	sp, #12
   10df2:	bd30      	pop	{r4, r5, pc}
   10df4:	00010d99 	.word	0x00010d99
   10df8:	10000008 	.word	0x10000008

00010dfc <Gpio::Set(GpioInterface::State)>:
  // Sets the GPIO output pin to high or low depending on the State enum
  // parameter
  void Set(State output = kHigh) override
   10dfc:	b510      	push	{r4, lr}
   10dfe:	b082      	sub	sp, #8
   10e00:	4674      	mov	r4, lr
   10e02:	9001      	str	r0, [sp, #4]
   10e04:	460b      	mov	r3, r1
   10e06:	f88d 3003 	strb.w	r3, [sp, #3]
   10e0a:	4623      	mov	r3, r4
   10e0c:	4619      	mov	r1, r3
   10e0e:	480b      	ldr	r0, [pc, #44]	; (10e3c <Gpio::Set(GpioInterface::State)+0x40>)
   10e10:	f004 f9f2 	bl	151f8 <__cyg_profile_func_enter>
  {
    (output) ? SetHigh() : SetLow();
   10e14:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10e18:	2b00      	cmp	r3, #0
   10e1a:	d003      	beq.n	10e24 <Gpio::Set(GpioInterface::State)+0x28>
   10e1c:	9801      	ldr	r0, [sp, #4]
   10e1e:	f7ff ff89 	bl	10d34 <Gpio::SetHigh()>
   10e22:	e002      	b.n	10e2a <Gpio::Set(GpioInterface::State)+0x2e>
   10e24:	9801      	ldr	r0, [sp, #4]
   10e26:	f7ff ffb7 	bl	10d98 <Gpio::SetLow()>
   10e2a:	4623      	mov	r3, r4
   10e2c:	4619      	mov	r1, r3
   10e2e:	4803      	ldr	r0, [pc, #12]	; (10e3c <Gpio::Set(GpioInterface::State)+0x40>)
   10e30:	f004 f9f6 	bl	15220 <__cyg_profile_func_exit>
  }
   10e34:	bf00      	nop
   10e36:	b002      	add	sp, #8
   10e38:	bd10      	pop	{r4, pc}
   10e3a:	bf00      	nop
   10e3c:	00010dfd 	.word	0x00010dfd

00010e40 <Gpio::Toggle()>:
  // Toggle the output of a GPIO output pin
  void Toggle() override
   10e40:	b530      	push	{r4, r5, lr}
   10e42:	b083      	sub	sp, #12
   10e44:	4675      	mov	r5, lr
   10e46:	9001      	str	r0, [sp, #4]
   10e48:	462b      	mov	r3, r5
   10e4a:	4619      	mov	r1, r3
   10e4c:	4815      	ldr	r0, [pc, #84]	; (10ea4 <Gpio::Toggle()+0x64>)
   10e4e:	f004 f9d3 	bl	151f8 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->PIN ^= (1 << pin_->GetPin());
   10e52:	9b01      	ldr	r3, [sp, #4]
   10e54:	689a      	ldr	r2, [r3, #8]
   10e56:	9b01      	ldr	r3, [sp, #4]
   10e58:	689b      	ldr	r3, [r3, #8]
   10e5a:	681b      	ldr	r3, [r3, #0]
   10e5c:	3330      	adds	r3, #48	; 0x30
   10e5e:	681b      	ldr	r3, [r3, #0]
   10e60:	4610      	mov	r0, r2
   10e62:	4798      	blx	r3
   10e64:	4603      	mov	r3, r0
   10e66:	461a      	mov	r2, r3
   10e68:	2301      	movs	r3, #1
   10e6a:	fa03 f402 	lsl.w	r4, r3, r2
   10e6e:	9b01      	ldr	r3, [sp, #4]
   10e70:	689a      	ldr	r2, [r3, #8]
   10e72:	9b01      	ldr	r3, [sp, #4]
   10e74:	689b      	ldr	r3, [r3, #8]
   10e76:	681b      	ldr	r3, [r3, #0]
   10e78:	332c      	adds	r3, #44	; 0x2c
   10e7a:	681b      	ldr	r3, [r3, #0]
   10e7c:	4610      	mov	r0, r2
   10e7e:	4798      	blx	r3
   10e80:	4603      	mov	r3, r0
   10e82:	461a      	mov	r2, r3
   10e84:	4b08      	ldr	r3, [pc, #32]	; (10ea8 <Gpio::Toggle()+0x68>)
   10e86:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10e8a:	695a      	ldr	r2, [r3, #20]
   10e8c:	4621      	mov	r1, r4
   10e8e:	404a      	eors	r2, r1
   10e90:	615a      	str	r2, [r3, #20]
   10e92:	462b      	mov	r3, r5
   10e94:	4619      	mov	r1, r3
   10e96:	4803      	ldr	r0, [pc, #12]	; (10ea4 <Gpio::Toggle()+0x64>)
   10e98:	f004 f9c2 	bl	15220 <__cyg_profile_func_exit>
  }
   10e9c:	bf00      	nop
   10e9e:	b003      	add	sp, #12
   10ea0:	bd30      	pop	{r4, r5, pc}
   10ea2:	bf00      	nop
   10ea4:	00010e41 	.word	0x00010e41
   10ea8:	10000008 	.word	0x10000008

00010eac <Gpio::ReadState()>:
  // Returns the current State state of the pin
  State ReadState(void) override
   10eac:	b530      	push	{r4, r5, lr}
   10eae:	b085      	sub	sp, #20
   10eb0:	4675      	mov	r5, lr
   10eb2:	9001      	str	r0, [sp, #4]
   10eb4:	462b      	mov	r3, r5
   10eb6:	4619      	mov	r1, r3
   10eb8:	4818      	ldr	r0, [pc, #96]	; (10f1c <Gpio::ReadState()+0x70>)
   10eba:	f004 f99d 	bl	151f8 <__cyg_profile_func_enter>
  {
    bool state = (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   10ebe:	9b01      	ldr	r3, [sp, #4]
   10ec0:	689a      	ldr	r2, [r3, #8]
   10ec2:	9b01      	ldr	r3, [sp, #4]
   10ec4:	689b      	ldr	r3, [r3, #8]
   10ec6:	681b      	ldr	r3, [r3, #0]
   10ec8:	332c      	adds	r3, #44	; 0x2c
   10eca:	681b      	ldr	r3, [r3, #0]
   10ecc:	4610      	mov	r0, r2
   10ece:	4798      	blx	r3
   10ed0:	4603      	mov	r3, r0
   10ed2:	461a      	mov	r2, r3
   10ed4:	4b12      	ldr	r3, [pc, #72]	; (10f20 <Gpio::ReadState()+0x74>)
   10ed6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10eda:	695c      	ldr	r4, [r3, #20]
   10edc:	9b01      	ldr	r3, [sp, #4]
   10ede:	689a      	ldr	r2, [r3, #8]
   10ee0:	9b01      	ldr	r3, [sp, #4]
   10ee2:	689b      	ldr	r3, [r3, #8]
   10ee4:	681b      	ldr	r3, [r3, #0]
   10ee6:	3330      	adds	r3, #48	; 0x30
   10ee8:	681b      	ldr	r3, [r3, #0]
   10eea:	4610      	mov	r0, r2
   10eec:	4798      	blx	r3
   10eee:	4603      	mov	r3, r0
   10ef0:	fa24 f303 	lsr.w	r3, r4, r3
   10ef4:	f003 0301 	and.w	r3, r3, #1
   10ef8:	2b00      	cmp	r3, #0
   10efa:	bf14      	ite	ne
   10efc:	2301      	movne	r3, #1
   10efe:	2300      	moveq	r3, #0
   10f00:	f88d 300f 	strb.w	r3, [sp, #15]
    return static_cast<State>(state);
   10f04:	f89d 400f 	ldrb.w	r4, [sp, #15]
   10f08:	462b      	mov	r3, r5
   10f0a:	4619      	mov	r1, r3
   10f0c:	4803      	ldr	r0, [pc, #12]	; (10f1c <Gpio::ReadState()+0x70>)
   10f0e:	f004 f987 	bl	15220 <__cyg_profile_func_exit>
   10f12:	4623      	mov	r3, r4
  }
   10f14:	4618      	mov	r0, r3
   10f16:	b005      	add	sp, #20
   10f18:	bd30      	pop	{r4, r5, pc}
   10f1a:	bf00      	nop
   10f1c:	00010ead 	.word	0x00010ead
   10f20:	10000008 	.word	0x10000008

00010f24 <Gpio::Read()>:
  // Returns true if input or output pin is high
  bool Read(void) override
   10f24:	b530      	push	{r4, r5, lr}
   10f26:	b083      	sub	sp, #12
   10f28:	4675      	mov	r5, lr
   10f2a:	9001      	str	r0, [sp, #4]
   10f2c:	462b      	mov	r3, r5
   10f2e:	4619      	mov	r1, r3
   10f30:	4816      	ldr	r0, [pc, #88]	; (10f8c <Gpio::Read()+0x68>)
   10f32:	f004 f961 	bl	151f8 <__cyg_profile_func_enter>
  {
    return (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   10f36:	9b01      	ldr	r3, [sp, #4]
   10f38:	689a      	ldr	r2, [r3, #8]
   10f3a:	9b01      	ldr	r3, [sp, #4]
   10f3c:	689b      	ldr	r3, [r3, #8]
   10f3e:	681b      	ldr	r3, [r3, #0]
   10f40:	332c      	adds	r3, #44	; 0x2c
   10f42:	681b      	ldr	r3, [r3, #0]
   10f44:	4610      	mov	r0, r2
   10f46:	4798      	blx	r3
   10f48:	4603      	mov	r3, r0
   10f4a:	461a      	mov	r2, r3
   10f4c:	4b10      	ldr	r3, [pc, #64]	; (10f90 <Gpio::Read()+0x6c>)
   10f4e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10f52:	695c      	ldr	r4, [r3, #20]
   10f54:	9b01      	ldr	r3, [sp, #4]
   10f56:	689a      	ldr	r2, [r3, #8]
   10f58:	9b01      	ldr	r3, [sp, #4]
   10f5a:	689b      	ldr	r3, [r3, #8]
   10f5c:	681b      	ldr	r3, [r3, #0]
   10f5e:	3330      	adds	r3, #48	; 0x30
   10f60:	681b      	ldr	r3, [r3, #0]
   10f62:	4610      	mov	r0, r2
   10f64:	4798      	blx	r3
   10f66:	4603      	mov	r3, r0
   10f68:	fa24 f303 	lsr.w	r3, r4, r3
   10f6c:	f003 0301 	and.w	r3, r3, #1
   10f70:	2b00      	cmp	r3, #0
   10f72:	bf14      	ite	ne
   10f74:	2301      	movne	r3, #1
   10f76:	2300      	moveq	r3, #0
   10f78:	b2dc      	uxtb	r4, r3
   10f7a:	462b      	mov	r3, r5
   10f7c:	4619      	mov	r1, r3
   10f7e:	4803      	ldr	r0, [pc, #12]	; (10f8c <Gpio::Read()+0x68>)
   10f80:	f004 f94e 	bl	15220 <__cyg_profile_func_exit>
   10f84:	4623      	mov	r3, r4
  }
   10f86:	4618      	mov	r0, r3
   10f88:	b003      	add	sp, #12
   10f8a:	bd30      	pop	{r4, r5, pc}
   10f8c:	00010f25 	.word	0x00010f25
   10f90:	10000008 	.word	0x10000008

00010f94 <Gpio::GetPin()>:
  PinInterface & GetPin() override
   10f94:	b530      	push	{r4, r5, lr}
   10f96:	b083      	sub	sp, #12
   10f98:	4675      	mov	r5, lr
   10f9a:	9001      	str	r0, [sp, #4]
   10f9c:	462b      	mov	r3, r5
   10f9e:	4619      	mov	r1, r3
   10fa0:	4806      	ldr	r0, [pc, #24]	; (10fbc <Gpio::GetPin()+0x28>)
   10fa2:	f004 f929 	bl	151f8 <__cyg_profile_func_enter>
  {
    return *pin_;
   10fa6:	9b01      	ldr	r3, [sp, #4]
   10fa8:	689c      	ldr	r4, [r3, #8]
   10faa:	462b      	mov	r3, r5
   10fac:	4619      	mov	r1, r3
   10fae:	4803      	ldr	r0, [pc, #12]	; (10fbc <Gpio::GetPin()+0x28>)
   10fb0:	f004 f936 	bl	15220 <__cyg_profile_func_exit>
   10fb4:	4623      	mov	r3, r4
  }
   10fb6:	4618      	mov	r0, r3
   10fb8:	b003      	add	sp, #12
   10fba:	bd30      	pop	{r4, r5, pc}
   10fbc:	00010f95 	.word	0x00010f95

00010fc0 <Gpio::ValidPortCheck()>:

  // Checks if the selected gpio port is valid for external interrupts.
  bool ValidPortCheck()
   10fc0:	b530      	push	{r4, r5, lr}
   10fc2:	b087      	sub	sp, #28
   10fc4:	4675      	mov	r5, lr
   10fc6:	9003      	str	r0, [sp, #12]
   10fc8:	462b      	mov	r3, r5
   10fca:	4619      	mov	r1, r3
   10fcc:	4817      	ldr	r0, [pc, #92]	; (1102c <Gpio::ValidPortCheck()+0x6c>)
   10fce:	f004 f913 	bl	151f8 <__cyg_profile_func_enter>
  {
    bool is_valid = (interupt_port_ <= 1);
   10fd2:	9b03      	ldr	r3, [sp, #12]
   10fd4:	791b      	ldrb	r3, [r3, #4]
   10fd6:	2b01      	cmp	r3, #1
   10fd8:	bf94      	ite	ls
   10fda:	2301      	movls	r3, #1
   10fdc:	2300      	movhi	r3, #0
   10fde:	b2db      	uxtb	r3, r3
   10fe0:	f88d 3017 	strb.w	r3, [sp, #23]
    SJ2_ASSERT_WARNING(is_valid,
   10fe4:	f89d 3017 	ldrb.w	r3, [sp, #23]
   10fe8:	f083 0301 	eor.w	r3, r3, #1
   10fec:	b2db      	uxtb	r3, r3
   10fee:	2b00      	cmp	r3, #0
   10ff0:	d010      	beq.n	11014 <Gpio::ValidPortCheck()+0x54>
   10ff2:	9b03      	ldr	r3, [sp, #12]
   10ff4:	689a      	ldr	r2, [r3, #8]
   10ff6:	9b03      	ldr	r3, [sp, #12]
   10ff8:	689b      	ldr	r3, [r3, #8]
   10ffa:	681b      	ldr	r3, [r3, #0]
   10ffc:	332c      	adds	r3, #44	; 0x2c
   10ffe:	681b      	ldr	r3, [r3, #0]
   11000:	4610      	mov	r0, r2
   11002:	4798      	blx	r3
   11004:	4603      	mov	r3, r0
   11006:	9300      	str	r3, [sp, #0]
   11008:	23a6      	movs	r3, #166	; 0xa6
   1100a:	4a09      	ldr	r2, [pc, #36]	; (11030 <Gpio::ValidPortCheck()+0x70>)
   1100c:	4909      	ldr	r1, [pc, #36]	; (11034 <Gpio::ValidPortCheck()+0x74>)
   1100e:	480a      	ldr	r0, [pc, #40]	; (11038 <Gpio::ValidPortCheck()+0x78>)
   11010:	f006 fcd6 	bl	179c0 <printf>
                       "Port %d cannot be used for External Interrupts. Need "
                       "to use GPIO on Port 0 or 2.",
                       pin_->GetPort());
    return is_valid;
   11014:	f89d 4017 	ldrb.w	r4, [sp, #23]
   11018:	462b      	mov	r3, r5
   1101a:	4619      	mov	r1, r3
   1101c:	4803      	ldr	r0, [pc, #12]	; (1102c <Gpio::ValidPortCheck()+0x6c>)
   1101e:	f004 f8ff 	bl	15220 <__cyg_profile_func_exit>
   11022:	4623      	mov	r3, r4
  }
   11024:	4618      	mov	r0, r3
   11026:	b007      	add	sp, #28
   11028:	bd30      	pop	{r4, r5, pc}
   1102a:	bf00      	nop
   1102c:	00010fc1 	.word	0x00010fc1
   11030:	0001a0b4 	.word	0x0001a0b4
   11034:	00019c28 	.word	0x00019c28
   11038:	00019754 	.word	0x00019754

0001103c <Gpio::SetInterruptRoutine(void (*)())>:

  // Assigns the developer's ISR function to the port/pin gpio instance.
  void SetInterruptRoutine(IsrPointer function) override
   1103c:	b570      	push	{r4, r5, r6, lr}
   1103e:	b082      	sub	sp, #8
   11040:	4676      	mov	r6, lr
   11042:	9001      	str	r0, [sp, #4]
   11044:	9100      	str	r1, [sp, #0]
   11046:	4633      	mov	r3, r6
   11048:	4619      	mov	r1, r3
   1104a:	4811      	ldr	r0, [pc, #68]	; (11090 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   1104c:	f004 f8d4 	bl	151f8 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   11050:	9801      	ldr	r0, [sp, #4]
   11052:	f7ff ffb5 	bl	10fc0 <Gpio::ValidPortCheck()>
    interrupthandlers[interupt_port_][pin_->GetPin()] = function;
   11056:	9c00      	ldr	r4, [sp, #0]
   11058:	9b01      	ldr	r3, [sp, #4]
   1105a:	791b      	ldrb	r3, [r3, #4]
   1105c:	461d      	mov	r5, r3
   1105e:	9b01      	ldr	r3, [sp, #4]
   11060:	689a      	ldr	r2, [r3, #8]
   11062:	9b01      	ldr	r3, [sp, #4]
   11064:	689b      	ldr	r3, [r3, #8]
   11066:	681b      	ldr	r3, [r3, #0]
   11068:	3330      	adds	r3, #48	; 0x30
   1106a:	681b      	ldr	r3, [r3, #0]
   1106c:	4610      	mov	r0, r2
   1106e:	4798      	blx	r3
   11070:	4603      	mov	r3, r0
   11072:	4619      	mov	r1, r3
   11074:	4a07      	ldr	r2, [pc, #28]	; (11094 <Gpio::SetInterruptRoutine(void (*)())+0x58>)
   11076:	016b      	lsls	r3, r5, #5
   11078:	440b      	add	r3, r1
   1107a:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
   1107e:	4633      	mov	r3, r6
   11080:	4619      	mov	r1, r3
   11082:	4803      	ldr	r0, [pc, #12]	; (11090 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   11084:	f004 f8cc 	bl	15220 <__cyg_profile_func_exit>
  }
   11088:	bf00      	nop
   1108a:	b002      	add	sp, #8
   1108c:	bd70      	pop	{r4, r5, r6, pc}
   1108e:	bf00      	nop
   11090:	0001103d 	.word	0x0001103d
   11094:	10000970 	.word	0x10000970

00011098 <Gpio::ClearInterruptRoutine()>:

  // Clears the developers ISR function from the port/pin gio instance.
  void ClearInterruptRoutine() override
   11098:	b530      	push	{r4, r5, lr}
   1109a:	b083      	sub	sp, #12
   1109c:	4675      	mov	r5, lr
   1109e:	9001      	str	r0, [sp, #4]
   110a0:	462b      	mov	r3, r5
   110a2:	4619      	mov	r1, r3
   110a4:	480f      	ldr	r0, [pc, #60]	; (110e4 <Gpio::ClearInterruptRoutine()+0x4c>)
   110a6:	f004 f8a7 	bl	151f8 <__cyg_profile_func_enter>
  {
    interrupthandlers[interupt_port_][pin_->GetPin()] = nullptr;
   110aa:	9b01      	ldr	r3, [sp, #4]
   110ac:	791b      	ldrb	r3, [r3, #4]
   110ae:	461c      	mov	r4, r3
   110b0:	9b01      	ldr	r3, [sp, #4]
   110b2:	689a      	ldr	r2, [r3, #8]
   110b4:	9b01      	ldr	r3, [sp, #4]
   110b6:	689b      	ldr	r3, [r3, #8]
   110b8:	681b      	ldr	r3, [r3, #0]
   110ba:	3330      	adds	r3, #48	; 0x30
   110bc:	681b      	ldr	r3, [r3, #0]
   110be:	4610      	mov	r0, r2
   110c0:	4798      	blx	r3
   110c2:	4603      	mov	r3, r0
   110c4:	4619      	mov	r1, r3
   110c6:	4a08      	ldr	r2, [pc, #32]	; (110e8 <Gpio::ClearInterruptRoutine()+0x50>)
   110c8:	0163      	lsls	r3, r4, #5
   110ca:	440b      	add	r3, r1
   110cc:	2100      	movs	r1, #0
   110ce:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   110d2:	462b      	mov	r3, r5
   110d4:	4619      	mov	r1, r3
   110d6:	4803      	ldr	r0, [pc, #12]	; (110e4 <Gpio::ClearInterruptRoutine()+0x4c>)
   110d8:	f004 f8a2 	bl	15220 <__cyg_profile_func_exit>
  }
   110dc:	bf00      	nop
   110de:	b003      	add	sp, #12
   110e0:	bd30      	pop	{r4, r5, pc}
   110e2:	bf00      	nop
   110e4:	00011099 	.word	0x00011099
   110e8:	10000970 	.word	0x10000970

000110ec <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>:
//
// @param enum_type_value variable you would like to get the value of.
// @return the value of the enum class type variable of with the underlying
//         type of the enum class.
template <typename Enum, typename Type = typename std::underlying_type_t<Enum>>
constexpr Type Value(Enum enum_type_value)
   110ec:	b530      	push	{r4, r5, lr}
   110ee:	b083      	sub	sp, #12
   110f0:	4675      	mov	r5, lr
   110f2:	4603      	mov	r3, r0
   110f4:	f88d 3007 	strb.w	r3, [sp, #7]
   110f8:	462b      	mov	r3, r5
   110fa:	4619      	mov	r1, r3
   110fc:	4806      	ldr	r0, [pc, #24]	; (11118 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   110fe:	f004 f87b 	bl	151f8 <__cyg_profile_func_enter>
{
  return static_cast<Type>(enum_type_value);
   11102:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11106:	462b      	mov	r3, r5
   11108:	4619      	mov	r1, r3
   1110a:	4803      	ldr	r0, [pc, #12]	; (11118 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   1110c:	f004 f888 	bl	15220 <__cyg_profile_func_exit>
   11110:	4623      	mov	r3, r4
}
   11112:	4618      	mov	r0, r3
   11114:	b003      	add	sp, #12
   11116:	bd30      	pop	{r4, r5, pc}
   11118:	000110ed 	.word	0x000110ed

0001111c <Gpio::SetInterruptEdge(GpioInterface::Edge)>:

  // Sets the selected edge that the gpio interrupt will be triggered on.
  void SetInterruptEdge(Edge edge) override
   1111c:	b510      	push	{r4, lr}
   1111e:	b084      	sub	sp, #16
   11120:	4674      	mov	r4, lr
   11122:	9003      	str	r0, [sp, #12]
   11124:	460b      	mov	r3, r1
   11126:	f88d 300b 	strb.w	r3, [sp, #11]
   1112a:	4623      	mov	r3, r4
   1112c:	4619      	mov	r1, r3
   1112e:	4819      	ldr	r0, [pc, #100]	; (11194 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   11130:	f004 f862 	bl	151f8 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   11134:	9803      	ldr	r0, [sp, #12]
   11136:	f7ff ff43 	bl	10fc0 <Gpio::ValidPortCheck()>
    switch (edge)
   1113a:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1113e:	2b01      	cmp	r3, #1
   11140:	d008      	beq.n	11154 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x38>
   11142:	2b01      	cmp	r3, #1
   11144:	d302      	bcc.n	1114c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x30>
   11146:	2b02      	cmp	r3, #2
   11148:	d008      	beq.n	1115c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x40>
   1114a:	e00e      	b.n	1116a <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        SetEdgeRising();
   1114c:	9803      	ldr	r0, [sp, #12]
   1114e:	f000 f8b1 	bl	112b4 <Gpio::SetEdgeRising()>
        break;
   11152:	e017      	b.n	11184 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        SetEdgeFalling();
   11154:	9803      	ldr	r0, [sp, #12]
   11156:	f000 f8eb 	bl	11330 <Gpio::SetEdgeFalling()>
        break;
   1115a:	e013      	b.n	11184 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        SetEdgeRising();
   1115c:	9803      	ldr	r0, [sp, #12]
   1115e:	f000 f8a9 	bl	112b4 <Gpio::SetEdgeRising()>
        SetEdgeFalling();
   11162:	9803      	ldr	r0, [sp, #12]
   11164:	f000 f8e4 	bl	11330 <Gpio::SetEdgeFalling()>
        break;
   11168:	e00c      	b.n	11184 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   1116a:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1116e:	4618      	mov	r0, r3
   11170:	f7ff ffbc 	bl	110ec <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   11174:	4603      	mov	r3, r0
   11176:	9300      	str	r3, [sp, #0]
   11178:	23d2      	movs	r3, #210	; 0xd2
   1117a:	4a07      	ldr	r2, [pc, #28]	; (11198 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x7c>)
   1117c:	4907      	ldr	r1, [pc, #28]	; (1119c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x80>)
   1117e:	4808      	ldr	r0, [pc, #32]	; (111a0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x84>)
   11180:	f006 fc1e 	bl	179c0 <printf>
   11184:	4623      	mov	r3, r4
   11186:	4619      	mov	r1, r3
   11188:	4802      	ldr	r0, [pc, #8]	; (11194 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   1118a:	f004 f849 	bl	15220 <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
            util::Value(edge));
      }
    }
  }
   1118e:	bf00      	nop
   11190:	b004      	add	sp, #16
   11192:	bd10      	pop	{r4, pc}
   11194:	0001111d 	.word	0x0001111d
   11198:	0001a0d0 	.word	0x0001a0d0
   1119c:	00019c34 	.word	0x00019c34
   111a0:	000197e4 	.word	0x000197e4

000111a4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)>:

  // Clears the seleted edge of the gpio interrupt from being triggered.
  void ClearInterruptEdge(Edge edge) override
   111a4:	b510      	push	{r4, lr}
   111a6:	b084      	sub	sp, #16
   111a8:	4674      	mov	r4, lr
   111aa:	9003      	str	r0, [sp, #12]
   111ac:	460b      	mov	r3, r1
   111ae:	f88d 300b 	strb.w	r3, [sp, #11]
   111b2:	4623      	mov	r3, r4
   111b4:	4619      	mov	r1, r3
   111b6:	4819      	ldr	r0, [pc, #100]	; (1121c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   111b8:	f004 f81e 	bl	151f8 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   111bc:	9803      	ldr	r0, [sp, #12]
   111be:	f7ff feff 	bl	10fc0 <Gpio::ValidPortCheck()>
    switch (edge)
   111c2:	f89d 300b 	ldrb.w	r3, [sp, #11]
   111c6:	2b01      	cmp	r3, #1
   111c8:	d008      	beq.n	111dc <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x38>
   111ca:	2b01      	cmp	r3, #1
   111cc:	d302      	bcc.n	111d4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x30>
   111ce:	2b02      	cmp	r3, #2
   111d0:	d008      	beq.n	111e4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x40>
   111d2:	e00e      	b.n	111f2 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        ClearEdgeRising();
   111d4:	9803      	ldr	r0, [sp, #12]
   111d6:	f000 f8e9 	bl	113ac <Gpio::ClearEdgeRising()>
        break;
   111da:	e017      	b.n	1120c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        ClearEdgeFalling();
   111dc:	9803      	ldr	r0, [sp, #12]
   111de:	f000 f923 	bl	11428 <Gpio::ClearEdgeFalling()>
        break;
   111e2:	e013      	b.n	1120c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        ClearEdgeRising();
   111e4:	9803      	ldr	r0, [sp, #12]
   111e6:	f000 f8e1 	bl	113ac <Gpio::ClearEdgeRising()>
        ClearEdgeFalling();
   111ea:	9803      	ldr	r0, [sp, #12]
   111ec:	f000 f91c 	bl	11428 <Gpio::ClearEdgeFalling()>
        break;
   111f0:	e00c      	b.n	1120c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   111f2:	f89d 300b 	ldrb.w	r3, [sp, #11]
   111f6:	4618      	mov	r0, r3
   111f8:	f7ff ff78 	bl	110ec <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   111fc:	4603      	mov	r3, r0
   111fe:	9300      	str	r3, [sp, #0]
   11200:	23f2      	movs	r3, #242	; 0xf2
   11202:	4a07      	ldr	r2, [pc, #28]	; (11220 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x7c>)
   11204:	4907      	ldr	r1, [pc, #28]	; (11224 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x80>)
   11206:	4808      	ldr	r0, [pc, #32]	; (11228 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x84>)
   11208:	f006 fbda 	bl	179c0 <printf>
   1120c:	4623      	mov	r3, r4
   1120e:	4619      	mov	r1, r3
   11210:	4802      	ldr	r0, [pc, #8]	; (1121c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   11212:	f004 f805 	bl	15220 <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
           util::Value(edge));
      }
    }
  }
   11216:	bf00      	nop
   11218:	b004      	add	sp, #16
   1121a:	bd10      	pop	{r4, pc}
   1121c:	000111a5 	.word	0x000111a5
   11220:	0001a078 	.word	0x0001a078
   11224:	00019c40 	.word	0x00019c40
   11228:	000197e4 	.word	0x000197e4

0001122c <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)>:

  // Assign the developer's ISR and sets the selected edge that the gpio
  // interrupt will be triggered on.
  void AttachInterrupt(IsrPointer function, Edge edge) override
   1122c:	b510      	push	{r4, lr}
   1122e:	b084      	sub	sp, #16
   11230:	4674      	mov	r4, lr
   11232:	9003      	str	r0, [sp, #12]
   11234:	9102      	str	r1, [sp, #8]
   11236:	4613      	mov	r3, r2
   11238:	f88d 3007 	strb.w	r3, [sp, #7]
   1123c:	4623      	mov	r3, r4
   1123e:	4619      	mov	r1, r3
   11240:	480b      	ldr	r0, [pc, #44]	; (11270 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   11242:	f003 ffd9 	bl	151f8 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   11246:	9803      	ldr	r0, [sp, #12]
   11248:	f7ff feba 	bl	10fc0 <Gpio::ValidPortCheck()>
    SetInterruptRoutine(function);
   1124c:	9902      	ldr	r1, [sp, #8]
   1124e:	9803      	ldr	r0, [sp, #12]
   11250:	f7ff fef4 	bl	1103c <Gpio::SetInterruptRoutine(void (*)())>
    SetInterruptEdge(edge);
   11254:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11258:	4619      	mov	r1, r3
   1125a:	9803      	ldr	r0, [sp, #12]
   1125c:	f7ff ff5e 	bl	1111c <Gpio::SetInterruptEdge(GpioInterface::Edge)>
   11260:	4623      	mov	r3, r4
   11262:	4619      	mov	r1, r3
   11264:	4802      	ldr	r0, [pc, #8]	; (11270 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   11266:	f003 ffdb 	bl	15220 <__cyg_profile_func_exit>
  }
   1126a:	bf00      	nop
   1126c:	b004      	add	sp, #16
   1126e:	bd10      	pop	{r4, pc}
   11270:	0001122d 	.word	0x0001122d

00011274 <Gpio::DetachInterrupt()>:

  // Removes the developer's ISR and clears the selected edge of the gpio
  // interrupt from being triggered.
  void DetachInterrupt() override
   11274:	b510      	push	{r4, lr}
   11276:	b082      	sub	sp, #8
   11278:	4674      	mov	r4, lr
   1127a:	9001      	str	r0, [sp, #4]
   1127c:	4623      	mov	r3, r4
   1127e:	4619      	mov	r1, r3
   11280:	480b      	ldr	r0, [pc, #44]	; (112b0 <Gpio::DetachInterrupt()+0x3c>)
   11282:	f003 ffb9 	bl	151f8 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   11286:	9801      	ldr	r0, [sp, #4]
   11288:	f7ff fe9a 	bl	10fc0 <Gpio::ValidPortCheck()>
    ClearInterruptRoutine();
   1128c:	9801      	ldr	r0, [sp, #4]
   1128e:	f7ff ff03 	bl	11098 <Gpio::ClearInterruptRoutine()>
    ClearEdgeRising();
   11292:	9801      	ldr	r0, [sp, #4]
   11294:	f000 f88a 	bl	113ac <Gpio::ClearEdgeRising()>
    ClearEdgeFalling();
   11298:	9801      	ldr	r0, [sp, #4]
   1129a:	f000 f8c5 	bl	11428 <Gpio::ClearEdgeFalling()>
   1129e:	4623      	mov	r3, r4
   112a0:	4619      	mov	r1, r3
   112a2:	4803      	ldr	r0, [pc, #12]	; (112b0 <Gpio::DetachInterrupt()+0x3c>)
   112a4:	f003 ffbc 	bl	15220 <__cyg_profile_func_exit>
  }
   112a8:	bf00      	nop
   112aa:	b002      	add	sp, #8
   112ac:	bd10      	pop	{r4, pc}
   112ae:	bf00      	nop
   112b0:	00011275 	.word	0x00011275

000112b4 <Gpio::SetEdgeRising()>:
    *interrupt[triggered_port].clear |= (1 << triggered_pin);
  }

 private:
  // Sets the gpio interrupt to trigger on a rising edge.
  void SetEdgeRising()
   112b4:	b530      	push	{r4, r5, lr}
   112b6:	b083      	sub	sp, #12
   112b8:	4675      	mov	r5, lr
   112ba:	9001      	str	r0, [sp, #4]
   112bc:	462b      	mov	r3, r5
   112be:	4619      	mov	r1, r3
   112c0:	4819      	ldr	r0, [pc, #100]	; (11328 <Gpio::SetEdgeRising()+0x74>)
   112c2:	f003 ff99 	bl	151f8 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge |= (1 << pin_->GetPin());
   112c6:	9b01      	ldr	r3, [sp, #4]
   112c8:	689a      	ldr	r2, [r3, #8]
   112ca:	9b01      	ldr	r3, [sp, #4]
   112cc:	689b      	ldr	r3, [r3, #8]
   112ce:	681b      	ldr	r3, [r3, #0]
   112d0:	3330      	adds	r3, #48	; 0x30
   112d2:	681b      	ldr	r3, [r3, #0]
   112d4:	4610      	mov	r0, r2
   112d6:	4798      	blx	r3
   112d8:	4603      	mov	r3, r0
   112da:	461a      	mov	r2, r3
   112dc:	2301      	movs	r3, #1
   112de:	fa03 f002 	lsl.w	r0, r3, r2
   112e2:	9b01      	ldr	r3, [sp, #4]
   112e4:	791b      	ldrb	r3, [r3, #4]
   112e6:	4619      	mov	r1, r3
   112e8:	4a10      	ldr	r2, [pc, #64]	; (1132c <Gpio::SetEdgeRising()+0x78>)
   112ea:	460b      	mov	r3, r1
   112ec:	009b      	lsls	r3, r3, #2
   112ee:	440b      	add	r3, r1
   112f0:	009b      	lsls	r3, r3, #2
   112f2:	4413      	add	r3, r2
   112f4:	330c      	adds	r3, #12
   112f6:	681b      	ldr	r3, [r3, #0]
   112f8:	681a      	ldr	r2, [r3, #0]
   112fa:	4604      	mov	r4, r0
   112fc:	9b01      	ldr	r3, [sp, #4]
   112fe:	791b      	ldrb	r3, [r3, #4]
   11300:	4618      	mov	r0, r3
   11302:	490a      	ldr	r1, [pc, #40]	; (1132c <Gpio::SetEdgeRising()+0x78>)
   11304:	4603      	mov	r3, r0
   11306:	009b      	lsls	r3, r3, #2
   11308:	4403      	add	r3, r0
   1130a:	009b      	lsls	r3, r3, #2
   1130c:	440b      	add	r3, r1
   1130e:	330c      	adds	r3, #12
   11310:	681b      	ldr	r3, [r3, #0]
   11312:	4322      	orrs	r2, r4
   11314:	601a      	str	r2, [r3, #0]
   11316:	462b      	mov	r3, r5
   11318:	4619      	mov	r1, r3
   1131a:	4803      	ldr	r0, [pc, #12]	; (11328 <Gpio::SetEdgeRising()+0x74>)
   1131c:	f003 ff80 	bl	15220 <__cyg_profile_func_exit>
  }
   11320:	bf00      	nop
   11322:	b003      	add	sp, #12
   11324:	bd30      	pop	{r4, r5, pc}
   11326:	bf00      	nop
   11328:	000112b5 	.word	0x000112b5
   1132c:	10000020 	.word	0x10000020

00011330 <Gpio::SetEdgeFalling()>:

  // Sets the gpio interrupt to trigger on a falling edge.
  void SetEdgeFalling()
   11330:	b530      	push	{r4, r5, lr}
   11332:	b083      	sub	sp, #12
   11334:	4675      	mov	r5, lr
   11336:	9001      	str	r0, [sp, #4]
   11338:	462b      	mov	r3, r5
   1133a:	4619      	mov	r1, r3
   1133c:	4819      	ldr	r0, [pc, #100]	; (113a4 <Gpio::SetEdgeFalling()+0x74>)
   1133e:	f003 ff5b 	bl	151f8 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge |= (1 << pin_->GetPin());
   11342:	9b01      	ldr	r3, [sp, #4]
   11344:	689a      	ldr	r2, [r3, #8]
   11346:	9b01      	ldr	r3, [sp, #4]
   11348:	689b      	ldr	r3, [r3, #8]
   1134a:	681b      	ldr	r3, [r3, #0]
   1134c:	3330      	adds	r3, #48	; 0x30
   1134e:	681b      	ldr	r3, [r3, #0]
   11350:	4610      	mov	r0, r2
   11352:	4798      	blx	r3
   11354:	4603      	mov	r3, r0
   11356:	461a      	mov	r2, r3
   11358:	2301      	movs	r3, #1
   1135a:	fa03 f002 	lsl.w	r0, r3, r2
   1135e:	9b01      	ldr	r3, [sp, #4]
   11360:	791b      	ldrb	r3, [r3, #4]
   11362:	4619      	mov	r1, r3
   11364:	4a10      	ldr	r2, [pc, #64]	; (113a8 <Gpio::SetEdgeFalling()+0x78>)
   11366:	460b      	mov	r3, r1
   11368:	009b      	lsls	r3, r3, #2
   1136a:	440b      	add	r3, r1
   1136c:	009b      	lsls	r3, r3, #2
   1136e:	4413      	add	r3, r2
   11370:	3310      	adds	r3, #16
   11372:	681b      	ldr	r3, [r3, #0]
   11374:	681a      	ldr	r2, [r3, #0]
   11376:	4604      	mov	r4, r0
   11378:	9b01      	ldr	r3, [sp, #4]
   1137a:	791b      	ldrb	r3, [r3, #4]
   1137c:	4618      	mov	r0, r3
   1137e:	490a      	ldr	r1, [pc, #40]	; (113a8 <Gpio::SetEdgeFalling()+0x78>)
   11380:	4603      	mov	r3, r0
   11382:	009b      	lsls	r3, r3, #2
   11384:	4403      	add	r3, r0
   11386:	009b      	lsls	r3, r3, #2
   11388:	440b      	add	r3, r1
   1138a:	3310      	adds	r3, #16
   1138c:	681b      	ldr	r3, [r3, #0]
   1138e:	4322      	orrs	r2, r4
   11390:	601a      	str	r2, [r3, #0]
   11392:	462b      	mov	r3, r5
   11394:	4619      	mov	r1, r3
   11396:	4803      	ldr	r0, [pc, #12]	; (113a4 <Gpio::SetEdgeFalling()+0x74>)
   11398:	f003 ff42 	bl	15220 <__cyg_profile_func_exit>
  }
   1139c:	bf00      	nop
   1139e:	b003      	add	sp, #12
   113a0:	bd30      	pop	{r4, r5, pc}
   113a2:	bf00      	nop
   113a4:	00011331 	.word	0x00011331
   113a8:	10000020 	.word	0x10000020

000113ac <Gpio::ClearEdgeRising()>:

  // Clears the gpio interrupt to no longer trigger on a rising edge.
  void ClearEdgeRising()
   113ac:	b530      	push	{r4, r5, lr}
   113ae:	b083      	sub	sp, #12
   113b0:	4675      	mov	r5, lr
   113b2:	9001      	str	r0, [sp, #4]
   113b4:	462b      	mov	r3, r5
   113b6:	4619      	mov	r1, r3
   113b8:	4819      	ldr	r0, [pc, #100]	; (11420 <Gpio::ClearEdgeRising()+0x74>)
   113ba:	f003 ff1d 	bl	151f8 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge &= ~(1 << pin_->GetPin());
   113be:	9b01      	ldr	r3, [sp, #4]
   113c0:	689a      	ldr	r2, [r3, #8]
   113c2:	9b01      	ldr	r3, [sp, #4]
   113c4:	689b      	ldr	r3, [r3, #8]
   113c6:	681b      	ldr	r3, [r3, #0]
   113c8:	3330      	adds	r3, #48	; 0x30
   113ca:	681b      	ldr	r3, [r3, #0]
   113cc:	4610      	mov	r0, r2
   113ce:	4798      	blx	r3
   113d0:	4603      	mov	r3, r0
   113d2:	461a      	mov	r2, r3
   113d4:	2301      	movs	r3, #1
   113d6:	4093      	lsls	r3, r2
   113d8:	43d8      	mvns	r0, r3
   113da:	9b01      	ldr	r3, [sp, #4]
   113dc:	791b      	ldrb	r3, [r3, #4]
   113de:	4619      	mov	r1, r3
   113e0:	4a10      	ldr	r2, [pc, #64]	; (11424 <Gpio::ClearEdgeRising()+0x78>)
   113e2:	460b      	mov	r3, r1
   113e4:	009b      	lsls	r3, r3, #2
   113e6:	440b      	add	r3, r1
   113e8:	009b      	lsls	r3, r3, #2
   113ea:	4413      	add	r3, r2
   113ec:	330c      	adds	r3, #12
   113ee:	681b      	ldr	r3, [r3, #0]
   113f0:	681a      	ldr	r2, [r3, #0]
   113f2:	4604      	mov	r4, r0
   113f4:	9b01      	ldr	r3, [sp, #4]
   113f6:	791b      	ldrb	r3, [r3, #4]
   113f8:	4618      	mov	r0, r3
   113fa:	490a      	ldr	r1, [pc, #40]	; (11424 <Gpio::ClearEdgeRising()+0x78>)
   113fc:	4603      	mov	r3, r0
   113fe:	009b      	lsls	r3, r3, #2
   11400:	4403      	add	r3, r0
   11402:	009b      	lsls	r3, r3, #2
   11404:	440b      	add	r3, r1
   11406:	330c      	adds	r3, #12
   11408:	681b      	ldr	r3, [r3, #0]
   1140a:	4022      	ands	r2, r4
   1140c:	601a      	str	r2, [r3, #0]
   1140e:	462b      	mov	r3, r5
   11410:	4619      	mov	r1, r3
   11412:	4803      	ldr	r0, [pc, #12]	; (11420 <Gpio::ClearEdgeRising()+0x74>)
   11414:	f003 ff04 	bl	15220 <__cyg_profile_func_exit>
  }
   11418:	bf00      	nop
   1141a:	b003      	add	sp, #12
   1141c:	bd30      	pop	{r4, r5, pc}
   1141e:	bf00      	nop
   11420:	000113ad 	.word	0x000113ad
   11424:	10000020 	.word	0x10000020

00011428 <Gpio::ClearEdgeFalling()>:

  // Clears the gpio interrupt to no longer trigger on a falling edge.
  void ClearEdgeFalling()
   11428:	b530      	push	{r4, r5, lr}
   1142a:	b083      	sub	sp, #12
   1142c:	4675      	mov	r5, lr
   1142e:	9001      	str	r0, [sp, #4]
   11430:	462b      	mov	r3, r5
   11432:	4619      	mov	r1, r3
   11434:	4819      	ldr	r0, [pc, #100]	; (1149c <Gpio::ClearEdgeFalling()+0x74>)
   11436:	f003 fedf 	bl	151f8 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge &= ~(1 << pin_->GetPin());
   1143a:	9b01      	ldr	r3, [sp, #4]
   1143c:	689a      	ldr	r2, [r3, #8]
   1143e:	9b01      	ldr	r3, [sp, #4]
   11440:	689b      	ldr	r3, [r3, #8]
   11442:	681b      	ldr	r3, [r3, #0]
   11444:	3330      	adds	r3, #48	; 0x30
   11446:	681b      	ldr	r3, [r3, #0]
   11448:	4610      	mov	r0, r2
   1144a:	4798      	blx	r3
   1144c:	4603      	mov	r3, r0
   1144e:	461a      	mov	r2, r3
   11450:	2301      	movs	r3, #1
   11452:	4093      	lsls	r3, r2
   11454:	43d8      	mvns	r0, r3
   11456:	9b01      	ldr	r3, [sp, #4]
   11458:	791b      	ldrb	r3, [r3, #4]
   1145a:	4619      	mov	r1, r3
   1145c:	4a10      	ldr	r2, [pc, #64]	; (114a0 <Gpio::ClearEdgeFalling()+0x78>)
   1145e:	460b      	mov	r3, r1
   11460:	009b      	lsls	r3, r3, #2
   11462:	440b      	add	r3, r1
   11464:	009b      	lsls	r3, r3, #2
   11466:	4413      	add	r3, r2
   11468:	3310      	adds	r3, #16
   1146a:	681b      	ldr	r3, [r3, #0]
   1146c:	681a      	ldr	r2, [r3, #0]
   1146e:	4604      	mov	r4, r0
   11470:	9b01      	ldr	r3, [sp, #4]
   11472:	791b      	ldrb	r3, [r3, #4]
   11474:	4618      	mov	r0, r3
   11476:	490a      	ldr	r1, [pc, #40]	; (114a0 <Gpio::ClearEdgeFalling()+0x78>)
   11478:	4603      	mov	r3, r0
   1147a:	009b      	lsls	r3, r3, #2
   1147c:	4403      	add	r3, r0
   1147e:	009b      	lsls	r3, r3, #2
   11480:	440b      	add	r3, r1
   11482:	3310      	adds	r3, #16
   11484:	681b      	ldr	r3, [r3, #0]
   11486:	4022      	ands	r2, r4
   11488:	601a      	str	r2, [r3, #0]
   1148a:	462b      	mov	r3, r5
   1148c:	4619      	mov	r1, r3
   1148e:	4803      	ldr	r0, [pc, #12]	; (1149c <Gpio::ClearEdgeFalling()+0x74>)
   11490:	f003 fec6 	bl	15220 <__cyg_profile_func_exit>
  }
   11494:	bf00      	nop
   11496:	b003      	add	sp, #12
   11498:	bd30      	pop	{r4, r5, pc}
   1149a:	bf00      	nop
   1149c:	00011429 	.word	0x00011429
   114a0:	10000020 	.word	0x10000020

000114a4 <SystemControllerInterface::SystemControllerInterface()>:
#include "L0_LowLevel/LPC40xx.h"
#include "utility/enum.hpp"
#include "utility/log.hpp"
#include "utility/macros.hpp"

class SystemControllerInterface
   114a4:	b082      	sub	sp, #8
   114a6:	9001      	str	r0, [sp, #4]
   114a8:	4a03      	ldr	r2, [pc, #12]	; (114b8 <SystemControllerInterface::SystemControllerInterface()+0x14>)
   114aa:	9b01      	ldr	r3, [sp, #4]
   114ac:	601a      	str	r2, [r3, #0]
   114ae:	9b01      	ldr	r3, [sp, #4]
   114b0:	4618      	mov	r0, r3
   114b2:	b002      	add	sp, #8
   114b4:	4770      	bx	lr
   114b6:	bf00      	nop
   114b8:	00019e14 	.word	0x00019e14

000114bc <Lpc40xxSystemController::Lpc40xxSystemController()>:
  static constexpr uint32_t kDefaultIRCFrequency    = 12'000'000;
  static constexpr uint32_t kDefaultTimeout         = 1'000;  // ms

  inline static LPC_SC_TypeDef * system_controller = LPC_SC;

  constexpr Lpc40xxSystemController() {}
   114bc:	b500      	push	{lr}
   114be:	b083      	sub	sp, #12
   114c0:	9001      	str	r0, [sp, #4]
   114c2:	9b01      	ldr	r3, [sp, #4]
   114c4:	4618      	mov	r0, r3
   114c6:	f7ff ffed 	bl	114a4 <SystemControllerInterface::SystemControllerInterface()>
   114ca:	4a04      	ldr	r2, [pc, #16]	; (114dc <Lpc40xxSystemController::Lpc40xxSystemController()+0x20>)
   114cc:	9b01      	ldr	r3, [sp, #4]
   114ce:	601a      	str	r2, [r3, #0]
   114d0:	9b01      	ldr	r3, [sp, #4]
   114d2:	4618      	mov	r0, r3
   114d4:	b003      	add	sp, #12
   114d6:	f85d fb04 	ldr.w	pc, [sp], #4
   114da:	bf00      	nop
   114dc:	00019df0 	.word	0x00019df0

000114e0 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>:

  uint32_t SetClockFrequency(uint8_t frequency_in_mhz) override
   114e0:	b500      	push	{lr}
   114e2:	b085      	sub	sp, #20
   114e4:	9001      	str	r0, [sp, #4]
   114e6:	460b      	mov	r3, r1
   114e8:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    uint32_t offset = 0;
   114ec:	2300      	movs	r3, #0
   114ee:	9303      	str	r3, [sp, #12]
    SelectOscillatorSource(OscillatorSource::kIrc);
   114f0:	2100      	movs	r1, #0
   114f2:	9801      	ldr	r0, [sp, #4]
   114f4:	f000 f8ce 	bl	11694 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    if (frequency_in_mhz > 12)
   114f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
   114fc:	2b0c      	cmp	r3, #12
   114fe:	d916      	bls.n	1152e <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x4e>
    {
      offset = SetMainPll(PllInput::kIrc, frequency_in_mhz);
   11500:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11504:	b29b      	uxth	r3, r3
   11506:	461a      	mov	r2, r3
   11508:	210c      	movs	r1, #12
   1150a:	9801      	ldr	r0, [sp, #4]
   1150c:	f000 f9ac 	bl	11868 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>
   11510:	9003      	str	r0, [sp, #12]
      SelectMainClockSource(MainClockSource::kPllClock);
   11512:	f44f 7180 	mov.w	r1, #256	; 0x100
   11516:	9801      	ldr	r0, [sp, #4]
   11518:	f000 f8d6 	bl	116c8 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = frequency_in_mhz * 1'000'000;
   1151c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11520:	4a10      	ldr	r2, [pc, #64]	; (11564 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x84>)
   11522:	fb02 f303 	mul.w	r3, r2, r3
   11526:	461a      	mov	r2, r3
   11528:	4b0f      	ldr	r3, [pc, #60]	; (11568 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   1152a:	601a      	str	r2, [r3, #0]
   1152c:	e006      	b.n	1153c <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x5c>
    }
    else
    {
      SelectMainClockSource(MainClockSource::kBaseClock);
   1152e:	2100      	movs	r1, #0
   11530:	9801      	ldr	r0, [sp, #4]
   11532:	f000 f8c9 	bl	116c8 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = kDefaultIRCFrequency;
   11536:	4b0c      	ldr	r3, [pc, #48]	; (11568 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   11538:	4a0c      	ldr	r2, [pc, #48]	; (1156c <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x8c>)
   1153a:	601a      	str	r2, [r3, #0]
    }
    SetCpuClockDivider(kDivideInputBy1);
   1153c:	2101      	movs	r1, #1
   1153e:	9801      	ldr	r0, [sp, #4]
   11540:	f000 fa4a 	bl	119d8 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>
    SetPeripheralClockDivider(kDivideInputBy1);
   11544:	9b01      	ldr	r3, [sp, #4]
   11546:	681b      	ldr	r3, [r3, #0]
   11548:	3304      	adds	r3, #4
   1154a:	681b      	ldr	r3, [r3, #0]
   1154c:	2101      	movs	r1, #1
   1154e:	9801      	ldr	r0, [sp, #4]
   11550:	4798      	blx	r3
    SetEmcClockDivider(EmcDivider::kSameSpeedAsCpu);
   11552:	2100      	movs	r1, #0
   11554:	9801      	ldr	r0, [sp, #4]
   11556:	f000 fa73 	bl	11a40 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>
    return offset;
   1155a:	9b03      	ldr	r3, [sp, #12]
  }
   1155c:	4618      	mov	r0, r3
   1155e:	b005      	add	sp, #20
   11560:	f85d fb04 	ldr.w	pc, [sp], #4
   11564:	000f4240 	.word	0x000f4240
   11568:	1000004c 	.word	0x1000004c
   1156c:	00b71b00 	.word	0x00b71b00

00011570 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>:

  void SetPeripheralClockDivider(uint8_t peripheral_divider) override
   11570:	b500      	push	{lr}
   11572:	b083      	sub	sp, #12
   11574:	9001      	str	r0, [sp, #4]
   11576:	460b      	mov	r3, r1
   11578:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(peripheral_divider <= 4, "Divider mustn't exceed 32");
   1157c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11580:	2b04      	cmp	r3, #4
   11582:	d90d      	bls.n	115a0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x30>
   11584:	23ae      	movs	r3, #174	; 0xae
   11586:	4a0b      	ldr	r2, [pc, #44]	; (115b4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x44>)
   11588:	490b      	ldr	r1, [pc, #44]	; (115b8 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x48>)
   1158a:	480c      	ldr	r0, [pc, #48]	; (115bc <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x4c>)
   1158c:	f006 fa18 	bl	179c0 <printf>
   11590:	480b      	ldr	r0, [pc, #44]	; (115c0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x50>)
   11592:	f003 fe01 	bl	15198 <puts>
   11596:	2100      	movs	r1, #0
   11598:	2001      	movs	r0, #1
   1159a:	f7ff fa1b 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   1159e:	e7fe      	b.n	1159e <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x2e>
    system_controller->PCLKSEL = peripheral_divider;
   115a0:	4b08      	ldr	r3, [pc, #32]	; (115c4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x54>)
   115a2:	681b      	ldr	r3, [r3, #0]
   115a4:	f89d 2003 	ldrb.w	r2, [sp, #3]
   115a8:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  }
   115ac:	bf00      	nop
   115ae:	b003      	add	sp, #12
   115b0:	f85d fb04 	ldr.w	pc, [sp], #4
   115b4:	00019f38 	.word	0x00019f38
   115b8:	00019c4c 	.word	0x00019c4c
   115bc:	00019884 	.word	0x00019884
   115c0:	00019924 	.word	0x00019924
   115c4:	10000048 	.word	0x10000048

000115c8 <Lpc40xxSystemController::GetPeripheralClockDivider() const>:

  uint32_t GetPeripheralClockDivider() const override
   115c8:	b082      	sub	sp, #8
   115ca:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return 1;
#else
    return system_controller->PCLKSEL;
   115cc:	4b03      	ldr	r3, [pc, #12]	; (115dc <Lpc40xxSystemController::GetPeripheralClockDivider() const+0x14>)
   115ce:	681b      	ldr	r3, [r3, #0]
   115d0:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
#endif
  }
   115d4:	4618      	mov	r0, r3
   115d6:	b002      	add	sp, #8
   115d8:	4770      	bx	lr
   115da:	bf00      	nop
   115dc:	10000048 	.word	0x10000048

000115e0 <Lpc40xxSystemController::GetSystemFrequency() const>:

  uint32_t GetSystemFrequency() const override
   115e0:	b082      	sub	sp, #8
   115e2:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return config::kSystemClockRate;
#else
    return speed_in_hertz;
   115e4:	4b02      	ldr	r3, [pc, #8]	; (115f0 <Lpc40xxSystemController::GetSystemFrequency() const+0x10>)
   115e6:	681b      	ldr	r3, [r3, #0]
#endif
  }
   115e8:	4618      	mov	r0, r3
   115ea:	b002      	add	sp, #8
   115ec:	4770      	bx	lr
   115ee:	bf00      	nop
   115f0:	1000004c 	.word	0x1000004c

000115f4 <Lpc40xxSystemController::GetPeripheralFrequency() const>:

  uint32_t GetPeripheralFrequency() const override
   115f4:	b500      	push	{lr}
   115f6:	b085      	sub	sp, #20
   115f8:	9001      	str	r0, [sp, #4]
  {
    uint32_t peripheral_clock_divider = GetPeripheralClockDivider();
   115fa:	9b01      	ldr	r3, [sp, #4]
   115fc:	681b      	ldr	r3, [r3, #0]
   115fe:	3308      	adds	r3, #8
   11600:	681b      	ldr	r3, [r3, #0]
   11602:	9801      	ldr	r0, [sp, #4]
   11604:	4798      	blx	r3
   11606:	9002      	str	r0, [sp, #8]
    uint32_t result = 0;  // return 0 if peripheral_clock_divider == 0
   11608:	2300      	movs	r3, #0
   1160a:	9303      	str	r3, [sp, #12]
    if (peripheral_clock_divider != 0)
   1160c:	9b02      	ldr	r3, [sp, #8]
   1160e:	2b00      	cmp	r3, #0
   11610:	d00a      	beq.n	11628 <Lpc40xxSystemController::GetPeripheralFrequency() const+0x34>
    {
      result = GetSystemFrequency() / peripheral_clock_divider;
   11612:	9b01      	ldr	r3, [sp, #4]
   11614:	681b      	ldr	r3, [r3, #0]
   11616:	330c      	adds	r3, #12
   11618:	681b      	ldr	r3, [r3, #0]
   1161a:	9801      	ldr	r0, [sp, #4]
   1161c:	4798      	blx	r3
   1161e:	4602      	mov	r2, r0
   11620:	9b02      	ldr	r3, [sp, #8]
   11622:	fbb2 f3f3 	udiv	r3, r2, r3
   11626:	9303      	str	r3, [sp, #12]
    }
    return result;
   11628:	9b03      	ldr	r3, [sp, #12]
  }
   1162a:	4618      	mov	r0, r3
   1162c:	b005      	add	sp, #20
   1162e:	f85d fb04 	ldr.w	pc, [sp], #4
   11632:	Address 0x0000000000011632 is out of bounds.


00011634 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>:

  void PowerUpPeripheral(const PeripheralID & peripheral_select) override
   11634:	b084      	sub	sp, #16
   11636:	9001      	str	r0, [sp, #4]
   11638:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_with_enabled_peripheral =
        system_controller->PCONP | (1 << peripheral_select.device_id);
   1163a:	4b09      	ldr	r3, [pc, #36]	; (11660 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   1163c:	681b      	ldr	r3, [r3, #0]
   1163e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   11642:	9a00      	ldr	r2, [sp, #0]
   11644:	6812      	ldr	r2, [r2, #0]
   11646:	2101      	movs	r1, #1
   11648:	fa01 f202 	lsl.w	r2, r1, r2
   1164c:	4313      	orrs	r3, r2
   1164e:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_with_enabled_peripheral;
   11650:	4b03      	ldr	r3, [pc, #12]	; (11660 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11652:	681b      	ldr	r3, [r3, #0]
   11654:	9a03      	ldr	r2, [sp, #12]
   11656:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   1165a:	bf00      	nop
   1165c:	b004      	add	sp, #16
   1165e:	4770      	bx	lr
   11660:	10000048 	.word	0x10000048

00011664 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)>:
  void PowerDownPeripheral(const PeripheralID & peripheral_select) override
   11664:	b084      	sub	sp, #16
   11666:	9001      	str	r0, [sp, #4]
   11668:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_without_enabled_peripheral =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   1166a:	4b09      	ldr	r3, [pc, #36]	; (11690 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   1166c:	681b      	ldr	r3, [r3, #0]
   1166e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   11672:	9a00      	ldr	r2, [sp, #0]
   11674:	6812      	ldr	r2, [r2, #0]
   11676:	2101      	movs	r1, #1
   11678:	fa01 f202 	lsl.w	r2, r1, r2
   1167c:	4013      	ands	r3, r2
   1167e:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_without_enabled_peripheral;
   11680:	4b03      	ldr	r3, [pc, #12]	; (11690 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11682:	681b      	ldr	r3, [r3, #0]
   11684:	9a03      	ldr	r2, [sp, #12]
   11686:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   1168a:	bf00      	nop
   1168c:	b004      	add	sp, #16
   1168e:	4770      	bx	lr
   11690:	10000048 	.word	0x10000048

00011694 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>:

 private:
  void SelectOscillatorSource(OscillatorSource source)
   11694:	b084      	sub	sp, #16
   11696:	9001      	str	r0, [sp, #4]
   11698:	460b      	mov	r3, r1
   1169a:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    uint32_t source_bit = static_cast<uint32_t>(source);
   1169e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   116a2:	9303      	str	r3, [sp, #12]
    system_controller->CLKSRCSEL =
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   116a4:	4b07      	ldr	r3, [pc, #28]	; (116c4 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   116a6:	681b      	ldr	r3, [r3, #0]
   116a8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   116ac:	f023 0101 	bic.w	r1, r3, #1
    system_controller->CLKSRCSEL =
   116b0:	4b04      	ldr	r3, [pc, #16]	; (116c4 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   116b2:	681b      	ldr	r3, [r3, #0]
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   116b4:	9a03      	ldr	r2, [sp, #12]
   116b6:	430a      	orrs	r2, r1
    system_controller->CLKSRCSEL =
   116b8:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  }
   116bc:	bf00      	nop
   116be:	b004      	add	sp, #16
   116c0:	4770      	bx	lr
   116c2:	bf00      	nop
   116c4:	10000048 	.word	0x10000048

000116c8 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>:

  void SelectMainClockSource(MainClockSource source)
   116c8:	b082      	sub	sp, #8
   116ca:	9001      	str	r0, [sp, #4]
   116cc:	460b      	mov	r3, r1
   116ce:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   116d2:	4b08      	ldr	r3, [pc, #32]	; (116f4 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   116d4:	681b      	ldr	r3, [r3, #0]
   116d6:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   116da:	f423 7180 	bic.w	r1, r3, #256	; 0x100
        static_cast<uint32_t>(source);
   116de:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->CCLKSEL =
   116e2:	4b04      	ldr	r3, [pc, #16]	; (116f4 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   116e4:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   116e6:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   116e8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   116ec:	bf00      	nop
   116ee:	b002      	add	sp, #8
   116f0:	4770      	bx	lr
   116f2:	bf00      	nop
   116f4:	10000048 	.word	0x10000048

000116f8 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>:

  void SelectUsbClockSource(UsbSource usb_clock)
   116f8:	b082      	sub	sp, #8
   116fa:	9001      	str	r0, [sp, #4]
   116fc:	460b      	mov	r3, r1
   116fe:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->USBCLKSEL =
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11702:	4b08      	ldr	r3, [pc, #32]	; (11724 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11704:	681b      	ldr	r3, [r3, #0]
   11706:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   1170a:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(usb_clock);
   1170e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->USBCLKSEL =
   11712:	4b04      	ldr	r3, [pc, #16]	; (11724 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11714:	681b      	ldr	r3, [r3, #0]
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11716:	430a      	orrs	r2, r1
    system_controller->USBCLKSEL =
   11718:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
   1171c:	bf00      	nop
   1171e:	b002      	add	sp, #8
   11720:	4770      	bx	lr
   11722:	bf00      	nop
   11724:	10000048 	.word	0x10000048

00011728 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>:

  void SelectSpifiClockSource(SpifiSource spifi_clock)
   11728:	b082      	sub	sp, #8
   1172a:	9001      	str	r0, [sp, #4]
   1172c:	460b      	mov	r3, r1
   1172e:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->SPIFISEL =
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   11732:	4b08      	ldr	r3, [pc, #32]	; (11754 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11734:	681b      	ldr	r3, [r3, #0]
   11736:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
   1173a:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(spifi_clock);
   1173e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->SPIFISEL =
   11742:	4b04      	ldr	r3, [pc, #16]	; (11754 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11744:	681b      	ldr	r3, [r3, #0]
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   11746:	430a      	orrs	r2, r1
    system_controller->SPIFISEL =
   11748:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  }
   1174c:	bf00      	nop
   1174e:	b002      	add	sp, #8
   11750:	4770      	bx	lr
   11752:	bf00      	nop
   11754:	10000048 	.word	0x10000048

00011758 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t CalculatePll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   11758:	b500      	push	{lr}
   1175a:	b087      	sub	sp, #28
   1175c:	9001      	str	r0, [sp, #4]
   1175e:	460b      	mov	r3, r1
   11760:	f8ad 3002 	strh.w	r3, [sp, #2]
   11764:	4613      	mov	r3, r2
   11766:	f8ad 3000 	strh.w	r3, [sp]
  {
    SJ2_ASSERT_FATAL(desired_speed_in_mhz < 384 && desired_speed_in_mhz > 12,
   1176a:	f8bd 3000 	ldrh.w	r3, [sp]
   1176e:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
   11772:	d203      	bcs.n	1177c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x24>
   11774:	f8bd 3000 	ldrh.w	r3, [sp]
   11778:	2b0c      	cmp	r3, #12
   1177a:	d80d      	bhi.n	11798 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x40>
   1177c:	23ff      	movs	r3, #255	; 0xff
   1177e:	4a34      	ldr	r2, [pc, #208]	; (11850 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   11780:	4934      	ldr	r1, [pc, #208]	; (11854 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xfc>)
   11782:	4835      	ldr	r0, [pc, #212]	; (11858 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x100>)
   11784:	f006 f91c 	bl	179c0 <printf>
   11788:	4834      	ldr	r0, [pc, #208]	; (1185c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   1178a:	f003 fd05 	bl	15198 <puts>
   1178e:	2100      	movs	r1, #0
   11790:	2001      	movs	r0, #1
   11792:	f7ff f91f 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   11796:	e7fe      	b.n	11796 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x3e>
                     "Frequency must be lower than 384 MHz"
                     "and greater than or equal to 12 MHz");
    bool calculating = true;
   11798:	2301      	movs	r3, #1
   1179a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32_t multiplier_value;
    if ((desired_speed_in_mhz % static_cast<uint16_t>(input_frequency)) >= 1)
   1179e:	f8bd 3000 	ldrh.w	r3, [sp]
   117a2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   117a6:	fbb3 f1f2 	udiv	r1, r3, r2
   117aa:	fb02 f201 	mul.w	r2, r2, r1
   117ae:	1a9b      	subs	r3, r3, r2
   117b0:	b29b      	uxth	r3, r3
   117b2:	2b00      	cmp	r3, #0
   117b4:	d009      	beq.n	117ca <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x72>
    {
      multiplier_value = static_cast<uint32_t>(
          (desired_speed_in_mhz / static_cast<uint16_t>(input_frequency)) + 1);
   117b6:	f8bd 2000 	ldrh.w	r2, [sp]
   117ba:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   117be:	fbb2 f3f3 	udiv	r3, r2, r3
   117c2:	b29b      	uxth	r3, r3
   117c4:	3301      	adds	r3, #1
      multiplier_value = static_cast<uint32_t>(
   117c6:	9304      	str	r3, [sp, #16]
   117c8:	e007      	b.n	117da <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x82>
    }
    else
    {
      multiplier_value = static_cast<uint32_t>(
          desired_speed_in_mhz / static_cast<uint16_t>(input_frequency));
   117ca:	f8bd 2000 	ldrh.w	r2, [sp]
   117ce:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   117d2:	fbb2 f3f3 	udiv	r3, r2, r3
   117d6:	b29b      	uxth	r3, r3
      multiplier_value = static_cast<uint32_t>(
   117d8:	9304      	str	r3, [sp, #16]
    }
    uint16_t divider_value = 1;
   117da:	2301      	movs	r3, #1
   117dc:	f8ad 300e 	strh.w	r3, [sp, #14]
    while (calculating)
   117e0:	f89d 3017 	ldrb.w	r3, [sp, #23]
   117e4:	2b00      	cmp	r3, #0
   117e6:	d02e      	beq.n	11846 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xee>
    {
      uint16_t current_controlled_oscillator_frequency;
      current_controlled_oscillator_frequency = static_cast<uint16_t>(
   117e8:	9b04      	ldr	r3, [sp, #16]
   117ea:	b29b      	uxth	r3, r3
   117ec:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   117f0:	fb12 f303 	smulbb	r3, r2, r3
   117f4:	b29b      	uxth	r3, r3
   117f6:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   117fa:	fb12 f303 	smulbb	r3, r2, r3
   117fe:	b29b      	uxth	r3, r3
   11800:	005b      	lsls	r3, r3, #1
   11802:	f8ad 300c 	strh.w	r3, [sp, #12]
          (static_cast<uint16_t>(input_frequency) * multiplier_value * 2) *
          divider_value);
      if (current_controlled_oscillator_frequency >= 156)
   11806:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1180a:	2b9b      	cmp	r3, #155	; 0x9b
   1180c:	d903      	bls.n	11816 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xbe>
      {
        calculating = false;
   1180e:	2300      	movs	r3, #0
   11810:	f88d 3017 	strb.w	r3, [sp, #23]
   11814:	e7e4      	b.n	117e0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
      }
      else
      {
        divider_value = static_cast<uint16_t>(divider_value * 2);
   11816:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1181a:	005b      	lsls	r3, r3, #1
   1181c:	f8ad 300e 	strh.w	r3, [sp, #14]
        SJ2_ASSERT_FATAL(divider_value < 8,
   11820:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   11824:	2b07      	cmp	r3, #7
   11826:	d9db      	bls.n	117e0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
   11828:	f240 131b 	movw	r3, #283	; 0x11b
   1182c:	4a08      	ldr	r2, [pc, #32]	; (11850 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   1182e:	490c      	ldr	r1, [pc, #48]	; (11860 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x108>)
   11830:	480c      	ldr	r0, [pc, #48]	; (11864 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x10c>)
   11832:	f006 f8c5 	bl	179c0 <printf>
   11836:	4809      	ldr	r0, [pc, #36]	; (1185c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   11838:	f003 fcae 	bl	15198 <puts>
   1183c:	2100      	movs	r1, #0
   1183e:	2001      	movs	r0, #1
   11840:	f7ff f8c8 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   11844:	e7fe      	b.n	11844 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xec>
                         "PLL divider value went out of bounds");
      }
    }

    return multiplier_value;
   11846:	9b04      	ldr	r3, [sp, #16]
  }
   11848:	4618      	mov	r0, r3
   1184a:	b007      	add	sp, #28
   1184c:	f85d fb04 	ldr.w	pc, [sp], #4
   11850:	00019fe0 	.word	0x00019fe0
   11854:	00019c64 	.word	0x00019c64
   11858:	0001993c 	.word	0x0001993c
   1185c:	00019924 	.word	0x00019924
   11860:	00019c7c 	.word	0x00019c7c
   11864:	00019a2c 	.word	0x00019a2c

00011868 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t SetMainPll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   11868:	b510      	push	{r4, lr}
   1186a:	b08a      	sub	sp, #40	; 0x28
   1186c:	9001      	str	r0, [sp, #4]
   1186e:	460b      	mov	r3, r1
   11870:	f8ad 3002 	strh.w	r3, [sp, #2]
   11874:	4613      	mov	r3, r2
   11876:	f8ad 3000 	strh.w	r3, [sp]
  {
    uint16_t divider_value = 1;
   1187a:	2301      	movs	r3, #1
   1187c:	f8ad 301a 	strh.w	r3, [sp, #26]
    uint64_t timeout_time  = Milliseconds() + kDefaultTimeout;
   11880:	f7ff f940 	bl	10b04 <Milliseconds()>
   11884:	460a      	mov	r2, r1
   11886:	4601      	mov	r1, r0
   11888:	f511 737a 	adds.w	r3, r1, #1000	; 0x3e8
   1188c:	f142 0400 	adc.w	r4, r2, #0
   11890:	e9cd 3404 	strd	r3, r4, [sp, #16]
    uint64_t current_time  = Milliseconds();
   11894:	f7ff f936 	bl	10b04 <Milliseconds()>
   11898:	e9cd 0108 	strd	r0, r1, [sp, #32]
    uint32_t multiplier_value =
        CalculatePll(input_frequency, desired_speed_in_mhz);
   1189c:	f8bd 2000 	ldrh.w	r2, [sp]
   118a0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   118a4:	4619      	mov	r1, r3
   118a6:	9801      	ldr	r0, [sp, #4]
   118a8:	f7ff ff56 	bl	11758 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>
   118ac:	9003      	str	r0, [sp, #12]
    uint32_t actual_speed =
        static_cast<uint32_t>(input_frequency) * multiplier_value;
   118ae:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    uint32_t actual_speed =
   118b2:	9b03      	ldr	r3, [sp, #12]
   118b4:	fb02 f303 	mul.w	r3, r2, r3
   118b8:	9307      	str	r3, [sp, #28]
    // TO DO: use registers to retreive values
    SelectOscillatorSource(OscillatorSource::kIrc);
   118ba:	2100      	movs	r1, #0
   118bc:	9801      	ldr	r0, [sp, #4]
   118be:	f7ff fee9 	bl	11694 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    SelectMainClockSource(MainClockSource::kBaseClock);
   118c2:	2100      	movs	r1, #0
   118c4:	9801      	ldr	r0, [sp, #4]
   118c6:	f7ff feff 	bl	116c8 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
    SelectUsbClockSource(UsbSource::kBaseClock);
   118ca:	2100      	movs	r1, #0
   118cc:	9801      	ldr	r0, [sp, #4]
   118ce:	f7ff ff13 	bl	116f8 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>
    SelectSpifiClockSource(SpifiSource::kBaseClock);
   118d2:	2100      	movs	r1, #0
   118d4:	9801      	ldr	r0, [sp, #4]
   118d6:	f7ff ff27 	bl	11728 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>
    // must subtract 1 from multiplier value as specified in datasheet
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   118da:	4b3a      	ldr	r3, [pc, #232]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   118dc:	681b      	ldr	r3, [r3, #0]
   118de:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   118e2:	f023 011f 	bic.w	r1, r3, #31
        (multiplier_value - 1);
   118e6:	9b03      	ldr	r3, [sp, #12]
   118e8:	1e5a      	subs	r2, r3, #1
    system_controller->PLL0CFG =
   118ea:	4b36      	ldr	r3, [pc, #216]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   118ec:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   118ee:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   118f0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   118f4:	4b33      	ldr	r3, [pc, #204]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   118f6:	681b      	ldr	r3, [r3, #0]
   118f8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   118fc:	f023 0260 	bic.w	r2, r3, #96	; 0x60
   11900:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   11904:	015b      	lsls	r3, r3, #5
   11906:	4619      	mov	r1, r3
    system_controller->PLL0CFG =
   11908:	4b2e      	ldr	r3, [pc, #184]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1190a:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   1190c:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   1190e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CON |= kEnablePll;
   11912:	4b2c      	ldr	r3, [pc, #176]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11914:	681b      	ldr	r3, [r3, #0]
   11916:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   1191a:	4b2a      	ldr	r3, [pc, #168]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1191c:	681b      	ldr	r3, [r3, #0]
   1191e:	f042 0201 	orr.w	r2, r2, #1
   11922:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // nessecary feed sequence to ensure the changes are intentional
    system_controller->PLL0FEED = 0xAA;
   11926:	4b27      	ldr	r3, [pc, #156]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11928:	681b      	ldr	r3, [r3, #0]
   1192a:	22aa      	movs	r2, #170	; 0xaa
   1192c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    system_controller->PLL0FEED = 0x55;
   11930:	4b24      	ldr	r3, [pc, #144]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11932:	681b      	ldr	r3, [r3, #0]
   11934:	2255      	movs	r2, #85	; 0x55
   11936:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   1193a:	4b22      	ldr	r3, [pc, #136]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1193c:	681b      	ldr	r3, [r3, #0]
   1193e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11942:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   11946:	2b00      	cmp	r3, #0
   11948:	d109      	bne.n	1195e <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   1194a:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   1194e:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   11952:	42a2      	cmp	r2, r4
   11954:	bf08      	it	eq
   11956:	4299      	cmpeq	r1, r3
   11958:	d201      	bcs.n	1195e <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   1195a:	2301      	movs	r3, #1
   1195c:	e000      	b.n	11960 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>
   1195e:	2300      	movs	r3, #0
   11960:	2b00      	cmp	r3, #0
   11962:	d004      	beq.n	1196e <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x106>
           (current_time < timeout_time))
    {
      current_time = Milliseconds();
   11964:	f7ff f8ce 	bl	10b04 <Milliseconds()>
   11968:	e9cd 0108 	strd	r0, r1, [sp, #32]
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   1196c:	e7e5      	b.n	1193a <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xd2>
    }
    if (!(system_controller->PLL0STAT >> kPlock & 1) &&
   1196e:	4b15      	ldr	r3, [pc, #84]	; (119c4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11970:	681b      	ldr	r3, [r3, #0]
   11972:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11976:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1197a:	2b00      	cmp	r3, #0
   1197c:	d109      	bne.n	11992 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   1197e:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   11982:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   11986:	42a2      	cmp	r2, r4
   11988:	bf08      	it	eq
   1198a:	4299      	cmpeq	r1, r3
   1198c:	d301      	bcc.n	11992 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   1198e:	2301      	movs	r3, #1
   11990:	e000      	b.n	11994 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12c>
   11992:	2300      	movs	r3, #0
   11994:	2b00      	cmp	r3, #0
   11996:	d00e      	beq.n	119b6 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14e>
        (current_time >= timeout_time))
    {
      SJ2_ASSERT_FATAL(false,
   11998:	f240 1343 	movw	r3, #323	; 0x143
   1199c:	4a0a      	ldr	r2, [pc, #40]	; (119c8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x160>)
   1199e:	490b      	ldr	r1, [pc, #44]	; (119cc <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x164>)
   119a0:	480b      	ldr	r0, [pc, #44]	; (119d0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x168>)
   119a2:	f006 f80d 	bl	179c0 <printf>
   119a6:	480b      	ldr	r0, [pc, #44]	; (119d4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x16c>)
   119a8:	f003 fbf6 	bl	15198 <puts>
   119ac:	2100      	movs	r1, #0
   119ae:	2001      	movs	r0, #1
   119b0:	f7ff f810 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   119b4:	e7fe      	b.n	119b4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14c>
                       "PLL lock could not be established before timeout");
      actual_speed = kDefaultIRCFrequency;
    }
    return (actual_speed - desired_speed_in_mhz);
   119b6:	f8bd 3000 	ldrh.w	r3, [sp]
   119ba:	9a07      	ldr	r2, [sp, #28]
   119bc:	1ad3      	subs	r3, r2, r3
  }
   119be:	4618      	mov	r0, r3
   119c0:	b00a      	add	sp, #40	; 0x28
   119c2:	bd10      	pop	{r4, pc}
   119c4:	10000048 	.word	0x10000048
   119c8:	00019f84 	.word	0x00019f84
   119cc:	00019c94 	.word	0x00019c94
   119d0:	00019ad4 	.word	0x00019ad4
   119d4:	00019924 	.word	0x00019924

000119d8 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>:
                       "PLL lock could not be established before timeout");
    }
    return (actual_speed - desired_speed_in_mhz);
  }

  void SetCpuClockDivider(uint8_t cpu_divider)
   119d8:	b500      	push	{lr}
   119da:	b083      	sub	sp, #12
   119dc:	9001      	str	r0, [sp, #4]
   119de:	460b      	mov	r3, r1
   119e0:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(cpu_divider < 32, "Divider mustn't exceed 32");
   119e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   119e8:	2b1f      	cmp	r3, #31
   119ea:	d90e      	bls.n	11a0a <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x32>
   119ec:	f240 136f 	movw	r3, #367	; 0x16f
   119f0:	4a0e      	ldr	r2, [pc, #56]	; (11a2c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x54>)
   119f2:	490f      	ldr	r1, [pc, #60]	; (11a30 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x58>)
   119f4:	480f      	ldr	r0, [pc, #60]	; (11a34 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x5c>)
   119f6:	f005 ffe3 	bl	179c0 <printf>
   119fa:	480f      	ldr	r0, [pc, #60]	; (11a38 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x60>)
   119fc:	f003 fbcc 	bl	15198 <puts>
   11a00:	2100      	movs	r1, #0
   11a02:	2001      	movs	r0, #1
   11a04:	f7fe ffe6 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   11a08:	e7fe      	b.n	11a08 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x30>
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11a0a:	4b0c      	ldr	r3, [pc, #48]	; (11a3c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11a0c:	681b      	ldr	r3, [r3, #0]
   11a0e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   11a12:	f023 011f 	bic.w	r1, r3, #31
   11a16:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->CCLKSEL =
   11a1a:	4b08      	ldr	r3, [pc, #32]	; (11a3c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11a1c:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11a1e:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11a20:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   11a24:	bf00      	nop
   11a26:	b003      	add	sp, #12
   11a28:	f85d fb04 	ldr.w	pc, [sp], #4
   11a2c:	0001a03c 	.word	0x0001a03c
   11a30:	00019cac 	.word	0x00019cac
   11a34:	00019b7c 	.word	0x00019b7c
   11a38:	00019924 	.word	0x00019924
   11a3c:	10000048 	.word	0x10000048

00011a40 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>:

  void SetEmcClockDivider(EmcDivider emc_divider)
   11a40:	b082      	sub	sp, #8
   11a42:	9001      	str	r0, [sp, #4]
   11a44:	460b      	mov	r3, r1
   11a46:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    system_controller->EMCCLKSEL =
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11a4a:	4b08      	ldr	r3, [pc, #32]	; (11a6c <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   11a4c:	681b      	ldr	r3, [r3, #0]
   11a4e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   11a52:	f023 0101 	bic.w	r1, r3, #1
        static_cast<uint8_t>(emc_divider);
   11a56:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->EMCCLKSEL =
   11a5a:	4b04      	ldr	r3, [pc, #16]	; (11a6c <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   11a5c:	681b      	ldr	r3, [r3, #0]
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   11a5e:	430a      	orrs	r2, r1
    system_controller->EMCCLKSEL =
   11a60:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
   11a64:	bf00      	nop
   11a66:	b002      	add	sp, #8
   11a68:	4770      	bx	lr
   11a6a:	bf00      	nop
   11a6c:	10000048 	.word	0x10000048

00011a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>:
constexpr Type Value(Enum enum_type_value)
   11a70:	b530      	push	{r4, r5, lr}
   11a72:	b083      	sub	sp, #12
   11a74:	4675      	mov	r5, lr
   11a76:	9001      	str	r0, [sp, #4]
   11a78:	462b      	mov	r3, r5
   11a7a:	4619      	mov	r1, r3
   11a7c:	4806      	ldr	r0, [pc, #24]	; (11a98 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   11a7e:	f003 fbbb 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11a82:	9c01      	ldr	r4, [sp, #4]
   11a84:	462b      	mov	r3, r5
   11a86:	4619      	mov	r1, r3
   11a88:	4803      	ldr	r0, [pc, #12]	; (11a98 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   11a8a:	f003 fbc9 	bl	15220 <__cyg_profile_func_exit>
   11a8e:	4623      	mov	r3, r4
}
   11a90:	4618      	mov	r0, r3
   11a92:	b003      	add	sp, #12
   11a94:	bd30      	pop	{r4, r5, pc}
   11a96:	bf00      	nop
   11a98:	00011a71 	.word	0x00011a71

00011a9c <SspInterface::SspInterface()>:
#include "L0_LowLevel/system_controller.hpp"
#include "L1_Drivers/pin.hpp"
#include "utility/bit.hpp"
#include "utility/enum.hpp"

class SspInterface
   11a9c:	b530      	push	{r4, r5, lr}
   11a9e:	b083      	sub	sp, #12
   11aa0:	4675      	mov	r5, lr
   11aa2:	9001      	str	r0, [sp, #4]
   11aa4:	462b      	mov	r3, r5
   11aa6:	4619      	mov	r1, r3
   11aa8:	4807      	ldr	r0, [pc, #28]	; (11ac8 <SspInterface::SspInterface()+0x2c>)
   11aaa:	f003 fba5 	bl	151f8 <__cyg_profile_func_enter>
   11aae:	4a07      	ldr	r2, [pc, #28]	; (11acc <SspInterface::SspInterface()+0x30>)
   11ab0:	9b01      	ldr	r3, [sp, #4]
   11ab2:	601a      	str	r2, [r3, #0]
   11ab4:	9c01      	ldr	r4, [sp, #4]
   11ab6:	462b      	mov	r3, r5
   11ab8:	4619      	mov	r1, r3
   11aba:	4803      	ldr	r0, [pc, #12]	; (11ac8 <SspInterface::SspInterface()+0x2c>)
   11abc:	f003 fbb0 	bl	15220 <__cyg_profile_func_exit>
   11ac0:	4623      	mov	r3, r4
   11ac2:	4618      	mov	r0, r3
   11ac4:	b003      	add	sp, #12
   11ac6:	bd30      	pop	{r4, r5, pc}
   11ac8:	00011a9d 	.word	0x00011a9d
   11acc:	00019dc8 	.word	0x00019dc8

00011ad0 <PinInterface::PinInterface(PinInterface const&)>:
class PinInterface
   11ad0:	b530      	push	{r4, r5, lr}
   11ad2:	b083      	sub	sp, #12
   11ad4:	4675      	mov	r5, lr
   11ad6:	9001      	str	r0, [sp, #4]
   11ad8:	9100      	str	r1, [sp, #0]
   11ada:	462b      	mov	r3, r5
   11adc:	4619      	mov	r1, r3
   11ade:	4808      	ldr	r0, [pc, #32]	; (11b00 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   11ae0:	f003 fb8a 	bl	151f8 <__cyg_profile_func_enter>
   11ae4:	4a07      	ldr	r2, [pc, #28]	; (11b04 <PinInterface::PinInterface(PinInterface const&)+0x34>)
   11ae6:	9b01      	ldr	r3, [sp, #4]
   11ae8:	601a      	str	r2, [r3, #0]
   11aea:	9c01      	ldr	r4, [sp, #4]
   11aec:	462b      	mov	r3, r5
   11aee:	4619      	mov	r1, r3
   11af0:	4803      	ldr	r0, [pc, #12]	; (11b00 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   11af2:	f003 fb95 	bl	15220 <__cyg_profile_func_exit>
   11af6:	4623      	mov	r3, r4
   11af8:	4618      	mov	r0, r3
   11afa:	b003      	add	sp, #12
   11afc:	bd30      	pop	{r4, r5, pc}
   11afe:	bf00      	nop
   11b00:	00011ad1 	.word	0x00011ad1
   11b04:	00019f04 	.word	0x00019f04

00011b08 <Pin::Pin(Pin const&)>:
class Pin : public PinInterface
   11b08:	b530      	push	{r4, r5, lr}
   11b0a:	b083      	sub	sp, #12
   11b0c:	4675      	mov	r5, lr
   11b0e:	9001      	str	r0, [sp, #4]
   11b10:	9100      	str	r1, [sp, #0]
   11b12:	462b      	mov	r3, r5
   11b14:	4619      	mov	r1, r3
   11b16:	480f      	ldr	r0, [pc, #60]	; (11b54 <Pin::Pin(Pin const&)+0x4c>)
   11b18:	f003 fb6e 	bl	151f8 <__cyg_profile_func_enter>
   11b1c:	9b01      	ldr	r3, [sp, #4]
   11b1e:	9a00      	ldr	r2, [sp, #0]
   11b20:	4611      	mov	r1, r2
   11b22:	4618      	mov	r0, r3
   11b24:	f7ff ffd4 	bl	11ad0 <PinInterface::PinInterface(PinInterface const&)>
   11b28:	4a0b      	ldr	r2, [pc, #44]	; (11b58 <Pin::Pin(Pin const&)+0x50>)
   11b2a:	9b01      	ldr	r3, [sp, #4]
   11b2c:	601a      	str	r2, [r3, #0]
   11b2e:	9b00      	ldr	r3, [sp, #0]
   11b30:	791a      	ldrb	r2, [r3, #4]
   11b32:	9b01      	ldr	r3, [sp, #4]
   11b34:	711a      	strb	r2, [r3, #4]
   11b36:	9b00      	ldr	r3, [sp, #0]
   11b38:	795a      	ldrb	r2, [r3, #5]
   11b3a:	9b01      	ldr	r3, [sp, #4]
   11b3c:	715a      	strb	r2, [r3, #5]
   11b3e:	9c01      	ldr	r4, [sp, #4]
   11b40:	462b      	mov	r3, r5
   11b42:	4619      	mov	r1, r3
   11b44:	4803      	ldr	r0, [pc, #12]	; (11b54 <Pin::Pin(Pin const&)+0x4c>)
   11b46:	f003 fb6b 	bl	15220 <__cyg_profile_func_exit>
   11b4a:	4623      	mov	r3, r4
   11b4c:	4618      	mov	r0, r3
   11b4e:	b003      	add	sp, #12
   11b50:	bd30      	pop	{r4, r5, pc}
   11b52:	bf00      	nop
   11b54:	00011b09 	.word	0x00011b09
   11b58:	00019ec8 	.word	0x00019ec8

00011b5c <Ssp::Ssp(Ssp::Peripheral)>:
        pssp_(Peripheral::kSsp0)
  {
  }

  /// User modified constructor. Must be followed by Set functions.
  explicit constexpr Ssp(Peripheral set_pssp)
   11b5c:	b530      	push	{r4, r5, lr}
   11b5e:	b083      	sub	sp, #12
   11b60:	4675      	mov	r5, lr
   11b62:	9001      	str	r0, [sp, #4]
   11b64:	9100      	str	r1, [sp, #0]
   11b66:	462b      	mov	r3, r5
   11b68:	4619      	mov	r1, r3
   11b6a:	4831      	ldr	r0, [pc, #196]	; (11c30 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   11b6c:	f003 fb44 	bl	151f8 <__cyg_profile_func_enter>
        miso_(&miso_pin_),
        sck_(&sck_pin_),
        mosi_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMosi]),
        miso_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMiso]),
        sck_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kSck]),
        pssp_(set_pssp)
   11b70:	9b01      	ldr	r3, [sp, #4]
   11b72:	4618      	mov	r0, r3
   11b74:	f7ff ff92 	bl	11a9c <SspInterface::SspInterface()>
   11b78:	9b01      	ldr	r3, [sp, #4]
   11b7a:	3304      	adds	r3, #4
   11b7c:	4618      	mov	r0, r3
   11b7e:	f7ff fc9d 	bl	114bc <Lpc40xxSystemController::Lpc40xxSystemController()>
   11b82:	4a2c      	ldr	r2, [pc, #176]	; (11c34 <Ssp::Ssp(Ssp::Peripheral)+0xd8>)
   11b84:	9b01      	ldr	r3, [sp, #4]
   11b86:	601a      	str	r2, [r3, #0]
   11b88:	4a2b      	ldr	r2, [pc, #172]	; (11c38 <Ssp::Ssp(Ssp::Peripheral)+0xdc>)
   11b8a:	9b01      	ldr	r3, [sp, #4]
   11b8c:	605a      	str	r2, [r3, #4]
   11b8e:	9b01      	ldr	r3, [sp, #4]
   11b90:	f103 0214 	add.w	r2, r3, #20
   11b94:	9b01      	ldr	r3, [sp, #4]
   11b96:	609a      	str	r2, [r3, #8]
   11b98:	9b01      	ldr	r3, [sp, #4]
   11b9a:	f103 021c 	add.w	r2, r3, #28
   11b9e:	9b01      	ldr	r3, [sp, #4]
   11ba0:	60da      	str	r2, [r3, #12]
   11ba2:	9b01      	ldr	r3, [sp, #4]
   11ba4:	f103 0224 	add.w	r2, r3, #36	; 0x24
   11ba8:	9b01      	ldr	r3, [sp, #4]
   11baa:	611a      	str	r2, [r3, #16]
   11bac:	9b01      	ldr	r3, [sp, #4]
   11bae:	f103 0414 	add.w	r4, r3, #20
        mosi_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMosi]),
   11bb2:	9800      	ldr	r0, [sp, #0]
   11bb4:	f7ff ff5c 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11bb8:	4602      	mov	r2, r0
        pssp_(set_pssp)
   11bba:	4613      	mov	r3, r2
   11bbc:	005b      	lsls	r3, r3, #1
   11bbe:	4413      	add	r3, r2
   11bc0:	00db      	lsls	r3, r3, #3
   11bc2:	4a1e      	ldr	r2, [pc, #120]	; (11c3c <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   11bc4:	4413      	add	r3, r2
   11bc6:	4619      	mov	r1, r3
   11bc8:	4620      	mov	r0, r4
   11bca:	f7ff ff9d 	bl	11b08 <Pin::Pin(Pin const&)>
   11bce:	9b01      	ldr	r3, [sp, #4]
   11bd0:	f103 041c 	add.w	r4, r3, #28
        miso_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMiso]),
   11bd4:	9800      	ldr	r0, [sp, #0]
   11bd6:	f7ff ff4b 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11bda:	4602      	mov	r2, r0
        pssp_(set_pssp)
   11bdc:	4613      	mov	r3, r2
   11bde:	005b      	lsls	r3, r3, #1
   11be0:	4413      	add	r3, r2
   11be2:	00db      	lsls	r3, r3, #3
   11be4:	3308      	adds	r3, #8
   11be6:	4a15      	ldr	r2, [pc, #84]	; (11c3c <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   11be8:	4413      	add	r3, r2
   11bea:	4619      	mov	r1, r3
   11bec:	4620      	mov	r0, r4
   11bee:	f7ff ff8b 	bl	11b08 <Pin::Pin(Pin const&)>
   11bf2:	9b01      	ldr	r3, [sp, #4]
   11bf4:	f103 0424 	add.w	r4, r3, #36	; 0x24
        sck_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kSck]),
   11bf8:	9800      	ldr	r0, [sp, #0]
   11bfa:	f7ff ff39 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11bfe:	4602      	mov	r2, r0
        pssp_(set_pssp)
   11c00:	4613      	mov	r3, r2
   11c02:	005b      	lsls	r3, r3, #1
   11c04:	4413      	add	r3, r2
   11c06:	00db      	lsls	r3, r3, #3
   11c08:	3310      	adds	r3, #16
   11c0a:	4a0c      	ldr	r2, [pc, #48]	; (11c3c <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   11c0c:	4413      	add	r3, r2
   11c0e:	4619      	mov	r1, r3
   11c10:	4620      	mov	r0, r4
   11c12:	f7ff ff79 	bl	11b08 <Pin::Pin(Pin const&)>
   11c16:	9b01      	ldr	r3, [sp, #4]
   11c18:	9a00      	ldr	r2, [sp, #0]
   11c1a:	62da      	str	r2, [r3, #44]	; 0x2c
  {
  }
   11c1c:	9c01      	ldr	r4, [sp, #4]
   11c1e:	462b      	mov	r3, r5
   11c20:	4619      	mov	r1, r3
   11c22:	4803      	ldr	r0, [pc, #12]	; (11c30 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   11c24:	f003 fafc 	bl	15220 <__cyg_profile_func_exit>
   11c28:	4623      	mov	r3, r4
   11c2a:	4618      	mov	r0, r3
   11c2c:	b003      	add	sp, #12
   11c2e:	bd30      	pop	{r4, r5, pc}
   11c30:	00011b5d 	.word	0x00011b5d
   11c34:	00019d7c 	.word	0x00019d7c
   11c38:	00019da4 	.word	0x00019da4
   11c3c:	00019cc8 	.word	0x00019cc8

00011c40 <Ssp::Initialize()>:
  }

  /// Powers on the peripheral, sets the peripheral clock, format, and data
  /// size, and enables the SSP pins for communication see and more.
  /// See page 601 of user manual UM10562 LPC408x/407x for more details.
  void Initialize() override
   11c40:	b570      	push	{r4, r5, r6, lr}
   11c42:	b086      	sub	sp, #24
   11c44:	4676      	mov	r6, lr
   11c46:	9001      	str	r0, [sp, #4]
   11c48:	4633      	mov	r3, r6
   11c4a:	4619      	mov	r1, r3
   11c4c:	4830      	ldr	r0, [pc, #192]	; (11d10 <Ssp::Initialize()+0xd0>)
   11c4e:	f003 fad3 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint32_t pssp = util::Value(pssp_);
   11c52:	9b01      	ldr	r3, [sp, #4]
   11c54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11c56:	4618      	mov	r0, r3
   11c58:	f7ff ff0a 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11c5c:	4603      	mov	r3, r0
   11c5e:	9305      	str	r3, [sp, #20]
    // Power up peripheral
    PowerUpPeripheral(kPowerBit[pssp]);
   11c60:	9b01      	ldr	r3, [sp, #4]
   11c62:	1d18      	adds	r0, r3, #4
   11c64:	9b01      	ldr	r3, [sp, #4]
   11c66:	685b      	ldr	r3, [r3, #4]
   11c68:	3314      	adds	r3, #20
   11c6a:	681b      	ldr	r3, [r3, #0]
   11c6c:	9a05      	ldr	r2, [sp, #20]
   11c6e:	0092      	lsls	r2, r2, #2
   11c70:	4928      	ldr	r1, [pc, #160]	; (11d14 <Ssp::Initialize()+0xd4>)
   11c72:	440a      	add	r2, r1
   11c74:	4611      	mov	r1, r2
   11c76:	4798      	blx	r3
    // Enable SSP pins
    mosi_->SetPinFunction(kPinSelect[pssp]);
   11c78:	9b01      	ldr	r3, [sp, #4]
   11c7a:	6898      	ldr	r0, [r3, #8]
   11c7c:	9b01      	ldr	r3, [sp, #4]
   11c7e:	689b      	ldr	r3, [r3, #8]
   11c80:	681b      	ldr	r3, [r3, #0]
   11c82:	681b      	ldr	r3, [r3, #0]
   11c84:	4924      	ldr	r1, [pc, #144]	; (11d18 <Ssp::Initialize()+0xd8>)
   11c86:	9a05      	ldr	r2, [sp, #20]
   11c88:	440a      	add	r2, r1
   11c8a:	7812      	ldrb	r2, [r2, #0]
   11c8c:	4611      	mov	r1, r2
   11c8e:	4798      	blx	r3
    miso_->SetPinFunction(kPinSelect[pssp]);
   11c90:	9b01      	ldr	r3, [sp, #4]
   11c92:	68d8      	ldr	r0, [r3, #12]
   11c94:	9b01      	ldr	r3, [sp, #4]
   11c96:	68db      	ldr	r3, [r3, #12]
   11c98:	681b      	ldr	r3, [r3, #0]
   11c9a:	681b      	ldr	r3, [r3, #0]
   11c9c:	491e      	ldr	r1, [pc, #120]	; (11d18 <Ssp::Initialize()+0xd8>)
   11c9e:	9a05      	ldr	r2, [sp, #20]
   11ca0:	440a      	add	r2, r1
   11ca2:	7812      	ldrb	r2, [r2, #0]
   11ca4:	4611      	mov	r1, r2
   11ca6:	4798      	blx	r3
    sck_->SetPinFunction(kPinSelect[pssp]);
   11ca8:	9b01      	ldr	r3, [sp, #4]
   11caa:	6918      	ldr	r0, [r3, #16]
   11cac:	9b01      	ldr	r3, [sp, #4]
   11cae:	691b      	ldr	r3, [r3, #16]
   11cb0:	681b      	ldr	r3, [r3, #0]
   11cb2:	681b      	ldr	r3, [r3, #0]
   11cb4:	4918      	ldr	r1, [pc, #96]	; (11d18 <Ssp::Initialize()+0xd8>)
   11cb6:	9a05      	ldr	r2, [sp, #20]
   11cb8:	440a      	add	r2, r1
   11cba:	7812      	ldrb	r2, [r2, #0]
   11cbc:	4611      	mov	r1, r2
   11cbe:	4798      	blx	r3
    // Enable SSP
    ssp_registers[pssp]->CR1 = bit::Set(ssp_registers[pssp]->CR1, kSspEnable);
   11cc0:	4a16      	ldr	r2, [pc, #88]	; (11d1c <Ssp::Initialize()+0xdc>)
   11cc2:	9b05      	ldr	r3, [sp, #20]
   11cc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11cc8:	685b      	ldr	r3, [r3, #4]
   11cca:	4914      	ldr	r1, [pc, #80]	; (11d1c <Ssp::Initialize()+0xdc>)
   11ccc:	9a05      	ldr	r2, [sp, #20]
   11cce:	f851 4022 	ldr.w	r4, [r1, r2, lsl #2]
   11cd2:	9304      	str	r3, [sp, #16]
   11cd4:	2301      	movs	r3, #1
   11cd6:	9303      	str	r3, [sp, #12]
   11cd8:	4633      	mov	r3, r6
   11cda:	4619      	mov	r1, r3
   11cdc:	4810      	ldr	r0, [pc, #64]	; (11d20 <Ssp::Initialize()+0xe0>)
   11cde:	f003 fa8b 	bl	151f8 <__cyg_profile_func_enter>
[[gnu::always_inline]] [[nodiscard]]
constexpr T Set(T target, uint32_t position)
{
  static_assert(std::numeric_limits<T>::is_integer,
                "Set only accepts intergers.");
  return target | (1 << position);
   11ce2:	2201      	movs	r2, #1
   11ce4:	9b03      	ldr	r3, [sp, #12]
   11ce6:	fa02 f303 	lsl.w	r3, r2, r3
   11cea:	461a      	mov	r2, r3
   11cec:	9b04      	ldr	r3, [sp, #16]
   11cee:	ea42 0503 	orr.w	r5, r2, r3
   11cf2:	4633      	mov	r3, r6
   11cf4:	4619      	mov	r1, r3
   11cf6:	480a      	ldr	r0, [pc, #40]	; (11d20 <Ssp::Initialize()+0xe0>)
   11cf8:	f003 fa92 	bl	15220 <__cyg_profile_func_exit>
   11cfc:	6065      	str	r5, [r4, #4]
   11cfe:	4633      	mov	r3, r6
   11d00:	4619      	mov	r1, r3
   11d02:	4803      	ldr	r0, [pc, #12]	; (11d10 <Ssp::Initialize()+0xd0>)
   11d04:	f003 fa8c 	bl	15220 <__cyg_profile_func_exit>
  }
   11d08:	bf00      	nop
   11d0a:	b006      	add	sp, #24
   11d0c:	bd70      	pop	{r4, r5, r6, pc}
   11d0e:	bf00      	nop
   11d10:	00011c41 	.word	0x00011c41
   11d14:	00019d10 	.word	0x00019d10
   11d18:	00019cc4 	.word	0x00019cc4
   11d1c:	10000050 	.word	0x10000050
   11d20:	00012d5d 	.word	0x00012d5d

00011d24 <Ssp::IsTransferRegBusy()>:

  /// Checks if the SSP controller is idle.
  /// @returns true if the controller is sending or receiving a data frame and
  /// false if it is idle.
  bool IsTransferRegBusy() override
   11d24:	b530      	push	{r4, r5, lr}
   11d26:	b085      	sub	sp, #20
   11d28:	4675      	mov	r5, lr
   11d2a:	9001      	str	r0, [sp, #4]
   11d2c:	462b      	mov	r3, r5
   11d2e:	4619      	mov	r1, r3
   11d30:	4817      	ldr	r0, [pc, #92]	; (11d90 <Ssp::IsTransferRegBusy()+0x6c>)
   11d32:	f003 fa61 	bl	151f8 <__cyg_profile_func_enter>
  {
    return (bit::Read(ssp_registers[util::Value(pssp_)]->SR, kDataLineIdleBit));
   11d36:	9b01      	ldr	r3, [sp, #4]
   11d38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11d3a:	4618      	mov	r0, r3
   11d3c:	f7ff fe98 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11d40:	4602      	mov	r2, r0
   11d42:	4b14      	ldr	r3, [pc, #80]	; (11d94 <Ssp::IsTransferRegBusy()+0x70>)
   11d44:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11d48:	68db      	ldr	r3, [r3, #12]
   11d4a:	9303      	str	r3, [sp, #12]
   11d4c:	2304      	movs	r3, #4
   11d4e:	9302      	str	r3, [sp, #8]
   11d50:	462b      	mov	r3, r5
   11d52:	4619      	mov	r1, r3
   11d54:	4810      	ldr	r0, [pc, #64]	; (11d98 <Ssp::IsTransferRegBusy()+0x74>)
   11d56:	f003 fa4f 	bl	151f8 <__cyg_profile_func_enter>
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
                                                        uint32_t position)
{
  static_assert(std::numeric_limits<T>::is_integer,
                "Read only accepts intergers.");
  return static_cast<bool>(target & (1 << position));
   11d5a:	2201      	movs	r2, #1
   11d5c:	9b02      	ldr	r3, [sp, #8]
   11d5e:	fa02 f303 	lsl.w	r3, r2, r3
   11d62:	461a      	mov	r2, r3
   11d64:	9b03      	ldr	r3, [sp, #12]
   11d66:	4013      	ands	r3, r2
   11d68:	2b00      	cmp	r3, #0
   11d6a:	bf14      	ite	ne
   11d6c:	2301      	movne	r3, #1
   11d6e:	2300      	moveq	r3, #0
   11d70:	b2dc      	uxtb	r4, r3
   11d72:	462b      	mov	r3, r5
   11d74:	4619      	mov	r1, r3
   11d76:	4808      	ldr	r0, [pc, #32]	; (11d98 <Ssp::IsTransferRegBusy()+0x74>)
   11d78:	f003 fa52 	bl	15220 <__cyg_profile_func_exit>
   11d7c:	462b      	mov	r3, r5
   11d7e:	4619      	mov	r1, r3
   11d80:	4803      	ldr	r0, [pc, #12]	; (11d90 <Ssp::IsTransferRegBusy()+0x6c>)
   11d82:	f003 fa4d 	bl	15220 <__cyg_profile_func_exit>
   11d86:	4623      	mov	r3, r4
  }
   11d88:	4618      	mov	r0, r3
   11d8a:	b005      	add	sp, #20
   11d8c:	bd30      	pop	{r4, r5, pc}
   11d8e:	bf00      	nop
   11d90:	00011d25 	.word	0x00011d25
   11d94:	10000050 	.word	0x10000050
   11d98:	00012d99 	.word	0x00012d99

00011d9c <Ssp::Transfer(unsigned short)>:
  /// data register. This functions for both transmitting and
  /// receiving data. It is recommended this region be protected
  /// by a mutex.
  /// @param data - information to be placed in data register
  /// @return - received data from external device
  uint16_t Transfer(uint16_t data) override
   11d9c:	b530      	push	{r4, r5, lr}
   11d9e:	b085      	sub	sp, #20
   11da0:	4675      	mov	r5, lr
   11da2:	9001      	str	r0, [sp, #4]
   11da4:	460b      	mov	r3, r1
   11da6:	f8ad 3002 	strh.w	r3, [sp, #2]
   11daa:	462b      	mov	r3, r5
   11dac:	4619      	mov	r1, r3
   11dae:	4814      	ldr	r0, [pc, #80]	; (11e00 <Ssp::Transfer(unsigned short)+0x64>)
   11db0:	f003 fa22 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint32_t pssp = util::Value(pssp_);
   11db4:	9b01      	ldr	r3, [sp, #4]
   11db6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11db8:	4618      	mov	r0, r3
   11dba:	f7ff fe59 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11dbe:	4603      	mov	r3, r0
   11dc0:	9303      	str	r3, [sp, #12]

    ssp_registers[pssp]->DR = data;
   11dc2:	4a10      	ldr	r2, [pc, #64]	; (11e04 <Ssp::Transfer(unsigned short)+0x68>)
   11dc4:	9b03      	ldr	r3, [sp, #12]
   11dc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11dca:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11dce:	609a      	str	r2, [r3, #8]
    while (IsTransferRegBusy())
   11dd0:	9801      	ldr	r0, [sp, #4]
   11dd2:	f7ff ffa7 	bl	11d24 <Ssp::IsTransferRegBusy()>
   11dd6:	4603      	mov	r3, r0
   11dd8:	2b00      	cmp	r3, #0
   11dda:	d001      	beq.n	11de0 <Ssp::Transfer(unsigned short)+0x44>
    {
      continue;
   11ddc:	bf00      	nop
    while (IsTransferRegBusy())
   11dde:	e7f7      	b.n	11dd0 <Ssp::Transfer(unsigned short)+0x34>
    }
    return static_cast<uint16_t>(ssp_registers[pssp]->DR);
   11de0:	4a08      	ldr	r2, [pc, #32]	; (11e04 <Ssp::Transfer(unsigned short)+0x68>)
   11de2:	9b03      	ldr	r3, [sp, #12]
   11de4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11de8:	689b      	ldr	r3, [r3, #8]
   11dea:	b29c      	uxth	r4, r3
   11dec:	462b      	mov	r3, r5
   11dee:	4619      	mov	r1, r3
   11df0:	4803      	ldr	r0, [pc, #12]	; (11e00 <Ssp::Transfer(unsigned short)+0x64>)
   11df2:	f003 fa15 	bl	15220 <__cyg_profile_func_exit>
   11df6:	4623      	mov	r3, r4
  }
   11df8:	4618      	mov	r0, r3
   11dfa:	b005      	add	sp, #20
   11dfc:	bd30      	pop	{r4, r5, pc}
   11dfe:	bf00      	nop
   11e00:	00011d9d 	.word	0x00011d9d
   11e04:	10000050 	.word	0x10000050

00011e08 <Ssp::SetSpiMasterDefault()>:

  /// Sets up SSP peripheral as SPI master
  void SetSpiMasterDefault() override
   11e08:	b510      	push	{r4, lr}
   11e0a:	b086      	sub	sp, #24
   11e0c:	4674      	mov	r4, lr
   11e0e:	9003      	str	r0, [sp, #12]
   11e10:	4623      	mov	r3, r4
   11e12:	4619      	mov	r1, r3
   11e14:	4812      	ldr	r0, [pc, #72]	; (11e60 <Ssp::SetSpiMasterDefault()+0x58>)
   11e16:	f003 f9ef 	bl	151f8 <__cyg_profile_func_enter>
  {
    constexpr bool kHighPolarity  = 1;
   11e1a:	2301      	movs	r3, #1
   11e1c:	f88d 3017 	strb.w	r3, [sp, #23]
    constexpr bool kPhase0        = 0;
   11e20:	2300      	movs	r3, #0
   11e22:	f88d 3016 	strb.w	r3, [sp, #22]
    constexpr uint8_t kScrDivider = 0;
   11e26:	2300      	movs	r3, #0
   11e28:	f88d 3015 	strb.w	r3, [sp, #21]
    constexpr uint8_t kPrescaler  = SJ2_SYSTEM_CLOCK_RATE_MHZ;
   11e2c:	2330      	movs	r3, #48	; 0x30
   11e2e:	f88d 3014 	strb.w	r3, [sp, #20]

    SetPeripheralMode(kMaster, kSpi, kEight);
   11e32:	2307      	movs	r3, #7
   11e34:	2200      	movs	r2, #0
   11e36:	2100      	movs	r1, #0
   11e38:	9803      	ldr	r0, [sp, #12]
   11e3a:	f000 f85b 	bl	11ef4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
    SetClock(kHighPolarity, kPhase0, kScrDivider, kPrescaler);
   11e3e:	2330      	movs	r3, #48	; 0x30
   11e40:	9300      	str	r3, [sp, #0]
   11e42:	2300      	movs	r3, #0
   11e44:	2200      	movs	r2, #0
   11e46:	2101      	movs	r1, #1
   11e48:	9803      	ldr	r0, [sp, #12]
   11e4a:	f000 fa09 	bl	12260 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
   11e4e:	4623      	mov	r3, r4
   11e50:	4619      	mov	r1, r3
   11e52:	4803      	ldr	r0, [pc, #12]	; (11e60 <Ssp::SetSpiMasterDefault()+0x58>)
   11e54:	f003 f9e4 	bl	15220 <__cyg_profile_func_exit>
  }
   11e58:	bf00      	nop
   11e5a:	b006      	add	sp, #24
   11e5c:	bd10      	pop	{r4, pc}
   11e5e:	bf00      	nop
   11e60:	00011e09 	.word	0x00011e09

00011e64 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>:
constexpr Type Value(Enum enum_type_value)
   11e64:	b530      	push	{r4, r5, lr}
   11e66:	b083      	sub	sp, #12
   11e68:	4675      	mov	r5, lr
   11e6a:	4603      	mov	r3, r0
   11e6c:	f88d 3007 	strb.w	r3, [sp, #7]
   11e70:	462b      	mov	r3, r5
   11e72:	4619      	mov	r1, r3
   11e74:	4806      	ldr	r0, [pc, #24]	; (11e90 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   11e76:	f003 f9bf 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11e7a:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11e7e:	462b      	mov	r3, r5
   11e80:	4619      	mov	r1, r3
   11e82:	4803      	ldr	r0, [pc, #12]	; (11e90 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   11e84:	f003 f9cc 	bl	15220 <__cyg_profile_func_exit>
   11e88:	4623      	mov	r3, r4
}
   11e8a:	4618      	mov	r0, r3
   11e8c:	b003      	add	sp, #12
   11e8e:	bd30      	pop	{r4, r5, pc}
   11e90:	00011e65 	.word	0x00011e65

00011e94 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>:
constexpr Type Value(Enum enum_type_value)
   11e94:	b530      	push	{r4, r5, lr}
   11e96:	b083      	sub	sp, #12
   11e98:	4675      	mov	r5, lr
   11e9a:	4603      	mov	r3, r0
   11e9c:	f88d 3007 	strb.w	r3, [sp, #7]
   11ea0:	462b      	mov	r3, r5
   11ea2:	4619      	mov	r1, r3
   11ea4:	4806      	ldr	r0, [pc, #24]	; (11ec0 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   11ea6:	f003 f9a7 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11eaa:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11eae:	462b      	mov	r3, r5
   11eb0:	4619      	mov	r1, r3
   11eb2:	4803      	ldr	r0, [pc, #12]	; (11ec0 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   11eb4:	f003 f9b4 	bl	15220 <__cyg_profile_func_exit>
   11eb8:	4623      	mov	r3, r4
}
   11eba:	4618      	mov	r0, r3
   11ebc:	b003      	add	sp, #12
   11ebe:	bd30      	pop	{r4, r5, pc}
   11ec0:	00011e95 	.word	0x00011e95

00011ec4 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>:
constexpr Type Value(Enum enum_type_value)
   11ec4:	b530      	push	{r4, r5, lr}
   11ec6:	b083      	sub	sp, #12
   11ec8:	4675      	mov	r5, lr
   11eca:	4603      	mov	r3, r0
   11ecc:	f88d 3007 	strb.w	r3, [sp, #7]
   11ed0:	462b      	mov	r3, r5
   11ed2:	4619      	mov	r1, r3
   11ed4:	4806      	ldr	r0, [pc, #24]	; (11ef0 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   11ed6:	f003 f98f 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11eda:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11ede:	462b      	mov	r3, r5
   11ee0:	4619      	mov	r1, r3
   11ee2:	4803      	ldr	r0, [pc, #12]	; (11ef0 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   11ee4:	f003 f99c 	bl	15220 <__cyg_profile_func_exit>
   11ee8:	4623      	mov	r3, r4
}
   11eea:	4618      	mov	r0, r3
   11eec:	b003      	add	sp, #12
   11eee:	bd30      	pop	{r4, r5, pc}
   11ef0:	00011ec5 	.word	0x00011ec5

00011ef4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>:

  /// Sets the various modes for the Peripheral
  /// @param mode - master or slave mode
  /// @param frame - format for Peripheral data to use
  /// @param size - number of bits per frame
  void SetPeripheralMode(MasterSlaveMode mode, FrameMode frame,
   11ef4:	b570      	push	{r4, r5, r6, lr}
   11ef6:	b098      	sub	sp, #96	; 0x60
   11ef8:	4674      	mov	r4, lr
   11efa:	9001      	str	r0, [sp, #4]
   11efc:	4608      	mov	r0, r1
   11efe:	4611      	mov	r1, r2
   11f00:	461a      	mov	r2, r3
   11f02:	4603      	mov	r3, r0
   11f04:	f88d 3003 	strb.w	r3, [sp, #3]
   11f08:	460b      	mov	r3, r1
   11f0a:	f88d 3002 	strb.w	r3, [sp, #2]
   11f0e:	4613      	mov	r3, r2
   11f10:	f88d 3001 	strb.w	r3, [sp, #1]
   11f14:	4623      	mov	r3, r4
   11f16:	4619      	mov	r1, r3
   11f18:	4875      	ldr	r0, [pc, #468]	; (120f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   11f1a:	f003 f96d 	bl	151f8 <__cyg_profile_func_enter>
                         DataSize size) override
  {
    uint32_t pssp = util::Value(pssp_);
   11f1e:	9b01      	ldr	r3, [sp, #4]
   11f20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   11f22:	4618      	mov	r0, r3
   11f24:	f7ff fda4 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   11f28:	4603      	mov	r3, r0
   11f2a:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   11f2c:	9b01      	ldr	r3, [sp, #4]
   11f2e:	1d18      	adds	r0, r3, #4
   11f30:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11f32:	009b      	lsls	r3, r3, #2
   11f34:	4a6f      	ldr	r2, [pc, #444]	; (120f4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x200>)
   11f36:	4413      	add	r3, r2
   11f38:	4619      	mov	r1, r3
   11f3a:	f7ff fb7b 	bl	11634 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    if (frame == kMicro)
   11f3e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   11f42:	2b02      	cmp	r3, #2
   11f44:	d102      	bne.n	11f4c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x58>
    {
      size = kEight;
   11f46:	2307      	movs	r3, #7
   11f48:	f88d 3001 	strb.w	r3, [sp, #1]
    }
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(size), kDataBit, 4);
   11f4c:	4a6a      	ldr	r2, [pc, #424]	; (120f8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11f4e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11f50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f54:	681e      	ldr	r6, [r3, #0]
   11f56:	f89d 3001 	ldrb.w	r3, [sp, #1]
   11f5a:	4618      	mov	r0, r3
   11f5c:	f7ff ff82 	bl	11e64 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>
   11f60:	4603      	mov	r3, r0
   11f62:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   11f64:	4a64      	ldr	r2, [pc, #400]	; (120f8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11f66:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11f68:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   11f6c:	9608      	str	r6, [sp, #32]
   11f6e:	460b      	mov	r3, r1
   11f70:	f88d 301f 	strb.w	r3, [sp, #31]
   11f74:	2300      	movs	r3, #0
   11f76:	9306      	str	r3, [sp, #24]
   11f78:	2304      	movs	r3, #4
   11f7a:	9305      	str	r3, [sp, #20]
   11f7c:	4623      	mov	r3, r4
   11f7e:	4619      	mov	r1, r3
   11f80:	485e      	ldr	r0, [pc, #376]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   11f82:	f003 f939 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   11f86:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   11f8a:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   11f8c:	2320      	movs	r3, #32
   11f8e:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   11f90:	9b05      	ldr	r3, [sp, #20]
   11f92:	f1c3 0320 	rsb	r3, r3, #32
   11f96:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11f9a:	fa22 f303 	lsr.w	r3, r2, r3
   11f9e:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   11fa0:	9a02      	ldr	r2, [sp, #8]
   11fa2:	9b06      	ldr	r3, [sp, #24]
   11fa4:	fa02 f303 	lsl.w	r3, r2, r3
   11fa8:	43db      	mvns	r3, r3
   11faa:	9a08      	ldr	r2, [sp, #32]
   11fac:	4013      	ands	r3, r2
   11fae:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   11fb0:	f89d 201f 	ldrb.w	r2, [sp, #31]
   11fb4:	9b02      	ldr	r3, [sp, #8]
   11fb6:	401a      	ands	r2, r3
   11fb8:	9b06      	ldr	r3, [sp, #24]
   11fba:	fa02 f303 	lsl.w	r3, r2, r3
   11fbe:	9a08      	ldr	r2, [sp, #32]
   11fc0:	4313      	orrs	r3, r2
   11fc2:	9308      	str	r3, [sp, #32]
  return target;
   11fc4:	9e08      	ldr	r6, [sp, #32]
   11fc6:	4623      	mov	r3, r4
   11fc8:	4619      	mov	r1, r3
   11fca:	484c      	ldr	r0, [pc, #304]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   11fcc:	f003 f928 	bl	15220 <__cyg_profile_func_exit>
   11fd0:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(frame), kFrameBit, 2);
   11fd2:	4a49      	ldr	r2, [pc, #292]	; (120f8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11fd4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11fd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11fda:	681e      	ldr	r6, [r3, #0]
   11fdc:	f89d 3002 	ldrb.w	r3, [sp, #2]
   11fe0:	4618      	mov	r0, r3
   11fe2:	f7ff ff57 	bl	11e94 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>
   11fe6:	4603      	mov	r3, r0
   11fe8:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   11fea:	4a43      	ldr	r2, [pc, #268]	; (120f8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   11fec:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   11fee:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   11ff2:	960f      	str	r6, [sp, #60]	; 0x3c
   11ff4:	460b      	mov	r3, r1
   11ff6:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   11ffa:	2304      	movs	r3, #4
   11ffc:	930d      	str	r3, [sp, #52]	; 0x34
   11ffe:	2302      	movs	r3, #2
   12000:	930c      	str	r3, [sp, #48]	; 0x30
   12002:	4623      	mov	r3, r4
   12004:	4619      	mov	r1, r3
   12006:	483d      	ldr	r0, [pc, #244]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   12008:	f003 f8f6 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1200c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12010:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12012:	2320      	movs	r3, #32
   12014:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12016:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12018:	f1c3 0320 	rsb	r3, r3, #32
   1201c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12020:	fa22 f303 	lsr.w	r3, r2, r3
   12024:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   12026:	9a09      	ldr	r2, [sp, #36]	; 0x24
   12028:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1202a:	fa02 f303 	lsl.w	r3, r2, r3
   1202e:	43db      	mvns	r3, r3
   12030:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   12032:	4013      	ands	r3, r2
   12034:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   12036:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   1203a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1203c:	401a      	ands	r2, r3
   1203e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12040:	fa02 f303 	lsl.w	r3, r2, r3
   12044:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   12046:	4313      	orrs	r3, r2
   12048:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   1204a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   1204c:	4623      	mov	r3, r4
   1204e:	4619      	mov	r1, r3
   12050:	482a      	ldr	r0, [pc, #168]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   12052:	f003 f8e5 	bl	15220 <__cyg_profile_func_exit>
   12056:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR1 = bit::Insert(
        ssp_registers[pssp]->CR1, util::Value(mode), kMasterModeBit, 1);
   12058:	4a27      	ldr	r2, [pc, #156]	; (120f8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   1205a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1205c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12060:	685e      	ldr	r6, [r3, #4]
    ssp_registers[pssp]->CR1 = bit::Insert(
   12062:	f89d 3003 	ldrb.w	r3, [sp, #3]
   12066:	4618      	mov	r0, r3
   12068:	f7ff ff2c 	bl	11ec4 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>
   1206c:	4603      	mov	r3, r0
   1206e:	4619      	mov	r1, r3
   12070:	4a21      	ldr	r2, [pc, #132]	; (120f8 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   12072:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   12074:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   12078:	9616      	str	r6, [sp, #88]	; 0x58
   1207a:	460b      	mov	r3, r1
   1207c:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   12080:	2302      	movs	r3, #2
   12082:	9314      	str	r3, [sp, #80]	; 0x50
   12084:	2301      	movs	r3, #1
   12086:	9313      	str	r3, [sp, #76]	; 0x4c
   12088:	4623      	mov	r3, r4
   1208a:	4619      	mov	r1, r3
   1208c:	481b      	ldr	r0, [pc, #108]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   1208e:	f003 f8b3 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12092:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12096:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12098:	2320      	movs	r3, #32
   1209a:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1209c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1209e:	f1c3 0320 	rsb	r3, r3, #32
   120a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   120a6:	fa22 f303 	lsr.w	r3, r2, r3
   120aa:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   120ac:	9a10      	ldr	r2, [sp, #64]	; 0x40
   120ae:	9b14      	ldr	r3, [sp, #80]	; 0x50
   120b0:	fa02 f303 	lsl.w	r3, r2, r3
   120b4:	43db      	mvns	r3, r3
   120b6:	9a16      	ldr	r2, [sp, #88]	; 0x58
   120b8:	4013      	ands	r3, r2
   120ba:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   120bc:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   120c0:	9b10      	ldr	r3, [sp, #64]	; 0x40
   120c2:	401a      	ands	r2, r3
   120c4:	9b14      	ldr	r3, [sp, #80]	; 0x50
   120c6:	fa02 f303 	lsl.w	r3, r2, r3
   120ca:	9a16      	ldr	r2, [sp, #88]	; 0x58
   120cc:	4313      	orrs	r3, r2
   120ce:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   120d0:	9e16      	ldr	r6, [sp, #88]	; 0x58
   120d2:	4623      	mov	r3, r4
   120d4:	4619      	mov	r1, r3
   120d6:	4809      	ldr	r0, [pc, #36]	; (120fc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   120d8:	f003 f8a2 	bl	15220 <__cyg_profile_func_exit>
   120dc:	606e      	str	r6, [r5, #4]
   120de:	4623      	mov	r3, r4
   120e0:	4619      	mov	r1, r3
   120e2:	4803      	ldr	r0, [pc, #12]	; (120f0 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   120e4:	f003 f89c 	bl	15220 <__cyg_profile_func_exit>
  }
   120e8:	bf00      	nop
   120ea:	b018      	add	sp, #96	; 0x60
   120ec:	bd70      	pop	{r4, r5, r6, pc}
   120ee:	bf00      	nop
   120f0:	00011ef5 	.word	0x00011ef5
   120f4:	00019d10 	.word	0x00019d10
   120f8:	10000050 	.word	0x10000050
   120fc:	00012ddd 	.word	0x00012ddd

00012100 <Ssp::GetPeripheralMode()>:
  /// Gets the Peripheral modes from registers
  /// @return - returns a 16-bit value as follows: 0000_000x 0xx0_xxxx
  ///       MasterSlaveMode = 1-bit @ bit 8
  ///       FrameMode       = 2-bit @ bit 5
  ///       DataSize        = 4-bit @ bit 0
  uint16_t GetPeripheralMode() override
   12100:	b570      	push	{r4, r5, r6, lr}
   12102:	b096      	sub	sp, #88	; 0x58
   12104:	4674      	mov	r4, lr
   12106:	9001      	str	r0, [sp, #4]
   12108:	4623      	mov	r3, r4
   1210a:	4619      	mov	r1, r3
   1210c:	4850      	ldr	r0, [pc, #320]	; (12250 <Ssp::GetPeripheralMode()+0x150>)
   1210e:	f003 f873 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint16_t return_val = 0;
   12112:	2300      	movs	r3, #0
   12114:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    uint32_t pssp       = util::Value(pssp_);
   12118:	9b01      	ldr	r3, [sp, #4]
   1211a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1211c:	4618      	mov	r0, r3
   1211e:	f7ff fca7 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   12122:	4603      	mov	r3, r0
   12124:	9314      	str	r3, [sp, #80]	; 0x50
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   12126:	9b01      	ldr	r3, [sp, #4]
   12128:	1d18      	adds	r0, r3, #4
   1212a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1212c:	009b      	lsls	r3, r3, #2
   1212e:	4a49      	ldr	r2, [pc, #292]	; (12254 <Ssp::GetPeripheralMode()+0x154>)
   12130:	4413      	add	r3, r2
   12132:	4619      	mov	r1, r3
   12134:	f7ff fa7e 	bl	11634 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val = static_cast<uint16_t>(
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   12138:	4a47      	ldr	r2, [pc, #284]	; (12258 <Ssp::GetPeripheralMode()+0x158>)
   1213a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1213c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12140:	681b      	ldr	r3, [r3, #0]
   12142:	9307      	str	r3, [sp, #28]
   12144:	2300      	movs	r3, #0
   12146:	9306      	str	r3, [sp, #24]
   12148:	2304      	movs	r3, #4
   1214a:	9305      	str	r3, [sp, #20]
   1214c:	4623      	mov	r3, r4
   1214e:	4619      	mov	r1, r3
   12150:	4842      	ldr	r0, [pc, #264]	; (1225c <Ssp::GetPeripheralMode()+0x15c>)
   12152:	f003 f851 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12156:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1215a:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1215c:	2320      	movs	r3, #32
   1215e:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12160:	9b05      	ldr	r3, [sp, #20]
   12162:	f1c3 0320 	rsb	r3, r3, #32
   12166:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1216a:	fa22 f303 	lsr.w	r3, r2, r3
   1216e:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   12170:	9a07      	ldr	r2, [sp, #28]
   12172:	9b06      	ldr	r3, [sp, #24]
   12174:	40da      	lsrs	r2, r3
   12176:	9b02      	ldr	r3, [sp, #8]
   12178:	ea02 0503 	and.w	r5, r2, r3
   1217c:	4623      	mov	r3, r4
   1217e:	4619      	mov	r1, r3
   12180:	4836      	ldr	r0, [pc, #216]	; (1225c <Ssp::GetPeripheralMode()+0x15c>)
   12182:	f003 f84d 	bl	15220 <__cyg_profile_func_exit>
   12186:	b2ad      	uxth	r5, r5
        ((bit::Extract(ssp_registers[pssp]->CR0, kFrameBit, 2)) << 5) +
   12188:	4a33      	ldr	r2, [pc, #204]	; (12258 <Ssp::GetPeripheralMode()+0x158>)
   1218a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1218c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12190:	681b      	ldr	r3, [r3, #0]
   12192:	930d      	str	r3, [sp, #52]	; 0x34
   12194:	2304      	movs	r3, #4
   12196:	930c      	str	r3, [sp, #48]	; 0x30
   12198:	2302      	movs	r3, #2
   1219a:	930b      	str	r3, [sp, #44]	; 0x2c
   1219c:	4623      	mov	r3, r4
   1219e:	4619      	mov	r1, r3
   121a0:	482e      	ldr	r0, [pc, #184]	; (1225c <Ssp::GetPeripheralMode()+0x15c>)
   121a2:	f003 f829 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   121a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   121aa:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   121ac:	2320      	movs	r3, #32
   121ae:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   121b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   121b2:	f1c3 0320 	rsb	r3, r3, #32
   121b6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   121ba:	fa22 f303 	lsr.w	r3, r2, r3
   121be:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   121c0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   121c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   121c4:	40da      	lsrs	r2, r3
   121c6:	9b08      	ldr	r3, [sp, #32]
   121c8:	ea02 0603 	and.w	r6, r2, r3
   121cc:	4623      	mov	r3, r4
   121ce:	4619      	mov	r1, r3
   121d0:	4822      	ldr	r0, [pc, #136]	; (1225c <Ssp::GetPeripheralMode()+0x15c>)
   121d2:	f003 f825 	bl	15220 <__cyg_profile_func_exit>
   121d6:	b2b3      	uxth	r3, r6
   121d8:	015b      	lsls	r3, r3, #5
   121da:	b29b      	uxth	r3, r3
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   121dc:	442b      	add	r3, r5
   121de:	b29d      	uxth	r5, r3
        ((bit::Extract(ssp_registers[pssp]->CR1, kMasterModeBit)) << 8));
   121e0:	4a1d      	ldr	r2, [pc, #116]	; (12258 <Ssp::GetPeripheralMode()+0x158>)
   121e2:	9b14      	ldr	r3, [sp, #80]	; 0x50
   121e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121e8:	685b      	ldr	r3, [r3, #4]
   121ea:	9313      	str	r3, [sp, #76]	; 0x4c
   121ec:	2302      	movs	r3, #2
   121ee:	9312      	str	r3, [sp, #72]	; 0x48
   121f0:	2301      	movs	r3, #1
   121f2:	9311      	str	r3, [sp, #68]	; 0x44
   121f4:	4623      	mov	r3, r4
   121f6:	4619      	mov	r1, r3
   121f8:	4818      	ldr	r0, [pc, #96]	; (1225c <Ssp::GetPeripheralMode()+0x15c>)
   121fa:	f002 fffd 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   121fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12202:	9310      	str	r3, [sp, #64]	; 0x40
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12204:	2320      	movs	r3, #32
   12206:	930f      	str	r3, [sp, #60]	; 0x3c
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12208:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1220a:	f1c3 0320 	rsb	r3, r3, #32
   1220e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12212:	fa22 f303 	lsr.w	r3, r2, r3
   12216:	930e      	str	r3, [sp, #56]	; 0x38
  return (target >> position) & mask;
   12218:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1221a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1221c:	40da      	lsrs	r2, r3
   1221e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   12220:	ea02 0603 	and.w	r6, r2, r3
   12224:	4623      	mov	r3, r4
   12226:	4619      	mov	r1, r3
   12228:	480c      	ldr	r0, [pc, #48]	; (1225c <Ssp::GetPeripheralMode()+0x15c>)
   1222a:	f002 fff9 	bl	15220 <__cyg_profile_func_exit>
   1222e:	b2b3      	uxth	r3, r6
   12230:	021b      	lsls	r3, r3, #8
   12232:	b29b      	uxth	r3, r3
    return_val = static_cast<uint16_t>(
   12234:	442b      	add	r3, r5
   12236:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    return return_val;
   1223a:	f8bd 5056 	ldrh.w	r5, [sp, #86]	; 0x56
   1223e:	4623      	mov	r3, r4
   12240:	4619      	mov	r1, r3
   12242:	4803      	ldr	r0, [pc, #12]	; (12250 <Ssp::GetPeripheralMode()+0x150>)
   12244:	f002 ffec 	bl	15220 <__cyg_profile_func_exit>
   12248:	462b      	mov	r3, r5
  }
   1224a:	4618      	mov	r0, r3
   1224c:	b016      	add	sp, #88	; 0x58
   1224e:	bd70      	pop	{r4, r5, r6, pc}
   12250:	00012101 	.word	0x00012101
   12254:	00019d10 	.word	0x00019d10
   12258:	10000050 	.word	0x10000050
   1225c:	00012e51 	.word	0x00012e51

00012260 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>:
  /// Sets the clock rate for the Peripheral
  /// @param polarity - maintain bus on clock 0=low or 1=high between frames
  /// @param phase - capture serial data on 0=first or 1=second clock cycle
  /// @param divider - see notes in SSP_Interface above
  /// @param prescaler - divides the PCLK, must be even value between 2-254
  void SetClock(bool polarity, bool phase, uint8_t divider,
   12260:	b570      	push	{r4, r5, r6, lr}
   12262:	b098      	sub	sp, #96	; 0x60
   12264:	4674      	mov	r4, lr
   12266:	9001      	str	r0, [sp, #4]
   12268:	4608      	mov	r0, r1
   1226a:	4611      	mov	r1, r2
   1226c:	461a      	mov	r2, r3
   1226e:	4603      	mov	r3, r0
   12270:	f88d 3003 	strb.w	r3, [sp, #3]
   12274:	460b      	mov	r3, r1
   12276:	f88d 3002 	strb.w	r3, [sp, #2]
   1227a:	4613      	mov	r3, r2
   1227c:	f88d 3001 	strb.w	r3, [sp, #1]
   12280:	4623      	mov	r3, r4
   12282:	4619      	mov	r1, r3
   12284:	486c      	ldr	r0, [pc, #432]	; (12438 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   12286:	f002 ffb7 	bl	151f8 <__cyg_profile_func_enter>
                uint8_t prescaler) override
  {
    uint32_t pssp = util::Value(pssp_);
   1228a:	9b01      	ldr	r3, [sp, #4]
   1228c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1228e:	4618      	mov	r0, r3
   12290:	f7ff fbee 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   12294:	4603      	mov	r3, r0
   12296:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   12298:	9b01      	ldr	r3, [sp, #4]
   1229a:	1d18      	adds	r0, r3, #4
   1229c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1229e:	009b      	lsls	r3, r3, #2
   122a0:	4a66      	ldr	r2, [pc, #408]	; (1243c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1dc>)
   122a2:	4413      	add	r3, r2
   122a4:	4619      	mov	r1, r3
   122a6:	f7ff f9c5 	bl	11634 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    // first clear the appropriate registers
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, polarity, kPolarityBit, 1);
   122aa:	4a65      	ldr	r2, [pc, #404]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   122ac:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   122ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   122b2:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   122b4:	4962      	ldr	r1, [pc, #392]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   122b6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   122b8:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   122bc:	9308      	str	r3, [sp, #32]
   122be:	f89d 3003 	ldrb.w	r3, [sp, #3]
   122c2:	f88d 301f 	strb.w	r3, [sp, #31]
   122c6:	2306      	movs	r3, #6
   122c8:	9306      	str	r3, [sp, #24]
   122ca:	2301      	movs	r3, #1
   122cc:	9305      	str	r3, [sp, #20]
   122ce:	4623      	mov	r3, r4
   122d0:	4619      	mov	r1, r3
   122d2:	485c      	ldr	r0, [pc, #368]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   122d4:	f002 ff90 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   122d8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   122dc:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   122de:	2320      	movs	r3, #32
   122e0:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   122e2:	9b05      	ldr	r3, [sp, #20]
   122e4:	f1c3 0320 	rsb	r3, r3, #32
   122e8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   122ec:	fa22 f303 	lsr.w	r3, r2, r3
   122f0:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   122f2:	9a02      	ldr	r2, [sp, #8]
   122f4:	9b06      	ldr	r3, [sp, #24]
   122f6:	fa02 f303 	lsl.w	r3, r2, r3
   122fa:	43db      	mvns	r3, r3
   122fc:	9a08      	ldr	r2, [sp, #32]
   122fe:	4013      	ands	r3, r2
   12300:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   12302:	f89d 201f 	ldrb.w	r2, [sp, #31]
   12306:	9b02      	ldr	r3, [sp, #8]
   12308:	401a      	ands	r2, r3
   1230a:	9b06      	ldr	r3, [sp, #24]
   1230c:	fa02 f303 	lsl.w	r3, r2, r3
   12310:	9a08      	ldr	r2, [sp, #32]
   12312:	4313      	orrs	r3, r2
   12314:	9308      	str	r3, [sp, #32]
  return target;
   12316:	9e08      	ldr	r6, [sp, #32]
   12318:	4623      	mov	r3, r4
   1231a:	4619      	mov	r1, r3
   1231c:	4849      	ldr	r0, [pc, #292]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   1231e:	f002 ff7f 	bl	15220 <__cyg_profile_func_exit>
   12322:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, phase, kPhaseBit, 1);
   12324:	4a46      	ldr	r2, [pc, #280]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   12326:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   12328:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1232c:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   1232e:	4944      	ldr	r1, [pc, #272]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   12330:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   12332:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   12336:	930f      	str	r3, [sp, #60]	; 0x3c
   12338:	f89d 3002 	ldrb.w	r3, [sp, #2]
   1233c:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   12340:	2307      	movs	r3, #7
   12342:	930d      	str	r3, [sp, #52]	; 0x34
   12344:	2301      	movs	r3, #1
   12346:	930c      	str	r3, [sp, #48]	; 0x30
   12348:	4623      	mov	r3, r4
   1234a:	4619      	mov	r1, r3
   1234c:	483d      	ldr	r0, [pc, #244]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   1234e:	f002 ff53 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12352:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12356:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12358:	2320      	movs	r3, #32
   1235a:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1235c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1235e:	f1c3 0320 	rsb	r3, r3, #32
   12362:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12366:	fa22 f303 	lsr.w	r3, r2, r3
   1236a:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   1236c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1236e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12370:	fa02 f303 	lsl.w	r3, r2, r3
   12374:	43db      	mvns	r3, r3
   12376:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   12378:	4013      	ands	r3, r2
   1237a:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   1237c:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   12380:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12382:	401a      	ands	r2, r3
   12384:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12386:	fa02 f303 	lsl.w	r3, r2, r3
   1238a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1238c:	4313      	orrs	r3, r2
   1238e:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   12390:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   12392:	4623      	mov	r3, r4
   12394:	4619      	mov	r1, r3
   12396:	482b      	ldr	r0, [pc, #172]	; (12444 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   12398:	f002 ff42 	bl	15220 <__cyg_profile_func_exit>
   1239c:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, divider, kDividerBit, 8);
   1239e:	4a28      	ldr	r2, [pc, #160]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   123a0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   123a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   123a6:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   123a8:	4925      	ldr	r1, [pc, #148]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   123aa:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   123ac:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   123b0:	9316      	str	r3, [sp, #88]	; 0x58
   123b2:	f89d 3001 	ldrb.w	r3, [sp, #1]
   123b6:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   123ba:	2308      	movs	r3, #8
   123bc:	9314      	str	r3, [sp, #80]	; 0x50
   123be:	2308      	movs	r3, #8
   123c0:	9313      	str	r3, [sp, #76]	; 0x4c
   123c2:	4623      	mov	r3, r4
   123c4:	4619      	mov	r1, r3
   123c6:	4820      	ldr	r0, [pc, #128]	; (12448 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   123c8:	f002 ff16 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   123cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   123d0:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   123d2:	2320      	movs	r3, #32
   123d4:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   123d6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   123d8:	f1c3 0320 	rsb	r3, r3, #32
   123dc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   123e0:	fa22 f303 	lsr.w	r3, r2, r3
   123e4:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   123e6:	9a10      	ldr	r2, [sp, #64]	; 0x40
   123e8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   123ea:	fa02 f303 	lsl.w	r3, r2, r3
   123ee:	43db      	mvns	r3, r3
   123f0:	9a16      	ldr	r2, [sp, #88]	; 0x58
   123f2:	4013      	ands	r3, r2
   123f4:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   123f6:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   123fa:	9b10      	ldr	r3, [sp, #64]	; 0x40
   123fc:	401a      	ands	r2, r3
   123fe:	9b14      	ldr	r3, [sp, #80]	; 0x50
   12400:	fa02 f303 	lsl.w	r3, r2, r3
   12404:	9a16      	ldr	r2, [sp, #88]	; 0x58
   12406:	4313      	orrs	r3, r2
   12408:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   1240a:	9e16      	ldr	r6, [sp, #88]	; 0x58
   1240c:	4623      	mov	r3, r4
   1240e:	4619      	mov	r1, r3
   12410:	480d      	ldr	r0, [pc, #52]	; (12448 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   12412:	f002 ff05 	bl	15220 <__cyg_profile_func_exit>
   12416:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CPSR = prescaler;
   12418:	4a09      	ldr	r2, [pc, #36]	; (12440 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1241a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1241c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12420:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   12424:	611a      	str	r2, [r3, #16]
   12426:	4623      	mov	r3, r4
   12428:	4619      	mov	r1, r3
   1242a:	4803      	ldr	r0, [pc, #12]	; (12438 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   1242c:	f002 fef8 	bl	15220 <__cyg_profile_func_exit>
  }
   12430:	bf00      	nop
   12432:	b018      	add	sp, #96	; 0x60
   12434:	bd70      	pop	{r4, r5, r6, pc}
   12436:	bf00      	nop
   12438:	00012261 	.word	0x00012261
   1243c:	00019d10 	.word	0x00019d10
   12440:	10000050 	.word	0x10000050
   12444:	00012ea5 	.word	0x00012ea5
   12448:	00012ddd 	.word	0x00012ddd

0001244c <Ssp::GetClock()>:
  ///   0000_0000 0000_0x0x xxxx_xxxx xxxx_xxxx
  ///       polarity    = 1-bit @ bit 18
  ///       phase       = 1-bit @ bit 16
  ///       divider     = 8-bits @ bit 8
  ///       prescaler   = 8-bits @ bit 0
  uint32_t GetClock() override
   1244c:	b570      	push	{r4, r5, r6, lr}
   1244e:	b094      	sub	sp, #80	; 0x50
   12450:	4674      	mov	r4, lr
   12452:	9001      	str	r0, [sp, #4]
   12454:	4623      	mov	r3, r4
   12456:	4619      	mov	r1, r3
   12458:	4858      	ldr	r0, [pc, #352]	; (125bc <Ssp::GetClock()+0x170>)
   1245a:	f002 fecd 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint32_t return_val = 0;
   1245e:	2300      	movs	r3, #0
   12460:	9313      	str	r3, [sp, #76]	; 0x4c
    uint32_t pssp       = util::Value(pssp_);
   12462:	9b01      	ldr	r3, [sp, #4]
   12464:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12466:	4618      	mov	r0, r3
   12468:	f7ff fb02 	bl	11a70 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   1246c:	4603      	mov	r3, r0
   1246e:	9312      	str	r3, [sp, #72]	; 0x48
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   12470:	9b01      	ldr	r3, [sp, #4]
   12472:	1d18      	adds	r0, r3, #4
   12474:	9b12      	ldr	r3, [sp, #72]	; 0x48
   12476:	009b      	lsls	r3, r3, #2
   12478:	4a51      	ldr	r2, [pc, #324]	; (125c0 <Ssp::GetClock()+0x174>)
   1247a:	4413      	add	r3, r2
   1247c:	4619      	mov	r1, r3
   1247e:	f7ff f8d9 	bl	11634 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val =
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   12482:	4a50      	ldr	r2, [pc, #320]	; (125c4 <Ssp::GetClock()+0x178>)
   12484:	9b12      	ldr	r3, [sp, #72]	; 0x48
   12486:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1248a:	691b      	ldr	r3, [r3, #16]
   1248c:	9307      	str	r3, [sp, #28]
   1248e:	2300      	movs	r3, #0
   12490:	9306      	str	r3, [sp, #24]
   12492:	2308      	movs	r3, #8
   12494:	9305      	str	r3, [sp, #20]
   12496:	4623      	mov	r3, r4
   12498:	4619      	mov	r1, r3
   1249a:	484b      	ldr	r0, [pc, #300]	; (125c8 <Ssp::GetClock()+0x17c>)
   1249c:	f002 feac 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   124a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   124a4:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   124a6:	2320      	movs	r3, #32
   124a8:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   124aa:	9b05      	ldr	r3, [sp, #20]
   124ac:	f1c3 0320 	rsb	r3, r3, #32
   124b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   124b4:	fa22 f303 	lsr.w	r3, r2, r3
   124b8:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   124ba:	9a07      	ldr	r2, [sp, #28]
   124bc:	9b06      	ldr	r3, [sp, #24]
   124be:	40da      	lsrs	r2, r3
   124c0:	9b02      	ldr	r3, [sp, #8]
   124c2:	ea02 0503 	and.w	r5, r2, r3
   124c6:	4623      	mov	r3, r4
   124c8:	4619      	mov	r1, r3
   124ca:	483f      	ldr	r0, [pc, #252]	; (125c8 <Ssp::GetClock()+0x17c>)
   124cc:	f002 fea8 	bl	15220 <__cyg_profile_func_exit>
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   124d0:	4a3c      	ldr	r2, [pc, #240]	; (125c4 <Ssp::GetClock()+0x178>)
   124d2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   124d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124d8:	681b      	ldr	r3, [r3, #0]
   124da:	930d      	str	r3, [sp, #52]	; 0x34
   124dc:	2308      	movs	r3, #8
   124de:	930c      	str	r3, [sp, #48]	; 0x30
   124e0:	2308      	movs	r3, #8
   124e2:	930b      	str	r3, [sp, #44]	; 0x2c
   124e4:	4623      	mov	r3, r4
   124e6:	4619      	mov	r1, r3
   124e8:	4837      	ldr	r0, [pc, #220]	; (125c8 <Ssp::GetClock()+0x17c>)
   124ea:	f002 fe85 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   124ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   124f2:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   124f4:	2320      	movs	r3, #32
   124f6:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   124f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   124fa:	f1c3 0320 	rsb	r3, r3, #32
   124fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12502:	fa22 f303 	lsr.w	r3, r2, r3
   12506:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   12508:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1250a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1250c:	40da      	lsrs	r2, r3
   1250e:	9b08      	ldr	r3, [sp, #32]
   12510:	ea02 0603 	and.w	r6, r2, r3
   12514:	4623      	mov	r3, r4
   12516:	4619      	mov	r1, r3
   12518:	482b      	ldr	r0, [pc, #172]	; (125c8 <Ssp::GetClock()+0x17c>)
   1251a:	f002 fe81 	bl	15220 <__cyg_profile_func_exit>
   1251e:	0233      	lsls	r3, r6, #8
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   12520:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPhaseBit)) << 16) +
   12522:	4a28      	ldr	r2, [pc, #160]	; (125c4 <Ssp::GetClock()+0x178>)
   12524:	9b12      	ldr	r3, [sp, #72]	; 0x48
   12526:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1252a:	681b      	ldr	r3, [r3, #0]
   1252c:	930f      	str	r3, [sp, #60]	; 0x3c
   1252e:	2307      	movs	r3, #7
   12530:	930e      	str	r3, [sp, #56]	; 0x38
   12532:	4623      	mov	r3, r4
   12534:	4619      	mov	r1, r3
   12536:	4825      	ldr	r0, [pc, #148]	; (125cc <Ssp::GetClock()+0x180>)
   12538:	f002 fe5e 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   1253c:	2201      	movs	r2, #1
   1253e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   12540:	fa02 f303 	lsl.w	r3, r2, r3
   12544:	461a      	mov	r2, r3
   12546:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   12548:	4013      	ands	r3, r2
   1254a:	2b00      	cmp	r3, #0
   1254c:	bf14      	ite	ne
   1254e:	2301      	movne	r3, #1
   12550:	2300      	moveq	r3, #0
   12552:	b2de      	uxtb	r6, r3
   12554:	4623      	mov	r3, r4
   12556:	4619      	mov	r1, r3
   12558:	481c      	ldr	r0, [pc, #112]	; (125cc <Ssp::GetClock()+0x180>)
   1255a:	f002 fe61 	bl	15220 <__cyg_profile_func_exit>
   1255e:	4633      	mov	r3, r6
   12560:	041b      	lsls	r3, r3, #16
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   12562:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPolarityBit)) << 18);
   12564:	4a17      	ldr	r2, [pc, #92]	; (125c4 <Ssp::GetClock()+0x178>)
   12566:	9b12      	ldr	r3, [sp, #72]	; 0x48
   12568:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1256c:	681b      	ldr	r3, [r3, #0]
   1256e:	9311      	str	r3, [sp, #68]	; 0x44
   12570:	2306      	movs	r3, #6
   12572:	9310      	str	r3, [sp, #64]	; 0x40
   12574:	4623      	mov	r3, r4
   12576:	4619      	mov	r1, r3
   12578:	4814      	ldr	r0, [pc, #80]	; (125cc <Ssp::GetClock()+0x180>)
   1257a:	f002 fe3d 	bl	151f8 <__cyg_profile_func_enter>
   1257e:	2201      	movs	r2, #1
   12580:	9b10      	ldr	r3, [sp, #64]	; 0x40
   12582:	fa02 f303 	lsl.w	r3, r2, r3
   12586:	461a      	mov	r2, r3
   12588:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1258a:	4013      	ands	r3, r2
   1258c:	2b00      	cmp	r3, #0
   1258e:	bf14      	ite	ne
   12590:	2301      	movne	r3, #1
   12592:	2300      	moveq	r3, #0
   12594:	b2de      	uxtb	r6, r3
   12596:	4623      	mov	r3, r4
   12598:	4619      	mov	r1, r3
   1259a:	480c      	ldr	r0, [pc, #48]	; (125cc <Ssp::GetClock()+0x180>)
   1259c:	f002 fe40 	bl	15220 <__cyg_profile_func_exit>
   125a0:	4633      	mov	r3, r6
   125a2:	049b      	lsls	r3, r3, #18
    return_val =
   125a4:	442b      	add	r3, r5
   125a6:	9313      	str	r3, [sp, #76]	; 0x4c

    return return_val;
   125a8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   125aa:	4623      	mov	r3, r4
   125ac:	4619      	mov	r1, r3
   125ae:	4803      	ldr	r0, [pc, #12]	; (125bc <Ssp::GetClock()+0x170>)
   125b0:	f002 fe36 	bl	15220 <__cyg_profile_func_exit>
   125b4:	462b      	mov	r3, r5
  }
   125b6:	4618      	mov	r0, r3
   125b8:	b014      	add	sp, #80	; 0x50
   125ba:	bd70      	pop	{r4, r5, r6, pc}
   125bc:	0001244d 	.word	0x0001244d
   125c0:	00019d10 	.word	0x00019d10
   125c4:	10000050 	.word	0x10000050
   125c8:	00012e51 	.word	0x00012e51
   125cc:	00012d99 	.word	0x00012d99

000125d0 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>:
class PixelDisplayInterface
{
 public:
  SJ2_PACKED(struct) Color_t
  {
    Color_t(bool r, bool g, bool b, uint8_t a, uint8_t bits,
   125d0:	b530      	push	{r4, r5, lr}
   125d2:	b083      	sub	sp, #12
   125d4:	4675      	mov	r5, lr
   125d6:	9001      	str	r0, [sp, #4]
   125d8:	4608      	mov	r0, r1
   125da:	4611      	mov	r1, r2
   125dc:	461a      	mov	r2, r3
   125de:	4603      	mov	r3, r0
   125e0:	f88d 3003 	strb.w	r3, [sp, #3]
   125e4:	460b      	mov	r3, r1
   125e6:	f88d 3002 	strb.w	r3, [sp, #2]
   125ea:	4613      	mov	r3, r2
   125ec:	f88d 3001 	strb.w	r3, [sp, #1]
   125f0:	462b      	mov	r3, r5
   125f2:	4619      	mov	r1, r3
   125f4:	481a      	ldr	r0, [pc, #104]	; (12660 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)+0x90>)
   125f6:	f002 fdff 	bl	151f8 <__cyg_profile_func_enter>
          red(r),
          green(g),
          blue(b),
          padding(0),
          color_bits(bits),
          alpha(a)
   125fa:	9a01      	ldr	r2, [sp, #4]
   125fc:	7813      	ldrb	r3, [r2, #0]
   125fe:	f89d 1020 	ldrb.w	r1, [sp, #32]
   12602:	f361 0300 	bfi	r3, r1, #0, #1
   12606:	7013      	strb	r3, [r2, #0]
   12608:	9a01      	ldr	r2, [sp, #4]
   1260a:	7813      	ldrb	r3, [r2, #0]
   1260c:	f89d 1003 	ldrb.w	r1, [sp, #3]
   12610:	f361 0341 	bfi	r3, r1, #1, #1
   12614:	7013      	strb	r3, [r2, #0]
   12616:	9a01      	ldr	r2, [sp, #4]
   12618:	7813      	ldrb	r3, [r2, #0]
   1261a:	f89d 1002 	ldrb.w	r1, [sp, #2]
   1261e:	f361 0382 	bfi	r3, r1, #2, #1
   12622:	7013      	strb	r3, [r2, #0]
   12624:	9a01      	ldr	r2, [sp, #4]
   12626:	7813      	ldrb	r3, [r2, #0]
   12628:	f89d 1001 	ldrb.w	r1, [sp, #1]
   1262c:	f361 03c3 	bfi	r3, r1, #3, #1
   12630:	7013      	strb	r3, [r2, #0]
   12632:	9a01      	ldr	r2, [sp, #4]
   12634:	7813      	ldrb	r3, [r2, #0]
   12636:	f36f 1307 	bfc	r3, #4, #4
   1263a:	7013      	strb	r3, [r2, #0]
   1263c:	9b01      	ldr	r3, [sp, #4]
   1263e:	f89d 201c 	ldrb.w	r2, [sp, #28]
   12642:	705a      	strb	r2, [r3, #1]
   12644:	9b01      	ldr	r3, [sp, #4]
   12646:	f89d 2018 	ldrb.w	r2, [sp, #24]
   1264a:	709a      	strb	r2, [r3, #2]
    {
    }
   1264c:	9c01      	ldr	r4, [sp, #4]
   1264e:	462b      	mov	r3, r5
   12650:	4619      	mov	r1, r3
   12652:	4803      	ldr	r0, [pc, #12]	; (12660 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)+0x90>)
   12654:	f002 fde4 	bl	15220 <__cyg_profile_func_exit>
   12658:	4623      	mov	r3, r4
   1265a:	4618      	mov	r0, r3
   1265c:	b003      	add	sp, #12
   1265e:	bd30      	pop	{r4, r5, pc}
   12660:	000125d1 	.word	0x000125d1

00012664 <PixelDisplayInterface::Color_t::Color_t()>:
    Color_t()
   12664:	b530      	push	{r4, r5, lr}
   12666:	b083      	sub	sp, #12
   12668:	4675      	mov	r5, lr
   1266a:	9001      	str	r0, [sp, #4]
   1266c:	462b      	mov	r3, r5
   1266e:	4619      	mov	r1, r3
   12670:	4815      	ldr	r0, [pc, #84]	; (126c8 <PixelDisplayInterface::Color_t::Color_t()+0x64>)
   12672:	f002 fdc1 	bl	151f8 <__cyg_profile_func_enter>
          red(false),
          green(false),
          blue(false),
          padding(0),
          color_bits(0),
          alpha(0)
   12676:	9a01      	ldr	r2, [sp, #4]
   12678:	7813      	ldrb	r3, [r2, #0]
   1267a:	f36f 0300 	bfc	r3, #0, #1
   1267e:	7013      	strb	r3, [r2, #0]
   12680:	9a01      	ldr	r2, [sp, #4]
   12682:	7813      	ldrb	r3, [r2, #0]
   12684:	f36f 0341 	bfc	r3, #1, #1
   12688:	7013      	strb	r3, [r2, #0]
   1268a:	9a01      	ldr	r2, [sp, #4]
   1268c:	7813      	ldrb	r3, [r2, #0]
   1268e:	f36f 0382 	bfc	r3, #2, #1
   12692:	7013      	strb	r3, [r2, #0]
   12694:	9a01      	ldr	r2, [sp, #4]
   12696:	7813      	ldrb	r3, [r2, #0]
   12698:	f36f 03c3 	bfc	r3, #3, #1
   1269c:	7013      	strb	r3, [r2, #0]
   1269e:	9a01      	ldr	r2, [sp, #4]
   126a0:	7813      	ldrb	r3, [r2, #0]
   126a2:	f36f 1307 	bfc	r3, #4, #4
   126a6:	7013      	strb	r3, [r2, #0]
   126a8:	9b01      	ldr	r3, [sp, #4]
   126aa:	2200      	movs	r2, #0
   126ac:	705a      	strb	r2, [r3, #1]
   126ae:	9b01      	ldr	r3, [sp, #4]
   126b0:	2200      	movs	r2, #0
   126b2:	709a      	strb	r2, [r3, #2]
    {
    }
   126b4:	9c01      	ldr	r4, [sp, #4]
   126b6:	462b      	mov	r3, r5
   126b8:	4619      	mov	r1, r3
   126ba:	4803      	ldr	r0, [pc, #12]	; (126c8 <PixelDisplayInterface::Color_t::Color_t()+0x64>)
   126bc:	f002 fdb0 	bl	15220 <__cyg_profile_func_exit>
   126c0:	4623      	mov	r3, r4
   126c2:	4618      	mov	r0, r3
   126c4:	b003      	add	sp, #12
   126c6:	bd30      	pop	{r4, r5, pc}
   126c8:	00012665 	.word	0x00012665

000126cc <PixelDisplayInterface::Enable()>:
  /// @returns a color object with the available colors.
  virtual Color_t AvailableColors() = 0;
  /// Configure hardware peripherals and initialize external display hardware
  virtual void Initialize() = 0;
  /// Optional method to turn on display if applicable
  virtual void Enable() {}
   126cc:	b510      	push	{r4, lr}
   126ce:	b082      	sub	sp, #8
   126d0:	4674      	mov	r4, lr
   126d2:	9001      	str	r0, [sp, #4]
   126d4:	4623      	mov	r3, r4
   126d6:	4619      	mov	r1, r3
   126d8:	4805      	ldr	r0, [pc, #20]	; (126f0 <PixelDisplayInterface::Enable()+0x24>)
   126da:	f002 fd8d 	bl	151f8 <__cyg_profile_func_enter>
   126de:	4623      	mov	r3, r4
   126e0:	4619      	mov	r1, r3
   126e2:	4803      	ldr	r0, [pc, #12]	; (126f0 <PixelDisplayInterface::Enable()+0x24>)
   126e4:	f002 fd9c 	bl	15220 <__cyg_profile_func_exit>
   126e8:	bf00      	nop
   126ea:	b002      	add	sp, #8
   126ec:	bd10      	pop	{r4, pc}
   126ee:	bf00      	nop
   126f0:	000126cd 	.word	0x000126cd

000126f4 <PixelDisplayInterface::Disable()>:
  /// Optional method to turn off display and potentially put it into a low
  /// power mode
  virtual void Disable() {}
   126f4:	b510      	push	{r4, lr}
   126f6:	b082      	sub	sp, #8
   126f8:	4674      	mov	r4, lr
   126fa:	9001      	str	r0, [sp, #4]
   126fc:	4623      	mov	r3, r4
   126fe:	4619      	mov	r1, r3
   12700:	4805      	ldr	r0, [pc, #20]	; (12718 <PixelDisplayInterface::Disable()+0x24>)
   12702:	f002 fd79 	bl	151f8 <__cyg_profile_func_enter>
   12706:	4623      	mov	r3, r4
   12708:	4619      	mov	r1, r3
   1270a:	4803      	ldr	r0, [pc, #12]	; (12718 <PixelDisplayInterface::Disable()+0x24>)
   1270c:	f002 fd88 	bl	15220 <__cyg_profile_func_exit>
   12710:	bf00      	nop
   12712:	b002      	add	sp, #8
   12714:	bd10      	pop	{r4, pc}
   12716:	bf00      	nop
   12718:	000126f5 	.word	0x000126f5

0001271c <PixelDisplayInterface::Update()>:
  /// @param color the color of the pixel. May be ignored on monochrome screens.
  virtual void DrawPixel(int32_t x, int32_t y, Color_t color) = 0;
  /// Update screen to match framebuffer.
  /// Implementations of this method that do not use a framebuffer, possibly
  /// due to memory constrains, can refrain from implementing this function.
  virtual void Update() {}
   1271c:	b510      	push	{r4, lr}
   1271e:	b082      	sub	sp, #8
   12720:	4674      	mov	r4, lr
   12722:	9001      	str	r0, [sp, #4]
   12724:	4623      	mov	r3, r4
   12726:	4619      	mov	r1, r3
   12728:	4805      	ldr	r0, [pc, #20]	; (12740 <PixelDisplayInterface::Update()+0x24>)
   1272a:	f002 fd65 	bl	151f8 <__cyg_profile_func_enter>
   1272e:	4623      	mov	r3, r4
   12730:	4619      	mov	r1, r3
   12732:	4803      	ldr	r0, [pc, #12]	; (12740 <PixelDisplayInterface::Update()+0x24>)
   12734:	f002 fd74 	bl	15220 <__cyg_profile_func_exit>
   12738:	bf00      	nop
   1273a:	b002      	add	sp, #8
   1273c:	bd10      	pop	{r4, pc}
   1273e:	bf00      	nop
   12740:	0001271d 	.word	0x0001271d

00012744 <PixelDisplayInterface::PixelDisplayInterface()>:
class PixelDisplayInterface
   12744:	b530      	push	{r4, r5, lr}
   12746:	b083      	sub	sp, #12
   12748:	4675      	mov	r5, lr
   1274a:	9001      	str	r0, [sp, #4]
   1274c:	462b      	mov	r3, r5
   1274e:	4619      	mov	r1, r3
   12750:	4807      	ldr	r0, [pc, #28]	; (12770 <PixelDisplayInterface::PixelDisplayInterface()+0x2c>)
   12752:	f002 fd51 	bl	151f8 <__cyg_profile_func_enter>
   12756:	4a07      	ldr	r2, [pc, #28]	; (12774 <PixelDisplayInterface::PixelDisplayInterface()+0x30>)
   12758:	9b01      	ldr	r3, [sp, #4]
   1275a:	601a      	str	r2, [r3, #0]
   1275c:	9c01      	ldr	r4, [sp, #4]
   1275e:	462b      	mov	r3, r5
   12760:	4619      	mov	r1, r3
   12762:	4803      	ldr	r0, [pc, #12]	; (12770 <PixelDisplayInterface::PixelDisplayInterface()+0x2c>)
   12764:	f002 fd5c 	bl	15220 <__cyg_profile_func_exit>
   12768:	4623      	mov	r3, r4
   1276a:	4618      	mov	r0, r3
   1276c:	b003      	add	sp, #12
   1276e:	bd30      	pop	{r4, r5, pc}
   12770:	00012745 	.word	0x00012745
   12774:	00019d50 	.word	0x00019d50

00012778 <Ssd1306::Ssd1306()>:
  {
    kCommand = 0,
    kData    = 1
  };

  constexpr Ssd1306()
   12778:	b530      	push	{r4, r5, lr}
   1277a:	b083      	sub	sp, #12
   1277c:	4675      	mov	r5, lr
   1277e:	9001      	str	r0, [sp, #4]
   12780:	462b      	mov	r3, r5
   12782:	4619      	mov	r1, r3
   12784:	481f      	ldr	r0, [pc, #124]	; (12804 <Ssd1306::Ssd1306()+0x8c>)
   12786:	f002 fd37 	bl	151f8 <__cyg_profile_func_enter>
        cs_(&cs_gpio_),
        dc_(&dc_gpio_),
        ssp1_(Ssp::Peripheral::kSsp1),
        cs_gpio_(1, 22),
        dc_gpio_(1, 25),
        bitmap_{}
   1278a:	9b01      	ldr	r3, [sp, #4]
   1278c:	4618      	mov	r0, r3
   1278e:	f7ff ffd9 	bl	12744 <PixelDisplayInterface::PixelDisplayInterface()>
   12792:	4a1d      	ldr	r2, [pc, #116]	; (12808 <Ssd1306::Ssd1306()+0x90>)
   12794:	9b01      	ldr	r3, [sp, #4]
   12796:	601a      	str	r2, [r3, #0]
      : ssp_(&ssp1_),
   12798:	9b01      	ldr	r3, [sp, #4]
   1279a:	f103 0210 	add.w	r2, r3, #16
        bitmap_{}
   1279e:	9b01      	ldr	r3, [sp, #4]
   127a0:	605a      	str	r2, [r3, #4]
        cs_(&cs_gpio_),
   127a2:	9b01      	ldr	r3, [sp, #4]
   127a4:	f103 0240 	add.w	r2, r3, #64	; 0x40
        bitmap_{}
   127a8:	9b01      	ldr	r3, [sp, #4]
   127aa:	609a      	str	r2, [r3, #8]
        dc_(&dc_gpio_),
   127ac:	9b01      	ldr	r3, [sp, #4]
   127ae:	f103 0254 	add.w	r2, r3, #84	; 0x54
        bitmap_{}
   127b2:	9b01      	ldr	r3, [sp, #4]
   127b4:	60da      	str	r2, [r3, #12]
   127b6:	9b01      	ldr	r3, [sp, #4]
   127b8:	3310      	adds	r3, #16
   127ba:	2101      	movs	r1, #1
   127bc:	4618      	mov	r0, r3
   127be:	f7ff f9cd 	bl	11b5c <Ssp::Ssp(Ssp::Peripheral)>
   127c2:	9b01      	ldr	r3, [sp, #4]
   127c4:	3340      	adds	r3, #64	; 0x40
   127c6:	2216      	movs	r2, #22
   127c8:	2101      	movs	r1, #1
   127ca:	4618      	mov	r0, r3
   127cc:	f7fe f9d6 	bl	10b7c <Gpio::Gpio(unsigned char, unsigned char)>
   127d0:	9b01      	ldr	r3, [sp, #4]
   127d2:	3354      	adds	r3, #84	; 0x54
   127d4:	2219      	movs	r2, #25
   127d6:	2101      	movs	r1, #1
   127d8:	4618      	mov	r0, r3
   127da:	f7fe f9cf 	bl	10b7c <Gpio::Gpio(unsigned char, unsigned char)>
   127de:	9b01      	ldr	r3, [sp, #4]
   127e0:	3368      	adds	r3, #104	; 0x68
   127e2:	f240 62c1 	movw	r2, #1729	; 0x6c1
   127e6:	2100      	movs	r1, #0
   127e8:	4618      	mov	r0, r3
   127ea:	f006 fe2e 	bl	1944a <memset>
  {
  }
   127ee:	9c01      	ldr	r4, [sp, #4]
   127f0:	462b      	mov	r3, r5
   127f2:	4619      	mov	r1, r3
   127f4:	4803      	ldr	r0, [pc, #12]	; (12804 <Ssd1306::Ssd1306()+0x8c>)
   127f6:	f002 fd13 	bl	15220 <__cyg_profile_func_exit>
   127fa:	4623      	mov	r3, r4
   127fc:	4618      	mov	r0, r3
   127fe:	b003      	add	sp, #12
   12800:	bd30      	pop	{r4, r5, pc}
   12802:	bf00      	nop
   12804:	00012779 	.word	0x00012779
   12808:	00019d24 	.word	0x00019d24

0001280c <Ssd1306::GetWidth()>:
        dc_gpio_(1, 25),
        bitmap_{}
  {
  }

  size_t GetWidth() final override
   1280c:	b530      	push	{r4, r5, lr}
   1280e:	b083      	sub	sp, #12
   12810:	4675      	mov	r5, lr
   12812:	9001      	str	r0, [sp, #4]
   12814:	462b      	mov	r3, r5
   12816:	4619      	mov	r1, r3
   12818:	4806      	ldr	r0, [pc, #24]	; (12834 <Ssd1306::GetWidth()+0x28>)
   1281a:	f002 fced 	bl	151f8 <__cyg_profile_func_enter>
  {
    return kWidth;
   1281e:	2480      	movs	r4, #128	; 0x80
   12820:	462b      	mov	r3, r5
   12822:	4619      	mov	r1, r3
   12824:	4803      	ldr	r0, [pc, #12]	; (12834 <Ssd1306::GetWidth()+0x28>)
   12826:	f002 fcfb 	bl	15220 <__cyg_profile_func_exit>
   1282a:	4623      	mov	r3, r4
  }
   1282c:	4618      	mov	r0, r3
   1282e:	b003      	add	sp, #12
   12830:	bd30      	pop	{r4, r5, pc}
   12832:	bf00      	nop
   12834:	0001280d 	.word	0x0001280d

00012838 <Ssd1306::GetHeight()>:
  size_t GetHeight() final override
   12838:	b530      	push	{r4, r5, lr}
   1283a:	b083      	sub	sp, #12
   1283c:	4675      	mov	r5, lr
   1283e:	9001      	str	r0, [sp, #4]
   12840:	462b      	mov	r3, r5
   12842:	4619      	mov	r1, r3
   12844:	4806      	ldr	r0, [pc, #24]	; (12860 <Ssd1306::GetHeight()+0x28>)
   12846:	f002 fcd7 	bl	151f8 <__cyg_profile_func_enter>
  {
    return kHeight;
   1284a:	2440      	movs	r4, #64	; 0x40
   1284c:	462b      	mov	r3, r5
   1284e:	4619      	mov	r1, r3
   12850:	4803      	ldr	r0, [pc, #12]	; (12860 <Ssd1306::GetHeight()+0x28>)
   12852:	f002 fce5 	bl	15220 <__cyg_profile_func_exit>
   12856:	4623      	mov	r3, r4
  }
   12858:	4618      	mov	r0, r3
   1285a:	b003      	add	sp, #12
   1285c:	bd30      	pop	{r4, r5, pc}
   1285e:	bf00      	nop
   12860:	00012839 	.word	0x00012839

00012864 <Ssd1306::AvailableColors()>:
  Color_t AvailableColors() final override
   12864:	b510      	push	{r4, lr}
   12866:	b088      	sub	sp, #32
   12868:	4674      	mov	r4, lr
   1286a:	9005      	str	r0, [sp, #20]
   1286c:	4623      	mov	r3, r4
   1286e:	4619      	mov	r1, r3
   12870:	4815      	ldr	r0, [pc, #84]	; (128c8 <Ssd1306::AvailableColors()+0x64>)
   12872:	f002 fcc1 	bl	151f8 <__cyg_profile_func_enter>
  {
    return Color_t(/* Red        = */ 1,
   12876:	a807      	add	r0, sp, #28
   12878:	2301      	movs	r3, #1
   1287a:	9302      	str	r3, [sp, #8]
   1287c:	2301      	movs	r3, #1
   1287e:	9301      	str	r3, [sp, #4]
   12880:	2301      	movs	r3, #1
   12882:	9300      	str	r3, [sp, #0]
   12884:	2301      	movs	r3, #1
   12886:	2201      	movs	r2, #1
   12888:	2101      	movs	r1, #1
   1288a:	f7ff fea1 	bl	125d0 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>
                   /* Green      = */ 1,
                   /* Blue       = */ 1,
                   /* Alpha      = */ 1,
                   /* Color Bits = */ 1,
                   /* Monochrome = */ true);
   1288e:	ab06      	add	r3, sp, #24
   12890:	aa07      	add	r2, sp, #28
   12892:	6812      	ldr	r2, [r2, #0]
   12894:	4611      	mov	r1, r2
   12896:	8019      	strh	r1, [r3, #0]
   12898:	3302      	adds	r3, #2
   1289a:	0c12      	lsrs	r2, r2, #16
   1289c:	701a      	strb	r2, [r3, #0]
   1289e:	4623      	mov	r3, r4
   128a0:	4619      	mov	r1, r3
   128a2:	4809      	ldr	r0, [pc, #36]	; (128c8 <Ssd1306::AvailableColors()+0x64>)
   128a4:	f002 fcbc 	bl	15220 <__cyg_profile_func_exit>
   128a8:	2300      	movs	r3, #0
   128aa:	f89d 2018 	ldrb.w	r2, [sp, #24]
   128ae:	f362 0307 	bfi	r3, r2, #0, #8
   128b2:	f89d 2019 	ldrb.w	r2, [sp, #25]
   128b6:	f362 230f 	bfi	r3, r2, #8, #8
   128ba:	f89d 201a 	ldrb.w	r2, [sp, #26]
   128be:	f362 4317 	bfi	r3, r2, #16, #8
  }
   128c2:	4618      	mov	r0, r3
   128c4:	b008      	add	sp, #32
   128c6:	bd10      	pop	{r4, pc}
   128c8:	00012865 	.word	0x00012865

000128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>:

  void Write(uint32_t data, Transaction transaction, size_t size = 1)
   128cc:	b510      	push	{r4, lr}
   128ce:	b086      	sub	sp, #24
   128d0:	4674      	mov	r4, lr
   128d2:	9003      	str	r0, [sp, #12]
   128d4:	9102      	str	r1, [sp, #8]
   128d6:	9201      	str	r2, [sp, #4]
   128d8:	9300      	str	r3, [sp, #0]
   128da:	4623      	mov	r3, r4
   128dc:	4619      	mov	r1, r3
   128de:	481e      	ldr	r0, [pc, #120]	; (12958 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x8c>)
   128e0:	f002 fc8a 	bl	151f8 <__cyg_profile_func_enter>
  {
    dc_->Set(static_cast<Gpio::State>(transaction));
   128e4:	9b03      	ldr	r3, [sp, #12]
   128e6:	68db      	ldr	r3, [r3, #12]
   128e8:	9a01      	ldr	r2, [sp, #4]
   128ea:	b2d2      	uxtb	r2, r2
   128ec:	4611      	mov	r1, r2
   128ee:	4618      	mov	r0, r3
   128f0:	f7fe fa84 	bl	10dfc <Gpio::Set(GpioInterface::State)>
    cs_->SetLow();
   128f4:	9b03      	ldr	r3, [sp, #12]
   128f6:	689b      	ldr	r3, [r3, #8]
   128f8:	4618      	mov	r0, r3
   128fa:	f7fe fa4d 	bl	10d98 <Gpio::SetLow()>
    for (size_t i = 0; i < size; i++)
   128fe:	2300      	movs	r3, #0
   12900:	9305      	str	r3, [sp, #20]
   12902:	9a05      	ldr	r2, [sp, #20]
   12904:	9b00      	ldr	r3, [sp, #0]
   12906:	429a      	cmp	r2, r3
   12908:	d218      	bcs.n	1293c <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x70>
    {
      uint8_t send = static_cast<uint8_t>(data >> (((size - 1) - i) * 8));
   1290a:	9a00      	ldr	r2, [sp, #0]
   1290c:	9b05      	ldr	r3, [sp, #20]
   1290e:	1ad3      	subs	r3, r2, r3
   12910:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   12914:	3b01      	subs	r3, #1
   12916:	00db      	lsls	r3, r3, #3
   12918:	9a02      	ldr	r2, [sp, #8]
   1291a:	fa22 f303 	lsr.w	r3, r2, r3
   1291e:	f88d 3013 	strb.w	r3, [sp, #19]
      if (transaction == Transaction::kCommand)
      {
        LOG_DEBUG("send = 0x%X", send);
      }
      ssp_->Transfer(send);
   12922:	9b03      	ldr	r3, [sp, #12]
   12924:	685b      	ldr	r3, [r3, #4]
   12926:	f89d 2013 	ldrb.w	r2, [sp, #19]
   1292a:	b292      	uxth	r2, r2
   1292c:	4611      	mov	r1, r2
   1292e:	4618      	mov	r0, r3
   12930:	f7ff fa34 	bl	11d9c <Ssp::Transfer(unsigned short)>
    for (size_t i = 0; i < size; i++)
   12934:	9b05      	ldr	r3, [sp, #20]
   12936:	3301      	adds	r3, #1
   12938:	9305      	str	r3, [sp, #20]
   1293a:	e7e2      	b.n	12902 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x36>
    }
    cs_->SetHigh();
   1293c:	9b03      	ldr	r3, [sp, #12]
   1293e:	689b      	ldr	r3, [r3, #8]
   12940:	4618      	mov	r0, r3
   12942:	f7fe f9f7 	bl	10d34 <Gpio::SetHigh()>
   12946:	4623      	mov	r3, r4
   12948:	4619      	mov	r1, r3
   1294a:	4803      	ldr	r0, [pc, #12]	; (12958 <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)+0x8c>)
   1294c:	f002 fc68 	bl	15220 <__cyg_profile_func_exit>
  }
   12950:	bf00      	nop
   12952:	b006      	add	sp, #24
   12954:	bd10      	pop	{r4, pc}
   12956:	bf00      	nop
   12958:	000128cd 	.word	0x000128cd

0001295c <Ssd1306::InitializationPanel()>:

  void InitializationPanel()
   1295c:	b510      	push	{r4, lr}
   1295e:	b082      	sub	sp, #8
   12960:	4674      	mov	r4, lr
   12962:	9001      	str	r0, [sp, #4]
   12964:	4623      	mov	r3, r4
   12966:	4619      	mov	r1, r3
   12968:	4837      	ldr	r0, [pc, #220]	; (12a48 <Ssd1306::InitializationPanel()+0xec>)
   1296a:	f002 fc45 	bl	151f8 <__cyg_profile_func_enter>
  {
    // This sequence of commands was found in:
    //   datasheets/OLED-display/ER-OLED0.96-1_Series_Datasheet.pdf, page 15

    // turn off oled panel
    Write(0xAE, Transaction::kCommand);
   1296e:	2301      	movs	r3, #1
   12970:	2200      	movs	r2, #0
   12972:	21ae      	movs	r1, #174	; 0xae
   12974:	9801      	ldr	r0, [sp, #4]
   12976:	f7ff ffa9 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set display clock divide ratio/oscillator frequency
    // set divide ratio
    Write(0xD5'80, Transaction::kCommand, 2);
   1297a:	2302      	movs	r3, #2
   1297c:	2200      	movs	r2, #0
   1297e:	f24d 5180 	movw	r1, #54656	; 0xd580
   12982:	9801      	ldr	r0, [sp, #4]
   12984:	f7ff ffa2 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set multiplex ratio(1 to 64)
    // 1/64 duty
    Write(0xA8'3F, Transaction::kCommand, 2);
   12988:	2302      	movs	r3, #2
   1298a:	2200      	movs	r2, #0
   1298c:	f64a 013f 	movw	r1, #43071	; 0xa83f
   12990:	9801      	ldr	r0, [sp, #4]
   12992:	f7ff ff9b 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set display offset = not offset
    Write(0xD3'00, Transaction::kCommand, 2);
   12996:	2302      	movs	r3, #2
   12998:	2200      	movs	r2, #0
   1299a:	f44f 4153 	mov.w	r1, #54016	; 0xd300
   1299e:	9801      	ldr	r0, [sp, #4]
   129a0:	f7ff ff94 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set display start line
    Write(0x40, Transaction::kCommand);
   129a4:	2301      	movs	r3, #1
   129a6:	2200      	movs	r2, #0
   129a8:	2140      	movs	r1, #64	; 0x40
   129aa:	9801      	ldr	r0, [sp, #4]
   129ac:	f7ff ff8e 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Disable Charge Pump
    Write(0x8D'14, Transaction::kCommand, 2);
   129b0:	2302      	movs	r3, #2
   129b2:	2200      	movs	r2, #0
   129b4:	f648 5114 	movw	r1, #36116	; 0x8d14
   129b8:	9801      	ldr	r0, [sp, #4]
   129ba:	f7ff ff87 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set segment re-map 128 to 0
    Write(0xA1, Transaction::kCommand);
   129be:	2301      	movs	r3, #1
   129c0:	2200      	movs	r2, #0
   129c2:	21a1      	movs	r1, #161	; 0xa1
   129c4:	9801      	ldr	r0, [sp, #4]
   129c6:	f7ff ff81 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set COM Output Scan Direction 64 to 0
    Write(0xC8, Transaction::kCommand);
   129ca:	2301      	movs	r3, #1
   129cc:	2200      	movs	r2, #0
   129ce:	21c8      	movs	r1, #200	; 0xc8
   129d0:	9801      	ldr	r0, [sp, #4]
   129d2:	f7ff ff7b 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set com pins hardware configuration
    Write(0xDA'12, Transaction::kCommand, 2);
   129d6:	2302      	movs	r3, #2
   129d8:	2200      	movs	r2, #0
   129da:	f64d 2112 	movw	r1, #55826	; 0xda12
   129de:	9801      	ldr	r0, [sp, #4]
   129e0:	f7ff ff74 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // set contrast control register
    Write(0x81'CF, Transaction::kCommand, 2);
   129e4:	2302      	movs	r3, #2
   129e6:	2200      	movs	r2, #0
   129e8:	f248 11cf 	movw	r1, #33231	; 0x81cf
   129ec:	9801      	ldr	r0, [sp, #4]
   129ee:	f7ff ff6d 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set pre-charge period
    Write(0xD9'F1, Transaction::kCommand, 2);
   129f2:	2302      	movs	r3, #2
   129f4:	2200      	movs	r2, #0
   129f6:	f64d 11f1 	movw	r1, #55793	; 0xd9f1
   129fa:	9801      	ldr	r0, [sp, #4]
   129fc:	f7ff ff66 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set Vcomh
    Write(0xDB'40, Transaction::kCommand, 2);
   12a00:	2302      	movs	r3, #2
   12a02:	2200      	movs	r2, #0
   12a04:	f64d 3140 	movw	r1, #56128	; 0xdb40
   12a08:	9801      	ldr	r0, [sp, #4]
   12a0a:	f7ff ff5f 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    SetHorizontalAddressMode();
   12a0e:	9801      	ldr	r0, [sp, #4]
   12a10:	f000 f85e 	bl	12ad0 <Ssd1306::SetHorizontalAddressMode()>

    // Enable entire display
    Write(0xA4, Transaction::kCommand);
   12a14:	2301      	movs	r3, #1
   12a16:	2200      	movs	r2, #0
   12a18:	21a4      	movs	r1, #164	; 0xa4
   12a1a:	9801      	ldr	r0, [sp, #4]
   12a1c:	f7ff ff56 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set display to normal colors
    Write(0xA6, Transaction::kCommand);
   12a20:	2301      	movs	r3, #1
   12a22:	2200      	movs	r2, #0
   12a24:	21a6      	movs	r1, #166	; 0xa6
   12a26:	9801      	ldr	r0, [sp, #4]
   12a28:	f7ff ff50 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>

    // Set Display On
    Write(0xAF, Transaction::kCommand);
   12a2c:	2301      	movs	r3, #1
   12a2e:	2200      	movs	r2, #0
   12a30:	21af      	movs	r1, #175	; 0xaf
   12a32:	9801      	ldr	r0, [sp, #4]
   12a34:	f7ff ff4a 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
   12a38:	4623      	mov	r3, r4
   12a3a:	4619      	mov	r1, r3
   12a3c:	4802      	ldr	r0, [pc, #8]	; (12a48 <Ssd1306::InitializationPanel()+0xec>)
   12a3e:	f002 fbef 	bl	15220 <__cyg_profile_func_exit>
  }
   12a42:	bf00      	nop
   12a44:	b002      	add	sp, #8
   12a46:	bd10      	pop	{r4, pc}
   12a48:	0001295d 	.word	0x0001295d

00012a4c <Ssd1306::Initialize()>:

  void Initialize() final override
   12a4c:	b510      	push	{r4, lr}
   12a4e:	b084      	sub	sp, #16
   12a50:	4674      	mov	r4, lr
   12a52:	9003      	str	r0, [sp, #12]
   12a54:	4623      	mov	r3, r4
   12a56:	4619      	mov	r1, r3
   12a58:	481c      	ldr	r0, [pc, #112]	; (12acc <Ssd1306::Initialize()+0x80>)
   12a5a:	f002 fbcd 	bl	151f8 <__cyg_profile_func_enter>
  {
    cs_->SetAsOutput();
   12a5e:	9b03      	ldr	r3, [sp, #12]
   12a60:	689b      	ldr	r3, [r3, #8]
   12a62:	4618      	mov	r0, r3
   12a64:	f7fe f906 	bl	10c74 <Gpio::SetAsOutput()>
    dc_->SetAsOutput();
   12a68:	9b03      	ldr	r3, [sp, #12]
   12a6a:	68db      	ldr	r3, [r3, #12]
   12a6c:	4618      	mov	r0, r3
   12a6e:	f7fe f901 	bl	10c74 <Gpio::SetAsOutput()>
    cs_->SetHigh();
   12a72:	9b03      	ldr	r3, [sp, #12]
   12a74:	689b      	ldr	r3, [r3, #8]
   12a76:	4618      	mov	r0, r3
   12a78:	f7fe f95c 	bl	10d34 <Gpio::SetHigh()>
    dc_->SetHigh();
   12a7c:	9b03      	ldr	r3, [sp, #12]
   12a7e:	68db      	ldr	r3, [r3, #12]
   12a80:	4618      	mov	r0, r3
   12a82:	f7fe f957 	bl	10d34 <Gpio::SetHigh()>

    ssp_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster, Ssp::FrameMode::kSpi,
   12a86:	9b03      	ldr	r3, [sp, #12]
   12a88:	6858      	ldr	r0, [r3, #4]
   12a8a:	2307      	movs	r3, #7
   12a8c:	2200      	movs	r2, #0
   12a8e:	2100      	movs	r1, #0
   12a90:	f7ff fa30 	bl	11ef4 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
                            Ssp::DataSize::kEight);
    // Set speed to 1Mhz by dividing by 1 * ClockFrequencyInMHz.
    ssp_->SetClock(false, false, 1, config::kSystemClockRateMhz/3);
   12a94:	9b03      	ldr	r3, [sp, #12]
   12a96:	6858      	ldr	r0, [r3, #4]
   12a98:	2310      	movs	r3, #16
   12a9a:	9300      	str	r3, [sp, #0]
   12a9c:	2301      	movs	r3, #1
   12a9e:	2200      	movs	r2, #0
   12aa0:	2100      	movs	r1, #0
   12aa2:	f7ff fbdd 	bl	12260 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
    ssp_->Initialize();
   12aa6:	9b03      	ldr	r3, [sp, #12]
   12aa8:	685b      	ldr	r3, [r3, #4]
   12aaa:	4618      	mov	r0, r3
   12aac:	f7ff f8c8 	bl	11c40 <Ssp::Initialize()>

    Clear();
   12ab0:	9803      	ldr	r0, [sp, #12]
   12ab2:	f000 f837 	bl	12b24 <Ssd1306::Clear()>
    InitializationPanel();
   12ab6:	9803      	ldr	r0, [sp, #12]
   12ab8:	f7ff ff50 	bl	1295c <Ssd1306::InitializationPanel()>
   12abc:	4623      	mov	r3, r4
   12abe:	4619      	mov	r1, r3
   12ac0:	4802      	ldr	r0, [pc, #8]	; (12acc <Ssd1306::Initialize()+0x80>)
   12ac2:	f002 fbad 	bl	15220 <__cyg_profile_func_exit>
  }
   12ac6:	bf00      	nop
   12ac8:	b004      	add	sp, #16
   12aca:	bd10      	pop	{r4, pc}
   12acc:	00012a4d 	.word	0x00012a4d

00012ad0 <Ssd1306::SetHorizontalAddressMode()>:

  void SetHorizontalAddressMode()
   12ad0:	b510      	push	{r4, lr}
   12ad2:	b082      	sub	sp, #8
   12ad4:	4674      	mov	r4, lr
   12ad6:	9001      	str	r0, [sp, #4]
   12ad8:	4623      	mov	r3, r4
   12ada:	4619      	mov	r1, r3
   12adc:	480e      	ldr	r0, [pc, #56]	; (12b18 <Ssd1306::SetHorizontalAddressMode()+0x48>)
   12ade:	f002 fb8b 	bl	151f8 <__cyg_profile_func_enter>
  {
    // Set Addressing mode
    // Addressing mode = Horizontal Mode (0b00)
    Write(0x20'00, Transaction::kCommand, 2);
   12ae2:	2302      	movs	r3, #2
   12ae4:	2200      	movs	r2, #0
   12ae6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   12aea:	9801      	ldr	r0, [sp, #4]
   12aec:	f7ff feee 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
    // Set Column Addresses
    // Set Column Address start = Column 0
    // Set Column Address start = Column 127
    Write(0x21'00'7F, Transaction::kCommand, 3);
   12af0:	2303      	movs	r3, #3
   12af2:	2200      	movs	r2, #0
   12af4:	4909      	ldr	r1, [pc, #36]	; (12b1c <Ssd1306::SetHorizontalAddressMode()+0x4c>)
   12af6:	9801      	ldr	r0, [sp, #4]
   12af8:	f7ff fee8 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
    // Set Page Addresses
    // Set Page Address start = Page 0
    // Set Page Address start = Page 7
    Write(0x22'00'07, Transaction::kCommand, 3);
   12afc:	2303      	movs	r3, #3
   12afe:	2200      	movs	r2, #0
   12b00:	4907      	ldr	r1, [pc, #28]	; (12b20 <Ssd1306::SetHorizontalAddressMode()+0x50>)
   12b02:	9801      	ldr	r0, [sp, #4]
   12b04:	f7ff fee2 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
   12b08:	4623      	mov	r3, r4
   12b0a:	4619      	mov	r1, r3
   12b0c:	4802      	ldr	r0, [pc, #8]	; (12b18 <Ssd1306::SetHorizontalAddressMode()+0x48>)
   12b0e:	f002 fb87 	bl	15220 <__cyg_profile_func_exit>
  }
   12b12:	bf00      	nop
   12b14:	b002      	add	sp, #8
   12b16:	bd10      	pop	{r4, pc}
   12b18:	00012ad1 	.word	0x00012ad1
   12b1c:	0021007f 	.word	0x0021007f
   12b20:	00220007 	.word	0x00220007

00012b24 <Ssd1306::Clear()>:
  /// Clears the internal bitmap_ to zero (or a user defined clear_value)
  void Clear() final override
   12b24:	b510      	push	{r4, lr}
   12b26:	b082      	sub	sp, #8
   12b28:	4674      	mov	r4, lr
   12b2a:	9001      	str	r0, [sp, #4]
   12b2c:	4623      	mov	r3, r4
   12b2e:	4619      	mov	r1, r3
   12b30:	4809      	ldr	r0, [pc, #36]	; (12b58 <Ssd1306::Clear()+0x34>)
   12b32:	f002 fb61 	bl	151f8 <__cyg_profile_func_enter>
  {
    memset(bitmap_, 0x00, sizeof(bitmap_));
   12b36:	9b01      	ldr	r3, [sp, #4]
   12b38:	3368      	adds	r3, #104	; 0x68
   12b3a:	f240 62c1 	movw	r2, #1729	; 0x6c1
   12b3e:	2100      	movs	r1, #0
   12b40:	4618      	mov	r0, r3
   12b42:	f006 fc82 	bl	1944a <memset>
   12b46:	4623      	mov	r3, r4
   12b48:	4619      	mov	r1, r3
   12b4a:	4803      	ldr	r0, [pc, #12]	; (12b58 <Ssd1306::Clear()+0x34>)
   12b4c:	f002 fb68 	bl	15220 <__cyg_profile_func_exit>
  }
   12b50:	bf00      	nop
   12b52:	b002      	add	sp, #8
   12b54:	bd10      	pop	{r4, pc}
   12b56:	bf00      	nop
   12b58:	00012b25 	.word	0x00012b25

00012b5c <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)>:
  void Fill()
  {
    memset(bitmap_, 0xFF, sizeof(bitmap_));
  }
  void DrawPixel(int32_t x, int32_t y, Color_t color) final override
   12b5c:	b510      	push	{r4, lr}
   12b5e:	b08c      	sub	sp, #48	; 0x30
   12b60:	4674      	mov	r4, lr
   12b62:	9003      	str	r0, [sp, #12]
   12b64:	9102      	str	r1, [sp, #8]
   12b66:	9201      	str	r2, [sp, #4]
   12b68:	9300      	str	r3, [sp, #0]
   12b6a:	4623      	mov	r3, r4
   12b6c:	4619      	mov	r1, r3
   12b6e:	481f      	ldr	r0, [pc, #124]	; (12bec <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)+0x90>)
   12b70:	f002 fb42 	bl	151f8 <__cyg_profile_func_enter>
  {
    // The 3 least significant bits hold the bit position within the byte
    uint32_t bit_position = y & 0b111;
   12b74:	9b01      	ldr	r3, [sp, #4]
   12b76:	f003 0307 	and.w	r3, r3, #7
   12b7a:	930b      	str	r3, [sp, #44]	; 0x2c
    // Each byte makes up a vertical column.
    // Shifting by 3, which also divides by 8 (the 8-bits of a column), will
    // be the row that we need to edit.
    uint32_t row = y >> 3;
   12b7c:	9b01      	ldr	r3, [sp, #4]
   12b7e:	10db      	asrs	r3, r3, #3
   12b80:	930a      	str	r3, [sp, #40]	; 0x28
    // Mask to clear the bit
    uint32_t clear_mask = ~(1 << bit_position);
   12b82:	2201      	movs	r2, #1
   12b84:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12b86:	fa02 f303 	lsl.w	r3, r2, r3
   12b8a:	43db      	mvns	r3, r3
   12b8c:	9309      	str	r3, [sp, #36]	; 0x24
    // Mask to set the bit, if color.alpha != 0
    bool pixel_is_on  = (color.alpha != 0);
   12b8e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   12b92:	2b00      	cmp	r3, #0
   12b94:	bf14      	ite	ne
   12b96:	2301      	movne	r3, #1
   12b98:	2300      	moveq	r3, #0
   12b9a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint32_t set_mask = pixel_is_on << bit_position;
   12b9e:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
   12ba2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12ba4:	fa02 f303 	lsl.w	r3, r2, r3
   12ba8:	9307      	str	r3, [sp, #28]
    // Address of the pixel column to edit
    uint8_t * pixel_column = &(bitmap_[row][x]);
   12baa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   12bac:	4613      	mov	r3, r2
   12bae:	015b      	lsls	r3, r3, #5
   12bb0:	4413      	add	r3, r2
   12bb2:	009b      	lsls	r3, r3, #2
   12bb4:	4413      	add	r3, r2
   12bb6:	9a02      	ldr	r2, [sp, #8]
   12bb8:	4413      	add	r3, r2
   12bba:	3368      	adds	r3, #104	; 0x68
   12bbc:	9a03      	ldr	r2, [sp, #12]
   12bbe:	4413      	add	r3, r2
   12bc0:	9306      	str	r3, [sp, #24]
    // Read pixel column and update the pixel
    uint32_t result = (*pixel_column & clear_mask) | set_mask;
   12bc2:	9b06      	ldr	r3, [sp, #24]
   12bc4:	781b      	ldrb	r3, [r3, #0]
   12bc6:	461a      	mov	r2, r3
   12bc8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12bca:	4013      	ands	r3, r2
   12bcc:	9a07      	ldr	r2, [sp, #28]
   12bce:	4313      	orrs	r3, r2
   12bd0:	9305      	str	r3, [sp, #20]
    // Update pixel with the result of this operation
    *pixel_column = static_cast<uint8_t>(result);
   12bd2:	9b05      	ldr	r3, [sp, #20]
   12bd4:	b2da      	uxtb	r2, r3
   12bd6:	9b06      	ldr	r3, [sp, #24]
   12bd8:	701a      	strb	r2, [r3, #0]
   12bda:	4623      	mov	r3, r4
   12bdc:	4619      	mov	r1, r3
   12bde:	4803      	ldr	r0, [pc, #12]	; (12bec <Ssd1306::DrawPixel(long, long, PixelDisplayInterface::Color_t)+0x90>)
   12be0:	f002 fb1e 	bl	15220 <__cyg_profile_func_exit>
  }
   12be4:	bf00      	nop
   12be6:	b00c      	add	sp, #48	; 0x30
   12be8:	bd10      	pop	{r4, pc}
   12bea:	bf00      	nop
   12bec:	00012b5d 	.word	0x00012b5d

00012bf0 <Ssd1306::Update()>:
  /// Writes internal bitmap_ to the screen
  void Update() final override
   12bf0:	b510      	push	{r4, lr}
   12bf2:	b084      	sub	sp, #16
   12bf4:	4674      	mov	r4, lr
   12bf6:	9001      	str	r0, [sp, #4]
   12bf8:	4623      	mov	r3, r4
   12bfa:	4619      	mov	r1, r3
   12bfc:	4818      	ldr	r0, [pc, #96]	; (12c60 <Ssd1306::Update()+0x70>)
   12bfe:	f002 fafb 	bl	151f8 <__cyg_profile_func_enter>
  {
    SetHorizontalAddressMode();
   12c02:	9801      	ldr	r0, [sp, #4]
   12c04:	f7ff ff64 	bl	12ad0 <Ssd1306::SetHorizontalAddressMode()>
    for (size_t row = 0; row < kRows; row++)
   12c08:	2300      	movs	r3, #0
   12c0a:	9303      	str	r3, [sp, #12]
   12c0c:	9b03      	ldr	r3, [sp, #12]
   12c0e:	2b07      	cmp	r3, #7
   12c10:	d81e      	bhi.n	12c50 <Ssd1306::Update()+0x60>
    {
      for (size_t column = 0; column < kColumns; column++)
   12c12:	2300      	movs	r3, #0
   12c14:	9302      	str	r3, [sp, #8]
   12c16:	9b02      	ldr	r3, [sp, #8]
   12c18:	2b7f      	cmp	r3, #127	; 0x7f
   12c1a:	d815      	bhi.n	12c48 <Ssd1306::Update()+0x58>
      {
        Write(bitmap_[row][column], Transaction::kData);
   12c1c:	9901      	ldr	r1, [sp, #4]
   12c1e:	9a03      	ldr	r2, [sp, #12]
   12c20:	4613      	mov	r3, r2
   12c22:	015b      	lsls	r3, r3, #5
   12c24:	4413      	add	r3, r2
   12c26:	009b      	lsls	r3, r3, #2
   12c28:	4413      	add	r3, r2
   12c2a:	18ca      	adds	r2, r1, r3
   12c2c:	9b02      	ldr	r3, [sp, #8]
   12c2e:	4413      	add	r3, r2
   12c30:	3368      	adds	r3, #104	; 0x68
   12c32:	781b      	ldrb	r3, [r3, #0]
   12c34:	4619      	mov	r1, r3
   12c36:	2301      	movs	r3, #1
   12c38:	2201      	movs	r2, #1
   12c3a:	9801      	ldr	r0, [sp, #4]
   12c3c:	f7ff fe46 	bl	128cc <Ssd1306::Write(unsigned long, Ssd1306::Transaction, unsigned int)>
      for (size_t column = 0; column < kColumns; column++)
   12c40:	9b02      	ldr	r3, [sp, #8]
   12c42:	3301      	adds	r3, #1
   12c44:	9302      	str	r3, [sp, #8]
   12c46:	e7e6      	b.n	12c16 <Ssd1306::Update()+0x26>
    for (size_t row = 0; row < kRows; row++)
   12c48:	9b03      	ldr	r3, [sp, #12]
   12c4a:	3301      	adds	r3, #1
   12c4c:	9303      	str	r3, [sp, #12]
   12c4e:	e7dd      	b.n	12c0c <Ssd1306::Update()+0x1c>
   12c50:	4623      	mov	r3, r4
   12c52:	4619      	mov	r1, r3
   12c54:	4802      	ldr	r0, [pc, #8]	; (12c60 <Ssd1306::Update()+0x70>)
   12c56:	f002 fae3 	bl	15220 <__cyg_profile_func_exit>
      }
    }
  }
   12c5a:	bf00      	nop
   12c5c:	b004      	add	sp, #16
   12c5e:	bd10      	pop	{r4, pc}
   12c60:	00012bf1 	.word	0x00012bf1

00012c64 <Graphics::Graphics(PixelDisplayInterface*)>:
#include "utility/log.hpp"

class Graphics
{
 public:
  explicit Graphics(PixelDisplayInterface * display)
   12c64:	b530      	push	{r4, r5, lr}
   12c66:	b083      	sub	sp, #12
   12c68:	4675      	mov	r5, lr
   12c6a:	9001      	str	r0, [sp, #4]
   12c6c:	9100      	str	r1, [sp, #0]
   12c6e:	462b      	mov	r3, r5
   12c70:	4619      	mov	r1, r3
   12c72:	481e      	ldr	r0, [pc, #120]	; (12cec <Graphics::Graphics(PixelDisplayInterface*)+0x88>)
   12c74:	f002 fac0 	bl	151f8 <__cyg_profile_func_enter>
      : display_(display), color_(), width_(0), height_(0)
   12c78:	9b01      	ldr	r3, [sp, #4]
   12c7a:	9a00      	ldr	r2, [sp, #0]
   12c7c:	601a      	str	r2, [r3, #0]
   12c7e:	9b01      	ldr	r3, [sp, #4]
   12c80:	3304      	adds	r3, #4
   12c82:	4618      	mov	r0, r3
   12c84:	f7ff fcee 	bl	12664 <PixelDisplayInterface::Color_t::Color_t()>
   12c88:	9b01      	ldr	r3, [sp, #4]
   12c8a:	2200      	movs	r2, #0
   12c8c:	609a      	str	r2, [r3, #8]
   12c8e:	9b01      	ldr	r3, [sp, #4]
   12c90:	2200      	movs	r2, #0
   12c92:	60da      	str	r2, [r3, #12]
  {
    width_  = display->GetWidth();
   12c94:	9b00      	ldr	r3, [sp, #0]
   12c96:	681b      	ldr	r3, [r3, #0]
   12c98:	681b      	ldr	r3, [r3, #0]
   12c9a:	9800      	ldr	r0, [sp, #0]
   12c9c:	4798      	blx	r3
   12c9e:	4602      	mov	r2, r0
   12ca0:	9b01      	ldr	r3, [sp, #4]
   12ca2:	609a      	str	r2, [r3, #8]
    height_ = display->GetHeight();
   12ca4:	9b00      	ldr	r3, [sp, #0]
   12ca6:	681b      	ldr	r3, [r3, #0]
   12ca8:	3304      	adds	r3, #4
   12caa:	681b      	ldr	r3, [r3, #0]
   12cac:	9800      	ldr	r0, [sp, #0]
   12cae:	4798      	blx	r3
   12cb0:	4602      	mov	r2, r0
   12cb2:	9b01      	ldr	r3, [sp, #4]
   12cb4:	60da      	str	r2, [r3, #12]
    color_  = display->AvailableColors();
   12cb6:	9b00      	ldr	r3, [sp, #0]
   12cb8:	681b      	ldr	r3, [r3, #0]
   12cba:	3308      	adds	r3, #8
   12cbc:	681b      	ldr	r3, [r3, #0]
   12cbe:	9c01      	ldr	r4, [sp, #4]
   12cc0:	9800      	ldr	r0, [sp, #0]
   12cc2:	4798      	blx	r3
   12cc4:	4603      	mov	r3, r0
   12cc6:	461a      	mov	r2, r3
   12cc8:	7122      	strb	r2, [r4, #4]
   12cca:	f3c3 2207 	ubfx	r2, r3, #8, #8
   12cce:	7162      	strb	r2, [r4, #5]
   12cd0:	f3c3 4307 	ubfx	r3, r3, #16, #8
   12cd4:	71a3      	strb	r3, [r4, #6]
  }
   12cd6:	9c01      	ldr	r4, [sp, #4]
   12cd8:	462b      	mov	r3, r5
   12cda:	4619      	mov	r1, r3
   12cdc:	4803      	ldr	r0, [pc, #12]	; (12cec <Graphics::Graphics(PixelDisplayInterface*)+0x88>)
   12cde:	f002 fa9f 	bl	15220 <__cyg_profile_func_exit>
   12ce2:	4623      	mov	r3, r4
   12ce4:	4618      	mov	r0, r3
   12ce6:	b003      	add	sp, #12
   12ce8:	bd30      	pop	{r4, r5, pc}
   12cea:	bf00      	nop
   12cec:	00012c65 	.word	0x00012c65

00012cf0 <OledTerminal::OledTerminal()>:
#include <cstdint>

#include "L2_HAL/displays/oled/ssd1306.hpp"
#include "L3_Application/graphics.hpp"

class OledTerminal
   12cf0:	b530      	push	{r4, r5, lr}
   12cf2:	b083      	sub	sp, #12
   12cf4:	4675      	mov	r5, lr
   12cf6:	9001      	str	r0, [sp, #4]
   12cf8:	462b      	mov	r3, r5
   12cfa:	4619      	mov	r1, r3
   12cfc:	4816      	ldr	r0, [pc, #88]	; (12d58 <OledTerminal::OledTerminal()+0x68>)
   12cfe:	f002 fa7b 	bl	151f8 <__cyg_profile_func_enter>
   12d02:	9b01      	ldr	r3, [sp, #4]
   12d04:	4618      	mov	r0, r3
   12d06:	f7ff fd37 	bl	12778 <Ssd1306::Ssd1306()>
   12d0a:	9b01      	ldr	r3, [sp, #4]
   12d0c:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   12d10:	9a01      	ldr	r2, [sp, #4]
   12d12:	4611      	mov	r1, r2
   12d14:	4618      	mov	r0, r3
   12d16:	f7ff ffa5 	bl	12c64 <Graphics::Graphics(PixelDisplayInterface*)>
   12d1a:	9b01      	ldr	r3, [sp, #4]
   12d1c:	2200      	movs	r2, #0
   12d1e:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
   12d22:	9b01      	ldr	r3, [sp, #4]
   12d24:	2200      	movs	r2, #0
   12d26:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
   12d2a:	9b01      	ldr	r3, [sp, #4]
   12d2c:	2200      	movs	r2, #0
   12d2e:	f8c3 2744 	str.w	r2, [r3, #1860]	; 0x744
   12d32:	9b01      	ldr	r3, [sp, #4]
   12d34:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   12d38:	2280      	movs	r2, #128	; 0x80
   12d3a:	2100      	movs	r1, #0
   12d3c:	4618      	mov	r0, r3
   12d3e:	f006 fb84 	bl	1944a <memset>
   12d42:	9c01      	ldr	r4, [sp, #4]
   12d44:	462b      	mov	r3, r5
   12d46:	4619      	mov	r1, r3
   12d48:	4803      	ldr	r0, [pc, #12]	; (12d58 <OledTerminal::OledTerminal()+0x68>)
   12d4a:	f002 fa69 	bl	15220 <__cyg_profile_func_exit>
   12d4e:	4623      	mov	r3, r4
   12d50:	4618      	mov	r0, r3
   12d52:	b003      	add	sp, #12
   12d54:	bd30      	pop	{r4, r5, pc}
   12d56:	bf00      	nop
   12d58:	00012cf1 	.word	0x00012cf1

00012d5c <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)>:
constexpr T Set(T target, uint32_t position)
   12d5c:	b530      	push	{r4, r5, lr}
   12d5e:	b083      	sub	sp, #12
   12d60:	4675      	mov	r5, lr
   12d62:	9001      	str	r0, [sp, #4]
   12d64:	9100      	str	r1, [sp, #0]
   12d66:	462b      	mov	r3, r5
   12d68:	4619      	mov	r1, r3
   12d6a:	480a      	ldr	r0, [pc, #40]	; (12d94 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   12d6c:	f002 fa44 	bl	151f8 <__cyg_profile_func_enter>
  return target | (1 << position);
   12d70:	2201      	movs	r2, #1
   12d72:	9b00      	ldr	r3, [sp, #0]
   12d74:	fa02 f303 	lsl.w	r3, r2, r3
   12d78:	461a      	mov	r2, r3
   12d7a:	9b01      	ldr	r3, [sp, #4]
   12d7c:	ea42 0403 	orr.w	r4, r2, r3
   12d80:	462b      	mov	r3, r5
   12d82:	4619      	mov	r1, r3
   12d84:	4803      	ldr	r0, [pc, #12]	; (12d94 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   12d86:	f002 fa4b 	bl	15220 <__cyg_profile_func_exit>
   12d8a:	4623      	mov	r3, r4
}
   12d8c:	4618      	mov	r0, r3
   12d8e:	b003      	add	sp, #12
   12d90:	bd30      	pop	{r4, r5, pc}
   12d92:	bf00      	nop
   12d94:	00012d5d 	.word	0x00012d5d

00012d98 <bool bit::Read<unsigned long>(unsigned long, unsigned long)>:
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
   12d98:	b530      	push	{r4, r5, lr}
   12d9a:	b083      	sub	sp, #12
   12d9c:	4675      	mov	r5, lr
   12d9e:	9001      	str	r0, [sp, #4]
   12da0:	9100      	str	r1, [sp, #0]
   12da2:	462b      	mov	r3, r5
   12da4:	4619      	mov	r1, r3
   12da6:	480c      	ldr	r0, [pc, #48]	; (12dd8 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   12da8:	f002 fa26 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   12dac:	2201      	movs	r2, #1
   12dae:	9b00      	ldr	r3, [sp, #0]
   12db0:	fa02 f303 	lsl.w	r3, r2, r3
   12db4:	461a      	mov	r2, r3
   12db6:	9b01      	ldr	r3, [sp, #4]
   12db8:	4013      	ands	r3, r2
   12dba:	2b00      	cmp	r3, #0
   12dbc:	bf14      	ite	ne
   12dbe:	2301      	movne	r3, #1
   12dc0:	2300      	moveq	r3, #0
   12dc2:	b2dc      	uxtb	r4, r3
   12dc4:	462b      	mov	r3, r5
   12dc6:	4619      	mov	r1, r3
   12dc8:	4803      	ldr	r0, [pc, #12]	; (12dd8 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   12dca:	f002 fa29 	bl	15220 <__cyg_profile_func_exit>
   12dce:	4623      	mov	r3, r4
}
   12dd0:	4618      	mov	r0, r3
   12dd2:	b003      	add	sp, #12
   12dd4:	bd30      	pop	{r4, r5, pc}
   12dd6:	bf00      	nop
   12dd8:	00012d99 	.word	0x00012d99

00012ddc <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   12ddc:	b530      	push	{r4, r5, lr}
   12dde:	b089      	sub	sp, #36	; 0x24
   12de0:	4675      	mov	r5, lr
   12de2:	9003      	str	r0, [sp, #12]
   12de4:	9201      	str	r2, [sp, #4]
   12de6:	9300      	str	r3, [sp, #0]
   12de8:	460b      	mov	r3, r1
   12dea:	f88d 300b 	strb.w	r3, [sp, #11]
   12dee:	462b      	mov	r3, r5
   12df0:	4619      	mov	r1, r3
   12df2:	4816      	ldr	r0, [pc, #88]	; (12e4c <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   12df4:	f002 fa00 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12df8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12dfc:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12dfe:	2320      	movs	r3, #32
   12e00:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12e02:	9b00      	ldr	r3, [sp, #0]
   12e04:	f1c3 0320 	rsb	r3, r3, #32
   12e08:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12e0c:	fa22 f303 	lsr.w	r3, r2, r3
   12e10:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   12e12:	9a05      	ldr	r2, [sp, #20]
   12e14:	9b01      	ldr	r3, [sp, #4]
   12e16:	fa02 f303 	lsl.w	r3, r2, r3
   12e1a:	43db      	mvns	r3, r3
   12e1c:	9a03      	ldr	r2, [sp, #12]
   12e1e:	4013      	ands	r3, r2
   12e20:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   12e22:	f89d 200b 	ldrb.w	r2, [sp, #11]
   12e26:	9b05      	ldr	r3, [sp, #20]
   12e28:	401a      	ands	r2, r3
   12e2a:	9b01      	ldr	r3, [sp, #4]
   12e2c:	fa02 f303 	lsl.w	r3, r2, r3
   12e30:	9a03      	ldr	r2, [sp, #12]
   12e32:	4313      	orrs	r3, r2
   12e34:	9303      	str	r3, [sp, #12]
  return target;
   12e36:	9c03      	ldr	r4, [sp, #12]
   12e38:	462b      	mov	r3, r5
   12e3a:	4619      	mov	r1, r3
   12e3c:	4803      	ldr	r0, [pc, #12]	; (12e4c <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   12e3e:	f002 f9ef 	bl	15220 <__cyg_profile_func_exit>
   12e42:	4623      	mov	r3, r4
}
   12e44:	4618      	mov	r0, r3
   12e46:	b009      	add	sp, #36	; 0x24
   12e48:	bd30      	pop	{r4, r5, pc}
   12e4a:	bf00      	nop
   12e4c:	00012ddd 	.word	0x00012ddd

00012e50 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)>:
constexpr T Extract(T target, uint32_t position, uint32_t width = 1)
   12e50:	b530      	push	{r4, r5, lr}
   12e52:	b089      	sub	sp, #36	; 0x24
   12e54:	4675      	mov	r5, lr
   12e56:	9003      	str	r0, [sp, #12]
   12e58:	9102      	str	r1, [sp, #8]
   12e5a:	9201      	str	r2, [sp, #4]
   12e5c:	462b      	mov	r3, r5
   12e5e:	4619      	mov	r1, r3
   12e60:	480f      	ldr	r0, [pc, #60]	; (12ea0 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   12e62:	f002 f9c9 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12e66:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12e6a:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12e6c:	2320      	movs	r3, #32
   12e6e:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12e70:	9b01      	ldr	r3, [sp, #4]
   12e72:	f1c3 0320 	rsb	r3, r3, #32
   12e76:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12e7a:	fa22 f303 	lsr.w	r3, r2, r3
   12e7e:	9305      	str	r3, [sp, #20]
  return (target >> position) & mask;
   12e80:	9a03      	ldr	r2, [sp, #12]
   12e82:	9b02      	ldr	r3, [sp, #8]
   12e84:	40da      	lsrs	r2, r3
   12e86:	9b05      	ldr	r3, [sp, #20]
   12e88:	ea02 0403 	and.w	r4, r2, r3
   12e8c:	462b      	mov	r3, r5
   12e8e:	4619      	mov	r1, r3
   12e90:	4803      	ldr	r0, [pc, #12]	; (12ea0 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   12e92:	f002 f9c5 	bl	15220 <__cyg_profile_func_exit>
   12e96:	4623      	mov	r3, r4
}
   12e98:	4618      	mov	r0, r3
   12e9a:	b009      	add	sp, #36	; 0x24
   12e9c:	bd30      	pop	{r4, r5, pc}
   12e9e:	bf00      	nop
   12ea0:	00012e51 	.word	0x00012e51

00012ea4 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   12ea4:	b530      	push	{r4, r5, lr}
   12ea6:	b089      	sub	sp, #36	; 0x24
   12ea8:	4675      	mov	r5, lr
   12eaa:	9003      	str	r0, [sp, #12]
   12eac:	9201      	str	r2, [sp, #4]
   12eae:	9300      	str	r3, [sp, #0]
   12eb0:	460b      	mov	r3, r1
   12eb2:	f88d 300b 	strb.w	r3, [sp, #11]
   12eb6:	462b      	mov	r3, r5
   12eb8:	4619      	mov	r1, r3
   12eba:	4816      	ldr	r0, [pc, #88]	; (12f14 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   12ebc:	f002 f99c 	bl	151f8 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   12ec0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12ec4:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   12ec6:	2320      	movs	r3, #32
   12ec8:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   12eca:	9b00      	ldr	r3, [sp, #0]
   12ecc:	f1c3 0320 	rsb	r3, r3, #32
   12ed0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12ed4:	fa22 f303 	lsr.w	r3, r2, r3
   12ed8:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   12eda:	9a05      	ldr	r2, [sp, #20]
   12edc:	9b01      	ldr	r3, [sp, #4]
   12ede:	fa02 f303 	lsl.w	r3, r2, r3
   12ee2:	43db      	mvns	r3, r3
   12ee4:	9a03      	ldr	r2, [sp, #12]
   12ee6:	4013      	ands	r3, r2
   12ee8:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   12eea:	f89d 200b 	ldrb.w	r2, [sp, #11]
   12eee:	9b05      	ldr	r3, [sp, #20]
   12ef0:	401a      	ands	r2, r3
   12ef2:	9b01      	ldr	r3, [sp, #4]
   12ef4:	fa02 f303 	lsl.w	r3, r2, r3
   12ef8:	9a03      	ldr	r2, [sp, #12]
   12efa:	4313      	orrs	r3, r2
   12efc:	9303      	str	r3, [sp, #12]
  return target;
   12efe:	9c03      	ldr	r4, [sp, #12]
   12f00:	462b      	mov	r3, r5
   12f02:	4619      	mov	r1, r3
   12f04:	4803      	ldr	r0, [pc, #12]	; (12f14 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   12f06:	f002 f98b 	bl	15220 <__cyg_profile_func_exit>
   12f0a:	4623      	mov	r3, r4
}
   12f0c:	4618      	mov	r0, r3
   12f0e:	b009      	add	sp, #36	; 0x24
   12f10:	bd30      	pop	{r4, r5, pc}
   12f12:	bf00      	nop
   12f14:	00012ea5 	.word	0x00012ea5

00012f18 <Graphics::Initialize()>:
  void SetColor(PixelDisplayInterface::Color_t color)
  {
    color_ = color;
  }

  void Initialize()
   12f18:	b510      	push	{r4, lr}
   12f1a:	b082      	sub	sp, #8
   12f1c:	4674      	mov	r4, lr
   12f1e:	9001      	str	r0, [sp, #4]
   12f20:	4623      	mov	r3, r4
   12f22:	4619      	mov	r1, r3
   12f24:	480e      	ldr	r0, [pc, #56]	; (12f60 <Graphics::Initialize()+0x48>)
   12f26:	f002 f967 	bl	151f8 <__cyg_profile_func_enter>
  {
    display_->Initialize();
   12f2a:	9b01      	ldr	r3, [sp, #4]
   12f2c:	681a      	ldr	r2, [r3, #0]
   12f2e:	9b01      	ldr	r3, [sp, #4]
   12f30:	681b      	ldr	r3, [r3, #0]
   12f32:	681b      	ldr	r3, [r3, #0]
   12f34:	330c      	adds	r3, #12
   12f36:	681b      	ldr	r3, [r3, #0]
   12f38:	4610      	mov	r0, r2
   12f3a:	4798      	blx	r3
    display_->Enable();
   12f3c:	9b01      	ldr	r3, [sp, #4]
   12f3e:	681a      	ldr	r2, [r3, #0]
   12f40:	9b01      	ldr	r3, [sp, #4]
   12f42:	681b      	ldr	r3, [r3, #0]
   12f44:	681b      	ldr	r3, [r3, #0]
   12f46:	3310      	adds	r3, #16
   12f48:	681b      	ldr	r3, [r3, #0]
   12f4a:	4610      	mov	r0, r2
   12f4c:	4798      	blx	r3
   12f4e:	4623      	mov	r3, r4
   12f50:	4619      	mov	r1, r3
   12f52:	4803      	ldr	r0, [pc, #12]	; (12f60 <Graphics::Initialize()+0x48>)
   12f54:	f002 f964 	bl	15220 <__cyg_profile_func_exit>
  }
   12f58:	bf00      	nop
   12f5a:	b002      	add	sp, #8
   12f5c:	bd10      	pop	{r4, pc}
   12f5e:	bf00      	nop
   12f60:	00012f19 	.word	0x00012f19

00012f64 <Graphics::DrawCharacter(long, long, char, bool)>:
    // |                    |
    // ----------------------
    DrawVerticalLine(x + width, y, height);
  }

  void DrawCharacter(int32_t x0, int32_t y0, char letter,
   12f64:	b510      	push	{r4, lr}
   12f66:	b08e      	sub	sp, #56	; 0x38
   12f68:	4674      	mov	r4, lr
   12f6a:	9007      	str	r0, [sp, #28]
   12f6c:	9106      	str	r1, [sp, #24]
   12f6e:	9205      	str	r2, [sp, #20]
   12f70:	f88d 3013 	strb.w	r3, [sp, #19]
   12f74:	4623      	mov	r3, r4
   12f76:	4619      	mov	r1, r3
   12f78:	4837      	ldr	r0, [pc, #220]	; (13058 <Graphics::DrawCharacter(long, long, char, bool)+0xf4>)
   12f7a:	f002 f93d 	bl	151f8 <__cyg_profile_func_enter>
                     bool fill_background = true)
  {
    int32_t letter_position = static_cast<int32_t>(letter);
   12f7e:	f89d 3013 	ldrb.w	r3, [sp, #19]
   12f82:	930b      	str	r3, [sp, #44]	; 0x2c

    PixelDisplayInterface::Color_t foreground = color_;
   12f84:	9a07      	ldr	r2, [sp, #28]
   12f86:	ab0a      	add	r3, sp, #40	; 0x28
   12f88:	3204      	adds	r2, #4
   12f8a:	6812      	ldr	r2, [r2, #0]
   12f8c:	4611      	mov	r1, r2
   12f8e:	8019      	strh	r1, [r3, #0]
   12f90:	3302      	adds	r3, #2
   12f92:	0c12      	lsrs	r2, r2, #16
   12f94:	701a      	strb	r2, [r3, #0]
    PixelDisplayInterface::Color_t background =
        PixelDisplayInterface::Color_t(0, 0, 0, 0, 1, true);
   12f96:	a809      	add	r0, sp, #36	; 0x24
   12f98:	2301      	movs	r3, #1
   12f9a:	9302      	str	r3, [sp, #8]
   12f9c:	2301      	movs	r3, #1
   12f9e:	9301      	str	r3, [sp, #4]
   12fa0:	2300      	movs	r3, #0
   12fa2:	9300      	str	r3, [sp, #0]
   12fa4:	2300      	movs	r3, #0
   12fa6:	2200      	movs	r2, #0
   12fa8:	2100      	movs	r1, #0
   12faa:	f7ff fb11 	bl	125d0 <PixelDisplayInterface::Color_t::Color_t(bool, bool, bool, unsigned char, unsigned char, bool)>

    for (int32_t y = 0; y < 8; y++)
   12fae:	2300      	movs	r3, #0
   12fb0:	930d      	str	r3, [sp, #52]	; 0x34
   12fb2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12fb4:	2b07      	cmp	r3, #7
   12fb6:	dc3d      	bgt.n	13034 <Graphics::DrawCharacter(long, long, char, bool)+0xd0>
    {
      for (int32_t x = 0; x < 8; x++)
   12fb8:	2300      	movs	r3, #0
   12fba:	930c      	str	r3, [sp, #48]	; 0x30
   12fbc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12fbe:	2b07      	cmp	r3, #7
   12fc0:	dc34      	bgt.n	1302c <Graphics::DrawCharacter(long, long, char, bool)+0xc8>
      {
        if (font8x8_basic[letter_position][y] & (1 << x))
   12fc2:	4a26      	ldr	r2, [pc, #152]	; (1305c <Graphics::DrawCharacter(long, long, char, bool)+0xf8>)
   12fc4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12fc6:	00db      	lsls	r3, r3, #3
   12fc8:	441a      	add	r2, r3
   12fca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12fcc:	4413      	add	r3, r2
   12fce:	781b      	ldrb	r3, [r3, #0]
   12fd0:	461a      	mov	r2, r3
   12fd2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12fd4:	fa42 f303 	asr.w	r3, r2, r3
   12fd8:	f003 0301 	and.w	r3, r3, #1
   12fdc:	2b00      	cmp	r3, #0
   12fde:	d009      	beq.n	12ff4 <Graphics::DrawCharacter(long, long, char, bool)+0x90>
        {
          color_ = foreground;
   12fe0:	9b07      	ldr	r3, [sp, #28]
   12fe2:	3304      	adds	r3, #4
   12fe4:	aa0a      	add	r2, sp, #40	; 0x28
   12fe6:	6812      	ldr	r2, [r2, #0]
   12fe8:	4611      	mov	r1, r2
   12fea:	8019      	strh	r1, [r3, #0]
   12fec:	3302      	adds	r3, #2
   12fee:	0c12      	lsrs	r2, r2, #16
   12ff0:	701a      	strb	r2, [r3, #0]
   12ff2:	e00c      	b.n	1300e <Graphics::DrawCharacter(long, long, char, bool)+0xaa>
        }
        else if (fill_background)
   12ff4:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   12ff8:	2b00      	cmp	r3, #0
   12ffa:	d008      	beq.n	1300e <Graphics::DrawCharacter(long, long, char, bool)+0xaa>
        {
          color_ = background;
   12ffc:	9b07      	ldr	r3, [sp, #28]
   12ffe:	3304      	adds	r3, #4
   13000:	aa09      	add	r2, sp, #36	; 0x24
   13002:	6812      	ldr	r2, [r2, #0]
   13004:	4611      	mov	r1, r2
   13006:	8019      	strh	r1, [r3, #0]
   13008:	3302      	adds	r3, #2
   1300a:	0c12      	lsrs	r2, r2, #16
   1300c:	701a      	strb	r2, [r3, #0]
        }
        DrawPixel(x0 + x, y0 + y);
   1300e:	9a06      	ldr	r2, [sp, #24]
   13010:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   13012:	4413      	add	r3, r2
   13014:	4619      	mov	r1, r3
   13016:	9a05      	ldr	r2, [sp, #20]
   13018:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1301a:	4413      	add	r3, r2
   1301c:	461a      	mov	r2, r3
   1301e:	9807      	ldr	r0, [sp, #28]
   13020:	f000 f81e 	bl	13060 <Graphics::DrawPixel(unsigned long, unsigned long)>
      for (int32_t x = 0; x < 8; x++)
   13024:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   13026:	3301      	adds	r3, #1
   13028:	930c      	str	r3, [sp, #48]	; 0x30
   1302a:	e7c7      	b.n	12fbc <Graphics::DrawCharacter(long, long, char, bool)+0x58>
    for (int32_t y = 0; y < 8; y++)
   1302c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1302e:	3301      	adds	r3, #1
   13030:	930d      	str	r3, [sp, #52]	; 0x34
   13032:	e7be      	b.n	12fb2 <Graphics::DrawCharacter(long, long, char, bool)+0x4e>
      }
    }
    color_ = foreground;
   13034:	9b07      	ldr	r3, [sp, #28]
   13036:	3304      	adds	r3, #4
   13038:	aa0a      	add	r2, sp, #40	; 0x28
   1303a:	6812      	ldr	r2, [r2, #0]
   1303c:	4611      	mov	r1, r2
   1303e:	8019      	strh	r1, [r3, #0]
   13040:	3302      	adds	r3, #2
   13042:	0c12      	lsrs	r2, r2, #16
   13044:	701a      	strb	r2, [r3, #0]
   13046:	4623      	mov	r3, r4
   13048:	4619      	mov	r1, r3
   1304a:	4803      	ldr	r0, [pc, #12]	; (13058 <Graphics::DrawCharacter(long, long, char, bool)+0xf4>)
   1304c:	f002 f8e8 	bl	15220 <__cyg_profile_func_exit>
  }
   13050:	bf00      	nop
   13052:	b00e      	add	sp, #56	; 0x38
   13054:	bd10      	pop	{r4, pc}
   13056:	bf00      	nop
   13058:	00012f65 	.word	0x00012f65
   1305c:	1000005c 	.word	0x1000005c

00013060 <Graphics::DrawPixel(unsigned long, unsigned long)>:

  void DrawPixel(uint32_t x, uint32_t y)
   13060:	b530      	push	{r4, r5, lr}
   13062:	b085      	sub	sp, #20
   13064:	4675      	mov	r5, lr
   13066:	9003      	str	r0, [sp, #12]
   13068:	9102      	str	r1, [sp, #8]
   1306a:	9201      	str	r2, [sp, #4]
   1306c:	462b      	mov	r3, r5
   1306e:	4619      	mov	r1, r3
   13070:	4810      	ldr	r0, [pc, #64]	; (130b4 <Graphics::DrawPixel(unsigned long, unsigned long)+0x54>)
   13072:	f002 f8c1 	bl	151f8 <__cyg_profile_func_enter>
  {
    // Pixels outside of the bounds of the screen will not be drawn.
    if (x <= width_ && y <= height_)
   13076:	9b03      	ldr	r3, [sp, #12]
   13078:	689b      	ldr	r3, [r3, #8]
   1307a:	9a02      	ldr	r2, [sp, #8]
   1307c:	429a      	cmp	r2, r3
   1307e:	d810      	bhi.n	130a2 <Graphics::DrawPixel(unsigned long, unsigned long)+0x42>
   13080:	9b03      	ldr	r3, [sp, #12]
   13082:	68db      	ldr	r3, [r3, #12]
   13084:	9a01      	ldr	r2, [sp, #4]
   13086:	429a      	cmp	r2, r3
   13088:	d80b      	bhi.n	130a2 <Graphics::DrawPixel(unsigned long, unsigned long)+0x42>
    {
      display_->DrawPixel(x, y, color_);
   1308a:	9b03      	ldr	r3, [sp, #12]
   1308c:	6818      	ldr	r0, [r3, #0]
   1308e:	9b03      	ldr	r3, [sp, #12]
   13090:	681b      	ldr	r3, [r3, #0]
   13092:	681b      	ldr	r3, [r3, #0]
   13094:	331c      	adds	r3, #28
   13096:	681c      	ldr	r4, [r3, #0]
   13098:	9902      	ldr	r1, [sp, #8]
   1309a:	9a01      	ldr	r2, [sp, #4]
   1309c:	9b03      	ldr	r3, [sp, #12]
   1309e:	685b      	ldr	r3, [r3, #4]
   130a0:	47a0      	blx	r4
   130a2:	462b      	mov	r3, r5
   130a4:	4619      	mov	r1, r3
   130a6:	4803      	ldr	r0, [pc, #12]	; (130b4 <Graphics::DrawPixel(unsigned long, unsigned long)+0x54>)
   130a8:	f002 f8ba 	bl	15220 <__cyg_profile_func_exit>
    }
  }
   130ac:	bf00      	nop
   130ae:	b005      	add	sp, #20
   130b0:	bd30      	pop	{r4, r5, pc}
   130b2:	bf00      	nop
   130b4:	00013061 	.word	0x00013061

000130b8 <Graphics::Update()>:
  void Update()
   130b8:	b510      	push	{r4, lr}
   130ba:	b082      	sub	sp, #8
   130bc:	4674      	mov	r4, lr
   130be:	9001      	str	r0, [sp, #4]
   130c0:	4623      	mov	r3, r4
   130c2:	4619      	mov	r1, r3
   130c4:	4809      	ldr	r0, [pc, #36]	; (130ec <Graphics::Update()+0x34>)
   130c6:	f002 f897 	bl	151f8 <__cyg_profile_func_enter>
  {
    display_->Update();
   130ca:	9b01      	ldr	r3, [sp, #4]
   130cc:	681a      	ldr	r2, [r3, #0]
   130ce:	9b01      	ldr	r3, [sp, #4]
   130d0:	681b      	ldr	r3, [r3, #0]
   130d2:	681b      	ldr	r3, [r3, #0]
   130d4:	3320      	adds	r3, #32
   130d6:	681b      	ldr	r3, [r3, #0]
   130d8:	4610      	mov	r0, r2
   130da:	4798      	blx	r3
   130dc:	4623      	mov	r3, r4
   130de:	4619      	mov	r1, r3
   130e0:	4802      	ldr	r0, [pc, #8]	; (130ec <Graphics::Update()+0x34>)
   130e2:	f002 f89d 	bl	15220 <__cyg_profile_func_exit>
  }
   130e6:	bf00      	nop
   130e8:	b002      	add	sp, #8
   130ea:	bd10      	pop	{r4, pc}
   130ec:	000130b9 	.word	0x000130b9

000130f0 <Graphics::Clear()>:
  void Clear()
   130f0:	b510      	push	{r4, lr}
   130f2:	b082      	sub	sp, #8
   130f4:	4674      	mov	r4, lr
   130f6:	9001      	str	r0, [sp, #4]
   130f8:	4623      	mov	r3, r4
   130fa:	4619      	mov	r1, r3
   130fc:	4809      	ldr	r0, [pc, #36]	; (13124 <Graphics::Clear()+0x34>)
   130fe:	f002 f87b 	bl	151f8 <__cyg_profile_func_enter>
  {
    display_->Clear();
   13102:	9b01      	ldr	r3, [sp, #4]
   13104:	681a      	ldr	r2, [r3, #0]
   13106:	9b01      	ldr	r3, [sp, #4]
   13108:	681b      	ldr	r3, [r3, #0]
   1310a:	681b      	ldr	r3, [r3, #0]
   1310c:	3318      	adds	r3, #24
   1310e:	681b      	ldr	r3, [r3, #0]
   13110:	4610      	mov	r0, r2
   13112:	4798      	blx	r3
   13114:	4623      	mov	r3, r4
   13116:	4619      	mov	r1, r3
   13118:	4802      	ldr	r0, [pc, #8]	; (13124 <Graphics::Clear()+0x34>)
   1311a:	f002 f881 	bl	15220 <__cyg_profile_func_exit>
  }
   1311e:	bf00      	nop
   13120:	b002      	add	sp, #8
   13122:	bd10      	pop	{r4, pc}
   13124:	000130f1 	.word	0x000130f1

00013128 <OledTerminal::Initialize()>:
  static constexpr size_t kCharacterHeight = 8;
  static constexpr size_t kCharacterWidth  = 8;
  static constexpr size_t kMaxColumns      = Ssd1306::kWidth / kCharacterWidth;
  static constexpr size_t kMaxRows = Ssd1306::kHeight / kCharacterHeight;

  void Initialize()
   13128:	b510      	push	{r4, lr}
   1312a:	b082      	sub	sp, #8
   1312c:	4674      	mov	r4, lr
   1312e:	9001      	str	r0, [sp, #4]
   13130:	4623      	mov	r3, r4
   13132:	4619      	mov	r1, r3
   13134:	480e      	ldr	r0, [pc, #56]	; (13170 <OledTerminal::Initialize()+0x48>)
   13136:	f002 f85f 	bl	151f8 <__cyg_profile_func_enter>
  {
    graphics_.Initialize();
   1313a:	9b01      	ldr	r3, [sp, #4]
   1313c:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   13140:	4618      	mov	r0, r3
   13142:	f7ff fee9 	bl	12f18 <Graphics::Initialize()>
    graphics_.Clear();
   13146:	9b01      	ldr	r3, [sp, #4]
   13148:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   1314c:	4618      	mov	r0, r3
   1314e:	f7ff ffcf 	bl	130f0 <Graphics::Clear()>
    graphics_.Update();
   13152:	9b01      	ldr	r3, [sp, #4]
   13154:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   13158:	4618      	mov	r0, r3
   1315a:	f7ff ffad 	bl	130b8 <Graphics::Update()>
   1315e:	4623      	mov	r3, r4
   13160:	4619      	mov	r1, r3
   13162:	4803      	ldr	r0, [pc, #12]	; (13170 <OledTerminal::Initialize()+0x48>)
   13164:	f002 f85c 	bl	15220 <__cyg_profile_func_exit>
  }
   13168:	bf00      	nop
   1316a:	b002      	add	sp, #8
   1316c:	bd10      	pop	{r4, pc}
   1316e:	bf00      	nop
   13170:	00013129 	.word	0x00013129

00013174 <OledTerminal::printf(char const*, ...)>:

  int printf(const char * format, ...)  // NOLINT
   13174:	b40e      	push	{r1, r2, r3}
   13176:	b530      	push	{r4, r5, lr}
   13178:	b0c6      	sub	sp, #280	; 0x118
   1317a:	4675      	mov	r5, lr
   1317c:	ab01      	add	r3, sp, #4
   1317e:	6018      	str	r0, [r3, #0]
   13180:	462b      	mov	r3, r5
   13182:	4619      	mov	r1, r3
   13184:	4850      	ldr	r0, [pc, #320]	; (132c8 <OledTerminal::printf(char const*, ...)+0x154>)
   13186:	f002 f837 	bl	151f8 <__cyg_profile_func_enter>
  {
    char buffer[256];

    va_list args;
    va_start(args, format);
   1318a:	aa4a      	add	r2, sp, #296	; 0x128
   1318c:	ab02      	add	r3, sp, #8
   1318e:	601a      	str	r2, [r3, #0]
    size_t characters = vsnprintf(buffer, sizeof(buffer), format, args);
   13190:	ab02      	add	r3, sp, #8
   13192:	a803      	add	r0, sp, #12
   13194:	681b      	ldr	r3, [r3, #0]
   13196:	9a49      	ldr	r2, [sp, #292]	; 0x124
   13198:	f44f 7180 	mov.w	r1, #256	; 0x100
   1319c:	f004 fc36 	bl	17a0c <vsnprintf>
   131a0:	4603      	mov	r3, r0
   131a2:	9344      	str	r3, [sp, #272]	; 0x110
    va_end(args);

    size_t pos = 0;
   131a4:	2300      	movs	r3, #0
   131a6:	9345      	str	r3, [sp, #276]	; 0x114
    for (; pos < characters; pos++)
   131a8:	9a45      	ldr	r2, [sp, #276]	; 0x114
   131aa:	9b44      	ldr	r3, [sp, #272]	; 0x110
   131ac:	429a      	cmp	r2, r3
   131ae:	d253      	bcs.n	13258 <OledTerminal::printf(char const*, ...)+0xe4>
    {
      char character = buffer[pos];
   131b0:	aa03      	add	r2, sp, #12
   131b2:	9b45      	ldr	r3, [sp, #276]	; 0x114
   131b4:	4413      	add	r3, r2
   131b6:	781b      	ldrb	r3, [r3, #0]
   131b8:	f88d 310f 	strb.w	r3, [sp, #271]	; 0x10f
      switch (character)
   131bc:	f89d 310f 	ldrb.w	r3, [sp, #271]	; 0x10f
   131c0:	2b0a      	cmp	r3, #10
   131c2:	d10e      	bne.n	131e2 <OledTerminal::printf(char const*, ...)+0x6e>
      {
        case '\n':
          column_ = 0;
   131c4:	ab01      	add	r3, sp, #4
   131c6:	681b      	ldr	r3, [r3, #0]
   131c8:	2200      	movs	r2, #0
   131ca:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
          row_++;
   131ce:	ab01      	add	r3, sp, #4
   131d0:	681b      	ldr	r3, [r3, #0]
   131d2:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   131d6:	1c5a      	adds	r2, r3, #1
   131d8:	ab01      	add	r3, sp, #4
   131da:	681b      	ldr	r3, [r3, #0]
   131dc:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
          break;
   131e0:	e036      	b.n	13250 <OledTerminal::printf(char const*, ...)+0xdc>
        default:
          terminal_[(row_ + row_start_) % kMaxRows][column_] = character;
   131e2:	ab01      	add	r3, sp, #4
   131e4:	681b      	ldr	r3, [r3, #0]
   131e6:	f8d3 273c 	ldr.w	r2, [r3, #1852]	; 0x73c
   131ea:	ab01      	add	r3, sp, #4
   131ec:	681b      	ldr	r3, [r3, #0]
   131ee:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   131f2:	4413      	add	r3, r2
   131f4:	f003 0207 	and.w	r2, r3, #7
   131f8:	ab01      	add	r3, sp, #4
   131fa:	681b      	ldr	r3, [r3, #0]
   131fc:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   13200:	a901      	add	r1, sp, #4
   13202:	6809      	ldr	r1, [r1, #0]
   13204:	0112      	lsls	r2, r2, #4
   13206:	440a      	add	r2, r1
   13208:	4413      	add	r3, r2
   1320a:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   1320e:	f89d 210f 	ldrb.w	r2, [sp, #271]	; 0x10f
   13212:	701a      	strb	r2, [r3, #0]
          column_++;
   13214:	ab01      	add	r3, sp, #4
   13216:	681b      	ldr	r3, [r3, #0]
   13218:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   1321c:	1c5a      	adds	r2, r3, #1
   1321e:	ab01      	add	r3, sp, #4
   13220:	681b      	ldr	r3, [r3, #0]
   13222:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
          if (column_ >= kMaxColumns)
   13226:	ab01      	add	r3, sp, #4
   13228:	681b      	ldr	r3, [r3, #0]
   1322a:	f8d3 3740 	ldr.w	r3, [r3, #1856]	; 0x740
   1322e:	2b0f      	cmp	r3, #15
   13230:	d90d      	bls.n	1324e <OledTerminal::printf(char const*, ...)+0xda>
          {
            column_ = 0;
   13232:	ab01      	add	r3, sp, #4
   13234:	681b      	ldr	r3, [r3, #0]
   13236:	2200      	movs	r2, #0
   13238:	f8c3 2740 	str.w	r2, [r3, #1856]	; 0x740
            row_++;
   1323c:	ab01      	add	r3, sp, #4
   1323e:	681b      	ldr	r3, [r3, #0]
   13240:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   13244:	1c5a      	adds	r2, r3, #1
   13246:	ab01      	add	r3, sp, #4
   13248:	681b      	ldr	r3, [r3, #0]
   1324a:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
          }
          break;
   1324e:	bf00      	nop
    for (; pos < characters; pos++)
   13250:	9b45      	ldr	r3, [sp, #276]	; 0x114
   13252:	3301      	adds	r3, #1
   13254:	9345      	str	r3, [sp, #276]	; 0x114
   13256:	e7a7      	b.n	131a8 <OledTerminal::printf(char const*, ...)+0x34>
      }
    }
    Update();
   13258:	ab01      	add	r3, sp, #4
   1325a:	6818      	ldr	r0, [r3, #0]
   1325c:	f000 f836 	bl	132cc <OledTerminal::Update()>
    if (row_ >= kMaxRows)
   13260:	ab01      	add	r3, sp, #4
   13262:	681b      	ldr	r3, [r3, #0]
   13264:	f8d3 373c 	ldr.w	r3, [r3, #1852]	; 0x73c
   13268:	2b07      	cmp	r3, #7
   1326a:	d91f      	bls.n	132ac <OledTerminal::printf(char const*, ...)+0x138>
    {
      row_start_ = (row_start_ + 1) % kMaxRows;
   1326c:	ab01      	add	r3, sp, #4
   1326e:	681b      	ldr	r3, [r3, #0]
   13270:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   13274:	3301      	adds	r3, #1
   13276:	f003 0207 	and.w	r2, r3, #7
   1327a:	ab01      	add	r3, sp, #4
   1327c:	681b      	ldr	r3, [r3, #0]
   1327e:	f8c3 2744 	str.w	r2, [r3, #1860]	; 0x744
      row_       = kMaxRows - 1;
   13282:	ab01      	add	r3, sp, #4
   13284:	681b      	ldr	r3, [r3, #0]
   13286:	2207      	movs	r2, #7
   13288:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
      ClearRow((row_ + row_start_) % kMaxRows);
   1328c:	ab01      	add	r3, sp, #4
   1328e:	681b      	ldr	r3, [r3, #0]
   13290:	f8d3 273c 	ldr.w	r2, [r3, #1852]	; 0x73c
   13294:	ab01      	add	r3, sp, #4
   13296:	681b      	ldr	r3, [r3, #0]
   13298:	f8d3 3744 	ldr.w	r3, [r3, #1860]	; 0x744
   1329c:	4413      	add	r3, r2
   1329e:	f003 0207 	and.w	r2, r3, #7
   132a2:	ab01      	add	r3, sp, #4
   132a4:	4611      	mov	r1, r2
   132a6:	6818      	ldr	r0, [r3, #0]
   132a8:	f000 f85e 	bl	13368 <OledTerminal::ClearRow(unsigned int)>
    }
    return pos;
   132ac:	9c45      	ldr	r4, [sp, #276]	; 0x114
   132ae:	462b      	mov	r3, r5
   132b0:	4619      	mov	r1, r3
   132b2:	4805      	ldr	r0, [pc, #20]	; (132c8 <OledTerminal::printf(char const*, ...)+0x154>)
   132b4:	f001 ffb4 	bl	15220 <__cyg_profile_func_exit>
   132b8:	4623      	mov	r3, r4
  }
   132ba:	4618      	mov	r0, r3
   132bc:	b046      	add	sp, #280	; 0x118
   132be:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   132c2:	b003      	add	sp, #12
   132c4:	4770      	bx	lr
   132c6:	bf00      	nop
   132c8:	00013175 	.word	0x00013175

000132cc <OledTerminal::Update()>:
  OledTerminal & MoveToLineStart()
  {
    column_ = 0;
    return *this;
  }
  OledTerminal & Update()
   132cc:	b530      	push	{r4, r5, lr}
   132ce:	b089      	sub	sp, #36	; 0x24
   132d0:	4675      	mov	r5, lr
   132d2:	9003      	str	r0, [sp, #12]
   132d4:	462b      	mov	r3, r5
   132d6:	4619      	mov	r1, r3
   132d8:	4822      	ldr	r0, [pc, #136]	; (13364 <OledTerminal::Update()+0x98>)
   132da:	f001 ff8d 	bl	151f8 <__cyg_profile_func_enter>
  {
    for (size_t i = 0; i < kMaxRows; i++)
   132de:	2300      	movs	r3, #0
   132e0:	9307      	str	r3, [sp, #28]
   132e2:	9b07      	ldr	r3, [sp, #28]
   132e4:	2b07      	cmp	r3, #7
   132e6:	d82c      	bhi.n	13342 <OledTerminal::Update()+0x76>
    {
      for (size_t j = 0; j < kMaxColumns; j++)
   132e8:	2300      	movs	r3, #0
   132ea:	9306      	str	r3, [sp, #24]
   132ec:	9b06      	ldr	r3, [sp, #24]
   132ee:	2b0f      	cmp	r3, #15
   132f0:	d823      	bhi.n	1333a <OledTerminal::Update()+0x6e>
      {
        size_t x = j * kCharacterWidth;
   132f2:	9b06      	ldr	r3, [sp, #24]
   132f4:	00db      	lsls	r3, r3, #3
   132f6:	9305      	str	r3, [sp, #20]
        size_t y = i * kCharacterHeight;
   132f8:	9b07      	ldr	r3, [sp, #28]
   132fa:	00db      	lsls	r3, r3, #3
   132fc:	9304      	str	r3, [sp, #16]
        graphics_.DrawCharacter(x, y,
   132fe:	9b03      	ldr	r3, [sp, #12]
   13300:	f203 702c 	addw	r0, r3, #1836	; 0x72c
   13304:	9905      	ldr	r1, [sp, #20]
   13306:	9c04      	ldr	r4, [sp, #16]
                                terminal_[(i + row_start_) % kMaxRows][j]);
   13308:	9b03      	ldr	r3, [sp, #12]
   1330a:	f8d3 2744 	ldr.w	r2, [r3, #1860]	; 0x744
   1330e:	9b07      	ldr	r3, [sp, #28]
   13310:	4413      	add	r3, r2
   13312:	f003 0307 	and.w	r3, r3, #7
        graphics_.DrawCharacter(x, y,
   13316:	9a03      	ldr	r2, [sp, #12]
   13318:	011b      	lsls	r3, r3, #4
   1331a:	441a      	add	r2, r3
   1331c:	9b06      	ldr	r3, [sp, #24]
   1331e:	4413      	add	r3, r2
   13320:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   13324:	781a      	ldrb	r2, [r3, #0]
   13326:	2301      	movs	r3, #1
   13328:	9300      	str	r3, [sp, #0]
   1332a:	4613      	mov	r3, r2
   1332c:	4622      	mov	r2, r4
   1332e:	f7ff fe19 	bl	12f64 <Graphics::DrawCharacter(long, long, char, bool)>
      for (size_t j = 0; j < kMaxColumns; j++)
   13332:	9b06      	ldr	r3, [sp, #24]
   13334:	3301      	adds	r3, #1
   13336:	9306      	str	r3, [sp, #24]
   13338:	e7d8      	b.n	132ec <OledTerminal::Update()+0x20>
    for (size_t i = 0; i < kMaxRows; i++)
   1333a:	9b07      	ldr	r3, [sp, #28]
   1333c:	3301      	adds	r3, #1
   1333e:	9307      	str	r3, [sp, #28]
   13340:	e7cf      	b.n	132e2 <OledTerminal::Update()+0x16>
      }
    }
    graphics_.Update();
   13342:	9b03      	ldr	r3, [sp, #12]
   13344:	f203 732c 	addw	r3, r3, #1836	; 0x72c
   13348:	4618      	mov	r0, r3
   1334a:	f7ff feb5 	bl	130b8 <Graphics::Update()>
    return *this;
   1334e:	9c03      	ldr	r4, [sp, #12]
   13350:	462b      	mov	r3, r5
   13352:	4619      	mov	r1, r3
   13354:	4803      	ldr	r0, [pc, #12]	; (13364 <OledTerminal::Update()+0x98>)
   13356:	f001 ff63 	bl	15220 <__cyg_profile_func_exit>
   1335a:	4623      	mov	r3, r4
  }
   1335c:	4618      	mov	r0, r3
   1335e:	b009      	add	sp, #36	; 0x24
   13360:	bd30      	pop	{r4, r5, pc}
   13362:	bf00      	nop
   13364:	000132cd 	.word	0x000132cd

00013368 <OledTerminal::ClearRow(unsigned int)>:
  void ClearRow(size_t row_location)
   13368:	b510      	push	{r4, lr}
   1336a:	b084      	sub	sp, #16
   1336c:	4674      	mov	r4, lr
   1336e:	9001      	str	r0, [sp, #4]
   13370:	9100      	str	r1, [sp, #0]
   13372:	4623      	mov	r3, r4
   13374:	4619      	mov	r1, r3
   13376:	480f      	ldr	r0, [pc, #60]	; (133b4 <OledTerminal::ClearRow(unsigned int)+0x4c>)
   13378:	f001 ff3e 	bl	151f8 <__cyg_profile_func_enter>
  {
    for (size_t i = 0; i < kMaxColumns; i++)
   1337c:	2300      	movs	r3, #0
   1337e:	9303      	str	r3, [sp, #12]
   13380:	9b03      	ldr	r3, [sp, #12]
   13382:	2b0f      	cmp	r3, #15
   13384:	d80d      	bhi.n	133a2 <OledTerminal::ClearRow(unsigned int)+0x3a>
    {
      terminal_[row_location][i] = ' ';
   13386:	9a01      	ldr	r2, [sp, #4]
   13388:	9b00      	ldr	r3, [sp, #0]
   1338a:	011b      	lsls	r3, r3, #4
   1338c:	441a      	add	r2, r3
   1338e:	9b03      	ldr	r3, [sp, #12]
   13390:	4413      	add	r3, r2
   13392:	f503 63e9 	add.w	r3, r3, #1864	; 0x748
   13396:	2220      	movs	r2, #32
   13398:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < kMaxColumns; i++)
   1339a:	9b03      	ldr	r3, [sp, #12]
   1339c:	3301      	adds	r3, #1
   1339e:	9303      	str	r3, [sp, #12]
   133a0:	e7ee      	b.n	13380 <OledTerminal::ClearRow(unsigned int)+0x18>
   133a2:	4623      	mov	r3, r4
   133a4:	4619      	mov	r1, r3
   133a6:	4803      	ldr	r0, [pc, #12]	; (133b4 <OledTerminal::ClearRow(unsigned int)+0x4c>)
   133a8:	f001 ff3a 	bl	15220 <__cyg_profile_func_exit>
    }
  }
   133ac:	bf00      	nop
   133ae:	b004      	add	sp, #16
   133b0:	bd10      	pop	{r4, pc}
   133b2:	bf00      	nop
   133b4:	00013369 	.word	0x00013369

000133b8 <main>:


//LabUART uart_rx(2);

int main() 
{   
   133b8:	b530      	push	{r4, r5, lr}
   133ba:	b085      	sub	sp, #20
   133bc:	4675      	mov	r5, lr
   133be:	462b      	mov	r3, r5
   133c0:	4619      	mov	r1, r3
   133c2:	481d      	ldr	r0, [pc, #116]	; (13438 <main+0x80>)
   133c4:	f001 ff18 	bl	151f8 <__cyg_profile_func_enter>
  char hold = '+';
   133c8:	232b      	movs	r3, #43	; 0x2b
   133ca:	f88d 300f 	strb.w	r3, [sp, #15]
  LOG_INFO("Start\n");
   133ce:	2324      	movs	r3, #36	; 0x24
   133d0:	4a1a      	ldr	r2, [pc, #104]	; (1343c <main+0x84>)
   133d2:	491b      	ldr	r1, [pc, #108]	; (13440 <main+0x88>)
   133d4:	481b      	ldr	r0, [pc, #108]	; (13444 <main+0x8c>)
   133d6:	f004 faf3 	bl	179c0 <printf>
  Global_Queue_Handle = xQueueCreate(10,sizeof(10));
   133da:	2200      	movs	r2, #0
   133dc:	2104      	movs	r1, #4
   133de:	200a      	movs	r0, #10
   133e0:	f002 fddc 	bl	15f9c <xQueueGenericCreate>
   133e4:	4602      	mov	r2, r0
   133e6:	4b18      	ldr	r3, [pc, #96]	; (13448 <main+0x90>)
   133e8:	601a      	str	r2, [r3, #0]
  xTaskCreate(vReceiveByteOverUartTask,(const char*) "receive", 4096, NULL, 1 , NULL);
   133ea:	2300      	movs	r3, #0
   133ec:	9301      	str	r3, [sp, #4]
   133ee:	2301      	movs	r3, #1
   133f0:	9300      	str	r3, [sp, #0]
   133f2:	2300      	movs	r3, #0
   133f4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   133f8:	4914      	ldr	r1, [pc, #80]	; (1344c <main+0x94>)
   133fa:	4815      	ldr	r0, [pc, #84]	; (13450 <main+0x98>)
   133fc:	f002 f811 	bl	15422 <xTaskCreate>
  oled_terminal.Initialize();
   13400:	4814      	ldr	r0, [pc, #80]	; (13454 <main+0x9c>)
   13402:	f7ff fe91 	bl	13128 <OledTerminal::Initialize()>
  InitializeUart2();
   13406:	f000 f827 	bl	13458 <InitializeUart2()>
  Uart2Send(hold);
   1340a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1340e:	4618      	mov	r0, r3
   13410:	f000 f8a4 	bl	1355c <Uart2Send(char)>
  Uart2Send(7);
   13414:	2007      	movs	r0, #7
   13416:	f000 f8a1 	bl	1355c <Uart2Send(char)>
  Uart2Send(5);
   1341a:	2005      	movs	r0, #5
   1341c:	f000 f89e 	bl	1355c <Uart2Send(char)>
  vTaskStartScheduler();
   13420:	f002 f92e 	bl	15680 <vTaskStartScheduler>
 
  
}
   13424:	2400      	movs	r4, #0
   13426:	462b      	mov	r3, r5
   13428:	4619      	mov	r1, r3
   1342a:	4803      	ldr	r0, [pc, #12]	; (13438 <main+0x80>)
   1342c:	f001 fef8 	bl	15220 <__cyg_profile_func_exit>
   13430:	4623      	mov	r3, r4
   13432:	4618      	mov	r0, r3
   13434:	b005      	add	sp, #20
   13436:	bd30      	pop	{r4, r5, pc}
   13438:	000133b9 	.word	0x000133b9
   1343c:	0001a76c 	.word	0x0001a76c
   13440:	0001a760 	.word	0x0001a760
   13444:	0001a6cc 	.word	0x0001a6cc
   13448:	10000a70 	.word	0x10000a70
   1344c:	0001a70c 	.word	0x0001a70c
   13450:	00013651 	.word	0x00013651
   13454:	10000a78 	.word	0x10000a78

00013458 <InitializeUart2()>:
void InitializeUart2()
{   //Power On
   13458:	b510      	push	{r4, lr}
   1345a:	4674      	mov	r4, lr
   1345c:	4623      	mov	r3, r4
   1345e:	4619      	mov	r1, r3
   13460:	4839      	ldr	r0, [pc, #228]	; (13548 <InitializeUart2()+0xf0>)
   13462:	f001 fec9 	bl	151f8 <__cyg_profile_func_enter>
    LPC_SC->PCONP |= (1<<24); 
   13466:	4b39      	ldr	r3, [pc, #228]	; (1354c <InitializeUart2()+0xf4>)
   13468:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   1346c:	4a37      	ldr	r2, [pc, #220]	; (1354c <InitializeUart2()+0xf4>)
   1346e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   13472:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
    LPC_UART2->LCR |= (1<<7);
   13476:	4b36      	ldr	r3, [pc, #216]	; (13550 <InitializeUart2()+0xf8>)
   13478:	7b1b      	ldrb	r3, [r3, #12]
   1347a:	b2db      	uxtb	r3, r3
   1347c:	4a34      	ldr	r2, [pc, #208]	; (13550 <InitializeUart2()+0xf8>)
   1347e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   13482:	b2db      	uxtb	r3, r3
   13484:	7313      	strb	r3, [r2, #12]
    //Enable FIFO
    LPC_UART2->FCR |= (1<<0);
   13486:	4b32      	ldr	r3, [pc, #200]	; (13550 <InitializeUart2()+0xf8>)
   13488:	7a1b      	ldrb	r3, [r3, #8]
   1348a:	b2db      	uxtb	r3, r3
   1348c:	4a30      	ldr	r2, [pc, #192]	; (13550 <InitializeUart2()+0xf8>)
   1348e:	f043 0301 	orr.w	r3, r3, #1
   13492:	b2db      	uxtb	r3, r3
   13494:	7213      	strb	r3, [r2, #8]
    //SetBaud Rate
    LPC_UART2->DLL |= 0x38;
   13496:	4b2e      	ldr	r3, [pc, #184]	; (13550 <InitializeUart2()+0xf8>)
   13498:	781b      	ldrb	r3, [r3, #0]
   1349a:	b2db      	uxtb	r3, r3
   1349c:	4a2c      	ldr	r2, [pc, #176]	; (13550 <InitializeUart2()+0xf8>)
   1349e:	f043 0338 	orr.w	r3, r3, #56	; 0x38
   134a2:	b2db      	uxtb	r3, r3
   134a4:	7013      	strb	r3, [r2, #0]
    LPC_UART2->DLM |= 0x1;
   134a6:	4b2a      	ldr	r3, [pc, #168]	; (13550 <InitializeUart2()+0xf8>)
   134a8:	791b      	ldrb	r3, [r3, #4]
   134aa:	b2db      	uxtb	r3, r3
   134ac:	4a28      	ldr	r2, [pc, #160]	; (13550 <InitializeUart2()+0xf8>)
   134ae:	f043 0301 	orr.w	r3, r3, #1
   134b2:	b2db      	uxtb	r3, r3
   134b4:	7113      	strb	r3, [r2, #4]
    //Set Pins
    pc.uart2_txd(2,8);
   134b6:	2208      	movs	r2, #8
   134b8:	2102      	movs	r1, #2
   134ba:	4826      	ldr	r0, [pc, #152]	; (13554 <InitializeUart2()+0xfc>)
   134bc:	f000 f97c 	bl	137b8 <pinconn::uart2_txd(unsigned char, unsigned char)>
    pc.uart2_rxd(2,9);
   134c0:	2209      	movs	r2, #9
   134c2:	2102      	movs	r1, #2
   134c4:	4823      	ldr	r0, [pc, #140]	; (13554 <InitializeUart2()+0xfc>)
   134c6:	f000 f9d7 	bl	13878 <pinconn::uart2_rxd(unsigned char, unsigned char)>
    LPC_UART2->LCR &= ~(0b11 <<2);
   134ca:	4b21      	ldr	r3, [pc, #132]	; (13550 <InitializeUart2()+0xf8>)
   134cc:	7b1b      	ldrb	r3, [r3, #12]
   134ce:	b2db      	uxtb	r3, r3
   134d0:	4a1f      	ldr	r2, [pc, #124]	; (13550 <InitializeUart2()+0xf8>)
   134d2:	f023 030c 	bic.w	r3, r3, #12
   134d6:	b2db      	uxtb	r3, r3
   134d8:	7313      	strb	r3, [r2, #12]
    LPC_UART2->LCR |= (0b11<<0);
   134da:	4b1d      	ldr	r3, [pc, #116]	; (13550 <InitializeUart2()+0xf8>)
   134dc:	7b1b      	ldrb	r3, [r3, #12]
   134de:	b2db      	uxtb	r3, r3
   134e0:	4a1b      	ldr	r2, [pc, #108]	; (13550 <InitializeUart2()+0xf8>)
   134e2:	f043 0303 	orr.w	r3, r3, #3
   134e6:	b2db      	uxtb	r3, r3
   134e8:	7313      	strb	r3, [r2, #12]
    // Disable for interrupt
    LPC_UART2->LCR &= ~(1<<7);
   134ea:	4b19      	ldr	r3, [pc, #100]	; (13550 <InitializeUart2()+0xf8>)
   134ec:	7b1b      	ldrb	r3, [r3, #12]
   134ee:	b2db      	uxtb	r3, r3
   134f0:	4a17      	ldr	r2, [pc, #92]	; (13550 <InitializeUart2()+0xf8>)
   134f2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   134f6:	b2db      	uxtb	r3, r3
   134f8:	7313      	strb	r3, [r2, #12]
    //Reset FIFOs
    LPC_UART2->FCR |= (0b11 << 1);
   134fa:	4b15      	ldr	r3, [pc, #84]	; (13550 <InitializeUart2()+0xf8>)
   134fc:	7a1b      	ldrb	r3, [r3, #8]
   134fe:	b2db      	uxtb	r3, r3
   13500:	4a13      	ldr	r2, [pc, #76]	; (13550 <InitializeUart2()+0xf8>)
   13502:	f043 0306 	orr.w	r3, r3, #6
   13506:	b2db      	uxtb	r3, r3
   13508:	7213      	strb	r3, [r2, #8]
    //Set TER
    LPC_UART2->TER |= (0b1<<7);
   1350a:	4b11      	ldr	r3, [pc, #68]	; (13550 <InitializeUart2()+0xf8>)
   1350c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   13510:	b2db      	uxtb	r3, r3
   13512:	4a0f      	ldr	r2, [pc, #60]	; (13550 <InitializeUart2()+0xf8>)
   13514:	f063 037f 	orn	r3, r3, #127	; 0x7f
   13518:	b2db      	uxtb	r3, r3
   1351a:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
    //Set Receive Data
    LPC_UART2->IER |= (1 << 0);
   1351e:	4b0c      	ldr	r3, [pc, #48]	; (13550 <InitializeUart2()+0xf8>)
   13520:	685b      	ldr	r3, [r3, #4]
   13522:	4a0b      	ldr	r2, [pc, #44]	; (13550 <InitializeUart2()+0xf8>)
   13524:	f043 0301 	orr.w	r3, r3, #1
   13528:	6053      	str	r3, [r2, #4]
  // Init PINSEL, baud rate, frame size, etc. 
    //NVIC_EnableIRQ(UART2_IRQn);
    RegisterIsr(UART2_IRQn, Uart2Interrupt);
   1352a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1352e:	2201      	movs	r2, #1
   13530:	4909      	ldr	r1, [pc, #36]	; (13558 <InitializeUart2()+0x100>)
   13532:	2007      	movs	r0, #7
   13534:	f001 fd0c 	bl	14f50 <RegisterIsr(IRQn, void (*)(), bool, long)>
   13538:	4623      	mov	r3, r4
   1353a:	4619      	mov	r1, r3
   1353c:	4802      	ldr	r0, [pc, #8]	; (13548 <InitializeUart2()+0xf0>)
   1353e:	f001 fe6f 	bl	15220 <__cyg_profile_func_exit>
}
   13542:	bf00      	nop
   13544:	bd10      	pop	{r4, pc}
   13546:	bf00      	nop
   13548:	00013459 	.word	0x00013459
   1354c:	400fc000 	.word	0x400fc000
   13550:	40098000 	.word	0x40098000
   13554:	10000a74 	.word	0x10000a74
   13558:	000135f5 	.word	0x000135f5

0001355c <Uart2Send(char)>:

void Uart2Send(char num)
{   
   1355c:	b510      	push	{r4, lr}
   1355e:	b084      	sub	sp, #16
   13560:	4674      	mov	r4, lr
   13562:	4603      	mov	r3, r0
   13564:	f88d 3007 	strb.w	r3, [sp, #7]
   13568:	4623      	mov	r3, r4
   1356a:	4619      	mov	r1, r3
   1356c:	481d      	ldr	r0, [pc, #116]	; (135e4 <Uart2Send(char)+0x88>)
   1356e:	f001 fe43 	bl	151f8 <__cyg_profile_func_enter>
    
        while(!(LPC_UART2->LSR & (1 << 5) ) );
   13572:	4b1d      	ldr	r3, [pc, #116]	; (135e8 <Uart2Send(char)+0x8c>)
   13574:	7d1b      	ldrb	r3, [r3, #20]
   13576:	b2db      	uxtb	r3, r3
   13578:	f003 0320 	and.w	r3, r3, #32
   1357c:	2b00      	cmp	r3, #0
   1357e:	bf0c      	ite	eq
   13580:	2301      	moveq	r3, #1
   13582:	2300      	movne	r3, #0
   13584:	b2db      	uxtb	r3, r3
   13586:	2b00      	cmp	r3, #0
   13588:	d000      	beq.n	1358c <Uart2Send(char)+0x30>
   1358a:	e7f2      	b.n	13572 <Uart2Send(char)+0x16>
        char char_val = 0;
   1358c:	2300      	movs	r3, #0
   1358e:	f88d 300f 	strb.w	r3, [sp, #15]
        char char_val2 = 0;
   13592:	2300      	movs	r3, #0
   13594:	f88d 300e 	strb.w	r3, [sp, #14]
        char_val2 = num;
   13598:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1359c:	f88d 300e 	strb.w	r3, [sp, #14]
        char_val = num + '0';
   135a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
   135a4:	3330      	adds	r3, #48	; 0x30
   135a6:	f88d 300f 	strb.w	r3, [sp, #15]
        if(char_val >= '0' && char_val <= '9') 
   135aa:	f89d 300f 	ldrb.w	r3, [sp, #15]
   135ae:	2b2f      	cmp	r3, #47	; 0x2f
   135b0:	d908      	bls.n	135c4 <Uart2Send(char)+0x68>
   135b2:	f89d 300f 	ldrb.w	r3, [sp, #15]
   135b6:	2b39      	cmp	r3, #57	; 0x39
   135b8:	d804      	bhi.n	135c4 <Uart2Send(char)+0x68>
        LPC_UART2->THR = char_val;
   135ba:	4a0b      	ldr	r2, [pc, #44]	; (135e8 <Uart2Send(char)+0x8c>)
   135bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
   135c0:	7013      	strb	r3, [r2, #0]
   135c2:	e003      	b.n	135cc <Uart2Send(char)+0x70>
        else 
        LPC_UART2->THR = char_val2;
   135c4:	4a08      	ldr	r2, [pc, #32]	; (135e8 <Uart2Send(char)+0x8c>)
   135c6:	f89d 300e 	ldrb.w	r3, [sp, #14]
   135ca:	7013      	strb	r3, [r2, #0]
        oled_terminal.printf("Letter sent\n");
   135cc:	4907      	ldr	r1, [pc, #28]	; (135ec <Uart2Send(char)+0x90>)
   135ce:	4808      	ldr	r0, [pc, #32]	; (135f0 <Uart2Send(char)+0x94>)
   135d0:	f7ff fdd0 	bl	13174 <OledTerminal::printf(char const*, ...)>
   135d4:	4623      	mov	r3, r4
   135d6:	4619      	mov	r1, r3
   135d8:	4802      	ldr	r0, [pc, #8]	; (135e4 <Uart2Send(char)+0x88>)
   135da:	f001 fe21 	bl	15220 <__cyg_profile_func_exit>
       
   
}
   135de:	bf00      	nop
   135e0:	b004      	add	sp, #16
   135e2:	bd10      	pop	{r4, pc}
   135e4:	0001355d 	.word	0x0001355d
   135e8:	40098000 	.word	0x40098000
   135ec:	0001a714 	.word	0x0001a714
   135f0:	10000a78 	.word	0x10000a78

000135f4 <Uart2Interrupt()>:
    array[0]= LPC_UART2->RBR;
    oled_terminal.printf("Data: %c\n",array[0]);
    
}
void Uart2Interrupt()
{
   135f4:	b510      	push	{r4, lr}
   135f6:	b082      	sub	sp, #8
   135f8:	4674      	mov	r4, lr
   135fa:	4623      	mov	r3, r4
   135fc:	4619      	mov	r1, r3
   135fe:	480f      	ldr	r0, [pc, #60]	; (1363c <Uart2Interrupt()+0x48>)
   13600:	f001 fdfa 	bl	151f8 <__cyg_profile_func_enter>
  char x=0;
   13604:	2300      	movs	r3, #0
   13606:	f88d 3007 	strb.w	r3, [sp, #7]
  oled_terminal.printf("In Here\n");
   1360a:	490d      	ldr	r1, [pc, #52]	; (13640 <Uart2Interrupt()+0x4c>)
   1360c:	480d      	ldr	r0, [pc, #52]	; (13644 <Uart2Interrupt()+0x50>)
   1360e:	f7ff fdb1 	bl	13174 <OledTerminal::printf(char const*, ...)>
  x = LPC_UART2->RBR;
   13612:	4b0d      	ldr	r3, [pc, #52]	; (13648 <Uart2Interrupt()+0x54>)
   13614:	781b      	ldrb	r3, [r3, #0]
   13616:	b2db      	uxtb	r3, r3
   13618:	f88d 3007 	strb.w	r3, [sp, #7]
  
  xQueueSendFromISR(Global_Queue_Handle, &x, NULL);
   1361c:	4b0b      	ldr	r3, [pc, #44]	; (1364c <Uart2Interrupt()+0x58>)
   1361e:	6818      	ldr	r0, [r3, #0]
   13620:	f10d 0107 	add.w	r1, sp, #7
   13624:	2300      	movs	r3, #0
   13626:	2200      	movs	r2, #0
   13628:	f002 fd0d 	bl	16046 <xQueueGenericSendFromISR>
   1362c:	4623      	mov	r3, r4
   1362e:	4619      	mov	r1, r3
   13630:	4802      	ldr	r0, [pc, #8]	; (1363c <Uart2Interrupt()+0x48>)
   13632:	f001 fdf5 	bl	15220 <__cyg_profile_func_exit>
}
   13636:	bf00      	nop
   13638:	b002      	add	sp, #8
   1363a:	bd10      	pop	{r4, pc}
   1363c:	000135f5 	.word	0x000135f5
   13640:	0001a730 	.word	0x0001a730
   13644:	10000a78 	.word	0x10000a78
   13648:	40098000 	.word	0x40098000
   1364c:	10000a70 	.word	0x10000a70

00013650 <vReceiveByteOverUartTask(void*)>:
void vReceiveByteOverUartTask(void * pvParamater)
{
   13650:	b500      	push	{lr}
   13652:	b087      	sub	sp, #28
   13654:	4673      	mov	r3, lr
   13656:	9001      	str	r0, [sp, #4]
   13658:	4619      	mov	r1, r3
   1365a:	481f      	ldr	r0, [pc, #124]	; (136d8 <vReceiveByteOverUartTask(void*)+0x88>)
   1365c:	f001 fdcc 	bl	151f8 <__cyg_profile_func_enter>
  char data = 0;
   13660:	2300      	movs	r3, #0
   13662:	f88d 300f 	strb.w	r3, [sp, #15]
  char Rx_x[]={};
  uint8_t index = 0;
   13666:	2300      	movs	r3, #0
   13668:	f88d 3017 	strb.w	r3, [sp, #23]
  while (true) 
  {
    if (xQueueReceive(Global_Queue_Handle,&data, portMAX_DELAY)) 
   1366c:	4b1b      	ldr	r3, [pc, #108]	; (136dc <vReceiveByteOverUartTask(void*)+0x8c>)
   1366e:	681b      	ldr	r3, [r3, #0]
   13670:	f10d 010f 	add.w	r1, sp, #15
   13674:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13678:	4618      	mov	r0, r3
   1367a:	f002 fd3d 	bl	160f8 <xQueueReceive>
   1367e:	4603      	mov	r3, r0
   13680:	2b00      	cmp	r3, #0
   13682:	bf14      	ite	ne
   13684:	2301      	movne	r3, #1
   13686:	2300      	moveq	r3, #0
   13688:	b2db      	uxtb	r3, r3
   1368a:	2b00      	cmp	r3, #0
   1368c:	d00f      	beq.n	136ae <vReceiveByteOverUartTask(void*)+0x5e>
    {
      printf("Here in Task\n");
   1368e:	4814      	ldr	r0, [pc, #80]	; (136e0 <vReceiveByteOverUartTask(void*)+0x90>)
   13690:	f001 fd82 	bl	15198 <puts>
     // printf("Data : %c\n" , Rx_x);
      Rx_x[index] = data;
   13694:	f89d 3017 	ldrb.w	r3, [sp, #23]
   13698:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1369c:	a906      	add	r1, sp, #24
   1369e:	440b      	add	r3, r1
   136a0:	f803 2c0c 	strb.w	r2, [r3, #-12]
      index++;
   136a4:	f89d 3017 	ldrb.w	r3, [sp, #23]
   136a8:	3301      	adds	r3, #1
   136aa:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    if(index == 3)
   136ae:	f89d 3017 	ldrb.w	r3, [sp, #23]
   136b2:	2b03      	cmp	r3, #3
   136b4:	d1da      	bne.n	1366c <vReceiveByteOverUartTask(void*)+0x1c>
    {
        for(int i = 0; i<3; i++)
   136b6:	2300      	movs	r3, #0
   136b8:	9304      	str	r3, [sp, #16]
   136ba:	9b04      	ldr	r3, [sp, #16]
   136bc:	2b02      	cmp	r3, #2
   136be:	dcd5      	bgt.n	1366c <vReceiveByteOverUartTask(void*)+0x1c>
        {
            printf("Recieve Data: %c\n",Rx_x[i]);
   136c0:	aa03      	add	r2, sp, #12
   136c2:	9b04      	ldr	r3, [sp, #16]
   136c4:	4413      	add	r3, r2
   136c6:	781b      	ldrb	r3, [r3, #0]
   136c8:	4619      	mov	r1, r3
   136ca:	4806      	ldr	r0, [pc, #24]	; (136e4 <vReceiveByteOverUartTask(void*)+0x94>)
   136cc:	f004 f978 	bl	179c0 <printf>
        for(int i = 0; i<3; i++)
   136d0:	9b04      	ldr	r3, [sp, #16]
   136d2:	3301      	adds	r3, #1
   136d4:	9304      	str	r3, [sp, #16]
   136d6:	e7f0      	b.n	136ba <vReceiveByteOverUartTask(void*)+0x6a>
   136d8:	00013651 	.word	0x00013651
   136dc:	10000a70 	.word	0x10000a70
   136e0:	0001a73c 	.word	0x0001a73c
   136e4:	0001a74c 	.word	0x0001a74c

000136e8 <__static_initialization_and_destruction_0(int, int)>:
        }
    }
  }
   136e8:	b510      	push	{r4, lr}
   136ea:	b082      	sub	sp, #8
   136ec:	4674      	mov	r4, lr
   136ee:	9001      	str	r0, [sp, #4]
   136f0:	9100      	str	r1, [sp, #0]
   136f2:	4623      	mov	r3, r4
   136f4:	4619      	mov	r1, r3
   136f6:	480b      	ldr	r0, [pc, #44]	; (13724 <__static_initialization_and_destruction_0(int, int)+0x3c>)
   136f8:	f001 fd7e 	bl	151f8 <__cyg_profile_func_enter>
   136fc:	9b01      	ldr	r3, [sp, #4]
   136fe:	2b01      	cmp	r3, #1
   13700:	d107      	bne.n	13712 <__static_initialization_and_destruction_0(int, int)+0x2a>
   13702:	9b00      	ldr	r3, [sp, #0]
   13704:	f64f 72ff 	movw	r2, #65535	; 0xffff
   13708:	4293      	cmp	r3, r2
   1370a:	d102      	bne.n	13712 <__static_initialization_and_destruction_0(int, int)+0x2a>
OledTerminal oled_terminal;
   1370c:	4806      	ldr	r0, [pc, #24]	; (13728 <__static_initialization_and_destruction_0(int, int)+0x40>)
   1370e:	f7ff faef 	bl	12cf0 <OledTerminal::OledTerminal()>
   13712:	4623      	mov	r3, r4
   13714:	4619      	mov	r1, r3
   13716:	4803      	ldr	r0, [pc, #12]	; (13724 <__static_initialization_and_destruction_0(int, int)+0x3c>)
   13718:	f001 fd82 	bl	15220 <__cyg_profile_func_exit>
   1371c:	bf00      	nop
   1371e:	b002      	add	sp, #8
   13720:	bd10      	pop	{r4, pc}
   13722:	bf00      	nop
   13724:	000136e9 	.word	0x000136e9
   13728:	10000a78 	.word	0x10000a78

0001372c <_GLOBAL__sub_I_Global_Queue_Handle>:
   1372c:	b510      	push	{r4, lr}
   1372e:	4674      	mov	r4, lr
   13730:	4623      	mov	r3, r4
   13732:	4619      	mov	r1, r3
   13734:	4806      	ldr	r0, [pc, #24]	; (13750 <_GLOBAL__sub_I_Global_Queue_Handle+0x24>)
   13736:	f001 fd5f 	bl	151f8 <__cyg_profile_func_enter>
   1373a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1373e:	2001      	movs	r0, #1
   13740:	f7ff ffd2 	bl	136e8 <__static_initialization_and_destruction_0(int, int)>
   13744:	4623      	mov	r3, r4
   13746:	4619      	mov	r1, r3
   13748:	4801      	ldr	r0, [pc, #4]	; (13750 <_GLOBAL__sub_I_Global_Queue_Handle+0x24>)
   1374a:	f001 fd69 	bl	15220 <__cyg_profile_func_exit>
   1374e:	bd10      	pop	{r4, pc}
   13750:	0001372d 	.word	0x0001372d

00013754 <pinconn::clear7(unsigned char, unsigned char)>:
    else
    {
        printf("Not a MOSI port");
    }
}
void pinconn::clear7(uint8_t port, uint8_t pin){
   13754:	b510      	push	{r4, lr}
   13756:	b082      	sub	sp, #8
   13758:	4674      	mov	r4, lr
   1375a:	9001      	str	r0, [sp, #4]
   1375c:	460b      	mov	r3, r1
   1375e:	f88d 3003 	strb.w	r3, [sp, #3]
   13762:	4613      	mov	r3, r2
   13764:	f88d 3002 	strb.w	r3, [sp, #2]
   13768:	4623      	mov	r3, r4
   1376a:	4619      	mov	r1, r3
   1376c:	4810      	ldr	r0, [pc, #64]	; (137b0 <pinconn::clear7(unsigned char, unsigned char)+0x5c>)
   1376e:	f001 fd43 	bl	151f8 <__cyg_profile_func_enter>
    *pincon[port][pin] &= ~(0x7F<<0);
   13772:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13776:	f89d 3002 	ldrb.w	r3, [sp, #2]
   1377a:	490e      	ldr	r1, [pc, #56]	; (137b4 <pinconn::clear7(unsigned char, unsigned char)+0x60>)
   1377c:	0152      	lsls	r2, r2, #5
   1377e:	4413      	add	r3, r2
   13780:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13784:	681a      	ldr	r2, [r3, #0]
   13786:	f89d 1003 	ldrb.w	r1, [sp, #3]
   1378a:	f89d 3002 	ldrb.w	r3, [sp, #2]
   1378e:	4809      	ldr	r0, [pc, #36]	; (137b4 <pinconn::clear7(unsigned char, unsigned char)+0x60>)
   13790:	0149      	lsls	r1, r1, #5
   13792:	440b      	add	r3, r1
   13794:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13798:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1379c:	601a      	str	r2, [r3, #0]
   1379e:	4623      	mov	r3, r4
   137a0:	4619      	mov	r1, r3
   137a2:	4803      	ldr	r0, [pc, #12]	; (137b0 <pinconn::clear7(unsigned char, unsigned char)+0x5c>)
   137a4:	f001 fd3c 	bl	15220 <__cyg_profile_func_exit>
}
   137a8:	bf00      	nop
   137aa:	b002      	add	sp, #8
   137ac:	bd10      	pop	{r4, pc}
   137ae:	bf00      	nop
   137b0:	00013755 	.word	0x00013755
   137b4:	1000045c 	.word	0x1000045c

000137b8 <pinconn::uart2_txd(unsigned char, unsigned char)>:
void pinconn::uart2_txd(uint8_t port, uint8_t pin){ 
   137b8:	b510      	push	{r4, lr}
   137ba:	b082      	sub	sp, #8
   137bc:	4674      	mov	r4, lr
   137be:	9001      	str	r0, [sp, #4]
   137c0:	460b      	mov	r3, r1
   137c2:	f88d 3003 	strb.w	r3, [sp, #3]
   137c6:	4613      	mov	r3, r2
   137c8:	f88d 3002 	strb.w	r3, [sp, #2]
   137cc:	4623      	mov	r3, r4
   137ce:	4619      	mov	r1, r3
   137d0:	4827      	ldr	r0, [pc, #156]	; (13870 <pinconn::uart2_txd(unsigned char, unsigned char)+0xb8>)
   137d2:	f001 fd11 	bl	151f8 <__cyg_profile_func_enter>
    clear7(port,pin);
   137d6:	f89d 2002 	ldrb.w	r2, [sp, #2]
   137da:	f89d 3003 	ldrb.w	r3, [sp, #3]
   137de:	4619      	mov	r1, r3
   137e0:	9801      	ldr	r0, [sp, #4]
   137e2:	f7ff ffb7 	bl	13754 <pinconn::clear7(unsigned char, unsigned char)>
    if(((port == 0) && (pin==10))){
   137e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
   137ea:	2b00      	cmp	r3, #0
   137ec:	d11a      	bne.n	13824 <pinconn::uart2_txd(unsigned char, unsigned char)+0x6c>
   137ee:	f89d 3002 	ldrb.w	r3, [sp, #2]
   137f2:	2b0a      	cmp	r3, #10
   137f4:	d116      	bne.n	13824 <pinconn::uart2_txd(unsigned char, unsigned char)+0x6c>
        *pincon[port][pin] |= (1<<1);
   137f6:	f89d 2003 	ldrb.w	r2, [sp, #3]
   137fa:	f89d 3002 	ldrb.w	r3, [sp, #2]
   137fe:	491d      	ldr	r1, [pc, #116]	; (13874 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   13800:	0152      	lsls	r2, r2, #5
   13802:	4413      	add	r3, r2
   13804:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13808:	681a      	ldr	r2, [r3, #0]
   1380a:	f89d 1003 	ldrb.w	r1, [sp, #3]
   1380e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13812:	4818      	ldr	r0, [pc, #96]	; (13874 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   13814:	0149      	lsls	r1, r1, #5
   13816:	440b      	add	r3, r1
   13818:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1381c:	f042 0202 	orr.w	r2, r2, #2
   13820:	601a      	str	r2, [r3, #0]
   13822:	e01d      	b.n	13860 <pinconn::uart2_txd(unsigned char, unsigned char)+0xa8>
    }
    else if ((port == 2) && (pin==8))
   13824:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13828:	2b02      	cmp	r3, #2
   1382a:	d119      	bne.n	13860 <pinconn::uart2_txd(unsigned char, unsigned char)+0xa8>
   1382c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13830:	2b08      	cmp	r3, #8
   13832:	d115      	bne.n	13860 <pinconn::uart2_txd(unsigned char, unsigned char)+0xa8>
    {
        *pincon[port][pin] |= (0b010);
   13834:	f89d 2003 	ldrb.w	r2, [sp, #3]
   13838:	f89d 3002 	ldrb.w	r3, [sp, #2]
   1383c:	490d      	ldr	r1, [pc, #52]	; (13874 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   1383e:	0152      	lsls	r2, r2, #5
   13840:	4413      	add	r3, r2
   13842:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13846:	681a      	ldr	r2, [r3, #0]
   13848:	f89d 1003 	ldrb.w	r1, [sp, #3]
   1384c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13850:	4808      	ldr	r0, [pc, #32]	; (13874 <pinconn::uart2_txd(unsigned char, unsigned char)+0xbc>)
   13852:	0149      	lsls	r1, r1, #5
   13854:	440b      	add	r3, r1
   13856:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1385a:	f042 0202 	orr.w	r2, r2, #2
   1385e:	601a      	str	r2, [r3, #0]
   13860:	4623      	mov	r3, r4
   13862:	4619      	mov	r1, r3
   13864:	4802      	ldr	r0, [pc, #8]	; (13870 <pinconn::uart2_txd(unsigned char, unsigned char)+0xb8>)
   13866:	f001 fcdb 	bl	15220 <__cyg_profile_func_exit>
    }
 }    
   1386a:	bf00      	nop
   1386c:	b002      	add	sp, #8
   1386e:	bd10      	pop	{r4, pc}
   13870:	000137b9 	.word	0x000137b9
   13874:	1000045c 	.word	0x1000045c

00013878 <pinconn::uart2_rxd(unsigned char, unsigned char)>:
 void pinconn::uart2_rxd(uint8_t port, uint8_t pin){
   13878:	b510      	push	{r4, lr}
   1387a:	b082      	sub	sp, #8
   1387c:	4674      	mov	r4, lr
   1387e:	9001      	str	r0, [sp, #4]
   13880:	460b      	mov	r3, r1
   13882:	f88d 3003 	strb.w	r3, [sp, #3]
   13886:	4613      	mov	r3, r2
   13888:	f88d 3002 	strb.w	r3, [sp, #2]
   1388c:	4623      	mov	r3, r4
   1388e:	4619      	mov	r1, r3
   13890:	4827      	ldr	r0, [pc, #156]	; (13930 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xb8>)
   13892:	f001 fcb1 	bl	151f8 <__cyg_profile_func_enter>
    clear7(port,pin);
   13896:	f89d 2002 	ldrb.w	r2, [sp, #2]
   1389a:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1389e:	4619      	mov	r1, r3
   138a0:	9801      	ldr	r0, [sp, #4]
   138a2:	f7ff ff57 	bl	13754 <pinconn::clear7(unsigned char, unsigned char)>
    if(((port == 0) && (pin==11))){
   138a6:	f89d 3003 	ldrb.w	r3, [sp, #3]
   138aa:	2b00      	cmp	r3, #0
   138ac:	d11a      	bne.n	138e4 <pinconn::uart2_rxd(unsigned char, unsigned char)+0x6c>
   138ae:	f89d 3002 	ldrb.w	r3, [sp, #2]
   138b2:	2b0b      	cmp	r3, #11
   138b4:	d116      	bne.n	138e4 <pinconn::uart2_rxd(unsigned char, unsigned char)+0x6c>
    *pincon[port][pin] |= (1<<1);
   138b6:	f89d 2003 	ldrb.w	r2, [sp, #3]
   138ba:	f89d 3002 	ldrb.w	r3, [sp, #2]
   138be:	491d      	ldr	r1, [pc, #116]	; (13934 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   138c0:	0152      	lsls	r2, r2, #5
   138c2:	4413      	add	r3, r2
   138c4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   138c8:	681a      	ldr	r2, [r3, #0]
   138ca:	f89d 1003 	ldrb.w	r1, [sp, #3]
   138ce:	f89d 3002 	ldrb.w	r3, [sp, #2]
   138d2:	4818      	ldr	r0, [pc, #96]	; (13934 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   138d4:	0149      	lsls	r1, r1, #5
   138d6:	440b      	add	r3, r1
   138d8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   138dc:	f042 0202 	orr.w	r2, r2, #2
   138e0:	601a      	str	r2, [r3, #0]
   138e2:	e01d      	b.n	13920 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xa8>
    }
    else if ((port == 2) && (pin==9))
   138e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   138e8:	2b02      	cmp	r3, #2
   138ea:	d119      	bne.n	13920 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xa8>
   138ec:	f89d 3002 	ldrb.w	r3, [sp, #2]
   138f0:	2b09      	cmp	r3, #9
   138f2:	d115      	bne.n	13920 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xa8>
    {
        *pincon[port][pin] |= (0b010);
   138f4:	f89d 2003 	ldrb.w	r2, [sp, #3]
   138f8:	f89d 3002 	ldrb.w	r3, [sp, #2]
   138fc:	490d      	ldr	r1, [pc, #52]	; (13934 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   138fe:	0152      	lsls	r2, r2, #5
   13900:	4413      	add	r3, r2
   13902:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13906:	681a      	ldr	r2, [r3, #0]
   13908:	f89d 1003 	ldrb.w	r1, [sp, #3]
   1390c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   13910:	4808      	ldr	r0, [pc, #32]	; (13934 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xbc>)
   13912:	0149      	lsls	r1, r1, #5
   13914:	440b      	add	r3, r1
   13916:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1391a:	f042 0202 	orr.w	r2, r2, #2
   1391e:	601a      	str	r2, [r3, #0]
   13920:	4623      	mov	r3, r4
   13922:	4619      	mov	r1, r3
   13924:	4802      	ldr	r0, [pc, #8]	; (13930 <pinconn::uart2_rxd(unsigned char, unsigned char)+0xb8>)
   13926:	f001 fc7b 	bl	15220 <__cyg_profile_func_exit>
    }
 }
   1392a:	bf00      	nop
   1392c:	b002      	add	sp, #8
   1392e:	bd10      	pop	{r4, pc}
   13930:	00013879 	.word	0x00013879
   13934:	1000045c 	.word	0x1000045c

00013938 <SetUptimeFunction(unsigned long long (*)())>:
{
   13938:	b510      	push	{r4, lr}
   1393a:	b082      	sub	sp, #8
   1393c:	4674      	mov	r4, lr
   1393e:	9001      	str	r0, [sp, #4]
   13940:	4623      	mov	r3, r4
   13942:	4619      	mov	r1, r3
   13944:	4806      	ldr	r0, [pc, #24]	; (13960 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   13946:	f001 fc57 	bl	151f8 <__cyg_profile_func_enter>
  Uptime = uptime_function;
   1394a:	4a06      	ldr	r2, [pc, #24]	; (13964 <SetUptimeFunction(unsigned long long (*)())+0x2c>)
   1394c:	9b01      	ldr	r3, [sp, #4]
   1394e:	6013      	str	r3, [r2, #0]
   13950:	4623      	mov	r3, r4
   13952:	4619      	mov	r1, r3
   13954:	4802      	ldr	r0, [pc, #8]	; (13960 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   13956:	f001 fc63 	bl	15220 <__cyg_profile_func_exit>
}
   1395a:	bf00      	nop
   1395c:	b002      	add	sp, #8
   1395e:	bd10      	pop	{r4, pc}
   13960:	00013939 	.word	0x00013939
   13964:	10000004 	.word	0x10000004

00013968 <SystemTimer::DisableTimer()>:
  /// system_timer_isr defaults to nullptr. The actual SystemTickHandler should
  /// check if the isr is set to nullptr, and if it is, turn off the timer, if
  /// set a proper function then execute it.
  inline static IsrPointer system_timer_isr = nullptr;
  /// WARNING: Doing so will most likely disable FreeRTOS
  static void DisableTimer()
   13968:	b510      	push	{r4, lr}
   1396a:	4674      	mov	r4, lr
   1396c:	4623      	mov	r3, r4
   1396e:	4619      	mov	r1, r3
   13970:	480a      	ldr	r0, [pc, #40]	; (1399c <SystemTimer::DisableTimer()+0x34>)
   13972:	f001 fc41 	bl	151f8 <__cyg_profile_func_enter>
  {
    sys_tick->LOAD = 0;
   13976:	4b0a      	ldr	r3, [pc, #40]	; (139a0 <SystemTimer::DisableTimer()+0x38>)
   13978:	681b      	ldr	r3, [r3, #0]
   1397a:	2200      	movs	r2, #0
   1397c:	605a      	str	r2, [r3, #4]
    sys_tick->VAL  = 0;
   1397e:	4b08      	ldr	r3, [pc, #32]	; (139a0 <SystemTimer::DisableTimer()+0x38>)
   13980:	681b      	ldr	r3, [r3, #0]
   13982:	2200      	movs	r2, #0
   13984:	609a      	str	r2, [r3, #8]
    sys_tick->CTRL = 0;
   13986:	4b06      	ldr	r3, [pc, #24]	; (139a0 <SystemTimer::DisableTimer()+0x38>)
   13988:	681b      	ldr	r3, [r3, #0]
   1398a:	2200      	movs	r2, #0
   1398c:	601a      	str	r2, [r3, #0]
   1398e:	4623      	mov	r3, r4
   13990:	4619      	mov	r1, r3
   13992:	4802      	ldr	r0, [pc, #8]	; (1399c <SystemTimer::DisableTimer()+0x34>)
   13994:	f001 fc44 	bl	15220 <__cyg_profile_func_exit>
  }
   13998:	bf00      	nop
   1399a:	bd10      	pop	{r4, pc}
   1399c:	00013969 	.word	0x00013969
   139a0:	1000075c 	.word	0x1000075c

000139a4 <SystemTimer::SystemTimerHandler()>:
  static void SystemTimerHandler()
   139a4:	b510      	push	{r4, lr}
   139a6:	4674      	mov	r4, lr
   139a8:	4623      	mov	r3, r4
   139aa:	4619      	mov	r1, r3
   139ac:	4808      	ldr	r0, [pc, #32]	; (139d0 <SystemTimer::SystemTimerHandler()+0x2c>)
   139ae:	f001 fc23 	bl	151f8 <__cyg_profile_func_enter>
  {
    // This assumes that SysTickHandler is called every millisecond.
    // Changing that frequency will distort the milliseconds time.
    if (system_timer_isr != nullptr)
   139b2:	4b08      	ldr	r3, [pc, #32]	; (139d4 <SystemTimer::SystemTimerHandler()+0x30>)
   139b4:	681b      	ldr	r3, [r3, #0]
   139b6:	2b00      	cmp	r3, #0
   139b8:	d002      	beq.n	139c0 <SystemTimer::SystemTimerHandler()+0x1c>
    {
      system_timer_isr();
   139ba:	4b06      	ldr	r3, [pc, #24]	; (139d4 <SystemTimer::SystemTimerHandler()+0x30>)
   139bc:	681b      	ldr	r3, [r3, #0]
   139be:	4798      	blx	r3
   139c0:	4623      	mov	r3, r4
   139c2:	4619      	mov	r1, r3
   139c4:	4802      	ldr	r0, [pc, #8]	; (139d0 <SystemTimer::SystemTimerHandler()+0x2c>)
   139c6:	f001 fc2b 	bl	15220 <__cyg_profile_func_exit>
    }
  }
   139ca:	bf00      	nop
   139cc:	bd10      	pop	{r4, pc}
   139ce:	bf00      	nop
   139d0:	000139a5 	.word	0x000139a5
   139d4:	10001240 	.word	0x10001240

000139d8 <SystemTimer::SetIsrFunction(void (*)())>:
  constexpr SystemTimer() {}
  void SetIsrFunction(IsrPointer isr) override
   139d8:	b510      	push	{r4, lr}
   139da:	b082      	sub	sp, #8
   139dc:	4674      	mov	r4, lr
   139de:	9001      	str	r0, [sp, #4]
   139e0:	9100      	str	r1, [sp, #0]
   139e2:	4623      	mov	r3, r4
   139e4:	4619      	mov	r1, r3
   139e6:	4807      	ldr	r0, [pc, #28]	; (13a04 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   139e8:	f001 fc06 	bl	151f8 <__cyg_profile_func_enter>
  {
    system_timer_isr = isr;
   139ec:	4a06      	ldr	r2, [pc, #24]	; (13a08 <SystemTimer::SetIsrFunction(void (*)())+0x30>)
   139ee:	9b00      	ldr	r3, [sp, #0]
   139f0:	6013      	str	r3, [r2, #0]
   139f2:	4623      	mov	r3, r4
   139f4:	4619      	mov	r1, r3
   139f6:	4803      	ldr	r0, [pc, #12]	; (13a04 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   139f8:	f001 fc12 	bl	15220 <__cyg_profile_func_exit>
  }
   139fc:	bf00      	nop
   139fe:	b002      	add	sp, #8
   13a00:	bd10      	pop	{r4, pc}
   13a02:	bf00      	nop
   13a04:	000139d9 	.word	0x000139d9
   13a08:	10001240 	.word	0x10001240

00013a0c <SystemTimer::StartTimer()>:
  bool StartTimer() override
   13a0c:	b530      	push	{r4, r5, lr}
   13a0e:	b085      	sub	sp, #20
   13a10:	4675      	mov	r5, lr
   13a12:	9001      	str	r0, [sp, #4]
   13a14:	462b      	mov	r3, r5
   13a16:	4619      	mov	r1, r3
   13a18:	4820      	ldr	r0, [pc, #128]	; (13a9c <SystemTimer::StartTimer()+0x90>)
   13a1a:	f001 fbed 	bl	151f8 <__cyg_profile_func_enter>
  {
    bool successful = false;
   13a1e:	2300      	movs	r3, #0
   13a20:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sys_tick->LOAD != 0)
   13a24:	4b1e      	ldr	r3, [pc, #120]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a26:	681b      	ldr	r3, [r3, #0]
   13a28:	685b      	ldr	r3, [r3, #4]
   13a2a:	2b00      	cmp	r3, #0
   13a2c:	bf14      	ite	ne
   13a2e:	2301      	movne	r3, #1
   13a30:	2300      	moveq	r3, #0
   13a32:	b2db      	uxtb	r3, r3
   13a34:	2b00      	cmp	r3, #0
   13a36:	d01e      	beq.n	13a76 <SystemTimer::StartTimer()+0x6a>
    {
      sys_tick->VAL = 0;
   13a38:	4b19      	ldr	r3, [pc, #100]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a3a:	681b      	ldr	r3, [r3, #0]
   13a3c:	2200      	movs	r2, #0
   13a3e:	609a      	str	r2, [r3, #8]
      sys_tick->CTRL |= (1 << ControlBitMap::kTickInterupt);
   13a40:	4b17      	ldr	r3, [pc, #92]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a42:	681b      	ldr	r3, [r3, #0]
   13a44:	681a      	ldr	r2, [r3, #0]
   13a46:	4b16      	ldr	r3, [pc, #88]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a48:	681b      	ldr	r3, [r3, #0]
   13a4a:	f042 0202 	orr.w	r2, r2, #2
   13a4e:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kEnableCounter);
   13a50:	4b13      	ldr	r3, [pc, #76]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a52:	681b      	ldr	r3, [r3, #0]
   13a54:	681a      	ldr	r2, [r3, #0]
   13a56:	4b12      	ldr	r3, [pc, #72]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a58:	681b      	ldr	r3, [r3, #0]
   13a5a:	f042 0201 	orr.w	r2, r2, #1
   13a5e:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kClkSource);
   13a60:	4b0f      	ldr	r3, [pc, #60]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a62:	681b      	ldr	r3, [r3, #0]
   13a64:	681a      	ldr	r2, [r3, #0]
   13a66:	4b0e      	ldr	r3, [pc, #56]	; (13aa0 <SystemTimer::StartTimer()+0x94>)
   13a68:	681b      	ldr	r3, [r3, #0]
   13a6a:	f042 0204 	orr.w	r2, r2, #4
   13a6e:	601a      	str	r2, [r3, #0]
      successful = true;
   13a70:	2301      	movs	r3, #1
   13a72:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    RegisterIsr(SysTick_IRQn, SystemTimerHandler);
   13a76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13a7a:	2201      	movs	r2, #1
   13a7c:	4909      	ldr	r1, [pc, #36]	; (13aa4 <SystemTimer::StartTimer()+0x98>)
   13a7e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13a82:	f001 fa65 	bl	14f50 <RegisterIsr(IRQn, void (*)(), bool, long)>
    return successful;
   13a86:	f89d 400f 	ldrb.w	r4, [sp, #15]
   13a8a:	462b      	mov	r3, r5
   13a8c:	4619      	mov	r1, r3
   13a8e:	4803      	ldr	r0, [pc, #12]	; (13a9c <SystemTimer::StartTimer()+0x90>)
   13a90:	f001 fbc6 	bl	15220 <__cyg_profile_func_exit>
   13a94:	4623      	mov	r3, r4
  }
   13a96:	4618      	mov	r0, r3
   13a98:	b005      	add	sp, #20
   13a9a:	bd30      	pop	{r4, r5, pc}
   13a9c:	00013a0d 	.word	0x00013a0d
   13aa0:	1000075c 	.word	0x1000075c
   13aa4:	000139a5 	.word	0x000139a5

00013aa8 <SystemTimer::SetTickFrequency(unsigned long)>:
  ///          remainder will be returned.
  ///          If the freqency supplied is less then 2Hz, the function will
  ///          return without changing any hardware.
  ///          If the reload value exceeds the SysTick_LOAD_RELOAD_Msk, the
  ///          returned value is the SysTick_LOAD_RELOAD_Msk.
  uint32_t SetTickFrequency(uint32_t frequency) override
   13aa8:	b530      	push	{r4, r5, lr}
   13aaa:	b085      	sub	sp, #20
   13aac:	4675      	mov	r5, lr
   13aae:	9001      	str	r0, [sp, #4]
   13ab0:	9100      	str	r1, [sp, #0]
   13ab2:	462b      	mov	r3, r5
   13ab4:	4619      	mov	r1, r3
   13ab6:	481f      	ldr	r0, [pc, #124]	; (13b34 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   13ab8:	f001 fb9e 	bl	151f8 <__cyg_profile_func_enter>
  {
    if (frequency <= 1)
   13abc:	9b00      	ldr	r3, [sp, #0]
   13abe:	2b01      	cmp	r3, #1
   13ac0:	d801      	bhi.n	13ac6 <SystemTimer::SetTickFrequency(unsigned long)+0x1e>
    {
      return 0;
   13ac2:	2400      	movs	r4, #0
   13ac4:	e02d      	b.n	13b22 <SystemTimer::SetTickFrequency(unsigned long)+0x7a>
    }
    uint32_t reload_value = (GetSystemFrequency() / frequency) - 1;
   13ac6:	9b01      	ldr	r3, [sp, #4]
   13ac8:	1d1a      	adds	r2, r3, #4
   13aca:	9b01      	ldr	r3, [sp, #4]
   13acc:	685b      	ldr	r3, [r3, #4]
   13ace:	330c      	adds	r3, #12
   13ad0:	681b      	ldr	r3, [r3, #0]
   13ad2:	4610      	mov	r0, r2
   13ad4:	4798      	blx	r3
   13ad6:	4602      	mov	r2, r0
   13ad8:	9b00      	ldr	r3, [sp, #0]
   13ada:	fbb2 f3f3 	udiv	r3, r2, r3
   13ade:	3b01      	subs	r3, #1
   13ae0:	9303      	str	r3, [sp, #12]
    int remainder         = (GetSystemFrequency() % frequency);
   13ae2:	9b01      	ldr	r3, [sp, #4]
   13ae4:	1d1a      	adds	r2, r3, #4
   13ae6:	9b01      	ldr	r3, [sp, #4]
   13ae8:	685b      	ldr	r3, [r3, #4]
   13aea:	330c      	adds	r3, #12
   13aec:	681b      	ldr	r3, [r3, #0]
   13aee:	4610      	mov	r0, r2
   13af0:	4798      	blx	r3
   13af2:	4603      	mov	r3, r0
   13af4:	9a00      	ldr	r2, [sp, #0]
   13af6:	fbb3 f2f2 	udiv	r2, r3, r2
   13afa:	9900      	ldr	r1, [sp, #0]
   13afc:	fb01 f202 	mul.w	r2, r1, r2
   13b00:	1a9b      	subs	r3, r3, r2
   13b02:	9302      	str	r3, [sp, #8]
    if (reload_value > SysTick_LOAD_RELOAD_Msk)
   13b04:	9b03      	ldr	r3, [sp, #12]
   13b06:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   13b0a:	d305      	bcc.n	13b18 <SystemTimer::SetTickFrequency(unsigned long)+0x70>
    {
      reload_value = SysTick_LOAD_RELOAD_Msk;
   13b0c:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   13b10:	9303      	str	r3, [sp, #12]
      remainder    = SysTick_LOAD_RELOAD_Msk;
   13b12:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   13b16:	9302      	str	r3, [sp, #8]
    }
    sys_tick->LOAD = reload_value;
   13b18:	4b07      	ldr	r3, [pc, #28]	; (13b38 <SystemTimer::SetTickFrequency(unsigned long)+0x90>)
   13b1a:	681b      	ldr	r3, [r3, #0]
   13b1c:	9a03      	ldr	r2, [sp, #12]
   13b1e:	605a      	str	r2, [r3, #4]
    return remainder;
   13b20:	9c02      	ldr	r4, [sp, #8]
   13b22:	462b      	mov	r3, r5
   13b24:	4619      	mov	r1, r3
   13b26:	4803      	ldr	r0, [pc, #12]	; (13b34 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   13b28:	f001 fb7a 	bl	15220 <__cyg_profile_func_exit>
   13b2c:	4623      	mov	r3, r4
  }
   13b2e:	4618      	mov	r0, r3
   13b30:	b005      	add	sp, #20
   13b32:	bd30      	pop	{r4, r5, pc}
   13b34:	00013aa9 	.word	0x00013aa9
   13b38:	1000075c 	.word	0x1000075c

00013b3c <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>:
constexpr Type Value(Enum enum_type_value)
   13b3c:	b530      	push	{r4, r5, lr}
   13b3e:	b083      	sub	sp, #12
   13b40:	4675      	mov	r5, lr
   13b42:	4603      	mov	r3, r0
   13b44:	f88d 3007 	strb.w	r3, [sp, #7]
   13b48:	462b      	mov	r3, r5
   13b4a:	4619      	mov	r1, r3
   13b4c:	4806      	ldr	r0, [pc, #24]	; (13b68 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   13b4e:	f001 fb53 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   13b52:	f89d 4007 	ldrb.w	r4, [sp, #7]
   13b56:	462b      	mov	r3, r5
   13b58:	4619      	mov	r1, r3
   13b5a:	4803      	ldr	r0, [pc, #12]	; (13b68 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   13b5c:	f001 fb60 	bl	15220 <__cyg_profile_func_exit>
   13b60:	4623      	mov	r3, r4
}
   13b62:	4618      	mov	r0, r3
   13b64:	b003      	add	sp, #12
   13b66:	bd30      	pop	{r4, r5, pc}
   13b68:	00013b3d 	.word	0x00013b3d

00013b6c <Timer::DoNothingIsr()>:
    Lpc40xxSystemController::Peripherals::kTimer3
  };

  static constexpr IRQn kTimerIrq[] = { IRQn::TIMER0_IRQn, IRQn::TIMER1_IRQn,
                                        IRQn::TIMER2_IRQn, IRQn::TIMER3_IRQn };
  static void DoNothingIsr() {}
   13b6c:	b510      	push	{r4, lr}
   13b6e:	4674      	mov	r4, lr
   13b70:	4623      	mov	r3, r4
   13b72:	4619      	mov	r1, r3
   13b74:	4804      	ldr	r0, [pc, #16]	; (13b88 <Timer::DoNothingIsr()+0x1c>)
   13b76:	f001 fb3f 	bl	151f8 <__cyg_profile_func_enter>
   13b7a:	4623      	mov	r3, r4
   13b7c:	4619      	mov	r1, r3
   13b7e:	4802      	ldr	r0, [pc, #8]	; (13b88 <Timer::DoNothingIsr()+0x1c>)
   13b80:	f001 fb4e 	bl	15220 <__cyg_profile_func_exit>
   13b84:	bf00      	nop
   13b86:	bd10      	pop	{r4, pc}
   13b88:	00013b6d 	.word	0x00013b6d

00013b8c <Timer::Initialize(unsigned long, void (*)(), long)>:
  ///                  register will be 10 ms.
  /// @param isr an ISR that will fire when the condition set by SetTimer
  ///            method is achieved.
  /// @param priority sets the Timer interrupt's priority level, defaults to -1
  ///                 which uses the platforms default priority.
  void Initialize(uint32_t frequency, IsrPointer isr = DoNothingIsr,
   13b8c:	b510      	push	{r4, lr}
   13b8e:	b086      	sub	sp, #24
   13b90:	4674      	mov	r4, lr
   13b92:	9003      	str	r0, [sp, #12]
   13b94:	9102      	str	r1, [sp, #8]
   13b96:	9201      	str	r2, [sp, #4]
   13b98:	9300      	str	r3, [sp, #0]
   13b9a:	4623      	mov	r3, r4
   13b9c:	4619      	mov	r1, r3
   13b9e:	483e      	ldr	r0, [pc, #248]	; (13c98 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   13ba0:	f001 fb2a 	bl	151f8 <__cyg_profile_func_enter>
                  int32_t priority = -1) override final
  {
    PowerUpPeripheral(kPowerbit[channel_]);
   13ba4:	9b03      	ldr	r3, [sp, #12]
   13ba6:	1d18      	adds	r0, r3, #4
   13ba8:	9b03      	ldr	r3, [sp, #12]
   13baa:	685b      	ldr	r3, [r3, #4]
   13bac:	3314      	adds	r3, #20
   13bae:	681b      	ldr	r3, [r3, #0]
   13bb0:	9a03      	ldr	r2, [sp, #12]
   13bb2:	7a12      	ldrb	r2, [r2, #8]
   13bb4:	0092      	lsls	r2, r2, #2
   13bb6:	4939      	ldr	r1, [pc, #228]	; (13c9c <Timer::Initialize(unsigned long, void (*)(), long)+0x110>)
   13bb8:	440a      	add	r2, r1
   13bba:	4611      	mov	r1, r2
   13bbc:	4798      	blx	r3
    SJ2_ASSERT_FATAL(
   13bbe:	9b02      	ldr	r3, [sp, #8]
   13bc0:	2b00      	cmp	r3, #0
   13bc2:	d10d      	bne.n	13be0 <Timer::Initialize(unsigned long, void (*)(), long)+0x54>
   13bc4:	2384      	movs	r3, #132	; 0x84
   13bc6:	4a36      	ldr	r2, [pc, #216]	; (13ca0 <Timer::Initialize(unsigned long, void (*)(), long)+0x114>)
   13bc8:	4936      	ldr	r1, [pc, #216]	; (13ca4 <Timer::Initialize(unsigned long, void (*)(), long)+0x118>)
   13bca:	4837      	ldr	r0, [pc, #220]	; (13ca8 <Timer::Initialize(unsigned long, void (*)(), long)+0x11c>)
   13bcc:	f003 fef8 	bl	179c0 <printf>
   13bd0:	4836      	ldr	r0, [pc, #216]	; (13cac <Timer::Initialize(unsigned long, void (*)(), long)+0x120>)
   13bd2:	f001 fae1 	bl	15198 <puts>
   13bd6:	2100      	movs	r1, #0
   13bd8:	2001      	movs	r0, #1
   13bda:	f7fc fefb 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   13bde:	e7fe      	b.n	13bde <Timer::Initialize(unsigned long, void (*)(), long)+0x52>
        frequency != 0,
        "Cannot have zero ticks per microsecond, please choose 1 or more.");
    // Set Prescale register for Prescale Counter to milliseconds
    uint32_t prescaler = GetPeripheralFrequency() / frequency;
   13be0:	9b03      	ldr	r3, [sp, #12]
   13be2:	1d1a      	adds	r2, r3, #4
   13be4:	9b03      	ldr	r3, [sp, #12]
   13be6:	685b      	ldr	r3, [r3, #4]
   13be8:	3310      	adds	r3, #16
   13bea:	681b      	ldr	r3, [r3, #0]
   13bec:	4610      	mov	r0, r2
   13bee:	4798      	blx	r3
   13bf0:	4602      	mov	r2, r0
   13bf2:	9b02      	ldr	r3, [sp, #8]
   13bf4:	fbb2 f3f3 	udiv	r3, r2, r3
   13bf8:	9305      	str	r3, [sp, #20]
    tim_register[channel_]->PR &= ~(kClear << 1);
   13bfa:	9b03      	ldr	r3, [sp, #12]
   13bfc:	7a1b      	ldrb	r3, [r3, #8]
   13bfe:	461a      	mov	r2, r3
   13c00:	4b2b      	ldr	r3, [pc, #172]	; (13cb0 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   13c02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13c06:	68da      	ldr	r2, [r3, #12]
   13c08:	9b03      	ldr	r3, [sp, #12]
   13c0a:	7a1b      	ldrb	r3, [r3, #8]
   13c0c:	4619      	mov	r1, r3
   13c0e:	4b28      	ldr	r3, [pc, #160]	; (13cb0 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   13c10:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   13c14:	f002 0201 	and.w	r2, r2, #1
   13c18:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->PR |= (prescaler << 1);
   13c1a:	9b03      	ldr	r3, [sp, #12]
   13c1c:	7a1b      	ldrb	r3, [r3, #8]
   13c1e:	461a      	mov	r2, r3
   13c20:	4b23      	ldr	r3, [pc, #140]	; (13cb0 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   13c22:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13c26:	68d9      	ldr	r1, [r3, #12]
   13c28:	9b05      	ldr	r3, [sp, #20]
   13c2a:	005a      	lsls	r2, r3, #1
   13c2c:	9b03      	ldr	r3, [sp, #12]
   13c2e:	7a1b      	ldrb	r3, [r3, #8]
   13c30:	4618      	mov	r0, r3
   13c32:	4b1f      	ldr	r3, [pc, #124]	; (13cb0 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   13c34:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   13c38:	430a      	orrs	r2, r1
   13c3a:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->TCR |= (1 << 0);
   13c3c:	9b03      	ldr	r3, [sp, #12]
   13c3e:	7a1b      	ldrb	r3, [r3, #8]
   13c40:	461a      	mov	r2, r3
   13c42:	4b1b      	ldr	r3, [pc, #108]	; (13cb0 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   13c44:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13c48:	685a      	ldr	r2, [r3, #4]
   13c4a:	9b03      	ldr	r3, [sp, #12]
   13c4c:	7a1b      	ldrb	r3, [r3, #8]
   13c4e:	4619      	mov	r1, r3
   13c50:	4b17      	ldr	r3, [pc, #92]	; (13cb0 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   13c52:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   13c56:	f042 0201 	orr.w	r2, r2, #1
   13c5a:	605a      	str	r2, [r3, #4]
    user_timer_isr[channel_] = isr;
   13c5c:	9b03      	ldr	r3, [sp, #12]
   13c5e:	7a1b      	ldrb	r3, [r3, #8]
   13c60:	4619      	mov	r1, r3
   13c62:	4a14      	ldr	r2, [pc, #80]	; (13cb4 <Timer::Initialize(unsigned long, void (*)(), long)+0x128>)
   13c64:	9b01      	ldr	r3, [sp, #4]
   13c66:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    RegisterIsr(kTimerIrq[channel_], kTimerIsr[channel_], true, priority);
   13c6a:	9b03      	ldr	r3, [sp, #12]
   13c6c:	7a1b      	ldrb	r3, [r3, #8]
   13c6e:	461a      	mov	r2, r3
   13c70:	4b11      	ldr	r3, [pc, #68]	; (13cb8 <Timer::Initialize(unsigned long, void (*)(), long)+0x12c>)
   13c72:	5698      	ldrsb	r0, [r3, r2]
   13c74:	9b03      	ldr	r3, [sp, #12]
   13c76:	7a1b      	ldrb	r3, [r3, #8]
   13c78:	461a      	mov	r2, r3
   13c7a:	4b10      	ldr	r3, [pc, #64]	; (13cbc <Timer::Initialize(unsigned long, void (*)(), long)+0x130>)
   13c7c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   13c80:	9b00      	ldr	r3, [sp, #0]
   13c82:	2201      	movs	r2, #1
   13c84:	f001 f964 	bl	14f50 <RegisterIsr(IRQn, void (*)(), bool, long)>
   13c88:	4623      	mov	r3, r4
   13c8a:	4619      	mov	r1, r3
   13c8c:	4802      	ldr	r0, [pc, #8]	; (13c98 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   13c8e:	f001 fac7 	bl	15220 <__cyg_profile_func_exit>
  }
   13c92:	bf00      	nop
   13c94:	b006      	add	sp, #24
   13c96:	bd10      	pop	{r4, pc}
   13c98:	00013b8d 	.word	0x00013b8d
   13c9c:	0001ad28 	.word	0x0001ad28
   13ca0:	0001ae28 	.word	0x0001ae28
   13ca4:	0001ad4c 	.word	0x0001ad4c
   13ca8:	0001ac08 	.word	0x0001ac08
   13cac:	0001a914 	.word	0x0001a914
   13cb0:	10000760 	.word	0x10000760
   13cb4:	10001284 	.word	0x10001284
   13cb8:	0001ad38 	.word	0x0001ad38
   13cbc:	0001ad3c 	.word	0x0001ad3c

00013cc0 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>:
constexpr Type Value(Enum enum_type_value)
   13cc0:	b530      	push	{r4, r5, lr}
   13cc2:	b083      	sub	sp, #12
   13cc4:	4675      	mov	r5, lr
   13cc6:	4603      	mov	r3, r0
   13cc8:	f88d 3007 	strb.w	r3, [sp, #7]
   13ccc:	462b      	mov	r3, r5
   13cce:	4619      	mov	r1, r3
   13cd0:	4806      	ldr	r0, [pc, #24]	; (13cec <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   13cd2:	f001 fa91 	bl	151f8 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   13cd6:	f89d 4007 	ldrb.w	r4, [sp, #7]
   13cda:	462b      	mov	r3, r5
   13cdc:	4619      	mov	r1, r3
   13cde:	4803      	ldr	r0, [pc, #12]	; (13cec <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   13ce0:	f001 fa9e 	bl	15220 <__cyg_profile_func_exit>
   13ce4:	4623      	mov	r3, r4
}
   13ce6:	4618      	mov	r0, r3
   13ce8:	b003      	add	sp, #12
   13cea:	bd30      	pop	{r4, r5, pc}
   13cec:	00013cc1 	.word	0x00013cc1

00013cf0 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)>:
  ///
  /// @param ticks the count of the timer register (TC) to have an ISR fire
  /// @param condition the condition for which a timer interrupt will occur
  /// @param match_register which match register (from 0 to 3) should be used
  ///                       for holding the ticks for the condition.
  void SetTimer(uint32_t ticks, TimerIsrCondition condition,
   13cf0:	b570      	push	{r4, r5, r6, lr}
   13cf2:	b086      	sub	sp, #24
   13cf4:	4676      	mov	r6, lr
   13cf6:	9003      	str	r0, [sp, #12]
   13cf8:	9102      	str	r1, [sp, #8]
   13cfa:	4611      	mov	r1, r2
   13cfc:	461a      	mov	r2, r3
   13cfe:	460b      	mov	r3, r1
   13d00:	f88d 3007 	strb.w	r3, [sp, #7]
   13d04:	4613      	mov	r3, r2
   13d06:	f88d 3006 	strb.w	r3, [sp, #6]
   13d0a:	4633      	mov	r3, r6
   13d0c:	4619      	mov	r1, r3
   13d0e:	4832      	ldr	r0, [pc, #200]	; (13dd8 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   13d10:	f001 fa72 	bl	151f8 <__cyg_profile_func_enter>
                MatchControlRegister match_register = kMat0) override final
  {
    static constexpr uint8_t kClearMode = 0b0111;

    uint8_t match_value = util::Value(match_register);
   13d14:	f89d 3006 	ldrb.w	r3, [sp, #6]
   13d18:	4618      	mov	r0, r3
   13d1a:	f7ff ffd1 	bl	13cc0 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>
   13d1e:	4603      	mov	r3, r0
   13d20:	f88d 3017 	strb.w	r3, [sp, #23]
    tim_register[channel_]->MCR &= ~(kClearMode << match_value);
   13d24:	9b03      	ldr	r3, [sp, #12]
   13d26:	7a1b      	ldrb	r3, [r3, #8]
   13d28:	461a      	mov	r2, r3
   13d2a:	4b2c      	ldr	r3, [pc, #176]	; (13ddc <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   13d2c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13d30:	695a      	ldr	r2, [r3, #20]
   13d32:	f89d 3017 	ldrb.w	r3, [sp, #23]
   13d36:	2107      	movs	r1, #7
   13d38:	fa01 f303 	lsl.w	r3, r1, r3
   13d3c:	43db      	mvns	r3, r3
   13d3e:	4619      	mov	r1, r3
   13d40:	9b03      	ldr	r3, [sp, #12]
   13d42:	7a1b      	ldrb	r3, [r3, #8]
   13d44:	4618      	mov	r0, r3
   13d46:	4b25      	ldr	r3, [pc, #148]	; (13ddc <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   13d48:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   13d4c:	400a      	ands	r2, r1
   13d4e:	615a      	str	r2, [r3, #20]
    tim_register[channel_]->MCR |= condition << match_value;
   13d50:	9b03      	ldr	r3, [sp, #12]
   13d52:	7a1b      	ldrb	r3, [r3, #8]
   13d54:	461a      	mov	r2, r3
   13d56:	4b21      	ldr	r3, [pc, #132]	; (13ddc <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   13d58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13d5c:	695a      	ldr	r2, [r3, #20]
   13d5e:	f89d 1007 	ldrb.w	r1, [sp, #7]
   13d62:	f89d 3017 	ldrb.w	r3, [sp, #23]
   13d66:	fa01 f303 	lsl.w	r3, r1, r3
   13d6a:	4619      	mov	r1, r3
   13d6c:	9b03      	ldr	r3, [sp, #12]
   13d6e:	7a1b      	ldrb	r3, [r3, #8]
   13d70:	4618      	mov	r0, r3
   13d72:	4b1a      	ldr	r3, [pc, #104]	; (13ddc <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   13d74:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   13d78:	430a      	orrs	r2, r1
   13d7a:	615a      	str	r2, [r3, #20]
    *match[channel_][match_value / 3] |= (((ticks / 2)) << 0);
   13d7c:	9b03      	ldr	r3, [sp, #12]
   13d7e:	7a1b      	ldrb	r3, [r3, #8]
   13d80:	4618      	mov	r0, r3
   13d82:	f89d 3017 	ldrb.w	r3, [sp, #23]
   13d86:	4a16      	ldr	r2, [pc, #88]	; (13de0 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   13d88:	fba2 2303 	umull	r2, r3, r2, r3
   13d8c:	085b      	lsrs	r3, r3, #1
   13d8e:	b2db      	uxtb	r3, r3
   13d90:	4619      	mov	r1, r3
   13d92:	4a14      	ldr	r2, [pc, #80]	; (13de4 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   13d94:	0083      	lsls	r3, r0, #2
   13d96:	440b      	add	r3, r1
   13d98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d9c:	6819      	ldr	r1, [r3, #0]
   13d9e:	9b02      	ldr	r3, [sp, #8]
   13da0:	085a      	lsrs	r2, r3, #1
   13da2:	9b03      	ldr	r3, [sp, #12]
   13da4:	7a1b      	ldrb	r3, [r3, #8]
   13da6:	461d      	mov	r5, r3
   13da8:	f89d 3017 	ldrb.w	r3, [sp, #23]
   13dac:	480c      	ldr	r0, [pc, #48]	; (13de0 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   13dae:	fba0 0303 	umull	r0, r3, r0, r3
   13db2:	085b      	lsrs	r3, r3, #1
   13db4:	b2db      	uxtb	r3, r3
   13db6:	461c      	mov	r4, r3
   13db8:	480a      	ldr	r0, [pc, #40]	; (13de4 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   13dba:	00ab      	lsls	r3, r5, #2
   13dbc:	4423      	add	r3, r4
   13dbe:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   13dc2:	430a      	orrs	r2, r1
   13dc4:	601a      	str	r2, [r3, #0]
   13dc6:	4633      	mov	r3, r6
   13dc8:	4619      	mov	r1, r3
   13dca:	4803      	ldr	r0, [pc, #12]	; (13dd8 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   13dcc:	f001 fa28 	bl	15220 <__cyg_profile_func_exit>
  }
   13dd0:	bf00      	nop
   13dd2:	b006      	add	sp, #24
   13dd4:	bd70      	pop	{r4, r5, r6, pc}
   13dd6:	bf00      	nop
   13dd8:	00013cf1 	.word	0x00013cf1
   13ddc:	10000760 	.word	0x10000760
   13de0:	aaaaaaab 	.word	0xaaaaaaab
   13de4:	10001244 	.word	0x10001244

00013de8 <Timer::GetTimer()>:

  [[gnu::always_inline]] uint32_t GetTimer() override final {
   13de8:	b530      	push	{r4, r5, lr}
   13dea:	b083      	sub	sp, #12
   13dec:	4675      	mov	r5, lr
   13dee:	9001      	str	r0, [sp, #4]
   13df0:	462b      	mov	r3, r5
   13df2:	4619      	mov	r1, r3
   13df4:	4809      	ldr	r0, [pc, #36]	; (13e1c <Timer::GetTimer()+0x34>)
   13df6:	f001 f9ff 	bl	151f8 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   13dfa:	9b01      	ldr	r3, [sp, #4]
   13dfc:	7a1b      	ldrb	r3, [r3, #8]
   13dfe:	461a      	mov	r2, r3
   13e00:	4b07      	ldr	r3, [pc, #28]	; (13e20 <Timer::GetTimer()+0x38>)
   13e02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13e06:	689c      	ldr	r4, [r3, #8]
   13e08:	462b      	mov	r3, r5
   13e0a:	4619      	mov	r1, r3
   13e0c:	4803      	ldr	r0, [pc, #12]	; (13e1c <Timer::GetTimer()+0x34>)
   13e0e:	f001 fa07 	bl	15220 <__cyg_profile_func_exit>
   13e12:	4623      	mov	r3, r4
  }
   13e14:	4618      	mov	r0, r3
   13e16:	b003      	add	sp, #12
   13e18:	bd30      	pop	{r4, r5, pc}
   13e1a:	bf00      	nop
   13e1c:	00013de9 	.word	0x00013de9
   13e20:	10000760 	.word	0x10000760

00013e24 <Uart::SetBaudRate(unsigned long)>:
  constexpr Uart(Channels mode, PinInterface * tx_pin, PinInterface * rx_pin)
      : channel_(static_cast<uint8_t>(mode)), tx_(tx_pin), rx_(rx_pin)
  {
  }

  void SetBaudRate(uint32_t baud_rate) override
   13e24:	b510      	push	{r4, lr}
   13e26:	b088      	sub	sp, #32
   13e28:	4674      	mov	r4, lr
   13e2a:	9001      	str	r0, [sp, #4]
   13e2c:	9100      	str	r1, [sp, #0]
   13e2e:	4623      	mov	r3, r4
   13e30:	4619      	mov	r1, r3
   13e32:	482d      	ldr	r0, [pc, #180]	; (13ee8 <Uart::SetBaudRate(unsigned long)+0xc4>)
   13e34:	f001 f9e0 	bl	151f8 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kDlabBit = (1 << 7);
   13e38:	2380      	movs	r3, #128	; 0x80
   13e3a:	f88d 301f 	strb.w	r3, [sp, #31]
    float baudrate             = static_cast<float>(baud_rate);
   13e3e:	9b00      	ldr	r3, [sp, #0]
   13e40:	ee07 3a90 	vmov	s15, r3
   13e44:	eef8 7a67 	vcvt.f32.u32	s15, s15
   13e48:	edcd 7a06 	vstr	s15, [sp, #24]
    UartCalibration_t dividers = GenerateUartCalibration(baudrate);
   13e4c:	ab02      	add	r3, sp, #8
   13e4e:	ed9d 0a06 	vldr	s0, [sp, #24]
   13e52:	9901      	ldr	r1, [sp, #4]
   13e54:	4618      	mov	r0, r3
   13e56:	f000 fb2d 	bl	144b4 <Uart::GenerateUartCalibration(float)>

    uint8_t dlm = static_cast<uint8_t>((dividers.divide_latch >> 8) & 0xFF);
   13e5a:	9b02      	ldr	r3, [sp, #8]
   13e5c:	0a1b      	lsrs	r3, r3, #8
   13e5e:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8_t dll = static_cast<uint8_t>(dividers.divide_latch & 0xFF);
   13e62:	9b02      	ldr	r3, [sp, #8]
   13e64:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   13e68:	9b04      	ldr	r3, [sp, #16]
   13e6a:	b2db      	uxtb	r3, r3
   13e6c:	011b      	lsls	r3, r3, #4
   13e6e:	b2da      	uxtb	r2, r3
                                       (dividers.divide_add & 0xF));
   13e70:	9b03      	ldr	r3, [sp, #12]
   13e72:	b2db      	uxtb	r3, r3
   13e74:	f003 030f 	and.w	r3, r3, #15
   13e78:	b2db      	uxtb	r3, r3
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   13e7a:	4313      	orrs	r3, r2
   13e7c:	f88d 3015 	strb.w	r3, [sp, #21]

    // Set baud rate
    uart[channel_]->LCR = kDlabBit;
   13e80:	9b01      	ldr	r3, [sp, #4]
   13e82:	7a1b      	ldrb	r3, [r3, #8]
   13e84:	461a      	mov	r2, r3
   13e86:	4b19      	ldr	r3, [pc, #100]	; (13eec <Uart::SetBaudRate(unsigned long)+0xc8>)
   13e88:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13e8c:	2280      	movs	r2, #128	; 0x80
   13e8e:	731a      	strb	r2, [r3, #12]
    uart[channel_]->DLM = dlm;
   13e90:	9b01      	ldr	r3, [sp, #4]
   13e92:	7a1b      	ldrb	r3, [r3, #8]
   13e94:	461a      	mov	r2, r3
   13e96:	4b15      	ldr	r3, [pc, #84]	; (13eec <Uart::SetBaudRate(unsigned long)+0xc8>)
   13e98:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13e9c:	f89d 2017 	ldrb.w	r2, [sp, #23]
   13ea0:	711a      	strb	r2, [r3, #4]
    uart[channel_]->DLL = dll;
   13ea2:	9b01      	ldr	r3, [sp, #4]
   13ea4:	7a1b      	ldrb	r3, [r3, #8]
   13ea6:	461a      	mov	r2, r3
   13ea8:	4b10      	ldr	r3, [pc, #64]	; (13eec <Uart::SetBaudRate(unsigned long)+0xc8>)
   13eaa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13eae:	f89d 2016 	ldrb.w	r2, [sp, #22]
   13eb2:	701a      	strb	r2, [r3, #0]
    uart[channel_]->FDR = fdr;
   13eb4:	9b01      	ldr	r3, [sp, #4]
   13eb6:	7a1b      	ldrb	r3, [r3, #8]
   13eb8:	461a      	mov	r2, r3
   13eba:	4b0c      	ldr	r3, [pc, #48]	; (13eec <Uart::SetBaudRate(unsigned long)+0xc8>)
   13ebc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13ec0:	f89d 2015 	ldrb.w	r2, [sp, #21]
   13ec4:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    uart[channel_]->LCR = kStandardUart;
   13ec8:	9b01      	ldr	r3, [sp, #4]
   13eca:	7a1b      	ldrb	r3, [r3, #8]
   13ecc:	461a      	mov	r2, r3
   13ece:	4b07      	ldr	r3, [pc, #28]	; (13eec <Uart::SetBaudRate(unsigned long)+0xc8>)
   13ed0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13ed4:	2203      	movs	r2, #3
   13ed6:	731a      	strb	r2, [r3, #12]
   13ed8:	4623      	mov	r3, r4
   13eda:	4619      	mov	r1, r3
   13edc:	4802      	ldr	r0, [pc, #8]	; (13ee8 <Uart::SetBaudRate(unsigned long)+0xc4>)
   13ede:	f001 f99f 	bl	15220 <__cyg_profile_func_exit>
  }
   13ee2:	bf00      	nop
   13ee4:	b008      	add	sp, #32
   13ee6:	bd10      	pop	{r4, pc}
   13ee8:	00013e25 	.word	0x00013e25
   13eec:	10000770 	.word	0x10000770

00013ef0 <Uart::Initialize(unsigned long)>:

  bool Initialize(uint32_t baud_rate) override
   13ef0:	b530      	push	{r4, r5, lr}
   13ef2:	b085      	sub	sp, #20
   13ef4:	4675      	mov	r5, lr
   13ef6:	9001      	str	r0, [sp, #4]
   13ef8:	9100      	str	r1, [sp, #0]
   13efa:	462b      	mov	r3, r5
   13efc:	4619      	mov	r1, r3
   13efe:	4830      	ldr	r0, [pc, #192]	; (13fc0 <Uart::Initialize(unsigned long)+0xd0>)
   13f00:	f001 f97a 	bl	151f8 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kFIFOEnableAndReset = 0b111;
   13f04:	2307      	movs	r3, #7
   13f06:	f88d 300f 	strb.w	r3, [sp, #15]
    // Powering the port
    PowerUpPeripheral(kPowerbit[channel_]);
   13f0a:	9b01      	ldr	r3, [sp, #4]
   13f0c:	1d18      	adds	r0, r3, #4
   13f0e:	9b01      	ldr	r3, [sp, #4]
   13f10:	685b      	ldr	r3, [r3, #4]
   13f12:	3314      	adds	r3, #20
   13f14:	681b      	ldr	r3, [r3, #0]
   13f16:	9a01      	ldr	r2, [sp, #4]
   13f18:	7a12      	ldrb	r2, [r2, #8]
   13f1a:	0092      	lsls	r2, r2, #2
   13f1c:	4929      	ldr	r1, [pc, #164]	; (13fc4 <Uart::Initialize(unsigned long)+0xd4>)
   13f1e:	440a      	add	r2, r1
   13f20:	4611      	mov	r1, r2
   13f22:	4798      	blx	r3
    // Setting the pin functions and modes
    rx_->SetPinFunction(kRxUartPortFunction[channel_]);
   13f24:	9b01      	ldr	r3, [sp, #4]
   13f26:	6918      	ldr	r0, [r3, #16]
   13f28:	9b01      	ldr	r3, [sp, #4]
   13f2a:	691b      	ldr	r3, [r3, #16]
   13f2c:	681b      	ldr	r3, [r3, #0]
   13f2e:	681b      	ldr	r3, [r3, #0]
   13f30:	9a01      	ldr	r2, [sp, #4]
   13f32:	7a12      	ldrb	r2, [r2, #8]
   13f34:	4611      	mov	r1, r2
   13f36:	4a24      	ldr	r2, [pc, #144]	; (13fc8 <Uart::Initialize(unsigned long)+0xd8>)
   13f38:	5c52      	ldrb	r2, [r2, r1]
   13f3a:	4611      	mov	r1, r2
   13f3c:	4798      	blx	r3
    tx_->SetPinFunction(kTxUartPortFunction[channel_]);
   13f3e:	9b01      	ldr	r3, [sp, #4]
   13f40:	68d8      	ldr	r0, [r3, #12]
   13f42:	9b01      	ldr	r3, [sp, #4]
   13f44:	68db      	ldr	r3, [r3, #12]
   13f46:	681b      	ldr	r3, [r3, #0]
   13f48:	681b      	ldr	r3, [r3, #0]
   13f4a:	9a01      	ldr	r2, [sp, #4]
   13f4c:	7a12      	ldrb	r2, [r2, #8]
   13f4e:	4611      	mov	r1, r2
   13f50:	4a1e      	ldr	r2, [pc, #120]	; (13fcc <Uart::Initialize(unsigned long)+0xdc>)
   13f52:	5c52      	ldrb	r2, [r2, r1]
   13f54:	4611      	mov	r1, r2
   13f56:	4798      	blx	r3
    rx_->SetMode(PinInterface::Mode::kPullUp);
   13f58:	9b01      	ldr	r3, [sp, #4]
   13f5a:	691a      	ldr	r2, [r3, #16]
   13f5c:	9b01      	ldr	r3, [sp, #4]
   13f5e:	691b      	ldr	r3, [r3, #16]
   13f60:	681b      	ldr	r3, [r3, #0]
   13f62:	3304      	adds	r3, #4
   13f64:	681b      	ldr	r3, [r3, #0]
   13f66:	2102      	movs	r1, #2
   13f68:	4610      	mov	r0, r2
   13f6a:	4798      	blx	r3
    tx_->SetMode(PinInterface::Mode::kPullUp);
   13f6c:	9b01      	ldr	r3, [sp, #4]
   13f6e:	68da      	ldr	r2, [r3, #12]
   13f70:	9b01      	ldr	r3, [sp, #4]
   13f72:	68db      	ldr	r3, [r3, #12]
   13f74:	681b      	ldr	r3, [r3, #0]
   13f76:	3304      	adds	r3, #4
   13f78:	681b      	ldr	r3, [r3, #0]
   13f7a:	2102      	movs	r1, #2
   13f7c:	4610      	mov	r0, r2
   13f7e:	4798      	blx	r3
    // Baud rate setting
    SetBaudRate(baud_rate);
   13f80:	9900      	ldr	r1, [sp, #0]
   13f82:	9801      	ldr	r0, [sp, #4]
   13f84:	f7ff ff4e 	bl	13e24 <Uart::SetBaudRate(unsigned long)>
    uart[channel_]->FCR |= kFIFOEnableAndReset;
   13f88:	9b01      	ldr	r3, [sp, #4]
   13f8a:	7a1b      	ldrb	r3, [r3, #8]
   13f8c:	461a      	mov	r2, r3
   13f8e:	4b10      	ldr	r3, [pc, #64]	; (13fd0 <Uart::Initialize(unsigned long)+0xe0>)
   13f90:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13f94:	7a1b      	ldrb	r3, [r3, #8]
   13f96:	b2da      	uxtb	r2, r3
   13f98:	9b01      	ldr	r3, [sp, #4]
   13f9a:	7a1b      	ldrb	r3, [r3, #8]
   13f9c:	4619      	mov	r1, r3
   13f9e:	4b0c      	ldr	r3, [pc, #48]	; (13fd0 <Uart::Initialize(unsigned long)+0xe0>)
   13fa0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   13fa4:	f042 0207 	orr.w	r2, r2, #7
   13fa8:	b2d2      	uxtb	r2, r2
   13faa:	721a      	strb	r2, [r3, #8]
    return true;
   13fac:	2401      	movs	r4, #1
   13fae:	462b      	mov	r3, r5
   13fb0:	4619      	mov	r1, r3
   13fb2:	4803      	ldr	r0, [pc, #12]	; (13fc0 <Uart::Initialize(unsigned long)+0xd0>)
   13fb4:	f001 f934 	bl	15220 <__cyg_profile_func_exit>
   13fb8:	4623      	mov	r3, r4
  }
   13fba:	4618      	mov	r0, r3
   13fbc:	b005      	add	sp, #20
   13fbe:	bd30      	pop	{r4, r5, pc}
   13fc0:	00013ef1 	.word	0x00013ef1
   13fc4:	0001ad60 	.word	0x0001ad60
   13fc8:	0001ad5c 	.word	0x0001ad5c
   13fcc:	0001ad58 	.word	0x0001ad58
   13fd0:	10000770 	.word	0x10000770

00013fd4 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>:

  void Send(uint8_t data) override
  {
    uart[channel_]->THR              = data;
    auto wait_for_transfer_to_finish = [this]() -> bool {
   13fd4:	b530      	push	{r4, r5, lr}
   13fd6:	b083      	sub	sp, #12
   13fd8:	4675      	mov	r5, lr
   13fda:	9001      	str	r0, [sp, #4]
   13fdc:	462b      	mov	r3, r5
   13fde:	4619      	mov	r1, r3
   13fe0:	480d      	ldr	r0, [pc, #52]	; (14018 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   13fe2:	f001 f909 	bl	151f8 <__cyg_profile_func_enter>
   13fe6:	9b01      	ldr	r3, [sp, #4]
   13fe8:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 5));
   13fea:	7a1b      	ldrb	r3, [r3, #8]
   13fec:	461a      	mov	r2, r3
   13fee:	4b0b      	ldr	r3, [pc, #44]	; (1401c <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x48>)
   13ff0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   13ff4:	7d1b      	ldrb	r3, [r3, #20]
   13ff6:	b2db      	uxtb	r3, r3
   13ff8:	f003 0320 	and.w	r3, r3, #32
   13ffc:	2b00      	cmp	r3, #0
   13ffe:	bf14      	ite	ne
   14000:	2301      	movne	r3, #1
   14002:	2300      	moveq	r3, #0
   14004:	b2dc      	uxtb	r4, r3
   14006:	462b      	mov	r3, r5
   14008:	4619      	mov	r1, r3
   1400a:	4803      	ldr	r0, [pc, #12]	; (14018 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   1400c:	f001 f908 	bl	15220 <__cyg_profile_func_exit>
   14010:	4623      	mov	r3, r4
    };
   14012:	4618      	mov	r0, r3
   14014:	b003      	add	sp, #12
   14016:	bd30      	pop	{r4, r5, pc}
   14018:	00013fd5 	.word	0x00013fd5
   1401c:	10000770 	.word	0x10000770

00014020 <Uart::Send(unsigned char)>:
  void Send(uint8_t data) override
   14020:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   14024:	b08a      	sub	sp, #40	; 0x28
   14026:	4675      	mov	r5, lr
   14028:	9001      	str	r0, [sp, #4]
   1402a:	460b      	mov	r3, r1
   1402c:	f88d 3003 	strb.w	r3, [sp, #3]
   14030:	462b      	mov	r3, r5
   14032:	4619      	mov	r1, r3
   14034:	4831      	ldr	r0, [pc, #196]	; (140fc <Uart::Send(unsigned char)+0xdc>)
   14036:	f001 f8df 	bl	151f8 <__cyg_profile_func_enter>
    uart[channel_]->THR              = data;
   1403a:	9b01      	ldr	r3, [sp, #4]
   1403c:	7a1b      	ldrb	r3, [r3, #8]
   1403e:	461a      	mov	r2, r3
   14040:	4b2f      	ldr	r3, [pc, #188]	; (14100 <Uart::Send(unsigned char)+0xe0>)
   14042:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14046:	f89d 2003 	ldrb.w	r2, [sp, #3]
   1404a:	701a      	strb	r2, [r3, #0]
    };
   1404c:	9b01      	ldr	r3, [sp, #4]
   1404e:	9304      	str	r3, [sp, #16]
   14050:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14054:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   14058:	e9cd 3408 	strd	r3, r4, [sp, #32]
   1405c:	9b04      	ldr	r3, [sp, #16]
   1405e:	9303      	str	r3, [sp, #12]
   14060:	462b      	mov	r3, r5
   14062:	4619      	mov	r1, r3
   14064:	4827      	ldr	r0, [pc, #156]	; (14104 <Uart::Send(unsigned char)+0xe4>)
   14066:	f001 f8c7 	bl	151f8 <__cyg_profile_func_enter>
template <typename F>
[[gnu::always_inline]] inline Status Wait(uint64_t timeout, F is_done);
template <typename F>
inline Status Wait(uint64_t timeout, F is_done)
{
  uint64_t timeout_time = 0;
   1406a:	f04f 0300 	mov.w	r3, #0
   1406e:	f04f 0400 	mov.w	r4, #0
   14072:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   14076:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   1407a:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   1407e:	bf08      	it	eq
   14080:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   14084:	d106      	bne.n	14094 <Uart::Send(unsigned char)+0x74>
  {
    timeout_time = kMaxWait;
   14086:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1408a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1408e:	e9cd 3406 	strd	r3, r4, [sp, #24]
   14092:	e00b      	b.n	140ac <Uart::Send(unsigned char)+0x8c>
  }
  else
  {
    timeout_time = Milliseconds() + timeout;
   14094:	f7fc fd36 	bl	10b04 <Milliseconds()>
   14098:	460a      	mov	r2, r1
   1409a:	4601      	mov	r1, r0
   1409c:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   140a0:	eb13 0b01 	adds.w	fp, r3, r1
   140a4:	eb44 0c02 	adc.w	ip, r4, r2
   140a8:	e9cd bc06 	strd	fp, ip, [sp, #24]
  }

  Status status = Status::kTimedOut;
   140ac:	2301      	movs	r3, #1
   140ae:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   140b0:	f7fc fd28 	bl	10b04 <Milliseconds()>
   140b4:	460a      	mov	r2, r1
   140b6:	4601      	mov	r1, r0
   140b8:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   140bc:	42a2      	cmp	r2, r4
   140be:	bf08      	it	eq
   140c0:	4299      	cmpeq	r1, r3
   140c2:	bf34      	ite	cc
   140c4:	2301      	movcc	r3, #1
   140c6:	2300      	movcs	r3, #0
   140c8:	b2db      	uxtb	r3, r3
   140ca:	2b00      	cmp	r3, #0
   140cc:	d008      	beq.n	140e0 <Uart::Send(unsigned char)+0xc0>
  {
    if (is_done())
   140ce:	ab03      	add	r3, sp, #12
   140d0:	4618      	mov	r0, r3
   140d2:	f7ff ff7f 	bl	13fd4 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   140d6:	4603      	mov	r3, r0
   140d8:	2b00      	cmp	r3, #0
   140da:	d0e9      	beq.n	140b0 <Uart::Send(unsigned char)+0x90>
    {
      status = Status::kSuccess;
   140dc:	2300      	movs	r3, #0
   140de:	9305      	str	r3, [sp, #20]
   140e0:	462b      	mov	r3, r5
   140e2:	4619      	mov	r1, r3
   140e4:	4807      	ldr	r0, [pc, #28]	; (14104 <Uart::Send(unsigned char)+0xe4>)
   140e6:	f001 f89b 	bl	15220 <__cyg_profile_func_exit>
   140ea:	462b      	mov	r3, r5
   140ec:	4619      	mov	r1, r3
   140ee:	4803      	ldr	r0, [pc, #12]	; (140fc <Uart::Send(unsigned char)+0xdc>)
   140f0:	f001 f896 	bl	15220 <__cyg_profile_func_exit>
    Wait(kMaxWait, wait_for_transfer_to_finish);
  }
   140f4:	bf00      	nop
   140f6:	b00a      	add	sp, #40	; 0x28
   140f8:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   140fc:	00014021 	.word	0x00014021
   14100:	10000770 	.word	0x10000770
   14104:	000149a9 	.word	0x000149a9

00014108 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>:

  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
  {
    uint8_t receiver   = '\xFF';
    auto byte_recieved = [this]() -> bool {
   14108:	b530      	push	{r4, r5, lr}
   1410a:	b083      	sub	sp, #12
   1410c:	4675      	mov	r5, lr
   1410e:	9001      	str	r0, [sp, #4]
   14110:	462b      	mov	r3, r5
   14112:	4619      	mov	r1, r3
   14114:	480d      	ldr	r0, [pc, #52]	; (1414c <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   14116:	f001 f86f 	bl	151f8 <__cyg_profile_func_enter>
   1411a:	9b01      	ldr	r3, [sp, #4]
   1411c:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 0));
   1411e:	7a1b      	ldrb	r3, [r3, #8]
   14120:	461a      	mov	r2, r3
   14122:	4b0b      	ldr	r3, [pc, #44]	; (14150 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x48>)
   14124:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14128:	7d1b      	ldrb	r3, [r3, #20]
   1412a:	b2db      	uxtb	r3, r3
   1412c:	f003 0301 	and.w	r3, r3, #1
   14130:	2b00      	cmp	r3, #0
   14132:	bf14      	ite	ne
   14134:	2301      	movne	r3, #1
   14136:	2300      	moveq	r3, #0
   14138:	b2dc      	uxtb	r4, r3
   1413a:	462b      	mov	r3, r5
   1413c:	4619      	mov	r1, r3
   1413e:	4803      	ldr	r0, [pc, #12]	; (1414c <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   14140:	f001 f86e 	bl	15220 <__cyg_profile_func_exit>
   14144:	4623      	mov	r3, r4
    };
   14146:	4618      	mov	r0, r3
   14148:	b003      	add	sp, #12
   1414a:	bd30      	pop	{r4, r5, pc}
   1414c:	00014109 	.word	0x00014109
   14150:	10000770 	.word	0x10000770

00014154 <Uart::Receive(unsigned long)>:
  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
   14154:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   14158:	b08c      	sub	sp, #48	; 0x30
   1415a:	4675      	mov	r5, lr
   1415c:	9001      	str	r0, [sp, #4]
   1415e:	9100      	str	r1, [sp, #0]
   14160:	462b      	mov	r3, r5
   14162:	4619      	mov	r1, r3
   14164:	4836      	ldr	r0, [pc, #216]	; (14240 <Uart::Receive(unsigned long)+0xec>)
   14166:	f001 f847 	bl	151f8 <__cyg_profile_func_enter>
    uint8_t receiver   = '\xFF';
   1416a:	23ff      	movs	r3, #255	; 0xff
   1416c:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    };
   14170:	9b01      	ldr	r3, [sp, #4]
   14172:	9304      	str	r3, [sp, #16]

    Status status = Wait(timeout, byte_recieved);
   14174:	9b00      	ldr	r3, [sp, #0]
   14176:	f04f 0400 	mov.w	r4, #0
   1417a:	e9cd 3408 	strd	r3, r4, [sp, #32]
   1417e:	9b04      	ldr	r3, [sp, #16]
   14180:	9303      	str	r3, [sp, #12]
   14182:	462b      	mov	r3, r5
   14184:	4619      	mov	r1, r3
   14186:	482f      	ldr	r0, [pc, #188]	; (14244 <Uart::Receive(unsigned long)+0xf0>)
   14188:	f001 f836 	bl	151f8 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   1418c:	f04f 0300 	mov.w	r3, #0
   14190:	f04f 0400 	mov.w	r4, #0
   14194:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   14198:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   1419c:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   141a0:	bf08      	it	eq
   141a2:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   141a6:	d106      	bne.n	141b6 <Uart::Receive(unsigned long)+0x62>
    timeout_time = kMaxWait;
   141a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   141ac:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   141b0:	e9cd 3406 	strd	r3, r4, [sp, #24]
   141b4:	e00b      	b.n	141ce <Uart::Receive(unsigned long)+0x7a>
    timeout_time = Milliseconds() + timeout;
   141b6:	f7fc fca5 	bl	10b04 <Milliseconds()>
   141ba:	460a      	mov	r2, r1
   141bc:	4601      	mov	r1, r0
   141be:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   141c2:	eb13 0b01 	adds.w	fp, r3, r1
   141c6:	eb44 0c02 	adc.w	ip, r4, r2
   141ca:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   141ce:	2301      	movs	r3, #1
   141d0:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   141d2:	f7fc fc97 	bl	10b04 <Milliseconds()>
   141d6:	460a      	mov	r2, r1
   141d8:	4601      	mov	r1, r0
   141da:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   141de:	42a2      	cmp	r2, r4
   141e0:	bf08      	it	eq
   141e2:	4299      	cmpeq	r1, r3
   141e4:	bf34      	ite	cc
   141e6:	2301      	movcc	r3, #1
   141e8:	2300      	movcs	r3, #0
   141ea:	b2db      	uxtb	r3, r3
   141ec:	2b00      	cmp	r3, #0
   141ee:	d008      	beq.n	14202 <Uart::Receive(unsigned long)+0xae>
    if (is_done())
   141f0:	ab03      	add	r3, sp, #12
   141f2:	4618      	mov	r0, r3
   141f4:	f7ff ff88 	bl	14108 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   141f8:	4603      	mov	r3, r0
   141fa:	2b00      	cmp	r3, #0
   141fc:	d0e9      	beq.n	141d2 <Uart::Receive(unsigned long)+0x7e>
      status = Status::kSuccess;
   141fe:	2300      	movs	r3, #0
   14200:	9305      	str	r3, [sp, #20]
      break;
    }
  }
  return status;
   14202:	9c05      	ldr	r4, [sp, #20]
   14204:	462b      	mov	r3, r5
   14206:	4619      	mov	r1, r3
   14208:	480e      	ldr	r0, [pc, #56]	; (14244 <Uart::Receive(unsigned long)+0xf0>)
   1420a:	f001 f809 	bl	15220 <__cyg_profile_func_exit>
   1420e:	940a      	str	r4, [sp, #40]	; 0x28

    if (status == Status::kSuccess)
   14210:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14212:	2b00      	cmp	r3, #0
   14214:	d108      	bne.n	14228 <Uart::Receive(unsigned long)+0xd4>
    {
      receiver = static_cast<uint8_t>(uart[channel_]->RBR);
   14216:	9b01      	ldr	r3, [sp, #4]
   14218:	7a1b      	ldrb	r3, [r3, #8]
   1421a:	461a      	mov	r2, r3
   1421c:	4b0a      	ldr	r3, [pc, #40]	; (14248 <Uart::Receive(unsigned long)+0xf4>)
   1421e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14222:	781b      	ldrb	r3, [r3, #0]
   14224:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    }
    return receiver;
   14228:	f89d 402f 	ldrb.w	r4, [sp, #47]	; 0x2f
   1422c:	462b      	mov	r3, r5
   1422e:	4619      	mov	r1, r3
   14230:	4803      	ldr	r0, [pc, #12]	; (14240 <Uart::Receive(unsigned long)+0xec>)
   14232:	f000 fff5 	bl	15220 <__cyg_profile_func_exit>
   14236:	4623      	mov	r3, r4
  }
   14238:	4618      	mov	r0, r3
   1423a:	b00c      	add	sp, #48	; 0x30
   1423c:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   14240:	00014155 	.word	0x00014155
   14244:	00014a51 	.word	0x00014a51
   14248:	10000770 	.word	0x10000770

0001424c <Uart::FindClosestFractional(float)>:

 private:
  UartCalibration_t FindClosestFractional(float decimal)
   1424c:	b510      	push	{r4, lr}
   1424e:	b08a      	sub	sp, #40	; 0x28
   14250:	4674      	mov	r4, lr
   14252:	9003      	str	r0, [sp, #12]
   14254:	9102      	str	r1, [sp, #8]
   14256:	ed8d 0a01 	vstr	s0, [sp, #4]
   1425a:	4623      	mov	r3, r4
   1425c:	4619      	mov	r1, r3
   1425e:	4838      	ldr	r0, [pc, #224]	; (14340 <Uart::FindClosestFractional(float)+0xf4>)
   14260:	f000 ffca 	bl	151f8 <__cyg_profile_func_enter>
  {
    UartCalibration_t result;
   14264:	9b03      	ldr	r3, [sp, #12]
   14266:	2200      	movs	r2, #0
   14268:	601a      	str	r2, [r3, #0]
   1426a:	9b03      	ldr	r3, [sp, #12]
   1426c:	2200      	movs	r2, #0
   1426e:	605a      	str	r2, [r3, #4]
   14270:	9b03      	ldr	r3, [sp, #12]
   14272:	2201      	movs	r2, #1
   14274:	609a      	str	r2, [r3, #8]
    bool finished = false;
   14276:	2300      	movs	r3, #0
   14278:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (int div = 0; div < 15 && !finished; div++)
   1427c:	2300      	movs	r3, #0
   1427e:	9308      	str	r3, [sp, #32]
   14280:	9b08      	ldr	r3, [sp, #32]
   14282:	2b0e      	cmp	r3, #14
   14284:	dc52      	bgt.n	1432c <Uart::FindClosestFractional(float)+0xe0>
   14286:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1428a:	2b00      	cmp	r3, #0
   1428c:	d14e      	bne.n	1432c <Uart::FindClosestFractional(float)+0xe0>
    {
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   1428e:	9b08      	ldr	r3, [sp, #32]
   14290:	3301      	adds	r3, #1
   14292:	9307      	str	r3, [sp, #28]
   14294:	9b07      	ldr	r3, [sp, #28]
   14296:	2b0e      	cmp	r3, #14
   14298:	dc44      	bgt.n	14324 <Uart::FindClosestFractional(float)+0xd8>
   1429a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1429e:	2b00      	cmp	r3, #0
   142a0:	d140      	bne.n	14324 <Uart::FindClosestFractional(float)+0xd8>
      {
        float divf         = static_cast<float>(div);
   142a2:	9b08      	ldr	r3, [sp, #32]
   142a4:	ee07 3a90 	vmov	s15, r3
   142a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   142ac:	edcd 7a06 	vstr	s15, [sp, #24]
        float mulf         = static_cast<float>(mul);
   142b0:	9b07      	ldr	r3, [sp, #28]
   142b2:	ee07 3a90 	vmov	s15, r3
   142b6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   142ba:	edcd 7a05 	vstr	s15, [sp, #20]
        float test_decimal = 1.0f + divf / mulf;
   142be:	eddd 6a06 	vldr	s13, [sp, #24]
   142c2:	ed9d 7a05 	vldr	s14, [sp, #20]
   142c6:	eec6 7a87 	vdiv.f32	s15, s13, s14
   142ca:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   142ce:	ee77 7a87 	vadd.f32	s15, s15, s14
   142d2:	edcd 7a04 	vstr	s15, [sp, #16]
        if (decimal <= test_decimal + kThreshold &&
   142d6:	eddd 7a04 	vldr	s15, [sp, #16]
   142da:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 14344 <Uart::FindClosestFractional(float)+0xf8>
   142de:	ee77 7a87 	vadd.f32	s15, s15, s14
   142e2:	ed9d 7a01 	vldr	s14, [sp, #4]
   142e6:	eeb4 7ae7 	vcmpe.f32	s14, s15
   142ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   142ee:	d815      	bhi.n	1431c <Uart::FindClosestFractional(float)+0xd0>
            decimal >= test_decimal - kThreshold)
   142f0:	eddd 7a04 	vldr	s15, [sp, #16]
   142f4:	ed9f 7a13 	vldr	s14, [pc, #76]	; 14344 <Uart::FindClosestFractional(float)+0xf8>
   142f8:	ee77 7ac7 	vsub.f32	s15, s15, s14
        if (decimal <= test_decimal + kThreshold &&
   142fc:	ed9d 7a01 	vldr	s14, [sp, #4]
   14300:	eeb4 7ae7 	vcmpe.f32	s14, s15
   14304:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14308:	db08      	blt.n	1431c <Uart::FindClosestFractional(float)+0xd0>
        {
          result.divide_add = div;
   1430a:	9a08      	ldr	r2, [sp, #32]
   1430c:	9b03      	ldr	r3, [sp, #12]
   1430e:	605a      	str	r2, [r3, #4]
          result.multiply   = mul;
   14310:	9a07      	ldr	r2, [sp, #28]
   14312:	9b03      	ldr	r3, [sp, #12]
   14314:	609a      	str	r2, [r3, #8]
          finished          = true;
   14316:	2301      	movs	r3, #1
   14318:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   1431c:	9b07      	ldr	r3, [sp, #28]
   1431e:	3301      	adds	r3, #1
   14320:	9307      	str	r3, [sp, #28]
   14322:	e7b7      	b.n	14294 <Uart::FindClosestFractional(float)+0x48>
    for (int div = 0; div < 15 && !finished; div++)
   14324:	9b08      	ldr	r3, [sp, #32]
   14326:	3301      	adds	r3, #1
   14328:	9308      	str	r3, [sp, #32]
   1432a:	e7a9      	b.n	14280 <Uart::FindClosestFractional(float)+0x34>
        }
      }
    }
    return result;
   1432c:	bf00      	nop
   1432e:	4623      	mov	r3, r4
   14330:	4619      	mov	r1, r3
   14332:	4803      	ldr	r0, [pc, #12]	; (14340 <Uart::FindClosestFractional(float)+0xf4>)
   14334:	f000 ff74 	bl	15220 <__cyg_profile_func_exit>
   14338:	bf00      	nop
  }
   1433a:	9803      	ldr	r0, [sp, #12]
   1433c:	b00a      	add	sp, #40	; 0x28
   1433e:	bd10      	pop	{r4, pc}
   14340:	0001424d 	.word	0x0001424d
   14344:	3d4ccccd 	.word	0x3d4ccccd

00014348 <Uart::DividerEstimate(float, float)>:

  float DividerEstimate(float baud_rate, float fraction_estimate = 1)
   14348:	b510      	push	{r4, lr}
   1434a:	ed2d 8b02 	vpush	{d8}
   1434e:	b086      	sub	sp, #24
   14350:	4674      	mov	r4, lr
   14352:	9003      	str	r0, [sp, #12]
   14354:	ed8d 0a02 	vstr	s0, [sp, #8]
   14358:	edcd 0a01 	vstr	s1, [sp, #4]
   1435c:	4623      	mov	r3, r4
   1435e:	4619      	mov	r1, r3
   14360:	4815      	ldr	r0, [pc, #84]	; (143b8 <Uart::DividerEstimate(float, float)+0x70>)
   14362:	f000 ff49 	bl	151f8 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   14366:	9b03      	ldr	r3, [sp, #12]
   14368:	1d1a      	adds	r2, r3, #4
   1436a:	9b03      	ldr	r3, [sp, #12]
   1436c:	685b      	ldr	r3, [r3, #4]
   1436e:	3310      	adds	r3, #16
   14370:	681b      	ldr	r3, [r3, #0]
   14372:	4610      	mov	r0, r2
   14374:	4798      	blx	r3
   14376:	ee07 0a90 	vmov	s15, r0
   1437a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1437e:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * fraction_estimate);
   14382:	eddd 7a02 	vldr	s15, [sp, #8]
   14386:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   1438a:	ee27 7a87 	vmul.f32	s14, s15, s14
   1438e:	eddd 7a01 	vldr	s15, [sp, #4]
   14392:	ee67 7a27 	vmul.f32	s15, s14, s15
   14396:	ed9d 7a05 	vldr	s14, [sp, #20]
   1439a:	ee87 8a27 	vdiv.f32	s16, s14, s15
   1439e:	4623      	mov	r3, r4
   143a0:	4619      	mov	r1, r3
   143a2:	4805      	ldr	r0, [pc, #20]	; (143b8 <Uart::DividerEstimate(float, float)+0x70>)
   143a4:	f000 ff3c 	bl	15220 <__cyg_profile_func_exit>
   143a8:	eef0 7a48 	vmov.f32	s15, s16
  }
   143ac:	eeb0 0a67 	vmov.f32	s0, s15
   143b0:	b006      	add	sp, #24
   143b2:	ecbd 8b02 	vpop	{d8}
   143b6:	bd10      	pop	{r4, pc}
   143b8:	00014349 	.word	0x00014349

000143bc <Uart::FractionalEstimate(float, float)>:

  float FractionalEstimate(float baud_rate, float divider)
   143bc:	b510      	push	{r4, lr}
   143be:	ed2d 8b02 	vpush	{d8}
   143c2:	b086      	sub	sp, #24
   143c4:	4674      	mov	r4, lr
   143c6:	9003      	str	r0, [sp, #12]
   143c8:	ed8d 0a02 	vstr	s0, [sp, #8]
   143cc:	edcd 0a01 	vstr	s1, [sp, #4]
   143d0:	4623      	mov	r3, r4
   143d2:	4619      	mov	r1, r3
   143d4:	4815      	ldr	r0, [pc, #84]	; (1442c <Uart::FractionalEstimate(float, float)+0x70>)
   143d6:	f000 ff0f 	bl	151f8 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   143da:	9b03      	ldr	r3, [sp, #12]
   143dc:	1d1a      	adds	r2, r3, #4
   143de:	9b03      	ldr	r3, [sp, #12]
   143e0:	685b      	ldr	r3, [r3, #4]
   143e2:	3310      	adds	r3, #16
   143e4:	681b      	ldr	r3, [r3, #0]
   143e6:	4610      	mov	r0, r2
   143e8:	4798      	blx	r3
   143ea:	ee07 0a90 	vmov	s15, r0
   143ee:	eef8 7a67 	vcvt.f32.u32	s15, s15
   143f2:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * divider);
   143f6:	eddd 7a02 	vldr	s15, [sp, #8]
   143fa:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   143fe:	ee27 7a87 	vmul.f32	s14, s15, s14
   14402:	eddd 7a01 	vldr	s15, [sp, #4]
   14406:	ee67 7a27 	vmul.f32	s15, s14, s15
   1440a:	ed9d 7a05 	vldr	s14, [sp, #20]
   1440e:	ee87 8a27 	vdiv.f32	s16, s14, s15
   14412:	4623      	mov	r3, r4
   14414:	4619      	mov	r1, r3
   14416:	4805      	ldr	r0, [pc, #20]	; (1442c <Uart::FractionalEstimate(float, float)+0x70>)
   14418:	f000 ff02 	bl	15220 <__cyg_profile_func_exit>
   1441c:	eef0 7a48 	vmov.f32	s15, s16
  }
   14420:	eeb0 0a67 	vmov.f32	s0, s15
   14424:	b006      	add	sp, #24
   14426:	ecbd 8b02 	vpop	{d8}
   1442a:	bd10      	pop	{r4, pc}
   1442c:	000143bd 	.word	0x000143bd

00014430 <Uart::IsDecmial(float)>:

  bool IsDecmial(float value)
   14430:	b530      	push	{r4, r5, lr}
   14432:	b087      	sub	sp, #28
   14434:	4675      	mov	r5, lr
   14436:	9001      	str	r0, [sp, #4]
   14438:	ed8d 0a00 	vstr	s0, [sp]
   1443c:	462b      	mov	r3, r5
   1443e:	4619      	mov	r1, r3
   14440:	4819      	ldr	r0, [pc, #100]	; (144a8 <Uart::IsDecmial(float)+0x78>)
   14442:	f000 fed9 	bl	151f8 <__cyg_profile_func_enter>
  {
    bool result         = false;
   14446:	2300      	movs	r3, #0
   14448:	f88d 3017 	strb.w	r3, [sp, #23]
    float rounded_value = roundf(value);
   1444c:	ed9d 0a00 	vldr	s0, [sp]
   14450:	f004 fdb4 	bl	18fbc <roundf>
   14454:	ed8d 0a04 	vstr	s0, [sp, #16]
    float error         = value - rounded_value;
   14458:	ed9d 7a00 	vldr	s14, [sp]
   1445c:	eddd 7a04 	vldr	s15, [sp, #16]
   14460:	ee77 7a67 	vsub.f32	s15, s14, s15
   14464:	edcd 7a03 	vstr	s15, [sp, #12]
    if (-kThreshold <= error && error <= kThreshold)
   14468:	eddd 7a03 	vldr	s15, [sp, #12]
   1446c:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 144ac <Uart::IsDecmial(float)+0x7c>
   14470:	eef4 7ac7 	vcmpe.f32	s15, s14
   14474:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14478:	db0b      	blt.n	14492 <Uart::IsDecmial(float)+0x62>
   1447a:	eddd 7a03 	vldr	s15, [sp, #12]
   1447e:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 144b0 <Uart::IsDecmial(float)+0x80>
   14482:	eef4 7ac7 	vcmpe.f32	s15, s14
   14486:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1448a:	d802      	bhi.n	14492 <Uart::IsDecmial(float)+0x62>
    {
      result = true;
   1448c:	2301      	movs	r3, #1
   1448e:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return result;
   14492:	f89d 4017 	ldrb.w	r4, [sp, #23]
   14496:	462b      	mov	r3, r5
   14498:	4619      	mov	r1, r3
   1449a:	4803      	ldr	r0, [pc, #12]	; (144a8 <Uart::IsDecmial(float)+0x78>)
   1449c:	f000 fec0 	bl	15220 <__cyg_profile_func_exit>
   144a0:	4623      	mov	r3, r4
  }
   144a2:	4618      	mov	r0, r3
   144a4:	b007      	add	sp, #28
   144a6:	bd30      	pop	{r4, r5, pc}
   144a8:	00014431 	.word	0x00014431
   144ac:	bd4ccccd 	.word	0xbd4ccccd
   144b0:	3d4ccccd 	.word	0x3d4ccccd

000144b4 <Uart::GenerateUartCalibration(float)>:

  UartCalibration_t GenerateUartCalibration(float baud_rate)
   144b4:	b530      	push	{r4, r5, lr}
   144b6:	b08f      	sub	sp, #60	; 0x3c
   144b8:	4675      	mov	r5, lr
   144ba:	9007      	str	r0, [sp, #28]
   144bc:	9106      	str	r1, [sp, #24]
   144be:	ed8d 0a05 	vstr	s0, [sp, #20]
   144c2:	462b      	mov	r3, r5
   144c4:	4619      	mov	r1, r3
   144c6:	4874      	ldr	r0, [pc, #464]	; (14698 <Uart::GenerateUartCalibration(float)+0x1e4>)
   144c8:	f000 fe96 	bl	151f8 <__cyg_profile_func_enter>
  {
    States state = States::kCalculateIntegerDivideLatch;
   144cc:	2300      	movs	r3, #0
   144ce:	930d      	str	r3, [sp, #52]	; 0x34
    UartCalibration_t uart_calibration;
   144d0:	9b07      	ldr	r3, [sp, #28]
   144d2:	2200      	movs	r2, #0
   144d4:	601a      	str	r2, [r3, #0]
   144d6:	9b07      	ldr	r3, [sp, #28]
   144d8:	2200      	movs	r2, #0
   144da:	605a      	str	r2, [r3, #4]
   144dc:	9b07      	ldr	r3, [sp, #28]
   144de:	2201      	movs	r2, #1
   144e0:	609a      	str	r2, [r3, #8]
    float divide_estimate = 0;
   144e2:	f04f 0300 	mov.w	r3, #0
   144e6:	930c      	str	r3, [sp, #48]	; 0x30
    float decimal         = 1.5;
   144e8:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
   144ec:	930b      	str	r3, [sp, #44]	; 0x2c
    float div             = 1;
   144ee:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   144f2:	930a      	str	r3, [sp, #40]	; 0x28
    float mul             = 2;
   144f4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   144f8:	9309      	str	r3, [sp, #36]	; 0x24
    while (state != States::kDone)
   144fa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   144fc:	2b04      	cmp	r3, #4
   144fe:	f000 80c1 	beq.w	14684 <Uart::GenerateUartCalibration(float)+0x1d0>
    {
      switch (state)
   14502:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14504:	2b04      	cmp	r3, #4
   14506:	f200 80bb 	bhi.w	14680 <Uart::GenerateUartCalibration(float)+0x1cc>
   1450a:	a201      	add	r2, pc, #4	; (adr r2, 14510 <Uart::GenerateUartCalibration(float)+0x5c>)
   1450c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   14510:	00014525 	.word	0x00014525
   14514:	00014581 	.word	0x00014581
   14518:	000145e1 	.word	0x000145e1
   1451c:	00014651 	.word	0x00014651
   14520:	00014681 	.word	0x00014681
      {
        case States::kCalculateIntegerDivideLatch:
        {
          divide_estimate = DividerEstimate(baud_rate);
   14524:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   14528:	ed9d 0a05 	vldr	s0, [sp, #20]
   1452c:	9806      	ldr	r0, [sp, #24]
   1452e:	f7ff ff0b 	bl	14348 <Uart::DividerEstimate(float, float)>
   14532:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          if (divide_estimate < 1.0f)
   14536:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   1453a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1453e:	eef4 7ac7 	vcmpe.f32	s15, s14
   14542:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14546:	d505      	bpl.n	14554 <Uart::GenerateUartCalibration(float)+0xa0>
          {
            uart_calibration.divide_latch = 0;
   14548:	9b07      	ldr	r3, [sp, #28]
   1454a:	2200      	movs	r2, #0
   1454c:	601a      	str	r2, [r3, #0]
            state                         = States::kDone;
   1454e:	2304      	movs	r3, #4
   14550:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kCalculateDivideLatchWithDecimal;
          }
          break;
   14552:	e096      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
          else if (IsDecmial(divide_estimate))
   14554:	ed9d 0a0c 	vldr	s0, [sp, #48]	; 0x30
   14558:	9806      	ldr	r0, [sp, #24]
   1455a:	f7ff ff69 	bl	14430 <Uart::IsDecmial(float)>
   1455e:	4603      	mov	r3, r0
   14560:	2b00      	cmp	r3, #0
   14562:	d00a      	beq.n	1457a <Uart::GenerateUartCalibration(float)+0xc6>
                static_cast<uint32_t>(divide_estimate);
   14564:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   14568:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1456c:	ee17 2a90 	vmov	r2, s15
            uart_calibration.divide_latch =
   14570:	9b07      	ldr	r3, [sp, #28]
   14572:	601a      	str	r2, [r3, #0]
            state = States::kDone;
   14574:	2304      	movs	r3, #4
   14576:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   14578:	e083      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kCalculateDivideLatchWithDecimal;
   1457a:	2301      	movs	r3, #1
   1457c:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   1457e:	e080      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kCalculateDivideLatchWithDecimal:
        {
          divide_estimate = roundf(DividerEstimate(baud_rate, decimal));
   14580:	eddd 0a0b 	vldr	s1, [sp, #44]	; 0x2c
   14584:	ed9d 0a05 	vldr	s0, [sp, #20]
   14588:	9806      	ldr	r0, [sp, #24]
   1458a:	f7ff fedd 	bl	14348 <Uart::DividerEstimate(float, float)>
   1458e:	eef0 7a40 	vmov.f32	s15, s0
   14592:	eeb0 0a67 	vmov.f32	s0, s15
   14596:	f004 fd11 	bl	18fbc <roundf>
   1459a:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          decimal         = FractionalEstimate(baud_rate, divide_estimate);
   1459e:	eddd 0a0c 	vldr	s1, [sp, #48]	; 0x30
   145a2:	ed9d 0a05 	vldr	s0, [sp, #20]
   145a6:	9806      	ldr	r0, [sp, #24]
   145a8:	f7ff ff08 	bl	143bc <Uart::FractionalEstimate(float, float)>
   145ac:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
          if (1.1f <= decimal && decimal <= 1.9f)
   145b0:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   145b4:	ed9f 7a39 	vldr	s14, [pc, #228]	; 1469c <Uart::GenerateUartCalibration(float)+0x1e8>
   145b8:	eef4 7ac7 	vcmpe.f32	s15, s14
   145bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   145c0:	db0b      	blt.n	145da <Uart::GenerateUartCalibration(float)+0x126>
   145c2:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   145c6:	ed9f 7a36 	vldr	s14, [pc, #216]	; 146a0 <Uart::GenerateUartCalibration(float)+0x1ec>
   145ca:	eef4 7ac7 	vcmpe.f32	s15, s14
   145ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   145d2:	d802      	bhi.n	145da <Uart::GenerateUartCalibration(float)+0x126>
          {
            state = States::kGenerateFractionFromDecimal;
   145d4:	2303      	movs	r3, #3
   145d6:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kDecimalFailedGenerateNewDecimal;
          }
          break;
   145d8:	e053      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kDecimalFailedGenerateNewDecimal;
   145da:	2302      	movs	r3, #2
   145dc:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   145de:	e050      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDecimalFailedGenerateNewDecimal:
        {
          mul += 1;
   145e0:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   145e4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   145e8:	ee77 7a87 	vadd.f32	s15, s15, s14
   145ec:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24

          if (div > 15)
   145f0:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   145f4:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   145f8:	eef4 7ac7 	vcmpe.f32	s15, s14
   145fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14600:	dd02      	ble.n	14608 <Uart::GenerateUartCalibration(float)+0x154>
          {
            state = States::kDone;
   14602:	2304      	movs	r3, #4
   14604:	930d      	str	r3, [sp, #52]	; 0x34
            break;
   14606:	e03c      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
          }
          else if (mul > 15)
   14608:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   1460c:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   14610:	eef4 7ac7 	vcmpe.f32	s15, s14
   14614:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   14618:	dd0f      	ble.n	1463a <Uart::GenerateUartCalibration(float)+0x186>
          {
            div += 1;
   1461a:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   1461e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   14622:	ee77 7a87 	vadd.f32	s15, s15, s14
   14626:	edcd 7a0a 	vstr	s15, [sp, #40]	; 0x28
            mul = div + 1;
   1462a:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   1462e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   14632:	ee77 7a87 	vadd.f32	s15, s15, s14
   14636:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
          }
          decimal = div / mul;
   1463a:	eddd 6a0a 	vldr	s13, [sp, #40]	; 0x28
   1463e:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
   14642:	eec6 7a87 	vdiv.f32	s15, s13, s14
   14646:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
          state   = States::kCalculateDivideLatchWithDecimal;
   1464a:	2301      	movs	r3, #1
   1464c:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   1464e:	e018      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kGenerateFractionFromDecimal:
        {
          uart_calibration = FindClosestFractional(decimal);
   14650:	9c07      	ldr	r4, [sp, #28]
   14652:	466b      	mov	r3, sp
   14654:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
   14658:	9906      	ldr	r1, [sp, #24]
   1465a:	4618      	mov	r0, r3
   1465c:	f7ff fdf6 	bl	1424c <Uart::FindClosestFractional(float)>
   14660:	466b      	mov	r3, sp
   14662:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   14666:	e884 0007 	stmia.w	r4, {r0, r1, r2}
          uart_calibration.divide_latch =
              static_cast<uint32_t>(divide_estimate);
   1466a:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   1466e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   14672:	ee17 2a90 	vmov	r2, s15
          uart_calibration.divide_latch =
   14676:	9b07      	ldr	r3, [sp, #28]
   14678:	601a      	str	r2, [r3, #0]
          state = States::kDone;
   1467a:	2304      	movs	r3, #4
   1467c:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   1467e:	e000      	b.n	14682 <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDone: { break;
        }
        default: { break;
   14680:	bf00      	nop
    while (state != States::kDone)
   14682:	e73a      	b.n	144fa <Uart::GenerateUartCalibration(float)+0x46>
        }
      }
    }
    return uart_calibration;
   14684:	bf00      	nop
   14686:	462b      	mov	r3, r5
   14688:	4619      	mov	r1, r3
   1468a:	4803      	ldr	r0, [pc, #12]	; (14698 <Uart::GenerateUartCalibration(float)+0x1e4>)
   1468c:	f000 fdc8 	bl	15220 <__cyg_profile_func_exit>
   14690:	bf00      	nop
  }
   14692:	9807      	ldr	r0, [sp, #28]
   14694:	b00f      	add	sp, #60	; 0x3c
   14696:	bd30      	pop	{r4, r5, pc}
   14698:	000144b5 	.word	0x000144b5
   1469c:	3f8ccccd 	.word	0x3f8ccccd
   146a0:	3ff33333 	.word	0x3ff33333

000146a4 <(anonymous namespace)::Lpc40xxUptime()>:
{
   146a4:	b538      	push	{r3, r4, r5, lr}
   146a6:	4675      	mov	r5, lr
   146a8:	462b      	mov	r3, r5
   146aa:	4619      	mov	r1, r3
   146ac:	480a      	ldr	r0, [pc, #40]	; (146d8 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   146ae:	f000 fda3 	bl	151f8 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   146b2:	4b0a      	ldr	r3, [pc, #40]	; (146dc <(anonymous namespace)::Lpc40xxUptime()+0x38>)
   146b4:	7a1b      	ldrb	r3, [r3, #8]
   146b6:	461a      	mov	r2, r3
   146b8:	4b09      	ldr	r3, [pc, #36]	; (146e0 <(anonymous namespace)::Lpc40xxUptime()+0x3c>)
   146ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   146be:	689c      	ldr	r4, [r3, #8]
   146c0:	462b      	mov	r3, r5
   146c2:	4619      	mov	r1, r3
   146c4:	4804      	ldr	r0, [pc, #16]	; (146d8 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   146c6:	f000 fdab 	bl	15220 <__cyg_profile_func_exit>
  return timer0.GetTimer();
   146ca:	4623      	mov	r3, r4
   146cc:	f04f 0400 	mov.w	r4, #0
}
   146d0:	4618      	mov	r0, r3
   146d2:	4621      	mov	r1, r4
   146d4:	bd38      	pop	{r3, r4, r5, pc}
   146d6:	bf00      	nop
   146d8:	00013de9 	.word	0x00013de9
   146dc:	100007e0 	.word	0x100007e0
   146e0:	10000760 	.word	0x10000760

000146e4 <UptimeRTOS>:
{
   146e4:	b538      	push	{r3, r4, r5, lr}
   146e6:	4675      	mov	r5, lr
   146e8:	462b      	mov	r3, r5
   146ea:	4619      	mov	r1, r3
   146ec:	480a      	ldr	r0, [pc, #40]	; (14718 <UptimeRTOS+0x34>)
   146ee:	f000 fd83 	bl	151f8 <__cyg_profile_func_enter>
   146f2:	4b0a      	ldr	r3, [pc, #40]	; (1471c <UptimeRTOS+0x38>)
   146f4:	7a1b      	ldrb	r3, [r3, #8]
   146f6:	461a      	mov	r2, r3
   146f8:	4b09      	ldr	r3, [pc, #36]	; (14720 <UptimeRTOS+0x3c>)
   146fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   146fe:	689c      	ldr	r4, [r3, #8]
   14700:	462b      	mov	r3, r5
   14702:	4619      	mov	r1, r3
   14704:	4804      	ldr	r0, [pc, #16]	; (14718 <UptimeRTOS+0x34>)
   14706:	f000 fd8b 	bl	15220 <__cyg_profile_func_exit>
  return timer0.GetTimer();
   1470a:	4623      	mov	r3, r4
   1470c:	f04f 0400 	mov.w	r4, #0
}
   14710:	4618      	mov	r0, r3
   14712:	4621      	mov	r1, r4
   14714:	bd38      	pop	{r3, r4, r5, pc}
   14716:	bf00      	nop
   14718:	00013de9 	.word	0x00013de9
   1471c:	100007e0 	.word	0x100007e0
   14720:	10000760 	.word	0x10000760

00014724 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>:
   *  @brief  Return the size of an array.
   *  @param  __array  Array.
   */
  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (&/*__array*/)[_Nm]) noexcept
   14724:	b530      	push	{r4, r5, lr}
   14726:	b083      	sub	sp, #12
   14728:	4675      	mov	r5, lr
   1472a:	9001      	str	r0, [sp, #4]
   1472c:	462b      	mov	r3, r5
   1472e:	4619      	mov	r1, r3
   14730:	4806      	ldr	r0, [pc, #24]	; (1474c <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   14732:	f000 fd61 	bl	151f8 <__cyg_profile_func_enter>
    { return _Nm; }
   14736:	2450      	movs	r4, #80	; 0x50
   14738:	462b      	mov	r3, r5
   1473a:	4619      	mov	r1, r3
   1473c:	4803      	ldr	r0, [pc, #12]	; (1474c <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   1473e:	f000 fd6f 	bl	15220 <__cyg_profile_func_exit>
   14742:	4623      	mov	r3, r4
   14744:	4618      	mov	r0, r3
   14746:	b003      	add	sp, #12
   14748:	bd30      	pop	{r4, r5, pc}
   1474a:	bf00      	nop
   1474c:	00014725 	.word	0x00014725

00014750 <vApplicationGetIdleTaskMemory>:
  {
   14750:	b500      	push	{lr}
   14752:	b085      	sub	sp, #20
   14754:	9003      	str	r0, [sp, #12]
   14756:	9102      	str	r1, [sp, #8]
   14758:	9201      	str	r2, [sp, #4]
    *ppx_idle_task_tcb_buffer   = &idle_task_tcb;
   1475a:	9b03      	ldr	r3, [sp, #12]
   1475c:	4a07      	ldr	r2, [pc, #28]	; (1477c <vApplicationGetIdleTaskMemory+0x2c>)
   1475e:	601a      	str	r2, [r3, #0]
    *ppx_idle_task_stack_buffer = idle_task_stack;
   14760:	9b02      	ldr	r3, [sp, #8]
   14762:	4a07      	ldr	r2, [pc, #28]	; (14780 <vApplicationGetIdleTaskMemory+0x30>)
   14764:	601a      	str	r2, [r3, #0]
    *pul_idle_task_stack_size   = std::size(idle_task_stack);
   14766:	4806      	ldr	r0, [pc, #24]	; (14780 <vApplicationGetIdleTaskMemory+0x30>)
   14768:	f7ff ffdc 	bl	14724 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>
   1476c:	4602      	mov	r2, r0
   1476e:	9b01      	ldr	r3, [sp, #4]
   14770:	601a      	str	r2, [r3, #0]
  }
   14772:	bf00      	nop
   14774:	b005      	add	sp, #20
   14776:	f85d fb04 	ldr.w	pc, [sp], #4
   1477a:	bf00      	nop
   1477c:	10001294 	.word	0x10001294
   14780:	100012f4 	.word	0x100012f4

00014784 <vPortSetupTimerInterrupt>:
  {
   14784:	b508      	push	{r3, lr}
    system_timer.DisableTimer();
   14786:	f7ff f8ef 	bl	13968 <SystemTimer::DisableTimer()>
    system_timer.SetTickFrequency(config::kRtosFrequency);
   1478a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1478e:	4806      	ldr	r0, [pc, #24]	; (147a8 <vPortSetupTimerInterrupt+0x24>)
   14790:	f7ff f98a 	bl	13aa8 <SystemTimer::SetTickFrequency(unsigned long)>
    system_timer.SetIsrFunction(xPortSysTickHandler);
   14794:	4905      	ldr	r1, [pc, #20]	; (147ac <vPortSetupTimerInterrupt+0x28>)
   14796:	4804      	ldr	r0, [pc, #16]	; (147a8 <vPortSetupTimerInterrupt+0x24>)
   14798:	f7ff f91e 	bl	139d8 <SystemTimer::SetIsrFunction(void (*)())>
    system_timer.StartTimer();
   1479c:	4802      	ldr	r0, [pc, #8]	; (147a8 <vPortSetupTimerInterrupt+0x24>)
   1479e:	f7ff f935 	bl	13a0c <SystemTimer::StartTimer()>
  }
   147a2:	bf00      	nop
   147a4:	bd08      	pop	{r3, pc}
   147a6:	bf00      	nop
   147a8:	100007d4 	.word	0x100007d4
   147ac:	00016629 	.word	0x00016629

000147b0 <LowLevelInit()>:

void LowLevelInit()
{
   147b0:	b500      	push	{lr}
   147b2:	b083      	sub	sp, #12
  // Set the SystemTick frequency to the RTOS tick frequency
  // It is critical that this happens before you set the system_clock, since
  // The system_timer keeps the time that the system_clock uses to delay itself.
  system_timer.SetTickFrequency(config::kRtosFrequency);
   147b4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   147b8:	4822      	ldr	r0, [pc, #136]	; (14844 <LowLevelInit()+0x94>)
   147ba:	f7ff f975 	bl	13aa8 <SystemTimer::SetTickFrequency(unsigned long)>
  bool timer_started_successfully = system_timer.StartTimer();
   147be:	4821      	ldr	r0, [pc, #132]	; (14844 <LowLevelInit()+0x94>)
   147c0:	f7ff f924 	bl	13a0c <SystemTimer::StartTimer()>
   147c4:	4603      	mov	r3, r0
   147c6:	f88d 3007 	strb.w	r3, [sp, #7]
  SJ2_ASSERT_WARNING(timer_started_successfully,
   147ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
   147ce:	f083 0301 	eor.w	r3, r3, #1
   147d2:	b2db      	uxtb	r3, r3
   147d4:	2b00      	cmp	r3, #0
   147d6:	d005      	beq.n	147e4 <LowLevelInit()+0x34>
   147d8:	23ad      	movs	r3, #173	; 0xad
   147da:	4a1b      	ldr	r2, [pc, #108]	; (14848 <LowLevelInit()+0x98>)
   147dc:	491b      	ldr	r1, [pc, #108]	; (1484c <LowLevelInit()+0x9c>)
   147de:	481c      	ldr	r0, [pc, #112]	; (14850 <LowLevelInit()+0xa0>)
   147e0:	f003 f8ee 	bl	179c0 <printf>
                     "System Timer has FAILED to start!");
  // Set Clock Speed
  // SetClockFrequency will timeout return the offset between desire clockspeed
  // and actual clockspeed if the PLL doesn't get a frequency fix within a
  // defined timeout (see L1/system_clock.hpp:kDefaultTimeout)
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   147e4:	2130      	movs	r1, #48	; 0x30
   147e6:	481b      	ldr	r0, [pc, #108]	; (14854 <LowLevelInit()+0xa4>)
   147e8:	f7fc fe7a 	bl	114e0 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>
   147ec:	4603      	mov	r3, r0
   147ee:	2b00      	cmp	r3, #0
   147f0:	bf14      	ite	ne
   147f2:	2301      	movne	r3, #1
   147f4:	2300      	moveq	r3, #0
   147f6:	b2db      	uxtb	r3, r3
   147f8:	2b00      	cmp	r3, #0
   147fa:	d001      	beq.n	14800 <LowLevelInit()+0x50>
  {
    // Continually attempt to set the clock frequency to the desired until the
    // delta between desired and actual are 0.
    continue;
   147fc:	bf00      	nop
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   147fe:	e7f1      	b.n	147e4 <LowLevelInit()+0x34>
  }
  // Enable Peripheral Clock and set its divider to 1 meaning the clock speed
  // fed to all peripherals will be 48Mhz.
  system_controller.SetPeripheralClockDivider(1);
   14800:	2101      	movs	r1, #1
   14802:	4814      	ldr	r0, [pc, #80]	; (14854 <LowLevelInit()+0xa4>)
   14804:	f7fc feb4 	bl	11570 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>
  // Set System Timer frequency again, since the clock speed has changed since
  // the last time we ran this.
  system_timer.DisableTimer();
   14808:	f7ff f8ae 	bl	13968 <SystemTimer::DisableTimer()>
  system_timer.SetTickFrequency(config::kRtosFrequency);
   1480c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   14810:	480c      	ldr	r0, [pc, #48]	; (14844 <LowLevelInit()+0x94>)
   14812:	f7ff f949 	bl	13aa8 <SystemTimer::SetTickFrequency(unsigned long)>
  system_timer.StartTimer();
   14816:	480b      	ldr	r0, [pc, #44]	; (14844 <LowLevelInit()+0x94>)
   14818:	f7ff f8f8 	bl	13a0c <SystemTimer::StartTimer()>
  // Set timer0 to 1 MHz (1,000,000 Hz) so that the timer increments every 1
  // micro second.
  timer0.Initialize(1'000'000);
   1481c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14820:	4a0d      	ldr	r2, [pc, #52]	; (14858 <LowLevelInit()+0xa8>)
   14822:	490e      	ldr	r1, [pc, #56]	; (1485c <LowLevelInit()+0xac>)
   14824:	480e      	ldr	r0, [pc, #56]	; (14860 <LowLevelInit()+0xb0>)
   14826:	f7ff f9b1 	bl	13b8c <Timer::Initialize(unsigned long, void (*)(), long)>
  SetUptimeFunction(Lpc40xxUptime);
   1482a:	480e      	ldr	r0, [pc, #56]	; (14864 <LowLevelInit()+0xb4>)
   1482c:	f7ff f884 	bl	13938 <SetUptimeFunction(unsigned long long (*)())>
  // Set UART0 baudrate, which is required for printf and scanf to work properly
  uart0.Initialize(config::kBaudRate);
   14830:	f44f 4116 	mov.w	r1, #38400	; 0x9600
   14834:	480c      	ldr	r0, [pc, #48]	; (14868 <LowLevelInit()+0xb8>)
   14836:	f7ff fb5b 	bl	13ef0 <Uart::Initialize(unsigned long)>
}
   1483a:	bf00      	nop
   1483c:	b003      	add	sp, #12
   1483e:	f85d fb04 	ldr.w	pc, [sp], #4
   14842:	bf00      	nop
   14844:	100007d4 	.word	0x100007d4
   14848:	0001ae68 	.word	0x0001ae68
   1484c:	0001ad70 	.word	0x0001ad70
   14850:	0001acc8 	.word	0x0001acc8
   14854:	100007dc 	.word	0x100007dc
   14858:	00013b6d 	.word	0x00013b6d
   1485c:	000f4240 	.word	0x000f4240
   14860:	100007e0 	.word	0x100007e0
   14864:	000146a5 	.word	0x000146a5
   14868:	100007c0 	.word	0x100007c0

0001486c <SystemInit>:

void SystemInit()
{
   1486c:	b508      	push	{r3, lr}
  // Transfer data section values from flash to RAM
  InitDataSection();
   1486e:	f7fb fc4d 	bl	1010c <InitDataSection()>
  // Clear BSS section of RAM
  // This is required because the nano implementation of the standard C/C++
  // libraries assumes that the BSS section is initialized to 0.
  InitBssSection();
   14872:	f7fb fc93 	bl	1019c <InitBssSection()>
  // Enable FPU (F.loating P.oint U.nit)
  // System will crash if floating point operations occur without
  // Initializing the FPU.
  InitFpu();
   14876:	f7fb fcc1 	bl	101fc <InitFpu()>
  // Initialisation C++ libraries
  __libc_init_array();
   1487a:	f004 fda7 	bl	193cc <__libc_init_array>
  // Run LowLevel System Initialization
  LowLevelInit();
   1487e:	f7ff ff97 	bl	147b0 <LowLevelInit()>
}
   14882:	bf00      	nop
   14884:	bd08      	pop	{r3, pc}
   14886:	Address 0x0000000000014886 is out of bounds.


00014888 <ResetIsr>:
// Sets up a simple runtime environment and initializes the C/C++ library.

extern "C"
{
  void ResetIsr(void)
  {
   14888:	b580      	push	{r7, lr}
   1488a:	b084      	sub	sp, #16
   1488c:	af00      	add	r7, sp, #0
    // The Hyperload bootloader takes up stack space to execute. The Hyperload
    // bootloader function launches this ISR manually, but it never returns thus
    // it never cleans up the memory it uses. To get that memory back, we have
    // to manually move the stack pointers back to the top of stack.
    const uint32_t kTopOfStack = reinterpret_cast<intptr_t>(&StackTop);
   1488e:	4b09      	ldr	r3, [pc, #36]	; (148b4 <ResetIsr+0x2c>)
   14890:	60fb      	str	r3, [r7, #12]
   14892:	68fb      	ldr	r3, [r7, #12]
   14894:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
   14896:	683b      	ldr	r3, [r7, #0]
   14898:	f383 8809 	msr	PSP, r3
   1489c:	68fb      	ldr	r3, [r7, #12]
   1489e:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
   148a0:	687b      	ldr	r3, [r7, #4]
   148a2:	f383 8808 	msr	MSP, r3
    __set_PSP(kTopOfStack);
    __set_MSP(kTopOfStack);

    SystemInit();
   148a6:	f7ff ffe1 	bl	1486c <SystemInit>
// #pragma ignored "-Wpedantic" to suppress main function call warning
#pragma GCC diagnostic push ignored "-Wpedantic"
    [[maybe_unused]] int32_t result = main();
   148aa:	f7fe fd85 	bl	133b8 <main>
   148ae:	60b8      	str	r0, [r7, #8]
   148b0:	e7fe      	b.n	148b0 <ResetIsr+0x28>
   148b2:	bf00      	nop
   148b4:	10010000 	.word	0x10010000

000148b8 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()>:
  static void TimerHandler()
   148b8:	b510      	push	{r4, lr}
   148ba:	4674      	mov	r4, lr
   148bc:	4623      	mov	r3, r4
   148be:	4619      	mov	r1, r3
   148c0:	480a      	ldr	r0, [pc, #40]	; (148ec <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   148c2:	f000 fc99 	bl	151f8 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   148c6:	2000      	movs	r0, #0
   148c8:	f7ff f938 	bl	13b3c <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   148cc:	4603      	mov	r3, r0
   148ce:	461a      	mov	r2, r3
   148d0:	4b07      	ldr	r3, [pc, #28]	; (148f0 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x38>)
   148d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   148d6:	4798      	blx	r3
    ClearInterrupts<port>();
   148d8:	f000 f90e 	bl	14af8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>
   148dc:	4623      	mov	r3, r4
   148de:	4619      	mov	r1, r3
   148e0:	4802      	ldr	r0, [pc, #8]	; (148ec <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   148e2:	f000 fc9d 	bl	15220 <__cyg_profile_func_exit>
  }
   148e6:	bf00      	nop
   148e8:	bd10      	pop	{r4, pc}
   148ea:	bf00      	nop
   148ec:	000148b9 	.word	0x000148b9
   148f0:	10001284 	.word	0x10001284

000148f4 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()>:
  static void TimerHandler()
   148f4:	b510      	push	{r4, lr}
   148f6:	4674      	mov	r4, lr
   148f8:	4623      	mov	r3, r4
   148fa:	4619      	mov	r1, r3
   148fc:	480a      	ldr	r0, [pc, #40]	; (14928 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   148fe:	f000 fc7b 	bl	151f8 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   14902:	2001      	movs	r0, #1
   14904:	f7ff f91a 	bl	13b3c <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14908:	4603      	mov	r3, r0
   1490a:	461a      	mov	r2, r3
   1490c:	4b07      	ldr	r3, [pc, #28]	; (1492c <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x38>)
   1490e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   14912:	4798      	blx	r3
    ClearInterrupts<port>();
   14914:	f000 f940 	bl	14b98 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>
   14918:	4623      	mov	r3, r4
   1491a:	4619      	mov	r1, r3
   1491c:	4802      	ldr	r0, [pc, #8]	; (14928 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   1491e:	f000 fc7f 	bl	15220 <__cyg_profile_func_exit>
  }
   14922:	bf00      	nop
   14924:	bd10      	pop	{r4, pc}
   14926:	bf00      	nop
   14928:	000148f5 	.word	0x000148f5
   1492c:	10001284 	.word	0x10001284

00014930 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()>:
  static void TimerHandler()
   14930:	b510      	push	{r4, lr}
   14932:	4674      	mov	r4, lr
   14934:	4623      	mov	r3, r4
   14936:	4619      	mov	r1, r3
   14938:	480a      	ldr	r0, [pc, #40]	; (14964 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   1493a:	f000 fc5d 	bl	151f8 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   1493e:	2002      	movs	r0, #2
   14940:	f7ff f8fc 	bl	13b3c <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14944:	4603      	mov	r3, r0
   14946:	461a      	mov	r2, r3
   14948:	4b07      	ldr	r3, [pc, #28]	; (14968 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x38>)
   1494a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1494e:	4798      	blx	r3
    ClearInterrupts<port>();
   14950:	f000 f972 	bl	14c38 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>
   14954:	4623      	mov	r3, r4
   14956:	4619      	mov	r1, r3
   14958:	4802      	ldr	r0, [pc, #8]	; (14964 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   1495a:	f000 fc61 	bl	15220 <__cyg_profile_func_exit>
  }
   1495e:	bf00      	nop
   14960:	bd10      	pop	{r4, pc}
   14962:	bf00      	nop
   14964:	00014931 	.word	0x00014931
   14968:	10001284 	.word	0x10001284

0001496c <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()>:
  static void TimerHandler()
   1496c:	b510      	push	{r4, lr}
   1496e:	4674      	mov	r4, lr
   14970:	4623      	mov	r3, r4
   14972:	4619      	mov	r1, r3
   14974:	480a      	ldr	r0, [pc, #40]	; (149a0 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   14976:	f000 fc3f 	bl	151f8 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   1497a:	2003      	movs	r0, #3
   1497c:	f7ff f8de 	bl	13b3c <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   14980:	4603      	mov	r3, r0
   14982:	461a      	mov	r2, r3
   14984:	4b07      	ldr	r3, [pc, #28]	; (149a4 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x38>)
   14986:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1498a:	4798      	blx	r3
    ClearInterrupts<port>();
   1498c:	f000 f9a4 	bl	14cd8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>
   14990:	4623      	mov	r3, r4
   14992:	4619      	mov	r1, r3
   14994:	4802      	ldr	r0, [pc, #8]	; (149a0 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   14996:	f000 fc43 	bl	15220 <__cyg_profile_func_exit>
  }
   1499a:	bf00      	nop
   1499c:	bd10      	pop	{r4, pc}
   1499e:	bf00      	nop
   149a0:	0001496d 	.word	0x0001496d
   149a4:	10001284 	.word	0x10001284

000149a8 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   149a8:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   149ac:	b088      	sub	sp, #32
   149ae:	4675      	mov	r5, lr
   149b0:	e9cd 0102 	strd	r0, r1, [sp, #8]
   149b4:	9201      	str	r2, [sp, #4]
   149b6:	462b      	mov	r3, r5
   149b8:	4619      	mov	r1, r3
   149ba:	4824      	ldr	r0, [pc, #144]	; (14a4c <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   149bc:	f000 fc1c 	bl	151f8 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   149c0:	f04f 0300 	mov.w	r3, #0
   149c4:	f04f 0400 	mov.w	r4, #0
   149c8:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   149cc:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   149d0:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   149d4:	bf08      	it	eq
   149d6:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   149da:	d106      	bne.n	149ea <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   149dc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   149e0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   149e4:	e9cd 3406 	strd	r3, r4, [sp, #24]
   149e8:	e00b      	b.n	14a02 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   149ea:	f7fc f88b 	bl	10b04 <Milliseconds()>
   149ee:	460a      	mov	r2, r1
   149f0:	4601      	mov	r1, r0
   149f2:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   149f6:	eb13 0b01 	adds.w	fp, r3, r1
   149fa:	eb44 0c02 	adc.w	ip, r4, r2
   149fe:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   14a02:	2301      	movs	r3, #1
   14a04:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   14a06:	f7fc f87d 	bl	10b04 <Milliseconds()>
   14a0a:	460a      	mov	r2, r1
   14a0c:	4601      	mov	r1, r0
   14a0e:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   14a12:	42a2      	cmp	r2, r4
   14a14:	bf08      	it	eq
   14a16:	4299      	cmpeq	r1, r3
   14a18:	bf34      	ite	cc
   14a1a:	2301      	movcc	r3, #1
   14a1c:	2300      	movcs	r3, #0
   14a1e:	b2db      	uxtb	r3, r3
   14a20:	2b00      	cmp	r3, #0
   14a22:	d008      	beq.n	14a36 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x8e>
    if (is_done())
   14a24:	ab01      	add	r3, sp, #4
   14a26:	4618      	mov	r0, r3
   14a28:	f7ff fad4 	bl	13fd4 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   14a2c:	4603      	mov	r3, r0
   14a2e:	2b00      	cmp	r3, #0
   14a30:	d0e9      	beq.n	14a06 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   14a32:	2300      	movs	r3, #0
   14a34:	9305      	str	r3, [sp, #20]
  return status;
   14a36:	9c05      	ldr	r4, [sp, #20]
   14a38:	462b      	mov	r3, r5
   14a3a:	4619      	mov	r1, r3
   14a3c:	4803      	ldr	r0, [pc, #12]	; (14a4c <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   14a3e:	f000 fbef 	bl	15220 <__cyg_profile_func_exit>
   14a42:	4623      	mov	r3, r4
}
   14a44:	4618      	mov	r0, r3
   14a46:	b008      	add	sp, #32
   14a48:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   14a4c:	000149a9 	.word	0x000149a9

00014a50 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   14a50:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   14a54:	b088      	sub	sp, #32
   14a56:	4675      	mov	r5, lr
   14a58:	e9cd 0102 	strd	r0, r1, [sp, #8]
   14a5c:	9201      	str	r2, [sp, #4]
   14a5e:	462b      	mov	r3, r5
   14a60:	4619      	mov	r1, r3
   14a62:	4824      	ldr	r0, [pc, #144]	; (14af4 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   14a64:	f000 fbc8 	bl	151f8 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   14a68:	f04f 0300 	mov.w	r3, #0
   14a6c:	f04f 0400 	mov.w	r4, #0
   14a70:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   14a74:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   14a78:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   14a7c:	bf08      	it	eq
   14a7e:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   14a82:	d106      	bne.n	14a92 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   14a84:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14a88:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   14a8c:	e9cd 3406 	strd	r3, r4, [sp, #24]
   14a90:	e00b      	b.n	14aaa <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   14a92:	f7fc f837 	bl	10b04 <Milliseconds()>
   14a96:	460a      	mov	r2, r1
   14a98:	4601      	mov	r1, r0
   14a9a:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   14a9e:	eb13 0b01 	adds.w	fp, r3, r1
   14aa2:	eb44 0c02 	adc.w	ip, r4, r2
   14aa6:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   14aaa:	2301      	movs	r3, #1
   14aac:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   14aae:	f7fc f829 	bl	10b04 <Milliseconds()>
   14ab2:	460a      	mov	r2, r1
   14ab4:	4601      	mov	r1, r0
   14ab6:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   14aba:	42a2      	cmp	r2, r4
   14abc:	bf08      	it	eq
   14abe:	4299      	cmpeq	r1, r3
   14ac0:	bf34      	ite	cc
   14ac2:	2301      	movcc	r3, #1
   14ac4:	2300      	movcs	r3, #0
   14ac6:	b2db      	uxtb	r3, r3
   14ac8:	2b00      	cmp	r3, #0
   14aca:	d008      	beq.n	14ade <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x8e>
    if (is_done())
   14acc:	ab01      	add	r3, sp, #4
   14ace:	4618      	mov	r0, r3
   14ad0:	f7ff fb1a 	bl	14108 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   14ad4:	4603      	mov	r3, r0
   14ad6:	2b00      	cmp	r3, #0
   14ad8:	d0e9      	beq.n	14aae <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   14ada:	2300      	movs	r3, #0
   14adc:	9305      	str	r3, [sp, #20]
  return status;
   14ade:	9c05      	ldr	r4, [sp, #20]
   14ae0:	462b      	mov	r3, r5
   14ae2:	4619      	mov	r1, r3
   14ae4:	4803      	ldr	r0, [pc, #12]	; (14af4 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   14ae6:	f000 fb9b 	bl	15220 <__cyg_profile_func_exit>
   14aea:	4623      	mov	r3, r4
}
   14aec:	4618      	mov	r0, r3
   14aee:	b008      	add	sp, #32
   14af0:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   14af4:	00014a51 	.word	0x00014a51

00014af8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>:
  static void ClearInterrupts()
   14af8:	b510      	push	{r4, lr}
   14afa:	b082      	sub	sp, #8
   14afc:	4674      	mov	r4, lr
   14afe:	4623      	mov	r3, r4
   14b00:	4619      	mov	r1, r3
   14b02:	4823      	ldr	r0, [pc, #140]	; (14b90 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   14b04:	f000 fb78 	bl	151f8 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14b08:	2300      	movs	r3, #0
   14b0a:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14b0e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b12:	4a20      	ldr	r2, [pc, #128]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b18:	681a      	ldr	r2, [r3, #0]
   14b1a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b1e:	491d      	ldr	r1, [pc, #116]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b20:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14b24:	f042 0201 	orr.w	r2, r2, #1
   14b28:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14b2a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b2e:	4a19      	ldr	r2, [pc, #100]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b34:	681a      	ldr	r2, [r3, #0]
   14b36:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b3a:	4916      	ldr	r1, [pc, #88]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14b40:	f042 0202 	orr.w	r2, r2, #2
   14b44:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14b46:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b4a:	4a12      	ldr	r2, [pc, #72]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b50:	681a      	ldr	r2, [r3, #0]
   14b52:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b56:	490f      	ldr	r1, [pc, #60]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b58:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14b5c:	f042 0204 	orr.w	r2, r2, #4
   14b60:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14b62:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b66:	4a0b      	ldr	r2, [pc, #44]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b6c:	681a      	ldr	r2, [r3, #0]
   14b6e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14b72:	4908      	ldr	r1, [pc, #32]	; (14b94 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   14b74:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14b78:	f042 0208 	orr.w	r2, r2, #8
   14b7c:	601a      	str	r2, [r3, #0]
   14b7e:	4623      	mov	r3, r4
   14b80:	4619      	mov	r1, r3
   14b82:	4803      	ldr	r0, [pc, #12]	; (14b90 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   14b84:	f000 fb4c 	bl	15220 <__cyg_profile_func_exit>
  }
   14b88:	bf00      	nop
   14b8a:	b002      	add	sp, #8
   14b8c:	bd10      	pop	{r4, pc}
   14b8e:	bf00      	nop
   14b90:	00014af9 	.word	0x00014af9
   14b94:	10000760 	.word	0x10000760

00014b98 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>:
  static void ClearInterrupts()
   14b98:	b510      	push	{r4, lr}
   14b9a:	b082      	sub	sp, #8
   14b9c:	4674      	mov	r4, lr
   14b9e:	4623      	mov	r3, r4
   14ba0:	4619      	mov	r1, r3
   14ba2:	4823      	ldr	r0, [pc, #140]	; (14c30 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   14ba4:	f000 fb28 	bl	151f8 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14ba8:	2301      	movs	r3, #1
   14baa:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14bae:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14bb2:	4a20      	ldr	r2, [pc, #128]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14bb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14bb8:	681a      	ldr	r2, [r3, #0]
   14bba:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14bbe:	491d      	ldr	r1, [pc, #116]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14bc0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14bc4:	f042 0201 	orr.w	r2, r2, #1
   14bc8:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14bca:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14bce:	4a19      	ldr	r2, [pc, #100]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14bd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14bd4:	681a      	ldr	r2, [r3, #0]
   14bd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14bda:	4916      	ldr	r1, [pc, #88]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14bdc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14be0:	f042 0202 	orr.w	r2, r2, #2
   14be4:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14be6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14bea:	4a12      	ldr	r2, [pc, #72]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14bec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14bf0:	681a      	ldr	r2, [r3, #0]
   14bf2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14bf6:	490f      	ldr	r1, [pc, #60]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14bf8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14bfc:	f042 0204 	orr.w	r2, r2, #4
   14c00:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14c02:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c06:	4a0b      	ldr	r2, [pc, #44]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14c08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c0c:	681a      	ldr	r2, [r3, #0]
   14c0e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c12:	4908      	ldr	r1, [pc, #32]	; (14c34 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   14c14:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14c18:	f042 0208 	orr.w	r2, r2, #8
   14c1c:	601a      	str	r2, [r3, #0]
   14c1e:	4623      	mov	r3, r4
   14c20:	4619      	mov	r1, r3
   14c22:	4803      	ldr	r0, [pc, #12]	; (14c30 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   14c24:	f000 fafc 	bl	15220 <__cyg_profile_func_exit>
  }
   14c28:	bf00      	nop
   14c2a:	b002      	add	sp, #8
   14c2c:	bd10      	pop	{r4, pc}
   14c2e:	bf00      	nop
   14c30:	00014b99 	.word	0x00014b99
   14c34:	10000760 	.word	0x10000760

00014c38 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>:
  static void ClearInterrupts()
   14c38:	b510      	push	{r4, lr}
   14c3a:	b082      	sub	sp, #8
   14c3c:	4674      	mov	r4, lr
   14c3e:	4623      	mov	r3, r4
   14c40:	4619      	mov	r1, r3
   14c42:	4823      	ldr	r0, [pc, #140]	; (14cd0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   14c44:	f000 fad8 	bl	151f8 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14c48:	2302      	movs	r3, #2
   14c4a:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14c4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c52:	4a20      	ldr	r2, [pc, #128]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14c54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c58:	681a      	ldr	r2, [r3, #0]
   14c5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c5e:	491d      	ldr	r1, [pc, #116]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14c60:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14c64:	f042 0201 	orr.w	r2, r2, #1
   14c68:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14c6a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c6e:	4a19      	ldr	r2, [pc, #100]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14c70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c74:	681a      	ldr	r2, [r3, #0]
   14c76:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c7a:	4916      	ldr	r1, [pc, #88]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14c7c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14c80:	f042 0202 	orr.w	r2, r2, #2
   14c84:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14c86:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c8a:	4a12      	ldr	r2, [pc, #72]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14c8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c90:	681a      	ldr	r2, [r3, #0]
   14c92:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c96:	490f      	ldr	r1, [pc, #60]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14c98:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14c9c:	f042 0204 	orr.w	r2, r2, #4
   14ca0:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14ca2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14ca6:	4a0b      	ldr	r2, [pc, #44]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14ca8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14cac:	681a      	ldr	r2, [r3, #0]
   14cae:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14cb2:	4908      	ldr	r1, [pc, #32]	; (14cd4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   14cb4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14cb8:	f042 0208 	orr.w	r2, r2, #8
   14cbc:	601a      	str	r2, [r3, #0]
   14cbe:	4623      	mov	r3, r4
   14cc0:	4619      	mov	r1, r3
   14cc2:	4803      	ldr	r0, [pc, #12]	; (14cd0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   14cc4:	f000 faac 	bl	15220 <__cyg_profile_func_exit>
  }
   14cc8:	bf00      	nop
   14cca:	b002      	add	sp, #8
   14ccc:	bd10      	pop	{r4, pc}
   14cce:	bf00      	nop
   14cd0:	00014c39 	.word	0x00014c39
   14cd4:	10000760 	.word	0x10000760

00014cd8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>:
  static void ClearInterrupts()
   14cd8:	b510      	push	{r4, lr}
   14cda:	b082      	sub	sp, #8
   14cdc:	4674      	mov	r4, lr
   14cde:	4623      	mov	r3, r4
   14ce0:	4619      	mov	r1, r3
   14ce2:	4823      	ldr	r0, [pc, #140]	; (14d70 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   14ce4:	f000 fa88 	bl	151f8 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   14ce8:	2303      	movs	r3, #3
   14cea:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   14cee:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14cf2:	4a20      	ldr	r2, [pc, #128]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14cf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14cf8:	681a      	ldr	r2, [r3, #0]
   14cfa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14cfe:	491d      	ldr	r1, [pc, #116]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14d00:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14d04:	f042 0201 	orr.w	r2, r2, #1
   14d08:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   14d0a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14d0e:	4a19      	ldr	r2, [pc, #100]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14d10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d14:	681a      	ldr	r2, [r3, #0]
   14d16:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14d1a:	4916      	ldr	r1, [pc, #88]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14d1c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14d20:	f042 0202 	orr.w	r2, r2, #2
   14d24:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   14d26:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14d2a:	4a12      	ldr	r2, [pc, #72]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14d2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d30:	681a      	ldr	r2, [r3, #0]
   14d32:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14d36:	490f      	ldr	r1, [pc, #60]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14d38:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14d3c:	f042 0204 	orr.w	r2, r2, #4
   14d40:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   14d42:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14d46:	4a0b      	ldr	r2, [pc, #44]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14d48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d4c:	681a      	ldr	r2, [r3, #0]
   14d4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14d52:	4908      	ldr	r1, [pc, #32]	; (14d74 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   14d54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   14d58:	f042 0208 	orr.w	r2, r2, #8
   14d5c:	601a      	str	r2, [r3, #0]
   14d5e:	4623      	mov	r3, r4
   14d60:	4619      	mov	r1, r3
   14d62:	4803      	ldr	r0, [pc, #12]	; (14d70 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   14d64:	f000 fa5c 	bl	15220 <__cyg_profile_func_exit>
  }
   14d68:	bf00      	nop
   14d6a:	b002      	add	sp, #8
   14d6c:	bd10      	pop	{r4, pc}
   14d6e:	bf00      	nop
   14d70:	00014cd9 	.word	0x00014cd9
   14d74:	10000760 	.word	0x10000760

00014d78 <__static_initialization_and_destruction_0(int, int)>:
#pragma GCC diagnostic pop
    // main() shouldn't return, but if it does, we'll just enter an infinite
    // loop
    Halt();
  }
}
   14d78:	b082      	sub	sp, #8
   14d7a:	9001      	str	r0, [sp, #4]
   14d7c:	9100      	str	r1, [sp, #0]
   14d7e:	9b01      	ldr	r3, [sp, #4]
   14d80:	2b01      	cmp	r3, #1
   14d82:	d15d      	bne.n	14e40 <__static_initialization_and_destruction_0(int, int)+0xc8>
   14d84:	9b00      	ldr	r3, [sp, #0]
   14d86:	f64f 72ff 	movw	r2, #65535	; 0xffff
   14d8a:	4293      	cmp	r3, r2
   14d8c:	d158      	bne.n	14e40 <__static_initialization_and_destruction_0(int, int)+0xc8>
  inline static volatile uint32_t * match[4][4] = {
   14d8e:	4b2e      	ldr	r3, [pc, #184]	; (14e48 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   14d90:	681b      	ldr	r3, [r3, #0]
   14d92:	f003 0301 	and.w	r3, r3, #1
   14d96:	2b00      	cmp	r3, #0
   14d98:	d152      	bne.n	14e40 <__static_initialization_and_destruction_0(int, int)+0xc8>
   14d9a:	4b2b      	ldr	r3, [pc, #172]	; (14e48 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   14d9c:	2201      	movs	r2, #1
   14d9e:	601a      	str	r2, [r3, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   14da0:	4b2a      	ldr	r3, [pc, #168]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14da2:	681b      	ldr	r3, [r3, #0]
   14da4:	3318      	adds	r3, #24
  };
   14da6:	4a2a      	ldr	r2, [pc, #168]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14da8:	6013      	str	r3, [r2, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   14daa:	4b28      	ldr	r3, [pc, #160]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14dac:	681b      	ldr	r3, [r3, #0]
   14dae:	331c      	adds	r3, #28
  };
   14db0:	4a27      	ldr	r2, [pc, #156]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14db2:	6053      	str	r3, [r2, #4]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   14db4:	4b25      	ldr	r3, [pc, #148]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14db6:	681b      	ldr	r3, [r3, #0]
   14db8:	3320      	adds	r3, #32
  };
   14dba:	4a25      	ldr	r2, [pc, #148]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14dbc:	6093      	str	r3, [r2, #8]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   14dbe:	4b23      	ldr	r3, [pc, #140]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14dc0:	681b      	ldr	r3, [r3, #0]
   14dc2:	3324      	adds	r3, #36	; 0x24
  };
   14dc4:	4a22      	ldr	r2, [pc, #136]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14dc6:	60d3      	str	r3, [r2, #12]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   14dc8:	4b20      	ldr	r3, [pc, #128]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14dca:	685b      	ldr	r3, [r3, #4]
   14dcc:	3318      	adds	r3, #24
  };
   14dce:	4a20      	ldr	r2, [pc, #128]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14dd0:	6113      	str	r3, [r2, #16]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   14dd2:	4b1e      	ldr	r3, [pc, #120]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14dd4:	685b      	ldr	r3, [r3, #4]
   14dd6:	331c      	adds	r3, #28
  };
   14dd8:	4a1d      	ldr	r2, [pc, #116]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14dda:	6153      	str	r3, [r2, #20]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   14ddc:	4b1b      	ldr	r3, [pc, #108]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14dde:	685b      	ldr	r3, [r3, #4]
   14de0:	3320      	adds	r3, #32
  };
   14de2:	4a1b      	ldr	r2, [pc, #108]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14de4:	6193      	str	r3, [r2, #24]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   14de6:	4b19      	ldr	r3, [pc, #100]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14de8:	685b      	ldr	r3, [r3, #4]
   14dea:	3324      	adds	r3, #36	; 0x24
  };
   14dec:	4a18      	ldr	r2, [pc, #96]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14dee:	61d3      	str	r3, [r2, #28]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   14df0:	4b16      	ldr	r3, [pc, #88]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14df2:	689b      	ldr	r3, [r3, #8]
   14df4:	3318      	adds	r3, #24
  };
   14df6:	4a16      	ldr	r2, [pc, #88]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14df8:	6213      	str	r3, [r2, #32]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   14dfa:	4b14      	ldr	r3, [pc, #80]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14dfc:	689b      	ldr	r3, [r3, #8]
   14dfe:	331c      	adds	r3, #28
  };
   14e00:	4a13      	ldr	r2, [pc, #76]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14e02:	6253      	str	r3, [r2, #36]	; 0x24
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   14e04:	4b11      	ldr	r3, [pc, #68]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14e06:	689b      	ldr	r3, [r3, #8]
   14e08:	3320      	adds	r3, #32
  };
   14e0a:	4a11      	ldr	r2, [pc, #68]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14e0c:	6293      	str	r3, [r2, #40]	; 0x28
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   14e0e:	4b0f      	ldr	r3, [pc, #60]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14e10:	689b      	ldr	r3, [r3, #8]
   14e12:	3324      	adds	r3, #36	; 0x24
  };
   14e14:	4a0e      	ldr	r2, [pc, #56]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14e16:	62d3      	str	r3, [r2, #44]	; 0x2c
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   14e18:	4b0c      	ldr	r3, [pc, #48]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14e1a:	68db      	ldr	r3, [r3, #12]
   14e1c:	3318      	adds	r3, #24
  };
   14e1e:	4a0c      	ldr	r2, [pc, #48]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14e20:	6313      	str	r3, [r2, #48]	; 0x30
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   14e22:	4b0a      	ldr	r3, [pc, #40]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14e24:	68db      	ldr	r3, [r3, #12]
   14e26:	331c      	adds	r3, #28
  };
   14e28:	4a09      	ldr	r2, [pc, #36]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14e2a:	6353      	str	r3, [r2, #52]	; 0x34
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   14e2c:	4b07      	ldr	r3, [pc, #28]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14e2e:	68db      	ldr	r3, [r3, #12]
   14e30:	3320      	adds	r3, #32
  };
   14e32:	4a07      	ldr	r2, [pc, #28]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14e34:	6393      	str	r3, [r2, #56]	; 0x38
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   14e36:	4b05      	ldr	r3, [pc, #20]	; (14e4c <__static_initialization_and_destruction_0(int, int)+0xd4>)
   14e38:	68db      	ldr	r3, [r3, #12]
   14e3a:	3324      	adds	r3, #36	; 0x24
  };
   14e3c:	4a04      	ldr	r2, [pc, #16]	; (14e50 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   14e3e:	63d3      	str	r3, [r2, #60]	; 0x3c
   14e40:	bf00      	nop
   14e42:	b002      	add	sp, #8
   14e44:	4770      	bx	lr
   14e46:	bf00      	nop
   14e48:	10001434 	.word	0x10001434
   14e4c:	10000760 	.word	0x10000760
   14e50:	10001244 	.word	0x10001244

00014e54 <_GLOBAL__sub_I_UptimeRTOS>:
   14e54:	b508      	push	{r3, lr}
   14e56:	f64f 71ff 	movw	r1, #65535	; 0xffff
   14e5a:	2001      	movs	r0, #1
   14e5c:	f7ff ff8c 	bl	14d78 <__static_initialization_and_destruction_0(int, int)>
   14e60:	bd08      	pop	{r3, pc}
   14e62:	Address 0x0000000000014e62 is out of bounds.


00014e64 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   14e64:	b082      	sub	sp, #8
   14e66:	4603      	mov	r3, r0
   14e68:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   14e6c:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   14e70:	f003 021f 	and.w	r2, r3, #31
   14e74:	4905      	ldr	r1, [pc, #20]	; (14e8c <NVIC_EnableIRQ+0x28>)
   14e76:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   14e7a:	095b      	lsrs	r3, r3, #5
   14e7c:	2001      	movs	r0, #1
   14e7e:	fa00 f202 	lsl.w	r2, r0, r2
   14e82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14e86:	bf00      	nop
   14e88:	b002      	add	sp, #8
   14e8a:	4770      	bx	lr
   14e8c:	e000e100 	.word	0xe000e100

00014e90 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   14e90:	b082      	sub	sp, #8
   14e92:	4603      	mov	r3, r0
   14e94:	9100      	str	r1, [sp, #0]
   14e96:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) < 0)
   14e9a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   14e9e:	2b00      	cmp	r3, #0
   14ea0:	da0c      	bge.n	14ebc <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   14ea2:	9b00      	ldr	r3, [sp, #0]
   14ea4:	b2da      	uxtb	r2, r3
   14ea6:	490d      	ldr	r1, [pc, #52]	; (14edc <NVIC_SetPriority+0x4c>)
   14ea8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   14eac:	f003 030f 	and.w	r3, r3, #15
   14eb0:	3b04      	subs	r3, #4
   14eb2:	0152      	lsls	r2, r2, #5
   14eb4:	b2d2      	uxtb	r2, r2
   14eb6:	440b      	add	r3, r1
   14eb8:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   14eba:	e00b      	b.n	14ed4 <NVIC_SetPriority+0x44>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   14ebc:	9b00      	ldr	r3, [sp, #0]
   14ebe:	b2db      	uxtb	r3, r3
   14ec0:	4a07      	ldr	r2, [pc, #28]	; (14ee0 <NVIC_SetPriority+0x50>)
   14ec2:	f99d 1007 	ldrsb.w	r1, [sp, #7]
   14ec6:	4608      	mov	r0, r1
   14ec8:	015b      	lsls	r3, r3, #5
   14eca:	b2d9      	uxtb	r1, r3
   14ecc:	1813      	adds	r3, r2, r0
   14ece:	460a      	mov	r2, r1
   14ed0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   14ed4:	bf00      	nop
   14ed6:	b002      	add	sp, #8
   14ed8:	4770      	bx	lr
   14eda:	bf00      	nop
   14edc:	e000ed00 	.word	0xe000ed00
   14ee0:	e000e100 	.word	0xe000e100

00014ee4 <InterruptLookupHandler>:
{
   14ee4:	b500      	push	{lr}
   14ee6:	b085      	sub	sp, #20
  uint8_t active_isr = (SCB->ICSR & 0xFF);
   14ee8:	4b12      	ldr	r3, [pc, #72]	; (14f34 <InterruptLookupHandler+0x50>)
   14eea:	685b      	ldr	r3, [r3, #4]
   14eec:	f88d 300f 	strb.w	r3, [sp, #15]
  IsrPointer isr     = dynamic_isr_vector_table[active_isr];
   14ef0:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14ef4:	4a10      	ldr	r2, [pc, #64]	; (14f38 <InterruptLookupHandler+0x54>)
   14ef6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14efa:	9302      	str	r3, [sp, #8]
  SJ2_ASSERT_FATAL(isr != InterruptLookupHandler,
   14efc:	9b02      	ldr	r3, [sp, #8]
   14efe:	4a0f      	ldr	r2, [pc, #60]	; (14f3c <InterruptLookupHandler+0x58>)
   14f00:	4293      	cmp	r3, r2
   14f02:	d110      	bne.n	14f26 <InterruptLookupHandler+0x42>
   14f04:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14f08:	9300      	str	r3, [sp, #0]
   14f0a:	23dd      	movs	r3, #221	; 0xdd
   14f0c:	4a0c      	ldr	r2, [pc, #48]	; (14f40 <InterruptLookupHandler+0x5c>)
   14f0e:	490d      	ldr	r1, [pc, #52]	; (14f44 <InterruptLookupHandler+0x60>)
   14f10:	480d      	ldr	r0, [pc, #52]	; (14f48 <InterruptLookupHandler+0x64>)
   14f12:	f002 fd55 	bl	179c0 <printf>
   14f16:	480d      	ldr	r0, [pc, #52]	; (14f4c <InterruptLookupHandler+0x68>)
   14f18:	f000 f93e 	bl	15198 <puts>
   14f1c:	2100      	movs	r1, #0
   14f1e:	2001      	movs	r0, #1
   14f20:	f7fb fd58 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   14f24:	e7fe      	b.n	14f24 <InterruptLookupHandler+0x40>
  isr();
   14f26:	9b02      	ldr	r3, [sp, #8]
   14f28:	4798      	blx	r3
}
   14f2a:	bf00      	nop
   14f2c:	b005      	add	sp, #20
   14f2e:	f85d fb04 	ldr.w	pc, [sp], #4
   14f32:	bf00      	nop
   14f34:	e000ed00 	.word	0xe000ed00
   14f38:	100007ec 	.word	0x100007ec
   14f3c:	00014ee5 	.word	0x00014ee5
   14f40:	0001b0e4 	.word	0x0001b0e4
   14f44:	0001b0d4 	.word	0x0001b0d4
   14f48:	0001af78 	.word	0x0001af78
   14f4c:	0001b024 	.word	0x0001b024

00014f50 <RegisterIsr(IRQn, void (*)(), bool, long)>:
{
   14f50:	b500      	push	{lr}
   14f52:	b085      	sub	sp, #20
   14f54:	9102      	str	r1, [sp, #8]
   14f56:	9301      	str	r3, [sp, #4]
   14f58:	4603      	mov	r3, r0
   14f5a:	f88d 300f 	strb.w	r3, [sp, #15]
   14f5e:	4613      	mov	r3, r2
   14f60:	f88d 300e 	strb.w	r3, [sp, #14]
  dynamic_isr_vector_table[irq + kIrqOffset] = isr;
   14f64:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   14f68:	3310      	adds	r3, #16
   14f6a:	490f      	ldr	r1, [pc, #60]	; (14fa8 <RegisterIsr(IRQn, void (*)(), bool, long)+0x58>)
   14f6c:	9a02      	ldr	r2, [sp, #8]
   14f6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  if (enable_interrupt && irq >= 0)
   14f72:	f89d 300e 	ldrb.w	r3, [sp, #14]
   14f76:	2b00      	cmp	r3, #0
   14f78:	d008      	beq.n	14f8c <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
   14f7a:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   14f7e:	2b00      	cmp	r3, #0
   14f80:	db04      	blt.n	14f8c <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
    NVIC_EnableIRQ(irq);
   14f82:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   14f86:	4618      	mov	r0, r3
   14f88:	f7ff ff6c 	bl	14e64 <NVIC_EnableIRQ>
  if (priority > -1)
   14f8c:	9b01      	ldr	r3, [sp, #4]
   14f8e:	2b00      	cmp	r3, #0
   14f90:	db06      	blt.n	14fa0 <RegisterIsr(IRQn, void (*)(), bool, long)+0x50>
    NVIC_SetPriority(irq, priority);
   14f92:	9a01      	ldr	r2, [sp, #4]
   14f94:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   14f98:	4611      	mov	r1, r2
   14f9a:	4618      	mov	r0, r3
   14f9c:	f7ff ff78 	bl	14e90 <NVIC_SetPriority>
}
   14fa0:	bf00      	nop
   14fa2:	b005      	add	sp, #20
   14fa4:	f85d fb04 	ldr.w	pc, [sp], #4
   14fa8:	100007ec 	.word	0x100007ec

00014fac <GetRegistersFromStack>:
{
   14fac:	b500      	push	{lr}
   14fae:	b08d      	sub	sp, #52	; 0x34
   14fb0:	9003      	str	r0, [sp, #12]
  volatile uint32_t r0  = fault_stack_address[0];
   14fb2:	9b03      	ldr	r3, [sp, #12]
   14fb4:	681b      	ldr	r3, [r3, #0]
   14fb6:	930b      	str	r3, [sp, #44]	; 0x2c
  volatile uint32_t r1  = fault_stack_address[1];
   14fb8:	9b03      	ldr	r3, [sp, #12]
   14fba:	685b      	ldr	r3, [r3, #4]
   14fbc:	930a      	str	r3, [sp, #40]	; 0x28
  volatile uint32_t r2  = fault_stack_address[2];
   14fbe:	9b03      	ldr	r3, [sp, #12]
   14fc0:	689b      	ldr	r3, [r3, #8]
   14fc2:	9309      	str	r3, [sp, #36]	; 0x24
  volatile uint32_t r3  = fault_stack_address[3];
   14fc4:	9b03      	ldr	r3, [sp, #12]
   14fc6:	68db      	ldr	r3, [r3, #12]
   14fc8:	9308      	str	r3, [sp, #32]
  volatile uint32_t r12 = fault_stack_address[4];
   14fca:	9b03      	ldr	r3, [sp, #12]
   14fcc:	691b      	ldr	r3, [r3, #16]
   14fce:	9307      	str	r3, [sp, #28]
  volatile uint32_t lr = fault_stack_address[5];
   14fd0:	9b03      	ldr	r3, [sp, #12]
   14fd2:	695b      	ldr	r3, [r3, #20]
   14fd4:	9306      	str	r3, [sp, #24]
  volatile uint32_t pc = fault_stack_address[6];
   14fd6:	9b03      	ldr	r3, [sp, #12]
   14fd8:	699b      	ldr	r3, [r3, #24]
   14fda:	9305      	str	r3, [sp, #20]
  volatile uint32_t psr = fault_stack_address[7];
   14fdc:	9b03      	ldr	r3, [sp, #12]
   14fde:	69db      	ldr	r3, [r3, #28]
   14fe0:	9304      	str	r3, [sp, #16]
  printf(SJ2_BACKGROUND_RED "Hard Fault Exception Occurred!\n" SJ2_COLOR_RESET);
   14fe2:	480d      	ldr	r0, [pc, #52]	; (15018 <GetRegistersFromStack+0x6c>)
   14fe4:	f002 fcec 	bl	179c0 <printf>
  printf("r0: 0x%08" PRIX32 ", r1: 0x%08" PRIX32
   14fe8:	990b      	ldr	r1, [sp, #44]	; 0x2c
   14fea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14fec:	9809      	ldr	r0, [sp, #36]	; 0x24
   14fee:	9b08      	ldr	r3, [sp, #32]
   14ff0:	9300      	str	r3, [sp, #0]
   14ff2:	4603      	mov	r3, r0
   14ff4:	4809      	ldr	r0, [pc, #36]	; (1501c <GetRegistersFromStack+0x70>)
   14ff6:	f002 fce3 	bl	179c0 <printf>
  printf("r12: 0x%08" PRIX32 ", lr: 0x%08" PRIX32
   14ffa:	9907      	ldr	r1, [sp, #28]
   14ffc:	9a06      	ldr	r2, [sp, #24]
   14ffe:	9805      	ldr	r0, [sp, #20]
   15000:	9b04      	ldr	r3, [sp, #16]
   15002:	9300      	str	r3, [sp, #0]
   15004:	4603      	mov	r3, r0
   15006:	4806      	ldr	r0, [pc, #24]	; (15020 <GetRegistersFromStack+0x74>)
   15008:	f002 fcda 	bl	179c0 <printf>
  debug::PrintBacktrace(true, reinterpret_cast<void *>(pc));
   1500c:	9b05      	ldr	r3, [sp, #20]
   1500e:	4619      	mov	r1, r3
   15010:	2001      	movs	r0, #1
   15012:	f7fb fcdf 	bl	109d4 <debug::PrintBacktrace(bool, void*)>
   15016:	e7fe      	b.n	15016 <GetRegistersFromStack+0x6a>
   15018:	0001b03c 	.word	0x0001b03c
   1501c:	0001b068 	.word	0x0001b068
   15020:	0001b09c 	.word	0x0001b09c

00015024 <FirmwareStdOut(int)>:
}
Stdout out = HostWrite;
Stdin in   = HostRead;
#else
int FirmwareStdOut(int data)
{
   15024:	b530      	push	{r4, r5, lr}
   15026:	b083      	sub	sp, #12
   15028:	4675      	mov	r5, lr
   1502a:	9001      	str	r0, [sp, #4]
   1502c:	462b      	mov	r3, r5
   1502e:	4619      	mov	r1, r3
   15030:	4809      	ldr	r0, [pc, #36]	; (15058 <FirmwareStdOut(int)+0x34>)
   15032:	f000 f8e1 	bl	151f8 <__cyg_profile_func_enter>
  uart0.Send(static_cast<uint8_t>(data));
   15036:	9b01      	ldr	r3, [sp, #4]
   15038:	b2db      	uxtb	r3, r3
   1503a:	4619      	mov	r1, r3
   1503c:	4807      	ldr	r0, [pc, #28]	; (1505c <FirmwareStdOut(int)+0x38>)
   1503e:	f7fe ffef 	bl	14020 <Uart::Send(unsigned char)>
  return 1;
   15042:	2401      	movs	r4, #1
   15044:	462b      	mov	r3, r5
   15046:	4619      	mov	r1, r3
   15048:	4803      	ldr	r0, [pc, #12]	; (15058 <FirmwareStdOut(int)+0x34>)
   1504a:	f000 f8e9 	bl	15220 <__cyg_profile_func_exit>
   1504e:	4623      	mov	r3, r4
}
   15050:	4618      	mov	r0, r3
   15052:	b003      	add	sp, #12
   15054:	bd30      	pop	{r4, r5, pc}
   15056:	bf00      	nop
   15058:	00015025 	.word	0x00015025
   1505c:	100007c0 	.word	0x100007c0

00015060 <_exit>:
  }
  // Dummy implementation of exit with return code placed into
  // Arm register r3
  // NOLINTNEXTLINE(readability-identifier-naming)
  void _exit([[maybe_unused]] int rc)
  {
   15060:	b500      	push	{lr}
   15062:	b083      	sub	sp, #12
   15064:	4673      	mov	r3, lr
   15066:	9001      	str	r0, [sp, #4]
   15068:	4619      	mov	r1, r3
   1506a:	4802      	ldr	r0, [pc, #8]	; (15074 <_exit+0x14>)
   1506c:	f000 f8c4 	bl	151f8 <__cyg_profile_func_enter>
    while (1)
    {
      continue;
   15070:	bf00      	nop
    while (1)
   15072:	e7fd      	b.n	15070 <_exit+0x10>
   15074:	00015061 	.word	0x00015061

00015078 <_getpid>:
    }
  }
  // Dummy implementation of getpid
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _getpid()
  {
   15078:	b538      	push	{r3, r4, r5, lr}
   1507a:	4675      	mov	r5, lr
   1507c:	462b      	mov	r3, r5
   1507e:	4619      	mov	r1, r3
   15080:	4805      	ldr	r0, [pc, #20]	; (15098 <_getpid+0x20>)
   15082:	f000 f8b9 	bl	151f8 <__cyg_profile_func_enter>
    return 1;
   15086:	2401      	movs	r4, #1
   15088:	462b      	mov	r3, r5
   1508a:	4619      	mov	r1, r3
   1508c:	4802      	ldr	r0, [pc, #8]	; (15098 <_getpid+0x20>)
   1508e:	f000 f8c7 	bl	15220 <__cyg_profile_func_exit>
   15092:	4623      	mov	r3, r4
  }
   15094:	4618      	mov	r0, r3
   15096:	bd38      	pop	{r3, r4, r5, pc}
   15098:	00015079 	.word	0x00015079

0001509c <_kill>:
  // Dummy implementation of kill
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _kill(int, int)
  {
   1509c:	b530      	push	{r4, r5, lr}
   1509e:	b083      	sub	sp, #12
   150a0:	4675      	mov	r5, lr
   150a2:	9001      	str	r0, [sp, #4]
   150a4:	9100      	str	r1, [sp, #0]
   150a6:	462b      	mov	r3, r5
   150a8:	4619      	mov	r1, r3
   150aa:	4807      	ldr	r0, [pc, #28]	; (150c8 <_kill+0x2c>)
   150ac:	f000 f8a4 	bl	151f8 <__cyg_profile_func_enter>
    return -1;
   150b0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   150b4:	462b      	mov	r3, r5
   150b6:	4619      	mov	r1, r3
   150b8:	4803      	ldr	r0, [pc, #12]	; (150c8 <_kill+0x2c>)
   150ba:	f000 f8b1 	bl	15220 <__cyg_profile_func_exit>
   150be:	4623      	mov	r3, r4
  }
   150c0:	4618      	mov	r0, r3
   150c2:	b003      	add	sp, #12
   150c4:	bd30      	pop	{r4, r5, pc}
   150c6:	bf00      	nop
   150c8:	0001509d 	.word	0x0001509d

000150cc <_sbrk>:
    return 0;
  }
  // Implementation of sbrk for allocating and deallocating space for malloc.
  // NOLINTNEXTLINE(readability-identifier-naming)
  void * _sbrk(int increment)
  {
   150cc:	b530      	push	{r4, r5, lr}
   150ce:	b085      	sub	sp, #20
   150d0:	4675      	mov	r5, lr
   150d2:	9001      	str	r0, [sp, #4]
   150d4:	462b      	mov	r3, r5
   150d6:	4619      	mov	r1, r3
   150d8:	480f      	ldr	r0, [pc, #60]	; (15118 <_sbrk+0x4c>)
   150da:	f000 f88d 	bl	151f8 <__cyg_profile_func_enter>
    void * previous_heap_position  = static_cast<void *>(heap_position);
   150de:	4b0f      	ldr	r3, [pc, #60]	; (1511c <_sbrk+0x50>)
   150e0:	681b      	ldr	r3, [r3, #0]
   150e2:	9303      	str	r3, [sp, #12]
    // Check that by allocating this space, we do not exceed the heap area.
    if ((heap_position + increment) > &heap_end)
   150e4:	4b0d      	ldr	r3, [pc, #52]	; (1511c <_sbrk+0x50>)
   150e6:	681a      	ldr	r2, [r3, #0]
   150e8:	9b01      	ldr	r3, [sp, #4]
   150ea:	4413      	add	r3, r2
   150ec:	4a0c      	ldr	r2, [pc, #48]	; (15120 <_sbrk+0x54>)
   150ee:	4293      	cmp	r3, r2
   150f0:	d901      	bls.n	150f6 <_sbrk+0x2a>
    {
      previous_heap_position = nullptr;
   150f2:	2300      	movs	r3, #0
   150f4:	9303      	str	r3, [sp, #12]
    }
    heap_position += increment;
   150f6:	4b09      	ldr	r3, [pc, #36]	; (1511c <_sbrk+0x50>)
   150f8:	681a      	ldr	r2, [r3, #0]
   150fa:	9b01      	ldr	r3, [sp, #4]
   150fc:	4413      	add	r3, r2
   150fe:	4a07      	ldr	r2, [pc, #28]	; (1511c <_sbrk+0x50>)
   15100:	6013      	str	r3, [r2, #0]
    return previous_heap_position;
   15102:	9c03      	ldr	r4, [sp, #12]
   15104:	462b      	mov	r3, r5
   15106:	4619      	mov	r1, r3
   15108:	4803      	ldr	r0, [pc, #12]	; (15118 <_sbrk+0x4c>)
   1510a:	f000 f889 	bl	15220 <__cyg_profile_func_exit>
   1510e:	4623      	mov	r3, r4
  }
   15110:	4618      	mov	r0, r3
   15112:	b005      	add	sp, #20
   15114:	bd30      	pop	{r4, r5, pc}
   15116:	bf00      	nop
   15118:	000150cd 	.word	0x000150cd
   1511c:	100008d0 	.word	0x100008d0
   15120:	20008000 	.word	0x20008000

00015124 <_putchar>:
    }
    return length;
  }
  // Needed by third party printf library
  void _putchar(char character)  // NOLINT
  {
   15124:	b510      	push	{r4, lr}
   15126:	b082      	sub	sp, #8
   15128:	4674      	mov	r4, lr
   1512a:	4603      	mov	r3, r0
   1512c:	f88d 3007 	strb.w	r3, [sp, #7]
   15130:	4623      	mov	r3, r4
   15132:	4619      	mov	r1, r3
   15134:	4808      	ldr	r0, [pc, #32]	; (15158 <_putchar+0x34>)
   15136:	f000 f85f 	bl	151f8 <__cyg_profile_func_enter>
    out(character);
   1513a:	4b08      	ldr	r3, [pc, #32]	; (1515c <_putchar+0x38>)
   1513c:	681b      	ldr	r3, [r3, #0]
   1513e:	f89d 2007 	ldrb.w	r2, [sp, #7]
   15142:	4610      	mov	r0, r2
   15144:	4798      	blx	r3
   15146:	4623      	mov	r3, r4
   15148:	4619      	mov	r1, r3
   1514a:	4803      	ldr	r0, [pc, #12]	; (15158 <_putchar+0x34>)
   1514c:	f000 f868 	bl	15220 <__cyg_profile_func_exit>
  }
   15150:	bf00      	nop
   15152:	b002      	add	sp, #8
   15154:	bd10      	pop	{r4, pc}
   15156:	bf00      	nop
   15158:	00015125 	.word	0x00015125
   1515c:	100008d4 	.word	0x100008d4

00015160 <putchar>:

  // Overload default libnano putchar() with a more optimal version that does
  // not use dynamic memory
  int putchar(int character)  // NOLINT
  {
   15160:	b530      	push	{r4, r5, lr}
   15162:	b083      	sub	sp, #12
   15164:	4674      	mov	r4, lr
   15166:	9001      	str	r0, [sp, #4]
   15168:	4623      	mov	r3, r4
   1516a:	4619      	mov	r1, r3
   1516c:	4808      	ldr	r0, [pc, #32]	; (15190 <putchar+0x30>)
   1516e:	f000 f843 	bl	151f8 <__cyg_profile_func_enter>
    return out(character);
   15172:	4b08      	ldr	r3, [pc, #32]	; (15194 <putchar+0x34>)
   15174:	681b      	ldr	r3, [r3, #0]
   15176:	9801      	ldr	r0, [sp, #4]
   15178:	4798      	blx	r3
   1517a:	4605      	mov	r5, r0
   1517c:	4623      	mov	r3, r4
   1517e:	4619      	mov	r1, r3
   15180:	4803      	ldr	r0, [pc, #12]	; (15190 <putchar+0x30>)
   15182:	f000 f84d 	bl	15220 <__cyg_profile_func_exit>
   15186:	462b      	mov	r3, r5
  }
   15188:	4618      	mov	r0, r3
   1518a:	b003      	add	sp, #12
   1518c:	bd30      	pop	{r4, r5, pc}
   1518e:	bf00      	nop
   15190:	00015161 	.word	0x00015161
   15194:	100008d4 	.word	0x100008d4

00015198 <puts>:

  // Overload default libnano puts() with a more optimal version that does
  // not use dynamic memory
  int puts(const char * str)  // NOLINT
  {
   15198:	b530      	push	{r4, r5, lr}
   1519a:	b085      	sub	sp, #20
   1519c:	4675      	mov	r5, lr
   1519e:	9001      	str	r0, [sp, #4]
   151a0:	462b      	mov	r3, r5
   151a2:	4619      	mov	r1, r3
   151a4:	4812      	ldr	r0, [pc, #72]	; (151f0 <puts+0x58>)
   151a6:	f000 f827 	bl	151f8 <__cyg_profile_func_enter>
    int i;
    for (i = 0; str[i] != '\0'; i++)
   151aa:	2300      	movs	r3, #0
   151ac:	9303      	str	r3, [sp, #12]
   151ae:	9b03      	ldr	r3, [sp, #12]
   151b0:	9a01      	ldr	r2, [sp, #4]
   151b2:	4413      	add	r3, r2
   151b4:	781b      	ldrb	r3, [r3, #0]
   151b6:	2b00      	cmp	r3, #0
   151b8:	d00b      	beq.n	151d2 <puts+0x3a>
    {
      out(str[i]);
   151ba:	4b0e      	ldr	r3, [pc, #56]	; (151f4 <puts+0x5c>)
   151bc:	681b      	ldr	r3, [r3, #0]
   151be:	9a03      	ldr	r2, [sp, #12]
   151c0:	9901      	ldr	r1, [sp, #4]
   151c2:	440a      	add	r2, r1
   151c4:	7812      	ldrb	r2, [r2, #0]
   151c6:	4610      	mov	r0, r2
   151c8:	4798      	blx	r3
    for (i = 0; str[i] != '\0'; i++)
   151ca:	9b03      	ldr	r3, [sp, #12]
   151cc:	3301      	adds	r3, #1
   151ce:	9303      	str	r3, [sp, #12]
   151d0:	e7ed      	b.n	151ae <puts+0x16>
    }
    out('\n');
   151d2:	4b08      	ldr	r3, [pc, #32]	; (151f4 <puts+0x5c>)
   151d4:	681b      	ldr	r3, [r3, #0]
   151d6:	200a      	movs	r0, #10
   151d8:	4798      	blx	r3
    return i;
   151da:	9c03      	ldr	r4, [sp, #12]
   151dc:	462b      	mov	r3, r5
   151de:	4619      	mov	r1, r3
   151e0:	4803      	ldr	r0, [pc, #12]	; (151f0 <puts+0x58>)
   151e2:	f000 f81d 	bl	15220 <__cyg_profile_func_exit>
   151e6:	4623      	mov	r3, r4
  }
   151e8:	4618      	mov	r0, r3
   151ea:	b005      	add	sp, #20
   151ec:	bd30      	pop	{r4, r5, pc}
   151ee:	bf00      	nop
   151f0:	00015199 	.word	0x00015199
   151f4:	100008d4 	.word	0x100008d4

000151f8 <__cyg_profile_func_enter>:
  // =============================
  void * stack_trace[config::kBacktraceDepth] = { nullptr };
  size_t stack_depth = 0;

  void __cyg_profile_func_enter(void *, void * call_site)  // NOLINT
  {
   151f8:	b082      	sub	sp, #8
   151fa:	9001      	str	r0, [sp, #4]
   151fc:	9100      	str	r1, [sp, #0]
    stack_trace[stack_depth++] = call_site;
   151fe:	9a00      	ldr	r2, [sp, #0]
   15200:	4b05      	ldr	r3, [pc, #20]	; (15218 <__cyg_profile_func_enter+0x20>)
   15202:	681b      	ldr	r3, [r3, #0]
   15204:	1c59      	adds	r1, r3, #1
   15206:	4804      	ldr	r0, [pc, #16]	; (15218 <__cyg_profile_func_enter+0x20>)
   15208:	6001      	str	r1, [r0, #0]
   1520a:	4904      	ldr	r1, [pc, #16]	; (1521c <__cyg_profile_func_enter+0x24>)
   1520c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
   15210:	bf00      	nop
   15212:	b002      	add	sp, #8
   15214:	4770      	bx	lr
   15216:	bf00      	nop
   15218:	10001538 	.word	0x10001538
   1521c:	10001438 	.word	0x10001438

00015220 <__cyg_profile_func_exit>:

  void __cyg_profile_func_exit(void *, void *)  // NOLINT
  {
   15220:	b082      	sub	sp, #8
   15222:	9001      	str	r0, [sp, #4]
   15224:	9100      	str	r1, [sp, #0]
    stack_depth--;
   15226:	4b04      	ldr	r3, [pc, #16]	; (15238 <__cyg_profile_func_exit+0x18>)
   15228:	681b      	ldr	r3, [r3, #0]
   1522a:	3b01      	subs	r3, #1
   1522c:	4a02      	ldr	r2, [pc, #8]	; (15238 <__cyg_profile_func_exit+0x18>)
   1522e:	6013      	str	r3, [r2, #0]
  }
   15230:	bf00      	nop
   15232:	b002      	add	sp, #8
   15234:	4770      	bx	lr
   15236:	bf00      	nop
   15238:	10001538 	.word	0x10001538

0001523c <GetStackTrace()>:
}

void ** GetStackTrace()
{
   1523c:	b538      	push	{r3, r4, r5, lr}
   1523e:	4675      	mov	r5, lr
   15240:	462b      	mov	r3, r5
   15242:	4619      	mov	r1, r3
   15244:	4805      	ldr	r0, [pc, #20]	; (1525c <GetStackTrace()+0x20>)
   15246:	f7ff ffd7 	bl	151f8 <__cyg_profile_func_enter>
  return stack_trace;
   1524a:	4c05      	ldr	r4, [pc, #20]	; (15260 <GetStackTrace()+0x24>)
   1524c:	462b      	mov	r3, r5
   1524e:	4619      	mov	r1, r3
   15250:	4802      	ldr	r0, [pc, #8]	; (1525c <GetStackTrace()+0x20>)
   15252:	f7ff ffe5 	bl	15220 <__cyg_profile_func_exit>
   15256:	4623      	mov	r3, r4
}
   15258:	4618      	mov	r0, r3
   1525a:	bd38      	pop	{r3, r4, r5, pc}
   1525c:	0001523d 	.word	0x0001523d
   15260:	10001438 	.word	0x10001438

00015264 <GetStackDepth()>:

size_t GetStackDepth()
{
   15264:	b538      	push	{r3, r4, r5, lr}
   15266:	4675      	mov	r5, lr
   15268:	462b      	mov	r3, r5
   1526a:	4619      	mov	r1, r3
   1526c:	4806      	ldr	r0, [pc, #24]	; (15288 <GetStackDepth()+0x24>)
   1526e:	f7ff ffc3 	bl	151f8 <__cyg_profile_func_enter>
  return stack_depth;
   15272:	4b06      	ldr	r3, [pc, #24]	; (1528c <GetStackDepth()+0x28>)
   15274:	681c      	ldr	r4, [r3, #0]
   15276:	462b      	mov	r3, r5
   15278:	4619      	mov	r1, r3
   1527a:	4803      	ldr	r0, [pc, #12]	; (15288 <GetStackDepth()+0x24>)
   1527c:	f7ff ffd0 	bl	15220 <__cyg_profile_func_exit>
   15280:	4623      	mov	r3, r4
}
   15282:	4618      	mov	r0, r3
   15284:	bd38      	pop	{r3, r4, r5, pc}
   15286:	bf00      	nop
   15288:	00015265 	.word	0x00015265
   1528c:	10001538 	.word	0x10001538

00015290 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   15290:	b082      	sub	sp, #8
   15292:	9001      	str	r0, [sp, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   15294:	9b01      	ldr	r3, [sp, #4]
   15296:	f103 0208 	add.w	r2, r3, #8
   1529a:	9b01      	ldr	r3, [sp, #4]
   1529c:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   1529e:	9b01      	ldr	r3, [sp, #4]
   152a0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   152a4:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   152a6:	9b01      	ldr	r3, [sp, #4]
   152a8:	f103 0208 	add.w	r2, r3, #8
   152ac:	9b01      	ldr	r3, [sp, #4]
   152ae:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   152b0:	9b01      	ldr	r3, [sp, #4]
   152b2:	f103 0208 	add.w	r2, r3, #8
   152b6:	9b01      	ldr	r3, [sp, #4]
   152b8:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   152ba:	9b01      	ldr	r3, [sp, #4]
   152bc:	2200      	movs	r2, #0
   152be:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   152c0:	bf00      	nop
   152c2:	b002      	add	sp, #8
   152c4:	4770      	bx	lr

000152c6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   152c6:	b082      	sub	sp, #8
   152c8:	9001      	str	r0, [sp, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   152ca:	9b01      	ldr	r3, [sp, #4]
   152cc:	2200      	movs	r2, #0
   152ce:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   152d0:	bf00      	nop
   152d2:	b002      	add	sp, #8
   152d4:	4770      	bx	lr

000152d6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   152d6:	b084      	sub	sp, #16
   152d8:	9001      	str	r0, [sp, #4]
   152da:	9100      	str	r1, [sp, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   152dc:	9b01      	ldr	r3, [sp, #4]
   152de:	685b      	ldr	r3, [r3, #4]
   152e0:	9303      	str	r3, [sp, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   152e2:	9b00      	ldr	r3, [sp, #0]
   152e4:	9a03      	ldr	r2, [sp, #12]
   152e6:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   152e8:	9b03      	ldr	r3, [sp, #12]
   152ea:	689a      	ldr	r2, [r3, #8]
   152ec:	9b00      	ldr	r3, [sp, #0]
   152ee:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   152f0:	9b03      	ldr	r3, [sp, #12]
   152f2:	689b      	ldr	r3, [r3, #8]
   152f4:	9a00      	ldr	r2, [sp, #0]
   152f6:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   152f8:	9b03      	ldr	r3, [sp, #12]
   152fa:	9a00      	ldr	r2, [sp, #0]
   152fc:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   152fe:	9b00      	ldr	r3, [sp, #0]
   15300:	9a01      	ldr	r2, [sp, #4]
   15302:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   15304:	9b01      	ldr	r3, [sp, #4]
   15306:	681b      	ldr	r3, [r3, #0]
   15308:	1c5a      	adds	r2, r3, #1
   1530a:	9b01      	ldr	r3, [sp, #4]
   1530c:	601a      	str	r2, [r3, #0]
}
   1530e:	bf00      	nop
   15310:	b004      	add	sp, #16
   15312:	4770      	bx	lr

00015314 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   15314:	b084      	sub	sp, #16
   15316:	9001      	str	r0, [sp, #4]
   15318:	9100      	str	r1, [sp, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   1531a:	9b00      	ldr	r3, [sp, #0]
   1531c:	681b      	ldr	r3, [r3, #0]
   1531e:	9302      	str	r3, [sp, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   15320:	9b02      	ldr	r3, [sp, #8]
   15322:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   15326:	d103      	bne.n	15330 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   15328:	9b01      	ldr	r3, [sp, #4]
   1532a:	691b      	ldr	r3, [r3, #16]
   1532c:	9303      	str	r3, [sp, #12]
   1532e:	e00c      	b.n	1534a <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   15330:	9b01      	ldr	r3, [sp, #4]
   15332:	3308      	adds	r3, #8
   15334:	9303      	str	r3, [sp, #12]
   15336:	e002      	b.n	1533e <vListInsert+0x2a>
   15338:	9b03      	ldr	r3, [sp, #12]
   1533a:	685b      	ldr	r3, [r3, #4]
   1533c:	9303      	str	r3, [sp, #12]
   1533e:	9b03      	ldr	r3, [sp, #12]
   15340:	685b      	ldr	r3, [r3, #4]
   15342:	681b      	ldr	r3, [r3, #0]
   15344:	9a02      	ldr	r2, [sp, #8]
   15346:	429a      	cmp	r2, r3
   15348:	d2f6      	bcs.n	15338 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   1534a:	9b03      	ldr	r3, [sp, #12]
   1534c:	685a      	ldr	r2, [r3, #4]
   1534e:	9b00      	ldr	r3, [sp, #0]
   15350:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   15352:	9b00      	ldr	r3, [sp, #0]
   15354:	685b      	ldr	r3, [r3, #4]
   15356:	9a00      	ldr	r2, [sp, #0]
   15358:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   1535a:	9b00      	ldr	r3, [sp, #0]
   1535c:	9a03      	ldr	r2, [sp, #12]
   1535e:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   15360:	9b03      	ldr	r3, [sp, #12]
   15362:	9a00      	ldr	r2, [sp, #0]
   15364:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   15366:	9b00      	ldr	r3, [sp, #0]
   15368:	9a01      	ldr	r2, [sp, #4]
   1536a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   1536c:	9b01      	ldr	r3, [sp, #4]
   1536e:	681b      	ldr	r3, [r3, #0]
   15370:	1c5a      	adds	r2, r3, #1
   15372:	9b01      	ldr	r3, [sp, #4]
   15374:	601a      	str	r2, [r3, #0]
}
   15376:	bf00      	nop
   15378:	b004      	add	sp, #16
   1537a:	4770      	bx	lr

0001537c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   1537c:	b084      	sub	sp, #16
   1537e:	9001      	str	r0, [sp, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   15380:	9b01      	ldr	r3, [sp, #4]
   15382:	691b      	ldr	r3, [r3, #16]
   15384:	9303      	str	r3, [sp, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   15386:	9b01      	ldr	r3, [sp, #4]
   15388:	685b      	ldr	r3, [r3, #4]
   1538a:	9a01      	ldr	r2, [sp, #4]
   1538c:	6892      	ldr	r2, [r2, #8]
   1538e:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   15390:	9b01      	ldr	r3, [sp, #4]
   15392:	689b      	ldr	r3, [r3, #8]
   15394:	9a01      	ldr	r2, [sp, #4]
   15396:	6852      	ldr	r2, [r2, #4]
   15398:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   1539a:	9b03      	ldr	r3, [sp, #12]
   1539c:	685b      	ldr	r3, [r3, #4]
   1539e:	9a01      	ldr	r2, [sp, #4]
   153a0:	429a      	cmp	r2, r3
   153a2:	d103      	bne.n	153ac <uxListRemove+0x30>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   153a4:	9b01      	ldr	r3, [sp, #4]
   153a6:	689a      	ldr	r2, [r3, #8]
   153a8:	9b03      	ldr	r3, [sp, #12]
   153aa:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   153ac:	9b01      	ldr	r3, [sp, #4]
   153ae:	2200      	movs	r2, #0
   153b0:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   153b2:	9b03      	ldr	r3, [sp, #12]
   153b4:	681b      	ldr	r3, [r3, #0]
   153b6:	1e5a      	subs	r2, r3, #1
   153b8:	9b03      	ldr	r3, [sp, #12]
   153ba:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   153bc:	9b03      	ldr	r3, [sp, #12]
   153be:	681b      	ldr	r3, [r3, #0]
}
   153c0:	4618      	mov	r0, r3
   153c2:	b004      	add	sp, #16
   153c4:	4770      	bx	lr

000153c6 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
   153c6:	b500      	push	{lr}
   153c8:	b08b      	sub	sp, #44	; 0x2c
   153ca:	9007      	str	r0, [sp, #28]
   153cc:	9106      	str	r1, [sp, #24]
   153ce:	9205      	str	r2, [sp, #20]
   153d0:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
   153d2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   153d4:	2b00      	cmp	r3, #0
   153d6:	d01d      	beq.n	15414 <xTaskCreateStatic+0x4e>
   153d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   153da:	2b00      	cmp	r3, #0
   153dc:	d01a      	beq.n	15414 <xTaskCreateStatic+0x4e>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
   153de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   153e0:	9309      	str	r3, [sp, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
   153e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   153e4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   153e6:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
   153e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   153ea:	2202      	movs	r2, #2
   153ec:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
   153f0:	2300      	movs	r3, #0
   153f2:	9303      	str	r3, [sp, #12]
   153f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   153f6:	9302      	str	r3, [sp, #8]
   153f8:	ab08      	add	r3, sp, #32
   153fa:	9301      	str	r3, [sp, #4]
   153fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   153fe:	9300      	str	r3, [sp, #0]
   15400:	9b04      	ldr	r3, [sp, #16]
   15402:	9a05      	ldr	r2, [sp, #20]
   15404:	9906      	ldr	r1, [sp, #24]
   15406:	9807      	ldr	r0, [sp, #28]
   15408:	f000 f852 	bl	154b0 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   1540c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1540e:	f000 f8c9 	bl	155a4 <prvAddNewTaskToReadyList>
   15412:	e001      	b.n	15418 <xTaskCreateStatic+0x52>
		}
		else
		{
			xReturn = NULL;
   15414:	2300      	movs	r3, #0
   15416:	9308      	str	r3, [sp, #32]
		}

		return xReturn;
   15418:	9b08      	ldr	r3, [sp, #32]
	}
   1541a:	4618      	mov	r0, r3
   1541c:	b00b      	add	sp, #44	; 0x2c
   1541e:	f85d fb04 	ldr.w	pc, [sp], #4

00015422 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   15422:	b500      	push	{lr}
   15424:	b08d      	sub	sp, #52	; 0x34
   15426:	9007      	str	r0, [sp, #28]
   15428:	9106      	str	r1, [sp, #24]
   1542a:	9304      	str	r3, [sp, #16]
   1542c:	4613      	mov	r3, r2
   1542e:	f8ad 3016 	strh.w	r3, [sp, #22]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   15432:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   15436:	009b      	lsls	r3, r3, #2
   15438:	4618      	mov	r0, r3
   1543a:	f001 f91f 	bl	1667c <pvPortMalloc>
   1543e:	9009      	str	r0, [sp, #36]	; 0x24

			if( pxStack != NULL )
   15440:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15442:	2b00      	cmp	r3, #0
   15444:	d00e      	beq.n	15464 <xTaskCreate+0x42>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   15446:	2060      	movs	r0, #96	; 0x60
   15448:	f001 f918 	bl	1667c <pvPortMalloc>
   1544c:	900b      	str	r0, [sp, #44]	; 0x2c

				if( pxNewTCB != NULL )
   1544e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15450:	2b00      	cmp	r3, #0
   15452:	d003      	beq.n	1545c <xTaskCreate+0x3a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   15454:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15456:	9a09      	ldr	r2, [sp, #36]	; 0x24
   15458:	631a      	str	r2, [r3, #48]	; 0x30
   1545a:	e005      	b.n	15468 <xTaskCreate+0x46>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   1545c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1545e:	f001 f91e 	bl	1669e <vPortFree>
   15462:	e001      	b.n	15468 <xTaskCreate+0x46>
				}
			}
			else
			{
				pxNewTCB = NULL;
   15464:	2300      	movs	r3, #0
   15466:	930b      	str	r3, [sp, #44]	; 0x2c
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   15468:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1546a:	2b00      	cmp	r3, #0
   1546c:	d018      	beq.n	154a0 <xTaskCreate+0x7e>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
   1546e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15470:	2200      	movs	r2, #0
   15472:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   15476:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   1547a:	2300      	movs	r3, #0
   1547c:	9303      	str	r3, [sp, #12]
   1547e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15480:	9302      	str	r3, [sp, #8]
   15482:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   15484:	9301      	str	r3, [sp, #4]
   15486:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   15488:	9300      	str	r3, [sp, #0]
   1548a:	9b04      	ldr	r3, [sp, #16]
   1548c:	9906      	ldr	r1, [sp, #24]
   1548e:	9807      	ldr	r0, [sp, #28]
   15490:	f000 f80e 	bl	154b0 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   15494:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15496:	f000 f885 	bl	155a4 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   1549a:	2301      	movs	r3, #1
   1549c:	930a      	str	r3, [sp, #40]	; 0x28
   1549e:	e002      	b.n	154a6 <xTaskCreate+0x84>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   154a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   154a4:	930a      	str	r3, [sp, #40]	; 0x28
		}

		return xReturn;
   154a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	}
   154a8:	4618      	mov	r0, r3
   154aa:	b00d      	add	sp, #52	; 0x34
   154ac:	f85d fb04 	ldr.w	pc, [sp], #4

000154b0 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   154b0:	b500      	push	{lr}
   154b2:	b087      	sub	sp, #28
   154b4:	9003      	str	r0, [sp, #12]
   154b6:	9102      	str	r1, [sp, #8]
   154b8:	9201      	str	r2, [sp, #4]
   154ba:	9300      	str	r3, [sp, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   154bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   154be:	6b18      	ldr	r0, [r3, #48]	; 0x30
   154c0:	9b01      	ldr	r3, [sp, #4]
   154c2:	009b      	lsls	r3, r3, #2
   154c4:	461a      	mov	r2, r3
   154c6:	21a5      	movs	r1, #165	; 0xa5
   154c8:	f003 ffbf 	bl	1944a <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   154cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   154ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   154d0:	9b01      	ldr	r3, [sp, #4]
   154d2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   154d6:	3b01      	subs	r3, #1
   154d8:	009b      	lsls	r3, r3, #2
   154da:	4413      	add	r3, r2
   154dc:	9304      	str	r3, [sp, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   154de:	9b04      	ldr	r3, [sp, #16]
   154e0:	f023 0307 	bic.w	r3, r3, #7
   154e4:	9304      	str	r3, [sp, #16]
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   154e6:	2300      	movs	r3, #0
   154e8:	9305      	str	r3, [sp, #20]
   154ea:	e012      	b.n	15512 <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   154ec:	9a02      	ldr	r2, [sp, #8]
   154ee:	9b05      	ldr	r3, [sp, #20]
   154f0:	4413      	add	r3, r2
   154f2:	7819      	ldrb	r1, [r3, #0]
   154f4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   154f6:	9b05      	ldr	r3, [sp, #20]
   154f8:	4413      	add	r3, r2
   154fa:	3334      	adds	r3, #52	; 0x34
   154fc:	460a      	mov	r2, r1
   154fe:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   15500:	9a02      	ldr	r2, [sp, #8]
   15502:	9b05      	ldr	r3, [sp, #20]
   15504:	4413      	add	r3, r2
   15506:	781b      	ldrb	r3, [r3, #0]
   15508:	2b00      	cmp	r3, #0
   1550a:	d006      	beq.n	1551a <prvInitialiseNewTask+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   1550c:	9b05      	ldr	r3, [sp, #20]
   1550e:	3301      	adds	r3, #1
   15510:	9305      	str	r3, [sp, #20]
   15512:	9b05      	ldr	r3, [sp, #20]
   15514:	2b0f      	cmp	r3, #15
   15516:	d9e9      	bls.n	154ec <prvInitialiseNewTask+0x3c>
   15518:	e000      	b.n	1551c <prvInitialiseNewTask+0x6c>
		{
			break;
   1551a:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   1551c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1551e:	2200      	movs	r2, #0
   15520:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   15524:	9b08      	ldr	r3, [sp, #32]
   15526:	2b04      	cmp	r3, #4
   15528:	d901      	bls.n	1552e <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1552a:	2304      	movs	r3, #4
   1552c:	9308      	str	r3, [sp, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   1552e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15530:	9a08      	ldr	r2, [sp, #32]
   15532:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   15534:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15536:	9a08      	ldr	r2, [sp, #32]
   15538:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
   1553a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1553c:	2200      	movs	r2, #0
   1553e:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   15540:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15542:	3304      	adds	r3, #4
   15544:	4618      	mov	r0, r3
   15546:	f7ff febe 	bl	152c6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   1554a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1554c:	3318      	adds	r3, #24
   1554e:	4618      	mov	r0, r3
   15550:	f7ff feb9 	bl	152c6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   15554:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15556:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   15558:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1555a:	9b08      	ldr	r3, [sp, #32]
   1555c:	f1c3 0205 	rsb	r2, r3, #5
   15560:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15562:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   15564:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15566:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   15568:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
   1556a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1556c:	2200      	movs	r2, #0
   1556e:	655a      	str	r2, [r3, #84]	; 0x54
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   15570:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15572:	2200      	movs	r2, #0
   15574:	659a      	str	r2, [r3, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   15576:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15578:	2200      	movs	r2, #0
   1557a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   1557e:	9a00      	ldr	r2, [sp, #0]
   15580:	9903      	ldr	r1, [sp, #12]
   15582:	9804      	ldr	r0, [sp, #16]
   15584:	f000 ff52 	bl	1642c <pxPortInitialiseStack>
   15588:	4602      	mov	r2, r0
   1558a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1558c:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   1558e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15590:	2b00      	cmp	r3, #0
   15592:	d002      	beq.n	1559a <prvInitialiseNewTask+0xea>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   15594:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15596:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   15598:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   1559a:	bf00      	nop
   1559c:	b007      	add	sp, #28
   1559e:	f85d fb04 	ldr.w	pc, [sp], #4
   155a2:	Address 0x00000000000155a2 is out of bounds.


000155a4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   155a4:	b500      	push	{lr}
   155a6:	b083      	sub	sp, #12
   155a8:	9001      	str	r0, [sp, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   155aa:	f000 ffdb 	bl	16564 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   155ae:	4b2d      	ldr	r3, [pc, #180]	; (15664 <prvAddNewTaskToReadyList+0xc0>)
   155b0:	681b      	ldr	r3, [r3, #0]
   155b2:	3301      	adds	r3, #1
   155b4:	4a2b      	ldr	r2, [pc, #172]	; (15664 <prvAddNewTaskToReadyList+0xc0>)
   155b6:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   155b8:	4b2b      	ldr	r3, [pc, #172]	; (15668 <prvAddNewTaskToReadyList+0xc4>)
   155ba:	681b      	ldr	r3, [r3, #0]
   155bc:	2b00      	cmp	r3, #0
   155be:	d109      	bne.n	155d4 <prvAddNewTaskToReadyList+0x30>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   155c0:	4a29      	ldr	r2, [pc, #164]	; (15668 <prvAddNewTaskToReadyList+0xc4>)
   155c2:	9b01      	ldr	r3, [sp, #4]
   155c4:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   155c6:	4b27      	ldr	r3, [pc, #156]	; (15664 <prvAddNewTaskToReadyList+0xc0>)
   155c8:	681b      	ldr	r3, [r3, #0]
   155ca:	2b01      	cmp	r3, #1
   155cc:	d110      	bne.n	155f0 <prvAddNewTaskToReadyList+0x4c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   155ce:	f000 fb1b 	bl	15c08 <prvInitialiseTaskLists>
   155d2:	e00d      	b.n	155f0 <prvAddNewTaskToReadyList+0x4c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   155d4:	4b25      	ldr	r3, [pc, #148]	; (1566c <prvAddNewTaskToReadyList+0xc8>)
   155d6:	681b      	ldr	r3, [r3, #0]
   155d8:	2b00      	cmp	r3, #0
   155da:	d109      	bne.n	155f0 <prvAddNewTaskToReadyList+0x4c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   155dc:	4b22      	ldr	r3, [pc, #136]	; (15668 <prvAddNewTaskToReadyList+0xc4>)
   155de:	681b      	ldr	r3, [r3, #0]
   155e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   155e2:	9b01      	ldr	r3, [sp, #4]
   155e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   155e6:	429a      	cmp	r2, r3
   155e8:	d802      	bhi.n	155f0 <prvAddNewTaskToReadyList+0x4c>
				{
					pxCurrentTCB = pxNewTCB;
   155ea:	4a1f      	ldr	r2, [pc, #124]	; (15668 <prvAddNewTaskToReadyList+0xc4>)
   155ec:	9b01      	ldr	r3, [sp, #4]
   155ee:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   155f0:	4b1f      	ldr	r3, [pc, #124]	; (15670 <prvAddNewTaskToReadyList+0xcc>)
   155f2:	681b      	ldr	r3, [r3, #0]
   155f4:	3301      	adds	r3, #1
   155f6:	4a1e      	ldr	r2, [pc, #120]	; (15670 <prvAddNewTaskToReadyList+0xcc>)
   155f8:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   155fa:	4b1d      	ldr	r3, [pc, #116]	; (15670 <prvAddNewTaskToReadyList+0xcc>)
   155fc:	681a      	ldr	r2, [r3, #0]
   155fe:	9b01      	ldr	r3, [sp, #4]
   15600:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   15602:	9b01      	ldr	r3, [sp, #4]
   15604:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15606:	2201      	movs	r2, #1
   15608:	409a      	lsls	r2, r3
   1560a:	4b1a      	ldr	r3, [pc, #104]	; (15674 <prvAddNewTaskToReadyList+0xd0>)
   1560c:	681b      	ldr	r3, [r3, #0]
   1560e:	4313      	orrs	r3, r2
   15610:	4a18      	ldr	r2, [pc, #96]	; (15674 <prvAddNewTaskToReadyList+0xd0>)
   15612:	6013      	str	r3, [r2, #0]
   15614:	9b01      	ldr	r3, [sp, #4]
   15616:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15618:	4613      	mov	r3, r2
   1561a:	009b      	lsls	r3, r3, #2
   1561c:	4413      	add	r3, r2
   1561e:	009b      	lsls	r3, r3, #2
   15620:	4a15      	ldr	r2, [pc, #84]	; (15678 <prvAddNewTaskToReadyList+0xd4>)
   15622:	441a      	add	r2, r3
   15624:	9b01      	ldr	r3, [sp, #4]
   15626:	3304      	adds	r3, #4
   15628:	4619      	mov	r1, r3
   1562a:	4610      	mov	r0, r2
   1562c:	f7ff fe53 	bl	152d6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   15630:	f000 ffac 	bl	1658c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   15634:	4b0d      	ldr	r3, [pc, #52]	; (1566c <prvAddNewTaskToReadyList+0xc8>)
   15636:	681b      	ldr	r3, [r3, #0]
   15638:	2b00      	cmp	r3, #0
   1563a:	d00e      	beq.n	1565a <prvAddNewTaskToReadyList+0xb6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   1563c:	4b0a      	ldr	r3, [pc, #40]	; (15668 <prvAddNewTaskToReadyList+0xc4>)
   1563e:	681b      	ldr	r3, [r3, #0]
   15640:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15642:	9b01      	ldr	r3, [sp, #4]
   15644:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15646:	429a      	cmp	r2, r3
   15648:	d207      	bcs.n	1565a <prvAddNewTaskToReadyList+0xb6>
		{
			taskYIELD_IF_USING_PREEMPTION();
   1564a:	4b0c      	ldr	r3, [pc, #48]	; (1567c <prvAddNewTaskToReadyList+0xd8>)
   1564c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   15650:	601a      	str	r2, [r3, #0]
   15652:	f3bf 8f4f 	dsb	sy
   15656:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   1565a:	bf00      	nop
   1565c:	b003      	add	sp, #12
   1565e:	f85d fb04 	ldr.w	pc, [sp], #4
   15662:	bf00      	nop
   15664:	10001614 	.word	0x10001614
   15668:	1000153c 	.word	0x1000153c
   1566c:	10001620 	.word	0x10001620
   15670:	10001630 	.word	0x10001630
   15674:	1000161c 	.word	0x1000161c
   15678:	10001540 	.word	0x10001540
   1567c:	e000ed04 	.word	0xe000ed04

00015680 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   15680:	b500      	push	{lr}
   15682:	b08b      	sub	sp, #44	; 0x2c
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   15684:	2300      	movs	r3, #0
   15686:	9307      	str	r3, [sp, #28]
		StackType_t *pxIdleTaskStackBuffer = NULL;
   15688:	2300      	movs	r3, #0
   1568a:	9306      	str	r3, [sp, #24]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   1568c:	aa05      	add	r2, sp, #20
   1568e:	a906      	add	r1, sp, #24
   15690:	ab07      	add	r3, sp, #28
   15692:	4618      	mov	r0, r3
   15694:	f7ff f85c 	bl	14750 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   15698:	9905      	ldr	r1, [sp, #20]
   1569a:	9b06      	ldr	r3, [sp, #24]
   1569c:	9a07      	ldr	r2, [sp, #28]
   1569e:	9202      	str	r2, [sp, #8]
   156a0:	9301      	str	r3, [sp, #4]
   156a2:	2300      	movs	r3, #0
   156a4:	9300      	str	r3, [sp, #0]
   156a6:	2300      	movs	r3, #0
   156a8:	460a      	mov	r2, r1
   156aa:	4916      	ldr	r1, [pc, #88]	; (15704 <vTaskStartScheduler+0x84>)
   156ac:	4816      	ldr	r0, [pc, #88]	; (15708 <vTaskStartScheduler+0x88>)
   156ae:	f7ff fe8a 	bl	153c6 <xTaskCreateStatic>
   156b2:	4602      	mov	r2, r0
   156b4:	4b15      	ldr	r3, [pc, #84]	; (1570c <vTaskStartScheduler+0x8c>)
   156b6:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
   156b8:	4b14      	ldr	r3, [pc, #80]	; (1570c <vTaskStartScheduler+0x8c>)
   156ba:	681b      	ldr	r3, [r3, #0]
   156bc:	2b00      	cmp	r3, #0
   156be:	d002      	beq.n	156c6 <vTaskStartScheduler+0x46>
		{
			xReturn = pdPASS;
   156c0:	2301      	movs	r3, #1
   156c2:	9309      	str	r3, [sp, #36]	; 0x24
   156c4:	e001      	b.n	156ca <vTaskStartScheduler+0x4a>
		}
		else
		{
			xReturn = pdFAIL;
   156c6:	2300      	movs	r3, #0
   156c8:	9309      	str	r3, [sp, #36]	; 0x24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   156ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
   156cc:	2b01      	cmp	r3, #1
   156ce:	d114      	bne.n	156fa <vTaskStartScheduler+0x7a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   156d0:	f04f 0328 	mov.w	r3, #40	; 0x28
   156d4:	f383 8811 	msr	BASEPRI, r3
   156d8:	f3bf 8f6f 	isb	sy
   156dc:	f3bf 8f4f 	dsb	sy
   156e0:	9308      	str	r3, [sp, #32]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   156e2:	4b0b      	ldr	r3, [pc, #44]	; (15710 <vTaskStartScheduler+0x90>)
   156e4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   156e8:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   156ea:	4b0a      	ldr	r3, [pc, #40]	; (15714 <vTaskStartScheduler+0x94>)
   156ec:	2201      	movs	r2, #1
   156ee:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   156f0:	4b09      	ldr	r3, [pc, #36]	; (15718 <vTaskStartScheduler+0x98>)
   156f2:	2200      	movs	r2, #0
   156f4:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   156f6:	f000 ff0b 	bl	16510 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   156fa:	bf00      	nop
   156fc:	b00b      	add	sp, #44	; 0x2c
   156fe:	f85d fb04 	ldr.w	pc, [sp], #4
   15702:	bf00      	nop
   15704:	0001b104 	.word	0x0001b104
   15708:	00015bfd 	.word	0x00015bfd
   1570c:	10001638 	.word	0x10001638
   15710:	10001634 	.word	0x10001634
   15714:	10001620 	.word	0x10001620
   15718:	10001618 	.word	0x10001618

0001571c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   1571c:	4b03      	ldr	r3, [pc, #12]	; (1572c <vTaskSuspendAll+0x10>)
   1571e:	681b      	ldr	r3, [r3, #0]
   15720:	3301      	adds	r3, #1
   15722:	4a02      	ldr	r2, [pc, #8]	; (1572c <vTaskSuspendAll+0x10>)
   15724:	6013      	str	r3, [r2, #0]
}
   15726:	bf00      	nop
   15728:	4770      	bx	lr
   1572a:	bf00      	nop
   1572c:	1000163c 	.word	0x1000163c

00015730 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   15730:	b500      	push	{lr}
   15732:	b085      	sub	sp, #20
TCB_t *pxTCB = NULL;
   15734:	2300      	movs	r3, #0
   15736:	9303      	str	r3, [sp, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   15738:	2300      	movs	r3, #0
   1573a:	9302      	str	r3, [sp, #8]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   1573c:	f000 ff12 	bl	16564 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   15740:	4b38      	ldr	r3, [pc, #224]	; (15824 <xTaskResumeAll+0xf4>)
   15742:	681b      	ldr	r3, [r3, #0]
   15744:	3b01      	subs	r3, #1
   15746:	4a37      	ldr	r2, [pc, #220]	; (15824 <xTaskResumeAll+0xf4>)
   15748:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1574a:	4b36      	ldr	r3, [pc, #216]	; (15824 <xTaskResumeAll+0xf4>)
   1574c:	681b      	ldr	r3, [r3, #0]
   1574e:	2b00      	cmp	r3, #0
   15750:	d161      	bne.n	15816 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   15752:	4b35      	ldr	r3, [pc, #212]	; (15828 <xTaskResumeAll+0xf8>)
   15754:	681b      	ldr	r3, [r3, #0]
   15756:	2b00      	cmp	r3, #0
   15758:	d05d      	beq.n	15816 <xTaskResumeAll+0xe6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1575a:	e02e      	b.n	157ba <xTaskResumeAll+0x8a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   1575c:	4b33      	ldr	r3, [pc, #204]	; (1582c <xTaskResumeAll+0xfc>)
   1575e:	68db      	ldr	r3, [r3, #12]
   15760:	68db      	ldr	r3, [r3, #12]
   15762:	9303      	str	r3, [sp, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   15764:	9b03      	ldr	r3, [sp, #12]
   15766:	3318      	adds	r3, #24
   15768:	4618      	mov	r0, r3
   1576a:	f7ff fe07 	bl	1537c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1576e:	9b03      	ldr	r3, [sp, #12]
   15770:	3304      	adds	r3, #4
   15772:	4618      	mov	r0, r3
   15774:	f7ff fe02 	bl	1537c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   15778:	9b03      	ldr	r3, [sp, #12]
   1577a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1577c:	2201      	movs	r2, #1
   1577e:	409a      	lsls	r2, r3
   15780:	4b2b      	ldr	r3, [pc, #172]	; (15830 <xTaskResumeAll+0x100>)
   15782:	681b      	ldr	r3, [r3, #0]
   15784:	4313      	orrs	r3, r2
   15786:	4a2a      	ldr	r2, [pc, #168]	; (15830 <xTaskResumeAll+0x100>)
   15788:	6013      	str	r3, [r2, #0]
   1578a:	9b03      	ldr	r3, [sp, #12]
   1578c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1578e:	4613      	mov	r3, r2
   15790:	009b      	lsls	r3, r3, #2
   15792:	4413      	add	r3, r2
   15794:	009b      	lsls	r3, r3, #2
   15796:	4a27      	ldr	r2, [pc, #156]	; (15834 <xTaskResumeAll+0x104>)
   15798:	441a      	add	r2, r3
   1579a:	9b03      	ldr	r3, [sp, #12]
   1579c:	3304      	adds	r3, #4
   1579e:	4619      	mov	r1, r3
   157a0:	4610      	mov	r0, r2
   157a2:	f7ff fd98 	bl	152d6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   157a6:	9b03      	ldr	r3, [sp, #12]
   157a8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   157aa:	4b23      	ldr	r3, [pc, #140]	; (15838 <xTaskResumeAll+0x108>)
   157ac:	681b      	ldr	r3, [r3, #0]
   157ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   157b0:	429a      	cmp	r2, r3
   157b2:	d302      	bcc.n	157ba <xTaskResumeAll+0x8a>
					{
						xYieldPending = pdTRUE;
   157b4:	4b21      	ldr	r3, [pc, #132]	; (1583c <xTaskResumeAll+0x10c>)
   157b6:	2201      	movs	r2, #1
   157b8:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   157ba:	4b1c      	ldr	r3, [pc, #112]	; (1582c <xTaskResumeAll+0xfc>)
   157bc:	681b      	ldr	r3, [r3, #0]
   157be:	2b00      	cmp	r3, #0
   157c0:	d1cc      	bne.n	1575c <xTaskResumeAll+0x2c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   157c2:	9b03      	ldr	r3, [sp, #12]
   157c4:	2b00      	cmp	r3, #0
   157c6:	d001      	beq.n	157cc <xTaskResumeAll+0x9c>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   157c8:	f000 faa6 	bl	15d18 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   157cc:	4b1c      	ldr	r3, [pc, #112]	; (15840 <xTaskResumeAll+0x110>)
   157ce:	681b      	ldr	r3, [r3, #0]
   157d0:	9301      	str	r3, [sp, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   157d2:	9b01      	ldr	r3, [sp, #4]
   157d4:	2b00      	cmp	r3, #0
   157d6:	d010      	beq.n	157fa <xTaskResumeAll+0xca>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   157d8:	f000 f836 	bl	15848 <xTaskIncrementTick>
   157dc:	4603      	mov	r3, r0
   157de:	2b00      	cmp	r3, #0
   157e0:	d002      	beq.n	157e8 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
   157e2:	4b16      	ldr	r3, [pc, #88]	; (1583c <xTaskResumeAll+0x10c>)
   157e4:	2201      	movs	r2, #1
   157e6:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   157e8:	9b01      	ldr	r3, [sp, #4]
   157ea:	3b01      	subs	r3, #1
   157ec:	9301      	str	r3, [sp, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   157ee:	9b01      	ldr	r3, [sp, #4]
   157f0:	2b00      	cmp	r3, #0
   157f2:	d1f1      	bne.n	157d8 <xTaskResumeAll+0xa8>

						uxPendedTicks = 0;
   157f4:	4b12      	ldr	r3, [pc, #72]	; (15840 <xTaskResumeAll+0x110>)
   157f6:	2200      	movs	r2, #0
   157f8:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   157fa:	4b10      	ldr	r3, [pc, #64]	; (1583c <xTaskResumeAll+0x10c>)
   157fc:	681b      	ldr	r3, [r3, #0]
   157fe:	2b00      	cmp	r3, #0
   15800:	d009      	beq.n	15816 <xTaskResumeAll+0xe6>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   15802:	2301      	movs	r3, #1
   15804:	9302      	str	r3, [sp, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   15806:	4b0f      	ldr	r3, [pc, #60]	; (15844 <xTaskResumeAll+0x114>)
   15808:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1580c:	601a      	str	r2, [r3, #0]
   1580e:	f3bf 8f4f 	dsb	sy
   15812:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   15816:	f000 feb9 	bl	1658c <vPortExitCritical>

	return xAlreadyYielded;
   1581a:	9b02      	ldr	r3, [sp, #8]
}
   1581c:	4618      	mov	r0, r3
   1581e:	b005      	add	sp, #20
   15820:	f85d fb04 	ldr.w	pc, [sp], #4
   15824:	1000163c 	.word	0x1000163c
   15828:	10001614 	.word	0x10001614
   1582c:	100015d4 	.word	0x100015d4
   15830:	1000161c 	.word	0x1000161c
   15834:	10001540 	.word	0x10001540
   15838:	1000153c 	.word	0x1000153c
   1583c:	10001628 	.word	0x10001628
   15840:	10001624 	.word	0x10001624
   15844:	e000ed04 	.word	0xe000ed04

00015848 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   15848:	b500      	push	{lr}
   1584a:	b087      	sub	sp, #28
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   1584c:	2300      	movs	r3, #0
   1584e:	9305      	str	r3, [sp, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   15850:	4b48      	ldr	r3, [pc, #288]	; (15974 <xTaskIncrementTick+0x12c>)
   15852:	681b      	ldr	r3, [r3, #0]
   15854:	2b00      	cmp	r3, #0
   15856:	d17c      	bne.n	15952 <xTaskIncrementTick+0x10a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   15858:	4b47      	ldr	r3, [pc, #284]	; (15978 <xTaskIncrementTick+0x130>)
   1585a:	681b      	ldr	r3, [r3, #0]
   1585c:	3301      	adds	r3, #1
   1585e:	9304      	str	r3, [sp, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   15860:	4a45      	ldr	r2, [pc, #276]	; (15978 <xTaskIncrementTick+0x130>)
   15862:	9b04      	ldr	r3, [sp, #16]
   15864:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   15866:	9b04      	ldr	r3, [sp, #16]
   15868:	2b00      	cmp	r3, #0
   1586a:	d110      	bne.n	1588e <xTaskIncrementTick+0x46>
		{
			taskSWITCH_DELAYED_LISTS();
   1586c:	4b43      	ldr	r3, [pc, #268]	; (1597c <xTaskIncrementTick+0x134>)
   1586e:	681b      	ldr	r3, [r3, #0]
   15870:	9303      	str	r3, [sp, #12]
   15872:	4b43      	ldr	r3, [pc, #268]	; (15980 <xTaskIncrementTick+0x138>)
   15874:	681b      	ldr	r3, [r3, #0]
   15876:	4a41      	ldr	r2, [pc, #260]	; (1597c <xTaskIncrementTick+0x134>)
   15878:	6013      	str	r3, [r2, #0]
   1587a:	4a41      	ldr	r2, [pc, #260]	; (15980 <xTaskIncrementTick+0x138>)
   1587c:	9b03      	ldr	r3, [sp, #12]
   1587e:	6013      	str	r3, [r2, #0]
   15880:	4b40      	ldr	r3, [pc, #256]	; (15984 <xTaskIncrementTick+0x13c>)
   15882:	681b      	ldr	r3, [r3, #0]
   15884:	3301      	adds	r3, #1
   15886:	4a3f      	ldr	r2, [pc, #252]	; (15984 <xTaskIncrementTick+0x13c>)
   15888:	6013      	str	r3, [r2, #0]
   1588a:	f000 fa45 	bl	15d18 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   1588e:	4b3e      	ldr	r3, [pc, #248]	; (15988 <xTaskIncrementTick+0x140>)
   15890:	681b      	ldr	r3, [r3, #0]
   15892:	9a04      	ldr	r2, [sp, #16]
   15894:	429a      	cmp	r2, r3
   15896:	d34d      	bcc.n	15934 <xTaskIncrementTick+0xec>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   15898:	4b38      	ldr	r3, [pc, #224]	; (1597c <xTaskIncrementTick+0x134>)
   1589a:	681b      	ldr	r3, [r3, #0]
   1589c:	681b      	ldr	r3, [r3, #0]
   1589e:	2b00      	cmp	r3, #0
   158a0:	d101      	bne.n	158a6 <xTaskIncrementTick+0x5e>
   158a2:	2301      	movs	r3, #1
   158a4:	e000      	b.n	158a8 <xTaskIncrementTick+0x60>
   158a6:	2300      	movs	r3, #0
   158a8:	2b00      	cmp	r3, #0
   158aa:	d004      	beq.n	158b6 <xTaskIncrementTick+0x6e>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   158ac:	4b36      	ldr	r3, [pc, #216]	; (15988 <xTaskIncrementTick+0x140>)
   158ae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   158b2:	601a      	str	r2, [r3, #0]
					break;
   158b4:	e03e      	b.n	15934 <xTaskIncrementTick+0xec>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   158b6:	4b31      	ldr	r3, [pc, #196]	; (1597c <xTaskIncrementTick+0x134>)
   158b8:	681b      	ldr	r3, [r3, #0]
   158ba:	68db      	ldr	r3, [r3, #12]
   158bc:	68db      	ldr	r3, [r3, #12]
   158be:	9302      	str	r3, [sp, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   158c0:	9b02      	ldr	r3, [sp, #8]
   158c2:	685b      	ldr	r3, [r3, #4]
   158c4:	9301      	str	r3, [sp, #4]

					if( xConstTickCount < xItemValue )
   158c6:	9a04      	ldr	r2, [sp, #16]
   158c8:	9b01      	ldr	r3, [sp, #4]
   158ca:	429a      	cmp	r2, r3
   158cc:	d203      	bcs.n	158d6 <xTaskIncrementTick+0x8e>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   158ce:	4a2e      	ldr	r2, [pc, #184]	; (15988 <xTaskIncrementTick+0x140>)
   158d0:	9b01      	ldr	r3, [sp, #4]
   158d2:	6013      	str	r3, [r2, #0]
						break;
   158d4:	e02e      	b.n	15934 <xTaskIncrementTick+0xec>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   158d6:	9b02      	ldr	r3, [sp, #8]
   158d8:	3304      	adds	r3, #4
   158da:	4618      	mov	r0, r3
   158dc:	f7ff fd4e 	bl	1537c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   158e0:	9b02      	ldr	r3, [sp, #8]
   158e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   158e4:	2b00      	cmp	r3, #0
   158e6:	d004      	beq.n	158f2 <xTaskIncrementTick+0xaa>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   158e8:	9b02      	ldr	r3, [sp, #8]
   158ea:	3318      	adds	r3, #24
   158ec:	4618      	mov	r0, r3
   158ee:	f7ff fd45 	bl	1537c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   158f2:	9b02      	ldr	r3, [sp, #8]
   158f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   158f6:	2201      	movs	r2, #1
   158f8:	409a      	lsls	r2, r3
   158fa:	4b24      	ldr	r3, [pc, #144]	; (1598c <xTaskIncrementTick+0x144>)
   158fc:	681b      	ldr	r3, [r3, #0]
   158fe:	4313      	orrs	r3, r2
   15900:	4a22      	ldr	r2, [pc, #136]	; (1598c <xTaskIncrementTick+0x144>)
   15902:	6013      	str	r3, [r2, #0]
   15904:	9b02      	ldr	r3, [sp, #8]
   15906:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15908:	4613      	mov	r3, r2
   1590a:	009b      	lsls	r3, r3, #2
   1590c:	4413      	add	r3, r2
   1590e:	009b      	lsls	r3, r3, #2
   15910:	4a1f      	ldr	r2, [pc, #124]	; (15990 <xTaskIncrementTick+0x148>)
   15912:	441a      	add	r2, r3
   15914:	9b02      	ldr	r3, [sp, #8]
   15916:	3304      	adds	r3, #4
   15918:	4619      	mov	r1, r3
   1591a:	4610      	mov	r0, r2
   1591c:	f7ff fcdb 	bl	152d6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   15920:	9b02      	ldr	r3, [sp, #8]
   15922:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15924:	4b1b      	ldr	r3, [pc, #108]	; (15994 <xTaskIncrementTick+0x14c>)
   15926:	681b      	ldr	r3, [r3, #0]
   15928:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1592a:	429a      	cmp	r2, r3
   1592c:	d3b4      	bcc.n	15898 <xTaskIncrementTick+0x50>
						{
							xSwitchRequired = pdTRUE;
   1592e:	2301      	movs	r3, #1
   15930:	9305      	str	r3, [sp, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   15932:	e7b1      	b.n	15898 <xTaskIncrementTick+0x50>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   15934:	4b17      	ldr	r3, [pc, #92]	; (15994 <xTaskIncrementTick+0x14c>)
   15936:	681b      	ldr	r3, [r3, #0]
   15938:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1593a:	4915      	ldr	r1, [pc, #84]	; (15990 <xTaskIncrementTick+0x148>)
   1593c:	4613      	mov	r3, r2
   1593e:	009b      	lsls	r3, r3, #2
   15940:	4413      	add	r3, r2
   15942:	009b      	lsls	r3, r3, #2
   15944:	440b      	add	r3, r1
   15946:	681b      	ldr	r3, [r3, #0]
   15948:	2b01      	cmp	r3, #1
   1594a:	d907      	bls.n	1595c <xTaskIncrementTick+0x114>
			{
				xSwitchRequired = pdTRUE;
   1594c:	2301      	movs	r3, #1
   1594e:	9305      	str	r3, [sp, #20]
   15950:	e004      	b.n	1595c <xTaskIncrementTick+0x114>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   15952:	4b11      	ldr	r3, [pc, #68]	; (15998 <xTaskIncrementTick+0x150>)
   15954:	681b      	ldr	r3, [r3, #0]
   15956:	3301      	adds	r3, #1
   15958:	4a0f      	ldr	r2, [pc, #60]	; (15998 <xTaskIncrementTick+0x150>)
   1595a:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   1595c:	4b0f      	ldr	r3, [pc, #60]	; (1599c <xTaskIncrementTick+0x154>)
   1595e:	681b      	ldr	r3, [r3, #0]
   15960:	2b00      	cmp	r3, #0
   15962:	d001      	beq.n	15968 <xTaskIncrementTick+0x120>
		{
			xSwitchRequired = pdTRUE;
   15964:	2301      	movs	r3, #1
   15966:	9305      	str	r3, [sp, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   15968:	9b05      	ldr	r3, [sp, #20]
}
   1596a:	4618      	mov	r0, r3
   1596c:	b007      	add	sp, #28
   1596e:	f85d fb04 	ldr.w	pc, [sp], #4
   15972:	bf00      	nop
   15974:	1000163c 	.word	0x1000163c
   15978:	10001618 	.word	0x10001618
   1597c:	100015cc 	.word	0x100015cc
   15980:	100015d0 	.word	0x100015d0
   15984:	1000162c 	.word	0x1000162c
   15988:	10001634 	.word	0x10001634
   1598c:	1000161c 	.word	0x1000161c
   15990:	10001540 	.word	0x10001540
   15994:	1000153c 	.word	0x1000153c
   15998:	10001624 	.word	0x10001624
   1599c:	10001628 	.word	0x10001628

000159a0 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   159a0:	b510      	push	{r4, lr}
   159a2:	b084      	sub	sp, #16
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   159a4:	4b29      	ldr	r3, [pc, #164]	; (15a4c <vTaskSwitchContext+0xac>)
   159a6:	681b      	ldr	r3, [r3, #0]
   159a8:	2b00      	cmp	r3, #0
   159aa:	d003      	beq.n	159b4 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   159ac:	4b28      	ldr	r3, [pc, #160]	; (15a50 <vTaskSwitchContext+0xb0>)
   159ae:	2201      	movs	r2, #1
   159b0:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   159b2:	e047      	b.n	15a44 <vTaskSwitchContext+0xa4>
		xYieldPending = pdFALSE;
   159b4:	4b26      	ldr	r3, [pc, #152]	; (15a50 <vTaskSwitchContext+0xb0>)
   159b6:	2200      	movs	r2, #0
   159b8:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   159ba:	f7fe fe93 	bl	146e4 <UptimeRTOS>
   159be:	4603      	mov	r3, r0
   159c0:	460c      	mov	r4, r1
   159c2:	461a      	mov	r2, r3
   159c4:	4b23      	ldr	r3, [pc, #140]	; (15a54 <vTaskSwitchContext+0xb4>)
   159c6:	601a      	str	r2, [r3, #0]
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   159c8:	4b22      	ldr	r3, [pc, #136]	; (15a54 <vTaskSwitchContext+0xb4>)
   159ca:	681a      	ldr	r2, [r3, #0]
   159cc:	4b22      	ldr	r3, [pc, #136]	; (15a58 <vTaskSwitchContext+0xb8>)
   159ce:	681b      	ldr	r3, [r3, #0]
   159d0:	429a      	cmp	r2, r3
   159d2:	d909      	bls.n	159e8 <vTaskSwitchContext+0x48>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   159d4:	4b21      	ldr	r3, [pc, #132]	; (15a5c <vTaskSwitchContext+0xbc>)
   159d6:	681b      	ldr	r3, [r3, #0]
   159d8:	6d59      	ldr	r1, [r3, #84]	; 0x54
   159da:	4a1e      	ldr	r2, [pc, #120]	; (15a54 <vTaskSwitchContext+0xb4>)
   159dc:	6810      	ldr	r0, [r2, #0]
   159de:	4a1e      	ldr	r2, [pc, #120]	; (15a58 <vTaskSwitchContext+0xb8>)
   159e0:	6812      	ldr	r2, [r2, #0]
   159e2:	1a82      	subs	r2, r0, r2
   159e4:	440a      	add	r2, r1
   159e6:	655a      	str	r2, [r3, #84]	; 0x54
				ulTaskSwitchedInTime = ulTotalRunTime;
   159e8:	4b1a      	ldr	r3, [pc, #104]	; (15a54 <vTaskSwitchContext+0xb4>)
   159ea:	681b      	ldr	r3, [r3, #0]
   159ec:	4a1a      	ldr	r2, [pc, #104]	; (15a58 <vTaskSwitchContext+0xb8>)
   159ee:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   159f0:	4b1b      	ldr	r3, [pc, #108]	; (15a60 <vTaskSwitchContext+0xc0>)
   159f2:	681b      	ldr	r3, [r3, #0]
   159f4:	9301      	str	r3, [sp, #4]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   159f6:	9b01      	ldr	r3, [sp, #4]
   159f8:	fab3 f383 	clz	r3, r3
   159fc:	f88d 3003 	strb.w	r3, [sp, #3]
		return ucReturn;
   15a00:	f89d 3003 	ldrb.w	r3, [sp, #3]
   15a04:	f1c3 031f 	rsb	r3, r3, #31
   15a08:	9303      	str	r3, [sp, #12]
   15a0a:	9a03      	ldr	r2, [sp, #12]
   15a0c:	4613      	mov	r3, r2
   15a0e:	009b      	lsls	r3, r3, #2
   15a10:	4413      	add	r3, r2
   15a12:	009b      	lsls	r3, r3, #2
   15a14:	4a13      	ldr	r2, [pc, #76]	; (15a64 <vTaskSwitchContext+0xc4>)
   15a16:	4413      	add	r3, r2
   15a18:	9302      	str	r3, [sp, #8]
   15a1a:	9b02      	ldr	r3, [sp, #8]
   15a1c:	685b      	ldr	r3, [r3, #4]
   15a1e:	685a      	ldr	r2, [r3, #4]
   15a20:	9b02      	ldr	r3, [sp, #8]
   15a22:	605a      	str	r2, [r3, #4]
   15a24:	9b02      	ldr	r3, [sp, #8]
   15a26:	685a      	ldr	r2, [r3, #4]
   15a28:	9b02      	ldr	r3, [sp, #8]
   15a2a:	3308      	adds	r3, #8
   15a2c:	429a      	cmp	r2, r3
   15a2e:	d104      	bne.n	15a3a <vTaskSwitchContext+0x9a>
   15a30:	9b02      	ldr	r3, [sp, #8]
   15a32:	685b      	ldr	r3, [r3, #4]
   15a34:	685a      	ldr	r2, [r3, #4]
   15a36:	9b02      	ldr	r3, [sp, #8]
   15a38:	605a      	str	r2, [r3, #4]
   15a3a:	9b02      	ldr	r3, [sp, #8]
   15a3c:	685b      	ldr	r3, [r3, #4]
   15a3e:	68db      	ldr	r3, [r3, #12]
   15a40:	4a06      	ldr	r2, [pc, #24]	; (15a5c <vTaskSwitchContext+0xbc>)
   15a42:	6013      	str	r3, [r2, #0]
}
   15a44:	bf00      	nop
   15a46:	b004      	add	sp, #16
   15a48:	bd10      	pop	{r4, pc}
   15a4a:	bf00      	nop
   15a4c:	1000163c 	.word	0x1000163c
   15a50:	10001628 	.word	0x10001628
   15a54:	10001644 	.word	0x10001644
   15a58:	10001640 	.word	0x10001640
   15a5c:	1000153c 	.word	0x1000153c
   15a60:	1000161c 	.word	0x1000161c
   15a64:	10001540 	.word	0x10001540

00015a68 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   15a68:	b500      	push	{lr}
   15a6a:	b083      	sub	sp, #12
   15a6c:	9001      	str	r0, [sp, #4]
   15a6e:	9100      	str	r1, [sp, #0]

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   15a70:	4b07      	ldr	r3, [pc, #28]	; (15a90 <vTaskPlaceOnEventList+0x28>)
   15a72:	681b      	ldr	r3, [r3, #0]
   15a74:	3318      	adds	r3, #24
   15a76:	4619      	mov	r1, r3
   15a78:	9801      	ldr	r0, [sp, #4]
   15a7a:	f7ff fc4b 	bl	15314 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   15a7e:	2101      	movs	r1, #1
   15a80:	9800      	ldr	r0, [sp, #0]
   15a82:	f000 f9cd 	bl	15e20 <prvAddCurrentTaskToDelayedList>
}
   15a86:	bf00      	nop
   15a88:	b003      	add	sp, #12
   15a8a:	f85d fb04 	ldr.w	pc, [sp], #4
   15a8e:	bf00      	nop
   15a90:	1000153c 	.word	0x1000153c

00015a94 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   15a94:	b500      	push	{lr}
   15a96:	b085      	sub	sp, #20
   15a98:	9001      	str	r0, [sp, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   15a9a:	9b01      	ldr	r3, [sp, #4]
   15a9c:	68db      	ldr	r3, [r3, #12]
   15a9e:	68db      	ldr	r3, [r3, #12]
   15aa0:	9302      	str	r3, [sp, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   15aa2:	9b02      	ldr	r3, [sp, #8]
   15aa4:	3318      	adds	r3, #24
   15aa6:	4618      	mov	r0, r3
   15aa8:	f7ff fc68 	bl	1537c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   15aac:	4b1d      	ldr	r3, [pc, #116]	; (15b24 <xTaskRemoveFromEventList+0x90>)
   15aae:	681b      	ldr	r3, [r3, #0]
   15ab0:	2b00      	cmp	r3, #0
   15ab2:	d11c      	bne.n	15aee <xTaskRemoveFromEventList+0x5a>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   15ab4:	9b02      	ldr	r3, [sp, #8]
   15ab6:	3304      	adds	r3, #4
   15ab8:	4618      	mov	r0, r3
   15aba:	f7ff fc5f 	bl	1537c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   15abe:	9b02      	ldr	r3, [sp, #8]
   15ac0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15ac2:	2201      	movs	r2, #1
   15ac4:	409a      	lsls	r2, r3
   15ac6:	4b18      	ldr	r3, [pc, #96]	; (15b28 <xTaskRemoveFromEventList+0x94>)
   15ac8:	681b      	ldr	r3, [r3, #0]
   15aca:	4313      	orrs	r3, r2
   15acc:	4a16      	ldr	r2, [pc, #88]	; (15b28 <xTaskRemoveFromEventList+0x94>)
   15ace:	6013      	str	r3, [r2, #0]
   15ad0:	9b02      	ldr	r3, [sp, #8]
   15ad2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15ad4:	4613      	mov	r3, r2
   15ad6:	009b      	lsls	r3, r3, #2
   15ad8:	4413      	add	r3, r2
   15ada:	009b      	lsls	r3, r3, #2
   15adc:	4a13      	ldr	r2, [pc, #76]	; (15b2c <xTaskRemoveFromEventList+0x98>)
   15ade:	441a      	add	r2, r3
   15ae0:	9b02      	ldr	r3, [sp, #8]
   15ae2:	3304      	adds	r3, #4
   15ae4:	4619      	mov	r1, r3
   15ae6:	4610      	mov	r0, r2
   15ae8:	f7ff fbf5 	bl	152d6 <vListInsertEnd>
   15aec:	e005      	b.n	15afa <xTaskRemoveFromEventList+0x66>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   15aee:	9b02      	ldr	r3, [sp, #8]
   15af0:	3318      	adds	r3, #24
   15af2:	4619      	mov	r1, r3
   15af4:	480e      	ldr	r0, [pc, #56]	; (15b30 <xTaskRemoveFromEventList+0x9c>)
   15af6:	f7ff fbee 	bl	152d6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   15afa:	9b02      	ldr	r3, [sp, #8]
   15afc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15afe:	4b0d      	ldr	r3, [pc, #52]	; (15b34 <xTaskRemoveFromEventList+0xa0>)
   15b00:	681b      	ldr	r3, [r3, #0]
   15b02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15b04:	429a      	cmp	r2, r3
   15b06:	d905      	bls.n	15b14 <xTaskRemoveFromEventList+0x80>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   15b08:	2301      	movs	r3, #1
   15b0a:	9303      	str	r3, [sp, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   15b0c:	4b0a      	ldr	r3, [pc, #40]	; (15b38 <xTaskRemoveFromEventList+0xa4>)
   15b0e:	2201      	movs	r2, #1
   15b10:	601a      	str	r2, [r3, #0]
   15b12:	e001      	b.n	15b18 <xTaskRemoveFromEventList+0x84>
	}
	else
	{
		xReturn = pdFALSE;
   15b14:	2300      	movs	r3, #0
   15b16:	9303      	str	r3, [sp, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   15b18:	9b03      	ldr	r3, [sp, #12]
}
   15b1a:	4618      	mov	r0, r3
   15b1c:	b005      	add	sp, #20
   15b1e:	f85d fb04 	ldr.w	pc, [sp], #4
   15b22:	bf00      	nop
   15b24:	1000163c 	.word	0x1000163c
   15b28:	1000161c 	.word	0x1000161c
   15b2c:	10001540 	.word	0x10001540
   15b30:	100015d4 	.word	0x100015d4
   15b34:	1000153c 	.word	0x1000153c
   15b38:	10001628 	.word	0x10001628

00015b3c <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   15b3c:	b082      	sub	sp, #8
   15b3e:	9001      	str	r0, [sp, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   15b40:	4b05      	ldr	r3, [pc, #20]	; (15b58 <vTaskInternalSetTimeOutState+0x1c>)
   15b42:	681a      	ldr	r2, [r3, #0]
   15b44:	9b01      	ldr	r3, [sp, #4]
   15b46:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   15b48:	4b04      	ldr	r3, [pc, #16]	; (15b5c <vTaskInternalSetTimeOutState+0x20>)
   15b4a:	681a      	ldr	r2, [r3, #0]
   15b4c:	9b01      	ldr	r3, [sp, #4]
   15b4e:	605a      	str	r2, [r3, #4]
}
   15b50:	bf00      	nop
   15b52:	b002      	add	sp, #8
   15b54:	4770      	bx	lr
   15b56:	bf00      	nop
   15b58:	1000162c 	.word	0x1000162c
   15b5c:	10001618 	.word	0x10001618

00015b60 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   15b60:	b500      	push	{lr}
   15b62:	b087      	sub	sp, #28
   15b64:	9001      	str	r0, [sp, #4]
   15b66:	9100      	str	r1, [sp, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   15b68:	f000 fcfc 	bl	16564 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   15b6c:	4b1d      	ldr	r3, [pc, #116]	; (15be4 <xTaskCheckForTimeOut+0x84>)
   15b6e:	681b      	ldr	r3, [r3, #0]
   15b70:	9304      	str	r3, [sp, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   15b72:	9b01      	ldr	r3, [sp, #4]
   15b74:	685b      	ldr	r3, [r3, #4]
   15b76:	9a04      	ldr	r2, [sp, #16]
   15b78:	1ad3      	subs	r3, r2, r3
   15b7a:	9303      	str	r3, [sp, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   15b7c:	9b00      	ldr	r3, [sp, #0]
   15b7e:	681b      	ldr	r3, [r3, #0]
   15b80:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   15b84:	d102      	bne.n	15b8c <xTaskCheckForTimeOut+0x2c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   15b86:	2300      	movs	r3, #0
   15b88:	9305      	str	r3, [sp, #20]
   15b8a:	e023      	b.n	15bd4 <xTaskCheckForTimeOut+0x74>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   15b8c:	9b01      	ldr	r3, [sp, #4]
   15b8e:	681a      	ldr	r2, [r3, #0]
   15b90:	4b15      	ldr	r3, [pc, #84]	; (15be8 <xTaskCheckForTimeOut+0x88>)
   15b92:	681b      	ldr	r3, [r3, #0]
   15b94:	429a      	cmp	r2, r3
   15b96:	d007      	beq.n	15ba8 <xTaskCheckForTimeOut+0x48>
   15b98:	9b01      	ldr	r3, [sp, #4]
   15b9a:	685b      	ldr	r3, [r3, #4]
   15b9c:	9a04      	ldr	r2, [sp, #16]
   15b9e:	429a      	cmp	r2, r3
   15ba0:	d302      	bcc.n	15ba8 <xTaskCheckForTimeOut+0x48>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   15ba2:	2301      	movs	r3, #1
   15ba4:	9305      	str	r3, [sp, #20]
   15ba6:	e015      	b.n	15bd4 <xTaskCheckForTimeOut+0x74>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   15ba8:	9b00      	ldr	r3, [sp, #0]
   15baa:	681b      	ldr	r3, [r3, #0]
   15bac:	9a03      	ldr	r2, [sp, #12]
   15bae:	429a      	cmp	r2, r3
   15bb0:	d20b      	bcs.n	15bca <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   15bb2:	9b00      	ldr	r3, [sp, #0]
   15bb4:	681a      	ldr	r2, [r3, #0]
   15bb6:	9b03      	ldr	r3, [sp, #12]
   15bb8:	1ad2      	subs	r2, r2, r3
   15bba:	9b00      	ldr	r3, [sp, #0]
   15bbc:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   15bbe:	9801      	ldr	r0, [sp, #4]
   15bc0:	f7ff ffbc 	bl	15b3c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   15bc4:	2300      	movs	r3, #0
   15bc6:	9305      	str	r3, [sp, #20]
   15bc8:	e004      	b.n	15bd4 <xTaskCheckForTimeOut+0x74>
		}
		else
		{
			*pxTicksToWait = 0;
   15bca:	9b00      	ldr	r3, [sp, #0]
   15bcc:	2200      	movs	r2, #0
   15bce:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   15bd0:	2301      	movs	r3, #1
   15bd2:	9305      	str	r3, [sp, #20]
		}
	}
	taskEXIT_CRITICAL();
   15bd4:	f000 fcda 	bl	1658c <vPortExitCritical>

	return xReturn;
   15bd8:	9b05      	ldr	r3, [sp, #20]
}
   15bda:	4618      	mov	r0, r3
   15bdc:	b007      	add	sp, #28
   15bde:	f85d fb04 	ldr.w	pc, [sp], #4
   15be2:	bf00      	nop
   15be4:	10001618 	.word	0x10001618
   15be8:	1000162c 	.word	0x1000162c

00015bec <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
   15bec:	4b02      	ldr	r3, [pc, #8]	; (15bf8 <vTaskMissedYield+0xc>)
   15bee:	2201      	movs	r2, #1
   15bf0:	601a      	str	r2, [r3, #0]
}
   15bf2:	bf00      	nop
   15bf4:	4770      	bx	lr
   15bf6:	bf00      	nop
   15bf8:	10001628 	.word	0x10001628

00015bfc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   15bfc:	b500      	push	{lr}
   15bfe:	b083      	sub	sp, #12
   15c00:	9001      	str	r0, [sp, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   15c02:	f000 f83f 	bl	15c84 <prvCheckTasksWaitingTermination>
   15c06:	e7fc      	b.n	15c02 <prvIdleTask+0x6>

00015c08 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   15c08:	b500      	push	{lr}
   15c0a:	b083      	sub	sp, #12
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   15c0c:	2300      	movs	r3, #0
   15c0e:	9301      	str	r3, [sp, #4]
   15c10:	e00c      	b.n	15c2c <prvInitialiseTaskLists+0x24>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   15c12:	9a01      	ldr	r2, [sp, #4]
   15c14:	4613      	mov	r3, r2
   15c16:	009b      	lsls	r3, r3, #2
   15c18:	4413      	add	r3, r2
   15c1a:	009b      	lsls	r3, r3, #2
   15c1c:	4a11      	ldr	r2, [pc, #68]	; (15c64 <prvInitialiseTaskLists+0x5c>)
   15c1e:	4413      	add	r3, r2
   15c20:	4618      	mov	r0, r3
   15c22:	f7ff fb35 	bl	15290 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   15c26:	9b01      	ldr	r3, [sp, #4]
   15c28:	3301      	adds	r3, #1
   15c2a:	9301      	str	r3, [sp, #4]
   15c2c:	9b01      	ldr	r3, [sp, #4]
   15c2e:	2b04      	cmp	r3, #4
   15c30:	d9ef      	bls.n	15c12 <prvInitialiseTaskLists+0xa>
	}

	vListInitialise( &xDelayedTaskList1 );
   15c32:	480d      	ldr	r0, [pc, #52]	; (15c68 <prvInitialiseTaskLists+0x60>)
   15c34:	f7ff fb2c 	bl	15290 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   15c38:	480c      	ldr	r0, [pc, #48]	; (15c6c <prvInitialiseTaskLists+0x64>)
   15c3a:	f7ff fb29 	bl	15290 <vListInitialise>
	vListInitialise( &xPendingReadyList );
   15c3e:	480c      	ldr	r0, [pc, #48]	; (15c70 <prvInitialiseTaskLists+0x68>)
   15c40:	f7ff fb26 	bl	15290 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   15c44:	480b      	ldr	r0, [pc, #44]	; (15c74 <prvInitialiseTaskLists+0x6c>)
   15c46:	f7ff fb23 	bl	15290 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   15c4a:	480b      	ldr	r0, [pc, #44]	; (15c78 <prvInitialiseTaskLists+0x70>)
   15c4c:	f7ff fb20 	bl	15290 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   15c50:	4b0a      	ldr	r3, [pc, #40]	; (15c7c <prvInitialiseTaskLists+0x74>)
   15c52:	4a05      	ldr	r2, [pc, #20]	; (15c68 <prvInitialiseTaskLists+0x60>)
   15c54:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   15c56:	4b0a      	ldr	r3, [pc, #40]	; (15c80 <prvInitialiseTaskLists+0x78>)
   15c58:	4a04      	ldr	r2, [pc, #16]	; (15c6c <prvInitialiseTaskLists+0x64>)
   15c5a:	601a      	str	r2, [r3, #0]
}
   15c5c:	bf00      	nop
   15c5e:	b003      	add	sp, #12
   15c60:	f85d fb04 	ldr.w	pc, [sp], #4
   15c64:	10001540 	.word	0x10001540
   15c68:	100015a4 	.word	0x100015a4
   15c6c:	100015b8 	.word	0x100015b8
   15c70:	100015d4 	.word	0x100015d4
   15c74:	100015e8 	.word	0x100015e8
   15c78:	10001600 	.word	0x10001600
   15c7c:	100015cc 	.word	0x100015cc
   15c80:	100015d0 	.word	0x100015d0

00015c84 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   15c84:	b500      	push	{lr}
   15c86:	b083      	sub	sp, #12
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   15c88:	e019      	b.n	15cbe <prvCheckTasksWaitingTermination+0x3a>
		{
			taskENTER_CRITICAL();
   15c8a:	f000 fc6b 	bl	16564 <vPortEnterCritical>
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   15c8e:	4b10      	ldr	r3, [pc, #64]	; (15cd0 <prvCheckTasksWaitingTermination+0x4c>)
   15c90:	68db      	ldr	r3, [r3, #12]
   15c92:	68db      	ldr	r3, [r3, #12]
   15c94:	9301      	str	r3, [sp, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   15c96:	9b01      	ldr	r3, [sp, #4]
   15c98:	3304      	adds	r3, #4
   15c9a:	4618      	mov	r0, r3
   15c9c:	f7ff fb6e 	bl	1537c <uxListRemove>
				--uxCurrentNumberOfTasks;
   15ca0:	4b0c      	ldr	r3, [pc, #48]	; (15cd4 <prvCheckTasksWaitingTermination+0x50>)
   15ca2:	681b      	ldr	r3, [r3, #0]
   15ca4:	3b01      	subs	r3, #1
   15ca6:	4a0b      	ldr	r2, [pc, #44]	; (15cd4 <prvCheckTasksWaitingTermination+0x50>)
   15ca8:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
   15caa:	4b0b      	ldr	r3, [pc, #44]	; (15cd8 <prvCheckTasksWaitingTermination+0x54>)
   15cac:	681b      	ldr	r3, [r3, #0]
   15cae:	3b01      	subs	r3, #1
   15cb0:	4a09      	ldr	r2, [pc, #36]	; (15cd8 <prvCheckTasksWaitingTermination+0x54>)
   15cb2:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
   15cb4:	f000 fc6a 	bl	1658c <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   15cb8:	9801      	ldr	r0, [sp, #4]
   15cba:	f000 f80f 	bl	15cdc <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   15cbe:	4b06      	ldr	r3, [pc, #24]	; (15cd8 <prvCheckTasksWaitingTermination+0x54>)
   15cc0:	681b      	ldr	r3, [r3, #0]
   15cc2:	2b00      	cmp	r3, #0
   15cc4:	d1e1      	bne.n	15c8a <prvCheckTasksWaitingTermination+0x6>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   15cc6:	bf00      	nop
   15cc8:	b003      	add	sp, #12
   15cca:	f85d fb04 	ldr.w	pc, [sp], #4
   15cce:	bf00      	nop
   15cd0:	100015e8 	.word	0x100015e8
   15cd4:	10001614 	.word	0x10001614
   15cd8:	100015fc 	.word	0x100015fc

00015cdc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   15cdc:	b500      	push	{lr}
   15cde:	b083      	sub	sp, #12
   15ce0:	9001      	str	r0, [sp, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   15ce2:	9b01      	ldr	r3, [sp, #4]
   15ce4:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   15ce8:	2b00      	cmp	r3, #0
   15cea:	d108      	bne.n	15cfe <prvDeleteTCB+0x22>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
   15cec:	9b01      	ldr	r3, [sp, #4]
   15cee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   15cf0:	4618      	mov	r0, r3
   15cf2:	f000 fcd4 	bl	1669e <vPortFree>
				vPortFree( pxTCB );
   15cf6:	9801      	ldr	r0, [sp, #4]
   15cf8:	f000 fcd1 	bl	1669e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   15cfc:	e007      	b.n	15d0e <prvDeleteTCB+0x32>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   15cfe:	9b01      	ldr	r3, [sp, #4]
   15d00:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   15d04:	2b01      	cmp	r3, #1
   15d06:	d102      	bne.n	15d0e <prvDeleteTCB+0x32>
				vPortFree( pxTCB );
   15d08:	9801      	ldr	r0, [sp, #4]
   15d0a:	f000 fcc8 	bl	1669e <vPortFree>
	}
   15d0e:	bf00      	nop
   15d10:	b003      	add	sp, #12
   15d12:	f85d fb04 	ldr.w	pc, [sp], #4
   15d16:	Address 0x0000000000015d16 is out of bounds.


00015d18 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   15d18:	b082      	sub	sp, #8
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   15d1a:	4b0d      	ldr	r3, [pc, #52]	; (15d50 <prvResetNextTaskUnblockTime+0x38>)
   15d1c:	681b      	ldr	r3, [r3, #0]
   15d1e:	681b      	ldr	r3, [r3, #0]
   15d20:	2b00      	cmp	r3, #0
   15d22:	d101      	bne.n	15d28 <prvResetNextTaskUnblockTime+0x10>
   15d24:	2301      	movs	r3, #1
   15d26:	e000      	b.n	15d2a <prvResetNextTaskUnblockTime+0x12>
   15d28:	2300      	movs	r3, #0
   15d2a:	2b00      	cmp	r3, #0
   15d2c:	d004      	beq.n	15d38 <prvResetNextTaskUnblockTime+0x20>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   15d2e:	4b09      	ldr	r3, [pc, #36]	; (15d54 <prvResetNextTaskUnblockTime+0x3c>)
   15d30:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15d34:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   15d36:	e008      	b.n	15d4a <prvResetNextTaskUnblockTime+0x32>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   15d38:	4b05      	ldr	r3, [pc, #20]	; (15d50 <prvResetNextTaskUnblockTime+0x38>)
   15d3a:	681b      	ldr	r3, [r3, #0]
   15d3c:	68db      	ldr	r3, [r3, #12]
   15d3e:	68db      	ldr	r3, [r3, #12]
   15d40:	9301      	str	r3, [sp, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   15d42:	9b01      	ldr	r3, [sp, #4]
   15d44:	685b      	ldr	r3, [r3, #4]
   15d46:	4a03      	ldr	r2, [pc, #12]	; (15d54 <prvResetNextTaskUnblockTime+0x3c>)
   15d48:	6013      	str	r3, [r2, #0]
}
   15d4a:	bf00      	nop
   15d4c:	b002      	add	sp, #8
   15d4e:	4770      	bx	lr
   15d50:	100015cc 	.word	0x100015cc
   15d54:	10001634 	.word	0x10001634

00015d58 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   15d58:	b500      	push	{lr}
   15d5a:	b085      	sub	sp, #20
   15d5c:	9001      	str	r0, [sp, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   15d5e:	9b01      	ldr	r3, [sp, #4]
   15d60:	9302      	str	r3, [sp, #8]
	BaseType_t xReturn = pdFALSE;
   15d62:	2300      	movs	r3, #0
   15d64:	9303      	str	r3, [sp, #12]

		if( pxMutexHolder != NULL )
   15d66:	9b01      	ldr	r3, [sp, #4]
   15d68:	2b00      	cmp	r3, #0
   15d6a:	d04f      	beq.n	15e0c <xTaskPriorityDisinherit+0xb4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
   15d6c:	9b02      	ldr	r3, [sp, #8]
   15d6e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   15d70:	1e5a      	subs	r2, r3, #1
   15d72:	9b02      	ldr	r3, [sp, #8]
   15d74:	651a      	str	r2, [r3, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   15d76:	9b02      	ldr	r3, [sp, #8]
   15d78:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15d7a:	9b02      	ldr	r3, [sp, #8]
   15d7c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   15d7e:	429a      	cmp	r2, r3
   15d80:	d044      	beq.n	15e0c <xTaskPriorityDisinherit+0xb4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   15d82:	9b02      	ldr	r3, [sp, #8]
   15d84:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   15d86:	2b00      	cmp	r3, #0
   15d88:	d140      	bne.n	15e0c <xTaskPriorityDisinherit+0xb4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   15d8a:	9b02      	ldr	r3, [sp, #8]
   15d8c:	3304      	adds	r3, #4
   15d8e:	4618      	mov	r0, r3
   15d90:	f7ff faf4 	bl	1537c <uxListRemove>
   15d94:	4603      	mov	r3, r0
   15d96:	2b00      	cmp	r3, #0
   15d98:	d115      	bne.n	15dc6 <xTaskPriorityDisinherit+0x6e>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   15d9a:	9b02      	ldr	r3, [sp, #8]
   15d9c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15d9e:	491e      	ldr	r1, [pc, #120]	; (15e18 <xTaskPriorityDisinherit+0xc0>)
   15da0:	4613      	mov	r3, r2
   15da2:	009b      	lsls	r3, r3, #2
   15da4:	4413      	add	r3, r2
   15da6:	009b      	lsls	r3, r3, #2
   15da8:	440b      	add	r3, r1
   15daa:	681b      	ldr	r3, [r3, #0]
   15dac:	2b00      	cmp	r3, #0
   15dae:	d10a      	bne.n	15dc6 <xTaskPriorityDisinherit+0x6e>
   15db0:	9b02      	ldr	r3, [sp, #8]
   15db2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15db4:	2201      	movs	r2, #1
   15db6:	fa02 f303 	lsl.w	r3, r2, r3
   15dba:	43da      	mvns	r2, r3
   15dbc:	4b17      	ldr	r3, [pc, #92]	; (15e1c <xTaskPriorityDisinherit+0xc4>)
   15dbe:	681b      	ldr	r3, [r3, #0]
   15dc0:	4013      	ands	r3, r2
   15dc2:	4a16      	ldr	r2, [pc, #88]	; (15e1c <xTaskPriorityDisinherit+0xc4>)
   15dc4:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   15dc6:	9b02      	ldr	r3, [sp, #8]
   15dc8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   15dca:	9b02      	ldr	r3, [sp, #8]
   15dcc:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   15dce:	9b02      	ldr	r3, [sp, #8]
   15dd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15dd2:	f1c3 0205 	rsb	r2, r3, #5
   15dd6:	9b02      	ldr	r3, [sp, #8]
   15dd8:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   15dda:	9b02      	ldr	r3, [sp, #8]
   15ddc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15dde:	2201      	movs	r2, #1
   15de0:	409a      	lsls	r2, r3
   15de2:	4b0e      	ldr	r3, [pc, #56]	; (15e1c <xTaskPriorityDisinherit+0xc4>)
   15de4:	681b      	ldr	r3, [r3, #0]
   15de6:	4313      	orrs	r3, r2
   15de8:	4a0c      	ldr	r2, [pc, #48]	; (15e1c <xTaskPriorityDisinherit+0xc4>)
   15dea:	6013      	str	r3, [r2, #0]
   15dec:	9b02      	ldr	r3, [sp, #8]
   15dee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   15df0:	4613      	mov	r3, r2
   15df2:	009b      	lsls	r3, r3, #2
   15df4:	4413      	add	r3, r2
   15df6:	009b      	lsls	r3, r3, #2
   15df8:	4a07      	ldr	r2, [pc, #28]	; (15e18 <xTaskPriorityDisinherit+0xc0>)
   15dfa:	441a      	add	r2, r3
   15dfc:	9b02      	ldr	r3, [sp, #8]
   15dfe:	3304      	adds	r3, #4
   15e00:	4619      	mov	r1, r3
   15e02:	4610      	mov	r0, r2
   15e04:	f7ff fa67 	bl	152d6 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
   15e08:	2301      	movs	r3, #1
   15e0a:	9303      	str	r3, [sp, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   15e0c:	9b03      	ldr	r3, [sp, #12]
	}
   15e0e:	4618      	mov	r0, r3
   15e10:	b005      	add	sp, #20
   15e12:	f85d fb04 	ldr.w	pc, [sp], #4
   15e16:	bf00      	nop
   15e18:	10001540 	.word	0x10001540
   15e1c:	1000161c 	.word	0x1000161c

00015e20 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   15e20:	b500      	push	{lr}
   15e22:	b085      	sub	sp, #20
   15e24:	9001      	str	r0, [sp, #4]
   15e26:	9100      	str	r1, [sp, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   15e28:	4b28      	ldr	r3, [pc, #160]	; (15ecc <prvAddCurrentTaskToDelayedList+0xac>)
   15e2a:	681b      	ldr	r3, [r3, #0]
   15e2c:	9303      	str	r3, [sp, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   15e2e:	4b28      	ldr	r3, [pc, #160]	; (15ed0 <prvAddCurrentTaskToDelayedList+0xb0>)
   15e30:	681b      	ldr	r3, [r3, #0]
   15e32:	3304      	adds	r3, #4
   15e34:	4618      	mov	r0, r3
   15e36:	f7ff faa1 	bl	1537c <uxListRemove>
   15e3a:	4603      	mov	r3, r0
   15e3c:	2b00      	cmp	r3, #0
   15e3e:	d10b      	bne.n	15e58 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   15e40:	4b23      	ldr	r3, [pc, #140]	; (15ed0 <prvAddCurrentTaskToDelayedList+0xb0>)
   15e42:	681b      	ldr	r3, [r3, #0]
   15e44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   15e46:	2201      	movs	r2, #1
   15e48:	fa02 f303 	lsl.w	r3, r2, r3
   15e4c:	43da      	mvns	r2, r3
   15e4e:	4b21      	ldr	r3, [pc, #132]	; (15ed4 <prvAddCurrentTaskToDelayedList+0xb4>)
   15e50:	681b      	ldr	r3, [r3, #0]
   15e52:	4013      	ands	r3, r2
   15e54:	4a1f      	ldr	r2, [pc, #124]	; (15ed4 <prvAddCurrentTaskToDelayedList+0xb4>)
   15e56:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   15e58:	9b01      	ldr	r3, [sp, #4]
   15e5a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   15e5e:	d10a      	bne.n	15e76 <prvAddCurrentTaskToDelayedList+0x56>
   15e60:	9b00      	ldr	r3, [sp, #0]
   15e62:	2b00      	cmp	r3, #0
   15e64:	d007      	beq.n	15e76 <prvAddCurrentTaskToDelayedList+0x56>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   15e66:	4b1a      	ldr	r3, [pc, #104]	; (15ed0 <prvAddCurrentTaskToDelayedList+0xb0>)
   15e68:	681b      	ldr	r3, [r3, #0]
   15e6a:	3304      	adds	r3, #4
   15e6c:	4619      	mov	r1, r3
   15e6e:	481a      	ldr	r0, [pc, #104]	; (15ed8 <prvAddCurrentTaskToDelayedList+0xb8>)
   15e70:	f7ff fa31 	bl	152d6 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   15e74:	e026      	b.n	15ec4 <prvAddCurrentTaskToDelayedList+0xa4>
			xTimeToWake = xConstTickCount + xTicksToWait;
   15e76:	9a03      	ldr	r2, [sp, #12]
   15e78:	9b01      	ldr	r3, [sp, #4]
   15e7a:	4413      	add	r3, r2
   15e7c:	9302      	str	r3, [sp, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   15e7e:	4b14      	ldr	r3, [pc, #80]	; (15ed0 <prvAddCurrentTaskToDelayedList+0xb0>)
   15e80:	681b      	ldr	r3, [r3, #0]
   15e82:	9a02      	ldr	r2, [sp, #8]
   15e84:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
   15e86:	9a02      	ldr	r2, [sp, #8]
   15e88:	9b03      	ldr	r3, [sp, #12]
   15e8a:	429a      	cmp	r2, r3
   15e8c:	d209      	bcs.n	15ea2 <prvAddCurrentTaskToDelayedList+0x82>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   15e8e:	4b13      	ldr	r3, [pc, #76]	; (15edc <prvAddCurrentTaskToDelayedList+0xbc>)
   15e90:	681a      	ldr	r2, [r3, #0]
   15e92:	4b0f      	ldr	r3, [pc, #60]	; (15ed0 <prvAddCurrentTaskToDelayedList+0xb0>)
   15e94:	681b      	ldr	r3, [r3, #0]
   15e96:	3304      	adds	r3, #4
   15e98:	4619      	mov	r1, r3
   15e9a:	4610      	mov	r0, r2
   15e9c:	f7ff fa3a 	bl	15314 <vListInsert>
}
   15ea0:	e010      	b.n	15ec4 <prvAddCurrentTaskToDelayedList+0xa4>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   15ea2:	4b0f      	ldr	r3, [pc, #60]	; (15ee0 <prvAddCurrentTaskToDelayedList+0xc0>)
   15ea4:	681a      	ldr	r2, [r3, #0]
   15ea6:	4b0a      	ldr	r3, [pc, #40]	; (15ed0 <prvAddCurrentTaskToDelayedList+0xb0>)
   15ea8:	681b      	ldr	r3, [r3, #0]
   15eaa:	3304      	adds	r3, #4
   15eac:	4619      	mov	r1, r3
   15eae:	4610      	mov	r0, r2
   15eb0:	f7ff fa30 	bl	15314 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   15eb4:	4b0b      	ldr	r3, [pc, #44]	; (15ee4 <prvAddCurrentTaskToDelayedList+0xc4>)
   15eb6:	681b      	ldr	r3, [r3, #0]
   15eb8:	9a02      	ldr	r2, [sp, #8]
   15eba:	429a      	cmp	r2, r3
   15ebc:	d202      	bcs.n	15ec4 <prvAddCurrentTaskToDelayedList+0xa4>
					xNextTaskUnblockTime = xTimeToWake;
   15ebe:	4a09      	ldr	r2, [pc, #36]	; (15ee4 <prvAddCurrentTaskToDelayedList+0xc4>)
   15ec0:	9b02      	ldr	r3, [sp, #8]
   15ec2:	6013      	str	r3, [r2, #0]
}
   15ec4:	bf00      	nop
   15ec6:	b005      	add	sp, #20
   15ec8:	f85d fb04 	ldr.w	pc, [sp], #4
   15ecc:	10001618 	.word	0x10001618
   15ed0:	1000153c 	.word	0x1000153c
   15ed4:	1000161c 	.word	0x1000161c
   15ed8:	10001600 	.word	0x10001600
   15edc:	100015d0 	.word	0x100015d0
   15ee0:	100015cc 	.word	0x100015cc
   15ee4:	10001634 	.word	0x10001634

00015ee8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   15ee8:	b500      	push	{lr}
   15eea:	b085      	sub	sp, #20
   15eec:	9001      	str	r0, [sp, #4]
   15eee:	9100      	str	r1, [sp, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   15ef0:	9b01      	ldr	r3, [sp, #4]
   15ef2:	9303      	str	r3, [sp, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   15ef4:	f000 fb36 	bl	16564 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   15ef8:	9b03      	ldr	r3, [sp, #12]
   15efa:	681a      	ldr	r2, [r3, #0]
   15efc:	9b03      	ldr	r3, [sp, #12]
   15efe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   15f00:	9903      	ldr	r1, [sp, #12]
   15f02:	6c09      	ldr	r1, [r1, #64]	; 0x40
   15f04:	fb01 f303 	mul.w	r3, r1, r3
   15f08:	441a      	add	r2, r3
   15f0a:	9b03      	ldr	r3, [sp, #12]
   15f0c:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   15f0e:	9b03      	ldr	r3, [sp, #12]
   15f10:	2200      	movs	r2, #0
   15f12:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   15f14:	9b03      	ldr	r3, [sp, #12]
   15f16:	681a      	ldr	r2, [r3, #0]
   15f18:	9b03      	ldr	r3, [sp, #12]
   15f1a:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   15f1c:	9b03      	ldr	r3, [sp, #12]
   15f1e:	681a      	ldr	r2, [r3, #0]
   15f20:	9b03      	ldr	r3, [sp, #12]
   15f22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   15f24:	3b01      	subs	r3, #1
   15f26:	9903      	ldr	r1, [sp, #12]
   15f28:	6c09      	ldr	r1, [r1, #64]	; 0x40
   15f2a:	fb01 f303 	mul.w	r3, r1, r3
   15f2e:	441a      	add	r2, r3
   15f30:	9b03      	ldr	r3, [sp, #12]
   15f32:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   15f34:	9b03      	ldr	r3, [sp, #12]
   15f36:	22ff      	movs	r2, #255	; 0xff
   15f38:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   15f3c:	9b03      	ldr	r3, [sp, #12]
   15f3e:	22ff      	movs	r2, #255	; 0xff
   15f40:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
   15f44:	9b00      	ldr	r3, [sp, #0]
   15f46:	2b00      	cmp	r3, #0
   15f48:	d114      	bne.n	15f74 <xQueueGenericReset+0x8c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   15f4a:	9b03      	ldr	r3, [sp, #12]
   15f4c:	691b      	ldr	r3, [r3, #16]
   15f4e:	2b00      	cmp	r3, #0
   15f50:	d01a      	beq.n	15f88 <xQueueGenericReset+0xa0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   15f52:	9b03      	ldr	r3, [sp, #12]
   15f54:	3310      	adds	r3, #16
   15f56:	4618      	mov	r0, r3
   15f58:	f7ff fd9c 	bl	15a94 <xTaskRemoveFromEventList>
   15f5c:	4603      	mov	r3, r0
   15f5e:	2b00      	cmp	r3, #0
   15f60:	d012      	beq.n	15f88 <xQueueGenericReset+0xa0>
				{
					queueYIELD_IF_USING_PREEMPTION();
   15f62:	4b0d      	ldr	r3, [pc, #52]	; (15f98 <xQueueGenericReset+0xb0>)
   15f64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   15f68:	601a      	str	r2, [r3, #0]
   15f6a:	f3bf 8f4f 	dsb	sy
   15f6e:	f3bf 8f6f 	isb	sy
   15f72:	e009      	b.n	15f88 <xQueueGenericReset+0xa0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   15f74:	9b03      	ldr	r3, [sp, #12]
   15f76:	3310      	adds	r3, #16
   15f78:	4618      	mov	r0, r3
   15f7a:	f7ff f989 	bl	15290 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   15f7e:	9b03      	ldr	r3, [sp, #12]
   15f80:	3324      	adds	r3, #36	; 0x24
   15f82:	4618      	mov	r0, r3
   15f84:	f7ff f984 	bl	15290 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   15f88:	f000 fb00 	bl	1658c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   15f8c:	2301      	movs	r3, #1
}
   15f8e:	4618      	mov	r0, r3
   15f90:	b005      	add	sp, #20
   15f92:	f85d fb04 	ldr.w	pc, [sp], #4
   15f96:	bf00      	nop
   15f98:	e000ed04 	.word	0xe000ed04

00015f9c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
   15f9c:	b500      	push	{lr}
   15f9e:	b08b      	sub	sp, #44	; 0x2c
   15fa0:	9005      	str	r0, [sp, #20]
   15fa2:	9104      	str	r1, [sp, #16]
   15fa4:	4613      	mov	r3, r2
   15fa6:	f88d 300f 	strb.w	r3, [sp, #15]
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
   15faa:	9b04      	ldr	r3, [sp, #16]
   15fac:	2b00      	cmp	r3, #0
   15fae:	d102      	bne.n	15fb6 <xQueueGenericCreate+0x1a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
   15fb0:	2300      	movs	r3, #0
   15fb2:	9309      	str	r3, [sp, #36]	; 0x24
   15fb4:	e004      	b.n	15fc0 <xQueueGenericCreate+0x24>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   15fb6:	9b05      	ldr	r3, [sp, #20]
   15fb8:	9a04      	ldr	r2, [sp, #16]
   15fba:	fb02 f303 	mul.w	r3, r2, r3
   15fbe:	9309      	str	r3, [sp, #36]	; 0x24
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   15fc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15fc2:	3350      	adds	r3, #80	; 0x50
   15fc4:	4618      	mov	r0, r3
   15fc6:	f000 fb59 	bl	1667c <pvPortMalloc>
   15fca:	9008      	str	r0, [sp, #32]

		if( pxNewQueue != NULL )
   15fcc:	9b08      	ldr	r3, [sp, #32]
   15fce:	2b00      	cmp	r3, #0
   15fd0:	d010      	beq.n	15ff4 <xQueueGenericCreate+0x58>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   15fd2:	9b08      	ldr	r3, [sp, #32]
   15fd4:	3350      	adds	r3, #80	; 0x50
   15fd6:	9307      	str	r3, [sp, #28]
			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
   15fd8:	9b08      	ldr	r3, [sp, #32]
   15fda:	2200      	movs	r2, #0
   15fdc:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   15fe0:	f89d 200f 	ldrb.w	r2, [sp, #15]
   15fe4:	9b08      	ldr	r3, [sp, #32]
   15fe6:	9300      	str	r3, [sp, #0]
   15fe8:	4613      	mov	r3, r2
   15fea:	9a07      	ldr	r2, [sp, #28]
   15fec:	9904      	ldr	r1, [sp, #16]
   15fee:	9805      	ldr	r0, [sp, #20]
   15ff0:	f000 f805 	bl	15ffe <prvInitialiseNewQueue>
		else
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
   15ff4:	9b08      	ldr	r3, [sp, #32]
	}
   15ff6:	4618      	mov	r0, r3
   15ff8:	b00b      	add	sp, #44	; 0x2c
   15ffa:	f85d fb04 	ldr.w	pc, [sp], #4

00015ffe <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
   15ffe:	b500      	push	{lr}
   16000:	b085      	sub	sp, #20
   16002:	9003      	str	r0, [sp, #12]
   16004:	9102      	str	r1, [sp, #8]
   16006:	9201      	str	r2, [sp, #4]
   16008:	f88d 3003 	strb.w	r3, [sp, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
   1600c:	9b02      	ldr	r3, [sp, #8]
   1600e:	2b00      	cmp	r3, #0
   16010:	d103      	bne.n	1601a <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   16012:	9b06      	ldr	r3, [sp, #24]
   16014:	9a06      	ldr	r2, [sp, #24]
   16016:	601a      	str	r2, [r3, #0]
   16018:	e002      	b.n	16020 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   1601a:	9b06      	ldr	r3, [sp, #24]
   1601c:	9a01      	ldr	r2, [sp, #4]
   1601e:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
   16020:	9b06      	ldr	r3, [sp, #24]
   16022:	9a03      	ldr	r2, [sp, #12]
   16024:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   16026:	9b06      	ldr	r3, [sp, #24]
   16028:	9a02      	ldr	r2, [sp, #8]
   1602a:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   1602c:	2101      	movs	r1, #1
   1602e:	9806      	ldr	r0, [sp, #24]
   16030:	f7ff ff5a 	bl	15ee8 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
   16034:	9b06      	ldr	r3, [sp, #24]
   16036:	f89d 2003 	ldrb.w	r2, [sp, #3]
   1603a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
   1603e:	bf00      	nop
   16040:	b005      	add	sp, #20
   16042:	f85d fb04 	ldr.w	pc, [sp], #4

00016046 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
   16046:	b500      	push	{lr}
   16048:	b08d      	sub	sp, #52	; 0x34
   1604a:	9003      	str	r0, [sp, #12]
   1604c:	9102      	str	r1, [sp, #8]
   1604e:	9201      	str	r2, [sp, #4]
   16050:	9300      	str	r3, [sp, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   16052:	9b03      	ldr	r3, [sp, #12]
   16054:	930a      	str	r3, [sp, #40]	; 0x28

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   16056:	f3ef 8211 	mrs	r2, BASEPRI
   1605a:	f04f 0328 	mov.w	r3, #40	; 0x28
   1605e:	f383 8811 	msr	BASEPRI, r3
   16062:	f3bf 8f6f 	isb	sy
   16066:	f3bf 8f4f 	dsb	sy
   1606a:	9207      	str	r2, [sp, #28]
   1606c:	9306      	str	r3, [sp, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   1606e:	9b07      	ldr	r3, [sp, #28]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   16070:	9309      	str	r3, [sp, #36]	; 0x24
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   16072:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16074:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   16076:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16078:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1607a:	429a      	cmp	r2, r3
   1607c:	d302      	bcc.n	16084 <xQueueGenericSendFromISR+0x3e>
   1607e:	9b00      	ldr	r3, [sp, #0]
   16080:	2b02      	cmp	r3, #2
   16082:	d12c      	bne.n	160de <xQueueGenericSendFromISR+0x98>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   16084:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16086:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   1608a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   1608e:	9a00      	ldr	r2, [sp, #0]
   16090:	9902      	ldr	r1, [sp, #8]
   16092:	980a      	ldr	r0, [sp, #40]	; 0x28
   16094:	f000 f8d0 	bl	16238 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   16098:	f99d 3023 	ldrsb.w	r3, [sp, #35]	; 0x23
   1609c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   160a0:	d112      	bne.n	160c8 <xQueueGenericSendFromISR+0x82>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   160a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   160a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   160a6:	2b00      	cmp	r3, #0
   160a8:	d016      	beq.n	160d8 <xQueueGenericSendFromISR+0x92>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   160aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   160ac:	3324      	adds	r3, #36	; 0x24
   160ae:	4618      	mov	r0, r3
   160b0:	f7ff fcf0 	bl	15a94 <xTaskRemoveFromEventList>
   160b4:	4603      	mov	r3, r0
   160b6:	2b00      	cmp	r3, #0
   160b8:	d00e      	beq.n	160d8 <xQueueGenericSendFromISR+0x92>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   160ba:	9b01      	ldr	r3, [sp, #4]
   160bc:	2b00      	cmp	r3, #0
   160be:	d00b      	beq.n	160d8 <xQueueGenericSendFromISR+0x92>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   160c0:	9b01      	ldr	r3, [sp, #4]
   160c2:	2201      	movs	r2, #1
   160c4:	601a      	str	r2, [r3, #0]
   160c6:	e007      	b.n	160d8 <xQueueGenericSendFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   160c8:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   160cc:	3301      	adds	r3, #1
   160ce:	b2db      	uxtb	r3, r3
   160d0:	b25a      	sxtb	r2, r3
   160d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   160d4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
   160d8:	2301      	movs	r3, #1
   160da:	930b      	str	r3, [sp, #44]	; 0x2c
		{
   160dc:	e001      	b.n	160e2 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   160de:	2300      	movs	r3, #0
   160e0:	930b      	str	r3, [sp, #44]	; 0x2c
   160e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   160e4:	9305      	str	r3, [sp, #20]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   160e6:	9b05      	ldr	r3, [sp, #20]
   160e8:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   160ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
   160ee:	4618      	mov	r0, r3
   160f0:	b00d      	add	sp, #52	; 0x34
   160f2:	f85d fb04 	ldr.w	pc, [sp], #4
   160f6:	Address 0x00000000000160f6 is out of bounds.


000160f8 <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
   160f8:	b500      	push	{lr}
   160fa:	b08b      	sub	sp, #44	; 0x2c
   160fc:	9003      	str	r0, [sp, #12]
   160fe:	9102      	str	r1, [sp, #8]
   16100:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
   16102:	2300      	movs	r3, #0
   16104:	9309      	str	r3, [sp, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   16106:	9b03      	ldr	r3, [sp, #12]
   16108:	9308      	str	r3, [sp, #32]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   1610a:	f000 fa2b 	bl	16564 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1610e:	9b08      	ldr	r3, [sp, #32]
   16110:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   16112:	9307      	str	r3, [sp, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   16114:	9b07      	ldr	r3, [sp, #28]
   16116:	2b00      	cmp	r3, #0
   16118:	d01f      	beq.n	1615a <xQueueReceive+0x62>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1611a:	9902      	ldr	r1, [sp, #8]
   1611c:	9808      	ldr	r0, [sp, #32]
   1611e:	f000 f8f4 	bl	1630a <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   16122:	9b07      	ldr	r3, [sp, #28]
   16124:	1e5a      	subs	r2, r3, #1
   16126:	9b08      	ldr	r3, [sp, #32]
   16128:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1612a:	9b08      	ldr	r3, [sp, #32]
   1612c:	691b      	ldr	r3, [r3, #16]
   1612e:	2b00      	cmp	r3, #0
   16130:	d00f      	beq.n	16152 <xQueueReceive+0x5a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   16132:	9b08      	ldr	r3, [sp, #32]
   16134:	3310      	adds	r3, #16
   16136:	4618      	mov	r0, r3
   16138:	f7ff fcac 	bl	15a94 <xTaskRemoveFromEventList>
   1613c:	4603      	mov	r3, r0
   1613e:	2b00      	cmp	r3, #0
   16140:	d007      	beq.n	16152 <xQueueReceive+0x5a>
					{
						queueYIELD_IF_USING_PREEMPTION();
   16142:	4b3c      	ldr	r3, [pc, #240]	; (16234 <xQueueReceive+0x13c>)
   16144:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   16148:	601a      	str	r2, [r3, #0]
   1614a:	f3bf 8f4f 	dsb	sy
   1614e:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   16152:	f000 fa1b 	bl	1658c <vPortExitCritical>
				return pdPASS;
   16156:	2301      	movs	r3, #1
   16158:	e067      	b.n	1622a <xQueueReceive+0x132>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   1615a:	9b01      	ldr	r3, [sp, #4]
   1615c:	2b00      	cmp	r3, #0
   1615e:	d103      	bne.n	16168 <xQueueReceive+0x70>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   16160:	f000 fa14 	bl	1658c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   16164:	2300      	movs	r3, #0
   16166:	e060      	b.n	1622a <xQueueReceive+0x132>
				}
				else if( xEntryTimeSet == pdFALSE )
   16168:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1616a:	2b00      	cmp	r3, #0
   1616c:	d105      	bne.n	1617a <xQueueReceive+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   1616e:	ab05      	add	r3, sp, #20
   16170:	4618      	mov	r0, r3
   16172:	f7ff fce3 	bl	15b3c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   16176:	2301      	movs	r3, #1
   16178:	9309      	str	r3, [sp, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   1617a:	f000 fa07 	bl	1658c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   1617e:	f7ff facd 	bl	1571c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   16182:	f000 f9ef 	bl	16564 <vPortEnterCritical>
   16186:	9b08      	ldr	r3, [sp, #32]
   16188:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   1618c:	b25b      	sxtb	r3, r3
   1618e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   16192:	d103      	bne.n	1619c <xQueueReceive+0xa4>
   16194:	9b08      	ldr	r3, [sp, #32]
   16196:	2200      	movs	r2, #0
   16198:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   1619c:	9b08      	ldr	r3, [sp, #32]
   1619e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   161a2:	b25b      	sxtb	r3, r3
   161a4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   161a8:	d103      	bne.n	161b2 <xQueueReceive+0xba>
   161aa:	9b08      	ldr	r3, [sp, #32]
   161ac:	2200      	movs	r2, #0
   161ae:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   161b2:	f000 f9eb 	bl	1658c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   161b6:	aa01      	add	r2, sp, #4
   161b8:	ab05      	add	r3, sp, #20
   161ba:	4611      	mov	r1, r2
   161bc:	4618      	mov	r0, r3
   161be:	f7ff fccf 	bl	15b60 <xTaskCheckForTimeOut>
   161c2:	4603      	mov	r3, r0
   161c4:	2b00      	cmp	r3, #0
   161c6:	d123      	bne.n	16210 <xQueueReceive+0x118>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   161c8:	9808      	ldr	r0, [sp, #32]
   161ca:	f000 f91a 	bl	16402 <prvIsQueueEmpty>
   161ce:	4603      	mov	r3, r0
   161d0:	2b00      	cmp	r3, #0
   161d2:	d017      	beq.n	16204 <xQueueReceive+0x10c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   161d4:	9b08      	ldr	r3, [sp, #32]
   161d6:	3324      	adds	r3, #36	; 0x24
   161d8:	9a01      	ldr	r2, [sp, #4]
   161da:	4611      	mov	r1, r2
   161dc:	4618      	mov	r0, r3
   161de:	f7ff fc43 	bl	15a68 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   161e2:	9808      	ldr	r0, [sp, #32]
   161e4:	f000 f8b6 	bl	16354 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   161e8:	f7ff faa2 	bl	15730 <xTaskResumeAll>
   161ec:	4603      	mov	r3, r0
   161ee:	2b00      	cmp	r3, #0
   161f0:	d18b      	bne.n	1610a <xQueueReceive+0x12>
				{
					portYIELD_WITHIN_API();
   161f2:	4b10      	ldr	r3, [pc, #64]	; (16234 <xQueueReceive+0x13c>)
   161f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   161f8:	601a      	str	r2, [r3, #0]
   161fa:	f3bf 8f4f 	dsb	sy
   161fe:	f3bf 8f6f 	isb	sy
   16202:	e782      	b.n	1610a <xQueueReceive+0x12>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
   16204:	9808      	ldr	r0, [sp, #32]
   16206:	f000 f8a5 	bl	16354 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   1620a:	f7ff fa91 	bl	15730 <xTaskResumeAll>
   1620e:	e77c      	b.n	1610a <xQueueReceive+0x12>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
   16210:	9808      	ldr	r0, [sp, #32]
   16212:	f000 f89f 	bl	16354 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   16216:	f7ff fa8b 	bl	15730 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1621a:	9808      	ldr	r0, [sp, #32]
   1621c:	f000 f8f1 	bl	16402 <prvIsQueueEmpty>
   16220:	4603      	mov	r3, r0
   16222:	2b00      	cmp	r3, #0
   16224:	f43f af71 	beq.w	1610a <xQueueReceive+0x12>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   16228:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
   1622a:	4618      	mov	r0, r3
   1622c:	b00b      	add	sp, #44	; 0x2c
   1622e:	f85d fb04 	ldr.w	pc, [sp], #4
   16232:	bf00      	nop
   16234:	e000ed04 	.word	0xe000ed04

00016238 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   16238:	b500      	push	{lr}
   1623a:	b087      	sub	sp, #28
   1623c:	9003      	str	r0, [sp, #12]
   1623e:	9102      	str	r1, [sp, #8]
   16240:	9201      	str	r2, [sp, #4]
BaseType_t xReturn = pdFALSE;
   16242:	2300      	movs	r3, #0
   16244:	9305      	str	r3, [sp, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   16246:	9b03      	ldr	r3, [sp, #12]
   16248:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1624a:	9304      	str	r3, [sp, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   1624c:	9b03      	ldr	r3, [sp, #12]
   1624e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   16250:	2b00      	cmp	r3, #0
   16252:	d10d      	bne.n	16270 <prvCopyDataToQueue+0x38>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   16254:	9b03      	ldr	r3, [sp, #12]
   16256:	681b      	ldr	r3, [r3, #0]
   16258:	2b00      	cmp	r3, #0
   1625a:	d14d      	bne.n	162f8 <prvCopyDataToQueue+0xc0>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   1625c:	9b03      	ldr	r3, [sp, #12]
   1625e:	685b      	ldr	r3, [r3, #4]
   16260:	4618      	mov	r0, r3
   16262:	f7ff fd79 	bl	15d58 <xTaskPriorityDisinherit>
   16266:	9005      	str	r0, [sp, #20]
				pxQueue->pxMutexHolder = NULL;
   16268:	9b03      	ldr	r3, [sp, #12]
   1626a:	2200      	movs	r2, #0
   1626c:	605a      	str	r2, [r3, #4]
   1626e:	e043      	b.n	162f8 <prvCopyDataToQueue+0xc0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   16270:	9b01      	ldr	r3, [sp, #4]
   16272:	2b00      	cmp	r3, #0
   16274:	d119      	bne.n	162aa <prvCopyDataToQueue+0x72>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   16276:	9b03      	ldr	r3, [sp, #12]
   16278:	6898      	ldr	r0, [r3, #8]
   1627a:	9b03      	ldr	r3, [sp, #12]
   1627c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1627e:	461a      	mov	r2, r3
   16280:	9902      	ldr	r1, [sp, #8]
   16282:	f003 f8d7 	bl	19434 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   16286:	9b03      	ldr	r3, [sp, #12]
   16288:	689a      	ldr	r2, [r3, #8]
   1628a:	9b03      	ldr	r3, [sp, #12]
   1628c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1628e:	441a      	add	r2, r3
   16290:	9b03      	ldr	r3, [sp, #12]
   16292:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   16294:	9b03      	ldr	r3, [sp, #12]
   16296:	689a      	ldr	r2, [r3, #8]
   16298:	9b03      	ldr	r3, [sp, #12]
   1629a:	685b      	ldr	r3, [r3, #4]
   1629c:	429a      	cmp	r2, r3
   1629e:	d32b      	bcc.n	162f8 <prvCopyDataToQueue+0xc0>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   162a0:	9b03      	ldr	r3, [sp, #12]
   162a2:	681a      	ldr	r2, [r3, #0]
   162a4:	9b03      	ldr	r3, [sp, #12]
   162a6:	609a      	str	r2, [r3, #8]
   162a8:	e026      	b.n	162f8 <prvCopyDataToQueue+0xc0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   162aa:	9b03      	ldr	r3, [sp, #12]
   162ac:	68d8      	ldr	r0, [r3, #12]
   162ae:	9b03      	ldr	r3, [sp, #12]
   162b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   162b2:	461a      	mov	r2, r3
   162b4:	9902      	ldr	r1, [sp, #8]
   162b6:	f003 f8bd 	bl	19434 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   162ba:	9b03      	ldr	r3, [sp, #12]
   162bc:	68da      	ldr	r2, [r3, #12]
   162be:	9b03      	ldr	r3, [sp, #12]
   162c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   162c2:	425b      	negs	r3, r3
   162c4:	441a      	add	r2, r3
   162c6:	9b03      	ldr	r3, [sp, #12]
   162c8:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   162ca:	9b03      	ldr	r3, [sp, #12]
   162cc:	68da      	ldr	r2, [r3, #12]
   162ce:	9b03      	ldr	r3, [sp, #12]
   162d0:	681b      	ldr	r3, [r3, #0]
   162d2:	429a      	cmp	r2, r3
   162d4:	d207      	bcs.n	162e6 <prvCopyDataToQueue+0xae>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   162d6:	9b03      	ldr	r3, [sp, #12]
   162d8:	685a      	ldr	r2, [r3, #4]
   162da:	9b03      	ldr	r3, [sp, #12]
   162dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   162de:	425b      	negs	r3, r3
   162e0:	441a      	add	r2, r3
   162e2:	9b03      	ldr	r3, [sp, #12]
   162e4:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   162e6:	9b01      	ldr	r3, [sp, #4]
   162e8:	2b02      	cmp	r3, #2
   162ea:	d105      	bne.n	162f8 <prvCopyDataToQueue+0xc0>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   162ec:	9b04      	ldr	r3, [sp, #16]
   162ee:	2b00      	cmp	r3, #0
   162f0:	d002      	beq.n	162f8 <prvCopyDataToQueue+0xc0>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   162f2:	9b04      	ldr	r3, [sp, #16]
   162f4:	3b01      	subs	r3, #1
   162f6:	9304      	str	r3, [sp, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   162f8:	9b04      	ldr	r3, [sp, #16]
   162fa:	1c5a      	adds	r2, r3, #1
   162fc:	9b03      	ldr	r3, [sp, #12]
   162fe:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   16300:	9b05      	ldr	r3, [sp, #20]
}
   16302:	4618      	mov	r0, r3
   16304:	b007      	add	sp, #28
   16306:	f85d fb04 	ldr.w	pc, [sp], #4

0001630a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   1630a:	b500      	push	{lr}
   1630c:	b083      	sub	sp, #12
   1630e:	9001      	str	r0, [sp, #4]
   16310:	9100      	str	r1, [sp, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   16312:	9b01      	ldr	r3, [sp, #4]
   16314:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   16316:	2b00      	cmp	r3, #0
   16318:	d018      	beq.n	1634c <prvCopyDataFromQueue+0x42>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   1631a:	9b01      	ldr	r3, [sp, #4]
   1631c:	68da      	ldr	r2, [r3, #12]
   1631e:	9b01      	ldr	r3, [sp, #4]
   16320:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   16322:	441a      	add	r2, r3
   16324:	9b01      	ldr	r3, [sp, #4]
   16326:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   16328:	9b01      	ldr	r3, [sp, #4]
   1632a:	68da      	ldr	r2, [r3, #12]
   1632c:	9b01      	ldr	r3, [sp, #4]
   1632e:	685b      	ldr	r3, [r3, #4]
   16330:	429a      	cmp	r2, r3
   16332:	d303      	bcc.n	1633c <prvCopyDataFromQueue+0x32>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   16334:	9b01      	ldr	r3, [sp, #4]
   16336:	681a      	ldr	r2, [r3, #0]
   16338:	9b01      	ldr	r3, [sp, #4]
   1633a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   1633c:	9b01      	ldr	r3, [sp, #4]
   1633e:	68d9      	ldr	r1, [r3, #12]
   16340:	9b01      	ldr	r3, [sp, #4]
   16342:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   16344:	461a      	mov	r2, r3
   16346:	9800      	ldr	r0, [sp, #0]
   16348:	f003 f874 	bl	19434 <memcpy>
	}
}
   1634c:	bf00      	nop
   1634e:	b003      	add	sp, #12
   16350:	f85d fb04 	ldr.w	pc, [sp], #4

00016354 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   16354:	b500      	push	{lr}
   16356:	b085      	sub	sp, #20
   16358:	9001      	str	r0, [sp, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   1635a:	f000 f903 	bl	16564 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   1635e:	9b01      	ldr	r3, [sp, #4]
   16360:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   16364:	f88d 300f 	strb.w	r3, [sp, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   16368:	e013      	b.n	16392 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1636a:	9b01      	ldr	r3, [sp, #4]
   1636c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1636e:	2b00      	cmp	r3, #0
   16370:	d014      	beq.n	1639c <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   16372:	9b01      	ldr	r3, [sp, #4]
   16374:	3324      	adds	r3, #36	; 0x24
   16376:	4618      	mov	r0, r3
   16378:	f7ff fb8c 	bl	15a94 <xTaskRemoveFromEventList>
   1637c:	4603      	mov	r3, r0
   1637e:	2b00      	cmp	r3, #0
   16380:	d001      	beq.n	16386 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   16382:	f7ff fc33 	bl	15bec <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   16386:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1638a:	3b01      	subs	r3, #1
   1638c:	b2db      	uxtb	r3, r3
   1638e:	f88d 300f 	strb.w	r3, [sp, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
   16392:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   16396:	2b00      	cmp	r3, #0
   16398:	dce7      	bgt.n	1636a <prvUnlockQueue+0x16>
   1639a:	e000      	b.n	1639e <prvUnlockQueue+0x4a>
					break;
   1639c:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
   1639e:	9b01      	ldr	r3, [sp, #4]
   163a0:	22ff      	movs	r2, #255	; 0xff
   163a2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
   163a6:	f000 f8f1 	bl	1658c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   163aa:	f000 f8db 	bl	16564 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   163ae:	9b01      	ldr	r3, [sp, #4]
   163b0:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   163b4:	f88d 300e 	strb.w	r3, [sp, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   163b8:	e013      	b.n	163e2 <prvUnlockQueue+0x8e>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   163ba:	9b01      	ldr	r3, [sp, #4]
   163bc:	691b      	ldr	r3, [r3, #16]
   163be:	2b00      	cmp	r3, #0
   163c0:	d014      	beq.n	163ec <prvUnlockQueue+0x98>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   163c2:	9b01      	ldr	r3, [sp, #4]
   163c4:	3310      	adds	r3, #16
   163c6:	4618      	mov	r0, r3
   163c8:	f7ff fb64 	bl	15a94 <xTaskRemoveFromEventList>
   163cc:	4603      	mov	r3, r0
   163ce:	2b00      	cmp	r3, #0
   163d0:	d001      	beq.n	163d6 <prvUnlockQueue+0x82>
				{
					vTaskMissedYield();
   163d2:	f7ff fc0b 	bl	15bec <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   163d6:	f89d 300e 	ldrb.w	r3, [sp, #14]
   163da:	3b01      	subs	r3, #1
   163dc:	b2db      	uxtb	r3, r3
   163de:	f88d 300e 	strb.w	r3, [sp, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
   163e2:	f99d 300e 	ldrsb.w	r3, [sp, #14]
   163e6:	2b00      	cmp	r3, #0
   163e8:	dce7      	bgt.n	163ba <prvUnlockQueue+0x66>
   163ea:	e000      	b.n	163ee <prvUnlockQueue+0x9a>
			}
			else
			{
				break;
   163ec:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   163ee:	9b01      	ldr	r3, [sp, #4]
   163f0:	22ff      	movs	r2, #255	; 0xff
   163f2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   163f6:	f000 f8c9 	bl	1658c <vPortExitCritical>
}
   163fa:	bf00      	nop
   163fc:	b005      	add	sp, #20
   163fe:	f85d fb04 	ldr.w	pc, [sp], #4

00016402 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   16402:	b500      	push	{lr}
   16404:	b085      	sub	sp, #20
   16406:	9001      	str	r0, [sp, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   16408:	f000 f8ac 	bl	16564 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   1640c:	9b01      	ldr	r3, [sp, #4]
   1640e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   16410:	2b00      	cmp	r3, #0
   16412:	d102      	bne.n	1641a <prvIsQueueEmpty+0x18>
		{
			xReturn = pdTRUE;
   16414:	2301      	movs	r3, #1
   16416:	9303      	str	r3, [sp, #12]
   16418:	e001      	b.n	1641e <prvIsQueueEmpty+0x1c>
		}
		else
		{
			xReturn = pdFALSE;
   1641a:	2300      	movs	r3, #0
   1641c:	9303      	str	r3, [sp, #12]
		}
	}
	taskEXIT_CRITICAL();
   1641e:	f000 f8b5 	bl	1658c <vPortExitCritical>

	return xReturn;
   16422:	9b03      	ldr	r3, [sp, #12]
}
   16424:	4618      	mov	r0, r3
   16426:	b005      	add	sp, #20
   16428:	f85d fb04 	ldr.w	pc, [sp], #4

0001642c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   1642c:	b084      	sub	sp, #16
   1642e:	9003      	str	r0, [sp, #12]
   16430:	9102      	str	r1, [sp, #8]
   16432:	9201      	str	r2, [sp, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
   16434:	9b03      	ldr	r3, [sp, #12]
   16436:	3b04      	subs	r3, #4
   16438:	9303      	str	r3, [sp, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   1643a:	9b03      	ldr	r3, [sp, #12]
   1643c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   16440:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   16442:	9b03      	ldr	r3, [sp, #12]
   16444:	3b04      	subs	r3, #4
   16446:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   16448:	9b02      	ldr	r3, [sp, #8]
   1644a:	f023 0201 	bic.w	r2, r3, #1
   1644e:	9b03      	ldr	r3, [sp, #12]
   16450:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   16452:	9b03      	ldr	r3, [sp, #12]
   16454:	3b04      	subs	r3, #4
   16456:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   16458:	4a0b      	ldr	r2, [pc, #44]	; (16488 <pxPortInitialiseStack+0x5c>)
   1645a:	9b03      	ldr	r3, [sp, #12]
   1645c:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   1645e:	9b03      	ldr	r3, [sp, #12]
   16460:	3b14      	subs	r3, #20
   16462:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   16464:	9a01      	ldr	r2, [sp, #4]
   16466:	9b03      	ldr	r3, [sp, #12]
   16468:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
   1646a:	9b03      	ldr	r3, [sp, #12]
   1646c:	3b04      	subs	r3, #4
   1646e:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   16470:	9b03      	ldr	r3, [sp, #12]
   16472:	f06f 0202 	mvn.w	r2, #2
   16476:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   16478:	9b03      	ldr	r3, [sp, #12]
   1647a:	3b20      	subs	r3, #32
   1647c:	9303      	str	r3, [sp, #12]

	return pxTopOfStack;
   1647e:	9b03      	ldr	r3, [sp, #12]
}
   16480:	4618      	mov	r0, r3
   16482:	b004      	add	sp, #16
   16484:	4770      	bx	lr
   16486:	bf00      	nop
   16488:	0001648d 	.word	0x0001648d

0001648c <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   1648c:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   1648e:	2300      	movs	r3, #0
   16490:	9300      	str	r3, [sp, #0]
	__asm volatile
   16492:	f04f 0328 	mov.w	r3, #40	; 0x28
   16496:	f383 8811 	msr	BASEPRI, r3
   1649a:	f3bf 8f6f 	isb	sy
   1649e:	f3bf 8f4f 	dsb	sy
   164a2:	9301      	str	r3, [sp, #4]

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   164a4:	bf00      	nop
   164a6:	9b00      	ldr	r3, [sp, #0]
   164a8:	2b00      	cmp	r3, #0
   164aa:	d0fc      	beq.n	164a6 <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   164ac:	bf00      	nop
   164ae:	b002      	add	sp, #8
   164b0:	4770      	bx	lr
   164b2:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   164b6:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   164ba:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   164be:	Address 0x00000000000164be is out of bounds.


000164c0 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   164c0:	4b07      	ldr	r3, [pc, #28]	; (164e0 <pxCurrentTCBConst2>)
   164c2:	6819      	ldr	r1, [r3, #0]
   164c4:	6808      	ldr	r0, [r1, #0]
   164c6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   164ca:	f380 8809 	msr	PSP, r0
   164ce:	f3bf 8f6f 	isb	sy
   164d2:	f04f 0000 	mov.w	r0, #0
   164d6:	f380 8811 	msr	BASEPRI, r0
   164da:	4770      	bx	lr
   164dc:	f3af 8000 	nop.w

000164e0 <pxCurrentTCBConst2>:
   164e0:	1000153c 	.word	0x1000153c
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   164e4:	bf00      	nop
   164e6:	bf00      	nop

000164e8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
   164e8:	4808      	ldr	r0, [pc, #32]	; (1650c <prvPortStartFirstTask+0x24>)
   164ea:	6800      	ldr	r0, [r0, #0]
   164ec:	6800      	ldr	r0, [r0, #0]
   164ee:	f380 8808 	msr	MSP, r0
   164f2:	f04f 0000 	mov.w	r0, #0
   164f6:	f380 8814 	msr	CONTROL, r0
   164fa:	b662      	cpsie	i
   164fc:	b661      	cpsie	f
   164fe:	f3bf 8f4f 	dsb	sy
   16502:	f3bf 8f6f 	isb	sy
   16506:	df00      	svc	0
   16508:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
   1650a:	bf00      	nop
   1650c:	e000ed08 	.word	0xe000ed08

00016510 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   16510:	b508      	push	{r3, lr}
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   16512:	4b11      	ldr	r3, [pc, #68]	; (16558 <xPortStartScheduler+0x48>)
   16514:	681b      	ldr	r3, [r3, #0]
   16516:	4a10      	ldr	r2, [pc, #64]	; (16558 <xPortStartScheduler+0x48>)
   16518:	f443 0378 	orr.w	r3, r3, #16252928	; 0xf80000
   1651c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   1651e:	4b0e      	ldr	r3, [pc, #56]	; (16558 <xPortStartScheduler+0x48>)
   16520:	681b      	ldr	r3, [r3, #0]
   16522:	4a0d      	ldr	r2, [pc, #52]	; (16558 <xPortStartScheduler+0x48>)
   16524:	f043 4378 	orr.w	r3, r3, #4160749568	; 0xf8000000
   16528:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   1652a:	f7fe f92b 	bl	14784 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   1652e:	4b0b      	ldr	r3, [pc, #44]	; (1655c <xPortStartScheduler+0x4c>)
   16530:	2200      	movs	r2, #0
   16532:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
   16534:	f000 f898 	bl	16668 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   16538:	4b09      	ldr	r3, [pc, #36]	; (16560 <xPortStartScheduler+0x50>)
   1653a:	681b      	ldr	r3, [r3, #0]
   1653c:	4a08      	ldr	r2, [pc, #32]	; (16560 <xPortStartScheduler+0x50>)
   1653e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   16542:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   16544:	f7ff ffd0 	bl	164e8 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   16548:	f7ff fa2a 	bl	159a0 <vTaskSwitchContext>
	prvTaskExitError();
   1654c:	f7ff ff9e 	bl	1648c <prvTaskExitError>

	/* Should not get here! */
	return 0;
   16550:	2300      	movs	r3, #0
}
   16552:	4618      	mov	r0, r3
   16554:	bd08      	pop	{r3, pc}
   16556:	bf00      	nop
   16558:	e000ed20 	.word	0xe000ed20
   1655c:	100008d8 	.word	0x100008d8
   16560:	e000ef34 	.word	0xe000ef34

00016564 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   16564:	b082      	sub	sp, #8
   16566:	f04f 0328 	mov.w	r3, #40	; 0x28
   1656a:	f383 8811 	msr	BASEPRI, r3
   1656e:	f3bf 8f6f 	isb	sy
   16572:	f3bf 8f4f 	dsb	sy
   16576:	9301      	str	r3, [sp, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   16578:	4b03      	ldr	r3, [pc, #12]	; (16588 <vPortEnterCritical+0x24>)
   1657a:	681b      	ldr	r3, [r3, #0]
   1657c:	3301      	adds	r3, #1
   1657e:	4a02      	ldr	r2, [pc, #8]	; (16588 <vPortEnterCritical+0x24>)
   16580:	6013      	str	r3, [r2, #0]
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
   16582:	bf00      	nop
   16584:	b002      	add	sp, #8
   16586:	4770      	bx	lr
   16588:	100008d8 	.word	0x100008d8

0001658c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   1658c:	b082      	sub	sp, #8
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
   1658e:	4b08      	ldr	r3, [pc, #32]	; (165b0 <vPortExitCritical+0x24>)
   16590:	681b      	ldr	r3, [r3, #0]
   16592:	3b01      	subs	r3, #1
   16594:	4a06      	ldr	r2, [pc, #24]	; (165b0 <vPortExitCritical+0x24>)
   16596:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   16598:	4b05      	ldr	r3, [pc, #20]	; (165b0 <vPortExitCritical+0x24>)
   1659a:	681b      	ldr	r3, [r3, #0]
   1659c:	2b00      	cmp	r3, #0
   1659e:	d104      	bne.n	165aa <vPortExitCritical+0x1e>
   165a0:	2300      	movs	r3, #0
   165a2:	9301      	str	r3, [sp, #4]
	__asm volatile
   165a4:	9b01      	ldr	r3, [sp, #4]
   165a6:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   165aa:	bf00      	nop
   165ac:	b002      	add	sp, #8
   165ae:	4770      	bx	lr
   165b0:	100008d8 	.word	0x100008d8
   165b4:	ffffffff 	.word	0xffffffff
   165b8:	ffffffff 	.word	0xffffffff
   165bc:	ffffffff 	.word	0xffffffff

000165c0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   165c0:	f3ef 8009 	mrs	r0, PSP
   165c4:	f3bf 8f6f 	isb	sy
   165c8:	4b15      	ldr	r3, [pc, #84]	; (16620 <pxCurrentTCBConst>)
   165ca:	681a      	ldr	r2, [r3, #0]
   165cc:	f01e 0f10 	tst.w	lr, #16
   165d0:	bf08      	it	eq
   165d2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   165d6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   165da:	6010      	str	r0, [r2, #0]
   165dc:	e92d 0009 	stmdb	sp!, {r0, r3}
   165e0:	f04f 0028 	mov.w	r0, #40	; 0x28
   165e4:	f380 8811 	msr	BASEPRI, r0
   165e8:	f3bf 8f4f 	dsb	sy
   165ec:	f3bf 8f6f 	isb	sy
   165f0:	f7ff f9d6 	bl	159a0 <vTaskSwitchContext>
   165f4:	f04f 0000 	mov.w	r0, #0
   165f8:	f380 8811 	msr	BASEPRI, r0
   165fc:	bc09      	pop	{r0, r3}
   165fe:	6819      	ldr	r1, [r3, #0]
   16600:	6808      	ldr	r0, [r1, #0]
   16602:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16606:	f01e 0f10 	tst.w	lr, #16
   1660a:	bf08      	it	eq
   1660c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   16610:	f380 8809 	msr	PSP, r0
   16614:	f3bf 8f6f 	isb	sy
   16618:	4770      	bx	lr
   1661a:	bf00      	nop
   1661c:	f3af 8000 	nop.w

00016620 <pxCurrentTCBConst>:
   16620:	1000153c 	.word	0x1000153c
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   16624:	bf00      	nop
   16626:	bf00      	nop

00016628 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   16628:	b500      	push	{lr}
   1662a:	b083      	sub	sp, #12
	__asm volatile
   1662c:	f04f 0328 	mov.w	r3, #40	; 0x28
   16630:	f383 8811 	msr	BASEPRI, r3
   16634:	f3bf 8f6f 	isb	sy
   16638:	f3bf 8f4f 	dsb	sy
   1663c:	9301      	str	r3, [sp, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   1663e:	f7ff f903 	bl	15848 <xTaskIncrementTick>
   16642:	4603      	mov	r3, r0
   16644:	2b00      	cmp	r3, #0
   16646:	d003      	beq.n	16650 <xPortSysTickHandler+0x28>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   16648:	4b06      	ldr	r3, [pc, #24]	; (16664 <xPortSysTickHandler+0x3c>)
   1664a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1664e:	601a      	str	r2, [r3, #0]
   16650:	2300      	movs	r3, #0
   16652:	9300      	str	r3, [sp, #0]
	__asm volatile
   16654:	9b00      	ldr	r3, [sp, #0]
   16656:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   1665a:	bf00      	nop
   1665c:	b003      	add	sp, #12
   1665e:	f85d fb04 	ldr.w	pc, [sp], #4
   16662:	bf00      	nop
   16664:	e000ed04 	.word	0xe000ed04

00016668 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   16668:	f8df 000c 	ldr.w	r0, [pc, #12]	; 16678 <vPortEnableVFP+0x10>
   1666c:	6801      	ldr	r1, [r0, #0]
   1666e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   16672:	6001      	str	r1, [r0, #0]
   16674:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   16676:	bf00      	nop
   16678:	e000ed88 	.word	0xe000ed88

0001667c <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   1667c:	b500      	push	{lr}
   1667e:	b085      	sub	sp, #20
   16680:	9001      	str	r0, [sp, #4]
void *pvReturn;

	vTaskSuspendAll();
   16682:	f7ff f84b 	bl	1571c <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
   16686:	9801      	ldr	r0, [sp, #4]
   16688:	f002 fec4 	bl	19414 <malloc>
   1668c:	4603      	mov	r3, r0
   1668e:	9303      	str	r3, [sp, #12]
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   16690:	f7ff f84e 	bl	15730 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
   16694:	9b03      	ldr	r3, [sp, #12]
}
   16696:	4618      	mov	r0, r3
   16698:	b005      	add	sp, #20
   1669a:	f85d fb04 	ldr.w	pc, [sp], #4

0001669e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   1669e:	b500      	push	{lr}
   166a0:	b083      	sub	sp, #12
   166a2:	9001      	str	r0, [sp, #4]
	if( pv )
   166a4:	9b01      	ldr	r3, [sp, #4]
   166a6:	2b00      	cmp	r3, #0
   166a8:	d006      	beq.n	166b8 <vPortFree+0x1a>
	{
		vTaskSuspendAll();
   166aa:	f7ff f837 	bl	1571c <vTaskSuspendAll>
		{
			free( pv );
   166ae:	9801      	ldr	r0, [sp, #4]
   166b0:	f002 feb8 	bl	19424 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
   166b4:	f7ff f83c 	bl	15730 <xTaskResumeAll>
	}
}
   166b8:	bf00      	nop
   166ba:	b003      	add	sp, #12
   166bc:	f85d fb04 	ldr.w	pc, [sp], #4

000166c0 <_out_buffer(char, void*, unsigned int, unsigned int)>:
} out_fct_wrap_type;


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
   166c0:	b510      	push	{r4, lr}
   166c2:	b084      	sub	sp, #16
   166c4:	4674      	mov	r4, lr
   166c6:	9102      	str	r1, [sp, #8]
   166c8:	9201      	str	r2, [sp, #4]
   166ca:	9300      	str	r3, [sp, #0]
   166cc:	4603      	mov	r3, r0
   166ce:	f88d 300f 	strb.w	r3, [sp, #15]
   166d2:	4623      	mov	r3, r4
   166d4:	4619      	mov	r1, r3
   166d6:	480a      	ldr	r0, [pc, #40]	; (16700 <_out_buffer(char, void*, unsigned int, unsigned int)+0x40>)
   166d8:	f7fe fd8e 	bl	151f8 <__cyg_profile_func_enter>
  if (idx < maxlen) {
   166dc:	9a01      	ldr	r2, [sp, #4]
   166de:	9b00      	ldr	r3, [sp, #0]
   166e0:	429a      	cmp	r2, r3
   166e2:	d205      	bcs.n	166f0 <_out_buffer(char, void*, unsigned int, unsigned int)+0x30>
    ((char*)buffer)[idx] = character;
   166e4:	9a02      	ldr	r2, [sp, #8]
   166e6:	9b01      	ldr	r3, [sp, #4]
   166e8:	4413      	add	r3, r2
   166ea:	f89d 200f 	ldrb.w	r2, [sp, #15]
   166ee:	701a      	strb	r2, [r3, #0]
   166f0:	4623      	mov	r3, r4
   166f2:	4619      	mov	r1, r3
   166f4:	4802      	ldr	r0, [pc, #8]	; (16700 <_out_buffer(char, void*, unsigned int, unsigned int)+0x40>)
   166f6:	f7fe fd93 	bl	15220 <__cyg_profile_func_exit>
  }
}
   166fa:	bf00      	nop
   166fc:	b004      	add	sp, #16
   166fe:	bd10      	pop	{r4, pc}
   16700:	000166c1 	.word	0x000166c1

00016704 <_out_null(char, void*, unsigned int, unsigned int)>:


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
   16704:	b510      	push	{r4, lr}
   16706:	b084      	sub	sp, #16
   16708:	4674      	mov	r4, lr
   1670a:	9102      	str	r1, [sp, #8]
   1670c:	9201      	str	r2, [sp, #4]
   1670e:	9300      	str	r3, [sp, #0]
   16710:	4603      	mov	r3, r0
   16712:	f88d 300f 	strb.w	r3, [sp, #15]
   16716:	4623      	mov	r3, r4
   16718:	4619      	mov	r1, r3
   1671a:	4805      	ldr	r0, [pc, #20]	; (16730 <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   1671c:	f7fe fd6c 	bl	151f8 <__cyg_profile_func_enter>
   16720:	4623      	mov	r3, r4
   16722:	4619      	mov	r1, r3
   16724:	4802      	ldr	r0, [pc, #8]	; (16730 <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   16726:	f7fe fd7b 	bl	15220 <__cyg_profile_func_exit>
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
   1672a:	bf00      	nop
   1672c:	b004      	add	sp, #16
   1672e:	bd10      	pop	{r4, pc}
   16730:	00016705 	.word	0x00016705

00016734 <_out_char(char, void*, unsigned int, unsigned int)>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
   16734:	b510      	push	{r4, lr}
   16736:	b084      	sub	sp, #16
   16738:	4674      	mov	r4, lr
   1673a:	9102      	str	r1, [sp, #8]
   1673c:	9201      	str	r2, [sp, #4]
   1673e:	9300      	str	r3, [sp, #0]
   16740:	4603      	mov	r3, r0
   16742:	f88d 300f 	strb.w	r3, [sp, #15]
   16746:	4623      	mov	r3, r4
   16748:	4619      	mov	r1, r3
   1674a:	480a      	ldr	r0, [pc, #40]	; (16774 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   1674c:	f7fe fd54 	bl	151f8 <__cyg_profile_func_enter>
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
   16750:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16754:	2b00      	cmp	r3, #0
   16756:	d004      	beq.n	16762 <_out_char(char, void*, unsigned int, unsigned int)+0x2e>
    _putchar(character);
   16758:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1675c:	4618      	mov	r0, r3
   1675e:	f7fe fce1 	bl	15124 <_putchar>
   16762:	4623      	mov	r3, r4
   16764:	4619      	mov	r1, r3
   16766:	4803      	ldr	r0, [pc, #12]	; (16774 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   16768:	f7fe fd5a 	bl	15220 <__cyg_profile_func_exit>
  }
}
   1676c:	bf00      	nop
   1676e:	b004      	add	sp, #16
   16770:	bd10      	pop	{r4, pc}
   16772:	bf00      	nop
   16774:	00016735 	.word	0x00016735

00016778 <_strlen(char const*)>:


// internal strlen
// \return The length of the string (excluding the terminating 0)
static inline unsigned int _strlen(const char* str)
{
   16778:	b530      	push	{r4, r5, lr}
   1677a:	b085      	sub	sp, #20
   1677c:	4674      	mov	r4, lr
   1677e:	9001      	str	r0, [sp, #4]
   16780:	4623      	mov	r3, r4
   16782:	4619      	mov	r1, r3
   16784:	480c      	ldr	r0, [pc, #48]	; (167b8 <_strlen(char const*)+0x40>)
   16786:	f7fe fd37 	bl	151f8 <__cyg_profile_func_enter>
  const char* s;
  for (s = str; *s; ++s);
   1678a:	9b01      	ldr	r3, [sp, #4]
   1678c:	9303      	str	r3, [sp, #12]
   1678e:	9b03      	ldr	r3, [sp, #12]
   16790:	781b      	ldrb	r3, [r3, #0]
   16792:	2b00      	cmp	r3, #0
   16794:	d003      	beq.n	1679e <_strlen(char const*)+0x26>
   16796:	9b03      	ldr	r3, [sp, #12]
   16798:	3301      	adds	r3, #1
   1679a:	9303      	str	r3, [sp, #12]
   1679c:	e7f7      	b.n	1678e <_strlen(char const*)+0x16>
  return (unsigned int)(s - str);
   1679e:	9a03      	ldr	r2, [sp, #12]
   167a0:	9b01      	ldr	r3, [sp, #4]
   167a2:	1ad3      	subs	r3, r2, r3
   167a4:	461d      	mov	r5, r3
   167a6:	4623      	mov	r3, r4
   167a8:	4619      	mov	r1, r3
   167aa:	4803      	ldr	r0, [pc, #12]	; (167b8 <_strlen(char const*)+0x40>)
   167ac:	f7fe fd38 	bl	15220 <__cyg_profile_func_exit>
   167b0:	462b      	mov	r3, r5
}
   167b2:	4618      	mov	r0, r3
   167b4:	b005      	add	sp, #20
   167b6:	bd30      	pop	{r4, r5, pc}
   167b8:	00016779 	.word	0x00016779

000167bc <_is_digit(char)>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
   167bc:	b530      	push	{r4, r5, lr}
   167be:	b083      	sub	sp, #12
   167c0:	4675      	mov	r5, lr
   167c2:	4603      	mov	r3, r0
   167c4:	f88d 3007 	strb.w	r3, [sp, #7]
   167c8:	462b      	mov	r3, r5
   167ca:	4619      	mov	r1, r3
   167cc:	480b      	ldr	r0, [pc, #44]	; (167fc <_is_digit(char)+0x40>)
   167ce:	f7fe fd13 	bl	151f8 <__cyg_profile_func_enter>
  return (ch >= '0') && (ch <= '9');
   167d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   167d6:	2b2f      	cmp	r3, #47	; 0x2f
   167d8:	d905      	bls.n	167e6 <_is_digit(char)+0x2a>
   167da:	f89d 3007 	ldrb.w	r3, [sp, #7]
   167de:	2b39      	cmp	r3, #57	; 0x39
   167e0:	d801      	bhi.n	167e6 <_is_digit(char)+0x2a>
   167e2:	2401      	movs	r4, #1
   167e4:	e000      	b.n	167e8 <_is_digit(char)+0x2c>
   167e6:	2400      	movs	r4, #0
   167e8:	462b      	mov	r3, r5
   167ea:	4619      	mov	r1, r3
   167ec:	4803      	ldr	r0, [pc, #12]	; (167fc <_is_digit(char)+0x40>)
   167ee:	f7fe fd17 	bl	15220 <__cyg_profile_func_exit>
   167f2:	4623      	mov	r3, r4
}
   167f4:	4618      	mov	r0, r3
   167f6:	b003      	add	sp, #12
   167f8:	bd30      	pop	{r4, r5, pc}
   167fa:	bf00      	nop
   167fc:	000167bd 	.word	0x000167bd

00016800 <_atoi(char const**)>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
   16800:	b530      	push	{r4, r5, lr}
   16802:	b085      	sub	sp, #20
   16804:	4675      	mov	r5, lr
   16806:	9001      	str	r0, [sp, #4]
   16808:	462b      	mov	r3, r5
   1680a:	4619      	mov	r1, r3
   1680c:	4813      	ldr	r0, [pc, #76]	; (1685c <_atoi(char const**)+0x5c>)
   1680e:	f7fe fcf3 	bl	151f8 <__cyg_profile_func_enter>
  unsigned int i = 0U;
   16812:	2300      	movs	r3, #0
   16814:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   16816:	9b01      	ldr	r3, [sp, #4]
   16818:	681b      	ldr	r3, [r3, #0]
   1681a:	781b      	ldrb	r3, [r3, #0]
   1681c:	4618      	mov	r0, r3
   1681e:	f7ff ffcd 	bl	167bc <_is_digit(char)>
   16822:	4603      	mov	r3, r0
   16824:	2b00      	cmp	r3, #0
   16826:	d00f      	beq.n	16848 <_atoi(char const**)+0x48>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
   16828:	9a03      	ldr	r2, [sp, #12]
   1682a:	4613      	mov	r3, r2
   1682c:	009b      	lsls	r3, r3, #2
   1682e:	4413      	add	r3, r2
   16830:	005b      	lsls	r3, r3, #1
   16832:	4618      	mov	r0, r3
   16834:	9b01      	ldr	r3, [sp, #4]
   16836:	681b      	ldr	r3, [r3, #0]
   16838:	1c59      	adds	r1, r3, #1
   1683a:	9a01      	ldr	r2, [sp, #4]
   1683c:	6011      	str	r1, [r2, #0]
   1683e:	781b      	ldrb	r3, [r3, #0]
   16840:	4403      	add	r3, r0
   16842:	3b30      	subs	r3, #48	; 0x30
   16844:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   16846:	e7e6      	b.n	16816 <_atoi(char const**)+0x16>
  }
  return i;
   16848:	9c03      	ldr	r4, [sp, #12]
   1684a:	462b      	mov	r3, r5
   1684c:	4619      	mov	r1, r3
   1684e:	4803      	ldr	r0, [pc, #12]	; (1685c <_atoi(char const**)+0x5c>)
   16850:	f7fe fce6 	bl	15220 <__cyg_profile_func_exit>
   16854:	4623      	mov	r3, r4
}
   16856:	4618      	mov	r0, r3
   16858:	b005      	add	sp, #20
   1685a:	bd30      	pop	{r4, r5, pc}
   1685c:	00016801 	.word	0x00016801

00016860 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
   16860:	b530      	push	{r4, r5, lr}
   16862:	b089      	sub	sp, #36	; 0x24
   16864:	4675      	mov	r5, lr
   16866:	9003      	str	r0, [sp, #12]
   16868:	9102      	str	r1, [sp, #8]
   1686a:	9201      	str	r2, [sp, #4]
   1686c:	9300      	str	r3, [sp, #0]
   1686e:	462b      	mov	r3, r5
   16870:	4619      	mov	r1, r3
   16872:	4891      	ldr	r0, [pc, #580]	; (16ab8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   16874:	f7fe fcc0 	bl	151f8 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   16878:	9b01      	ldr	r3, [sp, #4]
   1687a:	9305      	str	r3, [sp, #20]

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   1687c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1687e:	f003 0302 	and.w	r3, r3, #2
   16882:	2b00      	cmp	r3, #0
   16884:	d10e      	bne.n	168a4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   16886:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16888:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1688a:	429a      	cmp	r2, r3
   1688c:	d20a      	bcs.n	168a4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   1688e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16890:	2b1f      	cmp	r3, #31
   16892:	d807      	bhi.n	168a4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
    buf[len++] = '0';
   16894:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16896:	1c5a      	adds	r2, r3, #1
   16898:	920d      	str	r2, [sp, #52]	; 0x34
   1689a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1689c:	4413      	add	r3, r2
   1689e:	2230      	movs	r2, #48	; 0x30
   168a0:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   168a2:	e7eb      	b.n	1687c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1c>
  }
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   168a4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   168a6:	f003 0302 	and.w	r3, r3, #2
   168aa:	2b00      	cmp	r3, #0
   168ac:	d113      	bne.n	168d6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   168ae:	9b12      	ldr	r3, [sp, #72]	; 0x48
   168b0:	f003 0301 	and.w	r3, r3, #1
   168b4:	2b00      	cmp	r3, #0
   168b6:	d00e      	beq.n	168d6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   168b8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   168ba:	9b11      	ldr	r3, [sp, #68]	; 0x44
   168bc:	429a      	cmp	r2, r3
   168be:	d20a      	bcs.n	168d6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   168c0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   168c2:	2b1f      	cmp	r3, #31
   168c4:	d807      	bhi.n	168d6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
    buf[len++] = '0';
   168c6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   168c8:	1c5a      	adds	r2, r3, #1
   168ca:	920d      	str	r2, [sp, #52]	; 0x34
   168cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   168ce:	4413      	add	r3, r2
   168d0:	2230      	movs	r2, #48	; 0x30
   168d2:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   168d4:	e7e6      	b.n	168a4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
  }

  // handle hash
  if (flags & FLAGS_HASH) {
   168d6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   168d8:	f003 0310 	and.w	r3, r3, #16
   168dc:	2b00      	cmp	r3, #0
   168de:	d058      	beq.n	16992 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   168e0:	9b12      	ldr	r3, [sp, #72]	; 0x48
   168e2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   168e6:	2b00      	cmp	r3, #0
   168e8:	d116      	bne.n	16918 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   168ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   168ec:	2b00      	cmp	r3, #0
   168ee:	d013      	beq.n	16918 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   168f0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   168f2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   168f4:	429a      	cmp	r2, r3
   168f6:	d003      	beq.n	16900 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xa0>
   168f8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   168fa:	9b11      	ldr	r3, [sp, #68]	; 0x44
   168fc:	429a      	cmp	r2, r3
   168fe:	d10b      	bne.n	16918 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
      len--;
   16900:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16902:	3b01      	subs	r3, #1
   16904:	930d      	str	r3, [sp, #52]	; 0x34
      if (len && (base == 16U)) {
   16906:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16908:	2b00      	cmp	r3, #0
   1690a:	d005      	beq.n	16918 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   1690c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1690e:	2b10      	cmp	r3, #16
   16910:	d102      	bne.n	16918 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
        len--;
   16912:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16914:	3b01      	subs	r3, #1
   16916:	930d      	str	r3, [sp, #52]	; 0x34
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16918:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1691a:	2b10      	cmp	r3, #16
   1691c:	d10f      	bne.n	1693e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   1691e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16920:	f003 0320 	and.w	r3, r3, #32
   16924:	2b00      	cmp	r3, #0
   16926:	d10a      	bne.n	1693e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   16928:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1692a:	2b1f      	cmp	r3, #31
   1692c:	d807      	bhi.n	1693e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
      buf[len++] = 'x';
   1692e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16930:	1c5a      	adds	r2, r3, #1
   16932:	920d      	str	r2, [sp, #52]	; 0x34
   16934:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16936:	4413      	add	r3, r2
   16938:	2278      	movs	r2, #120	; 0x78
   1693a:	701a      	strb	r2, [r3, #0]
   1693c:	e01f      	b.n	1697e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   1693e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16940:	2b10      	cmp	r3, #16
   16942:	d10f      	bne.n	16964 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   16944:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16946:	f003 0320 	and.w	r3, r3, #32
   1694a:	2b00      	cmp	r3, #0
   1694c:	d00a      	beq.n	16964 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   1694e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16950:	2b1f      	cmp	r3, #31
   16952:	d807      	bhi.n	16964 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
      buf[len++] = 'X';
   16954:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16956:	1c5a      	adds	r2, r3, #1
   16958:	920d      	str	r2, [sp, #52]	; 0x34
   1695a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1695c:	4413      	add	r3, r2
   1695e:	2258      	movs	r2, #88	; 0x58
   16960:	701a      	strb	r2, [r3, #0]
   16962:	e00c      	b.n	1697e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   16964:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16966:	2b02      	cmp	r3, #2
   16968:	d109      	bne.n	1697e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
   1696a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1696c:	2b1f      	cmp	r3, #31
   1696e:	d806      	bhi.n	1697e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
      buf[len++] = 'b';
   16970:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16972:	1c5a      	adds	r2, r3, #1
   16974:	920d      	str	r2, [sp, #52]	; 0x34
   16976:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16978:	4413      	add	r3, r2
   1697a:	2262      	movs	r2, #98	; 0x62
   1697c:	701a      	strb	r2, [r3, #0]
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
   1697e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16980:	2b1f      	cmp	r3, #31
   16982:	d806      	bhi.n	16992 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
      buf[len++] = '0';
   16984:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16986:	1c5a      	adds	r2, r3, #1
   16988:	920d      	str	r2, [sp, #52]	; 0x34
   1698a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1698c:	4413      	add	r3, r2
   1698e:	2230      	movs	r2, #48	; 0x30
   16990:	701a      	strb	r2, [r3, #0]
    }
  }

  // handle sign
  if (len && (len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   16992:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16994:	2b00      	cmp	r3, #0
   16996:	d014      	beq.n	169c2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   16998:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1699a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1699c:	429a      	cmp	r2, r3
   1699e:	d110      	bne.n	169c2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   169a0:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   169a4:	2b00      	cmp	r3, #0
   169a6:	d109      	bne.n	169bc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   169a8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   169aa:	f003 0304 	and.w	r3, r3, #4
   169ae:	2b00      	cmp	r3, #0
   169b0:	d104      	bne.n	169bc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   169b2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   169b4:	f003 0308 	and.w	r3, r3, #8
   169b8:	2b00      	cmp	r3, #0
   169ba:	d002      	beq.n	169c2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
    len--;
   169bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   169be:	3b01      	subs	r3, #1
   169c0:	930d      	str	r3, [sp, #52]	; 0x34
  }
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
   169c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   169c4:	2b1f      	cmp	r3, #31
   169c6:	d824      	bhi.n	16a12 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    if (negative) {
   169c8:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   169cc:	2b00      	cmp	r3, #0
   169ce:	d007      	beq.n	169e0 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x180>
      buf[len++] = '-';
   169d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   169d2:	1c5a      	adds	r2, r3, #1
   169d4:	920d      	str	r2, [sp, #52]	; 0x34
   169d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   169d8:	4413      	add	r3, r2
   169da:	222d      	movs	r2, #45	; 0x2d
   169dc:	701a      	strb	r2, [r3, #0]
   169de:	e018      	b.n	16a12 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_PLUS) {
   169e0:	9b12      	ldr	r3, [sp, #72]	; 0x48
   169e2:	f003 0304 	and.w	r3, r3, #4
   169e6:	2b00      	cmp	r3, #0
   169e8:	d007      	beq.n	169fa <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x19a>
      buf[len++] = '+';  // ignore the space if the '+' exists
   169ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   169ec:	1c5a      	adds	r2, r3, #1
   169ee:	920d      	str	r2, [sp, #52]	; 0x34
   169f0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   169f2:	4413      	add	r3, r2
   169f4:	222b      	movs	r2, #43	; 0x2b
   169f6:	701a      	strb	r2, [r3, #0]
   169f8:	e00b      	b.n	16a12 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_SPACE) {
   169fa:	9b12      	ldr	r3, [sp, #72]	; 0x48
   169fc:	f003 0308 	and.w	r3, r3, #8
   16a00:	2b00      	cmp	r3, #0
   16a02:	d006      	beq.n	16a12 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
      buf[len++] = ' ';
   16a04:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16a06:	1c5a      	adds	r2, r3, #1
   16a08:	920d      	str	r2, [sp, #52]	; 0x34
   16a0a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16a0c:	4413      	add	r3, r2
   16a0e:	2220      	movs	r2, #32
   16a10:	701a      	strb	r2, [r3, #0]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   16a12:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16a14:	f003 0302 	and.w	r3, r3, #2
   16a18:	2b00      	cmp	r3, #0
   16a1a:	d116      	bne.n	16a4a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
   16a1c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16a1e:	f003 0301 	and.w	r3, r3, #1
   16a22:	2b00      	cmp	r3, #0
   16a24:	d111      	bne.n	16a4a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
    for (size_t i = len; i < width; i++) {
   16a26:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16a28:	9307      	str	r3, [sp, #28]
   16a2a:	9a07      	ldr	r2, [sp, #28]
   16a2c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16a2e:	429a      	cmp	r2, r3
   16a30:	d20b      	bcs.n	16a4a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
      out(' ', buffer, idx++, maxlen);
   16a32:	9a01      	ldr	r2, [sp, #4]
   16a34:	1c53      	adds	r3, r2, #1
   16a36:	9301      	str	r3, [sp, #4]
   16a38:	9c03      	ldr	r4, [sp, #12]
   16a3a:	9b00      	ldr	r3, [sp, #0]
   16a3c:	9902      	ldr	r1, [sp, #8]
   16a3e:	2020      	movs	r0, #32
   16a40:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   16a42:	9b07      	ldr	r3, [sp, #28]
   16a44:	3301      	adds	r3, #1
   16a46:	9307      	str	r3, [sp, #28]
   16a48:	e7ef      	b.n	16a2a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ca>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   16a4a:	2300      	movs	r3, #0
   16a4c:	9306      	str	r3, [sp, #24]
   16a4e:	9a06      	ldr	r2, [sp, #24]
   16a50:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16a52:	429a      	cmp	r2, r3
   16a54:	d211      	bcs.n	16a7a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x21a>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   16a56:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16a58:	9b06      	ldr	r3, [sp, #24]
   16a5a:	1ad3      	subs	r3, r2, r3
   16a5c:	3b01      	subs	r3, #1
   16a5e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16a60:	4413      	add	r3, r2
   16a62:	7818      	ldrb	r0, [r3, #0]
   16a64:	9a01      	ldr	r2, [sp, #4]
   16a66:	1c53      	adds	r3, r2, #1
   16a68:	9301      	str	r3, [sp, #4]
   16a6a:	9c03      	ldr	r4, [sp, #12]
   16a6c:	9b00      	ldr	r3, [sp, #0]
   16a6e:	9902      	ldr	r1, [sp, #8]
   16a70:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   16a72:	9b06      	ldr	r3, [sp, #24]
   16a74:	3301      	adds	r3, #1
   16a76:	9306      	str	r3, [sp, #24]
   16a78:	e7e9      	b.n	16a4e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ee>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   16a7a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16a7c:	f003 0302 	and.w	r3, r3, #2
   16a80:	2b00      	cmp	r3, #0
   16a82:	d00e      	beq.n	16aa2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
    while (idx - start_idx < width) {
   16a84:	9a01      	ldr	r2, [sp, #4]
   16a86:	9b05      	ldr	r3, [sp, #20]
   16a88:	1ad3      	subs	r3, r2, r3
   16a8a:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16a8c:	429a      	cmp	r2, r3
   16a8e:	d908      	bls.n	16aa2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
      out(' ', buffer, idx++, maxlen);
   16a90:	9a01      	ldr	r2, [sp, #4]
   16a92:	1c53      	adds	r3, r2, #1
   16a94:	9301      	str	r3, [sp, #4]
   16a96:	9c03      	ldr	r4, [sp, #12]
   16a98:	9b00      	ldr	r3, [sp, #0]
   16a9a:	9902      	ldr	r1, [sp, #8]
   16a9c:	2020      	movs	r0, #32
   16a9e:	47a0      	blx	r4
    while (idx - start_idx < width) {
   16aa0:	e7f0      	b.n	16a84 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x224>
    }
  }

  return idx;
   16aa2:	9c01      	ldr	r4, [sp, #4]
   16aa4:	462b      	mov	r3, r5
   16aa6:	4619      	mov	r1, r3
   16aa8:	4803      	ldr	r0, [pc, #12]	; (16ab8 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   16aaa:	f7fe fbb9 	bl	15220 <__cyg_profile_func_exit>
   16aae:	4623      	mov	r3, r4
}
   16ab0:	4618      	mov	r0, r3
   16ab2:	b009      	add	sp, #36	; 0x24
   16ab4:	bd30      	pop	{r4, r5, pc}
   16ab6:	bf00      	nop
   16ab8:	00016861 	.word	0x00016861

00016abc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   16abc:	b530      	push	{r4, r5, lr}
   16abe:	b097      	sub	sp, #92	; 0x5c
   16ac0:	4674      	mov	r4, lr
   16ac2:	900b      	str	r0, [sp, #44]	; 0x2c
   16ac4:	910a      	str	r1, [sp, #40]	; 0x28
   16ac6:	9209      	str	r2, [sp, #36]	; 0x24
   16ac8:	9308      	str	r3, [sp, #32]
   16aca:	4623      	mov	r3, r4
   16acc:	4619      	mov	r1, r3
   16ace:	4833      	ldr	r0, [pc, #204]	; (16b9c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   16ad0:	f7fe fb92 	bl	151f8 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   16ad4:	2300      	movs	r3, #0
   16ad6:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   16ad8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16ada:	2b00      	cmp	r3, #0
   16adc:	d103      	bne.n	16ae6 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x2a>
    flags &= ~FLAGS_HASH;
   16ade:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16ae0:	f023 0310 	bic.w	r3, r3, #16
   16ae4:	931f      	str	r3, [sp, #124]	; 0x7c
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   16ae6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16ae8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   16aec:	2b00      	cmp	r3, #0
   16aee:	d002      	beq.n	16af6 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
   16af0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16af2:	2b00      	cmp	r3, #0
   16af4:	d033      	beq.n	16b5e <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
      const char digit = (char)(value % base);
   16af6:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16af8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   16afa:	fbb3 f2f2 	udiv	r2, r3, r2
   16afe:	991c      	ldr	r1, [sp, #112]	; 0x70
   16b00:	fb01 f202 	mul.w	r2, r1, r2
   16b04:	1a9b      	subs	r3, r3, r2
   16b06:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   16b0a:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16b0e:	2b09      	cmp	r3, #9
   16b10:	d804      	bhi.n	16b1c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x60>
   16b12:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16b16:	3330      	adds	r3, #48	; 0x30
   16b18:	b2da      	uxtb	r2, r3
   16b1a:	e00d      	b.n	16b38 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x7c>
   16b1c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16b1e:	f003 0320 	and.w	r3, r3, #32
   16b22:	2b00      	cmp	r3, #0
   16b24:	d001      	beq.n	16b2a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x6e>
   16b26:	2241      	movs	r2, #65	; 0x41
   16b28:	e000      	b.n	16b2c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x70>
   16b2a:	2261      	movs	r2, #97	; 0x61
   16b2c:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16b30:	4413      	add	r3, r2
   16b32:	b2db      	uxtb	r3, r3
   16b34:	3b0a      	subs	r3, #10
   16b36:	b2da      	uxtb	r2, r3
   16b38:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16b3a:	1c59      	adds	r1, r3, #1
   16b3c:	9115      	str	r1, [sp, #84]	; 0x54
   16b3e:	a916      	add	r1, sp, #88	; 0x58
   16b40:	440b      	add	r3, r1
   16b42:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   16b46:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   16b48:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   16b4a:	fbb2 f3f3 	udiv	r3, r2, r3
   16b4e:	931a      	str	r3, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   16b50:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   16b52:	2b00      	cmp	r3, #0
   16b54:	d003      	beq.n	16b5e <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
   16b56:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16b58:	2b1f      	cmp	r3, #31
   16b5a:	d800      	bhi.n	16b5e <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
   16b5c:	e7cb      	b.n	16af6 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   16b5e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16b60:	9306      	str	r3, [sp, #24]
   16b62:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16b64:	9305      	str	r3, [sp, #20]
   16b66:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   16b68:	9304      	str	r3, [sp, #16]
   16b6a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   16b6c:	9303      	str	r3, [sp, #12]
   16b6e:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
   16b72:	9302      	str	r3, [sp, #8]
   16b74:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16b76:	9301      	str	r3, [sp, #4]
   16b78:	ab0c      	add	r3, sp, #48	; 0x30
   16b7a:	9300      	str	r3, [sp, #0]
   16b7c:	9b08      	ldr	r3, [sp, #32]
   16b7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16b80:	990a      	ldr	r1, [sp, #40]	; 0x28
   16b82:	980b      	ldr	r0, [sp, #44]	; 0x2c
   16b84:	f7ff fe6c 	bl	16860 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   16b88:	4605      	mov	r5, r0
   16b8a:	4623      	mov	r3, r4
   16b8c:	4619      	mov	r1, r3
   16b8e:	4803      	ldr	r0, [pc, #12]	; (16b9c <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   16b90:	f7fe fb46 	bl	15220 <__cyg_profile_func_exit>
   16b94:	462b      	mov	r3, r5
}
   16b96:	4618      	mov	r0, r3
   16b98:	b017      	add	sp, #92	; 0x5c
   16b9a:	bd30      	pop	{r4, r5, pc}
   16b9c:	00016abd 	.word	0x00016abd

00016ba0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   16ba0:	b530      	push	{r4, r5, lr}
   16ba2:	b097      	sub	sp, #92	; 0x5c
   16ba4:	4675      	mov	r5, lr
   16ba6:	900b      	str	r0, [sp, #44]	; 0x2c
   16ba8:	910a      	str	r1, [sp, #40]	; 0x28
   16baa:	9209      	str	r2, [sp, #36]	; 0x24
   16bac:	9308      	str	r3, [sp, #32]
   16bae:	462b      	mov	r3, r5
   16bb0:	4619      	mov	r1, r3
   16bb2:	4837      	ldr	r0, [pc, #220]	; (16c90 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   16bb4:	f7fe fb20 	bl	151f8 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   16bb8:	2300      	movs	r3, #0
   16bba:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   16bbc:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   16bc0:	4323      	orrs	r3, r4
   16bc2:	d103      	bne.n	16bcc <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x2c>
    flags &= ~FLAGS_HASH;
   16bc4:	9b22      	ldr	r3, [sp, #136]	; 0x88
   16bc6:	f023 0310 	bic.w	r3, r3, #16
   16bca:	9322      	str	r3, [sp, #136]	; 0x88
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   16bcc:	9b22      	ldr	r3, [sp, #136]	; 0x88
   16bce:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   16bd2:	2b00      	cmp	r3, #0
   16bd4:	d003      	beq.n	16bde <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
   16bd6:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   16bda:	4323      	orrs	r3, r4
   16bdc:	d039      	beq.n	16c52 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
      const char digit = (char)(value % base);
   16bde:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   16be2:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   16be6:	f002 fa69 	bl	190bc <__aeabi_uldivmod>
   16bea:	461c      	mov	r4, r3
   16bec:	4613      	mov	r3, r2
   16bee:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   16bf2:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16bf6:	2b09      	cmp	r3, #9
   16bf8:	d804      	bhi.n	16c04 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x64>
   16bfa:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16bfe:	3330      	adds	r3, #48	; 0x30
   16c00:	b2da      	uxtb	r2, r3
   16c02:	e00d      	b.n	16c20 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x80>
   16c04:	9b22      	ldr	r3, [sp, #136]	; 0x88
   16c06:	f003 0320 	and.w	r3, r3, #32
   16c0a:	2b00      	cmp	r3, #0
   16c0c:	d001      	beq.n	16c12 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x72>
   16c0e:	2241      	movs	r2, #65	; 0x41
   16c10:	e000      	b.n	16c14 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x74>
   16c12:	2261      	movs	r2, #97	; 0x61
   16c14:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   16c18:	4413      	add	r3, r2
   16c1a:	b2db      	uxtb	r3, r3
   16c1c:	3b0a      	subs	r3, #10
   16c1e:	b2da      	uxtb	r2, r3
   16c20:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16c22:	1c59      	adds	r1, r3, #1
   16c24:	9115      	str	r1, [sp, #84]	; 0x54
   16c26:	a916      	add	r1, sp, #88	; 0x58
   16c28:	440b      	add	r3, r1
   16c2a:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   16c2e:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   16c32:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   16c36:	f002 fa41 	bl	190bc <__aeabi_uldivmod>
   16c3a:	4603      	mov	r3, r0
   16c3c:	460c      	mov	r4, r1
   16c3e:	e9cd 341a 	strd	r3, r4, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   16c42:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   16c46:	4323      	orrs	r3, r4
   16c48:	d003      	beq.n	16c52 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
   16c4a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16c4c:	2b1f      	cmp	r3, #31
   16c4e:	d800      	bhi.n	16c52 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
   16c50:	e7c5      	b.n	16bde <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   16c52:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16c54:	9a22      	ldr	r2, [sp, #136]	; 0x88
   16c56:	9206      	str	r2, [sp, #24]
   16c58:	9a21      	ldr	r2, [sp, #132]	; 0x84
   16c5a:	9205      	str	r2, [sp, #20]
   16c5c:	9a20      	ldr	r2, [sp, #128]	; 0x80
   16c5e:	9204      	str	r2, [sp, #16]
   16c60:	9303      	str	r3, [sp, #12]
   16c62:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
   16c66:	9302      	str	r3, [sp, #8]
   16c68:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16c6a:	9301      	str	r3, [sp, #4]
   16c6c:	ab0c      	add	r3, sp, #48	; 0x30
   16c6e:	9300      	str	r3, [sp, #0]
   16c70:	9b08      	ldr	r3, [sp, #32]
   16c72:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16c74:	990a      	ldr	r1, [sp, #40]	; 0x28
   16c76:	980b      	ldr	r0, [sp, #44]	; 0x2c
   16c78:	f7ff fdf2 	bl	16860 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   16c7c:	4604      	mov	r4, r0
   16c7e:	462b      	mov	r3, r5
   16c80:	4619      	mov	r1, r3
   16c82:	4803      	ldr	r0, [pc, #12]	; (16c90 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   16c84:	f7fe facc 	bl	15220 <__cyg_profile_func_exit>
   16c88:	4623      	mov	r3, r4
}
   16c8a:	4618      	mov	r0, r3
   16c8c:	b017      	add	sp, #92	; 0x5c
   16c8e:	bd30      	pop	{r4, r5, pc}
   16c90:	00016ba1 	.word	0x00016ba1

00016c94 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>:
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value_param, unsigned int prec, unsigned int width, unsigned int flags)
{
   16c94:	b530      	push	{r4, r5, lr}
   16c96:	b09b      	sub	sp, #108	; 0x6c
   16c98:	4675      	mov	r5, lr
   16c9a:	9005      	str	r0, [sp, #20]
   16c9c:	9104      	str	r1, [sp, #16]
   16c9e:	9203      	str	r2, [sp, #12]
   16ca0:	9302      	str	r3, [sp, #8]
   16ca2:	ed8d 0b00 	vstr	d0, [sp]
   16ca6:	462b      	mov	r3, r5
   16ca8:	4619      	mov	r1, r3
   16caa:	48b7      	ldr	r0, [pc, #732]	; (16f88 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f4>)
   16cac:	f7fe faa4 	bl	151f8 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   16cb0:	9b03      	ldr	r3, [sp, #12]
   16cb2:	9311      	str	r3, [sp, #68]	; 0x44

  float value = static_cast<float>(value_param);
   16cb4:	e9dd 0100 	ldrd	r0, r1, [sp]
   16cb8:	f002 f9b0 	bl	1901c <__aeabi_d2f>
   16cbc:	4603      	mov	r3, r0
   16cbe:	9319      	str	r3, [sp, #100]	; 0x64

  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
   16cc0:	2300      	movs	r3, #0
   16cc2:	9318      	str	r3, [sp, #96]	; 0x60
  float diff = 0.0;
   16cc4:	f04f 0300 	mov.w	r3, #0
   16cc8:	9310      	str	r3, [sp, #64]	; 0x40

  // if input is larger than thres_max, revert to exponential
  const float thres_max = (float)0x7FFFFFFF;
   16cca:	f04f 439e 	mov.w	r3, #1325400064	; 0x4f000000
   16cce:	930f      	str	r3, [sp, #60]	; 0x3c

  // powers of 10
  static const float pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for negative
  bool negative = false;
   16cd0:	2300      	movs	r3, #0
   16cd2:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
  if (value < 0) {
   16cd6:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   16cda:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   16cde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16ce2:	d50a      	bpl.n	16cfa <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x66>
    negative = true;
   16ce4:	2301      	movs	r3, #1
   16ce6:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    value = 0 - value;
   16cea:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 16f8c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f8>
   16cee:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   16cf2:	ee77 7a67 	vsub.f32	s15, s14, s15
   16cf6:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
  }

  // set default precision to 6, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
   16cfa:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16cfc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   16d00:	2b00      	cmp	r3, #0
   16d02:	d101      	bne.n	16d08 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
    prec = 6U;
   16d04:	2306      	movs	r3, #6
   16d06:	931e      	str	r3, [sp, #120]	; 0x78
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   16d08:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16d0a:	2b1f      	cmp	r3, #31
   16d0c:	d80e      	bhi.n	16d2c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
   16d0e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16d10:	2b09      	cmp	r3, #9
   16d12:	d90b      	bls.n	16d2c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
    buf[len++] = '0';
   16d14:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16d16:	1c5a      	adds	r2, r3, #1
   16d18:	9218      	str	r2, [sp, #96]	; 0x60
   16d1a:	aa1a      	add	r2, sp, #104	; 0x68
   16d1c:	4413      	add	r3, r2
   16d1e:	2230      	movs	r2, #48	; 0x30
   16d20:	f803 2c50 	strb.w	r2, [r3, #-80]
    prec--;
   16d24:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16d26:	3b01      	subs	r3, #1
   16d28:	931e      	str	r3, [sp, #120]	; 0x78
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   16d2a:	e7ed      	b.n	16d08 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
  }

  int whole = (int)value;
   16d2c:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   16d30:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   16d34:	ee17 3a90 	vmov	r3, s15
   16d38:	9316      	str	r3, [sp, #88]	; 0x58
  float tmp = (value - whole) * pow10[prec];
   16d3a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16d3c:	ee07 3a90 	vmov	s15, r3
   16d40:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   16d44:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   16d48:	ee37 7a67 	vsub.f32	s14, s14, s15
   16d4c:	4a90      	ldr	r2, [pc, #576]	; (16f90 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   16d4e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16d50:	009b      	lsls	r3, r3, #2
   16d52:	4413      	add	r3, r2
   16d54:	edd3 7a00 	vldr	s15, [r3]
   16d58:	ee67 7a27 	vmul.f32	s15, s14, s15
   16d5c:	edcd 7a0e 	vstr	s15, [sp, #56]	; 0x38
  unsigned long frac = (unsigned long)tmp;
   16d60:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   16d64:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   16d68:	ee17 3a90 	vmov	r3, s15
   16d6c:	9315      	str	r3, [sp, #84]	; 0x54
  diff = tmp - frac;
   16d6e:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16d70:	ee07 3a90 	vmov	s15, r3
   16d74:	eef8 7a67 	vcvt.f32.u32	s15, s15
   16d78:	ed9d 7a0e 	vldr	s14, [sp, #56]	; 0x38
   16d7c:	ee77 7a67 	vsub.f32	s15, s14, s15
   16d80:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40

  if (diff > 0.5) {
   16d84:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   16d88:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   16d8c:	eef4 7ac7 	vcmpe.f32	s15, s14
   16d90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16d94:	dd18      	ble.n	16dc8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x134>
    ++frac;
   16d96:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16d98:	3301      	adds	r3, #1
   16d9a:	9315      	str	r3, [sp, #84]	; 0x54
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
   16d9c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16d9e:	ee07 3a90 	vmov	s15, r3
   16da2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   16da6:	4a7a      	ldr	r2, [pc, #488]	; (16f90 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   16da8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16daa:	009b      	lsls	r3, r3, #2
   16dac:	4413      	add	r3, r2
   16dae:	edd3 7a00 	vldr	s15, [r3]
   16db2:	eeb4 7ae7 	vcmpe.f32	s14, s15
   16db6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16dba:	db19      	blt.n	16df0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
      frac = 0;
   16dbc:	2300      	movs	r3, #0
   16dbe:	9315      	str	r3, [sp, #84]	; 0x54
      ++whole;
   16dc0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16dc2:	3301      	adds	r3, #1
   16dc4:	9316      	str	r3, [sp, #88]	; 0x58
   16dc6:	e013      	b.n	16df0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    }
  }
  else if ((diff == 0.5) && ((frac == 0U) || (frac & 1U))) {
   16dc8:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   16dcc:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   16dd0:	eef4 7a47 	vcmp.f32	s15, s14
   16dd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16dd8:	d10a      	bne.n	16df0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
   16dda:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16ddc:	2b00      	cmp	r3, #0
   16dde:	d004      	beq.n	16dea <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
   16de0:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16de2:	f003 0301 	and.w	r3, r3, #1
   16de6:	2b00      	cmp	r3, #0
   16de8:	d002      	beq.n	16df0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    // if halfway, round up if odd, OR if last digit is 0
    ++frac;
   16dea:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16dec:	3301      	adds	r3, #1
   16dee:	9315      	str	r3, [sp, #84]	; 0x54
  }

  // TBD: for very large numbers switch back to native sprintf for exponentials. Anyone want to write code to replace this?
  // Normal printf behavior is to print EVERY whole number digit which can be 100s of characters overflowing your buffers == bad
  if (value > thres_max) {
   16df0:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   16df4:	ed9f 7a67 	vldr	s14, [pc, #412]	; 16f94 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>
   16df8:	eef4 7ac7 	vcmpe.f32	s15, s14
   16dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16e00:	dd01      	ble.n	16e06 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x172>
    return 0U;
   16e02:	2400      	movs	r4, #0
   16e04:	e156      	b.n	170b4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x420>
  }

  if (prec == 0U) {
   16e06:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16e08:	2b00      	cmp	r3, #0
   16e0a:	d129      	bne.n	16e60 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1cc>
    diff = value - (float)whole;
   16e0c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16e0e:	ee07 3a90 	vmov	s15, r3
   16e12:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   16e16:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   16e1a:	ee77 7a67 	vsub.f32	s15, s14, s15
   16e1e:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
    if (diff > 0.5) {
   16e22:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   16e26:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   16e2a:	eef4 7ac7 	vcmpe.f32	s15, s14
   16e2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16e32:	dd03      	ble.n	16e3c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1a8>
      // greater than 0.5, round up, e.g. 1.6 -> 2
      ++whole;
   16e34:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16e36:	3301      	adds	r3, #1
   16e38:	9316      	str	r3, [sp, #88]	; 0x58
   16e3a:	e05f      	b.n	16efc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
    else if ((diff == 0.5) && (whole & 1)) {
   16e3c:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   16e40:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   16e44:	eef4 7a47 	vcmp.f32	s15, s14
   16e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16e4c:	d156      	bne.n	16efc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
   16e4e:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16e50:	f003 0301 	and.w	r3, r3, #1
   16e54:	2b00      	cmp	r3, #0
   16e56:	d051      	beq.n	16efc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
   16e58:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16e5a:	3301      	adds	r3, #1
   16e5c:	9316      	str	r3, [sp, #88]	; 0x58
   16e5e:	e04d      	b.n	16efc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
  }
  else {
    unsigned int count = prec;
   16e60:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   16e62:	9314      	str	r3, [sp, #80]	; 0x50
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   16e64:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16e66:	2b1f      	cmp	r3, #31
   16e68:	d827      	bhi.n	16eba <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
      --count;
   16e6a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16e6c:	3b01      	subs	r3, #1
   16e6e:	9314      	str	r3, [sp, #80]	; 0x50
      buf[len++] = (char)(48U + (frac % 10U));
   16e70:	9915      	ldr	r1, [sp, #84]	; 0x54
   16e72:	4b49      	ldr	r3, [pc, #292]	; (16f98 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   16e74:	fba3 2301 	umull	r2, r3, r3, r1
   16e78:	08da      	lsrs	r2, r3, #3
   16e7a:	4613      	mov	r3, r2
   16e7c:	009b      	lsls	r3, r3, #2
   16e7e:	4413      	add	r3, r2
   16e80:	005b      	lsls	r3, r3, #1
   16e82:	1aca      	subs	r2, r1, r3
   16e84:	b2d3      	uxtb	r3, r2
   16e86:	3330      	adds	r3, #48	; 0x30
   16e88:	b2d9      	uxtb	r1, r3
   16e8a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16e8c:	1c5a      	adds	r2, r3, #1
   16e8e:	9218      	str	r2, [sp, #96]	; 0x60
   16e90:	aa1a      	add	r2, sp, #104	; 0x68
   16e92:	4413      	add	r3, r2
   16e94:	460a      	mov	r2, r1
   16e96:	f803 2c50 	strb.w	r2, [r3, #-80]
      if (!(frac /= 10U)) {
   16e9a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16e9c:	4a3e      	ldr	r2, [pc, #248]	; (16f98 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   16e9e:	fba2 2303 	umull	r2, r3, r2, r3
   16ea2:	08db      	lsrs	r3, r3, #3
   16ea4:	9315      	str	r3, [sp, #84]	; 0x54
   16ea6:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16ea8:	2b00      	cmp	r3, #0
   16eaa:	bf0c      	ite	eq
   16eac:	2301      	moveq	r3, #1
   16eae:	2300      	movne	r3, #0
   16eb0:	b2db      	uxtb	r3, r3
   16eb2:	2b00      	cmp	r3, #0
   16eb4:	d100      	bne.n	16eb8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x224>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   16eb6:	e7d5      	b.n	16e64 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1d0>
        break;
   16eb8:	bf00      	nop
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   16eba:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16ebc:	2b1f      	cmp	r3, #31
   16ebe:	d806      	bhi.n	16ece <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   16ec0:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16ec2:	1e5a      	subs	r2, r3, #1
   16ec4:	9214      	str	r2, [sp, #80]	; 0x50
   16ec6:	2b00      	cmp	r3, #0
   16ec8:	d001      	beq.n	16ece <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   16eca:	2301      	movs	r3, #1
   16ecc:	e000      	b.n	16ed0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23c>
   16ece:	2300      	movs	r3, #0
   16ed0:	2b00      	cmp	r3, #0
   16ed2:	d008      	beq.n	16ee6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x252>
      buf[len++] = '0';
   16ed4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16ed6:	1c5a      	adds	r2, r3, #1
   16ed8:	9218      	str	r2, [sp, #96]	; 0x60
   16eda:	aa1a      	add	r2, sp, #104	; 0x68
   16edc:	4413      	add	r3, r2
   16ede:	2230      	movs	r2, #48	; 0x30
   16ee0:	f803 2c50 	strb.w	r2, [r3, #-80]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   16ee4:	e7e9      	b.n	16eba <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
   16ee6:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16ee8:	2b1f      	cmp	r3, #31
   16eea:	d807      	bhi.n	16efc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // add decimal
      buf[len++] = '.';
   16eec:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16eee:	1c5a      	adds	r2, r3, #1
   16ef0:	9218      	str	r2, [sp, #96]	; 0x60
   16ef2:	aa1a      	add	r2, sp, #104	; 0x68
   16ef4:	4413      	add	r3, r2
   16ef6:	222e      	movs	r2, #46	; 0x2e
   16ef8:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   16efc:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16efe:	2b1f      	cmp	r3, #31
   16f00:	d828      	bhi.n	16f54 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
    buf[len++] = (char)(48 + (whole % 10));
   16f02:	9a16      	ldr	r2, [sp, #88]	; 0x58
   16f04:	4b25      	ldr	r3, [pc, #148]	; (16f9c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   16f06:	fb83 1302 	smull	r1, r3, r3, r2
   16f0a:	1099      	asrs	r1, r3, #2
   16f0c:	17d3      	asrs	r3, r2, #31
   16f0e:	1ac9      	subs	r1, r1, r3
   16f10:	460b      	mov	r3, r1
   16f12:	009b      	lsls	r3, r3, #2
   16f14:	440b      	add	r3, r1
   16f16:	005b      	lsls	r3, r3, #1
   16f18:	1ad1      	subs	r1, r2, r3
   16f1a:	b2cb      	uxtb	r3, r1
   16f1c:	3330      	adds	r3, #48	; 0x30
   16f1e:	b2d9      	uxtb	r1, r3
   16f20:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16f22:	1c5a      	adds	r2, r3, #1
   16f24:	9218      	str	r2, [sp, #96]	; 0x60
   16f26:	aa1a      	add	r2, sp, #104	; 0x68
   16f28:	4413      	add	r3, r2
   16f2a:	460a      	mov	r2, r1
   16f2c:	f803 2c50 	strb.w	r2, [r3, #-80]
    if (!(whole /= 10)) {
   16f30:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16f32:	4a1a      	ldr	r2, [pc, #104]	; (16f9c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   16f34:	fb82 1203 	smull	r1, r2, r2, r3
   16f38:	1092      	asrs	r2, r2, #2
   16f3a:	17db      	asrs	r3, r3, #31
   16f3c:	1ad3      	subs	r3, r2, r3
   16f3e:	9316      	str	r3, [sp, #88]	; 0x58
   16f40:	9b16      	ldr	r3, [sp, #88]	; 0x58
   16f42:	2b00      	cmp	r3, #0
   16f44:	bf0c      	ite	eq
   16f46:	2301      	moveq	r3, #1
   16f48:	2300      	movne	r3, #0
   16f4a:	b2db      	uxtb	r3, r3
   16f4c:	2b00      	cmp	r3, #0
   16f4e:	d100      	bne.n	16f52 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2be>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   16f50:	e7d4      	b.n	16efc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      break;
   16f52:	bf00      	nop
    }
  }

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   16f54:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16f56:	f003 0302 	and.w	r3, r3, #2
   16f5a:	2b00      	cmp	r3, #0
   16f5c:	d120      	bne.n	16fa0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   16f5e:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16f60:	f003 0301 	and.w	r3, r3, #1
   16f64:	2b00      	cmp	r3, #0
   16f66:	d01b      	beq.n	16fa0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   16f68:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16f6a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16f6c:	429a      	cmp	r2, r3
   16f6e:	d217      	bcs.n	16fa0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   16f70:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16f72:	2b1f      	cmp	r3, #31
   16f74:	d814      	bhi.n	16fa0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
    buf[len++] = '0';
   16f76:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16f78:	1c5a      	adds	r2, r3, #1
   16f7a:	9218      	str	r2, [sp, #96]	; 0x60
   16f7c:	aa1a      	add	r2, sp, #104	; 0x68
   16f7e:	4413      	add	r3, r2
   16f80:	2230      	movs	r2, #48	; 0x30
   16f82:	f803 2c50 	strb.w	r2, [r3, #-80]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   16f86:	e7e5      	b.n	16f54 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
   16f88:	00016c95 	.word	0x00016c95
   16f8c:	00000000 	.word	0x00000000
   16f90:	0001b134 	.word	0x0001b134
   16f94:	4f000000 	.word	0x4f000000
   16f98:	cccccccd 	.word	0xcccccccd
   16f9c:	66666667 	.word	0x66666667
  }

  // handle sign
  if ((len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   16fa0:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16fa2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16fa4:	429a      	cmp	r2, r3
   16fa6:	d110      	bne.n	16fca <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
   16fa8:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   16fac:	2b00      	cmp	r3, #0
   16fae:	d109      	bne.n	16fc4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   16fb0:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16fb2:	f003 0304 	and.w	r3, r3, #4
   16fb6:	2b00      	cmp	r3, #0
   16fb8:	d104      	bne.n	16fc4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   16fba:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16fbc:	f003 0308 	and.w	r3, r3, #8
   16fc0:	2b00      	cmp	r3, #0
   16fc2:	d002      	beq.n	16fca <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
    len--;
   16fc4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16fc6:	3b01      	subs	r3, #1
   16fc8:	9318      	str	r3, [sp, #96]	; 0x60
  }
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
   16fca:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16fcc:	2b1f      	cmp	r3, #31
   16fce:	d827      	bhi.n	17020 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    if (negative) {
   16fd0:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   16fd4:	2b00      	cmp	r3, #0
   16fd6:	d008      	beq.n	16fea <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x356>
      buf[len++] = '-';
   16fd8:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16fda:	1c5a      	adds	r2, r3, #1
   16fdc:	9218      	str	r2, [sp, #96]	; 0x60
   16fde:	aa1a      	add	r2, sp, #104	; 0x68
   16fe0:	4413      	add	r3, r2
   16fe2:	222d      	movs	r2, #45	; 0x2d
   16fe4:	f803 2c50 	strb.w	r2, [r3, #-80]
   16fe8:	e01a      	b.n	17020 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_PLUS) {
   16fea:	9b20      	ldr	r3, [sp, #128]	; 0x80
   16fec:	f003 0304 	and.w	r3, r3, #4
   16ff0:	2b00      	cmp	r3, #0
   16ff2:	d008      	beq.n	17006 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x372>
      buf[len++] = '+';  // ignore the space if the '+' exists
   16ff4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16ff6:	1c5a      	adds	r2, r3, #1
   16ff8:	9218      	str	r2, [sp, #96]	; 0x60
   16ffa:	aa1a      	add	r2, sp, #104	; 0x68
   16ffc:	4413      	add	r3, r2
   16ffe:	222b      	movs	r2, #43	; 0x2b
   17000:	f803 2c50 	strb.w	r2, [r3, #-80]
   17004:	e00c      	b.n	17020 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_SPACE) {
   17006:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17008:	f003 0308 	and.w	r3, r3, #8
   1700c:	2b00      	cmp	r3, #0
   1700e:	d007      	beq.n	17020 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
      buf[len++] = ' ';
   17010:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17012:	1c5a      	adds	r2, r3, #1
   17014:	9218      	str	r2, [sp, #96]	; 0x60
   17016:	aa1a      	add	r2, sp, #104	; 0x68
   17018:	4413      	add	r3, r2
   1701a:	2220      	movs	r2, #32
   1701c:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   17020:	9b20      	ldr	r3, [sp, #128]	; 0x80
   17022:	f003 0302 	and.w	r3, r3, #2
   17026:	2b00      	cmp	r3, #0
   17028:	d116      	bne.n	17058 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
   1702a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1702c:	f003 0301 	and.w	r3, r3, #1
   17030:	2b00      	cmp	r3, #0
   17032:	d111      	bne.n	17058 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
    for (size_t i = len; i < width; i++) {
   17034:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17036:	9313      	str	r3, [sp, #76]	; 0x4c
   17038:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1703a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1703c:	429a      	cmp	r2, r3
   1703e:	d20b      	bcs.n	17058 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
      out(' ', buffer, idx++, maxlen);
   17040:	9a03      	ldr	r2, [sp, #12]
   17042:	1c53      	adds	r3, r2, #1
   17044:	9303      	str	r3, [sp, #12]
   17046:	9c05      	ldr	r4, [sp, #20]
   17048:	9b02      	ldr	r3, [sp, #8]
   1704a:	9904      	ldr	r1, [sp, #16]
   1704c:	2020      	movs	r0, #32
   1704e:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   17050:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17052:	3301      	adds	r3, #1
   17054:	9313      	str	r3, [sp, #76]	; 0x4c
   17056:	e7ef      	b.n	17038 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3a4>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   17058:	2300      	movs	r3, #0
   1705a:	9312      	str	r3, [sp, #72]	; 0x48
   1705c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1705e:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17060:	429a      	cmp	r2, r3
   17062:	d212      	bcs.n	1708a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3f6>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   17064:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17066:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17068:	1ad3      	subs	r3, r2, r3
   1706a:	3b01      	subs	r3, #1
   1706c:	aa1a      	add	r2, sp, #104	; 0x68
   1706e:	4413      	add	r3, r2
   17070:	f813 0c50 	ldrb.w	r0, [r3, #-80]
   17074:	9a03      	ldr	r2, [sp, #12]
   17076:	1c53      	adds	r3, r2, #1
   17078:	9303      	str	r3, [sp, #12]
   1707a:	9c05      	ldr	r4, [sp, #20]
   1707c:	9b02      	ldr	r3, [sp, #8]
   1707e:	9904      	ldr	r1, [sp, #16]
   17080:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   17082:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17084:	3301      	adds	r3, #1
   17086:	9312      	str	r3, [sp, #72]	; 0x48
   17088:	e7e8      	b.n	1705c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c8>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   1708a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1708c:	f003 0302 	and.w	r3, r3, #2
   17090:	2b00      	cmp	r3, #0
   17092:	d00e      	beq.n	170b2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
    while (idx - start_idx < width) {
   17094:	9a03      	ldr	r2, [sp, #12]
   17096:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17098:	1ad3      	subs	r3, r2, r3
   1709a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   1709c:	429a      	cmp	r2, r3
   1709e:	d908      	bls.n	170b2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
      out(' ', buffer, idx++, maxlen);
   170a0:	9a03      	ldr	r2, [sp, #12]
   170a2:	1c53      	adds	r3, r2, #1
   170a4:	9303      	str	r3, [sp, #12]
   170a6:	9c05      	ldr	r4, [sp, #20]
   170a8:	9b02      	ldr	r3, [sp, #8]
   170aa:	9904      	ldr	r1, [sp, #16]
   170ac:	2020      	movs	r0, #32
   170ae:	47a0      	blx	r4
    while (idx - start_idx < width) {
   170b0:	e7f0      	b.n	17094 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x400>
    }
  }

  return idx;
   170b2:	9c03      	ldr	r4, [sp, #12]
   170b4:	462b      	mov	r3, r5
   170b6:	4619      	mov	r1, r3
   170b8:	4803      	ldr	r0, [pc, #12]	; (170c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x434>)
   170ba:	f7fe f8b1 	bl	15220 <__cyg_profile_func_exit>
   170be:	4623      	mov	r3, r4
}
   170c0:	4618      	mov	r0, r3
   170c2:	b01b      	add	sp, #108	; 0x6c
   170c4:	bd30      	pop	{r4, r5, pc}
   170c6:	bf00      	nop
   170c8:	00016c95 	.word	0x00016c95

000170cc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
   170cc:	b570      	push	{r4, r5, r6, lr}
   170ce:	b0a0      	sub	sp, #128	; 0x80
   170d0:	4676      	mov	r6, lr
   170d2:	900d      	str	r0, [sp, #52]	; 0x34
   170d4:	910c      	str	r1, [sp, #48]	; 0x30
   170d6:	920b      	str	r2, [sp, #44]	; 0x2c
   170d8:	930a      	str	r3, [sp, #40]	; 0x28
   170da:	4633      	mov	r3, r6
   170dc:	4619      	mov	r1, r3
   170de:	48a7      	ldr	r0, [pc, #668]	; (1737c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b0>)
   170e0:	f7fe f88a 	bl	151f8 <__cyg_profile_func_enter>
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
   170e4:	2300      	movs	r3, #0
   170e6:	931b      	str	r3, [sp, #108]	; 0x6c

  if (!buffer) {
   170e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   170ea:	2b00      	cmp	r3, #0
   170ec:	d101      	bne.n	170f2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    // use null output function
    out = _out_null;
   170ee:	4ba4      	ldr	r3, [pc, #656]	; (17380 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b4>)
   170f0:	930d      	str	r3, [sp, #52]	; 0x34
  }

  while (*format)
   170f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   170f4:	781b      	ldrb	r3, [r3, #0]
   170f6:	2b00      	cmp	r3, #0
   170f8:	f000 8448 	beq.w	1798c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8c0>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
   170fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   170fe:	781b      	ldrb	r3, [r3, #0]
   17100:	2b25      	cmp	r3, #37	; 0x25
   17102:	d00d      	beq.n	17120 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x54>
      // no
      out(*format, buffer, idx++, maxlen);
   17104:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17106:	7818      	ldrb	r0, [r3, #0]
   17108:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1710a:	1c53      	adds	r3, r2, #1
   1710c:	931b      	str	r3, [sp, #108]	; 0x6c
   1710e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17110:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17112:	990c      	ldr	r1, [sp, #48]	; 0x30
   17114:	47a0      	blx	r4
      format++;
   17116:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17118:	3301      	adds	r3, #1
   1711a:	930a      	str	r3, [sp, #40]	; 0x28
      continue;
   1711c:	f000 bc34 	b.w	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
    }
    else {
      // yes, evaluate it
      format++;
   17120:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17122:	3301      	adds	r3, #1
   17124:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate flags
    flags = 0U;
   17126:	2300      	movs	r3, #0
   17128:	931f      	str	r3, [sp, #124]	; 0x7c
    do {
      switch (*format) {
   1712a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1712c:	781b      	ldrb	r3, [r3, #0]
   1712e:	3b20      	subs	r3, #32
   17130:	2b10      	cmp	r3, #16
   17132:	d857      	bhi.n	171e4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x118>
   17134:	a201      	add	r2, pc, #4	; (adr r2, 1713c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70>)
   17136:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1713a:	bf00      	nop
   1713c:	000171bd 	.word	0x000171bd
   17140:	000171e5 	.word	0x000171e5
   17144:	000171e5 	.word	0x000171e5
   17148:	000171d1 	.word	0x000171d1
   1714c:	000171e5 	.word	0x000171e5
   17150:	000171e5 	.word	0x000171e5
   17154:	000171e5 	.word	0x000171e5
   17158:	000171e5 	.word	0x000171e5
   1715c:	000171e5 	.word	0x000171e5
   17160:	000171e5 	.word	0x000171e5
   17164:	000171e5 	.word	0x000171e5
   17168:	000171a9 	.word	0x000171a9
   1716c:	000171e5 	.word	0x000171e5
   17170:	00017195 	.word	0x00017195
   17174:	000171e5 	.word	0x000171e5
   17178:	000171e5 	.word	0x000171e5
   1717c:	00017181 	.word	0x00017181
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   17180:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17182:	f043 0301 	orr.w	r3, r3, #1
   17186:	931f      	str	r3, [sp, #124]	; 0x7c
   17188:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1718a:	3301      	adds	r3, #1
   1718c:	930a      	str	r3, [sp, #40]	; 0x28
   1718e:	2301      	movs	r3, #1
   17190:	931c      	str	r3, [sp, #112]	; 0x70
   17192:	e02a      	b.n	171ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   17194:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17196:	f043 0302 	orr.w	r3, r3, #2
   1719a:	931f      	str	r3, [sp, #124]	; 0x7c
   1719c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1719e:	3301      	adds	r3, #1
   171a0:	930a      	str	r3, [sp, #40]	; 0x28
   171a2:	2301      	movs	r3, #1
   171a4:	931c      	str	r3, [sp, #112]	; 0x70
   171a6:	e020      	b.n	171ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   171a8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   171aa:	f043 0304 	orr.w	r3, r3, #4
   171ae:	931f      	str	r3, [sp, #124]	; 0x7c
   171b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   171b2:	3301      	adds	r3, #1
   171b4:	930a      	str	r3, [sp, #40]	; 0x28
   171b6:	2301      	movs	r3, #1
   171b8:	931c      	str	r3, [sp, #112]	; 0x70
   171ba:	e016      	b.n	171ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   171bc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   171be:	f043 0308 	orr.w	r3, r3, #8
   171c2:	931f      	str	r3, [sp, #124]	; 0x7c
   171c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   171c6:	3301      	adds	r3, #1
   171c8:	930a      	str	r3, [sp, #40]	; 0x28
   171ca:	2301      	movs	r3, #1
   171cc:	931c      	str	r3, [sp, #112]	; 0x70
   171ce:	e00c      	b.n	171ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   171d0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   171d2:	f043 0310 	orr.w	r3, r3, #16
   171d6:	931f      	str	r3, [sp, #124]	; 0x7c
   171d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   171da:	3301      	adds	r3, #1
   171dc:	930a      	str	r3, [sp, #40]	; 0x28
   171de:	2301      	movs	r3, #1
   171e0:	931c      	str	r3, [sp, #112]	; 0x70
   171e2:	e002      	b.n	171ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        default :                                   n = 0U; break;
   171e4:	2300      	movs	r3, #0
   171e6:	931c      	str	r3, [sp, #112]	; 0x70
   171e8:	bf00      	nop
      }
    } while (n);
   171ea:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   171ec:	2b00      	cmp	r3, #0
   171ee:	d000      	beq.n	171f2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x126>
    do {
   171f0:	e79b      	b.n	1712a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5e>

    // evaluate width field
    width = 0U;
   171f2:	2300      	movs	r3, #0
   171f4:	931e      	str	r3, [sp, #120]	; 0x78
    if (_is_digit(*format)) {
   171f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   171f8:	781b      	ldrb	r3, [r3, #0]
   171fa:	4618      	mov	r0, r3
   171fc:	f7ff fade 	bl	167bc <_is_digit(char)>
   17200:	4603      	mov	r3, r0
   17202:	2b00      	cmp	r3, #0
   17204:	d005      	beq.n	17212 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x146>
      width = _atoi(&format);
   17206:	ab0a      	add	r3, sp, #40	; 0x28
   17208:	4618      	mov	r0, r3
   1720a:	f7ff faf9 	bl	16800 <_atoi(char const**)>
   1720e:	901e      	str	r0, [sp, #120]	; 0x78
   17210:	e018      	b.n	17244 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
    }
    else if (*format == '*') {
   17212:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17214:	781b      	ldrb	r3, [r3, #0]
   17216:	2b2a      	cmp	r3, #42	; 0x2a
   17218:	d114      	bne.n	17244 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
      const int w = va_arg(va, int);
   1721a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1721c:	1d1a      	adds	r2, r3, #4
   1721e:	9224      	str	r2, [sp, #144]	; 0x90
   17220:	681b      	ldr	r3, [r3, #0]
   17222:	9316      	str	r3, [sp, #88]	; 0x58
      if (w < 0) {
   17224:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17226:	2b00      	cmp	r3, #0
   17228:	da07      	bge.n	1723a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16e>
        flags |= FLAGS_LEFT;    // reverse padding
   1722a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1722c:	f043 0302 	orr.w	r3, r3, #2
   17230:	931f      	str	r3, [sp, #124]	; 0x7c
        width = (unsigned int)-w;
   17232:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17234:	425b      	negs	r3, r3
   17236:	931e      	str	r3, [sp, #120]	; 0x78
   17238:	e001      	b.n	1723e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x172>
      }
      else {
        width = (unsigned int)w;
   1723a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1723c:	931e      	str	r3, [sp, #120]	; 0x78
      }
      format++;
   1723e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17240:	3301      	adds	r3, #1
   17242:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate precision field
    precision = 0U;
   17244:	2300      	movs	r3, #0
   17246:	931d      	str	r3, [sp, #116]	; 0x74
    if (*format == '.') {
   17248:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1724a:	781b      	ldrb	r3, [r3, #0]
   1724c:	2b2e      	cmp	r3, #46	; 0x2e
   1724e:	d124      	bne.n	1729a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      flags |= FLAGS_PRECISION;
   17250:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17252:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   17256:	931f      	str	r3, [sp, #124]	; 0x7c
      format++;
   17258:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1725a:	3301      	adds	r3, #1
   1725c:	930a      	str	r3, [sp, #40]	; 0x28
      if (_is_digit(*format)) {
   1725e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17260:	781b      	ldrb	r3, [r3, #0]
   17262:	4618      	mov	r0, r3
   17264:	f7ff faaa 	bl	167bc <_is_digit(char)>
   17268:	4603      	mov	r3, r0
   1726a:	2b00      	cmp	r3, #0
   1726c:	d005      	beq.n	1727a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ae>
        precision = _atoi(&format);
   1726e:	ab0a      	add	r3, sp, #40	; 0x28
   17270:	4618      	mov	r0, r3
   17272:	f7ff fac5 	bl	16800 <_atoi(char const**)>
   17276:	901d      	str	r0, [sp, #116]	; 0x74
   17278:	e00f      	b.n	1729a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      }
      else if (*format == '*') {
   1727a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1727c:	781b      	ldrb	r3, [r3, #0]
   1727e:	2b2a      	cmp	r3, #42	; 0x2a
   17280:	d10b      	bne.n	1729a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
        const int prec = (int)va_arg(va, int);
   17282:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17284:	1d1a      	adds	r2, r3, #4
   17286:	9224      	str	r2, [sp, #144]	; 0x90
   17288:	681b      	ldr	r3, [r3, #0]
   1728a:	9315      	str	r3, [sp, #84]	; 0x54
        precision = prec > 0 ? (unsigned int)prec : 0U;
   1728c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1728e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   17292:	931d      	str	r3, [sp, #116]	; 0x74
        format++;
   17294:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17296:	3301      	adds	r3, #1
   17298:	930a      	str	r3, [sp, #40]	; 0x28
      }
    }

    // evaluate length field
    switch (*format) {
   1729a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1729c:	781b      	ldrb	r3, [r3, #0]
   1729e:	3b68      	subs	r3, #104	; 0x68
   172a0:	2b12      	cmp	r3, #18
   172a2:	d867      	bhi.n	17374 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
   172a4:	a201      	add	r2, pc, #4	; (adr r2, 172ac <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1e0>)
   172a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   172aa:	bf00      	nop
   172ac:	0001731f 	.word	0x0001731f
   172b0:	00017375 	.word	0x00017375
   172b4:	00017355 	.word	0x00017355
   172b8:	00017375 	.word	0x00017375
   172bc:	000172f9 	.word	0x000172f9
   172c0:	00017375 	.word	0x00017375
   172c4:	00017375 	.word	0x00017375
   172c8:	00017375 	.word	0x00017375
   172cc:	00017375 	.word	0x00017375
   172d0:	00017375 	.word	0x00017375
   172d4:	00017375 	.word	0x00017375
   172d8:	00017375 	.word	0x00017375
   172dc:	00017345 	.word	0x00017345
   172e0:	00017375 	.word	0x00017375
   172e4:	00017375 	.word	0x00017375
   172e8:	00017375 	.word	0x00017375
   172ec:	00017375 	.word	0x00017375
   172f0:	00017375 	.word	0x00017375
   172f4:	00017365 	.word	0x00017365
      case 'l' :
        flags |= FLAGS_LONG;
   172f8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   172fa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   172fe:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   17300:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17302:	3301      	adds	r3, #1
   17304:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'l') {
   17306:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17308:	781b      	ldrb	r3, [r3, #0]
   1730a:	2b6c      	cmp	r3, #108	; 0x6c
   1730c:	d134      	bne.n	17378 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
          flags |= FLAGS_LONG_LONG;
   1730e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17310:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   17314:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   17316:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17318:	3301      	adds	r3, #1
   1731a:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   1731c:	e02c      	b.n	17378 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
      case 'h' :
        flags |= FLAGS_SHORT;
   1731e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17320:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   17324:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   17326:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17328:	3301      	adds	r3, #1
   1732a:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'h') {
   1732c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1732e:	781b      	ldrb	r3, [r3, #0]
   17330:	2b68      	cmp	r3, #104	; 0x68
   17332:	d127      	bne.n	17384 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
          flags |= FLAGS_CHAR;
   17334:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17336:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1733a:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   1733c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1733e:	3301      	adds	r3, #1
   17340:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   17342:	e01f      	b.n	17384 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   17344:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17346:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1734a:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   1734c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1734e:	3301      	adds	r3, #1
   17350:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17352:	e018      	b.n	17386 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   17354:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17356:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   1735a:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   1735c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1735e:	3301      	adds	r3, #1
   17360:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17362:	e010      	b.n	17386 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   17364:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17366:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1736a:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   1736c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1736e:	3301      	adds	r3, #1
   17370:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17372:	e008      	b.n	17386 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      default :
        break;
   17374:	bf00      	nop
   17376:	e006      	b.n	17386 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
        break;
   17378:	bf00      	nop
   1737a:	e004      	b.n	17386 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
   1737c:	000170cd 	.word	0x000170cd
   17380:	00016705 	.word	0x00016705
        break;
   17384:	bf00      	nop
    }

    // evaluate specifier
    switch (*format) {
   17386:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17388:	781b      	ldrb	r3, [r3, #0]
   1738a:	3b25      	subs	r3, #37	; 0x25
   1738c:	2b53      	cmp	r3, #83	; 0x53
   1738e:	f200 82ee 	bhi.w	1796e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8a2>
   17392:	a201      	add	r2, pc, #4	; (adr r2, 17398 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2cc>)
   17394:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   17398:	00017957 	.word	0x00017957
   1739c:	0001796f 	.word	0x0001796f
   173a0:	0001796f 	.word	0x0001796f
   173a4:	0001796f 	.word	0x0001796f
   173a8:	0001796f 	.word	0x0001796f
   173ac:	0001796f 	.word	0x0001796f
   173b0:	0001796f 	.word	0x0001796f
   173b4:	0001796f 	.word	0x0001796f
   173b8:	0001796f 	.word	0x0001796f
   173bc:	0001796f 	.word	0x0001796f
   173c0:	0001796f 	.word	0x0001796f
   173c4:	0001796f 	.word	0x0001796f
   173c8:	0001796f 	.word	0x0001796f
   173cc:	0001796f 	.word	0x0001796f
   173d0:	0001796f 	.word	0x0001796f
   173d4:	0001796f 	.word	0x0001796f
   173d8:	0001796f 	.word	0x0001796f
   173dc:	0001796f 	.word	0x0001796f
   173e0:	0001796f 	.word	0x0001796f
   173e4:	0001796f 	.word	0x0001796f
   173e8:	0001796f 	.word	0x0001796f
   173ec:	0001796f 	.word	0x0001796f
   173f0:	0001796f 	.word	0x0001796f
   173f4:	0001796f 	.word	0x0001796f
   173f8:	0001796f 	.word	0x0001796f
   173fc:	0001796f 	.word	0x0001796f
   17400:	0001796f 	.word	0x0001796f
   17404:	0001796f 	.word	0x0001796f
   17408:	0001796f 	.word	0x0001796f
   1740c:	0001796f 	.word	0x0001796f
   17410:	0001796f 	.word	0x0001796f
   17414:	0001796f 	.word	0x0001796f
   17418:	0001796f 	.word	0x0001796f
   1741c:	00017775 	.word	0x00017775
   17420:	0001796f 	.word	0x0001796f
   17424:	0001796f 	.word	0x0001796f
   17428:	0001796f 	.word	0x0001796f
   1742c:	0001796f 	.word	0x0001796f
   17430:	0001796f 	.word	0x0001796f
   17434:	0001796f 	.word	0x0001796f
   17438:	0001796f 	.word	0x0001796f
   1743c:	0001796f 	.word	0x0001796f
   17440:	0001796f 	.word	0x0001796f
   17444:	0001796f 	.word	0x0001796f
   17448:	0001796f 	.word	0x0001796f
   1744c:	0001796f 	.word	0x0001796f
   17450:	0001796f 	.word	0x0001796f
   17454:	0001796f 	.word	0x0001796f
   17458:	0001796f 	.word	0x0001796f
   1745c:	0001796f 	.word	0x0001796f
   17460:	0001796f 	.word	0x0001796f
   17464:	000174e9 	.word	0x000174e9
   17468:	0001796f 	.word	0x0001796f
   1746c:	0001796f 	.word	0x0001796f
   17470:	0001796f 	.word	0x0001796f
   17474:	0001796f 	.word	0x0001796f
   17478:	0001796f 	.word	0x0001796f
   1747c:	0001796f 	.word	0x0001796f
   17480:	0001796f 	.word	0x0001796f
   17484:	0001796f 	.word	0x0001796f
   17488:	0001796f 	.word	0x0001796f
   1748c:	000174e9 	.word	0x000174e9
   17490:	000177b1 	.word	0x000177b1
   17494:	000174e9 	.word	0x000174e9
   17498:	0001796f 	.word	0x0001796f
   1749c:	00017775 	.word	0x00017775
   174a0:	0001796f 	.word	0x0001796f
   174a4:	0001796f 	.word	0x0001796f
   174a8:	000174e9 	.word	0x000174e9
   174ac:	0001796f 	.word	0x0001796f
   174b0:	0001796f 	.word	0x0001796f
   174b4:	0001796f 	.word	0x0001796f
   174b8:	0001796f 	.word	0x0001796f
   174bc:	0001796f 	.word	0x0001796f
   174c0:	000174e9 	.word	0x000174e9
   174c4:	0001790f 	.word	0x0001790f
   174c8:	0001796f 	.word	0x0001796f
   174cc:	0001796f 	.word	0x0001796f
   174d0:	00017839 	.word	0x00017839
   174d4:	0001796f 	.word	0x0001796f
   174d8:	000174e9 	.word	0x000174e9
   174dc:	0001796f 	.word	0x0001796f
   174e0:	0001796f 	.word	0x0001796f
   174e4:	000174e9 	.word	0x000174e9
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
   174e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   174ea:	781b      	ldrb	r3, [r3, #0]
   174ec:	2b78      	cmp	r3, #120	; 0x78
   174ee:	d003      	beq.n	174f8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x42c>
   174f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   174f2:	781b      	ldrb	r3, [r3, #0]
   174f4:	2b58      	cmp	r3, #88	; 0x58
   174f6:	d102      	bne.n	174fe <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x432>
          base = 16U;
   174f8:	2310      	movs	r3, #16
   174fa:	931a      	str	r3, [sp, #104]	; 0x68
   174fc:	e013      	b.n	17526 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'o') {
   174fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17500:	781b      	ldrb	r3, [r3, #0]
   17502:	2b6f      	cmp	r3, #111	; 0x6f
   17504:	d102      	bne.n	1750c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x440>
          base =  8U;
   17506:	2308      	movs	r3, #8
   17508:	931a      	str	r3, [sp, #104]	; 0x68
   1750a:	e00c      	b.n	17526 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'b') {
   1750c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1750e:	781b      	ldrb	r3, [r3, #0]
   17510:	2b62      	cmp	r3, #98	; 0x62
   17512:	d102      	bne.n	1751a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44e>
          base =  2U;
   17514:	2302      	movs	r3, #2
   17516:	931a      	str	r3, [sp, #104]	; 0x68
   17518:	e005      	b.n	17526 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else {
          base = 10U;
   1751a:	230a      	movs	r3, #10
   1751c:	931a      	str	r3, [sp, #104]	; 0x68
          flags &= ~FLAGS_HASH;   // no hash for dec format
   1751e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17520:	f023 0310 	bic.w	r3, r3, #16
   17524:	931f      	str	r3, [sp, #124]	; 0x7c
        }
        // uppercase
        if (*format == 'X') {
   17526:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17528:	781b      	ldrb	r3, [r3, #0]
   1752a:	2b58      	cmp	r3, #88	; 0x58
   1752c:	d103      	bne.n	17536 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x46a>
          flags |= FLAGS_UPPERCASE;
   1752e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17530:	f043 0320 	orr.w	r3, r3, #32
   17534:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
   17536:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17538:	781b      	ldrb	r3, [r3, #0]
   1753a:	2b69      	cmp	r3, #105	; 0x69
   1753c:	d007      	beq.n	1754e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
   1753e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17540:	781b      	ldrb	r3, [r3, #0]
   17542:	2b64      	cmp	r3, #100	; 0x64
   17544:	d003      	beq.n	1754e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   17546:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17548:	f023 030c 	bic.w	r3, r3, #12
   1754c:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
   1754e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17550:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17554:	2b00      	cmp	r3, #0
   17556:	d003      	beq.n	17560 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x494>
          flags &= ~FLAGS_ZEROPAD;
   17558:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1755a:	f023 0301 	bic.w	r3, r3, #1
   1755e:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
   17560:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17562:	781b      	ldrb	r3, [r3, #0]
   17564:	2b69      	cmp	r3, #105	; 0x69
   17566:	d004      	beq.n	17572 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4a6>
   17568:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1756a:	781b      	ldrb	r3, [r3, #0]
   1756c:	2b64      	cmp	r3, #100	; 0x64
   1756e:	f040 808d 	bne.w	1768c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5c0>
          // signed
          if (flags & FLAGS_LONG_LONG) {
   17572:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17574:	f403 7300 	and.w	r3, r3, #512	; 0x200
   17578:	2b00      	cmp	r3, #0
   1757a:	d02e      	beq.n	175da <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x50e>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
   1757c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1757e:	3307      	adds	r3, #7
   17580:	f023 0307 	bic.w	r3, r3, #7
   17584:	f103 0208 	add.w	r2, r3, #8
   17588:	9224      	str	r2, [sp, #144]	; 0x90
   1758a:	e9d3 3400 	ldrd	r3, r4, [r3]
   1758e:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   17592:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   17596:	2b00      	cmp	r3, #0
   17598:	f174 0200 	sbcs.w	r2, r4, #0
   1759c:	da02      	bge.n	175a4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4d8>
   1759e:	425b      	negs	r3, r3
   175a0:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
   175a4:	4619      	mov	r1, r3
   175a6:	4622      	mov	r2, r4
   175a8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   175aa:	0fdb      	lsrs	r3, r3, #31
   175ac:	b2d8      	uxtb	r0, r3
   175ae:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   175b0:	f04f 0400 	mov.w	r4, #0
   175b4:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
   175b6:	9508      	str	r5, [sp, #32]
   175b8:	9d1e      	ldr	r5, [sp, #120]	; 0x78
   175ba:	9507      	str	r5, [sp, #28]
   175bc:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   175be:	9506      	str	r5, [sp, #24]
   175c0:	e9cd 3404 	strd	r3, r4, [sp, #16]
   175c4:	9002      	str	r0, [sp, #8]
   175c6:	e9cd 1200 	strd	r1, r2, [sp]
   175ca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   175cc:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   175ce:	990c      	ldr	r1, [sp, #48]	; 0x30
   175d0:	980d      	ldr	r0, [sp, #52]	; 0x34
   175d2:	f7ff fae5 	bl	16ba0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   175d6:	901b      	str	r0, [sp, #108]	; 0x6c
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
   175d8:	e0c8      	b.n	1776c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          else if (flags & FLAGS_LONG) {
   175da:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   175dc:	f403 7380 	and.w	r3, r3, #256	; 0x100
   175e0:	2b00      	cmp	r3, #0
   175e2:	d01e      	beq.n	17622 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x556>
            const long value = va_arg(va, long);
   175e4:	9b24      	ldr	r3, [sp, #144]	; 0x90
   175e6:	1d1a      	adds	r2, r3, #4
   175e8:	9224      	str	r2, [sp, #144]	; 0x90
   175ea:	681b      	ldr	r3, [r3, #0]
   175ec:	9311      	str	r3, [sp, #68]	; 0x44
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   175ee:	9b11      	ldr	r3, [sp, #68]	; 0x44
   175f0:	2b00      	cmp	r3, #0
   175f2:	bfb8      	it	lt
   175f4:	425b      	neglt	r3, r3
   175f6:	4619      	mov	r1, r3
   175f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   175fa:	0fdb      	lsrs	r3, r3, #31
   175fc:	b2db      	uxtb	r3, r3
   175fe:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   17600:	9205      	str	r2, [sp, #20]
   17602:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17604:	9204      	str	r2, [sp, #16]
   17606:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   17608:	9203      	str	r2, [sp, #12]
   1760a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   1760c:	9202      	str	r2, [sp, #8]
   1760e:	9301      	str	r3, [sp, #4]
   17610:	9100      	str	r1, [sp, #0]
   17612:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17614:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17616:	990c      	ldr	r1, [sp, #48]	; 0x30
   17618:	980d      	ldr	r0, [sp, #52]	; 0x34
   1761a:	f7ff fa4f 	bl	16abc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1761e:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   17620:	e0a4      	b.n	1776c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   17622:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17624:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17628:	2b00      	cmp	r3, #0
   1762a:	d005      	beq.n	17638 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x56c>
   1762c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1762e:	1d1a      	adds	r2, r3, #4
   17630:	9224      	str	r2, [sp, #144]	; 0x90
   17632:	681b      	ldr	r3, [r3, #0]
   17634:	b2db      	uxtb	r3, r3
   17636:	e00e      	b.n	17656 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   17638:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1763a:	f003 0380 	and.w	r3, r3, #128	; 0x80
   1763e:	2b00      	cmp	r3, #0
   17640:	d005      	beq.n	1764e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x582>
   17642:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17644:	1d1a      	adds	r2, r3, #4
   17646:	9224      	str	r2, [sp, #144]	; 0x90
   17648:	681b      	ldr	r3, [r3, #0]
   1764a:	b21b      	sxth	r3, r3
   1764c:	e003      	b.n	17656 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   1764e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17650:	1d1a      	adds	r2, r3, #4
   17652:	9224      	str	r2, [sp, #144]	; 0x90
   17654:	681b      	ldr	r3, [r3, #0]
   17656:	9312      	str	r3, [sp, #72]	; 0x48
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   17658:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1765a:	2b00      	cmp	r3, #0
   1765c:	bfb8      	it	lt
   1765e:	425b      	neglt	r3, r3
   17660:	4619      	mov	r1, r3
   17662:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17664:	0fdb      	lsrs	r3, r3, #31
   17666:	b2db      	uxtb	r3, r3
   17668:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   1766a:	9205      	str	r2, [sp, #20]
   1766c:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   1766e:	9204      	str	r2, [sp, #16]
   17670:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   17672:	9203      	str	r2, [sp, #12]
   17674:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   17676:	9202      	str	r2, [sp, #8]
   17678:	9301      	str	r3, [sp, #4]
   1767a:	9100      	str	r1, [sp, #0]
   1767c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1767e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17680:	990c      	ldr	r1, [sp, #48]	; 0x30
   17682:	980d      	ldr	r0, [sp, #52]	; 0x34
   17684:	f7ff fa1a 	bl	16abc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   17688:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   1768a:	e06f      	b.n	1776c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
   1768c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1768e:	f403 7300 	and.w	r3, r3, #512	; 0x200
   17692:	2b00      	cmp	r3, #0
   17694:	d020      	beq.n	176d8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x60c>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   17696:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17698:	3307      	adds	r3, #7
   1769a:	f023 0307 	bic.w	r3, r3, #7
   1769e:	f103 0208 	add.w	r2, r3, #8
   176a2:	9224      	str	r2, [sp, #144]	; 0x90
   176a4:	e9d3 3400 	ldrd	r3, r4, [r3]
   176a8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   176aa:	4611      	mov	r1, r2
   176ac:	f04f 0200 	mov.w	r2, #0
   176b0:	981f      	ldr	r0, [sp, #124]	; 0x7c
   176b2:	9008      	str	r0, [sp, #32]
   176b4:	981e      	ldr	r0, [sp, #120]	; 0x78
   176b6:	9007      	str	r0, [sp, #28]
   176b8:	981d      	ldr	r0, [sp, #116]	; 0x74
   176ba:	9006      	str	r0, [sp, #24]
   176bc:	e9cd 1204 	strd	r1, r2, [sp, #16]
   176c0:	2200      	movs	r2, #0
   176c2:	9202      	str	r2, [sp, #8]
   176c4:	e9cd 3400 	strd	r3, r4, [sp]
   176c8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   176ca:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   176cc:	990c      	ldr	r1, [sp, #48]	; 0x30
   176ce:	980d      	ldr	r0, [sp, #52]	; 0x34
   176d0:	f7ff fa66 	bl	16ba0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   176d4:	901b      	str	r0, [sp, #108]	; 0x6c
   176d6:	e049      	b.n	1776c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
#endif
          }
          else if (flags & FLAGS_LONG) {
   176d8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   176da:	f403 7380 	and.w	r3, r3, #256	; 0x100
   176de:	2b00      	cmp	r3, #0
   176e0:	d016      	beq.n	17710 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x644>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   176e2:	9b24      	ldr	r3, [sp, #144]	; 0x90
   176e4:	1d1a      	adds	r2, r3, #4
   176e6:	9224      	str	r2, [sp, #144]	; 0x90
   176e8:	681b      	ldr	r3, [r3, #0]
   176ea:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   176ec:	9205      	str	r2, [sp, #20]
   176ee:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   176f0:	9204      	str	r2, [sp, #16]
   176f2:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   176f4:	9203      	str	r2, [sp, #12]
   176f6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   176f8:	9202      	str	r2, [sp, #8]
   176fa:	2200      	movs	r2, #0
   176fc:	9201      	str	r2, [sp, #4]
   176fe:	9300      	str	r3, [sp, #0]
   17700:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17702:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17704:	990c      	ldr	r1, [sp, #48]	; 0x30
   17706:	980d      	ldr	r0, [sp, #52]	; 0x34
   17708:	f7ff f9d8 	bl	16abc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1770c:	901b      	str	r0, [sp, #108]	; 0x6c
   1770e:	e02d      	b.n	1776c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   17710:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17712:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17716:	2b00      	cmp	r3, #0
   17718:	d005      	beq.n	17726 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x65a>
   1771a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1771c:	1d1a      	adds	r2, r3, #4
   1771e:	9224      	str	r2, [sp, #144]	; 0x90
   17720:	681b      	ldr	r3, [r3, #0]
   17722:	b2db      	uxtb	r3, r3
   17724:	e00e      	b.n	17744 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   17726:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17728:	f003 0380 	and.w	r3, r3, #128	; 0x80
   1772c:	2b00      	cmp	r3, #0
   1772e:	d005      	beq.n	1773c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x670>
   17730:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17732:	1d1a      	adds	r2, r3, #4
   17734:	9224      	str	r2, [sp, #144]	; 0x90
   17736:	681b      	ldr	r3, [r3, #0]
   17738:	b29b      	uxth	r3, r3
   1773a:	e003      	b.n	17744 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   1773c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1773e:	1d1a      	adds	r2, r3, #4
   17740:	9224      	str	r2, [sp, #144]	; 0x90
   17742:	681b      	ldr	r3, [r3, #0]
   17744:	9313      	str	r3, [sp, #76]	; 0x4c
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   17746:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17748:	9305      	str	r3, [sp, #20]
   1774a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1774c:	9304      	str	r3, [sp, #16]
   1774e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17750:	9303      	str	r3, [sp, #12]
   17752:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   17754:	9302      	str	r3, [sp, #8]
   17756:	2300      	movs	r3, #0
   17758:	9301      	str	r3, [sp, #4]
   1775a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1775c:	9300      	str	r3, [sp, #0]
   1775e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17760:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17762:	990c      	ldr	r1, [sp, #48]	; 0x30
   17764:	980d      	ldr	r0, [sp, #52]	; 0x34
   17766:	f7ff f9a9 	bl	16abc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1776a:	901b      	str	r0, [sp, #108]	; 0x6c
          }
        }
        format++;
   1776c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1776e:	3301      	adds	r3, #1
   17770:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17772:	e109      	b.n	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   17774:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17776:	3307      	adds	r3, #7
   17778:	f023 0307 	bic.w	r3, r3, #7
   1777c:	f103 0208 	add.w	r2, r3, #8
   17780:	9224      	str	r2, [sp, #144]	; 0x90
   17782:	ed93 7b00 	vldr	d7, [r3]
   17786:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17788:	9302      	str	r3, [sp, #8]
   1778a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1778c:	9301      	str	r3, [sp, #4]
   1778e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17790:	9300      	str	r3, [sp, #0]
   17792:	eeb0 0a47 	vmov.f32	s0, s14
   17796:	eef0 0a67 	vmov.f32	s1, s15
   1779a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1779c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1779e:	990c      	ldr	r1, [sp, #48]	; 0x30
   177a0:	980d      	ldr	r0, [sp, #52]	; 0x34
   177a2:	f7ff fa77 	bl	16c94 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>
   177a6:	901b      	str	r0, [sp, #108]	; 0x6c
        format++;
   177a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   177aa:	3301      	adds	r3, #1
   177ac:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   177ae:	e0eb      	b.n	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
   177b0:	2301      	movs	r3, #1
   177b2:	9319      	str	r3, [sp, #100]	; 0x64
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
   177b4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   177b6:	f003 0302 	and.w	r3, r3, #2
   177ba:	2b00      	cmp	r3, #0
   177bc:	d113      	bne.n	177e6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
          while (l++ < width) {
   177be:	9b19      	ldr	r3, [sp, #100]	; 0x64
   177c0:	1c5a      	adds	r2, r3, #1
   177c2:	9219      	str	r2, [sp, #100]	; 0x64
   177c4:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   177c6:	429a      	cmp	r2, r3
   177c8:	bf8c      	ite	hi
   177ca:	2301      	movhi	r3, #1
   177cc:	2300      	movls	r3, #0
   177ce:	b2db      	uxtb	r3, r3
   177d0:	2b00      	cmp	r3, #0
   177d2:	d008      	beq.n	177e6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
            out(' ', buffer, idx++, maxlen);
   177d4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   177d6:	1c53      	adds	r3, r2, #1
   177d8:	931b      	str	r3, [sp, #108]	; 0x6c
   177da:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   177dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   177de:	990c      	ldr	r1, [sp, #48]	; 0x30
   177e0:	2020      	movs	r0, #32
   177e2:	47a0      	blx	r4
          while (l++ < width) {
   177e4:	e7eb      	b.n	177be <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6f2>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
   177e6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   177e8:	1d1a      	adds	r2, r3, #4
   177ea:	9224      	str	r2, [sp, #144]	; 0x90
   177ec:	681b      	ldr	r3, [r3, #0]
   177ee:	b2d8      	uxtb	r0, r3
   177f0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   177f2:	1c53      	adds	r3, r2, #1
   177f4:	931b      	str	r3, [sp, #108]	; 0x6c
   177f6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   177f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   177fa:	990c      	ldr	r1, [sp, #48]	; 0x30
   177fc:	47a0      	blx	r4
        // post padding
        if (flags & FLAGS_LEFT) {
   177fe:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17800:	f003 0302 	and.w	r3, r3, #2
   17804:	2b00      	cmp	r3, #0
   17806:	d013      	beq.n	17830 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
          while (l++ < width) {
   17808:	9b19      	ldr	r3, [sp, #100]	; 0x64
   1780a:	1c5a      	adds	r2, r3, #1
   1780c:	9219      	str	r2, [sp, #100]	; 0x64
   1780e:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17810:	429a      	cmp	r2, r3
   17812:	bf8c      	ite	hi
   17814:	2301      	movhi	r3, #1
   17816:	2300      	movls	r3, #0
   17818:	b2db      	uxtb	r3, r3
   1781a:	2b00      	cmp	r3, #0
   1781c:	d008      	beq.n	17830 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
            out(' ', buffer, idx++, maxlen);
   1781e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17820:	1c53      	adds	r3, r2, #1
   17822:	931b      	str	r3, [sp, #108]	; 0x6c
   17824:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   17826:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17828:	990c      	ldr	r1, [sp, #48]	; 0x30
   1782a:	2020      	movs	r0, #32
   1782c:	47a0      	blx	r4
          while (l++ < width) {
   1782e:	e7eb      	b.n	17808 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x73c>
          }
        }
        format++;
   17830:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17832:	3301      	adds	r3, #1
   17834:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17836:	e0a7      	b.n	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 's' : {
        char* p = va_arg(va, char*);
   17838:	9b24      	ldr	r3, [sp, #144]	; 0x90
   1783a:	1d1a      	adds	r2, r3, #4
   1783c:	9224      	str	r2, [sp, #144]	; 0x90
   1783e:	681b      	ldr	r3, [r3, #0]
   17840:	9318      	str	r3, [sp, #96]	; 0x60
        unsigned int l = _strlen(p);
   17842:	9818      	ldr	r0, [sp, #96]	; 0x60
   17844:	f7fe ff98 	bl	16778 <_strlen(char const*)>
   17848:	9017      	str	r0, [sp, #92]	; 0x5c
        // pre padding
        if (flags & FLAGS_PRECISION) {
   1784a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1784c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   17850:	2b00      	cmp	r3, #0
   17852:	d007      	beq.n	17864 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x798>
          l = (l < precision ? l : precision);
   17854:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   17856:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17858:	429a      	cmp	r2, r3
   1785a:	d201      	bcs.n	17860 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x794>
   1785c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1785e:	e000      	b.n	17862 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x796>
   17860:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17862:	9317      	str	r3, [sp, #92]	; 0x5c
        }
        if (!(flags & FLAGS_LEFT)) {
   17864:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17866:	f003 0302 	and.w	r3, r3, #2
   1786a:	2b00      	cmp	r3, #0
   1786c:	d113      	bne.n	17896 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
          while (l++ < width) {
   1786e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17870:	1c5a      	adds	r2, r3, #1
   17872:	9217      	str	r2, [sp, #92]	; 0x5c
   17874:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   17876:	429a      	cmp	r2, r3
   17878:	bf8c      	ite	hi
   1787a:	2301      	movhi	r3, #1
   1787c:	2300      	movls	r3, #0
   1787e:	b2db      	uxtb	r3, r3
   17880:	2b00      	cmp	r3, #0
   17882:	d008      	beq.n	17896 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
            out(' ', buffer, idx++, maxlen);
   17884:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17886:	1c53      	adds	r3, r2, #1
   17888:	931b      	str	r3, [sp, #108]	; 0x6c
   1788a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1788c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1788e:	990c      	ldr	r1, [sp, #48]	; 0x30
   17890:	2020      	movs	r0, #32
   17892:	47a0      	blx	r4
          while (l++ < width) {
   17894:	e7eb      	b.n	1786e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7a2>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   17896:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17898:	781b      	ldrb	r3, [r3, #0]
   1789a:	2b00      	cmp	r3, #0
   1789c:	d00b      	beq.n	178b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   1789e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   178a0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   178a4:	2b00      	cmp	r3, #0
   178a6:	d004      	beq.n	178b2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7e6>
   178a8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   178aa:	1e5a      	subs	r2, r3, #1
   178ac:	921d      	str	r2, [sp, #116]	; 0x74
   178ae:	2b00      	cmp	r3, #0
   178b0:	d001      	beq.n	178b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   178b2:	2301      	movs	r3, #1
   178b4:	e000      	b.n	178b8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ec>
   178b6:	2300      	movs	r3, #0
   178b8:	2b00      	cmp	r3, #0
   178ba:	d00b      	beq.n	178d4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x808>
          out(*(p++), buffer, idx++, maxlen);
   178bc:	9b18      	ldr	r3, [sp, #96]	; 0x60
   178be:	1c5a      	adds	r2, r3, #1
   178c0:	9218      	str	r2, [sp, #96]	; 0x60
   178c2:	7818      	ldrb	r0, [r3, #0]
   178c4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   178c6:	1c53      	adds	r3, r2, #1
   178c8:	931b      	str	r3, [sp, #108]	; 0x6c
   178ca:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   178cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   178ce:	990c      	ldr	r1, [sp, #48]	; 0x30
   178d0:	47a0      	blx	r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   178d2:	e7e0      	b.n	17896 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
   178d4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   178d6:	f003 0302 	and.w	r3, r3, #2
   178da:	2b00      	cmp	r3, #0
   178dc:	d013      	beq.n	17906 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
          while (l++ < width) {
   178de:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   178e0:	1c5a      	adds	r2, r3, #1
   178e2:	9217      	str	r2, [sp, #92]	; 0x5c
   178e4:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   178e6:	429a      	cmp	r2, r3
   178e8:	bf8c      	ite	hi
   178ea:	2301      	movhi	r3, #1
   178ec:	2300      	movls	r3, #0
   178ee:	b2db      	uxtb	r3, r3
   178f0:	2b00      	cmp	r3, #0
   178f2:	d008      	beq.n	17906 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
            out(' ', buffer, idx++, maxlen);
   178f4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   178f6:	1c53      	adds	r3, r2, #1
   178f8:	931b      	str	r3, [sp, #108]	; 0x6c
   178fa:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   178fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   178fe:	990c      	ldr	r1, [sp, #48]	; 0x30
   17900:	2020      	movs	r0, #32
   17902:	47a0      	blx	r4
          while (l++ < width) {
   17904:	e7eb      	b.n	178de <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x812>
          }
        }
        format++;
   17906:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17908:	3301      	adds	r3, #1
   1790a:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   1790c:	e03c      	b.n	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
   1790e:	2308      	movs	r3, #8
   17910:	931e      	str	r3, [sp, #120]	; 0x78
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   17912:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   17914:	f043 0321 	orr.w	r3, r3, #33	; 0x21
   17918:	931f      	str	r3, [sp, #124]	; 0x7c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   1791a:	2300      	movs	r3, #0
   1791c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   17920:	9b24      	ldr	r3, [sp, #144]	; 0x90
   17922:	1d1a      	adds	r2, r3, #4
   17924:	9224      	str	r2, [sp, #144]	; 0x90
   17926:	681b      	ldr	r3, [r3, #0]
   17928:	461a      	mov	r2, r3
   1792a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1792c:	9305      	str	r3, [sp, #20]
   1792e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17930:	9304      	str	r3, [sp, #16]
   17932:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   17934:	9303      	str	r3, [sp, #12]
   17936:	2310      	movs	r3, #16
   17938:	9302      	str	r3, [sp, #8]
   1793a:	2300      	movs	r3, #0
   1793c:	9301      	str	r3, [sp, #4]
   1793e:	9200      	str	r2, [sp, #0]
   17940:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17942:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17944:	990c      	ldr	r1, [sp, #48]	; 0x30
   17946:	980d      	ldr	r0, [sp, #52]	; 0x34
   17948:	f7ff f8b8 	bl	16abc <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   1794c:	901b      	str	r0, [sp, #108]	; 0x6c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
   1794e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17950:	3301      	adds	r3, #1
   17952:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17954:	e018      	b.n	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
   17956:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17958:	1c53      	adds	r3, r2, #1
   1795a:	931b      	str	r3, [sp, #108]	; 0x6c
   1795c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1795e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17960:	990c      	ldr	r1, [sp, #48]	; 0x30
   17962:	2025      	movs	r0, #37	; 0x25
   17964:	47a0      	blx	r4
        format++;
   17966:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17968:	3301      	adds	r3, #1
   1796a:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   1796c:	e00c      	b.n	17988 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>

      default :
        out(*format, buffer, idx++, maxlen);
   1796e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17970:	7818      	ldrb	r0, [r3, #0]
   17972:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   17974:	1c53      	adds	r3, r2, #1
   17976:	931b      	str	r3, [sp, #108]	; 0x6c
   17978:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1797a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1797c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1797e:	47a0      	blx	r4
        format++;
   17980:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17982:	3301      	adds	r3, #1
   17984:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   17986:	bf00      	nop
  while (*format)
   17988:	f7ff bbb3 	b.w	170f2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   1798c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1798e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17990:	429a      	cmp	r2, r3
   17992:	d302      	bcc.n	1799a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ce>
   17994:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17996:	1e5a      	subs	r2, r3, #1
   17998:	e000      	b.n	1799c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8d0>
   1799a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1799c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1799e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   179a0:	990c      	ldr	r1, [sp, #48]	; 0x30
   179a2:	2000      	movs	r0, #0
   179a4:	47a0      	blx	r4

  // return written chars without terminating \0
  return (int)idx;
   179a6:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   179a8:	4633      	mov	r3, r6
   179aa:	4619      	mov	r1, r3
   179ac:	4803      	ldr	r0, [pc, #12]	; (179bc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8f0>)
   179ae:	f7fd fc37 	bl	15220 <__cyg_profile_func_exit>
   179b2:	4623      	mov	r3, r4
}
   179b4:	4618      	mov	r0, r3
   179b6:	b020      	add	sp, #128	; 0x80
   179b8:	bd70      	pop	{r4, r5, r6, pc}
   179ba:	bf00      	nop
   179bc:	000170cd 	.word	0x000170cd

000179c0 <printf>:

///////////////////////////////////////////////////////////////////////////////


int printf(const char* format, ...)
{
   179c0:	b40f      	push	{r0, r1, r2, r3}
   179c2:	b530      	push	{r4, r5, lr}
   179c4:	b087      	sub	sp, #28
   179c6:	4675      	mov	r5, lr
   179c8:	462b      	mov	r3, r5
   179ca:	4619      	mov	r1, r3
   179cc:	480d      	ldr	r0, [pc, #52]	; (17a04 <printf+0x44>)
   179ce:	f7fd fc13 	bl	151f8 <__cyg_profile_func_enter>
  va_list va;
  va_start(va, format);
   179d2:	ab0b      	add	r3, sp, #44	; 0x2c
   179d4:	9304      	str	r3, [sp, #16]
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   179d6:	a903      	add	r1, sp, #12
   179d8:	9b04      	ldr	r3, [sp, #16]
   179da:	9300      	str	r3, [sp, #0]
   179dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   179de:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   179e2:	4809      	ldr	r0, [pc, #36]	; (17a08 <printf+0x48>)
   179e4:	f7ff fb72 	bl	170cc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   179e8:	9005      	str	r0, [sp, #20]
  va_end(va);
  return ret;
   179ea:	9c05      	ldr	r4, [sp, #20]
   179ec:	462b      	mov	r3, r5
   179ee:	4619      	mov	r1, r3
   179f0:	4804      	ldr	r0, [pc, #16]	; (17a04 <printf+0x44>)
   179f2:	f7fd fc15 	bl	15220 <__cyg_profile_func_exit>
   179f6:	4623      	mov	r3, r4
}
   179f8:	4618      	mov	r0, r3
   179fa:	b007      	add	sp, #28
   179fc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   17a00:	b004      	add	sp, #16
   17a02:	4770      	bx	lr
   17a04:	000179c1 	.word	0x000179c1
   17a08:	00016735 	.word	0x00016735

00017a0c <vsnprintf>:
  return ret;
}


int vsnprintf(char* buffer, size_t count, const char* format, va_list va)
{
   17a0c:	b530      	push	{r4, r5, lr}
   17a0e:	b087      	sub	sp, #28
   17a10:	4674      	mov	r4, lr
   17a12:	9005      	str	r0, [sp, #20]
   17a14:	9104      	str	r1, [sp, #16]
   17a16:	9203      	str	r2, [sp, #12]
   17a18:	9302      	str	r3, [sp, #8]
   17a1a:	4623      	mov	r3, r4
   17a1c:	4619      	mov	r1, r3
   17a1e:	480a      	ldr	r0, [pc, #40]	; (17a48 <vsnprintf+0x3c>)
   17a20:	f7fd fbea 	bl	151f8 <__cyg_profile_func_enter>
  return _vsnprintf(_out_buffer, buffer, count, format, va);
   17a24:	9b02      	ldr	r3, [sp, #8]
   17a26:	9300      	str	r3, [sp, #0]
   17a28:	9b03      	ldr	r3, [sp, #12]
   17a2a:	9a04      	ldr	r2, [sp, #16]
   17a2c:	9905      	ldr	r1, [sp, #20]
   17a2e:	4807      	ldr	r0, [pc, #28]	; (17a4c <vsnprintf+0x40>)
   17a30:	f7ff fb4c 	bl	170cc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   17a34:	4605      	mov	r5, r0
   17a36:	4623      	mov	r3, r4
   17a38:	4619      	mov	r1, r3
   17a3a:	4803      	ldr	r0, [pc, #12]	; (17a48 <vsnprintf+0x3c>)
   17a3c:	f7fd fbf0 	bl	15220 <__cyg_profile_func_exit>
   17a40:	462b      	mov	r3, r5
}
   17a42:	4618      	mov	r0, r3
   17a44:	b007      	add	sp, #28
   17a46:	bd30      	pop	{r4, r5, pc}
   17a48:	00017a0d 	.word	0x00017a0d
   17a4c:	000166c1 	.word	0x000166c1

00017a50 <Wait(unsigned long long)::{lambda()#1}::operator()() const>:

inline Status Wait(uint64_t timeout)
{
  return Wait(timeout, []() -> bool { return false; });
   17a50:	b530      	push	{r4, r5, lr}
   17a52:	b083      	sub	sp, #12
   17a54:	4675      	mov	r5, lr
   17a56:	9001      	str	r0, [sp, #4]
   17a58:	462b      	mov	r3, r5
   17a5a:	4619      	mov	r1, r3
   17a5c:	4806      	ldr	r0, [pc, #24]	; (17a78 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   17a5e:	f7fd fbcb 	bl	151f8 <__cyg_profile_func_enter>
   17a62:	2400      	movs	r4, #0
   17a64:	462b      	mov	r3, r5
   17a66:	4619      	mov	r1, r3
   17a68:	4803      	ldr	r0, [pc, #12]	; (17a78 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   17a6a:	f7fd fbd9 	bl	15220 <__cyg_profile_func_exit>
   17a6e:	4623      	mov	r3, r4
   17a70:	4618      	mov	r0, r3
   17a72:	b003      	add	sp, #12
   17a74:	bd30      	pop	{r4, r5, pc}
   17a76:	bf00      	nop
   17a78:	00017a51 	.word	0x00017a51

00017a7c <Wait(unsigned long long)::{lambda()#1}::_FUN()>:
   17a7c:	b538      	push	{r3, r4, r5, lr}
   17a7e:	4674      	mov	r4, lr
   17a80:	4623      	mov	r3, r4
   17a82:	4619      	mov	r1, r3
   17a84:	4807      	ldr	r0, [pc, #28]	; (17aa4 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   17a86:	f7fd fbb7 	bl	151f8 <__cyg_profile_func_enter>
   17a8a:	2000      	movs	r0, #0
   17a8c:	f7ff ffe0 	bl	17a50 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   17a90:	4603      	mov	r3, r0
   17a92:	461d      	mov	r5, r3
   17a94:	4623      	mov	r3, r4
   17a96:	4619      	mov	r1, r3
   17a98:	4802      	ldr	r0, [pc, #8]	; (17aa4 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   17a9a:	f7fd fbc1 	bl	15220 <__cyg_profile_func_exit>
   17a9e:	462b      	mov	r3, r5
   17aa0:	4618      	mov	r0, r3
   17aa2:	bd38      	pop	{r3, r4, r5, pc}
   17aa4:	00017a7d 	.word	0x00017a7d

00017aa8 <Wait(unsigned long long)>:
{
   17aa8:	b5f0      	push	{r4, r5, r6, r7, lr}
   17aaa:	b089      	sub	sp, #36	; 0x24
   17aac:	4675      	mov	r5, lr
   17aae:	e9cd 0100 	strd	r0, r1, [sp]
   17ab2:	462b      	mov	r3, r5
   17ab4:	4619      	mov	r1, r3
   17ab6:	482b      	ldr	r0, [pc, #172]	; (17b64 <Wait(unsigned long long)+0xbc>)
   17ab8:	f7fd fb9e 	bl	151f8 <__cyg_profile_func_enter>
   17abc:	e9dd 3400 	ldrd	r3, r4, [sp]
   17ac0:	e9cd 3406 	strd	r3, r4, [sp, #24]
   17ac4:	f88d 6008 	strb.w	r6, [sp, #8]
   17ac8:	462b      	mov	r3, r5
   17aca:	4619      	mov	r1, r3
   17acc:	4826      	ldr	r0, [pc, #152]	; (17b68 <Wait(unsigned long long)+0xc0>)
   17ace:	f7fd fb93 	bl	151f8 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   17ad2:	f04f 0300 	mov.w	r3, #0
   17ad6:	f04f 0400 	mov.w	r4, #0
   17ada:	e9cd 3404 	strd	r3, r4, [sp, #16]
  if (timeout == kMaxWait)
   17ade:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   17ae2:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   17ae6:	bf08      	it	eq
   17ae8:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   17aec:	d106      	bne.n	17afc <Wait(unsigned long long)+0x54>
    timeout_time = kMaxWait;
   17aee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17af2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   17af6:	e9cd 3404 	strd	r3, r4, [sp, #16]
   17afa:	e00a      	b.n	17b12 <Wait(unsigned long long)+0x6a>
    timeout_time = Milliseconds() + timeout;
   17afc:	f7f9 f802 	bl	10b04 <Milliseconds()>
   17b00:	460a      	mov	r2, r1
   17b02:	4601      	mov	r1, r0
   17b04:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   17b08:	185e      	adds	r6, r3, r1
   17b0a:	eb44 0702 	adc.w	r7, r4, r2
   17b0e:	e9cd 6704 	strd	r6, r7, [sp, #16]
  Status status = Status::kTimedOut;
   17b12:	2301      	movs	r3, #1
   17b14:	9303      	str	r3, [sp, #12]
  while (Milliseconds() < timeout_time)
   17b16:	f7f8 fff5 	bl	10b04 <Milliseconds()>
   17b1a:	460a      	mov	r2, r1
   17b1c:	4601      	mov	r1, r0
   17b1e:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   17b22:	42a2      	cmp	r2, r4
   17b24:	bf08      	it	eq
   17b26:	4299      	cmpeq	r1, r3
   17b28:	bf34      	ite	cc
   17b2a:	2301      	movcc	r3, #1
   17b2c:	2300      	movcs	r3, #0
   17b2e:	b2db      	uxtb	r3, r3
   17b30:	2b00      	cmp	r3, #0
   17b32:	d008      	beq.n	17b46 <Wait(unsigned long long)+0x9e>
    if (is_done())
   17b34:	ab02      	add	r3, sp, #8
   17b36:	4618      	mov	r0, r3
   17b38:	f7ff ff8a 	bl	17a50 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   17b3c:	4603      	mov	r3, r0
   17b3e:	2b00      	cmp	r3, #0
   17b40:	d0e9      	beq.n	17b16 <Wait(unsigned long long)+0x6e>
      status = Status::kSuccess;
   17b42:	2300      	movs	r3, #0
   17b44:	9303      	str	r3, [sp, #12]
  return status;
   17b46:	9c03      	ldr	r4, [sp, #12]
   17b48:	462b      	mov	r3, r5
   17b4a:	4619      	mov	r1, r3
   17b4c:	4806      	ldr	r0, [pc, #24]	; (17b68 <Wait(unsigned long long)+0xc0>)
   17b4e:	f7fd fb67 	bl	15220 <__cyg_profile_func_exit>
   17b52:	462b      	mov	r3, r5
   17b54:	4619      	mov	r1, r3
   17b56:	4803      	ldr	r0, [pc, #12]	; (17b64 <Wait(unsigned long long)+0xbc>)
   17b58:	f7fd fb62 	bl	15220 <__cyg_profile_func_exit>
  return Wait(timeout, []() -> bool { return false; });
   17b5c:	4623      	mov	r3, r4
}
   17b5e:	4618      	mov	r0, r3
   17b60:	b009      	add	sp, #36	; 0x24
   17b62:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17b64:	00017aa9 	.word	0x00017aa9
   17b68:	00018e6d 	.word	0x00018e6d

00017b6c <Delay(unsigned long long)>:

// Delay the system for a duration of time
inline void Delay([[maybe_unused]] uint64_t delay_time_ms)
{
   17b6c:	b510      	push	{r4, lr}
   17b6e:	b082      	sub	sp, #8
   17b70:	4674      	mov	r4, lr
   17b72:	e9cd 0100 	strd	r0, r1, [sp]
   17b76:	4623      	mov	r3, r4
   17b78:	4619      	mov	r1, r3
   17b7a:	4807      	ldr	r0, [pc, #28]	; (17b98 <Delay(unsigned long long)+0x2c>)
   17b7c:	f7fd fb3c 	bl	151f8 <__cyg_profile_func_enter>
#if defined(HOST_TEST)
  return;
#else
  Wait(delay_time_ms);
   17b80:	e9dd 0100 	ldrd	r0, r1, [sp]
   17b84:	f7ff ff90 	bl	17aa8 <Wait(unsigned long long)>
   17b88:	4623      	mov	r3, r4
   17b8a:	4619      	mov	r1, r3
   17b8c:	4802      	ldr	r0, [pc, #8]	; (17b98 <Delay(unsigned long long)+0x2c>)
   17b8e:	f7fd fb47 	bl	15220 <__cyg_profile_func_exit>
#endif  // HOST_TEST
}
   17b92:	bf00      	nop
   17b94:	b002      	add	sp, #8
   17b96:	bd10      	pop	{r4, pc}
   17b98:	00017b6d 	.word	0x00017b6d

00017b9c <SdInterface::SdInterface()>:
// NOLINTNEXTLINE(readability-identifier-naming)
// Relevant Datasheet:
// https://www.sdcard.org/downloads/pls/pdf/index.php?p=Part1_Physical_Layer_Simplified_Specification_Ver6.00.jpg&f=Part1_Physical_Layer_Simplified_Specification_Ver6.00.pdf&e=EN_SS1
// TODO(#348):  Write a class to represent a single Sd Card Block to make use
//              of block-related functions easier.
class SdInterface
   17b9c:	b530      	push	{r4, r5, lr}
   17b9e:	b083      	sub	sp, #12
   17ba0:	4675      	mov	r5, lr
   17ba2:	9001      	str	r0, [sp, #4]
   17ba4:	462b      	mov	r3, r5
   17ba6:	4619      	mov	r1, r3
   17ba8:	4807      	ldr	r0, [pc, #28]	; (17bc8 <SdInterface::SdInterface()+0x2c>)
   17baa:	f7fd fb25 	bl	151f8 <__cyg_profile_func_enter>
   17bae:	4a07      	ldr	r2, [pc, #28]	; (17bcc <SdInterface::SdInterface()+0x30>)
   17bb0:	9b01      	ldr	r3, [sp, #4]
   17bb2:	601a      	str	r2, [r3, #0]
   17bb4:	9c01      	ldr	r4, [sp, #4]
   17bb6:	462b      	mov	r3, r5
   17bb8:	4619      	mov	r1, r3
   17bba:	4803      	ldr	r0, [pc, #12]	; (17bc8 <SdInterface::SdInterface()+0x2c>)
   17bbc:	f7fd fb30 	bl	15220 <__cyg_profile_func_exit>
   17bc0:	4623      	mov	r3, r4
   17bc2:	4618      	mov	r0, r3
   17bc4:	b003      	add	sp, #12
   17bc6:	bd30      	pop	{r4, r5, pc}
   17bc8:	00017b9d 	.word	0x00017b9d
   17bcc:	0001c154 	.word	0x0001c154

00017bd0 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>:
  /// port that is broken out through the board's GPIO, allowing you to probe
  /// the chip select manually. To use this version instead of the main version,
  /// instantiate an Sd card instance like so:
  ///
  ///   Sd sdcard(Sd::DebugSdCard_t{});
  constexpr Sd(DebugSdCard_t, uint8_t port = 1, uint8_t pin = 8,
   17bd0:	b530      	push	{r4, r5, lr}
   17bd2:	b083      	sub	sp, #12
   17bd4:	4675      	mov	r5, lr
   17bd6:	9001      	str	r0, [sp, #4]
   17bd8:	f88d 1000 	strb.w	r1, [sp]
   17bdc:	4611      	mov	r1, r2
   17bde:	461a      	mov	r2, r3
   17be0:	460b      	mov	r3, r1
   17be2:	f88d 3003 	strb.w	r3, [sp, #3]
   17be6:	4613      	mov	r3, r2
   17be8:	f88d 3002 	strb.w	r3, [sp, #2]
   17bec:	462b      	mov	r3, r5
   17bee:	4619      	mov	r1, r3
   17bf0:	481d      	ldr	r0, [pc, #116]	; (17c68 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   17bf2:	f7fd fb01 	bl	151f8 <__cyg_profile_func_enter>
      : ssp_interface_(&ssp_),
        ssp_(Ssp::Peripheral::kSsp2),
        chip_select_(&chip_select_pin_),
        chip_select_external_(&chip_select_external_pin_),
        chip_select_pin_(port, pin),
        chip_select_external_pin_(extport, extpin)
   17bf6:	9b01      	ldr	r3, [sp, #4]
   17bf8:	4618      	mov	r0, r3
   17bfa:	f7ff ffcf 	bl	17b9c <SdInterface::SdInterface()>
   17bfe:	4a1b      	ldr	r2, [pc, #108]	; (17c6c <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x9c>)
   17c00:	9b01      	ldr	r3, [sp, #4]
   17c02:	601a      	str	r2, [r3, #0]
   17c04:	9b01      	ldr	r3, [sp, #4]
   17c06:	f103 0208 	add.w	r2, r3, #8
   17c0a:	9b01      	ldr	r3, [sp, #4]
   17c0c:	605a      	str	r2, [r3, #4]
   17c0e:	9b01      	ldr	r3, [sp, #4]
   17c10:	3308      	adds	r3, #8
   17c12:	2102      	movs	r1, #2
   17c14:	4618      	mov	r0, r3
   17c16:	f7f9 ffa1 	bl	11b5c <Ssp::Ssp(Ssp::Peripheral)>
   17c1a:	9b01      	ldr	r3, [sp, #4]
   17c1c:	f103 0240 	add.w	r2, r3, #64	; 0x40
   17c20:	9b01      	ldr	r3, [sp, #4]
   17c22:	639a      	str	r2, [r3, #56]	; 0x38
   17c24:	9b01      	ldr	r3, [sp, #4]
   17c26:	f103 0254 	add.w	r2, r3, #84	; 0x54
   17c2a:	9b01      	ldr	r3, [sp, #4]
   17c2c:	63da      	str	r2, [r3, #60]	; 0x3c
   17c2e:	9b01      	ldr	r3, [sp, #4]
   17c30:	3340      	adds	r3, #64	; 0x40
   17c32:	f89d 2002 	ldrb.w	r2, [sp, #2]
   17c36:	f89d 1003 	ldrb.w	r1, [sp, #3]
   17c3a:	4618      	mov	r0, r3
   17c3c:	f7f8 ff9e 	bl	10b7c <Gpio::Gpio(unsigned char, unsigned char)>
   17c40:	9b01      	ldr	r3, [sp, #4]
   17c42:	3354      	adds	r3, #84	; 0x54
   17c44:	f89d 201c 	ldrb.w	r2, [sp, #28]
   17c48:	f89d 1018 	ldrb.w	r1, [sp, #24]
   17c4c:	4618      	mov	r0, r3
   17c4e:	f7f8 ff95 	bl	10b7c <Gpio::Gpio(unsigned char, unsigned char)>
  {
  }
   17c52:	9c01      	ldr	r4, [sp, #4]
   17c54:	462b      	mov	r3, r5
   17c56:	4619      	mov	r1, r3
   17c58:	4803      	ldr	r0, [pc, #12]	; (17c68 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   17c5a:	f7fd fae1 	bl	15220 <__cyg_profile_func_exit>
   17c5e:	4623      	mov	r3, r4
   17c60:	4618      	mov	r0, r3
   17c62:	b003      	add	sp, #12
   17c64:	bd30      	pop	{r4, r5, pc}
   17c66:	bf00      	nop
   17c68:	00017bd1 	.word	0x00017bd1
   17c6c:	0001c128 	.word	0x0001c128

00017c70 <Sd::Initialize()>:

  void Initialize() override
   17c70:	b530      	push	{r4, r5, lr}
   17c72:	b085      	sub	sp, #20
   17c74:	4675      	mov	r5, lr
   17c76:	9003      	str	r0, [sp, #12]
   17c78:	462b      	mov	r3, r5
   17c7a:	4619      	mov	r1, r3
   17c7c:	4827      	ldr	r0, [pc, #156]	; (17d1c <Sd::Initialize()+0xac>)
   17c7e:	f7fd fabb 	bl	151f8 <__cyg_profile_func_enter>
  {
    LOG_DEBUG("Begin initialization:");
    LOG_DEBUG("Setting CS as output...");
    chip_select_->SetAsOutput();
   17c82:	9b03      	ldr	r3, [sp, #12]
   17c84:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   17c86:	9b03      	ldr	r3, [sp, #12]
   17c88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   17c8a:	681b      	ldr	r3, [r3, #0]
   17c8c:	3304      	adds	r3, #4
   17c8e:	681b      	ldr	r3, [r3, #0]
   17c90:	4610      	mov	r0, r2
   17c92:	4798      	blx	r3
    chip_select_->SetHigh();
   17c94:	9b03      	ldr	r3, [sp, #12]
   17c96:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   17c98:	9b03      	ldr	r3, [sp, #12]
   17c9a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   17c9c:	681b      	ldr	r3, [r3, #0]
   17c9e:	330c      	adds	r3, #12
   17ca0:	681b      	ldr	r3, [r3, #0]
   17ca2:	4610      	mov	r0, r2
   17ca4:	4798      	blx	r3
    chip_select_external_->SetAsOutput();
   17ca6:	9b03      	ldr	r3, [sp, #12]
   17ca8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   17caa:	9b03      	ldr	r3, [sp, #12]
   17cac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   17cae:	681b      	ldr	r3, [r3, #0]
   17cb0:	3304      	adds	r3, #4
   17cb2:	681b      	ldr	r3, [r3, #0]
   17cb4:	4610      	mov	r0, r2
   17cb6:	4798      	blx	r3
    chip_select_external_->SetHigh();
   17cb8:	9b03      	ldr	r3, [sp, #12]
   17cba:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   17cbc:	9b03      	ldr	r3, [sp, #12]
   17cbe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   17cc0:	681b      	ldr	r3, [r3, #0]
   17cc2:	330c      	adds	r3, #12
   17cc4:	681b      	ldr	r3, [r3, #0]
   17cc6:	4610      	mov	r0, r2
   17cc8:	4798      	blx	r3

    LOG_DEBUG("Setting SSP Clock Speed...");
    ssp_interface_->SetClock(false, false, 14, 2);  // 400kHz
   17cca:	9b03      	ldr	r3, [sp, #12]
   17ccc:	6858      	ldr	r0, [r3, #4]
   17cce:	9b03      	ldr	r3, [sp, #12]
   17cd0:	685b      	ldr	r3, [r3, #4]
   17cd2:	681b      	ldr	r3, [r3, #0]
   17cd4:	3318      	adds	r3, #24
   17cd6:	681c      	ldr	r4, [r3, #0]
   17cd8:	2302      	movs	r3, #2
   17cda:	9300      	str	r3, [sp, #0]
   17cdc:	230e      	movs	r3, #14
   17cde:	2200      	movs	r2, #0
   17ce0:	2100      	movs	r1, #0
   17ce2:	47a0      	blx	r4

    LOG_DEBUG("Setting Peripheral Mode...");
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   17ce4:	9b03      	ldr	r3, [sp, #12]
   17ce6:	6858      	ldr	r0, [r3, #4]
   17ce8:	9b03      	ldr	r3, [sp, #12]
   17cea:	685b      	ldr	r3, [r3, #4]
                                      Ssp::FrameMode::kSpi,
                                      Ssp::DataSize::kEight);
   17cec:	681b      	ldr	r3, [r3, #0]
   17cee:	3310      	adds	r3, #16
   17cf0:	681c      	ldr	r4, [r3, #0]
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   17cf2:	2307      	movs	r3, #7
   17cf4:	2200      	movs	r2, #0
   17cf6:	2100      	movs	r1, #0
   17cf8:	47a0      	blx	r4

    LOG_DEBUG("Starting SSP Peripheral...");
    ssp_interface_->Initialize();
   17cfa:	9b03      	ldr	r3, [sp, #12]
   17cfc:	685a      	ldr	r2, [r3, #4]
   17cfe:	9b03      	ldr	r3, [sp, #12]
   17d00:	685b      	ldr	r3, [r3, #4]
   17d02:	681b      	ldr	r3, [r3, #0]
   17d04:	681b      	ldr	r3, [r3, #0]
   17d06:	4610      	mov	r0, r2
   17d08:	4798      	blx	r3
   17d0a:	462b      	mov	r3, r5
   17d0c:	4619      	mov	r1, r3
   17d0e:	4803      	ldr	r0, [pc, #12]	; (17d1c <Sd::Initialize()+0xac>)
   17d10:	f7fd fa86 	bl	15220 <__cyg_profile_func_exit>
  }
   17d14:	bf00      	nop
   17d16:	b005      	add	sp, #20
   17d18:	bd30      	pop	{r4, r5, pc}
   17d1a:	bf00      	nop
   17d1c:	00017c71 	.word	0x00017c71

00017d20 <Sd::Mount(SdInterface::CardInfo_t*)>:

  // Initialize SD Card
  // TODO(#349): Split method into smaller piece with single jobs
  bool Mount(CardInfo_t * sd) override
   17d20:	b530      	push	{r4, r5, lr}
   17d22:	b08b      	sub	sp, #44	; 0x2c
   17d24:	4675      	mov	r5, lr
   17d26:	9003      	str	r0, [sp, #12]
   17d28:	9102      	str	r1, [sp, #8]
   17d2a:	462b      	mov	r3, r5
   17d2c:	4619      	mov	r1, r3
   17d2e:	48a7      	ldr	r0, [pc, #668]	; (17fcc <Sd::Mount(SdInterface::CardInfo_t*)+0x2ac>)
   17d30:	f7fd fa62 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint8_t tries     = 0;
   17d34:	2300      	movs	r3, #0
   17d36:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    bool card_is_idle = false;
   17d3a:	2300      	movs	r3, #0
   17d3c:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26

    // Reset the card and force it to go to idle state at <400kHz with a
    // CMD0 + (active-low) CS
    LOG_DEBUG("Sending SD Card to Idle State...");
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   17d40:	9b03      	ldr	r3, [sp, #12]
   17d42:	681b      	ldr	r3, [r3, #0]
   17d44:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
   17d46:	9b02      	ldr	r3, [sp, #8]
   17d48:	f103 0208 	add.w	r2, r3, #8
   17d4c:	2301      	movs	r3, #1
   17d4e:	9301      	str	r3, [sp, #4]
   17d50:	2364      	movs	r3, #100	; 0x64
   17d52:	9300      	str	r3, [sp, #0]
   17d54:	4613      	mov	r3, r2
   17d56:	2200      	movs	r2, #0
   17d58:	2140      	movs	r1, #64	; 0x40
   17d5a:	9803      	ldr	r0, [sp, #12]
   17d5c:	47a0      	blx	r4
   17d5e:	4602      	mov	r2, r0
   17d60:	9b02      	ldr	r3, [sp, #8]
   17d62:	611a      	str	r2, [r3, #16]

    // Reset the card again to trigger SPI mode
    LOG_DEBUG("Initializing SPI mode...");
    do
    {
      tries++;
   17d64:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17d68:	3301      	adds	r3, #1
   17d6a:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      sd->response.length = SendCmd(
          Command::kReset, 0x00, sd->response.data.byte, 100, KeepAlive::kYes);
   17d6e:	9b03      	ldr	r3, [sp, #12]
   17d70:	681b      	ldr	r3, [r3, #0]
   17d72:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(
   17d74:	9b02      	ldr	r3, [sp, #8]
   17d76:	f103 0208 	add.w	r2, r3, #8
   17d7a:	2301      	movs	r3, #1
   17d7c:	9301      	str	r3, [sp, #4]
   17d7e:	2364      	movs	r3, #100	; 0x64
   17d80:	9300      	str	r3, [sp, #0]
   17d82:	4613      	mov	r3, r2
   17d84:	2200      	movs	r2, #0
   17d86:	2140      	movs	r1, #64	; 0x40
   17d88:	9803      	ldr	r0, [sp, #12]
   17d8a:	47a0      	blx	r4
   17d8c:	4602      	mov	r2, r0
   17d8e:	9b02      	ldr	r3, [sp, #8]
   17d90:	611a      	str	r2, [r3, #16]

      // Check if R1 response frame's bit 1 is set (to ensure that
      // card is in idle state)
      if (sd->response.data.byte[0] != 0xFF &&
   17d92:	9b02      	ldr	r3, [sp, #8]
   17d94:	7a1b      	ldrb	r3, [r3, #8]
   17d96:	2bff      	cmp	r3, #255	; 0xff
   17d98:	d008      	beq.n	17dac <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
          (sd->response.data.byte[0] & 0x01) == 0x01)
   17d9a:	9b02      	ldr	r3, [sp, #8]
   17d9c:	7a1b      	ldrb	r3, [r3, #8]
   17d9e:	f003 0301 	and.w	r3, r3, #1
      if (sd->response.data.byte[0] != 0xFF &&
   17da2:	2b00      	cmp	r3, #0
   17da4:	d002      	beq.n	17dac <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
      {
        // If it is, we can move on; otherwise, keep trying for a set
        // amount of tries
        card_is_idle = true;
   17da6:	2301      	movs	r3, #1
   17da8:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
      }
      Delay(10);
   17dac:	f04f 000a 	mov.w	r0, #10
   17db0:	f04f 0100 	mov.w	r1, #0
   17db4:	f7ff feda 	bl	17b6c <Delay(unsigned long long)>
    } while (tries < kBusTimeout && !card_is_idle);
   17db8:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17dbc:	2bf9      	cmp	r3, #249	; 0xf9
   17dbe:	d804      	bhi.n	17dca <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
   17dc0:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   17dc4:	2b00      	cmp	r3, #0
   17dc6:	d100      	bne.n	17dca <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
    do
   17dc8:	e7cc      	b.n	17d64 <Sd::Mount(SdInterface::CardInfo_t*)+0x44>
    LOG_DEBUG("%d tries", tries);
    if (tries >= kBusTimeout)
   17dca:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17dce:	2bf9      	cmp	r3, #249	; 0xf9
   17dd0:	d91b      	bls.n	17e0a <Sd::Mount(SdInterface::CardInfo_t*)+0xea>
    {
      LOG_ERROR("Failed to initiate SPI mode within timeout. Aborting!");
   17dd2:	f240 13ff 	movw	r3, #511	; 0x1ff
   17dd6:	4a7e      	ldr	r2, [pc, #504]	; (17fd0 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   17dd8:	497e      	ldr	r1, [pc, #504]	; (17fd4 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b4>)
   17dda:	487f      	ldr	r0, [pc, #508]	; (17fd8 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b8>)
   17ddc:	f7ff fdf0 	bl	179c0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17de0:	9b03      	ldr	r3, [sp, #12]
   17de2:	681b      	ldr	r3, [r3, #0]
   17de4:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   17de6:	9b02      	ldr	r3, [sp, #8]
   17de8:	f103 0208 	add.w	r2, r3, #8
   17dec:	2300      	movs	r3, #0
   17dee:	9301      	str	r3, [sp, #4]
   17df0:	2300      	movs	r3, #0
   17df2:	9300      	str	r3, [sp, #0]
   17df4:	4613      	mov	r3, r2
   17df6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17dfa:	21ff      	movs	r1, #255	; 0xff
   17dfc:	9803      	ldr	r0, [sp, #12]
   17dfe:	47a0      	blx	r4
   17e00:	4602      	mov	r2, r0
   17e02:	9b02      	ldr	r3, [sp, #8]
   17e04:	611a      	str	r2, [r3, #16]
      return false;
   17e06:	2400      	movs	r4, #0
   17e08:	e10c      	b.n	18024 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Send the host's supported voltage (3.3V) and ask if the card
    // supports it
    LOG_DEBUG("Checking Current SD Card Voltage Level...");
    constexpr uint8_t kCheckPattern = 0xAB;
   17e0a:	23ab      	movs	r3, #171	; 0xab
   17e0c:	f88d 301f 	strb.w	r3, [sp, #31]
    uint64_t supported_voltage      = 0x00000001;
   17e10:	f04f 0301 	mov.w	r3, #1
   17e14:	f04f 0400 	mov.w	r4, #0
   17e18:	e9cd 3404 	strd	r3, r4, [sp, #16]
    sd->response.length =
        SendCmd(Command::kGetOp,
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
                sd->response.data.byte, 100, KeepAlive::kYes);
   17e1c:	9b03      	ldr	r3, [sp, #12]
   17e1e:	681b      	ldr	r3, [r3, #0]
   17e20:	681c      	ldr	r4, [r3, #0]
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
   17e22:	9b04      	ldr	r3, [sp, #16]
   17e24:	021b      	lsls	r3, r3, #8
        SendCmd(Command::kGetOp,
   17e26:	f043 02ab 	orr.w	r2, r3, #171	; 0xab
   17e2a:	9b02      	ldr	r3, [sp, #8]
   17e2c:	f103 0108 	add.w	r1, r3, #8
   17e30:	2301      	movs	r3, #1
   17e32:	9301      	str	r3, [sp, #4]
   17e34:	2364      	movs	r3, #100	; 0x64
   17e36:	9300      	str	r3, [sp, #0]
   17e38:	460b      	mov	r3, r1
   17e3a:	2148      	movs	r1, #72	; 0x48
   17e3c:	9803      	ldr	r0, [sp, #12]
   17e3e:	47a0      	blx	r4
   17e40:	4602      	mov	r2, r0
    sd->response.length =
   17e42:	9b02      	ldr	r3, [sp, #8]
   17e44:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[4] != kCheckPattern)
   17e46:	9b02      	ldr	r3, [sp, #8]
   17e48:	7b1b      	ldrb	r3, [r3, #12]
   17e4a:	2bab      	cmp	r3, #171	; 0xab
   17e4c:	d01b      	beq.n	17e86 <Sd::Mount(SdInterface::CardInfo_t*)+0x166>
    {
      // If the last byte is not an exact echo of the LSB of the kGetOp
      // command's argument, this response is invalid
      LOG_ERROR("Response integrity check failed. Aborting!");
   17e4e:	f240 2312 	movw	r3, #530	; 0x212
   17e52:	4a5f      	ldr	r2, [pc, #380]	; (17fd0 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   17e54:	4961      	ldr	r1, [pc, #388]	; (17fdc <Sd::Mount(SdInterface::CardInfo_t*)+0x2bc>)
   17e56:	4862      	ldr	r0, [pc, #392]	; (17fe0 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c0>)
   17e58:	f7ff fdb2 	bl	179c0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17e5c:	9b03      	ldr	r3, [sp, #12]
   17e5e:	681b      	ldr	r3, [r3, #0]
   17e60:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   17e62:	9b02      	ldr	r3, [sp, #8]
   17e64:	f103 0208 	add.w	r2, r3, #8
   17e68:	2300      	movs	r3, #0
   17e6a:	9301      	str	r3, [sp, #4]
   17e6c:	2300      	movs	r3, #0
   17e6e:	9300      	str	r3, [sp, #0]
   17e70:	4613      	mov	r3, r2
   17e72:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17e76:	21ff      	movs	r1, #255	; 0xff
   17e78:	9803      	ldr	r0, [sp, #12]
   17e7a:	47a0      	blx	r4
   17e7c:	4602      	mov	r2, r0
   17e7e:	9b02      	ldr	r3, [sp, #8]
   17e80:	611a      	str	r2, [r3, #16]
      return false;
   17e82:	2400      	movs	r4, #0
   17e84:	e0ce      	b.n	18024 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }
    else if (sd->response.data.byte[3] &
   17e86:	9b02      	ldr	r3, [sp, #8]
   17e88:	7adb      	ldrb	r3, [r3, #11]
   17e8a:	4619      	mov	r1, r3
             (supported_voltage == static_cast<uint64_t>(0x00)))
   17e8c:	9a04      	ldr	r2, [sp, #16]
   17e8e:	9b05      	ldr	r3, [sp, #20]
   17e90:	4313      	orrs	r3, r2
   17e92:	2b00      	cmp	r3, #0
   17e94:	bf0c      	ite	eq
   17e96:	2301      	moveq	r3, #1
   17e98:	2300      	movne	r3, #0
   17e9a:	b2db      	uxtb	r3, r3
    else if (sd->response.data.byte[3] &
   17e9c:	400b      	ands	r3, r1
   17e9e:	2b00      	cmp	r3, #0
   17ea0:	d01b      	beq.n	17eda <Sd::Mount(SdInterface::CardInfo_t*)+0x1ba>
    {
      // If the 2nd-to-last byte of the reponse AND'ed with our host
      // device's supported voltage range is 0x00, the SD card doesn't
      // support our device's operating voltage
      LOG_ERROR("Unsupported voltage in use. Aborting!");
   17ea2:	f240 231d 	movw	r3, #541	; 0x21d
   17ea6:	4a4a      	ldr	r2, [pc, #296]	; (17fd0 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   17ea8:	494e      	ldr	r1, [pc, #312]	; (17fe4 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c4>)
   17eaa:	484f      	ldr	r0, [pc, #316]	; (17fe8 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c8>)
   17eac:	f7ff fd88 	bl	179c0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17eb0:	9b03      	ldr	r3, [sp, #12]
   17eb2:	681b      	ldr	r3, [r3, #0]
   17eb4:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   17eb6:	9b02      	ldr	r3, [sp, #8]
   17eb8:	f103 0208 	add.w	r2, r3, #8
   17ebc:	2300      	movs	r3, #0
   17ebe:	9301      	str	r3, [sp, #4]
   17ec0:	2300      	movs	r3, #0
   17ec2:	9300      	str	r3, [sp, #0]
   17ec4:	4613      	mov	r3, r2
   17ec6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17eca:	21ff      	movs	r1, #255	; 0xff
   17ecc:	9803      	ldr	r0, [sp, #12]
   17ece:	47a0      	blx	r4
   17ed0:	4602      	mov	r2, r0
   17ed2:	9b02      	ldr	r3, [sp, #8]
   17ed4:	611a      	str	r2, [r3, #16]
      return false;
   17ed6:	2400      	movs	r4, #0
   17ed8:	e0a4      	b.n	18024 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Indicate that the host supports SDHC/SDXC and wait for card to
    // shift out of idle state
    LOG_DEBUG("Expressing High-Capacity SD Card Support...");
    tries = 0;
   17eda:	2300      	movs	r3, #0
   17edc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    do
    {
      // Send host's operating conditions
      sd->response.length =
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
                  KeepAlive::kYes);
   17ee0:	9b03      	ldr	r3, [sp, #12]
   17ee2:	681b      	ldr	r3, [r3, #0]
   17ee4:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
   17ee6:	9b02      	ldr	r3, [sp, #8]
   17ee8:	f103 0208 	add.w	r2, r3, #8
   17eec:	2301      	movs	r3, #1
   17eee:	9301      	str	r3, [sp, #4]
   17ef0:	2364      	movs	r3, #100	; 0x64
   17ef2:	9300      	str	r3, [sp, #0]
   17ef4:	4613      	mov	r3, r2
   17ef6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   17efa:	2141      	movs	r1, #65	; 0x41
   17efc:	9803      	ldr	r0, [sp, #12]
   17efe:	47a0      	blx	r4
   17f00:	4602      	mov	r2, r0
      sd->response.length =
   17f02:	9b02      	ldr	r3, [sp, #8]
   17f04:	611a      	str	r2, [r3, #16]
      tries++;
   17f06:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17f0a:	3301      	adds	r3, #1
   17f0c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    } while (tries < kBusTimeout && sd->response.data.byte[0] & 0x01);
   17f10:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17f14:	2bf9      	cmp	r3, #249	; 0xf9
   17f16:	d806      	bhi.n	17f26 <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
   17f18:	9b02      	ldr	r3, [sp, #8]
   17f1a:	7a1b      	ldrb	r3, [r3, #8]
   17f1c:	f003 0301 	and.w	r3, r3, #1
   17f20:	2b00      	cmp	r3, #0
   17f22:	d000      	beq.n	17f26 <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
    do
   17f24:	e7dc      	b.n	17ee0 <Sd::Mount(SdInterface::CardInfo_t*)+0x1c0>
    if (tries == kBusTimeout)
   17f26:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17f2a:	2bfa      	cmp	r3, #250	; 0xfa
   17f2c:	d11b      	bne.n	17f66 <Sd::Mount(SdInterface::CardInfo_t*)+0x246>
    {
      LOG_ERROR("SD Card timed out. Aborting!");
   17f2e:	f240 2331 	movw	r3, #561	; 0x231
   17f32:	4a27      	ldr	r2, [pc, #156]	; (17fd0 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   17f34:	492d      	ldr	r1, [pc, #180]	; (17fec <Sd::Mount(SdInterface::CardInfo_t*)+0x2cc>)
   17f36:	482e      	ldr	r0, [pc, #184]	; (17ff0 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d0>)
   17f38:	f7ff fd42 	bl	179c0 <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17f3c:	9b03      	ldr	r3, [sp, #12]
   17f3e:	681b      	ldr	r3, [r3, #0]
   17f40:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   17f42:	9b02      	ldr	r3, [sp, #8]
   17f44:	f103 0208 	add.w	r2, r3, #8
   17f48:	2300      	movs	r3, #0
   17f4a:	9301      	str	r3, [sp, #4]
   17f4c:	2300      	movs	r3, #0
   17f4e:	9300      	str	r3, [sp, #0]
   17f50:	4613      	mov	r3, r2
   17f52:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17f56:	21ff      	movs	r1, #255	; 0xff
   17f58:	9803      	ldr	r0, [sp, #12]
   17f5a:	47a0      	blx	r4
   17f5c:	4602      	mov	r2, r0
   17f5e:	9b02      	ldr	r3, [sp, #8]
   17f60:	611a      	str	r2, [r3, #16]
      return false;
   17f62:	2400      	movs	r4, #0
   17f64:	e05e      	b.n	18024 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    // After card is ready, acquire card capacity info using kGetOcr a
    // second time
    LOG_DEBUG("Reading Card Capacity Information...");
    // Read CCS
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   17f66:	9b03      	ldr	r3, [sp, #12]
   17f68:	681b      	ldr	r3, [r3, #0]
   17f6a:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
   17f6c:	9b02      	ldr	r3, [sp, #8]
   17f6e:	f103 0208 	add.w	r2, r3, #8
   17f72:	2301      	movs	r3, #1
   17f74:	9301      	str	r3, [sp, #4]
   17f76:	2364      	movs	r3, #100	; 0x64
   17f78:	9300      	str	r3, [sp, #0]
   17f7a:	4613      	mov	r3, r2
   17f7c:	2200      	movs	r2, #0
   17f7e:	217a      	movs	r1, #122	; 0x7a
   17f80:	9803      	ldr	r0, [sp, #12]
   17f82:	47a0      	blx	r4
   17f84:	4602      	mov	r2, r0
   17f86:	9b02      	ldr	r3, [sp, #8]
   17f88:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[1] & 0x40)
   17f8a:	9b02      	ldr	r3, [sp, #8]
   17f8c:	7a5b      	ldrb	r3, [r3, #9]
   17f8e:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17f92:	2b00      	cmp	r3, #0
   17f94:	d003      	beq.n	17f9e <Sd::Mount(SdInterface::CardInfo_t*)+0x27e>
    {
      // The card is either high or extended capacity
      LOG_DEBUG("SD Card is HC/XC");
      sd->type = Type::kSDHC;
   17f96:	9b02      	ldr	r3, [sp, #8]
   17f98:	2201      	movs	r2, #1
   17f9a:	605a      	str	r2, [r3, #4]
   17f9c:	e002      	b.n	17fa4 <Sd::Mount(SdInterface::CardInfo_t*)+0x284>
    }
    else
    {
      // The card is standard capacity
      LOG_DEBUG("SD Card is SC");
      sd->type = Type::kSDSC;
   17f9e:	9b02      	ldr	r3, [sp, #8]
   17fa0:	2200      	movs	r2, #0
   17fa2:	605a      	str	r2, [r3, #4]
    }

    // Store OCR information
    for (int i = 0; i < 4; i++)
   17fa4:	2300      	movs	r3, #0
   17fa6:	9308      	str	r3, [sp, #32]
   17fa8:	9b08      	ldr	r3, [sp, #32]
   17faa:	2b03      	cmp	r3, #3
   17fac:	dc22      	bgt.n	17ff4 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d4>
    {
      // ensure OCR doesn't capture the R1 section of the response
      sd->ocr.byte[i] = sd->response.data.byte[i + 1];
   17fae:	9b08      	ldr	r3, [sp, #32]
   17fb0:	3301      	adds	r3, #1
   17fb2:	9a02      	ldr	r2, [sp, #8]
   17fb4:	4413      	add	r3, r2
   17fb6:	7a19      	ldrb	r1, [r3, #8]
   17fb8:	9a02      	ldr	r2, [sp, #8]
   17fba:	9b08      	ldr	r3, [sp, #32]
   17fbc:	4413      	add	r3, r2
   17fbe:	460a      	mov	r2, r1
   17fc0:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < 4; i++)
   17fc2:	9b08      	ldr	r3, [sp, #32]
   17fc4:	3301      	adds	r3, #1
   17fc6:	9308      	str	r3, [sp, #32]
   17fc8:	e7ee      	b.n	17fa8 <Sd::Mount(SdInterface::CardInfo_t*)+0x288>
   17fca:	bf00      	nop
   17fcc:	00017d21 	.word	0x00017d21
   17fd0:	0001c178 	.word	0x0001c178
   17fd4:	0001c088 	.word	0x0001c088
   17fd8:	0001b71c 	.word	0x0001b71c
   17fdc:	0001c090 	.word	0x0001c090
   17fe0:	0001b78c 	.word	0x0001b78c
   17fe4:	0001c098 	.word	0x0001c098
   17fe8:	0001b7f0 	.word	0x0001b7f0
   17fec:	0001c0a0 	.word	0x0001c0a0
   17ff0:	0001b850 	.word	0x0001b850
    }

    // If card is SDSC, manually set its block size
    if (sd->type == Type::kSDSC)
   17ff4:	9b02      	ldr	r3, [sp, #8]
   17ff6:	685b      	ldr	r3, [r3, #4]
   17ff8:	2b00      	cmp	r3, #0
   17ffa:	d112      	bne.n	18022 <Sd::Mount(SdInterface::CardInfo_t*)+0x302>
    {
      // Send requested byte size
      sd->response.length =
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
                  sd->response.data.byte, 0, KeepAlive::kYes);
   17ffc:	9b03      	ldr	r3, [sp, #12]
   17ffe:	681b      	ldr	r3, [r3, #0]
   18000:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
   18002:	9b02      	ldr	r3, [sp, #8]
   18004:	f103 0208 	add.w	r2, r3, #8
   18008:	2301      	movs	r3, #1
   1800a:	9301      	str	r3, [sp, #4]
   1800c:	2300      	movs	r3, #0
   1800e:	9300      	str	r3, [sp, #0]
   18010:	4613      	mov	r3, r2
   18012:	f44f 7200 	mov.w	r2, #512	; 0x200
   18016:	2150      	movs	r1, #80	; 0x50
   18018:	9803      	ldr	r0, [sp, #12]
   1801a:	47a0      	blx	r4
   1801c:	4602      	mov	r2, r0
      sd->response.length =
   1801e:	9b02      	ldr	r3, [sp, #8]
   18020:	611a      	str	r2, [r3, #16]
    }

    return true;
   18022:	2401      	movs	r4, #1
   18024:	462b      	mov	r3, r5
   18026:	4619      	mov	r1, r3
   18028:	4803      	ldr	r0, [pc, #12]	; (18038 <Sd::Mount(SdInterface::CardInfo_t*)+0x318>)
   1802a:	f7fd f8f9 	bl	15220 <__cyg_profile_func_exit>
   1802e:	4623      	mov	r3, r4
  }
   18030:	4618      	mov	r0, r3
   18032:	b00b      	add	sp, #44	; 0x2c
   18034:	bd30      	pop	{r4, r5, pc}
   18036:	bf00      	nop
   18038:	00017d21 	.word	0x00017d21

0001803c <Sd::ToBool(bool)>:

  // Returns string to represent a boolean value
  const char * ToBool(bool condition)
   1803c:	b530      	push	{r4, r5, lr}
   1803e:	b083      	sub	sp, #12
   18040:	4675      	mov	r5, lr
   18042:	9001      	str	r0, [sp, #4]
   18044:	460b      	mov	r3, r1
   18046:	f88d 3003 	strb.w	r3, [sp, #3]
   1804a:	462b      	mov	r3, r5
   1804c:	4619      	mov	r1, r3
   1804e:	4809      	ldr	r0, [pc, #36]	; (18074 <Sd::ToBool(bool)+0x38>)
   18050:	f7fd f8d2 	bl	151f8 <__cyg_profile_func_enter>
  {
    return (condition) ? "true" : "false";
   18054:	f89d 3003 	ldrb.w	r3, [sp, #3]
   18058:	2b00      	cmp	r3, #0
   1805a:	d001      	beq.n	18060 <Sd::ToBool(bool)+0x24>
   1805c:	4c06      	ldr	r4, [pc, #24]	; (18078 <Sd::ToBool(bool)+0x3c>)
   1805e:	e000      	b.n	18062 <Sd::ToBool(bool)+0x26>
   18060:	4c06      	ldr	r4, [pc, #24]	; (1807c <Sd::ToBool(bool)+0x40>)
   18062:	462b      	mov	r3, r5
   18064:	4619      	mov	r1, r3
   18066:	4803      	ldr	r0, [pc, #12]	; (18074 <Sd::ToBool(bool)+0x38>)
   18068:	f7fd f8da 	bl	15220 <__cyg_profile_func_exit>
   1806c:	4623      	mov	r3, r4
  }
   1806e:	4618      	mov	r0, r3
   18070:	b003      	add	sp, #12
   18072:	bd30      	pop	{r4, r5, pc}
   18074:	0001803d 	.word	0x0001803d
   18078:	0001b8a8 	.word	0x0001b8a8
   1807c:	0001b8b0 	.word	0x0001b8b0

00018080 <Sd::WaitToReadBlock()>:

  // Waits for the card to respond after a single or multi block read cmd is
  // sent.
  void WaitToReadBlock()
   18080:	b510      	push	{r4, lr}
   18082:	b084      	sub	sp, #16
   18084:	4674      	mov	r4, lr
   18086:	9001      	str	r0, [sp, #4]
   18088:	4623      	mov	r3, r4
   1808a:	4619      	mov	r1, r3
   1808c:	4814      	ldr	r0, [pc, #80]	; (180e0 <Sd::WaitToReadBlock()+0x60>)
   1808e:	f7fd f8b3 	bl	151f8 <__cyg_profile_func_enter>
    // Bit 4 -->  If set, card is locked
    // Bit 3 -->  If set, address is out or range
    // Bit 2 -->  If set, card ECC failed
    // Bit 1 -->  If set, CC error occurred
    // Bit 0 -->  If set, a generic error occurred
    uint8_t wait_byte = 0x00;
   18092:	2300      	movs	r3, #0
   18094:	f88d 300f 	strb.w	r3, [sp, #15]
    do
    {
      wait_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18098:	9b01      	ldr	r3, [sp, #4]
   1809a:	685a      	ldr	r2, [r3, #4]
   1809c:	9b01      	ldr	r3, [sp, #4]
   1809e:	685b      	ldr	r3, [r3, #4]
   180a0:	681b      	ldr	r3, [r3, #0]
   180a2:	3308      	adds	r3, #8
   180a4:	681b      	ldr	r3, [r3, #0]
   180a6:	21ff      	movs	r1, #255	; 0xff
   180a8:	4610      	mov	r0, r2
   180aa:	4798      	blx	r3
   180ac:	4603      	mov	r3, r0
   180ae:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (wait_byte != 0xFE && (wait_byte & 0xE0) != 0x00);
   180b2:	f89d 300f 	ldrb.w	r3, [sp, #15]
   180b6:	2bfe      	cmp	r3, #254	; 0xfe
   180b8:	d006      	beq.n	180c8 <Sd::WaitToReadBlock()+0x48>
   180ba:	f89d 300f 	ldrb.w	r3, [sp, #15]
   180be:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   180c2:	2b00      	cmp	r3, #0
   180c4:	d000      	beq.n	180c8 <Sd::WaitToReadBlock()+0x48>
    do
   180c6:	e7e7      	b.n	18098 <Sd::WaitToReadBlock()+0x18>

    // DEBUG: Check the value of the wait byte
    if (wait_byte == 0xFE)
   180c8:	f89d 300f 	ldrb.w	r3, [sp, #15]
   180cc:	2bfe      	cmp	r3, #254	; 0xfe
   180ce:	4623      	mov	r3, r4
   180d0:	4619      	mov	r1, r3
   180d2:	4803      	ldr	r0, [pc, #12]	; (180e0 <Sd::WaitToReadBlock()+0x60>)
   180d4:	f7fd f8a4 	bl	15220 <__cyg_profile_func_exit>
      LOG_DEBUG("Addr Out of Range?: %s", ToBool(wait_byte & 0x08));
      LOG_DEBUG("Card ECC Failed?: %s", ToBool(wait_byte & 0x04));
      LOG_DEBUG("CC Error?: %s", ToBool(wait_byte & 0x02));
      LOG_DEBUG("Error?: %s", ToBool(wait_byte & 0x01));
    }
  }
   180d8:	bf00      	nop
   180da:	b004      	add	sp, #16
   180dc:	bd10      	pop	{r4, pc}
   180de:	bf00      	nop
   180e0:	00018081 	.word	0x00018081

000180e4 <Sd::WaitWhileBusy()>:

  // Waits for the card to be ready to receive a new block after one has
  // been written or erased
  void WaitWhileBusy()
   180e4:	b510      	push	{r4, lr}
   180e6:	b084      	sub	sp, #16
   180e8:	4674      	mov	r4, lr
   180ea:	9001      	str	r0, [sp, #4]
   180ec:	4623      	mov	r3, r4
   180ee:	4619      	mov	r1, r3
   180f0:	480f      	ldr	r0, [pc, #60]	; (18130 <Sd::WaitWhileBusy()+0x4c>)
   180f2:	f7fd f881 	bl	151f8 <__cyg_profile_func_enter>
  {
    // Wait for the card to finish programming (i.e. when the
    // bytes return to 0xFF)
    uint8_t busy_byte = 0x00;
   180f6:	2300      	movs	r3, #0
   180f8:	f88d 300f 	strb.w	r3, [sp, #15]
    LOG_DEBUG("Card is busy. Waiting for it to finish...");
    do
    {
      busy_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   180fc:	9b01      	ldr	r3, [sp, #4]
   180fe:	685a      	ldr	r2, [r3, #4]
   18100:	9b01      	ldr	r3, [sp, #4]
   18102:	685b      	ldr	r3, [r3, #4]
   18104:	681b      	ldr	r3, [r3, #0]
   18106:	3308      	adds	r3, #8
   18108:	681b      	ldr	r3, [r3, #0]
   1810a:	21ff      	movs	r1, #255	; 0xff
   1810c:	4610      	mov	r0, r2
   1810e:	4798      	blx	r3
   18110:	4603      	mov	r3, r0
   18112:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (busy_byte != 0xFF);
   18116:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1811a:	2bff      	cmp	r3, #255	; 0xff
   1811c:	d000      	beq.n	18120 <Sd::WaitWhileBusy()+0x3c>
    do
   1811e:	e7ed      	b.n	180fc <Sd::WaitWhileBusy()+0x18>
   18120:	4623      	mov	r3, r4
   18122:	4619      	mov	r1, r3
   18124:	4802      	ldr	r0, [pc, #8]	; (18130 <Sd::WaitWhileBusy()+0x4c>)
   18126:	f7fd f87b 	bl	15220 <__cyg_profile_func_exit>
    LOG_DEBUG("Card finished!");
  }
   1812a:	bf00      	nop
   1812c:	b004      	add	sp, #16
   1812e:	bd10      	pop	{r4, pc}
   18130:	000180e5 	.word	0x000180e5

00018134 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)>:

  // Read any number of blocks from the SD card
  uint8_t ReadBlock(uint32_t address, uint8_t * array,
   18134:	b530      	push	{r4, r5, lr}
   18136:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
   1813a:	4675      	mov	r5, lr
   1813c:	ac05      	add	r4, sp, #20
   1813e:	6020      	str	r0, [r4, #0]
   18140:	a804      	add	r0, sp, #16
   18142:	6001      	str	r1, [r0, #0]
   18144:	a903      	add	r1, sp, #12
   18146:	600a      	str	r2, [r1, #0]
   18148:	aa02      	add	r2, sp, #8
   1814a:	6013      	str	r3, [r2, #0]
   1814c:	462b      	mov	r3, r5
   1814e:	4619      	mov	r1, r3
   18150:	487d      	ldr	r0, [pc, #500]	; (18348 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x214>)
   18152:	f7fd f851 	bl	151f8 <__cyg_profile_func_enter>
                    uint32_t blocks = 1) override
  {
    LOG_DEBUG("Block %" PRId32 " :: 0x%" PRIX32 " for %" PRId32 " blocks",
              address, address, blocks);
    // Wait for a previous command to finish
    WaitWhileBusy();
   18156:	ab05      	add	r3, sp, #20
   18158:	6818      	ldr	r0, [r3, #0]
   1815a:	f7ff ffc3 	bl	180e4 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool payload_had_bad_crc = false;
   1815e:	2300      	movs	r3, #0
   18160:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247

    // Create a temporary place to store blocks of 512 bytes (this is now
    // possible because the constructor enforces block size cross-
    // compatibility)
    uint8_t block_store[512] = { 0 };
   18164:	ab06      	add	r3, sp, #24
   18166:	4618      	mov	r0, r3
   18168:	f44f 7300 	mov.w	r3, #512	; 0x200
   1816c:	461a      	mov	r2, r3
   1816e:	2100      	movs	r1, #0
   18170:	f001 f96b 	bl	1944a <memset>

    // Determine appropriate command to send
    Command read_cmd;
    if (blocks > 1)
   18174:	ab02      	add	r3, sp, #8
   18176:	681b      	ldr	r3, [r3, #0]
   18178:	2b01      	cmp	r3, #1
   1817a:	d902      	bls.n	18182 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x4e>
    {
      read_cmd = Command::kReadMulti;
   1817c:	2352      	movs	r3, #82	; 0x52
   1817e:	9390      	str	r3, [sp, #576]	; 0x240
   18180:	e001      	b.n	18186 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x52>
    }
    else
    {
      read_cmd = Command::kReadSingle;
   18182:	2351      	movs	r3, #81	; 0x51
   18184:	9390      	str	r3, [sp, #576]	; 0x240
    }

    // Send initial read command
    sd.response.length =
        SendCmd(read_cmd, address, sd.response.data.byte, 100, KeepAlive::kYes);
   18186:	ab05      	add	r3, sp, #20
   18188:	681b      	ldr	r3, [r3, #0]
   1818a:	681b      	ldr	r3, [r3, #0]
   1818c:	681c      	ldr	r4, [r3, #0]
   1818e:	ab86      	add	r3, sp, #536	; 0x218
   18190:	f103 0108 	add.w	r1, r3, #8
   18194:	aa04      	add	r2, sp, #16
   18196:	a805      	add	r0, sp, #20
   18198:	2301      	movs	r3, #1
   1819a:	9301      	str	r3, [sp, #4]
   1819c:	2364      	movs	r3, #100	; 0x64
   1819e:	9300      	str	r3, [sp, #0]
   181a0:	460b      	mov	r3, r1
   181a2:	6812      	ldr	r2, [r2, #0]
   181a4:	9990      	ldr	r1, [sp, #576]	; 0x240
   181a6:	6800      	ldr	r0, [r0, #0]
   181a8:	47a0      	blx	r4
   181aa:	4603      	mov	r3, r0
    sd.response.length =
   181ac:	938a      	str	r3, [sp, #552]	; 0x228
    LOG_DEBUG("Sent Read Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the command was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   181ae:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   181b2:	2b00      	cmp	r3, #0
   181b4:	f040 80d8 	bne.w	18368 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x234>
    {
      // For every block requested
      uint16_t block_count;
      for (block_count = 0; block_count < blocks; block_count++)
   181b8:	2300      	movs	r3, #0
   181ba:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   181be:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   181c2:	aa02      	add	r2, sp, #8
   181c4:	6812      	ldr	r2, [r2, #0]
   181c6:	429a      	cmp	r2, r3
   181c8:	f240 8099 	bls.w	182fe <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1ca>
      {
        // Wait for the card to respond with a ready signal
        WaitToReadBlock();
   181cc:	ab05      	add	r3, sp, #20
   181ce:	6818      	ldr	r0, [r3, #0]
   181d0:	f7ff ff56 	bl	18080 <Sd::WaitToReadBlock()>

        // Calculate the block address offset
        uint16_t block_addr_offset =
   181d4:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   181d8:	025b      	lsls	r3, r3, #9
   181da:	f8ad 323a 	strh.w	r3, [sp, #570]	; 0x23a
            static_cast<uint16_t>(block_count * kBlockSize);

        // Read all the bytes of a single block
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   181de:	2300      	movs	r3, #0
   181e0:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   181e4:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   181e8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   181ec:	d22b      	bcs.n	18246 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x112>
        {
          // Calculate the current storage index
          uint16_t storage_index =
   181ee:	f8bd 223a 	ldrh.w	r2, [sp, #570]	; 0x23a
   181f2:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   181f6:	4413      	add	r3, r2
   181f8:	f8ad 3238 	strh.w	r3, [sp, #568]	; 0x238
              static_cast<uint16_t>(block_addr_offset + byte_count);

          // Transfer a byte to read a block from the SD card
          array[storage_index] =
              static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   181fc:	ab05      	add	r3, sp, #20
   181fe:	681b      	ldr	r3, [r3, #0]
   18200:	685a      	ldr	r2, [r3, #4]
   18202:	ab05      	add	r3, sp, #20
   18204:	681b      	ldr	r3, [r3, #0]
   18206:	685b      	ldr	r3, [r3, #4]
   18208:	681b      	ldr	r3, [r3, #0]
   1820a:	3308      	adds	r3, #8
   1820c:	681b      	ldr	r3, [r3, #0]
   1820e:	21ff      	movs	r1, #255	; 0xff
   18210:	4610      	mov	r0, r2
   18212:	4798      	blx	r3
   18214:	4603      	mov	r3, r0
   18216:	4619      	mov	r1, r3
          array[storage_index] =
   18218:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   1821c:	aa03      	add	r2, sp, #12
   1821e:	6812      	ldr	r2, [r2, #0]
   18220:	4413      	add	r3, r2
   18222:	b2ca      	uxtb	r2, r1
   18224:	701a      	strb	r2, [r3, #0]

          // Copy that byte into our temporary block store
          block_store[byte_count] = array[storage_index];
   18226:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   1822a:	aa03      	add	r2, sp, #12
   1822c:	6812      	ldr	r2, [r2, #0]
   1822e:	441a      	add	r2, r3
   18230:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   18234:	7811      	ldrb	r1, [r2, #0]
   18236:	aa06      	add	r2, sp, #24
   18238:	54d1      	strb	r1, [r2, r3]
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   1823a:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   1823e:	3301      	adds	r3, #1
   18240:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   18244:	e7ce      	b.n	181e4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0xb0>
        }

        // Then read the block's 16-bit CRC (i.e. read two bytes)
        uint16_t block_crc =
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   18246:	ab05      	add	r3, sp, #20
   18248:	681b      	ldr	r3, [r3, #0]
   1824a:	685a      	ldr	r2, [r3, #4]
   1824c:	ab05      	add	r3, sp, #20
   1824e:	681b      	ldr	r3, [r3, #0]
   18250:	685b      	ldr	r3, [r3, #4]
   18252:	681b      	ldr	r3, [r3, #0]
   18254:	3308      	adds	r3, #8
   18256:	681b      	ldr	r3, [r3, #0]
   18258:	21ff      	movs	r1, #255	; 0xff
   1825a:	4610      	mov	r0, r2
   1825c:	4798      	blx	r3
   1825e:	4603      	mov	r3, r0
   18260:	021b      	lsls	r3, r3, #8
   18262:	b21c      	sxth	r4, r3
                                  ssp_interface_->Transfer(0xFF));
   18264:	ab05      	add	r3, sp, #20
   18266:	681b      	ldr	r3, [r3, #0]
   18268:	685a      	ldr	r2, [r3, #4]
   1826a:	ab05      	add	r3, sp, #20
   1826c:	681b      	ldr	r3, [r3, #0]
   1826e:	685b      	ldr	r3, [r3, #4]
   18270:	681b      	ldr	r3, [r3, #0]
   18272:	3308      	adds	r3, #8
   18274:	681b      	ldr	r3, [r3, #0]
   18276:	21ff      	movs	r1, #255	; 0xff
   18278:	4610      	mov	r0, r2
   1827a:	4798      	blx	r3
   1827c:	4603      	mov	r3, r0
   1827e:	b21b      	sxth	r3, r3
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   18280:	4323      	orrs	r3, r4
   18282:	b21b      	sxth	r3, r3
                                  ssp_interface_->Transfer(0xFF));
   18284:	f8ad 3236 	strh.w	r3, [sp, #566]	; 0x236

        // Run a CRC-16 calculation on the message to determine if the
        // received CRCs match (i.e. checks if the block data is
        // valid).
        uint16_t expected_block_crc = GetCrc16(block_store, 512);
   18288:	ab05      	add	r3, sp, #20
   1828a:	681b      	ldr	r3, [r3, #0]
   1828c:	681b      	ldr	r3, [r3, #0]
   1828e:	3320      	adds	r3, #32
   18290:	681b      	ldr	r3, [r3, #0]
   18292:	a906      	add	r1, sp, #24
   18294:	a805      	add	r0, sp, #20
   18296:	f44f 7200 	mov.w	r2, #512	; 0x200
   1829a:	6800      	ldr	r0, [r0, #0]
   1829c:	4798      	blx	r3
   1829e:	4603      	mov	r3, r0
   182a0:	f8ad 3234 	strh.w	r3, [sp, #564]	; 0x234

        LOG_DEBUG("Block #%d @ 0x%" PRIX32 " acquired", block_count, address);
        LOG_DEBUG("Expecting block crc16 '0x%04X'", expected_block_crc);
        LOG_DEBUG("Got '0x%04X'", block_crc);
        if (expected_block_crc != block_crc)
   182a4:	f8bd 2234 	ldrh.w	r2, [sp, #564]	; 0x234
   182a8:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   182ac:	429a      	cmp	r2, r3
   182ae:	d020      	beq.n	182f2 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1be>
        {
          // If they do not match, set the bad crc status
          payload_had_bad_crc = true;
   182b0:	2301      	movs	r3, #1
   182b2:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247
          LOG_ERROR("While Reading Block #%d CRC16:", block_count);
   182b6:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   182ba:	9300      	str	r3, [sp, #0]
   182bc:	f240 23ed 	movw	r3, #749	; 0x2ed
   182c0:	4a22      	ldr	r2, [pc, #136]	; (1834c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   182c2:	4923      	ldr	r1, [pc, #140]	; (18350 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x21c>)
   182c4:	4823      	ldr	r0, [pc, #140]	; (18354 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x220>)
   182c6:	f7ff fb7b 	bl	179c0 <printf>
          LOG_ERROR("Expected '0x%04X'", expected_block_crc);
   182ca:	f8bd 3234 	ldrh.w	r3, [sp, #564]	; 0x234
   182ce:	9300      	str	r3, [sp, #0]
   182d0:	f240 23ee 	movw	r3, #750	; 0x2ee
   182d4:	4a1d      	ldr	r2, [pc, #116]	; (1834c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   182d6:	4920      	ldr	r1, [pc, #128]	; (18358 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x224>)
   182d8:	4820      	ldr	r0, [pc, #128]	; (1835c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x228>)
   182da:	f7ff fb71 	bl	179c0 <printf>
          LOG_ERROR("Got '0x%04X'", block_crc);
   182de:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   182e2:	9300      	str	r3, [sp, #0]
   182e4:	f240 23ef 	movw	r3, #751	; 0x2ef
   182e8:	4a18      	ldr	r2, [pc, #96]	; (1834c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   182ea:	491d      	ldr	r1, [pc, #116]	; (18360 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x22c>)
   182ec:	481d      	ldr	r0, [pc, #116]	; (18364 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x230>)
   182ee:	f7ff fb67 	bl	179c0 <printf>
      for (block_count = 0; block_count < blocks; block_count++)
   182f2:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   182f6:	3301      	adds	r3, #1
   182f8:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   182fc:	e75f      	b.n	181be <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x8a>
        }
      }

      // After reading multiple blocks, send the stop command to terminate the
      // transaction (i.e. no keep-alive)
      if (blocks > 1)
   182fe:	ab02      	add	r3, sp, #8
   18300:	681b      	ldr	r3, [r3, #0]
   18302:	2b01      	cmp	r3, #1
   18304:	d913      	bls.n	1832e <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1fa>
      {
        sd.response.length =
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
                    KeepAlive::kNo);
   18306:	ab05      	add	r3, sp, #20
   18308:	681b      	ldr	r3, [r3, #0]
   1830a:	681b      	ldr	r3, [r3, #0]
   1830c:	681c      	ldr	r4, [r3, #0]
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
   1830e:	ab86      	add	r3, sp, #536	; 0x218
   18310:	f103 0208 	add.w	r2, r3, #8
   18314:	a805      	add	r0, sp, #20
   18316:	2300      	movs	r3, #0
   18318:	9301      	str	r3, [sp, #4]
   1831a:	2364      	movs	r3, #100	; 0x64
   1831c:	9300      	str	r3, [sp, #0]
   1831e:	4613      	mov	r3, r2
   18320:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18324:	214c      	movs	r1, #76	; 0x4c
   18326:	6800      	ldr	r0, [r0, #0]
   18328:	47a0      	blx	r4
   1832a:	4603      	mov	r3, r0
        sd.response.length =
   1832c:	938a      	str	r3, [sp, #552]	; 0x228
      LOG_DEBUG("Response Byte");
      LOG_DEBUG("0x%02X", sd.response.data.byte[0]);

      // If there was a bad crc from the payload, manually set the
      // CRC error flag in the command response byte
      if (payload_had_bad_crc)
   1832e:	f89d 3247 	ldrb.w	r3, [sp, #583]	; 0x247
   18332:	2b00      	cmp	r3, #0
   18334:	f000 80c0 	beq.w	184b8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
      {
        sd.response.data.byte[0] |= 0x08;
   18338:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   1833c:	f043 0308 	orr.w	r3, r3, #8
   18340:	b2db      	uxtb	r3, r3
   18342:	f88d 3220 	strb.w	r3, [sp, #544]	; 0x220
   18346:	e0b7      	b.n	184b8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
   18348:	00018135 	.word	0x00018135
   1834c:	0001c1ac 	.word	0x0001c1ac
   18350:	0001c0a8 	.word	0x0001c0a8
   18354:	0001b8b8 	.word	0x0001b8b8
   18358:	0001c0b0 	.word	0x0001c0b0
   1835c:	0001b910 	.word	0x0001b910
   18360:	0001c0b8 	.word	0x0001c0b8
   18364:	0001b95c 	.word	0x0001b95c
      }
    }
    else
    {
      LOG_ERROR("Read Cmd was not acknowledged properly!");
   18368:	f240 3309 	movw	r3, #777	; 0x309
   1836c:	4a65      	ldr	r2, [pc, #404]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   1836e:	4966      	ldr	r1, [pc, #408]	; (18508 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d4>)
   18370:	4866      	ldr	r0, [pc, #408]	; (1850c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d8>)
   18372:	f7ff fb25 	bl	179c0 <printf>
      LOG_ERROR("Parameter Err: %s", ToBool(sd.response.data.byte[0] & 0x40));
   18376:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   1837a:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1837e:	2b00      	cmp	r3, #0
   18380:	bf14      	ite	ne
   18382:	2301      	movne	r3, #1
   18384:	2300      	moveq	r3, #0
   18386:	b2da      	uxtb	r2, r3
   18388:	ab05      	add	r3, sp, #20
   1838a:	4611      	mov	r1, r2
   1838c:	6818      	ldr	r0, [r3, #0]
   1838e:	f7ff fe55 	bl	1803c <Sd::ToBool(bool)>
   18392:	4603      	mov	r3, r0
   18394:	9300      	str	r3, [sp, #0]
   18396:	f240 330a 	movw	r3, #778	; 0x30a
   1839a:	4a5a      	ldr	r2, [pc, #360]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   1839c:	495c      	ldr	r1, [pc, #368]	; (18510 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3dc>)
   1839e:	485d      	ldr	r0, [pc, #372]	; (18514 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e0>)
   183a0:	f7ff fb0e 	bl	179c0 <printf>
      LOG_ERROR("Addr Err: %s", ToBool(sd.response.data.byte[0] & 0x20));
   183a4:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   183a8:	f003 0320 	and.w	r3, r3, #32
   183ac:	2b00      	cmp	r3, #0
   183ae:	bf14      	ite	ne
   183b0:	2301      	movne	r3, #1
   183b2:	2300      	moveq	r3, #0
   183b4:	b2da      	uxtb	r2, r3
   183b6:	ab05      	add	r3, sp, #20
   183b8:	4611      	mov	r1, r2
   183ba:	6818      	ldr	r0, [r3, #0]
   183bc:	f7ff fe3e 	bl	1803c <Sd::ToBool(bool)>
   183c0:	4603      	mov	r3, r0
   183c2:	9300      	str	r3, [sp, #0]
   183c4:	f240 330b 	movw	r3, #779	; 0x30b
   183c8:	4a4e      	ldr	r2, [pc, #312]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   183ca:	4953      	ldr	r1, [pc, #332]	; (18518 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e4>)
   183cc:	4853      	ldr	r0, [pc, #332]	; (1851c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e8>)
   183ce:	f7ff faf7 	bl	179c0 <printf>
      LOG_ERROR("Erase Seq Err: %s", ToBool(sd.response.data.byte[0] & 0x10));
   183d2:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   183d6:	f003 0310 	and.w	r3, r3, #16
   183da:	2b00      	cmp	r3, #0
   183dc:	bf14      	ite	ne
   183de:	2301      	movne	r3, #1
   183e0:	2300      	moveq	r3, #0
   183e2:	b2da      	uxtb	r2, r3
   183e4:	ab05      	add	r3, sp, #20
   183e6:	4611      	mov	r1, r2
   183e8:	6818      	ldr	r0, [r3, #0]
   183ea:	f7ff fe27 	bl	1803c <Sd::ToBool(bool)>
   183ee:	4603      	mov	r3, r0
   183f0:	9300      	str	r3, [sp, #0]
   183f2:	f44f 7343 	mov.w	r3, #780	; 0x30c
   183f6:	4a43      	ldr	r2, [pc, #268]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   183f8:	4949      	ldr	r1, [pc, #292]	; (18520 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3ec>)
   183fa:	484a      	ldr	r0, [pc, #296]	; (18524 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f0>)
   183fc:	f7ff fae0 	bl	179c0 <printf>
      LOG_ERROR("Com CRC Err: %s", ToBool(sd.response.data.byte[0] & 0x08));
   18400:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18404:	f003 0308 	and.w	r3, r3, #8
   18408:	2b00      	cmp	r3, #0
   1840a:	bf14      	ite	ne
   1840c:	2301      	movne	r3, #1
   1840e:	2300      	moveq	r3, #0
   18410:	b2da      	uxtb	r2, r3
   18412:	ab05      	add	r3, sp, #20
   18414:	4611      	mov	r1, r2
   18416:	6818      	ldr	r0, [r3, #0]
   18418:	f7ff fe10 	bl	1803c <Sd::ToBool(bool)>
   1841c:	4603      	mov	r3, r0
   1841e:	9300      	str	r3, [sp, #0]
   18420:	f240 330d 	movw	r3, #781	; 0x30d
   18424:	4a37      	ldr	r2, [pc, #220]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   18426:	4940      	ldr	r1, [pc, #256]	; (18528 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f4>)
   18428:	4840      	ldr	r0, [pc, #256]	; (1852c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f8>)
   1842a:	f7ff fac9 	bl	179c0 <printf>
      LOG_ERROR("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
   1842e:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18432:	f003 0304 	and.w	r3, r3, #4
   18436:	2b00      	cmp	r3, #0
   18438:	bf14      	ite	ne
   1843a:	2301      	movne	r3, #1
   1843c:	2300      	moveq	r3, #0
   1843e:	b2da      	uxtb	r2, r3
   18440:	ab05      	add	r3, sp, #20
   18442:	4611      	mov	r1, r2
   18444:	6818      	ldr	r0, [r3, #0]
   18446:	f7ff fdf9 	bl	1803c <Sd::ToBool(bool)>
   1844a:	4603      	mov	r3, r0
   1844c:	9300      	str	r3, [sp, #0]
   1844e:	f240 330e 	movw	r3, #782	; 0x30e
   18452:	4a2c      	ldr	r2, [pc, #176]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   18454:	4936      	ldr	r1, [pc, #216]	; (18530 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3fc>)
   18456:	4837      	ldr	r0, [pc, #220]	; (18534 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x400>)
   18458:	f7ff fab2 	bl	179c0 <printf>
      LOG_ERROR("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
   1845c:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   18460:	f003 0302 	and.w	r3, r3, #2
   18464:	2b00      	cmp	r3, #0
   18466:	bf14      	ite	ne
   18468:	2301      	movne	r3, #1
   1846a:	2300      	moveq	r3, #0
   1846c:	b2da      	uxtb	r2, r3
   1846e:	ab05      	add	r3, sp, #20
   18470:	4611      	mov	r1, r2
   18472:	6818      	ldr	r0, [r3, #0]
   18474:	f7ff fde2 	bl	1803c <Sd::ToBool(bool)>
   18478:	4603      	mov	r3, r0
   1847a:	9300      	str	r3, [sp, #0]
   1847c:	f240 330f 	movw	r3, #783	; 0x30f
   18480:	4a20      	ldr	r2, [pc, #128]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   18482:	492d      	ldr	r1, [pc, #180]	; (18538 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x404>)
   18484:	482d      	ldr	r0, [pc, #180]	; (1853c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x408>)
   18486:	f7ff fa9b 	bl	179c0 <printf>
      LOG_ERROR("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
   1848a:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   1848e:	f003 0301 	and.w	r3, r3, #1
   18492:	2b00      	cmp	r3, #0
   18494:	bf14      	ite	ne
   18496:	2301      	movne	r3, #1
   18498:	2300      	moveq	r3, #0
   1849a:	b2da      	uxtb	r2, r3
   1849c:	ab05      	add	r3, sp, #20
   1849e:	4611      	mov	r1, r2
   184a0:	6818      	ldr	r0, [r3, #0]
   184a2:	f7ff fdcb 	bl	1803c <Sd::ToBool(bool)>
   184a6:	4603      	mov	r3, r0
   184a8:	9300      	str	r3, [sp, #0]
   184aa:	f44f 7344 	mov.w	r3, #784	; 0x310
   184ae:	4a15      	ldr	r2, [pc, #84]	; (18504 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   184b0:	4923      	ldr	r1, [pc, #140]	; (18540 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x40c>)
   184b2:	4824      	ldr	r0, [pc, #144]	; (18544 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x410>)
   184b4:	f7ff fa84 	bl	179c0 <printf>
    LOG_DEBUG("Now waiting for SD Card to exit Idle Mode...");
    do
    {
      // Query the status register
      sd.response.length = SendCmd(Command::kGetStatus, 32,
                                   sd.response.data.byte, 0, KeepAlive::kNo);
   184b8:	ab05      	add	r3, sp, #20
   184ba:	681b      	ldr	r3, [r3, #0]
   184bc:	681b      	ldr	r3, [r3, #0]
   184be:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kGetStatus, 32,
   184c0:	ab86      	add	r3, sp, #536	; 0x218
   184c2:	f103 0208 	add.w	r2, r3, #8
   184c6:	a805      	add	r0, sp, #20
   184c8:	2300      	movs	r3, #0
   184ca:	9301      	str	r3, [sp, #4]
   184cc:	2300      	movs	r3, #0
   184ce:	9300      	str	r3, [sp, #0]
   184d0:	4613      	mov	r3, r2
   184d2:	2220      	movs	r2, #32
   184d4:	210d      	movs	r1, #13
   184d6:	6800      	ldr	r0, [r0, #0]
   184d8:	47a0      	blx	r4
   184da:	4603      	mov	r3, r0
   184dc:	938a      	str	r3, [sp, #552]	; 0x228
    } while (sd.response.data.byte[0] & 0x01);
   184de:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   184e2:	f003 0301 	and.w	r3, r3, #1
   184e6:	2b00      	cmp	r3, #0
   184e8:	d000      	beq.n	184ec <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3b8>
    do
   184ea:	e7e5      	b.n	184b8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
    LOG_DEBUG("SD Card is out of Idle Mode!");

    // Return the status
    LOG_DEBUG("Read Complete! [R1 Response: 0x%02X]", sd.response.data.byte[0]);
    return sd.response.data.byte[0];
   184ec:	f89d 4220 	ldrb.w	r4, [sp, #544]	; 0x220
   184f0:	462b      	mov	r3, r5
   184f2:	4619      	mov	r1, r3
   184f4:	4814      	ldr	r0, [pc, #80]	; (18548 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x414>)
   184f6:	f7fc fe93 	bl	15220 <__cyg_profile_func_exit>
   184fa:	4623      	mov	r3, r4
  }
   184fc:	4618      	mov	r0, r3
   184fe:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
   18502:	bd30      	pop	{r4, r5, pc}
   18504:	0001c1ac 	.word	0x0001c1ac
   18508:	0001c0c0 	.word	0x0001c0c0
   1850c:	0001b9a4 	.word	0x0001b9a4
   18510:	0001c0c8 	.word	0x0001c0c8
   18514:	0001ba08 	.word	0x0001ba08
   18518:	0001c0d0 	.word	0x0001c0d0
   1851c:	0001ba54 	.word	0x0001ba54
   18520:	0001c0d8 	.word	0x0001c0d8
   18524:	0001ba9c 	.word	0x0001ba9c
   18528:	0001c0e0 	.word	0x0001c0e0
   1852c:	0001bae8 	.word	0x0001bae8
   18530:	0001c0e8 	.word	0x0001c0e8
   18534:	0001bb34 	.word	0x0001bb34
   18538:	0001c0f0 	.word	0x0001c0f0
   1853c:	0001bb84 	.word	0x0001bb84
   18540:	0001c0f8 	.word	0x0001c0f8
   18544:	0001bbd0 	.word	0x0001bbd0
   18548:	00018135 	.word	0x00018135

0001854c <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)>:

  // Writes any number of 512-byte blocks to the SD Card
  uint8_t WriteBlock(uint32_t address, const uint8_t * array,
   1854c:	b530      	push	{r4, r5, lr}
   1854e:	b095      	sub	sp, #84	; 0x54
   18550:	4675      	mov	r5, lr
   18552:	9005      	str	r0, [sp, #20]
   18554:	9104      	str	r1, [sp, #16]
   18556:	9203      	str	r2, [sp, #12]
   18558:	9302      	str	r3, [sp, #8]
   1855a:	462b      	mov	r3, r5
   1855c:	4619      	mov	r1, r3
   1855e:	4865      	ldr	r0, [pc, #404]	; (186f4 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   18560:	f7fc fe4a 	bl	151f8 <__cyg_profile_func_enter>
                     uint32_t blocks = 1) override
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   18564:	9805      	ldr	r0, [sp, #20]
   18566:	f7ff fdbd 	bl	180e4 <Sd::WaitWhileBusy()>
    Sd::CardInfo_t sd;

    // Determine appropriate command and start token to send
    Command write_cmd;
    uint8_t write_start_tkn;
    if (blocks > 1)
   1856a:	9b02      	ldr	r3, [sp, #8]
   1856c:	2b01      	cmp	r3, #1
   1856e:	d905      	bls.n	1857c <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x30>
    {
      write_cmd       = Command::kWriteMulti;
   18570:	2359      	movs	r3, #89	; 0x59
   18572:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFC;
   18574:	23fc      	movs	r3, #252	; 0xfc
   18576:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
   1857a:	e004      	b.n	18586 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x3a>
    }
    else
    {
      write_cmd       = Command::kWriteSingle;
   1857c:	2358      	movs	r3, #88	; 0x58
   1857e:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFE;
   18580:	23fe      	movs	r3, #254	; 0xfe
   18582:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
    }

    // Send initial write command
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
                                 KeepAlive::kYes);
   18586:	9b05      	ldr	r3, [sp, #20]
   18588:	681b      	ldr	r3, [r3, #0]
   1858a:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
   1858c:	ab06      	add	r3, sp, #24
   1858e:	f103 0208 	add.w	r2, r3, #8
   18592:	2301      	movs	r3, #1
   18594:	9301      	str	r3, [sp, #4]
   18596:	2364      	movs	r3, #100	; 0x64
   18598:	9300      	str	r3, [sp, #0]
   1859a:	4613      	mov	r3, r2
   1859c:	9a04      	ldr	r2, [sp, #16]
   1859e:	9913      	ldr	r1, [sp, #76]	; 0x4c
   185a0:	9805      	ldr	r0, [sp, #20]
   185a2:	47a0      	blx	r4
   185a4:	4603      	mov	r3, r0
   185a6:	930a      	str	r3, [sp, #40]	; 0x28
    LOG_DEBUG("Sent Write Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the response was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   185a8:	f89d 3020 	ldrb.w	r3, [sp, #32]
   185ac:	2b00      	cmp	r3, #0
   185ae:	f040 8096 	bne.w	186de <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
    {
      // If no errors, proceed write given block(s) to SD Card
      // For each given block
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   185b2:	2300      	movs	r3, #0
   185b4:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   185b8:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   185bc:	9a02      	ldr	r2, [sp, #8]
   185be:	429a      	cmp	r2, r3
   185c0:	d97a      	bls.n	186b8 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x16c>
           current_block_num++)
      {
        // Calculate array offset
        uint64_t arr_offset = current_block_num * kBlockSize;
   185c2:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   185c6:	025b      	lsls	r3, r3, #9
   185c8:	ea4f 74e3 	mov.w	r4, r3, asr #31
   185cc:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38

        // Send the start token for the current block
        ssp_interface_->Transfer(write_start_tkn);
   185d0:	9b05      	ldr	r3, [sp, #20]
   185d2:	685a      	ldr	r2, [r3, #4]
   185d4:	9b05      	ldr	r3, [sp, #20]
   185d6:	685b      	ldr	r3, [r3, #4]
   185d8:	681b      	ldr	r3, [r3, #0]
   185da:	3308      	adds	r3, #8
   185dc:	681b      	ldr	r3, [r3, #0]
   185de:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
   185e2:	b289      	uxth	r1, r1
   185e4:	4610      	mov	r0, r2
   185e6:	4798      	blx	r3

        // Write all 512-bytes of the given block
        LOG_DEBUG("Writing block #%d", current_block_num);
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   185e8:	2300      	movs	r3, #0
   185ea:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   185ee:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   185f2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   185f6:	d216      	bcs.n	18626 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xda>
             current_byte++)
        {
          ssp_interface_->Transfer(array[arr_offset + current_byte]);
   185f8:	9b05      	ldr	r3, [sp, #20]
   185fa:	6858      	ldr	r0, [r3, #4]
   185fc:	9b05      	ldr	r3, [sp, #20]
   185fe:	685b      	ldr	r3, [r3, #4]
   18600:	681b      	ldr	r3, [r3, #0]
   18602:	3308      	adds	r3, #8
   18604:	681b      	ldr	r3, [r3, #0]
   18606:	990e      	ldr	r1, [sp, #56]	; 0x38
   18608:	f8bd 2046 	ldrh.w	r2, [sp, #70]	; 0x46
   1860c:	440a      	add	r2, r1
   1860e:	9903      	ldr	r1, [sp, #12]
   18610:	440a      	add	r2, r1
   18612:	7812      	ldrb	r2, [r2, #0]
   18614:	b292      	uxth	r2, r2
   18616:	4611      	mov	r1, r2
   18618:	4798      	blx	r3
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   1861a:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   1861e:	3301      	adds	r3, #1
   18620:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   18624:	e7e3      	b.n	185ee <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xa2>
        }

        // Read the data response token after writing the block
        uint8_t data_response_tkn =
            static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18626:	9b05      	ldr	r3, [sp, #20]
   18628:	685a      	ldr	r2, [r3, #4]
   1862a:	9b05      	ldr	r3, [sp, #20]
   1862c:	685b      	ldr	r3, [r3, #4]
   1862e:	681b      	ldr	r3, [r3, #0]
   18630:	3308      	adds	r3, #8
   18632:	681b      	ldr	r3, [r3, #0]
   18634:	21ff      	movs	r1, #255	; 0xff
   18636:	4610      	mov	r0, r2
   18638:	4798      	blx	r3
   1863a:	4603      	mov	r3, r0
   1863c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
                  ToBool(data_response_tkn & 0x0B));
        LOG_DEBUG("Data Rejected (write err)?: %s",
                  ToBool(data_response_tkn & 0x0D));

        // If writing multiple blocks and the previous block was rejected
        if (blocks > 1 && !(data_response_tkn & 0x05))
   18640:	9b02      	ldr	r3, [sp, #8]
   18642:	2b01      	cmp	r3, #1
   18644:	d92f      	bls.n	186a6 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
   18646:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1864a:	f003 0305 	and.w	r3, r3, #5
   1864e:	2b00      	cmp	r3, #0
   18650:	d129      	bne.n	186a6 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
        {
          // Send an immediate stop (CMD12)
          sd.response.length =
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
                      100, KeepAlive::kYes);
   18652:	9b05      	ldr	r3, [sp, #20]
   18654:	681b      	ldr	r3, [r3, #0]
   18656:	681c      	ldr	r4, [r3, #0]
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
   18658:	ab06      	add	r3, sp, #24
   1865a:	f103 0208 	add.w	r2, r3, #8
   1865e:	2301      	movs	r3, #1
   18660:	9301      	str	r3, [sp, #4]
   18662:	2364      	movs	r3, #100	; 0x64
   18664:	9300      	str	r3, [sp, #0]
   18666:	4613      	mov	r3, r2
   18668:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1866c:	214c      	movs	r1, #76	; 0x4c
   1866e:	9805      	ldr	r0, [sp, #20]
   18670:	47a0      	blx	r4
   18672:	4603      	mov	r3, r0
          sd.response.length =
   18674:	930a      	str	r3, [sp, #40]	; 0x28
          LOG_DEBUG("Stopped Transmission due to rejection...");
          LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);

          // In the case of a write error, ask for the reason why
          if (data_response_tkn & 0x0D)
   18676:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   1867a:	f003 030d 	and.w	r3, r3, #13
   1867e:	2b00      	cmp	r3, #0
   18680:	d011      	beq.n	186a6 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
          {
            sd.response.length =
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
                        100, KeepAlive::kYes);
   18682:	9b05      	ldr	r3, [sp, #20]
   18684:	681b      	ldr	r3, [r3, #0]
   18686:	681c      	ldr	r4, [r3, #0]
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
   18688:	ab06      	add	r3, sp, #24
   1868a:	f103 0208 	add.w	r2, r3, #8
   1868e:	2301      	movs	r3, #1
   18690:	9301      	str	r3, [sp, #4]
   18692:	2364      	movs	r3, #100	; 0x64
   18694:	9300      	str	r3, [sp, #0]
   18696:	4613      	mov	r3, r2
   18698:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1869c:	210d      	movs	r1, #13
   1869e:	9805      	ldr	r0, [sp, #20]
   186a0:	47a0      	blx	r4
   186a2:	4603      	mov	r3, r0
            sd.response.length =
   186a4:	930a      	str	r3, [sp, #40]	; 0x28
                "Checking Status Register to see cause of Write Error...");
            LOG_DEBUG("[R2 Response: 0x%04" PRIX32 "]",
                      sd.response.data.dWord.lo);
          }
        }
        WaitWhileBusy();
   186a6:	9805      	ldr	r0, [sp, #20]
   186a8:	f7ff fd1c 	bl	180e4 <Sd::WaitWhileBusy()>
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   186ac:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   186b0:	3301      	adds	r3, #1
   186b2:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   186b6:	e77f      	b.n	185b8 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x6c>
      }

      if (blocks > 1)
   186b8:	9b02      	ldr	r3, [sp, #8]
   186ba:	2b01      	cmp	r3, #1
   186bc:	d90f      	bls.n	186de <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
      {
        constexpr uint8_t kStopToken = 0xFD;
   186be:	23fd      	movs	r3, #253	; 0xfd
   186c0:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
        ssp_interface_->Transfer(kStopToken);
   186c4:	9b05      	ldr	r3, [sp, #20]
   186c6:	685a      	ldr	r2, [r3, #4]
   186c8:	9b05      	ldr	r3, [sp, #20]
   186ca:	685b      	ldr	r3, [r3, #4]
   186cc:	681b      	ldr	r3, [r3, #0]
   186ce:	3308      	adds	r3, #8
   186d0:	681b      	ldr	r3, [r3, #0]
   186d2:	21fd      	movs	r1, #253	; 0xfd
   186d4:	4610      	mov	r0, r2
   186d6:	4798      	blx	r3

        // Wait for the card's programming to complete before
        // reselecting it (i.e. to prevent corruption)
        WaitWhileBusy();
   186d8:	9805      	ldr	r0, [sp, #20]
   186da:	f7ff fd03 	bl	180e4 <Sd::WaitWhileBusy()>
      LOG_DEBUG("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
      LOG_DEBUG("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
      LOG_DEBUG("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
    }

    return sd.response.data.byte[0];
   186de:	f89d 4020 	ldrb.w	r4, [sp, #32]
   186e2:	462b      	mov	r3, r5
   186e4:	4619      	mov	r1, r3
   186e6:	4803      	ldr	r0, [pc, #12]	; (186f4 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   186e8:	f7fc fd9a 	bl	15220 <__cyg_profile_func_exit>
   186ec:	4623      	mov	r3, r4
  }
   186ee:	4618      	mov	r0, r3
   186f0:	b015      	add	sp, #84	; 0x54
   186f2:	bd30      	pop	{r4, r5, pc}
   186f4:	0001854d 	.word	0x0001854d

000186f8 <Sd::DeleteBlock(unsigned long, unsigned long)>:

  // Deletes any number of blocks (inclusively) within a range of address.
  uint8_t DeleteBlock(uint32_t start, uint32_t end) override
   186f8:	b530      	push	{r4, r5, lr}
   186fa:	b08f      	sub	sp, #60	; 0x3c
   186fc:	4675      	mov	r5, lr
   186fe:	9005      	str	r0, [sp, #20]
   18700:	9104      	str	r1, [sp, #16]
   18702:	9203      	str	r2, [sp, #12]
   18704:	462b      	mov	r3, r5
   18706:	4619      	mov	r1, r3
   18708:	483d      	ldr	r0, [pc, #244]	; (18800 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   1870a:	f7fc fd75 	bl	151f8 <__cyg_profile_func_enter>
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   1870e:	9805      	ldr	r0, [sp, #20]
   18710:	f7ff fce8 	bl	180e4 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool delete_failed = false;
   18714:	2300      	movs	r3, #0
   18716:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37

    // Set the delete start address
    LOG_DEBUG("Setting Delete Start Address...");
    sd.response.length = SendCmd(Command::kDelFrom, start,
                                 sd.response.data.byte, 100, KeepAlive::kYes);
   1871a:	9b05      	ldr	r3, [sp, #20]
   1871c:	681b      	ldr	r3, [r3, #0]
   1871e:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(Command::kDelFrom, start,
   18720:	ab06      	add	r3, sp, #24
   18722:	f103 0208 	add.w	r2, r3, #8
   18726:	2301      	movs	r3, #1
   18728:	9301      	str	r3, [sp, #4]
   1872a:	2364      	movs	r3, #100	; 0x64
   1872c:	9300      	str	r3, [sp, #0]
   1872e:	4613      	mov	r3, r2
   18730:	9a04      	ldr	r2, [sp, #16]
   18732:	2160      	movs	r1, #96	; 0x60
   18734:	9805      	ldr	r0, [sp, #20]
   18736:	47a0      	blx	r4
   18738:	4603      	mov	r3, r0
   1873a:	930a      	str	r3, [sp, #40]	; 0x28

    // Wait while the writing the start address
    WaitWhileBusy();
   1873c:	9805      	ldr	r0, [sp, #20]
   1873e:	f7ff fcd1 	bl	180e4 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   18742:	f89d 3020 	ldrb.w	r3, [sp, #32]
   18746:	2b00      	cmp	r3, #0
   18748:	d009      	beq.n	1875e <Sd::DeleteBlock(unsigned long, unsigned long)+0x66>
    {
      LOG_ERROR("Failed to set Start Address!");
   1874a:	f44f 736a 	mov.w	r3, #936	; 0x3a8
   1874e:	4a2d      	ldr	r2, [pc, #180]	; (18804 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   18750:	492d      	ldr	r1, [pc, #180]	; (18808 <Sd::DeleteBlock(unsigned long, unsigned long)+0x110>)
   18752:	482e      	ldr	r0, [pc, #184]	; (1880c <Sd::DeleteBlock(unsigned long, unsigned long)+0x114>)
   18754:	f7ff f934 	bl	179c0 <printf>
      delete_failed = true;
   18758:	2301      	movs	r3, #1
   1875a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Set the delete end address
    if (!delete_failed)
   1875e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   18762:	f083 0301 	eor.w	r3, r3, #1
   18766:	b2db      	uxtb	r3, r3
   18768:	2b00      	cmp	r3, #0
   1876a:	d010      	beq.n	1878e <Sd::DeleteBlock(unsigned long, unsigned long)+0x96>
    {
      LOG_DEBUG("Setting Delete End Address...");
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
                                   100, KeepAlive::kYes);
   1876c:	9b05      	ldr	r3, [sp, #20]
   1876e:	681b      	ldr	r3, [r3, #0]
   18770:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
   18772:	ab06      	add	r3, sp, #24
   18774:	f103 0208 	add.w	r2, r3, #8
   18778:	2301      	movs	r3, #1
   1877a:	9301      	str	r3, [sp, #4]
   1877c:	2364      	movs	r3, #100	; 0x64
   1877e:	9300      	str	r3, [sp, #0]
   18780:	4613      	mov	r3, r2
   18782:	9a03      	ldr	r2, [sp, #12]
   18784:	2161      	movs	r1, #97	; 0x61
   18786:	9805      	ldr	r0, [sp, #20]
   18788:	47a0      	blx	r4
   1878a:	4603      	mov	r3, r0
   1878c:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // Wait while the writing the end address
    WaitWhileBusy();
   1878e:	9805      	ldr	r0, [sp, #20]
   18790:	f7ff fca8 	bl	180e4 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   18794:	f89d 3020 	ldrb.w	r3, [sp, #32]
   18798:	2b00      	cmp	r3, #0
   1879a:	d009      	beq.n	187b0 <Sd::DeleteBlock(unsigned long, unsigned long)+0xb8>
    {
      LOG_ERROR("Failed to set End Address!");
   1879c:	f240 33ba 	movw	r3, #954	; 0x3ba
   187a0:	4a18      	ldr	r2, [pc, #96]	; (18804 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   187a2:	491b      	ldr	r1, [pc, #108]	; (18810 <Sd::DeleteBlock(unsigned long, unsigned long)+0x118>)
   187a4:	481b      	ldr	r0, [pc, #108]	; (18814 <Sd::DeleteBlock(unsigned long, unsigned long)+0x11c>)
   187a6:	f7ff f90b 	bl	179c0 <printf>
      delete_failed = true;
   187aa:	2301      	movs	r3, #1
   187ac:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Finally, attempt a delete
    if (!delete_failed)
   187b0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   187b4:	f083 0301 	eor.w	r3, r3, #1
   187b8:	b2db      	uxtb	r3, r3
   187ba:	2b00      	cmp	r3, #0
   187bc:	d014      	beq.n	187e8 <Sd::DeleteBlock(unsigned long, unsigned long)+0xf0>
    {
      // Issue the delete command to delete from our from:to range
      LOG_DEBUG("Issuing Delete Command...");
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
                                   sd.response.data.byte, 100, KeepAlive::kYes);
   187be:	9b05      	ldr	r3, [sp, #20]
   187c0:	681b      	ldr	r3, [r3, #0]
   187c2:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
   187c4:	ab06      	add	r3, sp, #24
   187c6:	f103 0208 	add.w	r2, r3, #8
   187ca:	2301      	movs	r3, #1
   187cc:	9301      	str	r3, [sp, #4]
   187ce:	2364      	movs	r3, #100	; 0x64
   187d0:	9300      	str	r3, [sp, #0]
   187d2:	4613      	mov	r3, r2
   187d4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   187d8:	2166      	movs	r1, #102	; 0x66
   187da:	9805      	ldr	r0, [sp, #20]
   187dc:	47a0      	blx	r4
   187de:	4603      	mov	r3, r0
   187e0:	930a      	str	r3, [sp, #40]	; 0x28

      // Wait while the deletion occurs
      WaitWhileBusy();
   187e2:	9805      	ldr	r0, [sp, #20]
   187e4:	f7ff fc7e 	bl	180e4 <Sd::WaitWhileBusy()>
      LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);
      LOG_DEBUG("Deletion Complete...");
    }

    // Return status
    return sd.response.data.byte[0];
   187e8:	f89d 4020 	ldrb.w	r4, [sp, #32]
   187ec:	462b      	mov	r3, r5
   187ee:	4619      	mov	r1, r3
   187f0:	4803      	ldr	r0, [pc, #12]	; (18800 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   187f2:	f7fc fd15 	bl	15220 <__cyg_profile_func_exit>
   187f6:	4623      	mov	r3, r4
  }
   187f8:	4618      	mov	r0, r3
   187fa:	b00f      	add	sp, #60	; 0x3c
   187fc:	bd30      	pop	{r4, r5, pc}
   187fe:	bf00      	nop
   18800:	000186f9 	.word	0x000186f9
   18804:	0001c1e8 	.word	0x0001c1e8
   18808:	0001c100 	.word	0x0001c100
   1880c:	0001bc18 	.word	0x0001bc18
   18810:	0001c108 	.word	0x0001c108
   18814:	0001bc70 	.word	0x0001bc70

00018818 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)>:

  // Send a command
  uint32_t SendCmd(Command sdc, uint32_t arg, uint8_t response_buffer[],
   18818:	e92d 49f0 	stmdb	sp!, {r4, r5, r6, r7, r8, fp, lr}
   1881c:	b08f      	sub	sp, #60	; 0x3c
   1881e:	46f0      	mov	r8, lr
   18820:	9003      	str	r0, [sp, #12]
   18822:	9102      	str	r1, [sp, #8]
   18824:	9201      	str	r2, [sp, #4]
   18826:	9300      	str	r3, [sp, #0]
   18828:	4643      	mov	r3, r8
   1882a:	4619      	mov	r1, r3
   1882c:	4840      	ldr	r0, [pc, #256]	; (18930 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x118>)
   1882e:	f7fc fce3 	bl	151f8 <__cyg_profile_func_enter>
                   uint32_t delay, KeepAlive keep_alive) override
  {
    ResponseType res_type;
    uint8_t res_len    = 0;
   18832:	2300      	movs	r3, #0
   18834:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    uint8_t crc        = 0;
   18838:	2300      	movs	r3, #0
   1883a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    uint8_t tries      = 0;
   1883e:	2300      	movs	r3, #0
   18840:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    uint8_t bit_offset = 0;  // determines the distance of the response's
   18844:	2300      	movs	r3, #0
   18846:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                             // 0 bit from the MSB place
    uint8_t temp_byte = 0;
   1884a:	2300      	movs	r3, #0
   1884c:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f

    // Determine the response type of the set command
    switch (sdc)
   18850:	9b02      	ldr	r3, [sp, #8]
   18852:	2b58      	cmp	r3, #88	; 0x58
   18854:	d052      	beq.n	188fc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xe4>
   18856:	2b58      	cmp	r3, #88	; 0x58
   18858:	dc16      	bgt.n	18888 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x70>
   1885a:	2b48      	cmp	r3, #72	; 0x48
   1885c:	d033      	beq.n	188c6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xae>
   1885e:	2b48      	cmp	r3, #72	; 0x48
   18860:	dc06      	bgt.n	18870 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x58>
   18862:	2b40      	cmp	r3, #64	; 0x40
   18864:	d029      	beq.n	188ba <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa2>
   18866:	2b41      	cmp	r3, #65	; 0x41
   18868:	d02a      	beq.n	188c0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa8>
   1886a:	2b0d      	cmp	r3, #13
   1886c:	d031      	beq.n	188d2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xba>
   1886e:	e054      	b.n	1891a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18870:	2b50      	cmp	r3, #80	; 0x50
   18872:	d03a      	beq.n	188ea <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd2>
   18874:	2b50      	cmp	r3, #80	; 0x50
   18876:	dc02      	bgt.n	1887e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x66>
   18878:	2b4c      	cmp	r3, #76	; 0x4c
   1887a:	d027      	beq.n	188cc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xb4>
   1887c:	e04d      	b.n	1891a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   1887e:	2b51      	cmp	r3, #81	; 0x51
   18880:	d036      	beq.n	188f0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd8>
   18882:	2b52      	cmp	r3, #82	; 0x52
   18884:	d037      	beq.n	188f6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xde>
   18886:	e048      	b.n	1891a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18888:	2b66      	cmp	r3, #102	; 0x66
   1888a:	d043      	beq.n	18914 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xfc>
   1888c:	2b66      	cmp	r3, #102	; 0x66
   1888e:	dc06      	bgt.n	1889e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x86>
   18890:	2b60      	cmp	r3, #96	; 0x60
   18892:	d039      	beq.n	18908 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf0>
   18894:	2b61      	cmp	r3, #97	; 0x61
   18896:	d03a      	beq.n	1890e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf6>
   18898:	2b59      	cmp	r3, #89	; 0x59
   1889a:	d032      	beq.n	18902 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xea>
   1889c:	e03d      	b.n	1891a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   1889e:	2b77      	cmp	r3, #119	; 0x77
   188a0:	d01a      	beq.n	188d8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc0>
   188a2:	2b77      	cmp	r3, #119	; 0x77
   188a4:	dc02      	bgt.n	188ac <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x94>
   188a6:	2b69      	cmp	r3, #105	; 0x69
   188a8:	d019      	beq.n	188de <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc6>
   188aa:	e036      	b.n	1891a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   188ac:	2b7a      	cmp	r3, #122	; 0x7a
   188ae:	d019      	beq.n	188e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xcc>
   188b0:	2bff      	cmp	r3, #255	; 0xff
   188b2:	d132      	bne.n	1891a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
    {
      case Command::kGarbage: res_type = ResponseType::kR1; break;
   188b4:	2300      	movs	r3, #0
   188b6:	930d      	str	r3, [sp, #52]	; 0x34
   188b8:	e042      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReset: res_type = ResponseType::kR1; break;
   188ba:	2300      	movs	r3, #0
   188bc:	930d      	str	r3, [sp, #52]	; 0x34
   188be:	e03f      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kInit: res_type = ResponseType::kR1; break;
   188c0:	2300      	movs	r3, #0
   188c2:	930d      	str	r3, [sp, #52]	; 0x34
   188c4:	e03c      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOp: res_type = ResponseType::kR7; break;
   188c6:	2307      	movs	r3, #7
   188c8:	930d      	str	r3, [sp, #52]	; 0x34
   188ca:	e039      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kStopTrans: res_type = ResponseType::kR1; break;
   188cc:	2300      	movs	r3, #0
   188ce:	930d      	str	r3, [sp, #52]	; 0x34
   188d0:	e036      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetStatus: res_type = ResponseType::kR2; break;
   188d2:	2302      	movs	r3, #2
   188d4:	930d      	str	r3, [sp, #52]	; 0x34
   188d6:	e033      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcBegin: res_type = ResponseType::kR1; break;
   188d8:	2300      	movs	r3, #0
   188da:	930d      	str	r3, [sp, #52]	; 0x34
   188dc:	e030      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcInit: res_type = ResponseType::kR1; break;
   188de:	2300      	movs	r3, #0
   188e0:	930d      	str	r3, [sp, #52]	; 0x34
   188e2:	e02d      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOcr: res_type = ResponseType::kR3; break;
   188e4:	2303      	movs	r3, #3
   188e6:	930d      	str	r3, [sp, #52]	; 0x34
   188e8:	e02a      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kChgBlkLen: res_type = ResponseType::kR1; break;
   188ea:	2300      	movs	r3, #0
   188ec:	930d      	str	r3, [sp, #52]	; 0x34
   188ee:	e027      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadSingle: res_type = ResponseType::kR1; break;
   188f0:	2300      	movs	r3, #0
   188f2:	930d      	str	r3, [sp, #52]	; 0x34
   188f4:	e024      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadMulti: res_type = ResponseType::kR1; break;
   188f6:	2300      	movs	r3, #0
   188f8:	930d      	str	r3, [sp, #52]	; 0x34
   188fa:	e021      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteSingle: res_type = ResponseType::kR1; break;
   188fc:	2300      	movs	r3, #0
   188fe:	930d      	str	r3, [sp, #52]	; 0x34
   18900:	e01e      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteMulti: res_type = ResponseType::kR1; break;
   18902:	2300      	movs	r3, #0
   18904:	930d      	str	r3, [sp, #52]	; 0x34
   18906:	e01b      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelFrom: res_type = ResponseType::kR1; break;
   18908:	2300      	movs	r3, #0
   1890a:	930d      	str	r3, [sp, #52]	; 0x34
   1890c:	e018      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelTo: res_type = ResponseType::kR1; break;
   1890e:	2300      	movs	r3, #0
   18910:	930d      	str	r3, [sp, #52]	; 0x34
   18912:	e015      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDel: res_type = ResponseType::kR1b; break;
   18914:	2301      	movs	r3, #1
   18916:	930d      	str	r3, [sp, #52]	; 0x34
   18918:	e012      	b.n	18940 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      default:
        LOG_ERROR("Unknown response type. Aborting!");
   1891a:	f240 33f3 	movw	r3, #1011	; 0x3f3
   1891e:	4a05      	ldr	r2, [pc, #20]	; (18934 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x11c>)
   18920:	4905      	ldr	r1, [pc, #20]	; (18938 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x120>)
   18922:	4806      	ldr	r0, [pc, #24]	; (1893c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x124>)
   18924:	f7ff f84c 	bl	179c0 <printf>
        return -1;
   18928:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1892c:	e1b1      	b.n	18c92 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
   1892e:	bf00      	nop
   18930:	00018819 	.word	0x00018819
   18934:	0001c21c 	.word	0x0001c21c
   18938:	0001c110 	.word	0x0001c110
   1893c:	0001bcc4 	.word	0x0001bcc4
    // algorithm
    uint8_t msg[5] = { static_cast<uint8_t>(sdc),
                       static_cast<uint8_t>(arg >> 24),
                       static_cast<uint8_t>(arg >> 16),
                       static_cast<uint8_t>(arg >> 8),
                       static_cast<uint8_t>(arg >> 0) };
   18940:	9b02      	ldr	r3, [sp, #8]
   18942:	b2db      	uxtb	r3, r3
   18944:	f88d 3010 	strb.w	r3, [sp, #16]
                       static_cast<uint8_t>(arg >> 24),
   18948:	9b01      	ldr	r3, [sp, #4]
   1894a:	0e1b      	lsrs	r3, r3, #24
                       static_cast<uint8_t>(arg >> 0) };
   1894c:	b2db      	uxtb	r3, r3
   1894e:	f88d 3011 	strb.w	r3, [sp, #17]
                       static_cast<uint8_t>(arg >> 16),
   18952:	9b01      	ldr	r3, [sp, #4]
   18954:	0c1b      	lsrs	r3, r3, #16
                       static_cast<uint8_t>(arg >> 0) };
   18956:	b2db      	uxtb	r3, r3
   18958:	f88d 3012 	strb.w	r3, [sp, #18]
                       static_cast<uint8_t>(arg >> 8),
   1895c:	9b01      	ldr	r3, [sp, #4]
   1895e:	0a1b      	lsrs	r3, r3, #8
                       static_cast<uint8_t>(arg >> 0) };
   18960:	b2db      	uxtb	r3, r3
   18962:	f88d 3013 	strb.w	r3, [sp, #19]
   18966:	9b01      	ldr	r3, [sp, #4]
   18968:	b2db      	uxtb	r3, r3
   1896a:	f88d 3014 	strb.w	r3, [sp, #20]

    crc = GetCrc7(msg, sizeof(msg));
   1896e:	9b03      	ldr	r3, [sp, #12]
   18970:	681b      	ldr	r3, [r3, #0]
   18972:	331c      	adds	r3, #28
   18974:	681b      	ldr	r3, [r3, #0]
   18976:	a904      	add	r1, sp, #16
   18978:	2205      	movs	r2, #5
   1897a:	9803      	ldr	r0, [sp, #12]
   1897c:	4798      	blx	r3
   1897e:	4603      	mov	r3, r0
   18980:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    if (sdc == Command::kGarbage)
   18984:	9b02      	ldr	r3, [sp, #8]
   18986:	2bff      	cmp	r3, #255	; 0xff
   18988:	d102      	bne.n	18990 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x178>
    {
      crc = 0xFF;
   1898a:	23ff      	movs	r3, #255	; 0xff
   1898c:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    }

    // Select the SD Card
    chip_select_->SetLow();
   18990:	9b03      	ldr	r3, [sp, #12]
   18992:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18994:	9b03      	ldr	r3, [sp, #12]
   18996:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   18998:	681b      	ldr	r3, [r3, #0]
   1899a:	3310      	adds	r3, #16
   1899c:	681b      	ldr	r3, [r3, #0]
   1899e:	4610      	mov	r0, r2
   189a0:	4798      	blx	r3
    chip_select_external_->SetLow();
   189a2:	9b03      	ldr	r3, [sp, #12]
   189a4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   189a6:	9b03      	ldr	r3, [sp, #12]
   189a8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   189aa:	681b      	ldr	r3, [r3, #0]
   189ac:	3310      	adds	r3, #16
   189ae:	681b      	ldr	r3, [r3, #0]
   189b0:	4610      	mov	r0, r2
   189b2:	4798      	blx	r3

    // If desired, wait a bit before talking
    if (delay > 0)
   189b4:	9b16      	ldr	r3, [sp, #88]	; 0x58
   189b6:	2b00      	cmp	r3, #0
   189b8:	d007      	beq.n	189ca <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x1b2>
    {
      Delay(delay);
   189ba:	9b16      	ldr	r3, [sp, #88]	; 0x58
   189bc:	461a      	mov	r2, r3
   189be:	f04f 0300 	mov.w	r3, #0
   189c2:	4610      	mov	r0, r2
   189c4:	4619      	mov	r1, r3
   189c6:	f7ff f8d1 	bl	17b6c <Delay(unsigned long long)>
    }

    // Send the desired command frame to the SD card board
    // Begin by transfering the command byte
    ssp_interface_->Transfer(static_cast<uint16_t>(sdc));
   189ca:	9b03      	ldr	r3, [sp, #12]
   189cc:	685a      	ldr	r2, [r3, #4]
   189ce:	9b03      	ldr	r3, [sp, #12]
   189d0:	685b      	ldr	r3, [r3, #4]
   189d2:	681b      	ldr	r3, [r3, #0]
   189d4:	3308      	adds	r3, #8
   189d6:	681b      	ldr	r3, [r3, #0]
   189d8:	9902      	ldr	r1, [sp, #8]
   189da:	b289      	uxth	r1, r1
   189dc:	4610      	mov	r0, r2
   189de:	4798      	blx	r3
    // Send arg byte [31:24]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 24) & 0xFF);
   189e0:	9b03      	ldr	r3, [sp, #12]
   189e2:	6858      	ldr	r0, [r3, #4]
   189e4:	9b03      	ldr	r3, [sp, #12]
   189e6:	685b      	ldr	r3, [r3, #4]
   189e8:	681b      	ldr	r3, [r3, #0]
   189ea:	3308      	adds	r3, #8
   189ec:	681b      	ldr	r3, [r3, #0]
   189ee:	9a01      	ldr	r2, [sp, #4]
   189f0:	0e12      	lsrs	r2, r2, #24
   189f2:	b292      	uxth	r2, r2
   189f4:	b2d2      	uxtb	r2, r2
   189f6:	b292      	uxth	r2, r2
   189f8:	4611      	mov	r1, r2
   189fa:	4798      	blx	r3
    // Send arg byte [23:16]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 16) & 0xFF);
   189fc:	9b03      	ldr	r3, [sp, #12]
   189fe:	6858      	ldr	r0, [r3, #4]
   18a00:	9b03      	ldr	r3, [sp, #12]
   18a02:	685b      	ldr	r3, [r3, #4]
   18a04:	681b      	ldr	r3, [r3, #0]
   18a06:	3308      	adds	r3, #8
   18a08:	681b      	ldr	r3, [r3, #0]
   18a0a:	9a01      	ldr	r2, [sp, #4]
   18a0c:	0c12      	lsrs	r2, r2, #16
   18a0e:	b292      	uxth	r2, r2
   18a10:	b2d2      	uxtb	r2, r2
   18a12:	b292      	uxth	r2, r2
   18a14:	4611      	mov	r1, r2
   18a16:	4798      	blx	r3
    // Send arg byte [15:8]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 8) & 0xFF);
   18a18:	9b03      	ldr	r3, [sp, #12]
   18a1a:	6858      	ldr	r0, [r3, #4]
   18a1c:	9b03      	ldr	r3, [sp, #12]
   18a1e:	685b      	ldr	r3, [r3, #4]
   18a20:	681b      	ldr	r3, [r3, #0]
   18a22:	3308      	adds	r3, #8
   18a24:	681b      	ldr	r3, [r3, #0]
   18a26:	9a01      	ldr	r2, [sp, #4]
   18a28:	0a12      	lsrs	r2, r2, #8
   18a2a:	b292      	uxth	r2, r2
   18a2c:	b2d2      	uxtb	r2, r2
   18a2e:	b292      	uxth	r2, r2
   18a30:	4611      	mov	r1, r2
   18a32:	4798      	blx	r3
    // Send arg byte [7:0]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 0) & 0xFF);
   18a34:	9b03      	ldr	r3, [sp, #12]
   18a36:	685a      	ldr	r2, [r3, #4]
   18a38:	9b03      	ldr	r3, [sp, #12]
   18a3a:	685b      	ldr	r3, [r3, #4]
   18a3c:	681b      	ldr	r3, [r3, #0]
   18a3e:	3308      	adds	r3, #8
   18a40:	681b      	ldr	r3, [r3, #0]
   18a42:	9901      	ldr	r1, [sp, #4]
   18a44:	b289      	uxth	r1, r1
   18a46:	b2c9      	uxtb	r1, r1
   18a48:	b289      	uxth	r1, r1
   18a4a:	4610      	mov	r0, r2
   18a4c:	4798      	blx	r3
    // Send 7-bit CRC and LSB stop addr (as b1)
    ssp_interface_->Transfer(static_cast<uint16_t>(crc << 1) | 0x01);
   18a4e:	9b03      	ldr	r3, [sp, #12]
   18a50:	6858      	ldr	r0, [r3, #4]
   18a52:	9b03      	ldr	r3, [sp, #12]
   18a54:	685b      	ldr	r3, [r3, #4]
   18a56:	681b      	ldr	r3, [r3, #0]
   18a58:	3308      	adds	r3, #8
   18a5a:	681b      	ldr	r3, [r3, #0]
   18a5c:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   18a60:	b292      	uxth	r2, r2
   18a62:	0052      	lsls	r2, r2, #1
   18a64:	b292      	uxth	r2, r2
   18a66:	f042 0201 	orr.w	r2, r2, #1
   18a6a:	b292      	uxth	r2, r2
   18a6c:	4611      	mov	r1, r2
   18a6e:	4798      	blx	r3

    // Write garbage while waiting for a response
    // Send at least 1 byte of garbage before checking for a response
    temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18a70:	9b03      	ldr	r3, [sp, #12]
   18a72:	685a      	ldr	r2, [r3, #4]
   18a74:	9b03      	ldr	r3, [sp, #12]
   18a76:	685b      	ldr	r3, [r3, #4]
   18a78:	681b      	ldr	r3, [r3, #0]
   18a7a:	3308      	adds	r3, #8
   18a7c:	681b      	ldr	r3, [r3, #0]
   18a7e:	21ff      	movs	r1, #255	; 0xff
   18a80:	4610      	mov	r0, r2
   18a82:	4798      	blx	r3
   18a84:	4603      	mov	r3, r0
   18a86:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (tries++ < kBusTimeout)
   18a8a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   18a8e:	1c5a      	adds	r2, r3, #1
   18a90:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   18a94:	2bf9      	cmp	r3, #249	; 0xf9
   18a96:	bf94      	ite	ls
   18a98:	2301      	movls	r3, #1
   18a9a:	2300      	movhi	r3, #0
   18a9c:	b2db      	uxtb	r3, r3
   18a9e:	2b00      	cmp	r3, #0
   18aa0:	d027      	beq.n	18af2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2da>
    {
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18aa2:	9b03      	ldr	r3, [sp, #12]
   18aa4:	685a      	ldr	r2, [r3, #4]
   18aa6:	9b03      	ldr	r3, [sp, #12]
   18aa8:	685b      	ldr	r3, [r3, #4]
   18aaa:	681b      	ldr	r3, [r3, #0]
   18aac:	3308      	adds	r3, #8
   18aae:	681b      	ldr	r3, [r3, #0]
   18ab0:	21ff      	movs	r1, #255	; 0xff
   18ab2:	4610      	mov	r0, r2
   18ab4:	4798      	blx	r3
   18ab6:	4603      	mov	r3, r0
   18ab8:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
      if (temp_byte != 0xFF)
   18abc:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   18ac0:	2bff      	cmp	r3, #255	; 0xff
   18ac2:	d00f      	beq.n	18ae4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2cc>
      {
        // Determine the offset, since the first byte of a
        // response will always be 0.
        while (temp_byte & (0x80 >> bit_offset))
   18ac4:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   18ac8:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18acc:	2180      	movs	r1, #128	; 0x80
   18ace:	fa41 f303 	asr.w	r3, r1, r3
   18ad2:	4013      	ands	r3, r2
   18ad4:	2b00      	cmp	r3, #0
   18ad6:	d00b      	beq.n	18af0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2d8>
        {
          bit_offset++;
   18ad8:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18adc:	3301      	adds	r3, #1
   18ade:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        while (temp_byte & (0x80 >> bit_offset))
   18ae2:	e7ef      	b.n	18ac4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2ac>
        }
        break;
      }
      tries++;
   18ae4:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   18ae8:	3301      	adds	r3, #1
   18aea:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    while (tries++ < kBusTimeout)
   18aee:	e7cc      	b.n	18a8a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x272>
        break;
   18af0:	bf00      	nop
    }

    // Determine response length (in bytes) based on response type
    switch (res_type)
   18af2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18af4:	2b07      	cmp	r3, #7
   18af6:	d827      	bhi.n	18b48 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x330>
   18af8:	a201      	add	r2, pc, #4	; (adr r2, 18b00 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2e8>)
   18afa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   18afe:	bf00      	nop
   18b00:	00018b21 	.word	0x00018b21
   18b04:	00018b29 	.word	0x00018b29
   18b08:	00018b31 	.word	0x00018b31
   18b0c:	00018b39 	.word	0x00018b39
   18b10:	00018b49 	.word	0x00018b49
   18b14:	00018b49 	.word	0x00018b49
   18b18:	00018b49 	.word	0x00018b49
   18b1c:	00018b41 	.word	0x00018b41
    {
      case ResponseType::kR1: res_len = 1; break;
   18b20:	2301      	movs	r3, #1
   18b22:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18b26:	e019      	b.n	18b5c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR1b: res_len = 1; break;
   18b28:	2301      	movs	r3, #1
   18b2a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18b2e:	e015      	b.n	18b5c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR2: res_len = 2; break;
   18b30:	2302      	movs	r3, #2
   18b32:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18b36:	e011      	b.n	18b5c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR3: res_len = 5; break;
   18b38:	2305      	movs	r3, #5
   18b3a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18b3e:	e00d      	b.n	18b5c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR7: res_len = 5; break;
   18b40:	2305      	movs	r3, #5
   18b42:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   18b46:	e009      	b.n	18b5c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      default:
        LOG_ERROR("Response unsupported in SPI mode. Aborting!");
   18b48:	f240 433a 	movw	r3, #1082	; 0x43a
   18b4c:	4a56      	ldr	r2, [pc, #344]	; (18ca8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x490>)
   18b4e:	4957      	ldr	r1, [pc, #348]	; (18cac <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x494>)
   18b50:	4857      	ldr	r0, [pc, #348]	; (18cb0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x498>)
   18b52:	f7fe ff35 	bl	179c0 <printf>
        return -1;
   18b56:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   18b5a:	e09a      	b.n	18c92 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
        break;
    }

    // Acquire the response
    uint64_t temp_response = 0;
   18b5c:	f04f 0200 	mov.w	r2, #0
   18b60:	f04f 0300 	mov.w	r3, #0
   18b64:	e9cd 2308 	strd	r2, r3, [sp, #32]
    // Read an extra 8 bits since the response was offset
    uint8_t bytes_to_read =
   18b68:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18b6c:	2b00      	cmp	r3, #0
   18b6e:	d004      	beq.n	18b7a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x362>
   18b70:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   18b74:	3301      	adds	r3, #1
   18b76:	b2db      	uxtb	r3, r3
   18b78:	e001      	b.n	18b7e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x366>
   18b7a:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   18b7e:	f88d 301f 	strb.w	r3, [sp, #31]
        static_cast<uint8_t>((bit_offset > 0) ? res_len + 1 : res_len);
    while (bytes_to_read-- > 0)
   18b82:	f89d 301f 	ldrb.w	r3, [sp, #31]
   18b86:	1e5a      	subs	r2, r3, #1
   18b88:	f88d 201f 	strb.w	r2, [sp, #31]
   18b8c:	2b00      	cmp	r3, #0
   18b8e:	bf14      	ite	ne
   18b90:	2301      	movne	r3, #1
   18b92:	2300      	moveq	r3, #0
   18b94:	b2db      	uxtb	r3, r3
   18b96:	2b00      	cmp	r3, #0
   18b98:	d025      	beq.n	18be6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x3ce>
    {
      // Make space for the next byte
      temp_response = temp_response << 8;
   18b9a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   18b9e:	f04f 0200 	mov.w	r2, #0
   18ba2:	f04f 0300 	mov.w	r3, #0
   18ba6:	020b      	lsls	r3, r1, #8
   18ba8:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
   18bac:	0202      	lsls	r2, r0, #8
   18bae:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_response |= temp_byte;
   18bb2:	f89d b02f 	ldrb.w	fp, [sp, #47]	; 0x2f
   18bb6:	f04f 0c00 	mov.w	ip, #0
   18bba:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   18bbe:	ea4b 0200 	orr.w	r2, fp, r0
   18bc2:	ea4c 0301 	orr.w	r3, ip, r1
   18bc6:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18bca:	9b03      	ldr	r3, [sp, #12]
   18bcc:	685a      	ldr	r2, [r3, #4]
   18bce:	9b03      	ldr	r3, [sp, #12]
   18bd0:	685b      	ldr	r3, [r3, #4]
   18bd2:	681b      	ldr	r3, [r3, #0]
   18bd4:	3308      	adds	r3, #8
   18bd6:	681b      	ldr	r3, [r3, #0]
   18bd8:	21ff      	movs	r1, #255	; 0xff
   18bda:	4610      	mov	r0, r2
   18bdc:	4798      	blx	r3
   18bde:	4603      	mov	r3, r0
   18be0:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (bytes_to_read-- > 0)
   18be4:	e7cd      	b.n	18b82 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x36a>
    }
    // Compensate for the bit offset
    temp_response = temp_response >> bit_offset;
   18be6:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
   18bea:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   18bee:	f1c1 0c20 	rsb	ip, r1, #32
   18bf2:	f1a1 0020 	sub.w	r0, r1, #32
   18bf6:	fa22 f401 	lsr.w	r4, r2, r1
   18bfa:	fa03 fc0c 	lsl.w	ip, r3, ip
   18bfe:	ea44 040c 	orr.w	r4, r4, ip
   18c02:	fa23 f000 	lsr.w	r0, r3, r0
   18c06:	4304      	orrs	r4, r0
   18c08:	fa23 f501 	lsr.w	r5, r3, r1
   18c0c:	e9cd 4508 	strd	r4, r5, [sp, #32]

    // Only write to the response buffer if it is provided
    if (response_buffer != nullptr)
   18c10:	9b00      	ldr	r3, [sp, #0]
   18c12:	2b00      	cmp	r3, #0
   18c14:	d025      	beq.n	18c62 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
    {
      for (int i = 0; i < res_len; i++)
   18c16:	2300      	movs	r3, #0
   18c18:	9306      	str	r3, [sp, #24]
   18c1a:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   18c1e:	9a06      	ldr	r2, [sp, #24]
   18c20:	429a      	cmp	r2, r3
   18c22:	da1e      	bge.n	18c62 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
      {
        response_buffer[i] =
            static_cast<uint8_t>(temp_response >> 8 * (res_len - 1 - i));
   18c24:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   18c28:	1e5a      	subs	r2, r3, #1
   18c2a:	9b06      	ldr	r3, [sp, #24]
   18c2c:	1ad3      	subs	r3, r2, r3
   18c2e:	00da      	lsls	r2, r3, #3
   18c30:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   18c34:	f1c2 0020 	rsb	r0, r2, #32
   18c38:	f1a2 0120 	sub.w	r1, r2, #32
   18c3c:	fa23 f602 	lsr.w	r6, r3, r2
   18c40:	fa04 f000 	lsl.w	r0, r4, r0
   18c44:	4306      	orrs	r6, r0
   18c46:	fa24 f101 	lsr.w	r1, r4, r1
   18c4a:	430e      	orrs	r6, r1
   18c4c:	fa24 f702 	lsr.w	r7, r4, r2
        response_buffer[i] =
   18c50:	9b06      	ldr	r3, [sp, #24]
   18c52:	9a00      	ldr	r2, [sp, #0]
   18c54:	4413      	add	r3, r2
   18c56:	b2f2      	uxtb	r2, r6
   18c58:	701a      	strb	r2, [r3, #0]
      for (int i = 0; i < res_len; i++)
   18c5a:	9b06      	ldr	r3, [sp, #24]
   18c5c:	3301      	adds	r3, #1
   18c5e:	9306      	str	r3, [sp, #24]
   18c60:	e7db      	b.n	18c1a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x402>
      }
    }

    // Only end the transaction if keep_alive isn't requested
    if (keep_alive == KeepAlive::kNo)
   18c62:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
   18c66:	2b00      	cmp	r3, #0
   18c68:	d111      	bne.n	18c8e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x476>
    {
      // Deselect the SPI comm board
      chip_select_->SetHigh();
   18c6a:	9b03      	ldr	r3, [sp, #12]
   18c6c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18c6e:	9b03      	ldr	r3, [sp, #12]
   18c70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   18c72:	681b      	ldr	r3, [r3, #0]
   18c74:	330c      	adds	r3, #12
   18c76:	681b      	ldr	r3, [r3, #0]
   18c78:	4610      	mov	r0, r2
   18c7a:	4798      	blx	r3
      chip_select_external_->SetHigh();
   18c7c:	9b03      	ldr	r3, [sp, #12]
   18c7e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   18c80:	9b03      	ldr	r3, [sp, #12]
   18c82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   18c84:	681b      	ldr	r3, [r3, #0]
   18c86:	330c      	adds	r3, #12
   18c88:	681b      	ldr	r3, [r3, #0]
   18c8a:	4610      	mov	r0, r2
   18c8c:	4798      	blx	r3
    }
    return res_len;
   18c8e:	f89d 4033 	ldrb.w	r4, [sp, #51]	; 0x33
   18c92:	4643      	mov	r3, r8
   18c94:	4619      	mov	r1, r3
   18c96:	4807      	ldr	r0, [pc, #28]	; (18cb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x49c>)
   18c98:	f7fc fac2 	bl	15220 <__cyg_profile_func_exit>
   18c9c:	4623      	mov	r3, r4
  }
   18c9e:	4618      	mov	r0, r3
   18ca0:	b00f      	add	sp, #60	; 0x3c
   18ca2:	e8bd 89f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, fp, pc}
   18ca6:	bf00      	nop
   18ca8:	0001c21c 	.word	0x0001c21c
   18cac:	0001c118 	.word	0x0001c118
   18cb0:	0001bd20 	.word	0x0001bd20
   18cb4:	00018819 	.word	0x00018819

00018cb8 <Sd::Crc7Add(unsigned char, unsigned char)>:

  // Adds a message byte to the current CRC-7 to get a the new CRC-7
  uint8_t Crc7Add(uint8_t crc, uint8_t message_byte) override
   18cb8:	b530      	push	{r4, r5, lr}
   18cba:	b083      	sub	sp, #12
   18cbc:	4675      	mov	r5, lr
   18cbe:	9001      	str	r0, [sp, #4]
   18cc0:	460b      	mov	r3, r1
   18cc2:	f88d 3003 	strb.w	r3, [sp, #3]
   18cc6:	4613      	mov	r3, r2
   18cc8:	f88d 3002 	strb.w	r3, [sp, #2]
   18ccc:	462b      	mov	r3, r5
   18cce:	4619      	mov	r1, r3
   18cd0:	4809      	ldr	r0, [pc, #36]	; (18cf8 <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   18cd2:	f7fc fa91 	bl	151f8 <__cyg_profile_func_enter>
  {
    return kCrcTable8.crc_table[(crc << 1) ^ message_byte];
   18cd6:	f89d 3003 	ldrb.w	r3, [sp, #3]
   18cda:	005a      	lsls	r2, r3, #1
   18cdc:	f89d 3002 	ldrb.w	r3, [sp, #2]
   18ce0:	4053      	eors	r3, r2
   18ce2:	4a06      	ldr	r2, [pc, #24]	; (18cfc <Sd::Crc7Add(unsigned char, unsigned char)+0x44>)
   18ce4:	5cd4      	ldrb	r4, [r2, r3]
   18ce6:	462b      	mov	r3, r5
   18ce8:	4619      	mov	r1, r3
   18cea:	4803      	ldr	r0, [pc, #12]	; (18cf8 <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   18cec:	f7fc fa98 	bl	15220 <__cyg_profile_func_exit>
   18cf0:	4623      	mov	r3, r4
  }
   18cf2:	4618      	mov	r0, r3
   18cf4:	b003      	add	sp, #12
   18cf6:	bd30      	pop	{r4, r5, pc}
   18cf8:	00018cb9 	.word	0x00018cb9
   18cfc:	0001bd88 	.word	0x0001bd88

00018d00 <Sd::GetCrc7(unsigned char*, unsigned char)>:

  // Returns the CRC-7 for a message of "length" bytes
  uint8_t GetCrc7(uint8_t * message, uint8_t length) override
   18d00:	b530      	push	{r4, r5, lr}
   18d02:	b087      	sub	sp, #28
   18d04:	4675      	mov	r5, lr
   18d06:	9003      	str	r0, [sp, #12]
   18d08:	9102      	str	r1, [sp, #8]
   18d0a:	4613      	mov	r3, r2
   18d0c:	f88d 3007 	strb.w	r3, [sp, #7]
   18d10:	462b      	mov	r3, r5
   18d12:	4619      	mov	r1, r3
   18d14:	4815      	ldr	r0, [pc, #84]	; (18d6c <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   18d16:	f7fc fa6f 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint8_t crc = 0;
   18d1a:	2300      	movs	r3, #0
   18d1c:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   18d20:	2300      	movs	r3, #0
   18d22:	9304      	str	r3, [sp, #16]
   18d24:	f89d 3007 	ldrb.w	r3, [sp, #7]
   18d28:	9a04      	ldr	r2, [sp, #16]
   18d2a:	429a      	cmp	r2, r3
   18d2c:	da12      	bge.n	18d54 <Sd::GetCrc7(unsigned char*, unsigned char)+0x54>
    {
      crc = Crc7Add(crc, message[i]);
   18d2e:	9b03      	ldr	r3, [sp, #12]
   18d30:	681b      	ldr	r3, [r3, #0]
   18d32:	3318      	adds	r3, #24
   18d34:	681b      	ldr	r3, [r3, #0]
   18d36:	9a04      	ldr	r2, [sp, #16]
   18d38:	9902      	ldr	r1, [sp, #8]
   18d3a:	440a      	add	r2, r1
   18d3c:	7812      	ldrb	r2, [r2, #0]
   18d3e:	f89d 1017 	ldrb.w	r1, [sp, #23]
   18d42:	9803      	ldr	r0, [sp, #12]
   18d44:	4798      	blx	r3
   18d46:	4603      	mov	r3, r0
   18d48:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   18d4c:	9b04      	ldr	r3, [sp, #16]
   18d4e:	3301      	adds	r3, #1
   18d50:	9304      	str	r3, [sp, #16]
   18d52:	e7e7      	b.n	18d24 <Sd::GetCrc7(unsigned char*, unsigned char)+0x24>
    }
    return crc;
   18d54:	f89d 4017 	ldrb.w	r4, [sp, #23]
   18d58:	462b      	mov	r3, r5
   18d5a:	4619      	mov	r1, r3
   18d5c:	4803      	ldr	r0, [pc, #12]	; (18d6c <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   18d5e:	f7fc fa5f 	bl	15220 <__cyg_profile_func_exit>
   18d62:	4623      	mov	r3, r4
  }
   18d64:	4618      	mov	r0, r3
   18d66:	b007      	add	sp, #28
   18d68:	bd30      	pop	{r4, r5, pc}
   18d6a:	bf00      	nop
   18d6c:	00018d01 	.word	0x00018d01

00018d70 <Sd::GetCrc16(unsigned char*, unsigned short)>:

  // Returns CCITT CRC-16 for a message of "length" bytes
  uint16_t GetCrc16(uint8_t * message, uint16_t length) override
   18d70:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   18d74:	b08c      	sub	sp, #48	; 0x30
   18d76:	4677      	mov	r7, lr
   18d78:	9003      	str	r0, [sp, #12]
   18d7a:	9102      	str	r1, [sp, #8]
   18d7c:	4613      	mov	r3, r2
   18d7e:	f8ad 3006 	strh.w	r3, [sp, #6]
   18d82:	463b      	mov	r3, r7
   18d84:	4619      	mov	r1, r3
   18d86:	4837      	ldr	r0, [pc, #220]	; (18e64 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   18d88:	f7fc fa36 	bl	151f8 <__cyg_profile_func_enter>
  {
    uint64_t crc = 0x0000;
   18d8c:	f04f 0300 	mov.w	r3, #0
   18d90:	f04f 0400 	mov.w	r4, #0
   18d94:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    uint64_t temp;
    uint64_t final_value = 0;
   18d98:	f04f 0300 	mov.w	r3, #0
   18d9c:	f04f 0400 	mov.w	r4, #0
   18da0:	e9cd 3406 	strd	r3, r4, [sp, #24]

    for (uint64_t count = 0; count < length; ++count)
   18da4:	f04f 0300 	mov.w	r3, #0
   18da8:	f04f 0400 	mov.w	r4, #0
   18dac:	e9cd 3408 	strd	r3, r4, [sp, #32]
   18db0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   18db4:	f04f 0400 	mov.w	r4, #0
   18db8:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   18dbc:	42a2      	cmp	r2, r4
   18dbe:	bf08      	it	eq
   18dc0:	4299      	cmpeq	r1, r3
   18dc2:	d23f      	bcs.n	18e44 <Sd::GetCrc16(unsigned char*, unsigned short)+0xd4>
    {
      temp = (*message++ ^ (crc >> 8)) & 0xff;
   18dc4:	9b02      	ldr	r3, [sp, #8]
   18dc6:	1c5a      	adds	r2, r3, #1
   18dc8:	9202      	str	r2, [sp, #8]
   18dca:	781b      	ldrb	r3, [r3, #0]
   18dcc:	b2dd      	uxtb	r5, r3
   18dce:	f04f 0600 	mov.w	r6, #0
   18dd2:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   18dd6:	f04f 0300 	mov.w	r3, #0
   18dda:	f04f 0400 	mov.w	r4, #0
   18dde:	0a0b      	lsrs	r3, r1, #8
   18de0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   18de4:	0a14      	lsrs	r4, r2, #8
   18de6:	ea83 0b05 	eor.w	fp, r3, r5
   18dea:	ea84 0c06 	eor.w	ip, r4, r6
   18dee:	f04f 01ff 	mov.w	r1, #255	; 0xff
   18df2:	f04f 0200 	mov.w	r2, #0
   18df6:	ea0b 0301 	and.w	r3, fp, r1
   18dfa:	ea0c 0402 	and.w	r4, ip, r2
   18dfe:	e9cd 3404 	strd	r3, r4, [sp, #16]
      crc  = kCrcTable16.crc_table[temp] ^ (crc << 8);
   18e02:	4a19      	ldr	r2, [pc, #100]	; (18e68 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf8>)
   18e04:	9b04      	ldr	r3, [sp, #16]
   18e06:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   18e0a:	b29d      	uxth	r5, r3
   18e0c:	f04f 0600 	mov.w	r6, #0
   18e10:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   18e14:	f04f 0b00 	mov.w	fp, #0
   18e18:	f04f 0c00 	mov.w	ip, #0
   18e1c:	ea4f 2c02 	mov.w	ip, r2, lsl #8
   18e20:	ea4c 6c11 	orr.w	ip, ip, r1, lsr #24
   18e24:	ea4f 2b01 	mov.w	fp, r1, lsl #8
   18e28:	ea8b 0305 	eor.w	r3, fp, r5
   18e2c:	ea8c 0406 	eor.w	r4, ip, r6
   18e30:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    for (uint64_t count = 0; count < length; ++count)
   18e34:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   18e38:	1c59      	adds	r1, r3, #1
   18e3a:	f144 0200 	adc.w	r2, r4, #0
   18e3e:	e9cd 1208 	strd	r1, r2, [sp, #32]
   18e42:	e7b5      	b.n	18db0 <Sd::GetCrc16(unsigned char*, unsigned short)+0x40>
    }

    return static_cast<uint16_t>(crc ^ final_value);
   18e44:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   18e48:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   18e4c:	4053      	eors	r3, r2
   18e4e:	b29c      	uxth	r4, r3
   18e50:	463b      	mov	r3, r7
   18e52:	4619      	mov	r1, r3
   18e54:	4803      	ldr	r0, [pc, #12]	; (18e64 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   18e56:	f7fc f9e3 	bl	15220 <__cyg_profile_func_exit>
   18e5a:	4623      	mov	r3, r4
  }
   18e5c:	4618      	mov	r0, r3
   18e5e:	b00c      	add	sp, #48	; 0x30
   18e60:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   18e64:	00018d71 	.word	0x00018d71
   18e68:	0001be88 	.word	0x0001be88

00018e6c <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   18e6c:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   18e70:	b088      	sub	sp, #32
   18e72:	4675      	mov	r5, lr
   18e74:	e9cd 0102 	strd	r0, r1, [sp, #8]
   18e78:	f88d 2004 	strb.w	r2, [sp, #4]
   18e7c:	462b      	mov	r3, r5
   18e7e:	4619      	mov	r1, r3
   18e80:	4824      	ldr	r0, [pc, #144]	; (18f14 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   18e82:	f7fc f9b9 	bl	151f8 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   18e86:	f04f 0300 	mov.w	r3, #0
   18e8a:	f04f 0400 	mov.w	r4, #0
   18e8e:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   18e92:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   18e96:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   18e9a:	bf08      	it	eq
   18e9c:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   18ea0:	d106      	bne.n	18eb0 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x44>
    timeout_time = kMaxWait;
   18ea2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   18ea6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   18eaa:	e9cd 3406 	strd	r3, r4, [sp, #24]
   18eae:	e00b      	b.n	18ec8 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x5c>
    timeout_time = Milliseconds() + timeout;
   18eb0:	f7f7 fe28 	bl	10b04 <Milliseconds()>
   18eb4:	460a      	mov	r2, r1
   18eb6:	4601      	mov	r1, r0
   18eb8:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   18ebc:	eb13 0b01 	adds.w	fp, r3, r1
   18ec0:	eb44 0c02 	adc.w	ip, r4, r2
   18ec4:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   18ec8:	2301      	movs	r3, #1
   18eca:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   18ecc:	f7f7 fe1a 	bl	10b04 <Milliseconds()>
   18ed0:	460a      	mov	r2, r1
   18ed2:	4601      	mov	r1, r0
   18ed4:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   18ed8:	42a2      	cmp	r2, r4
   18eda:	bf08      	it	eq
   18edc:	4299      	cmpeq	r1, r3
   18ede:	bf34      	ite	cc
   18ee0:	2301      	movcc	r3, #1
   18ee2:	2300      	movcs	r3, #0
   18ee4:	b2db      	uxtb	r3, r3
   18ee6:	2b00      	cmp	r3, #0
   18ee8:	d008      	beq.n	18efc <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x90>
    if (is_done())
   18eea:	ab01      	add	r3, sp, #4
   18eec:	4618      	mov	r0, r3
   18eee:	f7fe fdaf 	bl	17a50 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   18ef2:	4603      	mov	r3, r0
   18ef4:	2b00      	cmp	r3, #0
   18ef6:	d0e9      	beq.n	18ecc <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x60>
      status = Status::kSuccess;
   18ef8:	2300      	movs	r3, #0
   18efa:	9305      	str	r3, [sp, #20]
  return status;
   18efc:	9c05      	ldr	r4, [sp, #20]
   18efe:	462b      	mov	r3, r5
   18f00:	4619      	mov	r1, r3
   18f02:	4804      	ldr	r0, [pc, #16]	; (18f14 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   18f04:	f7fc f98c 	bl	15220 <__cyg_profile_func_exit>
   18f08:	4623      	mov	r3, r4
}
   18f0a:	4618      	mov	r0, r3
   18f0c:	b008      	add	sp, #32
   18f0e:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   18f12:	bf00      	nop
   18f14:	00018e6d 	.word	0x00018e6d

00018f18 <__static_initialization_and_destruction_0(int, int)>:
extern "C" DRESULT disk_ioctl([[maybe_unused]] BYTE drive_number,
                              [[maybe_unused]] BYTE command,
                              [[maybe_unused]] void * buffer)
{
  return RES_PARERR;
}
   18f18:	b530      	push	{r4, r5, lr}
   18f1a:	b085      	sub	sp, #20
   18f1c:	4674      	mov	r4, lr
   18f1e:	9003      	str	r0, [sp, #12]
   18f20:	9102      	str	r1, [sp, #8]
   18f22:	4623      	mov	r3, r4
   18f24:	4619      	mov	r1, r3
   18f26:	480e      	ldr	r0, [pc, #56]	; (18f60 <__static_initialization_and_destruction_0(int, int)+0x48>)
   18f28:	f7fc f966 	bl	151f8 <__cyg_profile_func_enter>
   18f2c:	9b03      	ldr	r3, [sp, #12]
   18f2e:	2b01      	cmp	r3, #1
   18f30:	d10e      	bne.n	18f50 <__static_initialization_and_destruction_0(int, int)+0x38>
   18f32:	9b02      	ldr	r3, [sp, #8]
   18f34:	f64f 72ff 	movw	r2, #65535	; 0xffff
   18f38:	4293      	cmp	r3, r2
   18f3a:	d109      	bne.n	18f50 <__static_initialization_and_destruction_0(int, int)+0x38>
Sd sd_card(Sd::DebugSdCard_t{});
   18f3c:	2306      	movs	r3, #6
   18f3e:	9301      	str	r3, [sp, #4]
   18f40:	2300      	movs	r3, #0
   18f42:	9300      	str	r3, [sp, #0]
   18f44:	2308      	movs	r3, #8
   18f46:	2201      	movs	r2, #1
   18f48:	4629      	mov	r1, r5
   18f4a:	4806      	ldr	r0, [pc, #24]	; (18f64 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   18f4c:	f7fe fe40 	bl	17bd0 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>
   18f50:	4623      	mov	r3, r4
   18f52:	4619      	mov	r1, r3
   18f54:	4802      	ldr	r0, [pc, #8]	; (18f60 <__static_initialization_and_destruction_0(int, int)+0x48>)
   18f56:	f7fc f963 	bl	15220 <__cyg_profile_func_exit>
}
   18f5a:	bf00      	nop
   18f5c:	b005      	add	sp, #20
   18f5e:	bd30      	pop	{r4, r5, pc}
   18f60:	00018f19 	.word	0x00018f19
   18f64:	10001648 	.word	0x10001648

00018f68 <_GLOBAL__sub_I_disk_status>:
   18f68:	b510      	push	{r4, lr}
   18f6a:	4674      	mov	r4, lr
   18f6c:	4623      	mov	r3, r4
   18f6e:	4619      	mov	r1, r3
   18f70:	4806      	ldr	r0, [pc, #24]	; (18f8c <_GLOBAL__sub_I_disk_status+0x24>)
   18f72:	f7fc f941 	bl	151f8 <__cyg_profile_func_enter>
   18f76:	f64f 71ff 	movw	r1, #65535	; 0xffff
   18f7a:	2001      	movs	r0, #1
   18f7c:	f7ff ffcc 	bl	18f18 <__static_initialization_and_destruction_0(int, int)>
   18f80:	4623      	mov	r3, r4
   18f82:	4619      	mov	r1, r3
   18f84:	4801      	ldr	r0, [pc, #4]	; (18f8c <_GLOBAL__sub_I_disk_status+0x24>)
   18f86:	f7fc f94b 	bl	15220 <__cyg_profile_func_exit>
   18f8a:	bd10      	pop	{r4, pc}
   18f8c:	00018f69 	.word	0x00018f69

00018f90 <__cxa_pure_virtual>:
   18f90:	b508      	push	{r3, lr}
   18f92:	f000 f80d 	bl	18fb0 <std::terminate()>

00018f96 <__cxxabiv1::__terminate(void (*)())>:
   18f96:	b508      	push	{r3, lr}
   18f98:	4780      	blx	r0
   18f9a:	f000 fa0f 	bl	193bc <abort>
   18f9e:	Address 0x0000000000018f9e is out of bounds.


00018fa0 <std::get_terminate()>:
   18fa0:	4b02      	ldr	r3, [pc, #8]	; (18fac <std::get_terminate()+0xc>)
   18fa2:	6818      	ldr	r0, [r3, #0]
   18fa4:	f3bf 8f5b 	dmb	ish
   18fa8:	4770      	bx	lr
   18faa:	bf00      	nop
   18fac:	100008dc 	.word	0x100008dc

00018fb0 <std::terminate()>:
   18fb0:	b508      	push	{r3, lr}
   18fb2:	f7ff fff5 	bl	18fa0 <std::get_terminate()>
   18fb6:	f7ff ffee 	bl	18f96 <__cxxabiv1::__terminate(void (*)())>
   18fba:	Address 0x0000000000018fba is out of bounds.


00018fbc <roundf>:
   18fbc:	b082      	sub	sp, #8
   18fbe:	ed8d 0a01 	vstr	s0, [sp, #4]
   18fc2:	9901      	ldr	r1, [sp, #4]
   18fc4:	f3c1 53c7 	ubfx	r3, r1, #23, #8
   18fc8:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
   18fcc:	2a16      	cmp	r2, #22
   18fce:	dc0c      	bgt.n	18fea <roundf+0x2e>
   18fd0:	2a00      	cmp	r2, #0
   18fd2:	db10      	blt.n	18ff6 <roundf+0x3a>
   18fd4:	4810      	ldr	r0, [pc, #64]	; (19018 <roundf+0x5c>)
   18fd6:	4110      	asrs	r0, r2
   18fd8:	4201      	tst	r1, r0
   18fda:	d008      	beq.n	18fee <roundf+0x32>
   18fdc:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   18fe0:	4113      	asrs	r3, r2
   18fe2:	440b      	add	r3, r1
   18fe4:	ea23 0300 	bic.w	r3, r3, r0
   18fe8:	e00b      	b.n	19002 <roundf+0x46>
   18fea:	2a80      	cmp	r2, #128	; 0x80
   18fec:	d00d      	beq.n	1900a <roundf+0x4e>
   18fee:	ed9d 0a01 	vldr	s0, [sp, #4]
   18ff2:	b002      	add	sp, #8
   18ff4:	4770      	bx	lr
   18ff6:	3201      	adds	r2, #1
   18ff8:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
   18ffc:	d101      	bne.n	19002 <roundf+0x46>
   18ffe:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
   19002:	ee00 3a10 	vmov	s0, r3
   19006:	b002      	add	sp, #8
   19008:	4770      	bx	lr
   1900a:	eddd 7a01 	vldr	s15, [sp, #4]
   1900e:	ee37 0aa7 	vadd.f32	s0, s15, s15
   19012:	b002      	add	sp, #8
   19014:	4770      	bx	lr
   19016:	bf00      	nop
   19018:	007fffff 	.word	0x007fffff

0001901c <__aeabi_d2f>:
   1901c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   19020:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   19024:	bf24      	itt	cs
   19026:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1902a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1902e:	d90d      	bls.n	1904c <__aeabi_d2f+0x30>
   19030:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   19034:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   19038:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   1903c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   19040:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   19044:	bf08      	it	eq
   19046:	f020 0001 	biceq.w	r0, r0, #1
   1904a:	4770      	bx	lr
   1904c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   19050:	d121      	bne.n	19096 <__aeabi_d2f+0x7a>
   19052:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   19056:	bfbc      	itt	lt
   19058:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   1905c:	4770      	bxlt	lr
   1905e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   19062:	ea4f 5252 	mov.w	r2, r2, lsr #21
   19066:	f1c2 0218 	rsb	r2, r2, #24
   1906a:	f1c2 0c20 	rsb	ip, r2, #32
   1906e:	fa10 f30c 	lsls.w	r3, r0, ip
   19072:	fa20 f002 	lsr.w	r0, r0, r2
   19076:	bf18      	it	ne
   19078:	f040 0001 	orrne.w	r0, r0, #1
   1907c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   19080:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   19084:	fa03 fc0c 	lsl.w	ip, r3, ip
   19088:	ea40 000c 	orr.w	r0, r0, ip
   1908c:	fa23 f302 	lsr.w	r3, r3, r2
   19090:	ea4f 0343 	mov.w	r3, r3, lsl #1
   19094:	e7cc      	b.n	19030 <__aeabi_d2f+0x14>
   19096:	ea7f 5362 	mvns.w	r3, r2, asr #21
   1909a:	d107      	bne.n	190ac <__aeabi_d2f+0x90>
   1909c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   190a0:	bf1e      	ittt	ne
   190a2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   190a6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   190aa:	4770      	bxne	lr
   190ac:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   190b0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   190b4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   190b8:	4770      	bx	lr
   190ba:	bf00      	nop

000190bc <__aeabi_uldivmod>:
   190bc:	b953      	cbnz	r3, 190d4 <__aeabi_uldivmod+0x18>
   190be:	b94a      	cbnz	r2, 190d4 <__aeabi_uldivmod+0x18>
   190c0:	2900      	cmp	r1, #0
   190c2:	bf08      	it	eq
   190c4:	2800      	cmpeq	r0, #0
   190c6:	bf1c      	itt	ne
   190c8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   190cc:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   190d0:	f000 b972 	b.w	193b8 <__aeabi_idiv0>
   190d4:	f1ad 0c08 	sub.w	ip, sp, #8
   190d8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   190dc:	f000 f806 	bl	190ec <__udivmoddi4>
   190e0:	f8dd e004 	ldr.w	lr, [sp, #4]
   190e4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   190e8:	b004      	add	sp, #16
   190ea:	4770      	bx	lr

000190ec <__udivmoddi4>:
   190ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   190f0:	9e08      	ldr	r6, [sp, #32]
   190f2:	4604      	mov	r4, r0
   190f4:	4688      	mov	r8, r1
   190f6:	2b00      	cmp	r3, #0
   190f8:	d14b      	bne.n	19192 <__udivmoddi4+0xa6>
   190fa:	428a      	cmp	r2, r1
   190fc:	4615      	mov	r5, r2
   190fe:	d967      	bls.n	191d0 <__udivmoddi4+0xe4>
   19100:	fab2 f282 	clz	r2, r2
   19104:	b14a      	cbz	r2, 1911a <__udivmoddi4+0x2e>
   19106:	f1c2 0720 	rsb	r7, r2, #32
   1910a:	fa01 f302 	lsl.w	r3, r1, r2
   1910e:	fa20 f707 	lsr.w	r7, r0, r7
   19112:	4095      	lsls	r5, r2
   19114:	ea47 0803 	orr.w	r8, r7, r3
   19118:	4094      	lsls	r4, r2
   1911a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1911e:	0c23      	lsrs	r3, r4, #16
   19120:	fbb8 f7fe 	udiv	r7, r8, lr
   19124:	fa1f fc85 	uxth.w	ip, r5
   19128:	fb0e 8817 	mls	r8, lr, r7, r8
   1912c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   19130:	fb07 f10c 	mul.w	r1, r7, ip
   19134:	4299      	cmp	r1, r3
   19136:	d909      	bls.n	1914c <__udivmoddi4+0x60>
   19138:	18eb      	adds	r3, r5, r3
   1913a:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   1913e:	f080 811b 	bcs.w	19378 <__udivmoddi4+0x28c>
   19142:	4299      	cmp	r1, r3
   19144:	f240 8118 	bls.w	19378 <__udivmoddi4+0x28c>
   19148:	3f02      	subs	r7, #2
   1914a:	442b      	add	r3, r5
   1914c:	1a5b      	subs	r3, r3, r1
   1914e:	b2a4      	uxth	r4, r4
   19150:	fbb3 f0fe 	udiv	r0, r3, lr
   19154:	fb0e 3310 	mls	r3, lr, r0, r3
   19158:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1915c:	fb00 fc0c 	mul.w	ip, r0, ip
   19160:	45a4      	cmp	ip, r4
   19162:	d909      	bls.n	19178 <__udivmoddi4+0x8c>
   19164:	192c      	adds	r4, r5, r4
   19166:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1916a:	f080 8107 	bcs.w	1937c <__udivmoddi4+0x290>
   1916e:	45a4      	cmp	ip, r4
   19170:	f240 8104 	bls.w	1937c <__udivmoddi4+0x290>
   19174:	3802      	subs	r0, #2
   19176:	442c      	add	r4, r5
   19178:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   1917c:	eba4 040c 	sub.w	r4, r4, ip
   19180:	2700      	movs	r7, #0
   19182:	b11e      	cbz	r6, 1918c <__udivmoddi4+0xa0>
   19184:	40d4      	lsrs	r4, r2
   19186:	2300      	movs	r3, #0
   19188:	e9c6 4300 	strd	r4, r3, [r6]
   1918c:	4639      	mov	r1, r7
   1918e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   19192:	428b      	cmp	r3, r1
   19194:	d909      	bls.n	191aa <__udivmoddi4+0xbe>
   19196:	2e00      	cmp	r6, #0
   19198:	f000 80eb 	beq.w	19372 <__udivmoddi4+0x286>
   1919c:	2700      	movs	r7, #0
   1919e:	e9c6 0100 	strd	r0, r1, [r6]
   191a2:	4638      	mov	r0, r7
   191a4:	4639      	mov	r1, r7
   191a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   191aa:	fab3 f783 	clz	r7, r3
   191ae:	2f00      	cmp	r7, #0
   191b0:	d147      	bne.n	19242 <__udivmoddi4+0x156>
   191b2:	428b      	cmp	r3, r1
   191b4:	d302      	bcc.n	191bc <__udivmoddi4+0xd0>
   191b6:	4282      	cmp	r2, r0
   191b8:	f200 80fa 	bhi.w	193b0 <__udivmoddi4+0x2c4>
   191bc:	1a84      	subs	r4, r0, r2
   191be:	eb61 0303 	sbc.w	r3, r1, r3
   191c2:	2001      	movs	r0, #1
   191c4:	4698      	mov	r8, r3
   191c6:	2e00      	cmp	r6, #0
   191c8:	d0e0      	beq.n	1918c <__udivmoddi4+0xa0>
   191ca:	e9c6 4800 	strd	r4, r8, [r6]
   191ce:	e7dd      	b.n	1918c <__udivmoddi4+0xa0>
   191d0:	b902      	cbnz	r2, 191d4 <__udivmoddi4+0xe8>
   191d2:	deff      	udf	#255	; 0xff
   191d4:	fab2 f282 	clz	r2, r2
   191d8:	2a00      	cmp	r2, #0
   191da:	f040 808f 	bne.w	192fc <__udivmoddi4+0x210>
   191de:	1b49      	subs	r1, r1, r5
   191e0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   191e4:	fa1f f885 	uxth.w	r8, r5
   191e8:	2701      	movs	r7, #1
   191ea:	fbb1 fcfe 	udiv	ip, r1, lr
   191ee:	0c23      	lsrs	r3, r4, #16
   191f0:	fb0e 111c 	mls	r1, lr, ip, r1
   191f4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   191f8:	fb08 f10c 	mul.w	r1, r8, ip
   191fc:	4299      	cmp	r1, r3
   191fe:	d907      	bls.n	19210 <__udivmoddi4+0x124>
   19200:	18eb      	adds	r3, r5, r3
   19202:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   19206:	d202      	bcs.n	1920e <__udivmoddi4+0x122>
   19208:	4299      	cmp	r1, r3
   1920a:	f200 80cd 	bhi.w	193a8 <__udivmoddi4+0x2bc>
   1920e:	4684      	mov	ip, r0
   19210:	1a59      	subs	r1, r3, r1
   19212:	b2a3      	uxth	r3, r4
   19214:	fbb1 f0fe 	udiv	r0, r1, lr
   19218:	fb0e 1410 	mls	r4, lr, r0, r1
   1921c:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   19220:	fb08 f800 	mul.w	r8, r8, r0
   19224:	45a0      	cmp	r8, r4
   19226:	d907      	bls.n	19238 <__udivmoddi4+0x14c>
   19228:	192c      	adds	r4, r5, r4
   1922a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1922e:	d202      	bcs.n	19236 <__udivmoddi4+0x14a>
   19230:	45a0      	cmp	r8, r4
   19232:	f200 80b6 	bhi.w	193a2 <__udivmoddi4+0x2b6>
   19236:	4618      	mov	r0, r3
   19238:	eba4 0408 	sub.w	r4, r4, r8
   1923c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   19240:	e79f      	b.n	19182 <__udivmoddi4+0x96>
   19242:	f1c7 0c20 	rsb	ip, r7, #32
   19246:	40bb      	lsls	r3, r7
   19248:	fa22 fe0c 	lsr.w	lr, r2, ip
   1924c:	ea4e 0e03 	orr.w	lr, lr, r3
   19250:	fa01 f407 	lsl.w	r4, r1, r7
   19254:	fa20 f50c 	lsr.w	r5, r0, ip
   19258:	fa21 f30c 	lsr.w	r3, r1, ip
   1925c:	ea4f 481e 	mov.w	r8, lr, lsr #16
   19260:	4325      	orrs	r5, r4
   19262:	fbb3 f9f8 	udiv	r9, r3, r8
   19266:	0c2c      	lsrs	r4, r5, #16
   19268:	fb08 3319 	mls	r3, r8, r9, r3
   1926c:	fa1f fa8e 	uxth.w	sl, lr
   19270:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   19274:	fb09 f40a 	mul.w	r4, r9, sl
   19278:	429c      	cmp	r4, r3
   1927a:	fa02 f207 	lsl.w	r2, r2, r7
   1927e:	fa00 f107 	lsl.w	r1, r0, r7
   19282:	d90b      	bls.n	1929c <__udivmoddi4+0x1b0>
   19284:	eb1e 0303 	adds.w	r3, lr, r3
   19288:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   1928c:	f080 8087 	bcs.w	1939e <__udivmoddi4+0x2b2>
   19290:	429c      	cmp	r4, r3
   19292:	f240 8084 	bls.w	1939e <__udivmoddi4+0x2b2>
   19296:	f1a9 0902 	sub.w	r9, r9, #2
   1929a:	4473      	add	r3, lr
   1929c:	1b1b      	subs	r3, r3, r4
   1929e:	b2ad      	uxth	r5, r5
   192a0:	fbb3 f0f8 	udiv	r0, r3, r8
   192a4:	fb08 3310 	mls	r3, r8, r0, r3
   192a8:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   192ac:	fb00 fa0a 	mul.w	sl, r0, sl
   192b0:	45a2      	cmp	sl, r4
   192b2:	d908      	bls.n	192c6 <__udivmoddi4+0x1da>
   192b4:	eb1e 0404 	adds.w	r4, lr, r4
   192b8:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   192bc:	d26b      	bcs.n	19396 <__udivmoddi4+0x2aa>
   192be:	45a2      	cmp	sl, r4
   192c0:	d969      	bls.n	19396 <__udivmoddi4+0x2aa>
   192c2:	3802      	subs	r0, #2
   192c4:	4474      	add	r4, lr
   192c6:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   192ca:	fba0 8902 	umull	r8, r9, r0, r2
   192ce:	eba4 040a 	sub.w	r4, r4, sl
   192d2:	454c      	cmp	r4, r9
   192d4:	46c2      	mov	sl, r8
   192d6:	464b      	mov	r3, r9
   192d8:	d354      	bcc.n	19384 <__udivmoddi4+0x298>
   192da:	d051      	beq.n	19380 <__udivmoddi4+0x294>
   192dc:	2e00      	cmp	r6, #0
   192de:	d069      	beq.n	193b4 <__udivmoddi4+0x2c8>
   192e0:	ebb1 050a 	subs.w	r5, r1, sl
   192e4:	eb64 0403 	sbc.w	r4, r4, r3
   192e8:	fa04 fc0c 	lsl.w	ip, r4, ip
   192ec:	40fd      	lsrs	r5, r7
   192ee:	40fc      	lsrs	r4, r7
   192f0:	ea4c 0505 	orr.w	r5, ip, r5
   192f4:	e9c6 5400 	strd	r5, r4, [r6]
   192f8:	2700      	movs	r7, #0
   192fa:	e747      	b.n	1918c <__udivmoddi4+0xa0>
   192fc:	f1c2 0320 	rsb	r3, r2, #32
   19300:	fa20 f703 	lsr.w	r7, r0, r3
   19304:	4095      	lsls	r5, r2
   19306:	fa01 f002 	lsl.w	r0, r1, r2
   1930a:	fa21 f303 	lsr.w	r3, r1, r3
   1930e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   19312:	4338      	orrs	r0, r7
   19314:	0c01      	lsrs	r1, r0, #16
   19316:	fbb3 f7fe 	udiv	r7, r3, lr
   1931a:	fa1f f885 	uxth.w	r8, r5
   1931e:	fb0e 3317 	mls	r3, lr, r7, r3
   19322:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   19326:	fb07 f308 	mul.w	r3, r7, r8
   1932a:	428b      	cmp	r3, r1
   1932c:	fa04 f402 	lsl.w	r4, r4, r2
   19330:	d907      	bls.n	19342 <__udivmoddi4+0x256>
   19332:	1869      	adds	r1, r5, r1
   19334:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   19338:	d22f      	bcs.n	1939a <__udivmoddi4+0x2ae>
   1933a:	428b      	cmp	r3, r1
   1933c:	d92d      	bls.n	1939a <__udivmoddi4+0x2ae>
   1933e:	3f02      	subs	r7, #2
   19340:	4429      	add	r1, r5
   19342:	1acb      	subs	r3, r1, r3
   19344:	b281      	uxth	r1, r0
   19346:	fbb3 f0fe 	udiv	r0, r3, lr
   1934a:	fb0e 3310 	mls	r3, lr, r0, r3
   1934e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   19352:	fb00 f308 	mul.w	r3, r0, r8
   19356:	428b      	cmp	r3, r1
   19358:	d907      	bls.n	1936a <__udivmoddi4+0x27e>
   1935a:	1869      	adds	r1, r5, r1
   1935c:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   19360:	d217      	bcs.n	19392 <__udivmoddi4+0x2a6>
   19362:	428b      	cmp	r3, r1
   19364:	d915      	bls.n	19392 <__udivmoddi4+0x2a6>
   19366:	3802      	subs	r0, #2
   19368:	4429      	add	r1, r5
   1936a:	1ac9      	subs	r1, r1, r3
   1936c:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   19370:	e73b      	b.n	191ea <__udivmoddi4+0xfe>
   19372:	4637      	mov	r7, r6
   19374:	4630      	mov	r0, r6
   19376:	e709      	b.n	1918c <__udivmoddi4+0xa0>
   19378:	4607      	mov	r7, r0
   1937a:	e6e7      	b.n	1914c <__udivmoddi4+0x60>
   1937c:	4618      	mov	r0, r3
   1937e:	e6fb      	b.n	19178 <__udivmoddi4+0x8c>
   19380:	4541      	cmp	r1, r8
   19382:	d2ab      	bcs.n	192dc <__udivmoddi4+0x1f0>
   19384:	ebb8 0a02 	subs.w	sl, r8, r2
   19388:	eb69 020e 	sbc.w	r2, r9, lr
   1938c:	3801      	subs	r0, #1
   1938e:	4613      	mov	r3, r2
   19390:	e7a4      	b.n	192dc <__udivmoddi4+0x1f0>
   19392:	4660      	mov	r0, ip
   19394:	e7e9      	b.n	1936a <__udivmoddi4+0x27e>
   19396:	4618      	mov	r0, r3
   19398:	e795      	b.n	192c6 <__udivmoddi4+0x1da>
   1939a:	4667      	mov	r7, ip
   1939c:	e7d1      	b.n	19342 <__udivmoddi4+0x256>
   1939e:	4681      	mov	r9, r0
   193a0:	e77c      	b.n	1929c <__udivmoddi4+0x1b0>
   193a2:	3802      	subs	r0, #2
   193a4:	442c      	add	r4, r5
   193a6:	e747      	b.n	19238 <__udivmoddi4+0x14c>
   193a8:	f1ac 0c02 	sub.w	ip, ip, #2
   193ac:	442b      	add	r3, r5
   193ae:	e72f      	b.n	19210 <__udivmoddi4+0x124>
   193b0:	4638      	mov	r0, r7
   193b2:	e708      	b.n	191c6 <__udivmoddi4+0xda>
   193b4:	4637      	mov	r7, r6
   193b6:	e6e9      	b.n	1918c <__udivmoddi4+0xa0>

000193b8 <__aeabi_idiv0>:
   193b8:	4770      	bx	lr
   193ba:	bf00      	nop

000193bc <abort>:
   193bc:	b508      	push	{r3, lr}
   193be:	2006      	movs	r0, #6
   193c0:	f000 f92c 	bl	1961c <raise>
   193c4:	2001      	movs	r0, #1
   193c6:	f7fb fe4b 	bl	15060 <_exit>
   193ca:	Address 0x00000000000193ca is out of bounds.


000193cc <__libc_init_array>:
   193cc:	b570      	push	{r4, r5, r6, lr}
   193ce:	4e0d      	ldr	r6, [pc, #52]	; (19404 <__libc_init_array+0x38>)
   193d0:	4c0d      	ldr	r4, [pc, #52]	; (19408 <__libc_init_array+0x3c>)
   193d2:	1ba4      	subs	r4, r4, r6
   193d4:	10a4      	asrs	r4, r4, #2
   193d6:	2500      	movs	r5, #0
   193d8:	42a5      	cmp	r5, r4
   193da:	d109      	bne.n	193f0 <__libc_init_array+0x24>
   193dc:	4e0b      	ldr	r6, [pc, #44]	; (1940c <__libc_init_array+0x40>)
   193de:	4c0c      	ldr	r4, [pc, #48]	; (19410 <__libc_init_array+0x44>)
   193e0:	f7f6 ff8e 	bl	10300 <_init>
   193e4:	1ba4      	subs	r4, r4, r6
   193e6:	10a4      	asrs	r4, r4, #2
   193e8:	2500      	movs	r5, #0
   193ea:	42a5      	cmp	r5, r4
   193ec:	d105      	bne.n	193fa <__libc_init_array+0x2e>
   193ee:	bd70      	pop	{r4, r5, r6, pc}
   193f0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   193f4:	4798      	blx	r3
   193f6:	3501      	adds	r5, #1
   193f8:	e7ee      	b.n	193d8 <__libc_init_array+0xc>
   193fa:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   193fe:	4798      	blx	r3
   19400:	3501      	adds	r5, #1
   19402:	e7f2      	b.n	193ea <__libc_init_array+0x1e>
   19404:	0001030c 	.word	0x0001030c
   19408:	0001030c 	.word	0x0001030c
   1940c:	0001030c 	.word	0x0001030c
   19410:	0001031c 	.word	0x0001031c

00019414 <malloc>:
   19414:	4b02      	ldr	r3, [pc, #8]	; (19420 <malloc+0xc>)
   19416:	4601      	mov	r1, r0
   19418:	6818      	ldr	r0, [r3, #0]
   1941a:	f000 b86d 	b.w	194f8 <_malloc_r>
   1941e:	bf00      	nop
   19420:	100008e0 	.word	0x100008e0

00019424 <free>:
   19424:	4b02      	ldr	r3, [pc, #8]	; (19430 <free+0xc>)
   19426:	4601      	mov	r1, r0
   19428:	6818      	ldr	r0, [r3, #0]
   1942a:	f000 b817 	b.w	1945c <_free_r>
   1942e:	bf00      	nop
   19430:	100008e0 	.word	0x100008e0

00019434 <memcpy>:
   19434:	b510      	push	{r4, lr}
   19436:	1e43      	subs	r3, r0, #1
   19438:	440a      	add	r2, r1
   1943a:	4291      	cmp	r1, r2
   1943c:	d100      	bne.n	19440 <memcpy+0xc>
   1943e:	bd10      	pop	{r4, pc}
   19440:	f811 4b01 	ldrb.w	r4, [r1], #1
   19444:	f803 4f01 	strb.w	r4, [r3, #1]!
   19448:	e7f7      	b.n	1943a <memcpy+0x6>

0001944a <memset>:
   1944a:	4402      	add	r2, r0
   1944c:	4603      	mov	r3, r0
   1944e:	4293      	cmp	r3, r2
   19450:	d100      	bne.n	19454 <memset+0xa>
   19452:	4770      	bx	lr
   19454:	f803 1b01 	strb.w	r1, [r3], #1
   19458:	e7f9      	b.n	1944e <memset+0x4>
   1945a:	Address 0x000000000001945a is out of bounds.


0001945c <_free_r>:
   1945c:	b538      	push	{r3, r4, r5, lr}
   1945e:	4605      	mov	r5, r0
   19460:	2900      	cmp	r1, #0
   19462:	d045      	beq.n	194f0 <_free_r+0x94>
   19464:	f851 3c04 	ldr.w	r3, [r1, #-4]
   19468:	1f0c      	subs	r4, r1, #4
   1946a:	2b00      	cmp	r3, #0
   1946c:	bfb8      	it	lt
   1946e:	18e4      	addlt	r4, r4, r3
   19470:	f000 f8f0 	bl	19654 <__malloc_lock>
   19474:	4a1f      	ldr	r2, [pc, #124]	; (194f4 <_free_r+0x98>)
   19476:	6813      	ldr	r3, [r2, #0]
   19478:	4610      	mov	r0, r2
   1947a:	b933      	cbnz	r3, 1948a <_free_r+0x2e>
   1947c:	6063      	str	r3, [r4, #4]
   1947e:	6014      	str	r4, [r2, #0]
   19480:	4628      	mov	r0, r5
   19482:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   19486:	f000 b8e6 	b.w	19656 <__malloc_unlock>
   1948a:	42a3      	cmp	r3, r4
   1948c:	d90c      	bls.n	194a8 <_free_r+0x4c>
   1948e:	6821      	ldr	r1, [r4, #0]
   19490:	1862      	adds	r2, r4, r1
   19492:	4293      	cmp	r3, r2
   19494:	bf04      	itt	eq
   19496:	681a      	ldreq	r2, [r3, #0]
   19498:	685b      	ldreq	r3, [r3, #4]
   1949a:	6063      	str	r3, [r4, #4]
   1949c:	bf04      	itt	eq
   1949e:	1852      	addeq	r2, r2, r1
   194a0:	6022      	streq	r2, [r4, #0]
   194a2:	6004      	str	r4, [r0, #0]
   194a4:	e7ec      	b.n	19480 <_free_r+0x24>
   194a6:	4613      	mov	r3, r2
   194a8:	685a      	ldr	r2, [r3, #4]
   194aa:	b10a      	cbz	r2, 194b0 <_free_r+0x54>
   194ac:	42a2      	cmp	r2, r4
   194ae:	d9fa      	bls.n	194a6 <_free_r+0x4a>
   194b0:	6819      	ldr	r1, [r3, #0]
   194b2:	1858      	adds	r0, r3, r1
   194b4:	42a0      	cmp	r0, r4
   194b6:	d10b      	bne.n	194d0 <_free_r+0x74>
   194b8:	6820      	ldr	r0, [r4, #0]
   194ba:	4401      	add	r1, r0
   194bc:	1858      	adds	r0, r3, r1
   194be:	4282      	cmp	r2, r0
   194c0:	6019      	str	r1, [r3, #0]
   194c2:	d1dd      	bne.n	19480 <_free_r+0x24>
   194c4:	6810      	ldr	r0, [r2, #0]
   194c6:	6852      	ldr	r2, [r2, #4]
   194c8:	605a      	str	r2, [r3, #4]
   194ca:	4401      	add	r1, r0
   194cc:	6019      	str	r1, [r3, #0]
   194ce:	e7d7      	b.n	19480 <_free_r+0x24>
   194d0:	d902      	bls.n	194d8 <_free_r+0x7c>
   194d2:	230c      	movs	r3, #12
   194d4:	602b      	str	r3, [r5, #0]
   194d6:	e7d3      	b.n	19480 <_free_r+0x24>
   194d8:	6820      	ldr	r0, [r4, #0]
   194da:	1821      	adds	r1, r4, r0
   194dc:	428a      	cmp	r2, r1
   194de:	bf04      	itt	eq
   194e0:	6811      	ldreq	r1, [r2, #0]
   194e2:	6852      	ldreq	r2, [r2, #4]
   194e4:	6062      	str	r2, [r4, #4]
   194e6:	bf04      	itt	eq
   194e8:	1809      	addeq	r1, r1, r0
   194ea:	6021      	streq	r1, [r4, #0]
   194ec:	605c      	str	r4, [r3, #4]
   194ee:	e7c7      	b.n	19480 <_free_r+0x24>
   194f0:	bd38      	pop	{r3, r4, r5, pc}
   194f2:	bf00      	nop
   194f4:	100016b0 	.word	0x100016b0

000194f8 <_malloc_r>:
   194f8:	b570      	push	{r4, r5, r6, lr}
   194fa:	1ccd      	adds	r5, r1, #3
   194fc:	f025 0503 	bic.w	r5, r5, #3
   19500:	3508      	adds	r5, #8
   19502:	2d0c      	cmp	r5, #12
   19504:	bf38      	it	cc
   19506:	250c      	movcc	r5, #12
   19508:	2d00      	cmp	r5, #0
   1950a:	4606      	mov	r6, r0
   1950c:	db01      	blt.n	19512 <_malloc_r+0x1a>
   1950e:	42a9      	cmp	r1, r5
   19510:	d903      	bls.n	1951a <_malloc_r+0x22>
   19512:	230c      	movs	r3, #12
   19514:	6033      	str	r3, [r6, #0]
   19516:	2000      	movs	r0, #0
   19518:	bd70      	pop	{r4, r5, r6, pc}
   1951a:	f000 f89b 	bl	19654 <__malloc_lock>
   1951e:	4a21      	ldr	r2, [pc, #132]	; (195a4 <_malloc_r+0xac>)
   19520:	6814      	ldr	r4, [r2, #0]
   19522:	4621      	mov	r1, r4
   19524:	b991      	cbnz	r1, 1954c <_malloc_r+0x54>
   19526:	4c20      	ldr	r4, [pc, #128]	; (195a8 <_malloc_r+0xb0>)
   19528:	6823      	ldr	r3, [r4, #0]
   1952a:	b91b      	cbnz	r3, 19534 <_malloc_r+0x3c>
   1952c:	4630      	mov	r0, r6
   1952e:	f000 f83d 	bl	195ac <_sbrk_r>
   19532:	6020      	str	r0, [r4, #0]
   19534:	4629      	mov	r1, r5
   19536:	4630      	mov	r0, r6
   19538:	f000 f838 	bl	195ac <_sbrk_r>
   1953c:	1c43      	adds	r3, r0, #1
   1953e:	d124      	bne.n	1958a <_malloc_r+0x92>
   19540:	230c      	movs	r3, #12
   19542:	6033      	str	r3, [r6, #0]
   19544:	4630      	mov	r0, r6
   19546:	f000 f886 	bl	19656 <__malloc_unlock>
   1954a:	e7e4      	b.n	19516 <_malloc_r+0x1e>
   1954c:	680b      	ldr	r3, [r1, #0]
   1954e:	1b5b      	subs	r3, r3, r5
   19550:	d418      	bmi.n	19584 <_malloc_r+0x8c>
   19552:	2b0b      	cmp	r3, #11
   19554:	d90f      	bls.n	19576 <_malloc_r+0x7e>
   19556:	600b      	str	r3, [r1, #0]
   19558:	50cd      	str	r5, [r1, r3]
   1955a:	18cc      	adds	r4, r1, r3
   1955c:	4630      	mov	r0, r6
   1955e:	f000 f87a 	bl	19656 <__malloc_unlock>
   19562:	f104 000b 	add.w	r0, r4, #11
   19566:	1d23      	adds	r3, r4, #4
   19568:	f020 0007 	bic.w	r0, r0, #7
   1956c:	1ac3      	subs	r3, r0, r3
   1956e:	d0d3      	beq.n	19518 <_malloc_r+0x20>
   19570:	425a      	negs	r2, r3
   19572:	50e2      	str	r2, [r4, r3]
   19574:	e7d0      	b.n	19518 <_malloc_r+0x20>
   19576:	428c      	cmp	r4, r1
   19578:	684b      	ldr	r3, [r1, #4]
   1957a:	bf16      	itet	ne
   1957c:	6063      	strne	r3, [r4, #4]
   1957e:	6013      	streq	r3, [r2, #0]
   19580:	460c      	movne	r4, r1
   19582:	e7eb      	b.n	1955c <_malloc_r+0x64>
   19584:	460c      	mov	r4, r1
   19586:	6849      	ldr	r1, [r1, #4]
   19588:	e7cc      	b.n	19524 <_malloc_r+0x2c>
   1958a:	1cc4      	adds	r4, r0, #3
   1958c:	f024 0403 	bic.w	r4, r4, #3
   19590:	42a0      	cmp	r0, r4
   19592:	d005      	beq.n	195a0 <_malloc_r+0xa8>
   19594:	1a21      	subs	r1, r4, r0
   19596:	4630      	mov	r0, r6
   19598:	f000 f808 	bl	195ac <_sbrk_r>
   1959c:	3001      	adds	r0, #1
   1959e:	d0cf      	beq.n	19540 <_malloc_r+0x48>
   195a0:	6025      	str	r5, [r4, #0]
   195a2:	e7db      	b.n	1955c <_malloc_r+0x64>
   195a4:	100016b0 	.word	0x100016b0
   195a8:	100016b4 	.word	0x100016b4

000195ac <_sbrk_r>:
   195ac:	b538      	push	{r3, r4, r5, lr}
   195ae:	4c06      	ldr	r4, [pc, #24]	; (195c8 <_sbrk_r+0x1c>)
   195b0:	2300      	movs	r3, #0
   195b2:	4605      	mov	r5, r0
   195b4:	4608      	mov	r0, r1
   195b6:	6023      	str	r3, [r4, #0]
   195b8:	f7fb fd88 	bl	150cc <_sbrk>
   195bc:	1c43      	adds	r3, r0, #1
   195be:	d102      	bne.n	195c6 <_sbrk_r+0x1a>
   195c0:	6823      	ldr	r3, [r4, #0]
   195c2:	b103      	cbz	r3, 195c6 <_sbrk_r+0x1a>
   195c4:	602b      	str	r3, [r5, #0]
   195c6:	bd38      	pop	{r3, r4, r5, pc}
   195c8:	100016b8 	.word	0x100016b8

000195cc <_raise_r>:
   195cc:	291f      	cmp	r1, #31
   195ce:	b538      	push	{r3, r4, r5, lr}
   195d0:	4604      	mov	r4, r0
   195d2:	460d      	mov	r5, r1
   195d4:	d904      	bls.n	195e0 <_raise_r+0x14>
   195d6:	2316      	movs	r3, #22
   195d8:	6003      	str	r3, [r0, #0]
   195da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   195de:	bd38      	pop	{r3, r4, r5, pc}
   195e0:	6c42      	ldr	r2, [r0, #68]	; 0x44
   195e2:	b112      	cbz	r2, 195ea <_raise_r+0x1e>
   195e4:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   195e8:	b94b      	cbnz	r3, 195fe <_raise_r+0x32>
   195ea:	4620      	mov	r0, r4
   195ec:	f000 f830 	bl	19650 <_getpid_r>
   195f0:	462a      	mov	r2, r5
   195f2:	4601      	mov	r1, r0
   195f4:	4620      	mov	r0, r4
   195f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   195fa:	f000 b817 	b.w	1962c <_kill_r>
   195fe:	2b01      	cmp	r3, #1
   19600:	d00a      	beq.n	19618 <_raise_r+0x4c>
   19602:	1c59      	adds	r1, r3, #1
   19604:	d103      	bne.n	1960e <_raise_r+0x42>
   19606:	2316      	movs	r3, #22
   19608:	6003      	str	r3, [r0, #0]
   1960a:	2001      	movs	r0, #1
   1960c:	e7e7      	b.n	195de <_raise_r+0x12>
   1960e:	2400      	movs	r4, #0
   19610:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   19614:	4628      	mov	r0, r5
   19616:	4798      	blx	r3
   19618:	2000      	movs	r0, #0
   1961a:	e7e0      	b.n	195de <_raise_r+0x12>

0001961c <raise>:
   1961c:	4b02      	ldr	r3, [pc, #8]	; (19628 <raise+0xc>)
   1961e:	4601      	mov	r1, r0
   19620:	6818      	ldr	r0, [r3, #0]
   19622:	f7ff bfd3 	b.w	195cc <_raise_r>
   19626:	bf00      	nop
   19628:	100008e0 	.word	0x100008e0

0001962c <_kill_r>:
   1962c:	b538      	push	{r3, r4, r5, lr}
   1962e:	4c07      	ldr	r4, [pc, #28]	; (1964c <_kill_r+0x20>)
   19630:	2300      	movs	r3, #0
   19632:	4605      	mov	r5, r0
   19634:	4608      	mov	r0, r1
   19636:	4611      	mov	r1, r2
   19638:	6023      	str	r3, [r4, #0]
   1963a:	f7fb fd2f 	bl	1509c <_kill>
   1963e:	1c43      	adds	r3, r0, #1
   19640:	d102      	bne.n	19648 <_kill_r+0x1c>
   19642:	6823      	ldr	r3, [r4, #0]
   19644:	b103      	cbz	r3, 19648 <_kill_r+0x1c>
   19646:	602b      	str	r3, [r5, #0]
   19648:	bd38      	pop	{r3, r4, r5, pc}
   1964a:	bf00      	nop
   1964c:	100016b8 	.word	0x100016b8

00019650 <_getpid_r>:
   19650:	f7fb bd12 	b.w	15078 <_getpid>

00019654 <__malloc_lock>:
   19654:	4770      	bx	lr

00019656 <__malloc_unlock>:
   19656:	4770      	bx	lr
   19658:	63617453 	.word	0x63617453
   1965c:	6544206b 	.word	0x6544206b
   19660:	20687470 	.word	0x20687470
   19664:	7a25203d 	.word	0x7a25203d
   19668:	00000a64 	.word	0x00000a64
   1966c:	25232020 	.word	0x25232020
   19670:	203a757a 	.word	0x203a757a
   19674:	70257830 	.word	0x70257830
   19678:	0000000a 	.word	0x0000000a
   1967c:	6e75520a 	.word	0x6e75520a
   19680:	6874203a 	.word	0x6874203a
   19684:	6f662065 	.word	0x6f662065
   19688:	776f6c6c 	.word	0x776f6c6c
   1968c:	20676e69 	.word	0x20676e69
   19690:	6d6d6f63 	.word	0x6d6d6f63
   19694:	20646e61 	.word	0x20646e61
   19698:	79206e69 	.word	0x79206e69
   1969c:	2072756f 	.word	0x2072756f
   196a0:	6a6f7270 	.word	0x6a6f7270
   196a4:	20746365 	.word	0x20746365
   196a8:	65726964 	.word	0x65726964
   196ac:	726f7463 	.word	0x726f7463
   196b0:	00000079 	.word	0x00000079
   196b4:	1b20200a 	.word	0x1b20200a
   196b8:	333b315b 	.word	0x333b315b
   196bc:	616d6d37 	.word	0x616d6d37
   196c0:	7320656b 	.word	0x7320656b
   196c4:	6b636174 	.word	0x6b636174
   196c8:	63617274 	.word	0x63617274
   196cc:	73252d65 	.word	0x73252d65
   196d0:	41525420 	.word	0x41525420
   196d4:	3d534543 	.word	0x3d534543
   196d8:	00000022 	.word	0x00000022
   196dc:	70257830 	.word	0x70257830
   196e0:	00000000 	.word	0x00000000
   196e4:	25783020 	.word	0x25783020
   196e8:	00000070 	.word	0x00000070
   196ec:	5b1b0a22 	.word	0x5b1b0a22
   196f0:	00006d30 	.word	0x00006d30
   196f4:	73696854 	.word	0x73696854
   196f8:	6c697720 	.word	0x6c697720
   196fc:	6572206c 	.word	0x6572206c
   19700:	74726f70 	.word	0x74726f70
   19704:	65687420 	.word	0x65687420
   19708:	6c696620 	.word	0x6c696620
   1970c:	6e612065 	.word	0x6e612065
   19710:	696c2064 	.word	0x696c2064
   19714:	6e20656e 	.word	0x6e20656e
   19718:	65626d75 	.word	0x65626d75
   1971c:	68742072 	.word	0x68742072
   19720:	6c207461 	.word	0x6c207461
   19724:	74206465 	.word	0x74206465
   19728:	6874206f 	.word	0x6874206f
   1972c:	66207369 	.word	0x66207369
   19730:	74636e75 	.word	0x74636e75
   19734:	206e6f69 	.word	0x206e6f69
   19738:	6e696562 	.word	0x6e696562
   1973c:	61632067 	.word	0x61632067
   19740:	64656c6c 	.word	0x64656c6c
   19744:	0000002e 	.word	0x0000002e
   19748:	6c707061 	.word	0x6c707061
   1974c:	74616369 	.word	0x74616369
   19750:	006e6f69 	.word	0x006e6f69
   19754:	33345b1b 	.word	0x33345b1b
   19758:	4157206d 	.word	0x4157206d
   1975c:	4e494e52 	.word	0x4e494e52
   19760:	305b1b47 	.word	0x305b1b47
   19764:	6d34393b 	.word	0x6d34393b
   19768:	3a73253a 	.word	0x3a73253a
   1976c:	3b305b1b 	.word	0x3b305b1b
   19770:	256d3239 	.word	0x256d3239
   19774:	5b1b3a73 	.word	0x5b1b3a73
   19778:	33393b30 	.word	0x33393b30
   1977c:	3e64256d 	.word	0x3e64256d
   19780:	305b1b20 	.word	0x305b1b20
   19784:	6d37333b 	.word	0x6d37333b
   19788:	74726f50 	.word	0x74726f50
   1978c:	20642520 	.word	0x20642520
   19790:	6e6e6163 	.word	0x6e6e6163
   19794:	6220746f 	.word	0x6220746f
   19798:	73752065 	.word	0x73752065
   1979c:	66206465 	.word	0x66206465
   197a0:	4520726f 	.word	0x4520726f
   197a4:	72657478 	.word	0x72657478
   197a8:	206c616e 	.word	0x206c616e
   197ac:	65746e49 	.word	0x65746e49
   197b0:	70757272 	.word	0x70757272
   197b4:	202e7374 	.word	0x202e7374
   197b8:	6465654e 	.word	0x6465654e
   197bc:	206f7420 	.word	0x206f7420
   197c0:	20657375 	.word	0x20657375
   197c4:	4f495047 	.word	0x4f495047
   197c8:	206e6f20 	.word	0x206e6f20
   197cc:	74726f50 	.word	0x74726f50
   197d0:	6f203020 	.word	0x6f203020
   197d4:	2e322072 	.word	0x2e322072
   197d8:	6d305b1b 	.word	0x6d305b1b
   197dc:	6d305b1b 	.word	0x6d305b1b
   197e0:	0000000a 	.word	0x0000000a
   197e4:	33345b1b 	.word	0x33345b1b
   197e8:	4157206d 	.word	0x4157206d
   197ec:	4e494e52 	.word	0x4e494e52
   197f0:	305b1b47 	.word	0x305b1b47
   197f4:	6d34393b 	.word	0x6d34393b
   197f8:	3a73253a 	.word	0x3a73253a
   197fc:	3b305b1b 	.word	0x3b305b1b
   19800:	256d3239 	.word	0x256d3239
   19804:	5b1b3a73 	.word	0x5b1b3a73
   19808:	33393b30 	.word	0x33393b30
   1980c:	3e64256d 	.word	0x3e64256d
   19810:	305b1b20 	.word	0x305b1b20
   19814:	6d37333b 	.word	0x6d37333b
   19818:	65676445 	.word	0x65676445
   1981c:	20642520 	.word	0x20642520
   19820:	6e6e6163 	.word	0x6e6e6163
   19824:	6220746f 	.word	0x6220746f
   19828:	73752065 	.word	0x73752065
   1982c:	66206465 	.word	0x66206465
   19830:	4520726f 	.word	0x4520726f
   19834:	72657478 	.word	0x72657478
   19838:	206c616e 	.word	0x206c616e
   1983c:	65746e49 	.word	0x65746e49
   19840:	70757272 	.word	0x70757272
   19844:	4e2e7374 	.word	0x4e2e7374
   19848:	20646565 	.word	0x20646565
   1984c:	75206f74 	.word	0x75206f74
   19850:	61206573 	.word	0x61206573
   19854:	73697220 	.word	0x73697220
   19858:	2c676e69 	.word	0x2c676e69
   1985c:	6c616620 	.word	0x6c616620
   19860:	676e696c 	.word	0x676e696c
   19864:	726f202c 	.word	0x726f202c
   19868:	746f6220 	.word	0x746f6220
   1986c:	6f632068 	.word	0x6f632068
   19870:	6769666e 	.word	0x6769666e
   19874:	74617275 	.word	0x74617275
   19878:	2e6e6f69 	.word	0x2e6e6f69
   1987c:	6d305b1b 	.word	0x6d305b1b
   19880:	0000000a 	.word	0x0000000a
   19884:	31345b1b 	.word	0x31345b1b
   19888:	4952436d 	.word	0x4952436d
   1988c:	41434954 	.word	0x41434954
   19890:	305b1b4c 	.word	0x305b1b4c
   19894:	6d34393b 	.word	0x6d34393b
   19898:	3a73253a 	.word	0x3a73253a
   1989c:	3b305b1b 	.word	0x3b305b1b
   198a0:	256d3239 	.word	0x256d3239
   198a4:	5b1b3a73 	.word	0x5b1b3a73
   198a8:	33393b30 	.word	0x33393b30
   198ac:	3e64256d 	.word	0x3e64256d
   198b0:	305b1b20 	.word	0x305b1b20
   198b4:	6d37333b 	.word	0x6d37333b
   198b8:	65737341 	.word	0x65737341
   198bc:	6f697472 	.word	0x6f697472
   198c0:	6146206e 	.word	0x6146206e
   198c4:	72756c69 	.word	0x72756c69
   198c8:	43202c65 	.word	0x43202c65
   198cc:	69646e6f 	.word	0x69646e6f
   198d0:	6e6f6974 	.word	0x6e6f6974
   198d4:	73655420 	.word	0x73655420
   198d8:	3a646574 	.word	0x3a646574
   198dc:	65702820 	.word	0x65702820
   198e0:	68706972 	.word	0x68706972
   198e4:	6c617265 	.word	0x6c617265
   198e8:	7669645f 	.word	0x7669645f
   198ec:	72656469 	.word	0x72656469
   198f0:	203d3c20 	.word	0x203d3c20
   198f4:	200a2934 	.word	0x200a2934
   198f8:	20202020 	.word	0x20202020
   198fc:	20202020 	.word	0x20202020
   19900:	76694420 	.word	0x76694420
   19904:	72656469 	.word	0x72656469
   19908:	73756d20 	.word	0x73756d20
   1990c:	74276e74 	.word	0x74276e74
   19910:	63786520 	.word	0x63786520
   19914:	20646565 	.word	0x20646565
   19918:	5b1b3233 	.word	0x5b1b3233
   1991c:	5b1b6d30 	.word	0x5b1b6d30
   19920:	000a6d30 	.word	0x000a6d30
   19924:	6972500a 	.word	0x6972500a
   19928:	6e69746e 	.word	0x6e69746e
   1992c:	74532067 	.word	0x74532067
   19930:	206b6361 	.word	0x206b6361
   19934:	63617254 	.word	0x63617254
   19938:	000a3a65 	.word	0x000a3a65
   1993c:	31345b1b 	.word	0x31345b1b
   19940:	4952436d 	.word	0x4952436d
   19944:	41434954 	.word	0x41434954
   19948:	305b1b4c 	.word	0x305b1b4c
   1994c:	6d34393b 	.word	0x6d34393b
   19950:	3a73253a 	.word	0x3a73253a
   19954:	3b305b1b 	.word	0x3b305b1b
   19958:	256d3239 	.word	0x256d3239
   1995c:	5b1b3a73 	.word	0x5b1b3a73
   19960:	33393b30 	.word	0x33393b30
   19964:	3e64256d 	.word	0x3e64256d
   19968:	305b1b20 	.word	0x305b1b20
   1996c:	6d37333b 	.word	0x6d37333b
   19970:	65737341 	.word	0x65737341
   19974:	6f697472 	.word	0x6f697472
   19978:	6146206e 	.word	0x6146206e
   1997c:	72756c69 	.word	0x72756c69
   19980:	43202c65 	.word	0x43202c65
   19984:	69646e6f 	.word	0x69646e6f
   19988:	6e6f6974 	.word	0x6e6f6974
   1998c:	73655420 	.word	0x73655420
   19990:	3a646574 	.word	0x3a646574
   19994:	65642820 	.word	0x65642820
   19998:	65726973 	.word	0x65726973
   1999c:	70735f64 	.word	0x70735f64
   199a0:	5f646565 	.word	0x5f646565
   199a4:	6d5f6e69 	.word	0x6d5f6e69
   199a8:	3c207a68 	.word	0x3c207a68
   199ac:	34383320 	.word	0x34383320
   199b0:	20262620 	.word	0x20262620
   199b4:	69736564 	.word	0x69736564
   199b8:	5f646572 	.word	0x5f646572
   199bc:	65657073 	.word	0x65657073
   199c0:	6e695f64 	.word	0x6e695f64
   199c4:	7a686d5f 	.word	0x7a686d5f
   199c8:	31203e20 	.word	0x31203e20
   199cc:	200a2932 	.word	0x200a2932
   199d0:	20202020 	.word	0x20202020
   199d4:	20202020 	.word	0x20202020
   199d8:	65724620 	.word	0x65724620
   199dc:	6e657571 	.word	0x6e657571
   199e0:	6d207963 	.word	0x6d207963
   199e4:	20747375 	.word	0x20747375
   199e8:	6c206562 	.word	0x6c206562
   199ec:	7265776f 	.word	0x7265776f
   199f0:	61687420 	.word	0x61687420
   199f4:	3833206e 	.word	0x3833206e
   199f8:	484d2034 	.word	0x484d2034
   199fc:	646e617a 	.word	0x646e617a
   19a00:	65726720 	.word	0x65726720
   19a04:	72657461 	.word	0x72657461
   19a08:	61687420 	.word	0x61687420
   19a0c:	726f206e 	.word	0x726f206e
   19a10:	75716520 	.word	0x75716520
   19a14:	74206c61 	.word	0x74206c61
   19a18:	3231206f 	.word	0x3231206f
   19a1c:	7a484d20 	.word	0x7a484d20
   19a20:	6d305b1b 	.word	0x6d305b1b
   19a24:	6d305b1b 	.word	0x6d305b1b
   19a28:	0000000a 	.word	0x0000000a
   19a2c:	31345b1b 	.word	0x31345b1b
   19a30:	4952436d 	.word	0x4952436d
   19a34:	41434954 	.word	0x41434954
   19a38:	305b1b4c 	.word	0x305b1b4c
   19a3c:	6d34393b 	.word	0x6d34393b
   19a40:	3a73253a 	.word	0x3a73253a
   19a44:	3b305b1b 	.word	0x3b305b1b
   19a48:	256d3239 	.word	0x256d3239
   19a4c:	5b1b3a73 	.word	0x5b1b3a73
   19a50:	33393b30 	.word	0x33393b30
   19a54:	3e64256d 	.word	0x3e64256d
   19a58:	305b1b20 	.word	0x305b1b20
   19a5c:	6d37333b 	.word	0x6d37333b
   19a60:	65737341 	.word	0x65737341
   19a64:	6f697472 	.word	0x6f697472
   19a68:	6146206e 	.word	0x6146206e
   19a6c:	72756c69 	.word	0x72756c69
   19a70:	43202c65 	.word	0x43202c65
   19a74:	69646e6f 	.word	0x69646e6f
   19a78:	6e6f6974 	.word	0x6e6f6974
   19a7c:	73655420 	.word	0x73655420
   19a80:	3a646574 	.word	0x3a646574
   19a84:	69642820 	.word	0x69642820
   19a88:	65646976 	.word	0x65646976
   19a8c:	61765f72 	.word	0x61765f72
   19a90:	2065756c 	.word	0x2065756c
   19a94:	2938203c 	.word	0x2938203c
   19a98:	2020200a 	.word	0x2020200a
   19a9c:	20202020 	.word	0x20202020
   19aa0:	50202020 	.word	0x50202020
   19aa4:	64204c4c 	.word	0x64204c4c
   19aa8:	64697669 	.word	0x64697669
   19aac:	76207265 	.word	0x76207265
   19ab0:	65756c61 	.word	0x65756c61
   19ab4:	6e657720 	.word	0x6e657720
   19ab8:	756f2074 	.word	0x756f2074
   19abc:	666f2074 	.word	0x666f2074
   19ac0:	756f6220 	.word	0x756f6220
   19ac4:	1b73646e 	.word	0x1b73646e
   19ac8:	1b6d305b 	.word	0x1b6d305b
   19acc:	0a6d305b 	.word	0x0a6d305b
   19ad0:	00000000 	.word	0x00000000
   19ad4:	31345b1b 	.word	0x31345b1b
   19ad8:	4952436d 	.word	0x4952436d
   19adc:	41434954 	.word	0x41434954
   19ae0:	305b1b4c 	.word	0x305b1b4c
   19ae4:	6d34393b 	.word	0x6d34393b
   19ae8:	3a73253a 	.word	0x3a73253a
   19aec:	3b305b1b 	.word	0x3b305b1b
   19af0:	256d3239 	.word	0x256d3239
   19af4:	5b1b3a73 	.word	0x5b1b3a73
   19af8:	33393b30 	.word	0x33393b30
   19afc:	3e64256d 	.word	0x3e64256d
   19b00:	305b1b20 	.word	0x305b1b20
   19b04:	6d37333b 	.word	0x6d37333b
   19b08:	65737341 	.word	0x65737341
   19b0c:	6f697472 	.word	0x6f697472
   19b10:	6146206e 	.word	0x6146206e
   19b14:	72756c69 	.word	0x72756c69
   19b18:	43202c65 	.word	0x43202c65
   19b1c:	69646e6f 	.word	0x69646e6f
   19b20:	6e6f6974 	.word	0x6e6f6974
   19b24:	73655420 	.word	0x73655420
   19b28:	3a646574 	.word	0x3a646574
   19b2c:	61662820 	.word	0x61662820
   19b30:	2965736c 	.word	0x2965736c
   19b34:	2020200a 	.word	0x2020200a
   19b38:	20202020 	.word	0x20202020
   19b3c:	50202020 	.word	0x50202020
   19b40:	6c204c4c 	.word	0x6c204c4c
   19b44:	206b636f 	.word	0x206b636f
   19b48:	6c756f63 	.word	0x6c756f63
   19b4c:	6f6e2064 	.word	0x6f6e2064
   19b50:	65622074 	.word	0x65622074
   19b54:	74736520 	.word	0x74736520
   19b58:	696c6261 	.word	0x696c6261
   19b5c:	64656873 	.word	0x64656873
   19b60:	66656220 	.word	0x66656220
   19b64:	2065726f 	.word	0x2065726f
   19b68:	656d6974 	.word	0x656d6974
   19b6c:	1b74756f 	.word	0x1b74756f
   19b70:	1b6d305b 	.word	0x1b6d305b
   19b74:	0a6d305b 	.word	0x0a6d305b
   19b78:	00000000 	.word	0x00000000
   19b7c:	31345b1b 	.word	0x31345b1b
   19b80:	4952436d 	.word	0x4952436d
   19b84:	41434954 	.word	0x41434954
   19b88:	305b1b4c 	.word	0x305b1b4c
   19b8c:	6d34393b 	.word	0x6d34393b
   19b90:	3a73253a 	.word	0x3a73253a
   19b94:	3b305b1b 	.word	0x3b305b1b
   19b98:	256d3239 	.word	0x256d3239
   19b9c:	5b1b3a73 	.word	0x5b1b3a73
   19ba0:	33393b30 	.word	0x33393b30
   19ba4:	3e64256d 	.word	0x3e64256d
   19ba8:	305b1b20 	.word	0x305b1b20
   19bac:	6d37333b 	.word	0x6d37333b
   19bb0:	65737341 	.word	0x65737341
   19bb4:	6f697472 	.word	0x6f697472
   19bb8:	6146206e 	.word	0x6146206e
   19bbc:	72756c69 	.word	0x72756c69
   19bc0:	43202c65 	.word	0x43202c65
   19bc4:	69646e6f 	.word	0x69646e6f
   19bc8:	6e6f6974 	.word	0x6e6f6974
   19bcc:	73655420 	.word	0x73655420
   19bd0:	3a646574 	.word	0x3a646574
   19bd4:	70632820 	.word	0x70632820
   19bd8:	69645f75 	.word	0x69645f75
   19bdc:	65646976 	.word	0x65646976
   19be0:	203c2072 	.word	0x203c2072
   19be4:	0a293233 	.word	0x0a293233
   19be8:	20202020 	.word	0x20202020
   19bec:	20202020 	.word	0x20202020
   19bf0:	69442020 	.word	0x69442020
   19bf4:	65646976 	.word	0x65646976
   19bf8:	756d2072 	.word	0x756d2072
   19bfc:	276e7473 	.word	0x276e7473
   19c00:	78652074 	.word	0x78652074
   19c04:	64656563 	.word	0x64656563
   19c08:	1b323320 	.word	0x1b323320
   19c0c:	1b6d305b 	.word	0x1b6d305b
   19c10:	0a6d305b 	.word	0x0a6d305b
   19c14:	00000000 	.word	0x00000000
   19c18:	75736552 	.word	0x75736552
   19c1c:	3d20746c 	.word	0x3d20746c
   19c20:	0a782520 	.word	0x0a782520
   19c24:	ffffff00 	.word	0xffffff00

00019c28 <Gpio::ValidPortCheck()::file>:
   19c28:	6f697067 7070682e ffffff00              gpio.hpp....

00019c34 <Gpio::SetInterruptEdge(GpioInterface::Edge)::file>:
   19c34:	6f697067 7070682e ffffff00              gpio.hpp....

00019c40 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::file>:
   19c40:	6f697067 7070682e ffffff00              gpio.hpp....

00019c4c <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file>:
   19c4c:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   19c5c:	70682e72 ffff0070                       r.hpp...

00019c64 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   19c64:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   19c74:	70682e72 ffff0070                       r.hpp...

00019c7c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   19c7c:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   19c8c:	70682e72 ffff0070                       r.hpp...

00019c94 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   19c94:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   19ca4:	70682e72 ffff0070                       r.hpp...

00019cac <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file>:
   19cac:	74737973 635f6d65 72746e6f 656c6c6f     system_controlle
   19cbc:	70682e72 ffff0070                       r.hpp...

00019cc4 <Ssp::kPinSelect>:
   19cc4:	ff040202                                ....

00019cc8 <Ssp::kSspPinMatrix>:
   19cc8:	00019ec8 00001200 00019ec8 00001100     ................
   19cd8:	00019ec8 00000f00 00019ec8 00000900     ................
   19ce8:	00019ec8 00000800 00019ec8 00000700     ................
   19cf8:	00019ec8 00000101 00019ec8 00000401     ................
   19d08:	00019ec8 00000001                       ........

00019d10 <Ssp::kPowerBit>:
   19d10:	00000015 0000000a 00000014              ............

00019d1c <vtable for Ssd1306>:
	...
   19d24:	0001280d 00012839 00012865 00012a4d     .(..9(..e(..M*..
   19d34:	000126cd 000126f5 00012b25 00012b5d     .&...&..%+..]+..
   19d44:	00012bf1                                .+..

00019d48 <vtable for PixelDisplayInterface>:
	...
   19d50:	00018f91 00018f91 00018f91 00018f91     ................
   19d60:	000126cd 000126f5 00018f91 00018f91     .&...&..........
   19d70:	0001271d                                .'..

00019d74 <vtable for Ssp>:
	...
   19d7c:	00011c41 00011d25 00011d9d 00011e09     A...%...........
   19d8c:	00011ef5 00012101 00012261 0001244d     .....!..a"..M$..
   19d9c:	fffffffc 00000000 000114e1 00011571     ............q...
   19dac:	000115c9 000115e1 000115f5 00011635     ............5...
   19dbc:	00011665                                e...

00019dc0 <vtable for SspInterface>:
	...
   19dc8:	00018f91 00018f91 00018f91 00018f91     ................
   19dd8:	00018f91 00018f91 00018f91 00018f91     ................

00019de8 <vtable for Lpc40xxSystemController>:
	...
   19df0:	000114e1 00011571 000115c9 000115e1     ....q...........
   19e00:	000115f5 00011635 00011665              ....5...e...

00019e0c <vtable for SystemControllerInterface>:
	...
   19e14:	00018f91 00018f91 00018f91 00018f91     ................
   19e24:	00018f91 00018f91 00018f91              ............

00019e30 <vtable for Gpio>:
	...
   19e38:	00010bf9 00010c75 00010cf1 00010d35     ....u.......5...
   19e48:	00010d99 00010dfd 00010e41 00010ead     ........A.......
   19e58:	00010f25 00010f95 0001122d 00011275     %.......-...u...
   19e68:	0001103d 00011099 0001111d 000111a5     =...............

00019e78 <vtable for GpioInterface>:
	...
   19e80:	00018f91 00018f91 00018f91 00018f91     ................
   19e90:	00018f91 00018f91 00018f91 00018f91     ................
   19ea0:	00018f91 00018f91 00018f91 00018f91     ................
   19eb0:	00018f91 00018f91 00018f91 00018f91     ................

00019ec0 <vtable for Pin>:
	...
   19ec8:	000103f5 0001046d 000104ed 00010561     ....m.......a...
   19ed8:	000105d5 00010651 000106cd 00010741     ....Q.......A...
   19ee8:	000107bd 00010831 000108a5 0001097d     ....1.......}...
   19ef8:	000109a9                                ....

00019efc <vtable for PinInterface>:
	...
   19f04:	00018f91 00018f91 00018f91 00018f91     ................
   19f14:	00018f91 00018f91 00018f91 00018f91     ................
   19f24:	00018f91 00018f91 00018f91 00018f91     ................
   19f34:	00018f91                                ....

00019f38 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   19f38:	74726976 206c6175 64696f76 63704c20     virtual void Lpc
   19f48:	78783034 74737953 6f436d65 6f72746e     40xxSystemContro
   19f58:	72656c6c 65533a3a 72655074 65687069     ller::SetPeriphe
   19f68:	436c6172 6b636f6c 69766944 28726564     ralClockDivider(
   19f78:	746e6975 29745f38 ffffff00              uint8_t)....

00019f84 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   19f84:	746e6975 745f3233 63704c20 78783034     uint32_t Lpc40xx
   19f94:	74737953 6f436d65 6f72746e 72656c6c     SystemController
   19fa4:	65533a3a 69614d74 6c6c506e 63704c28     ::SetMainPll(Lpc
   19fb4:	78783034 74737953 6f436d65 6f72746e     40xxSystemContro
   19fc4:	72656c6c 6c503a3a 706e496c 202c7475     ller::PllInput, 
   19fd4:	746e6975 745f3631 ffff0029              uint16_t)...

00019fe0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   19fe0:	746e6975 745f3233 63704c20 78783034     uint32_t Lpc40xx
   19ff0:	74737953 6f436d65 6f72746e 72656c6c     SystemController
   1a000:	61433a3a 6c75636c 50657461 4c286c6c     ::CalculatePll(L
   1a010:	30346370 79537878 6d657473 746e6f43     pc40xxSystemCont
   1a020:	6c6c6f72 3a3a7265 496c6c50 7475706e     roller::PllInput
   1a030:	6975202c 3631746e 0029745f              , uint16_t).

0001a03c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   1a03c:	64696f76 63704c20 78783034 74737953     void Lpc40xxSyst
   1a04c:	6f436d65 6f72746e 72656c6c 65533a3a     emController::Se
   1a05c:	75704374 636f6c43 7669446b 72656469     tCpuClockDivider
   1a06c:	6e697528 745f3874 ffff0029              (uint8_t)...

0001a078 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1a078:	74726976 206c6175 64696f76 69704720     virtual void Gpi
   1a088:	433a3a6f 7261656c 65746e49 70757272     o::ClearInterrup
   1a098:	67644574 70472865 6e496f69 66726574     tEdge(GpioInterf
   1a0a8:	3a656361 6764453a ff002965              ace::Edge)..

0001a0b4 <Gpio::ValidPortCheck()::__PRETTY_FUNCTION__>:
   1a0b4:	6c6f6f62 69704720 563a3a6f 64696c61     bool Gpio::Valid
   1a0c4:	74726f50 63656843 0029286b              PortCheck().

0001a0d0 <Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1a0d0:	74726976 206c6175 64696f76 69704720     virtual void Gpi
   1a0e0:	533a3a6f 6e497465 72726574 45747075     o::SetInterruptE
   1a0f0:	28656764 6f697047 65746e49 63616672     dge(GpioInterfac
   1a100:	453a3a65 29656764 ffffff00 63617453     e::Edge)....Stac
   1a110:	6544206b 20687470 7a25203d 00000a64     k Depth = %zd...
   1a120:	25232020 203a757a 70257830 0000000a       #%zu: 0x%p....
   1a130:	6e75520a 6874203a 6f662065 776f6c6c     .Run: the follow
   1a140:	20676e69 6d6d6f63 20646e61 79206e69     ing command in y
   1a150:	2072756f 6a6f7270 20746365 65726964     our project dire
   1a160:	726f7463 00000079 1b20200a 333b315b     ctory....  .[1;3
   1a170:	616d6d37 7320656b 6b636174 63617274     7mmake stacktrac
   1a180:	73252d65 41525420 3d534543 00000022     e-%s TRACES="...
   1a190:	70257830 00000000 25783020 00000070     0x%p.... 0x%p...
   1a1a0:	5b1b0a22 00006d30 73696854 6c697720     "..[0m..This wil
   1a1b0:	6572206c 74726f70 65687420 6c696620     l report the fil
   1a1c0:	6e612065 696c2064 6e20656e 65626d75     e and line numbe
   1a1d0:	68742072 6c207461 74206465 6874206f     r that led to th
   1a1e0:	66207369 74636e75 206e6f69 6e696562     is function bein
   1a1f0:	61632067 64656c6c 0000002e 6c707061     g called....appl
   1a200:	74616369 006e6f69 33345b1b 4157206d     ication..[43m WA
   1a210:	4e494e52 305b1b47 6d34393b 3a73253a     RNING.[0;94m:%s:
   1a220:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a230:	3e64256d 305b1b20 6d37333b 74726f50     m%d> .[0;37mPort
   1a240:	20642520 6e6e6163 6220746f 73752065      %d cannot be us
   1a250:	66206465 4520726f 72657478 206c616e     ed for External 
   1a260:	65746e49 70757272 202e7374 6465654e     Interrupts. Need
   1a270:	206f7420 20657375 4f495047 206e6f20      to use GPIO on 
   1a280:	74726f50 6f203020 2e322072 6d305b1b     Port 0 or 2..[0m
   1a290:	6d305b1b 0000000a 33345b1b 4157206d     .[0m.....[43m WA
   1a2a0:	4e494e52 305b1b47 6d34393b 3a73253a     RNING.[0;94m:%s:
   1a2b0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a2c0:	3e64256d 305b1b20 6d37333b 65676445     m%d> .[0;37mEdge
   1a2d0:	20642520 6e6e6163 6220746f 73752065      %d cannot be us
   1a2e0:	66206465 4520726f 72657478 206c616e     ed for External 
   1a2f0:	65746e49 70757272 4e2e7374 20646565     Interrupts.Need 
   1a300:	75206f74 61206573 73697220 2c676e69     to use a rising,
   1a310:	6c616620 676e696c 726f202c 746f6220      falling, or bot
   1a320:	6f632068 6769666e 74617275 2e6e6f69     h configuration.
   1a330:	6d305b1b 0000000a 31345b1b 4952436d     .[0m.....[41mCRI
   1a340:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1a350:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a360:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1a370:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1a380:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1a390:	65702820 68706972 6c617265 7669645f      (peripheral_div
   1a3a0:	72656469 203d3c20 200a2934 20202020     ider <= 4).     
   1a3b0:	20202020 76694420 72656469 73756d20          Divider mus
   1a3c0:	74276e74 63786520 20646565 5b1b3233     tn't exceed 32.[
   1a3d0:	5b1b6d30 000a6d30 6972500a 6e69746e     0m.[0m...Printin
   1a3e0:	74532067 206b6361 63617254 000a3a65     g Stack Trace:..
   1a3f0:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1a400:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1a410:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1a420:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1a430:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1a440:	73655420 3a646574 65642820 65726973      Tested: (desire
   1a450:	70735f64 5f646565 6d5f6e69 3c207a68     d_speed_in_mhz <
   1a460:	34383320 20262620 69736564 5f646572      384 && desired_
   1a470:	65657073 6e695f64 7a686d5f 31203e20     speed_in_mhz > 1
   1a480:	200a2932 20202020 20202020 65724620     2).          Fre
   1a490:	6e657571 6d207963 20747375 6c206562     quency must be l
   1a4a0:	7265776f 61687420 3833206e 484d2034     ower than 384 MH
   1a4b0:	646e617a 65726720 72657461 61687420     zand greater tha
   1a4c0:	726f206e 75716520 74206c61 3231206f     n or equal to 12
   1a4d0:	7a484d20 6d305b1b 6d305b1b 0000000a      MHz.[0m.[0m....
   1a4e0:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1a4f0:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1a500:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1a510:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1a520:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1a530:	73655420 3a646574 69642820 65646976      Tested: (divide
   1a540:	61765f72 2065756c 2938203c 2020200a     r_value < 8).   
   1a550:	20202020 50202020 64204c4c 64697669            PLL divid
   1a560:	76207265 65756c61 6e657720 756f2074     er value went ou
   1a570:	666f2074 756f6220 1b73646e 1b6d305b     t of bounds.[0m.
   1a580:	0a6d305b 00000000 31345b1b 4952436d     [0m......[41mCRI
   1a590:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1a5a0:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a5b0:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1a5c0:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1a5d0:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1a5e0:	61662820 2965736c 2020200a 20202020      (false).       
   1a5f0:	50202020 6c204c4c 206b636f 6c756f63        PLL lock coul
   1a600:	6f6e2064 65622074 74736520 696c6261     d not be establi
   1a610:	64656873 66656220 2065726f 656d6974     shed before time
   1a620:	1b74756f 1b6d305b 0a6d305b 00000000     out.[0m.[0m.....
   1a630:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1a640:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1a650:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1a660:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1a670:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1a680:	73655420 3a646574 70632820 69645f75      Tested: (cpu_di
   1a690:	65646976 203c2072 0a293233 20202020     vider < 32).    
   1a6a0:	20202020 69442020 65646976 756d2072           Divider mu
   1a6b0:	276e7473 78652074 64656563 1b323320     stn't exceed 32.
   1a6c0:	1b6d305b 0a6d305b 00000000 32345b1b     [0m.[0m......[42
   1a6d0:	2020206d 464e4920 305b1b4f 6d34393b     m    INFO.[0;94m
   1a6e0:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1a6f0:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1a700:	72617453 5b1b0a74 000a6d30 65636572     Start..[0m..rece
   1a710:	00657669 7474654c 73207265 0a746e65     ive.Letter sent.
   1a720:	00000000 61746144 6325203a 0000000a     ....Data: %c....
   1a730:	48206e49 0a657265 00000000 65726548     In Here.....Here
   1a740:	206e6920 6b736154 00000000 69636552      in Task....Reci
   1a750:	20657665 61746144 6325203a ffff000a     eve Data: %c....

0001a760 <main::file>:
   1a760:	6e69616d 7070632e ffffff00              main.cpp....

0001a76c <main::__PRETTY_FUNCTION__>:
   1a76c:	20746e69 6e69616d ff002928 63617453     int main()..Stac
   1a77c:	6544206b 20687470 7a25203d 00000a64     k Depth = %zd...
   1a78c:	25232020 203a757a 70257830 0000000a       #%zu: 0x%p....
   1a79c:	6e75520a 6874203a 6f662065 776f6c6c     .Run: the follow
   1a7ac:	20676e69 6d6d6f63 20646e61 79206e69     ing command in y
   1a7bc:	2072756f 6a6f7270 20746365 65726964     our project dire
   1a7cc:	726f7463 00000079 1b20200a 333b315b     ctory....  .[1;3
   1a7dc:	616d6d37 7320656b 6b636174 63617274     7mmake stacktrac
   1a7ec:	73252d65 41525420 3d534543 00000022     e-%s TRACES="...
   1a7fc:	70257830 00000000 25783020 00000070     0x%p.... 0x%p...
   1a80c:	5b1b0a22 00006d30 73696854 6c697720     "..[0m..This wil
   1a81c:	6572206c 74726f70 65687420 6c696620     l report the fil
   1a82c:	6e612065 696c2064 6e20656e 65626d75     e and line numbe
   1a83c:	68742072 6c207461 74206465 6874206f     r that led to th
   1a84c:	66207369 74636e75 206e6f69 6e696562     is function bein
   1a85c:	61632067 64656c6c 0000002e 6c707061     g called....appl
   1a86c:	74616369 006e6f69 31345b1b 4952436d     ication..[41mCRI
   1a87c:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1a88c:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1a89c:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1a8ac:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1a8bc:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1a8cc:	65702820 68706972 6c617265 7669645f      (peripheral_div
   1a8dc:	72656469 203d3c20 200a2934 20202020     ider <= 4).     
   1a8ec:	20202020 76694420 72656469 73756d20          Divider mus
   1a8fc:	74276e74 63786520 20646565 5b1b3233     tn't exceed 32.[
   1a90c:	5b1b6d30 000a6d30 6972500a 6e69746e     0m.[0m...Printin
   1a91c:	74532067 206b6361 63617254 000a3a65     g Stack Trace:..
   1a92c:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1a93c:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1a94c:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1a95c:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1a96c:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1a97c:	73655420 3a646574 65642820 65726973      Tested: (desire
   1a98c:	70735f64 5f646565 6d5f6e69 3c207a68     d_speed_in_mhz <
   1a99c:	34383320 20262620 69736564 5f646572      384 && desired_
   1a9ac:	65657073 6e695f64 7a686d5f 31203e20     speed_in_mhz > 1
   1a9bc:	200a2932 20202020 20202020 65724620     2).          Fre
   1a9cc:	6e657571 6d207963 20747375 6c206562     quency must be l
   1a9dc:	7265776f 61687420 3833206e 484d2034     ower than 384 MH
   1a9ec:	646e617a 65726720 72657461 61687420     zand greater tha
   1a9fc:	726f206e 75716520 74206c61 3231206f     n or equal to 12
   1aa0c:	7a484d20 6d305b1b 6d305b1b 0000000a      MHz.[0m.[0m....
   1aa1c:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1aa2c:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1aa3c:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1aa4c:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1aa5c:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1aa6c:	73655420 3a646574 69642820 65646976      Tested: (divide
   1aa7c:	61765f72 2065756c 2938203c 2020200a     r_value < 8).   
   1aa8c:	20202020 50202020 64204c4c 64697669            PLL divid
   1aa9c:	76207265 65756c61 6e657720 756f2074     er value went ou
   1aaac:	666f2074 756f6220 1b73646e 1b6d305b     t of bounds.[0m.
   1aabc:	0a6d305b 00000000 31345b1b 4952436d     [0m......[41mCRI
   1aacc:	41434954 305b1b4c 6d34393b 3a73253a     TICAL.[0;94m:%s:
   1aadc:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1aaec:	3e64256d 305b1b20 6d37333b 65737341     m%d> .[0;37mAsse
   1aafc:	6f697472 6146206e 72756c69 43202c65     rtion Failure, C
   1ab0c:	69646e6f 6e6f6974 73655420 3a646574     ondition Tested:
   1ab1c:	61662820 2965736c 2020200a 20202020      (false).       
   1ab2c:	50202020 6c204c4c 206b636f 6c756f63        PLL lock coul
   1ab3c:	6f6e2064 65622074 74736520 696c6261     d not be establi
   1ab4c:	64656873 66656220 2065726f 656d6974     shed before time
   1ab5c:	1b74756f 1b6d305b 0a6d305b 00000000     out.[0m.[0m.....
   1ab6c:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1ab7c:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ab8c:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1ab9c:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1abac:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1abbc:	73655420 3a646574 70632820 69645f75      Tested: (cpu_di
   1abcc:	65646976 203c2072 0a293233 20202020     vider < 32).    
   1abdc:	20202020 69442020 65646976 756d2072           Divider mu
   1abec:	276e7473 78652074 64656563 1b323320     stn't exceed 32.
   1abfc:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   1ac0c:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1ac1c:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1ac2c:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1ac3c:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1ac4c:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1ac5c:	3a646574 72662820 65757165 2079636e     ted: (frequency 
   1ac6c:	30203d21 20200a29 20202020 20202020     != 0).          
   1ac7c:	6e6e6143 6820746f 20657661 6f72657a     Cannot have zero
   1ac8c:	63697420 7020736b 6d207265 6f726369      ticks per micro
   1ac9c:	6f636573 202c646e 61656c70 63206573     second, please c
   1acac:	736f6f68 20312065 6d20726f 2e65726f     hoose 1 or more.
   1acbc:	6d305b1b 6d305b1b 0000000a 33345b1b     .[0m.[0m.....[43
   1accc:	4157206d 4e494e52 305b1b47 6d34393b     m WARNING.[0;94m
   1acdc:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1acec:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1acfc:	74737953 54206d65 72656d69 73616820     System Timer has
   1ad0c:	49414620 2044454c 73206f74 74726174      FAILED to start
   1ad1c:	305b1b21 305b1b6d ff000a6d              !.[0m.[0m...

0001ad28 <Timer::kPowerbit>:
   1ad28:	00000001 00000002 00000016 00000017     ................

0001ad38 <Timer::kTimerIrq>:
   1ad38:	04030201                                ....

0001ad3c <Timer::kTimerIsr>:
   1ad3c:	000148b9 000148f5 00014931 0001496d     .H...H..1I..mI..

0001ad4c <Timer::Initialize(unsigned long, void (*)(), long)::file>:
   1ad4c:	656d6974 70682e72 ffff0070              timer.hpp...

0001ad58 <Uart::kTxUartPortFunction>:
   1ad58:	05020201                                ....

0001ad5c <Uart::kRxUartPortFunction>:
   1ad5c:	03020201                                ....

0001ad60 <Uart::kPowerbit>:
   1ad60:	00000003 00000018 00000019 00000008     ................

0001ad70 <LowLevelInit()::file>:
   1ad70:	72617473 2e707574 00707063              startup.cpp.

0001ad7c <vtable for Uart>:
	...
   1ad84:	00013e25 00013ef1 00014021 00014155     %>...>..!@..UA..
   1ad94:	fffffffc 00000000 000114e1 00011571     ............q...
   1ada4:	000115c9 000115e1 000115f5 00011635     ............5...
   1adb4:	00011665                                e...

0001adb8 <vtable for Timer>:
	...
   1adc0:	00013b8d 00013cf1 00013de9 fffffffc     .;...<...=......
   1add0:	00000000 000114e1 00011571 000115c9     ........q.......
   1ade0:	000115e1 000115f5 00011635 00011665     ........5...e...

0001adf0 <vtable for SystemTimer>:
	...
   1adf8:	000139d9 00013a0d 00013aa9 fffffffc     .9...:...:......
   1ae08:	00000000 000114e1 00011571 000115c9     ........q.......
   1ae18:	000115e1 000115f5 00011635 00011665     ........5...e...

0001ae28 <Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__>:
   1ae28:	74726976 206c6175 64696f76 6d695420     virtual void Tim
   1ae38:	3a3a7265 74696e49 696c6169 7528657a     er::Initialize(u
   1ae48:	33746e69 2c745f32 72734920 6e696f50     int32_t, IsrPoin
   1ae58:	2c726574 746e6920 745f3233 ffff0029     ter, int32_t)...

0001ae68 <LowLevelInit()::__PRETTY_FUNCTION__>:
   1ae68:	64696f76 776f4c20 6576654c 696e496c     void LowLevelIni
   1ae78:	00292874 63617453 6544206b 20687470     t().Stack Depth 
   1ae88:	7a25203d 00000a64 25232020 203a757a     = %zd...  #%zu: 
   1ae98:	70257830 0000000a 6e75520a 6874203a     0x%p.....Run: th
   1aea8:	6f662065 776f6c6c 20676e69 6d6d6f63     e following comm
   1aeb8:	20646e61 79206e69 2072756f 6a6f7270     and in your proj
   1aec8:	20746365 65726964 726f7463 00000079     ect directory...
   1aed8:	1b20200a 333b315b 616d6d37 7320656b     .  .[1;37mmake s
   1aee8:	6b636174 63617274 73252d65 41525420     tacktrace-%s TRA
   1aef8:	3d534543 00000022 70257830 00000000     CES="...0x%p....
   1af08:	25783020 00000070 5b1b0a22 00006d30      0x%p..."..[0m..
   1af18:	73696854 6c697720 6572206c 74726f70     This will report
   1af28:	65687420 6c696620 6e612065 696c2064      the file and li
   1af38:	6e20656e 65626d75 68742072 6c207461     ne number that l
   1af48:	74206465 6874206f 66207369 74636e75     ed to this funct
   1af58:	206e6f69 6e696562 61632067 64656c6c     ion being called
   1af68:	0000002e 6c707061 74616369 006e6f69     ....application.
   1af78:	31345b1b 4952436d 41434954 305b1b4c     .[41mCRITICAL.[0
   1af88:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1af98:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1afa8:	6d37333b 65737341 6f697472 6146206e     ;37mAssertion Fa
   1afb8:	72756c69 43202c65 69646e6f 6e6f6974     ilure, Condition
   1afc8:	73655420 3a646574 73692820 3d212072      Tested: (isr !=
   1afd8:	746e4920 75727265 6f4c7470 70756b6f      InterruptLookup
   1afe8:	646e6148 2972656c 2020200a 20202020     Handler).       
   1aff8:	4e202020 5349206f 6f662052 20646e75        No ISR found 
   1b008:	20726f66 20656874 74636576 2520726f     for the vector %
   1b018:	305b1b75 305b1b6d 00000a6d 6972500a     u.[0m.[0m....Pri
   1b028:	6e69746e 74532067 206b6361 63617254     nting Stack Trac
   1b038:	000a3a65 31345b1b 7261486d 61462064     e:...[41mHard Fa
   1b048:	20746c75 65637845 6f697470 634f206e     ult Exception Oc
   1b058:	72727563 0a216465 6d305b1b 00000000     curred!..[0m....
   1b068:	203a3072 30257830 2c586c38 3a317220     r0: 0x%08lX, r1:
   1b078:	25783020 586c3830 3272202c 7830203a      0x%08lX, r2: 0x
   1b088:	6c383025 72202c58 30203a33 38302578     %08lX, r3: 0x%08
   1b098:	000a586c 3a323172 25783020 586c3830     lX..r12: 0x%08lX
   1b0a8:	726c202c 7830203a 6c383025 70202c58     , lr: 0x%08lX, p
   1b0b8:	30203a63 38302578 202c586c 3a727370     c: 0x%08lX, psr:
   1b0c8:	25783020 586c3830 ffff000a               0x%08lX....

0001b0d4 <InterruptLookupHandler::file>:
   1b0d4:	65746e69 70757272 70632e74 ffff0070     interrupt.cpp...

0001b0e4 <InterruptLookupHandler::__PRETTY_FUNCTION__>:
   1b0e4:	64696f76 746e4920 75727265 6f4c7470     void InterruptLo
   1b0f4:	70756b6f 646e6148 2872656c ffff0029     okupHandler()...
   1b104:	454c4449 00000000 09632509 25097525     IDLE.....%c.%u.%
   1b114:	75250975 00000a0d 09752509 25752509     u.%u.....%u..%u%
   1b124:	000a0d25 09752509 25313c09 000a0d25     %....%u..<1%%...

0001b134 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10>:
   1b134:	3f800000 41200000 42c80000 447a0000     ...?.. A...B..zD
   1b144:	461c4000 47c35000 49742400 4b189680     .@.F.P.G.$tI...K
   1b154:	4cbebc20 4e6e6b28 63617453 6544206b      ..L(knNStack De
   1b164:	20687470 7a25203d 00000a64 25232020     pth = %zd...  #%
   1b174:	203a757a 70257830 0000000a 6e75520a     zu: 0x%p.....Run
   1b184:	6874203a 6f662065 776f6c6c 20676e69     : the following 
   1b194:	6d6d6f63 20646e61 79206e69 2072756f     command in your 
   1b1a4:	6a6f7270 20746365 65726964 726f7463     project director
   1b1b4:	00000079 1b20200a 333b315b 616d6d37     y....  .[1;37mma
   1b1c4:	7320656b 6b636174 63617274 73252d65     ke stacktrace-%s
   1b1d4:	41525420 3d534543 00000022 70257830      TRACES="...0x%p
   1b1e4:	00000000 25783020 00000070 5b1b0a22     .... 0x%p..."..[
   1b1f4:	00006d30 73696854 6c697720 6572206c     0m..This will re
   1b204:	74726f70 65687420 6c696620 6e612065     port the file an
   1b214:	696c2064 6e20656e 65626d75 68742072     d line number th
   1b224:	6c207461 74206465 6874206f 66207369     at led to this f
   1b234:	74636e75 206e6f69 6e696562 61632067     unction being ca
   1b244:	64656c6c 0000002e 6c707061 74616369     lled....applicat
   1b254:	006e6f69 33345b1b 4157206d 4e494e52     ion..[43m WARNIN
   1b264:	305b1b47 6d34393b 3a73253a 3b305b1b     G.[0;94m:%s:.[0;
   1b274:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b284:	305b1b20 6d37333b 74726f50 20642520      .[0;37mPort %d 
   1b294:	6e6e6163 6220746f 73752065 66206465     cannot be used f
   1b2a4:	4520726f 72657478 206c616e 65746e49     or External Inte
   1b2b4:	70757272 202e7374 6465654e 206f7420     rrupts. Need to 
   1b2c4:	20657375 4f495047 206e6f20 74726f50     use GPIO on Port
   1b2d4:	6f203020 2e322072 6d305b1b 6d305b1b      0 or 2..[0m.[0m
   1b2e4:	0000000a 33345b1b 4157206d 4e494e52     .....[43m WARNIN
   1b2f4:	305b1b47 6d34393b 3a73253a 3b305b1b     G.[0;94m:%s:.[0;
   1b304:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b314:	305b1b20 6d37333b 65676445 20642520      .[0;37mEdge %d 
   1b324:	6e6e6163 6220746f 73752065 66206465     cannot be used f
   1b334:	4520726f 72657478 206c616e 65746e49     or External Inte
   1b344:	70757272 4e2e7374 20646565 75206f74     rrupts.Need to u
   1b354:	61206573 73697220 2c676e69 6c616620     se a rising, fal
   1b364:	676e696c 726f202c 746f6220 6f632068     ling, or both co
   1b374:	6769666e 74617275 2e6e6f69 6d305b1b     nfiguration..[0m
   1b384:	0000000a 31345b1b 4952436d 41434954     .....[41mCRITICA
   1b394:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1b3a4:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b3b4:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1b3c4:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1b3d4:	6e6f6974 73655420 3a646574 65702820     tion Tested: (pe
   1b3e4:	68706972 6c617265 7669645f 72656469     ripheral_divider
   1b3f4:	203d3c20 200a2934 20202020 20202020      <= 4).         
   1b404:	76694420 72656469 73756d20 74276e74      Divider mustn't
   1b414:	63786520 20646565 5b1b3233 5b1b6d30      exceed 32.[0m.[
   1b424:	000a6d30 6972500a 6e69746e 74532067     0m...Printing St
   1b434:	206b6361 63617254 000a3a65 31345b1b     ack Trace:...[41
   1b444:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1b454:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b464:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b474:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1b484:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1b494:	3a646574 65642820 65726973 70735f64     ted: (desired_sp
   1b4a4:	5f646565 6d5f6e69 3c207a68 34383320     eed_in_mhz < 384
   1b4b4:	20262620 69736564 5f646572 65657073      && desired_spee
   1b4c4:	6e695f64 7a686d5f 31203e20 200a2932     d_in_mhz > 12). 
   1b4d4:	20202020 20202020 65724620 6e657571              Frequen
   1b4e4:	6d207963 20747375 6c206562 7265776f     cy must be lower
   1b4f4:	61687420 3833206e 484d2034 646e617a      than 384 MHzand
   1b504:	65726720 72657461 61687420 726f206e      greater than or
   1b514:	75716520 74206c61 3231206f 7a484d20      equal to 12 MHz
   1b524:	6d305b1b 6d305b1b 0000000a 31345b1b     .[0m.[0m.....[41
   1b534:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1b544:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b554:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b564:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1b574:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1b584:	3a646574 69642820 65646976 61765f72     ted: (divider_va
   1b594:	2065756c 2938203c 2020200a 20202020     lue < 8).       
   1b5a4:	50202020 64204c4c 64697669 76207265        PLL divider v
   1b5b4:	65756c61 6e657720 756f2074 666f2074     alue went out of
   1b5c4:	756f6220 1b73646e 1b6d305b 0a6d305b      bounds.[0m.[0m.
   1b5d4:	00000000 31345b1b 4952436d 41434954     .....[41mCRITICA
   1b5e4:	305b1b4c 6d34393b 3a73253a 3b305b1b     L.[0;94m:%s:.[0;
   1b5f4:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b604:	305b1b20 6d37333b 65737341 6f697472      .[0;37mAssertio
   1b614:	6146206e 72756c69 43202c65 69646e6f     n Failure, Condi
   1b624:	6e6f6974 73655420 3a646574 61662820     tion Tested: (fa
   1b634:	2965736c 2020200a 20202020 50202020     lse).          P
   1b644:	6c204c4c 206b636f 6c756f63 6f6e2064     LL lock could no
   1b654:	65622074 74736520 696c6261 64656873     t be established
   1b664:	66656220 2065726f 656d6974 1b74756f      before timeout.
   1b674:	1b6d305b 0a6d305b 00000000 31345b1b     [0m.[0m......[41
   1b684:	4952436d 41434954 305b1b4c 6d34393b     mCRITICAL.[0;94m
   1b694:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b6a4:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b6b4:	65737341 6f697472 6146206e 72756c69     Assertion Failur
   1b6c4:	43202c65 69646e6f 6e6f6974 73655420     e, Condition Tes
   1b6d4:	3a646574 70632820 69645f75 65646976     ted: (cpu_divide
   1b6e4:	203c2072 0a293233 20202020 20202020     r < 32).        
   1b6f4:	69442020 65646976 756d2072 276e7473       Divider mustn'
   1b704:	78652074 64656563 1b323320 1b6d305b     t exceed 32.[0m.
   1b714:	0a6d305b 00000000 35345b1b 2020206d     [0m......[45m   
   1b724:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1b734:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1b744:	3e64256d 305b1b20 6d37333b 6c696146     m%d> .[0;37mFail
   1b754:	74206465 6e69206f 61697469 53206574     ed to initiate S
   1b764:	6d204950 2065646f 68746977 74206e69     PI mode within t
   1b774:	6f656d69 202e7475 726f6241 676e6974     imeout. Aborting
   1b784:	305b1b21 00000a6d 35345b1b 2020206d     !.[0m....[45m   
   1b794:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1b7a4:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1b7b4:	3e64256d 305b1b20 6d37333b 70736552     m%d> .[0;37mResp
   1b7c4:	65736e6f 746e6920 69726765 63207974     onse integrity c
   1b7d4:	6b636568 69616620 2e64656c 6f624120     heck failed. Abo
   1b7e4:	6e697472 5b1b2167 000a6d30 35345b1b     rting!.[0m...[45
   1b7f4:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1b804:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b814:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b824:	75736e55 726f7070 20646574 746c6f76     Unsupported volt
   1b834:	20656761 75206e69 202e6573 726f6241     age in use. Abor
   1b844:	676e6974 305b1b21 00000a6d 35345b1b     ting!.[0m....[45
   1b854:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1b864:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b874:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b884:	43204453 20647261 656d6974 756f2064     SD Card timed ou
   1b894:	41202e74 74726f62 21676e69 6d305b1b     t. Aborting!.[0m
   1b8a4:	0000000a 65757274 00000000 736c6166     ....true....fals
   1b8b4:	00000065 35345b1b 2020206d 4f525245     e....[45m   ERRO
   1b8c4:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1b8d4:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1b8e4:	305b1b20 6d37333b 6c696857 65522065      .[0;37mWhile Re
   1b8f4:	6e696461 6c422067 206b636f 20642523     ading Block #%d 
   1b904:	31435243 5b1b3a36 000a6d30 35345b1b     CRC16:.[0m...[45
   1b914:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1b924:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1b934:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1b944:	65707845 64657463 78302720 58343025     Expected '0x%04X
   1b954:	305b1b27 00000a6d 35345b1b 2020206d     '.[0m....[45m   
   1b964:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1b974:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1b984:	3e64256d 305b1b20 6d37333b 20746f47     m%d> .[0;37mGot 
   1b994:	25783027 27583430 6d305b1b 0000000a     '0x%04X'.[0m....
   1b9a4:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1b9b4:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1b9c4:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1b9d4:	6d37333b 64616552 646d4320 73617720     ;37mRead Cmd was
   1b9e4:	746f6e20 6b636120 6c776f6e 65676465      not acknowledge
   1b9f4:	72702064 7265706f 1b21796c 0a6d305b     d properly!.[0m.
   1ba04:	00000000 35345b1b 2020206d 4f525245     .....[45m   ERRO
   1ba14:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1ba24:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1ba34:	305b1b20 6d37333b 61726150 6574656d      .[0;37mParamete
   1ba44:	72452072 25203a72 305b1b73 00000a6d     r Err: %s.[0m...
   1ba54:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1ba64:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1ba74:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1ba84:	6d37333b 72646441 72724520 7325203a     ;37mAddr Err: %s
   1ba94:	6d305b1b 0000000a 35345b1b 2020206d     .[0m.....[45m   
   1baa4:	4f525245 305b1b52 6d34393b 3a73253a     ERROR.[0;94m:%s:
   1bab4:	3b305b1b 256d3239 5b1b3a73 33393b30     .[0;92m%s:.[0;93
   1bac4:	3e64256d 305b1b20 6d37333b 73617245     m%d> .[0;37mEras
   1bad4:	65532065 72452071 25203a72 305b1b73     e Seq Err: %s.[0
   1bae4:	00000a6d 35345b1b 2020206d 4f525245     m....[45m   ERRO
   1baf4:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1bb04:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1bb14:	305b1b20 6d37333b 206d6f43 20435243      .[0;37mCom CRC 
   1bb24:	3a727245 1b732520 0a6d305b 00000000     Err: %s.[0m.....
   1bb34:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1bb44:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1bb54:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1bb64:	6d37333b 656c6c49 206c6167 20646d43     ;37mIllegal Cmd 
   1bb74:	3a727245 1b732520 0a6d305b 00000000     Err: %s.[0m.....
   1bb84:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1bb94:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1bba4:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1bbb4:	6d37333b 73617245 65522065 3a746573     ;37mErase Reset:
   1bbc4:	1b732520 0a6d305b 00000000 35345b1b      %s.[0m......[45
   1bbd4:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1bbe4:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1bbf4:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1bc04:	49206e49 3a656c64 1b732520 0a6d305b     In Idle: %s.[0m.
   1bc14:	00000000 35345b1b 2020206d 4f525245     .....[45m   ERRO
   1bc24:	305b1b52 6d34393b 3a73253a 3b305b1b     R.[0;94m:%s:.[0;
   1bc34:	256d3239 5b1b3a73 33393b30 3e64256d     92m%s:.[0;93m%d>
   1bc44:	305b1b20 6d37333b 6c696146 74206465      .[0;37mFailed t
   1bc54:	6573206f 74532074 20747261 72646441     o set Start Addr
   1bc64:	21737365 6d305b1b 0000000a 35345b1b     ess!.[0m.....[45
   1bc74:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1bc84:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1bc94:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1bca4:	6c696146 74206465 6573206f 6e452074     Failed to set En
   1bcb4:	64412064 73657264 5b1b2173 000a6d30     d Address!.[0m..
   1bcc4:	35345b1b 2020206d 4f525245 305b1b52     .[45m   ERROR.[0
   1bcd4:	6d34393b 3a73253a 3b305b1b 256d3239     ;94m:%s:.[0;92m%
   1bce4:	5b1b3a73 33393b30 3e64256d 305b1b20     s:.[0;93m%d> .[0
   1bcf4:	6d37333b 6e6b6e55 206e776f 70736572     ;37mUnknown resp
   1bd04:	65736e6f 70797420 41202e65 74726f62     onse type. Abort
   1bd14:	21676e69 6d305b1b 0000000a 35345b1b     ing!.[0m.....[45
   1bd24:	2020206d 4f525245 305b1b52 6d34393b     m   ERROR.[0;94m
   1bd34:	3a73253a 3b305b1b 256d3239 5b1b3a73     :%s:.[0;92m%s:.[
   1bd44:	33393b30 3e64256d 305b1b20 6d37333b     0;93m%d> .[0;37m
   1bd54:	70736552 65736e6f 736e7520 6f707075     Response unsuppo
   1bd64:	64657472 206e6920 20495053 65646f6d     rted in SPI mode
   1bd74:	6241202e 6974726f 1b21676e 0a6d305b     . Aborting!.[0m.
   1bd84:	ffffff00                                ....

0001bd88 <Sd::kCrcTable8>:
   1bd88:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
   1bd98:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
   1bda8:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
   1bdb8:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
   1bdc8:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
   1bdd8:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
   1bde8:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
   1bdf8:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
   1be08:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
   1be18:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
   1be28:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
   1be38:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
   1be48:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
   1be58:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
   1be68:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
   1be78:	151c070e 3138232a 5d544f46 00706b62     ....*#81FOT]bkp.

0001be88 <Sd::kCrcTable16>:
   1be88:	10210000 30632042 50a54084 70e760c6     ..!.B c0.@.P.`.p
   1be98:	91298108 b16ba14a d1adc18c f1efe1ce     ..).J.k.........
   1bea8:	02101231 22523273 429452b5 62d672f7     1...s2R".R.B.r.b
   1beb8:	83189339 a35ab37b c39cd3bd e3def3ff     9...{.Z.........
   1bec8:	34432462 14010420 74c764e6 548544a4     b$C4 ....d.t.D.T
   1bed8:	b54ba56a 95098528 f5cfe5ee d58dc5ac     j.K.(...........
   1bee8:	26723653 06301611 66f676d7 46b45695     S6r&..0..v.f.V.F
   1bef8:	a77ab75b 87389719 e7fef7df c7bcd79d     [.z...8.........
   1bf08:	58e548c4 78a76886 18610840 38232802     .H.X.h.x@.a..(#8
   1bf18:	d9edc9cc f9afe98e 99698948 b92ba90a     ........H.i...+.
   1bf28:	4ad45af5 6a967ab7 0a501a71 2a123a33     .Z.J.z.jq.P.3:.*
   1bf38:	cbdcdbfd eb9efbbf 8b589b79 ab1abb3b     ........y.X.;...
   1bf48:	7c876ca6 5cc54ce4 3c032c22 1c410c60     .l.|.L.\",.<`.A.
   1bf58:	fd8fedae ddcdcdec bd0bad2a 9d498d68     ........*...h.I.
   1bf68:	6eb67e97 4ef45ed5 2e323e13 0e701e51     .~.n.^.N.>2.Q.p.
   1bf78:	efbeff9f cffcdfdd af3abf1b 8f789f59     ..........:.Y.x.
   1bf88:	81a99188 a1ebb1ca c12dd10c e16ff14e     ..........-.N.o.
   1bf98:	00a11080 20e330c2 40255004 60677046     .....0. .P%@Fpg`
   1bfa8:	939883b9 b3daa3fb d31cc33d f35ee37f     ........=.....^.
   1bfb8:	129002b1 32d222f3 52144235 72566277     .....".25B.RwbVr
   1bfc8:	a5cbb5ea 858995a8 e54ff56e c50dd52c     ........n.O.,...
   1bfd8:	24c334e2 048114a0 64477466 44055424     .4.$....ftGd$T.D
   1bfe8:	b7faa7db 97b88799 f77ee75f d73cc71d     ........_.~...<.
   1bff8:	36f226d3 16b00691 76766657 56344615     .&.6....Wfvv.F4V
   1c008:	c96dd94c e92ff90e 89e999c8 a9abb98a     L.m.../.........
   1c018:	48655844 68277806 08e118c0 28a33882     DXeH.x'h.....8.(
   1c028:	db5ccb7d fb1eeb3f 9bd88bf9 bb9aabbb     }.\.?...........
   1c038:	5a544a75 7a166a37 1ad00af1 3a922ab3     uJTZ7j.z.....*.:
   1c048:	ed0ffd2e cd4ddd6c ad8bbdaa 8dc99de8     ....l.M.........
   1c058:	6c077c26 4c455c64 2c833ca2 0cc11ce0     &|.ld\EL.<.,....
   1c068:	ff3eef1f df7ccf5d bfbaaf9b 9ff88fd9     ..>.].|.........
   1c078:	7e366e17 5e744e55 3eb22e93 1ef00ed1     .n6~UNt^...>....

0001c088 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c088:	682e6473 ff007070                       sd.hpp..

0001c090 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c090:	682e6473 ff007070                       sd.hpp..

0001c098 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c098:	682e6473 ff007070                       sd.hpp..

0001c0a0 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1c0a0:	682e6473 ff007070                       sd.hpp..

0001c0a8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0a8:	682e6473 ff007070                       sd.hpp..

0001c0b0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0b0:	682e6473 ff007070                       sd.hpp..

0001c0b8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0b8:	682e6473 ff007070                       sd.hpp..

0001c0c0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0c0:	682e6473 ff007070                       sd.hpp..

0001c0c8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0c8:	682e6473 ff007070                       sd.hpp..

0001c0d0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0d0:	682e6473 ff007070                       sd.hpp..

0001c0d8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0d8:	682e6473 ff007070                       sd.hpp..

0001c0e0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0e0:	682e6473 ff007070                       sd.hpp..

0001c0e8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0e8:	682e6473 ff007070                       sd.hpp..

0001c0f0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0f0:	682e6473 ff007070                       sd.hpp..

0001c0f8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1c0f8:	682e6473 ff007070                       sd.hpp..

0001c100 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1c100:	682e6473 ff007070                       sd.hpp..

0001c108 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1c108:	682e6473 ff007070                       sd.hpp..

0001c110 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1c110:	682e6473 ff007070                       sd.hpp..

0001c118 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1c118:	682e6473 ff007070                       sd.hpp..

0001c120 <vtable for Sd>:
	...
   1c128:	00018819 00017c71 00017d21 00018135     ....q|..!}..5...
   1c138:	0001854d 000186f9 00018cb9 00018d01     M...............
   1c148:	00018d71                                q...

0001c14c <vtable for SdInterface>:
	...
   1c154:	00018f91 00018f91 00018f91 00018f91     ................
   1c164:	00018f91 00018f91 00018f91 00018f91     ................
   1c174:	00018f91                                ....

0001c178 <Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__>:
   1c178:	74726976 206c6175 6c6f6f62 3a645320     virtual bool Sd:
   1c188:	756f4d3a 5328746e 746e4964 61667265     :Mount(SdInterfa
   1c198:	3a3a6563 64726143 6f666e49 292a745f     ce::CardInfo_t*)
   1c1a8:	ffffff00                                ....

0001c1ac <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__>:
   1c1ac:	74726976 206c6175 746e6975 20745f38     virtual uint8_t 
   1c1bc:	3a3a6453 64616552 636f6c42 6975286b     Sd::ReadBlock(ui
   1c1cc:	3233746e 202c745f 746e6975 2a745f38     nt32_t, uint8_t*
   1c1dc:	6975202c 3233746e 0029745f              , uint32_t).

0001c1e8 <Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__>:
   1c1e8:	74726976 206c6175 746e6975 20745f38     virtual uint8_t 
   1c1f8:	3a3a6453 656c6544 6c426574 286b636f     Sd::DeleteBlock(
   1c208:	746e6975 745f3233 6975202c 3233746e     uint32_t, uint32
   1c218:	0029745f                                _t).

0001c21c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__>:
   1c21c:	74726976 206c6175 746e6975 745f3233     virtual uint32_t
   1c22c:	3a645320 6e65533a 646d4364 49645328      Sd::SendCmd(SdI
   1c23c:	7265746e 65636166 6f433a3a 6e616d6d     nterface::Comman
   1c24c:	75202c64 33746e69 2c745f32 6e697520     d, uint32_t, uin
   1c25c:	745f3874 75202c2a 33746e69 2c745f32     t8_t*, uint32_t,
   1c26c:	49645320 7265746e 65636166 654b3a3a      SdInterface::Ke
   1c27c:	6c417065 29657669 ffffff00              epAlive)....

0001c288 <__sf_fake_stderr>:
	...

0001c2a8 <__sf_fake_stdin>:
	...

0001c2c8 <__sf_fake_stdout>:
	...
