
build/application/firmware.elf:     file format elf32-littlearm
build/application/firmware.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00012be1

Program Header:
0x70000001 off    0x0001b344 vaddr 0x0001b344 paddr 0x0001b344 align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010000 vaddr 0x00010000 paddr 0x00010000 align 2**16
         filesz 0x0000b34c memsz 0x0000b34c flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x0001b34c align 2**16
         filesz 0x00000284 memsz 0x00000284 flags rw-
    LOAD off    0x00020288 vaddr 0x10000288 paddr 0x10000288 align 2**16
         filesz 0x00000000 memsz 0x000006cc flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name             Size      VMA       LMA       File off  Algn  Flags
  0 .text            0000b344  00010000  00010000  00010000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data            00000284  10000000  0001b34c  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2       00000000  20000000  20000000  00020284  2**2  CONTENTS
  3 .bss             000006cc  10000288  10000288  00020288  2**3  ALLOC
  4 .ARM.exidx       00000008  0001b344  0001b344  0001b344  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .uninit_RESERVED 00000000  10000000  10000000  00020284  2**2  CONTENTS
  6 .noinit_RAM2     00000000  20000000  20000000  00020284  2**2  CONTENTS
  7 .noinit          00000000  10000954  10000954  00020284  2**2  CONTENTS
  8 .ARM.attributes  00000030  00000000  00000000  00020284  2**0  CONTENTS, READONLY
  9 .comment         0000007e  00000000  00000000  000202b4  2**0  CONTENTS, READONLY
 10 .debug_info      00044c6a  00000000  00000000  00020332  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev    00005107  00000000  00000000  00064f9c  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges   00000ef8  00000000  00000000  0006a0a3  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges    00000e38  00000000  00000000  0006af9b  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_line      0000795f  00000000  00000000  0006bdd3  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_str       0001aa4a  00000000  00000000  00073732  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame     00003a18  00000000  00000000  0008e17c  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
20000000 l    d  .data_RAM2	00000000 .data_RAM2
10000288 l    d  .bss	00000000 .bss
0001b344 l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
20000000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
10000954 l    d  .noinit	00000000 .noinit
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 interrupt.cpp
000131bc l     F .text	0000002c NVIC_EnableIRQ
000131e8 l     F .text	00000054 NVIC_SetPriority
00010000 l     O .text	000000e4 kInterruptVectorTable
00019ebc l     O .text	0000000e InterruptLookupHandler::file
00019ecc l     O .text	0000001e InterruptLookupHandler::__PRETTY_FUNCTION__
0001022c l       .text	00000000 handler2_address_const
00000000 l    df *ABS*	00000000 startup.cpp
00019ad0 l     O .text	00000049 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__
00019b78 l     O .text	0000005c Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
00019b1c l     O .text	0000005a Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
00019bd4 l     O .text	0000003a Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__
00019c10 l     O .text	0000003e Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__
100000ec l     O .data	00000008 (anonymous namespace)::system_timer
100000f4 l     O .data	00000004 (anonymous namespace)::system_controller
100000f8 l     O .data	0000000c (anonymous namespace)::timer0
000129fc l     F .text	00000040 (anonymous namespace)::Lpc40xxUptime()
1000042c l     O .bss	00000060 idle_task_tcb
1000048c l     O .bss	00000140 idle_task_stack
000199b8 l     O .text	0000000c LowLevelInit()::file
00019c50 l     O .text	00000014 LowLevelInit()::__PRETTY_FUNCTION__
000102fc l     O .text	00000004 kCrpWord
000130d0 l     F .text	000000dc __static_initialization_and_destruction_0(int, int)
000131ac l     F .text	0000000e _GLOBAL__sub_I_UptimeRTOS
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crti.o
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00010328 l     F .text	00000000 __do_global_dtors_aux
10000288 l       .bss	00000001 completed.9929
0001034c l     F .text	00000000 frame_dummy
1000028c l       .bss	00000018 object.9934
0001030c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
100003a8 l     O .bss	00000008 (anonymous namespace)::uptime
00010864 l     F .text	00000030 (anonymous namespace)::DefaultUptime()
0001907c l     O .text	00000009 main::file
000192fc l     O .text	0000000b main::__PRETTY_FUNCTION__
000192b4 l     O .text	00000009 isr_toggle()::file
00019308 l     O .text	00000012 isr_toggle()::__PRETTY_FUNCTION__
000192c0 l     O .text	00000009 isr_toggle2()::file
0001931c l     O .text	00000013 isr_toggle2()::__PRETTY_FUNCTION__
000192cc l     O .text	00000009 led_task(void*)::file
000192d8 l     O .text	00000009 led_task(void*)::file
000192e4 l     O .text	00000009 led_task(void*)::file
000192f0 l     O .text	00000009 led_task(void*)::file
00019330 l     O .text	00000015 led_task(void*)::__PRETTY_FUNCTION__
00010f88 l     F .text	00000070 __static_initialization_and_destruction_0(int, int)
00010ff8 l     F .text	00000028 _GLOBAL__sub_I_binary_sem
00000000 l    df *ABS*	00000000 diskio.cpp
0001b17c l     O .text	0000001c Gpio::ValidPortCheck()::__PRETTY_FUNCTION__
0001b198 l     O .text	00000039 Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001b140 l     O .text	0000003b Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001b1d4 l     O .text	00000031 Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__
0001b208 l     O .text	0000003c Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__
0001b244 l     O .text	00000034 Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__
0001b278 l     O .text	00000069 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__
100008e0 l     O .bss	00000068 (anonymous namespace)::sd_card
00018888 l     F .text	00000050 __static_initialization_and_destruction_0(int, int)
000188d8 l     F .text	00000028 _GLOBAL__sub_I_disk_status
00000000 l    df *ABS*	00000000 LabGPIO.cpp
10000000 l     O .data	00000018 GPIO
10000018 l     O .data	00000028 interrupts
00018fc8 l     O .text	0000000c LabGPIO::IntEdge(LabGPIO::Edge)::file
0001902c l     O .text	00000025 LabGPIO::IntEdge(LabGPIO::Edge)::__PRETTY_FUNCTION__
00019020 l     O .text	0000000c LabGPIO::ClrEdge(LabGPIO::Edge)::file
00019054 l     O .text	00000025 LabGPIO::ClrEdge(LabGPIO::Edge)::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 newlib.cpp
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 tasks.c
100006d8 l     O .bss	00000064 pxReadyTasksLists
1000073c l     O .bss	00000014 xDelayedTaskList1
10000750 l     O .bss	00000014 xDelayedTaskList2
10000764 l     O .bss	00000004 pxDelayedTaskList
10000768 l     O .bss	00000004 pxOverflowDelayedTaskList
1000076c l     O .bss	00000014 xPendingReadyList
10000780 l     O .bss	00000014 xTasksWaitingTermination
10000794 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
10000798 l     O .bss	00000014 xSuspendedTaskList
100007ac l     O .bss	00000004 uxCurrentNumberOfTasks
100007b0 l     O .bss	00000004 xTickCount
100007b4 l     O .bss	00000004 uxTopReadyPriority
100007b8 l     O .bss	00000004 xSchedulerRunning
100007bc l     O .bss	00000004 uxPendedTicks
100007c0 l     O .bss	00000004 xYieldPending
100007c4 l     O .bss	00000004 xNumOfOverflows
100007c8 l     O .bss	00000004 uxTaskNumber
100007cc l     O .bss	00000004 xNextTaskUnblockTime
100007d0 l     O .bss	00000004 xIdleTaskHandle
100007d4 l     O .bss	00000004 uxSchedulerSuspended
100007d8 l     O .bss	00000004 ulTaskSwitchedInTime
100007dc l     O .bss	00000004 ulTotalRunTime
00013808 l     F .text	000000f2 prvInitialiseNewTask
000138fc l     F .text	000000dc prvAddNewTaskToReadyList
00013f60 l     F .text	0000007c prvInitialiseTaskLists
00014034 l     F .text	0000003a prvDeleteTCB
00014070 l     F .text	00000040 prvResetNextTaskUnblockTime
00014398 l     F .text	000000c8 prvAddCurrentTaskToDelayedList
00013f54 l     F .text	0000000c prvIdleTask
00013fdc l     F .text	00000058 prvCheckTasksWaitingTermination
00000000 l    df *ABS*	00000000 queue.c
00014576 l     F .text	00000048 prvInitialiseNewQueue
0001496a l     F .text	000000d2 prvCopyDataToQueue
00014b14 l     F .text	0000002e prvIsQueueFull
00014a3c l     F .text	000000ae prvUnlockQueue
00014aea l     F .text	0000002a prvIsQueueEmpty
00014944 l     F .text	00000026 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 port.c
100001f0 l     O .data	00000004 uxCriticalNesting
00014ba4 l     F .text	00000026 prvTaskExitError
00014bf0 l       .text	00000000 pxCurrentTCBConst2
00014bf8 l     F .text	00000024 prvPortStartFirstTask
00014d78 l     F .text	00000010 vPortEnableVFP
00014d30 l       .text	00000000 pxCurrentTCBConst
00000000 l    df *ABS*	00000000 heap_3.c
00000000 l    df *ABS*	00000000 printf.cpp
00014dd0 l     F .text	00000030 _out_null(char, void*, unsigned int, unsigned int)
00014e00 l     F .text	00000044 _out_char(char, void*, unsigned int, unsigned int)
00014e44 l     F .text	00000044 _strlen(char const*)
00014e88 l     F .text	00000044 _is_digit(char)
00014ecc l     F .text	00000060 _atoi(char const**)
00014f2c l     F .text	0000025c _ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)
00015188 l     F .text	000000e4 _ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)
0001526c l     F .text	000000f4 _ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)
00019f1c l     O .text	00000028 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10
00015360 l     F .text	00000438 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)
00015798 l     F .text	000008f4 _vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)
00000000 l    df *ABS*	00000000 pure.cc
00000000 l    df *ABS*	00000000 eh_terminate.cc
00000000 l    df *ABS*	00000000 sf_round.c
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcpy-stub.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 findfp.c
00000000 l    df *ABS*	00000000 eh_term_handler.cc
00000000 l    df *ABS*	00000000 impure.c
10000224 l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 reent.c
00011264  w    F .text	0000003e Lpc40xxSystemController::GetPeripheralFrequency() const
000134b8 g     F .text	00000038 putchar
0001323c  w    F .text	0000006c Pwm0IrqHandler
0001ab7c  w    O .text	00000009 Gpio::SetInterruptEdge(GpioInterface::Edge)::file
00010218 g     F .text	0000001c HardFaultHandler
000133d0 g     F .text	00000024 _getpid
0001347c g     F .text	0000003c _putchar
0001323c  w    F .text	0000006c EepromIrqHandler
0001323c  w    F .text	0000006c Timer2IrqHandler
100000d8  w    O .data	00000014 uart0
000135bc g     F .text	0000002c GetStackDepth()
0001aeec  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
000169cc  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
00019980  w    O .text	00000004 Timer::kTimerIrq
00014c9c g     F .text	00000028 vPortExitCritical
0001af24  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00018f9c g     F .text	00000024 _kill_r
0001010c g       .text	00000000 bss_section_table_end
0001608c g     F .text	0000004c printf
10000070  w    O .data	00000004 SystemTimer::sys_tick
0001323c  w    F .text	0000006c I2c1IrqHandler
00012c88  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)2>()
00010798 g     F .text	00000050 LabGPIO::ClrRisingEdge()
10000088  w    O .data	00000010 Uart::uart
0001af54  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00010000 g       *ABS*	00000000 __vectors_start__
00018fc6 g     F .text	00000002 __malloc_unlock
00010894  w    F .text	00000044 Milliseconds()
000113c8  w    F .text	00000110 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)
000169f0  w    F .text	00000034 SspInterface::SspInterface()
0001323c  w    F .text	0000006c BusFaultHandler
100005d0 g     O .bss	00000100 stack_trace
10000074  w    O .data	00000004 Pin::pin_map
00012248  w    F .text	000000e4 Uart::Initialize(unsigned long)
20000000 g       *ABS*	00000000 __base_RAM2
0001b34c g       .ARM.exidx	00000000 __exidx_end
000168bc  w    F .text	0000007c Gpio::ClearEdgeRising()
000116b0  w    F .text	00000030 Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)
0001ab70  w    O .text	00000009 Gpio::ValidPortCheck()::file
00010530 g     F .text	000000c8 LabGPIO::GpioInterruptHandler()
100006d4 g     O .bss	00000004 pxCurrentTCB
000160d8  w    F .text	00000034 PinInterface::PinInterface()
000105f8 g     F .text	00000034 LabGPIO::EnableInterrupts()
00013578 g     F .text	0000001c __cyg_profile_func_exit
0001855c  w    F .text	00000048 Sd::Crc7Add(unsigned char, unsigned char)
00017474  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
00012ef0  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()
10000950 g     O .bss	00000004 errno
0001b34c g       .ARM.exidx	00000000 _etext
10000068  w    O .data	00000004 Lpc40xxSystemController::system_controller
00011150  w    F .text	00000090 Lpc40xxSystemController::SetClockFrequency(unsigned char)
00012018  w    F .text	00000030 unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)
00011250  w    F .text	00000014 Lpc40xxSystemController::GetSystemFrequency() const
0001280c  w    F .text	000001f0 Uart::GenerateUartCalibration(float)
10000044  w    O .data	00000018 Gpio::gpio_port
00012048  w    F .text	000000f8 Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)
00012b08  w    F .text	000000bc LowLevelInit()
0001323c  w    F .text	0000006c LcdIrqHandler
0001af7c  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
00080000 g       *ABS*	00000000 __top_MFlash512
00010bd4  w    F .text	0000006c Ssp::Transfer(unsigned short)
00013e94 g     F .text	00000024 vTaskInternalSetTimeOutState
000124ac  w    F .text	000000f8 Uart::Receive(unsigned long)
00011368  w    F .text	00000030 Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)
000109f4  w    F .text	00000030 Delay(unsigned long long)
000199a8  w    O .text	00000010 Uart::kPowerbit
0001323c  w    F .text	0000006c I2c2IrqHandler
100003d8  w    O .bss	00000004 SystemTimer::system_timer_isr
00016784  w    F .text	00000040 Gpio::DetachInterrupt()
0001323c  w    F .text	0000006c CanIrqHandler
00014c20 g     F .text	00000054 xPortStartScheduler
00018da4 g     F .text	00000016 memcpy
00013dc0 g     F .text	0000002c vTaskPlaceOnEventList
100003c8 g     O .bss	00000008 Button2
00011d64  w    F .text	00000074 Pin::EnableDac(bool)
00010448 g     F .text	00000050 LabGPIO::ReadBool()
00012adc g     F .text	0000002c vPortSetupTimerInterrupt
00011a94  w    F .text	0000007c Pin::SetAsAnalogMode(bool)
00014d38 g     F .text	00000040 xPortSysTickHandler
00011648  w    F .text	00000068 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)
00018614  w    F .text	000000fc Sd::GetCrc16(unsigned char*, unsigned short)
00018a2c g     F .text	00000000 .hidden __aeabi_uldivmod
10000954 g       .noinit	00000000 _noinit
000134f0 g     F .text	00000060 puts
00014dae g     F .text	00000022 vPortFree
10000104 g     O .data	000000e4 dynamic_isr_vector_table
000164a4  w    F .text	0000002c Gpio::GetPin()
00010d10 g     F .text	00000060 isr_toggle()
0001654c  w    F .text	0000005c Gpio::SetInterruptRoutine(void (*)())
00016164  w    F .text	00000034 GpioInterface::GpioInterface()
000169f0  w    F .text	00000034 SspInterface::SspInterface()
000147b8 g     F .text	0000018c xQueueSemaphoreTake
0001323c  w    F .text	0000006c RitIrqHandler
0001323c  w    F .text	0000006c Uart2IrqHandler
00011dd8  w    F .text	00000064 Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)
00019958  w    O .text	00000016 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file
0001af0c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00018d84 g     F .text	00000010 malloc
00016f70  w    F .text	00000160 Ssp::GetPeripheralMode()
00012f90  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()
0001892c g     F .text	00000060 roundf
00018f3c g     F .text	00000050 _raise_r
00010904  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::_FUN()
00010b30  w    F .text	0000002c int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)
00016a24  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10010000 g       *ABS*	00000000 __top_RAM
000199a4  w    O .text	00000004 Uart::kRxUartPortFunction
00014cd0 g     F .text	00000066 xPortPendSVHandler
00010930  w    F .text	000000c4 Wait(unsigned long long)
00017440  w    F .text	00000034 SdInterface::SdInterface()
00012140  w    F .text	0000003c Timer::GetTimer()
10000000 g       *ABS*	00000000 __base_RamLoc64
00013594 g     F .text	00000028 GetStackTrace()
100001ec g     O .data	00000004 out
0001362e g     F .text	0000003e vListInsertEnd
1000006c  w    O .data	00000004 Lpc40xxSystemController::speed_in_hertz
0001af5c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001af44  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00018fc0 g     F .text	00000004 _getpid_r
00000000 g       *ABS*	00000000 __base_MFlash512
0001afdc  w    O .text	0000004c vtable for Ssp
10010000 g       *ABS*	00000000 StackTop
00017924  w    F .text	00000064 Sd::WaitToReadBlock()
0001ab94  w    O .text	00000003 Ssp::kPinSelect
00018a5c g     F .text	000002cc .hidden __udivmoddi4
0001323c  w    F .text	0000006c I2sIrqHandler
00018f1c g     F .text	00000020 _sbrk_r
000100fc g       .text	00000000 bss_section_table
0001062c g     F .text	0000007c LabGPIO::IntEdge(LabGPIO::Edge)
00010300 g       .text	00000000 __CRP_WORD_END__
20008000 g       *ABS*	00000000 __top_RAM2
00012be0 g     F .text	00000030 ResetIsr
0001361e g     F .text	00000010 vListInitialiseItem
000178e0  w    F .text	00000044 Sd::ToBool(bool)
0001b028  w    O .text	00000028 vtable for SspInterface
0001323c  w    F .text	0000006c PendSVHandler
00016cd4  w    F .text	00000030 unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)
00011750  w    F .text	00000034 SystemTimer::SetIsrFunction(void (*)())
00010f44  w    F .text	00000044 bool bit::Read<unsigned long>(unsigned long, unsigned long)
00010b5c  w    F .text	00000078 Ssp::IsTransferRegBusy()
0001323c  w    F .text	0000006c UsageFaultHandler
20000000 g       *ABS*	00000000 __user_heap_base
0001b344 g       .text	00000000 __exidx_start
00011c7c  w    F .text	00000074 Pin::EnableI2cHighCurrentDrive(bool)
0001323c  w    F .text	0000006c Uart4IrqHandler
000165a8  w    F .text	00000054 Gpio::ClearInterruptRoutine()
00011c00  w    F .text	0000007c Pin::EnableI2cHighSpeedMode(bool)
000101fc g     F .text	00000018 InitFpu()
00011b10  w    F .text	0000007c Pin::EnableDigitalFilter(bool)
00018d3c g     F .text	00000048 __libc_init_array
0001323c g     F .text	0000006c InterruptLookupHandler
00011398  w    F .text	00000030 Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)
00011238  w    F .text	00000018 Lpc40xxSystemController::GetPeripheralClockDivider() const
10000040  w    O .data	00000004 Uptime
0001b0bc  w    O .text	00000048 vtable for GpioInterface
00012378  w    F .text	000000e8 Uart::Send(unsigned char)
00018d2c g     F .text	0000000e abort
0001323c  w    F .text	0000006c BodIrqHandler
00013424 g     F .text	00000058 _sbrk
00014d8c g     F .text	00000022 pvPortMalloc
000172bc  w    F .text	00000184 Ssp::GetClock()
00010300 g     F .text	00000000 _init
0001010c g       .text	00000000 section_table_end
00013030  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()
000135e8 g     F .text	00000036 vListInitialise
00018920 g     F .text	0000000a std::terminate()
0001898c g     F .text	0000009e .hidden __aeabi_d2f
000145c0 g     F .text	00000150 xQueueGenericSend
00016938  w    F .text	0000007c Gpio::ClearEdgeFalling()
0001323c  w    F .text	0000006c SysTickHandler
000100e4 g       .text	00000000 section_table_start
10000954 g       .bss	00000000 _ebss
00016840  w    F .text	0000007c Gpio::SetEdgeFalling()
0001af1c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001323c  w    F .text	0000006c RtcIrqHandler
000141b8 g     F .text	000000c8 xTaskPriorityDisinherit
00016434  w    F .text	00000070 Gpio::Read()
00012d00  w    F .text	000000a8 Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})
eff80912 g       *ABS*	00000000 ValidUserCodeChecksum
0001323c  w    F .text	0000006c Uart0IrqHandler
00013304 g     F .text	00000078 GetRegistersFromStack
00018710  w    F .text	0000003c unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)
00013dec g     F .text	000000a8 xTaskRemoveFromEventList
0001b104  w    O .text	0000003c vtable for PinInterface
0001323c  w    F .text	0000006c UsbIrqHandler
0001323c  w    F .text	0000006c AdcIrqHandler
00012460  w    F .text	0000004c Uart::Receive(unsigned long)::{lambda()#1}::operator()() const
00011120  w    F .text	00000030 SetUptimeFunction(unsigned long long (*)())
00010368 g     F .text	00000058 LabGPIO::LabGPIO(unsigned char, unsigned char)
0001b2e4 g     O .text	00000020 __sf_fake_stderr
0001abec  w    O .text	00000100 Sd::kCrcTable8
00018910 g     F .text	00000010 std::get_terminate()
00012714  w    F .text	00000074 Uart::FractionalEstimate(float, float)
0001662c  w    F .text	00000088 Gpio::SetInterruptEdge(GpioInterface::Edge)
0001323c  w    F .text	0000006c EnetIrqHandler
0001323c  w    F .text	0000006c DmaIrqHandler
0001010c g     F .text	00000090 InitDataSection()
000132a8 g     F .text	0000005c RegisterIsr(IRQn, void (*)(), bool, long)
00014378 g     F .text	00000020 pvTaskIncrementMutexHeldCount
00000000 g       *ABS*	00000000 __base_Flash
0001323c  w    F .text	0000006c Eint1IrqHandler
100003b4 g     O .bss	00000004 binary_sema
1000005c  w    O .data	0000000c Ssp::ssp_registers
0001323c  w    F .text	0000006c SvcHandler
00013eb8 g     F .text	0000008c xTaskCheckForTimeOut
0001323c  w    F .text	0000006c GpioIrqHandler
00018dcc g     F .text	0000009c _free_r
100003b0 g     O .bss	00000004 binary_sem
0001af6c  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
000140b0 g     F .text	00000108 xTaskPriorityInherit
0001323c  w    F .text	0000006c SdioIrqHandler
10010000 g       *ABS*	00000000 __top_RamLoc64
10000288 g       .bss	00000000 _bss
0001af04  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001323c  w    F .text	0000006c Pll1IrqHandler
0001323c  w    F .text	0000006c MemManageHandler
00013a74 g     F .text	00000014 vTaskSuspendAll
00018900 g     F .text	00000006 __cxa_pure_virtual
0001323c  w    F .text	0000006c Pwm1IrqHandler
000136d4 g     F .text	0000004a uxListRemove
000165fc  w    F .text	00000030 unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)
0001323c  w    F .text	0000006c Timer0IrqHandler
00012da8  w    F .text	000000a8 Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})
00080000 g       *ABS*	00000000 __top_Flash
00012788  w    F .text	00000084 Uart::IsDecmial(float)
000170d0  w    F .text	000001ec Ssp::SetClock(bool, bool, unsigned char, unsigned char)
0001371e g     F .text	0000005c xTaskCreateStatic
10000954 g       .noinit	00000000 _end_noinit
000116e0  w    F .text	0000003c SystemTimer::DisableTimer()
00017f9c  w    F .text	00000120 Sd::DeleteBlock(unsigned long, unsigned long)
00013cf8 g     F .text	000000c8 vTaskSwitchContext
000187c0  w    F .text	00000054 unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)
0001610c  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
00016d34  w    F .text	00000030 unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)
00010d70 g     F .text	00000060 isr_toggle2()
0001af2c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000199a0  w    O .text	00000004 Uart::kTxUartPortFunction
0001323c  w    F .text	0000006c Uart3IrqHandler
000169b4  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
0001af64  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
20000000 g       *ABS*	00000000 __base_RamPeriph32
00012aa8 g     F .text	00000034 vApplicationGetIdleTaskMemory
0001ab88  w    O .text	00000009 Gpio::ClearInterruptEdge(GpioInterface::Edge)::file
100006d0 g     O .bss	00000004 stack_depth
00016350  w    F .text	0000006c Gpio::Toggle()
0001af3c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001acec  w    O .text	00000200 Sd::kCrcTable16
100007e0  w    O .bss	00000100 Gpio::interrupthandlers
00018d28  w    F .text	00000002 .hidden __aeabi_ldiv0
0001323c  w    F .text	0000006c Timer1IrqHandler
000126a0  w    F .text	00000074 Uart::DividerEstimate(float, float)
00010a24  w    F .text	00000064 Gpio::SetHigh()
000106f8 g     F .text	00000050 LabGPIO::setRisingEdge()
000125a4  w    F .text	000000fc Uart::FindClosestFractional(float)
00016ab0  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
000100e4 g       .text	00000000 data_section_table
0001192c  w    F .text	00000080 Pin::SetMode(PinInterface::Mode)
00019910  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
00017988  w    F .text	00000050 Sd::WaitWhileBusy()
00018fc4 g     F .text	00000002 __malloc_lock
00011820  w    F .text	00000094 SystemTimer::SetTickFrequency(unsigned long)
0001b304 g     O .text	00000020 __sf_fake_stdin
00018814  w    F .text	00000074 unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)
000102fc g       .text	00000000 __CRP_WORD_START__
00019984  w    O .text	00000010 Timer::kTimerIsr
0001673c  w    F .text	00000048 Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)
0001323c  w    F .text	0000006c Uart1IrqHandler
00016214  w    F .text	0000007c Gpio::SetAsInput()
00013550 g     F .text	00000028 __cyg_profile_func_enter
00018dba g     F .text	00000010 memset
00010c40 g     F .text	000000d0 main
00017474  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
100003c0 g     O .bss	00000008 led3
100001f4  w    O .data	00000028 Gpio::interrupt
00011ec4  w    F .text	00000020 Timer::DoNothingIsr()
0001323c  w    F .text	0000006c QeiIrqHandler
20000000 g       *ABS*	00000000 heap
0001366c g     F .text	00000068 vListInsert
0001323c  w    F .text	0000006c Ssp2IrqHandler
00011e3c  w    F .text	0000002c Pin::GetPort() const
00017df0  w    F .text	000001ac Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)
0001610c  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
0001898c g     F .text	0000009e .hidden __truncdfsf2
0001031c g       .text	00000000 __init_array_end
00014bd0 g     F .text	00000026 vPortSVCHandler
0001337c g     F .text	0000003c FirmwareStdOut(int)
00018e68 g     F .text	000000b4 _malloc_r
0001af84  w    O .text	0000002c vtable for Sd
000166b4  w    F .text	00000088 Gpio::ClearInterruptEdge(GpioInterface::Edge)
0001323c  w    F .text	0000006c Ssp1IrqHandler
00012c10  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)0>()
0001abe0  w    O .text	0000000c Ssp::kPowerBit
00011e68  w    F .text	0000002c Pin::GetPin() const
00014514 g     F .text	00000062 xQueueGenericCreate
0001217c  w    F .text	000000cc Uart::SetBaudRate(unsigned long)
0001630c  w    F .text	00000044 Gpio::SetDirection(GpioInterface::Direction)
000199c4  w    O .text	0000003c vtable for Uart
00016290  w    F .text	0000007c Gpio::SetAsOutput()
0001af4c  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000114d8  w    F .text	00000170 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)
00010a88  w    F .text	00000064 Gpio::SetLow()
00019aac  w    O .text	00000024 vtable for Lpc40xxSystemController
000179d8  w    F .text	00000418 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)
0001af74  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
000198f8  w    O .text	00000016 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file
00012bc4 g     F .text	0000001a SystemInit
00011ee4  w    F .text	00000134 Timer::Initialize(unsigned long, void (*)(), long)
000112a4  w    F .text	00000030 Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)
20008000 g       *ABS*	00000000 heap_end
00016b94  w    F .text	000000e4 Ssp::Initialize()
00019a00  w    O .text	00000038 vtable for Timer
00016a24  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10000078  w    O .data	00000010 Timer::tim_register
0001323c  w    F .text	0000006c Ssp0IrqHandler
00010368 g     F .text	00000058 LabGPIO::LabGPIO(unsigned char, unsigned char)
0001031c g     F .text	00000000 _fini
0001323c  w    F .text	0000006c UsbactivityIrqHandler
00010aec  w    F .text	00000044 Gpio::Set(GpioInterface::State)
0001323c  w    F .text	0000006c Pll0IrqHandler
00013a88 g     F .text	00000118 xTaskResumeAll
00016a5c  w    F .text	00000054 Pin::Pin(Pin const&)
000100fc g       .text	00000000 data_section_table_end
0001323c  w    F .text	0000006c CanactivityIrqHandler
000139d8 g     F .text	0000009c vTaskStartScheduler
0001323c  w    F .text	0000006c NmiHandler
0001ab98  w    O .text	00000048 Ssp::kSspPinMatrix
000163bc  w    F .text	00000078 Gpio::ReadState()
0001af14  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000106a8 g     F .text	00000050 LabGPIO::setFallingEdge()
10000220 g     O .data	00000004 _impure_ptr
00010e98  w    F .text	000000ac Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
000185a4  w    F .text	00000070 Sd::GetCrc7(unsigned char*, unsigned char)
0001323c  w    F .text	0000006c McpwmIrqHandler
0001030c g       .text	00000000 __preinit_array_end
0001323c  w    F .text	0000006c WdtIrqHandler
000108d8  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::operator()() const
000107e8 g     F .text	0000007c LabGPIO::ClrEdge(LabGPIO::Edge)
000180bc  w    F .text	000004a0 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)
000169cc  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
00019a38  w    O .text	0000003c vtable for Pin
10000000 g       .data	00000000 _data
00011a20  w    F .text	00000074 Pin::SetAsActiveLow(bool)
00011338  w    F .text	00000030 Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)
000167c4  w    F .text	0000007c Gpio::SetEdgeRising()
0001aef4  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
00013f44 g     F .text	00000010 vTaskMissedYield
00011e94  w    F .text	00000030 unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)
1000041c  w    O .bss	00000010 Timer::user_timer_isr
00019928  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
100003dc  w    O .bss	00000040 Timer::match
00010404 g     F .text	00000044 LabGPIO::SetLow()
0001232c  w    F .text	0000004c Uart::Send(unsigned char)::{lambda()#1}::operator()() const
00013ba0 g     F .text	00000158 xTaskIncrementTick
000175c4  w    F .text	0000031c Sd::Mount(SdInterface::CardInfo_t*)
1000021c g     O .data	00000004 __cxxabiv1::__terminate_handler
00014460 g     F .text	000000b4 xQueueGenericReset
0001b050  w    O .text	00000024 vtable for SystemControllerInterface
0001b074  w    O .text	00000048 vtable for Gpio
10000284 g       .data	00000000 _edata
00019970  w    O .text	00000010 Timer::kPowerbit
00012c4c  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)1>()
000119ac  w    F .text	00000074 Pin::EnableHysteresis(bool)
00016164  w    F .text	00000034 GpioInterface::GpioInterface()
00010498 g     F .text	00000048 LabGPIO::toggle()
0001323c  w    F .text	0000006c DebugMonHandler
000164d0  w    F .text	0000007c Gpio::ValidPortCheck()
0001377a g     F .text	0000008e xTaskCreate
0001323c  w    F .text	0000006c Eint2IrqHandler
20008000 g       *ABS*	00000000 __top_RamPeriph32
00016ab0  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
0001323c  w    F .text	0000006c Timer3IrqHandler
00010748 g     F .text	00000050 LabGPIO::ClrFallingEdge()
000103c0 g     F .text	00000044 LabGPIO::SetHigh()
10000000 g       *ABS*	00000000 __base_RAM
0001323c  w    F .text	0000006c Eint3IrqHandler
00018906 g     F .text	00000008 __cxxabiv1::__terminate(void (*)())
00012a7c  w    F .text	0000002c unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])
000133f4 g     F .text	00000030 _kill
0001323c  w    F .text	0000006c I2c0IrqHandler
00016a5c  w    F .text	00000054 Pin::Pin(Pin const&)
00019994  w    O .text	0000000a Timer::Initialize(unsigned long, void (*)(), long)::file
0001171c  w    F .text	00000034 SystemTimer::SystemTimerHandler()
0001aefc  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001b324 g     O .text	00000020 __sf_fake_stdout
00011020  w    F .text	00000100 debug::PrintBacktrace(bool, void*)
00014280 g     F .text	000000f8 vTaskPriorityDisinheritAfterTimeout
0001030c g       .text	00000000 __init_array_start
00018d28  w    F .text	00000002 .hidden __aeabi_idiv0
0001afb0  w    O .text	0000002c vtable for SdInterface
00017514  w    F .text	000000b0 Sd::Initialize()
000133b8 g     F .text	00000018 _exit
00011b8c  w    F .text	00000074 Pin::EnableFastMode(bool)
00012e50  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()
0001323c  w    F .text	0000006c Eint0IrqHandler
00011784  w    F .text	0000009c SystemTimer::StartTimer()
00016d04  w    F .text	00000030 unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)
00014b44 g     F .text	00000060 pxPortInitialiseStack
0001019c g     F .text	00000060 InitBssSection()
1000094c g     O .bss	00000004 __malloc_sbrk_start
00016198  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
00012a3c g     F .text	00000040 UptimeRTOS
00011cf0  w    F .text	00000074 Pin::SetAsOpenDrain(bool)
100002a4 g     O .bss	00000100 LabGPIO::pin_isr_map
00014c74 g     F .text	00000028 vPortEnterCritical
00019a74  w    O .text	00000038 vtable for SystemTimer
0001323c  w    F .text	0000006c SpiIrqHandler
0001af34  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
10000948 g     O .bss	00000004 __malloc_free_list
00016c78  w    F .text	0000005c Ssp::SetSpiMasterDefault()
10000098  w    O .data	00000040 Uart::pairs
000169b4  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
000112d4  w    F .text	00000030 Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)
00017440  w    F .text	00000034 SdInterface::SdInterface()
0001030c g       .text	00000000 __preinit_array_start
00010dd0 g     F .text	000000c8 led_task(void*)
000104e0 g     F .text	00000050 LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)
100001e8  w    O .data	00000004 heap_position
00019940  w    O .text	00000016 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file
00011304  w    F .text	00000034 Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)
100005cc  w    O .bss	00000004 guard variable for Timer::match
00016d64  w    F .text	0000020c Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)
100003b8 g     O .bss	00000008 Button3
000118b4  w    F .text	00000078 Pin::SetPinFunction(unsigned char)
100003d0 g     O .bss	00000008 led2
0001874c  w    F .text	00000074 unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)
000160d8  w    F .text	00000034 PinInterface::PinInterface()
000111e0  w    F .text	00000058 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)
00016198  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
00014710 g     F .text	000000a8 xQueueGiveFromISR
00012cc4  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)3>()
00018f8c g     F .text	00000010 raise
00018d94 g     F .text	00000010 free



Disassembly of section .text:

00010000 <kInterruptVectorTable>:
   10000:	00 00 01 10 e1 2b 01 00 3d 32 01 00 19 02 01 00     .....+..=2......
   10010:	3d 32 01 00 3d 32 01 00 3d 32 01 00 12 09 f8 ef     =2..=2..=2......
	...
   1002c:	d1 4b 01 00 3d 32 01 00 00 00 00 00 d1 4c 01 00     .K..=2.......L..
   1003c:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   1004c:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   1005c:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   1006c:	3d 32 01 00 3d 32 01 00 00 00 00 00 3d 32 01 00     =2..=2......=2..
   1007c:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   1008c:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   1009c:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   100ac:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   100bc:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   100cc:	3d 32 01 00 3d 32 01 00 3d 32 01 00 3d 32 01 00     =2..=2..=2..=2..
   100dc:	3d 32 01 00 3d 32 01 00                             =2..=2..

000100e4 <data_section_table>:
   100e4:	0001b34c 	.word	0x0001b34c
   100e8:	10000000 	.word	0x10000000
   100ec:	00000284 	.word	0x00000284
   100f0:	0001b34c 	.word	0x0001b34c
   100f4:	20000000 	.word	0x20000000
   100f8:	00000000 	.word	0x00000000

000100fc <bss_section_table>:
   100fc:	10000288 	.word	0x10000288
   10100:	000006cc 	.word	0x000006cc
   10104:	20000000 	.word	0x20000000
   10108:	00000000 	.word	0x00000000

0001010c <InitDataSection()>:
SJ2_IGNORE_STACK_TRACE(void SystemInit());

// Functions to carry out the initialization of RW and BSS data sections.
SJ2_SECTION(".after_vectors")
void InitDataSection()
{
   1010c:	b086      	sub	sp, #24
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   1010e:	2300      	movs	r3, #0
   10110:	9305      	str	r3, [sp, #20]
   10112:	9a05      	ldr	r2, [sp, #20]
   10114:	4613      	mov	r3, r2
   10116:	005b      	lsls	r3, r3, #1
   10118:	4413      	add	r3, r2
   1011a:	009b      	lsls	r3, r3, #2
   1011c:	4a1d      	ldr	r2, [pc, #116]	; (10194 <InitDataSection()+0x88>)
   1011e:	4413      	add	r3, r2
   10120:	4a1d      	ldr	r2, [pc, #116]	; (10198 <InitDataSection()+0x8c>)
   10122:	4293      	cmp	r3, r2
   10124:	d233      	bcs.n	1018e <InitDataSection()+0x82>
  {
    uint32_t * rom_location = data_section_table[i].rom_location;
   10126:	491b      	ldr	r1, [pc, #108]	; (10194 <InitDataSection()+0x88>)
   10128:	9a05      	ldr	r2, [sp, #20]
   1012a:	4613      	mov	r3, r2
   1012c:	005b      	lsls	r3, r3, #1
   1012e:	4413      	add	r3, r2
   10130:	009b      	lsls	r3, r3, #2
   10132:	440b      	add	r3, r1
   10134:	681b      	ldr	r3, [r3, #0]
   10136:	9303      	str	r3, [sp, #12]
    uint32_t * ram_location = data_section_table[i].ram_location;
   10138:	4916      	ldr	r1, [pc, #88]	; (10194 <InitDataSection()+0x88>)
   1013a:	9a05      	ldr	r2, [sp, #20]
   1013c:	4613      	mov	r3, r2
   1013e:	005b      	lsls	r3, r3, #1
   10140:	4413      	add	r3, r2
   10142:	009b      	lsls	r3, r3, #2
   10144:	440b      	add	r3, r1
   10146:	685b      	ldr	r3, [r3, #4]
   10148:	9302      	str	r3, [sp, #8]
    uint32_t length         = data_section_table[i].length;
   1014a:	4912      	ldr	r1, [pc, #72]	; (10194 <InitDataSection()+0x88>)
   1014c:	9a05      	ldr	r2, [sp, #20]
   1014e:	4613      	mov	r3, r2
   10150:	005b      	lsls	r3, r3, #1
   10152:	4413      	add	r3, r2
   10154:	009b      	lsls	r3, r3, #2
   10156:	440b      	add	r3, r1
   10158:	3308      	adds	r3, #8
   1015a:	681b      	ldr	r3, [r3, #0]
   1015c:	9301      	str	r3, [sp, #4]
    for (size_t j = 0; j < length; j++)
   1015e:	2300      	movs	r3, #0
   10160:	9304      	str	r3, [sp, #16]
   10162:	9a04      	ldr	r2, [sp, #16]
   10164:	9b01      	ldr	r3, [sp, #4]
   10166:	429a      	cmp	r2, r3
   10168:	d20d      	bcs.n	10186 <InitDataSection()+0x7a>
    {
      ram_location[j] = rom_location[j];
   1016a:	9b04      	ldr	r3, [sp, #16]
   1016c:	009b      	lsls	r3, r3, #2
   1016e:	9a03      	ldr	r2, [sp, #12]
   10170:	441a      	add	r2, r3
   10172:	9b04      	ldr	r3, [sp, #16]
   10174:	009b      	lsls	r3, r3, #2
   10176:	9902      	ldr	r1, [sp, #8]
   10178:	440b      	add	r3, r1
   1017a:	6812      	ldr	r2, [r2, #0]
   1017c:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   1017e:	9b04      	ldr	r3, [sp, #16]
   10180:	3301      	adds	r3, #1
   10182:	9304      	str	r3, [sp, #16]
   10184:	e7ed      	b.n	10162 <InitDataSection()+0x56>
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   10186:	9b05      	ldr	r3, [sp, #20]
   10188:	3301      	adds	r3, #1
   1018a:	9305      	str	r3, [sp, #20]
   1018c:	e7c1      	b.n	10112 <InitDataSection()+0x6>
    }
  }
}
   1018e:	bf00      	nop
   10190:	b006      	add	sp, #24
   10192:	4770      	bx	lr
   10194:	000100e4 	.word	0x000100e4
   10198:	000100fc 	.word	0x000100fc

0001019c <InitBssSection()>:

// Functions to initialization BSS data sections. This is important because
// the std c libs assume that BSS is set to zero.
SJ2_SECTION(".after_vectors")
void InitBssSection()
{
   1019c:	b084      	sub	sp, #16
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   1019e:	2300      	movs	r3, #0
   101a0:	9303      	str	r3, [sp, #12]
   101a2:	9b03      	ldr	r3, [sp, #12]
   101a4:	00db      	lsls	r3, r3, #3
   101a6:	4a13      	ldr	r2, [pc, #76]	; (101f4 <InitBssSection()+0x58>)
   101a8:	4413      	add	r3, r2
   101aa:	4a13      	ldr	r2, [pc, #76]	; (101f8 <InitBssSection()+0x5c>)
   101ac:	4293      	cmp	r3, r2
   101ae:	d21e      	bcs.n	101ee <InitBssSection()+0x52>
  {
    uint32_t * ram_location = bss_section_table[i].ram_location;
   101b0:	4a10      	ldr	r2, [pc, #64]	; (101f4 <InitBssSection()+0x58>)
   101b2:	9b03      	ldr	r3, [sp, #12]
   101b4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   101b8:	9301      	str	r3, [sp, #4]
    uint32_t length         = bss_section_table[i].length;
   101ba:	4a0e      	ldr	r2, [pc, #56]	; (101f4 <InitBssSection()+0x58>)
   101bc:	9b03      	ldr	r3, [sp, #12]
   101be:	00db      	lsls	r3, r3, #3
   101c0:	4413      	add	r3, r2
   101c2:	685b      	ldr	r3, [r3, #4]
   101c4:	9300      	str	r3, [sp, #0]
    for (size_t j = 0; j < length; j++)
   101c6:	2300      	movs	r3, #0
   101c8:	9302      	str	r3, [sp, #8]
   101ca:	9a02      	ldr	r2, [sp, #8]
   101cc:	9b00      	ldr	r3, [sp, #0]
   101ce:	429a      	cmp	r2, r3
   101d0:	d209      	bcs.n	101e6 <InitBssSection()+0x4a>
    {
      ram_location[j] = 0;
   101d2:	9b02      	ldr	r3, [sp, #8]
   101d4:	009b      	lsls	r3, r3, #2
   101d6:	9a01      	ldr	r2, [sp, #4]
   101d8:	4413      	add	r3, r2
   101da:	2200      	movs	r2, #0
   101dc:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   101de:	9b02      	ldr	r3, [sp, #8]
   101e0:	3301      	adds	r3, #1
   101e2:	9302      	str	r3, [sp, #8]
   101e4:	e7f1      	b.n	101ca <InitBssSection()+0x2e>
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101e6:	9b03      	ldr	r3, [sp, #12]
   101e8:	3301      	adds	r3, #1
   101ea:	9303      	str	r3, [sp, #12]
   101ec:	e7d9      	b.n	101a2 <InitBssSection()+0x6>
    }
  }
}
   101ee:	bf00      	nop
   101f0:	b004      	add	sp, #16
   101f2:	4770      	bx	lr
   101f4:	000100fc 	.word	0x000100fc
   101f8:	0001010c 	.word	0x0001010c

000101fc <InitFpu()>:
      // Write back the modified value to the CPACR
      "STR     R1, [R0]\n"
      // Wait for store to complete
      "DSB\n"
      // reset pipeline now the FPU is enabled
      "ISB\n");
   101fc:	f8df 0014 	ldr.w	r0, [pc, #20]	; 10214 <InitFpu()+0x18>
   10200:	6801      	ldr	r1, [r0, #0]
   10202:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   10206:	6001      	str	r1, [r0, #0]
   10208:	f3bf 8f4f 	dsb	sy
   1020c:	f3bf 8f6f 	isb	sy
}
   10210:	bf00      	nop
   10212:	4770      	bx	lr
   10214:	e000ed88 	.word	0xe000ed88

00010218 <HardFaultHandler>:
      " mrseq r0, msp                                       \n"
      " mrsne r0, psp                                       \n"
      " ldr r1, [r0, #24]                                   \n"
      " ldr r2, handler2_address_const                      \n"
      " bx r2                                               \n"
      " handler2_address_const: .word GetRegistersFromStack \n");
   10218:	f01e 0f04 	tst.w	lr, #4
   1021c:	bf0c      	ite	eq
   1021e:	f3ef 8008 	mrseq	r0, MSP
   10222:	f3ef 8009 	mrsne	r0, PSP
   10226:	6981      	ldr	r1, [r0, #24]
   10228:	4a00      	ldr	r2, [pc, #0]	; (1022c <handler2_address_const>)
   1022a:	4710      	bx	r2

0001022c <handler2_address_const>:
   1022c:	00013305 	.word	0x00013305
#endif
}
   10230:	bf00      	nop
   10232:	4770      	bx	lr
   10234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1023c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1024c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1025c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000102fc <__CRP_WORD_START__>:
   102fc:	ffffffff 	.word	0xffffffff

00010300 <_init>:
   10300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10302:	bf00      	nop
   10304:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10306:	bc08      	pop	{r3}
   10308:	469e      	mov	lr, r3
   1030a:	4770      	bx	lr

0001030c <__init_array_start>:
   1030c:	0001034d 	.word	0x0001034d
   10310:	00010ff9 	.word	0x00010ff9
   10314:	000131ad 	.word	0x000131ad
   10318:	000188d9 	.word	0x000188d9

0001031c <_fini>:
   1031c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1031e:	bf00      	nop
   10320:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10322:	bc08      	pop	{r3}
   10324:	469e      	mov	lr, r3
   10326:	4770      	bx	lr

00010328 <__do_global_dtors_aux>:
   10328:	b510      	push	{r4, lr}
   1032a:	4c05      	ldr	r4, [pc, #20]	; (10340 <__do_global_dtors_aux+0x18>)
   1032c:	7823      	ldrb	r3, [r4, #0]
   1032e:	b933      	cbnz	r3, 1033e <__do_global_dtors_aux+0x16>
   10330:	4b04      	ldr	r3, [pc, #16]	; (10344 <__do_global_dtors_aux+0x1c>)
   10332:	b113      	cbz	r3, 1033a <__do_global_dtors_aux+0x12>
   10334:	4804      	ldr	r0, [pc, #16]	; (10348 <__do_global_dtors_aux+0x20>)
   10336:	f3af 8000 	nop.w
   1033a:	2301      	movs	r3, #1
   1033c:	7023      	strb	r3, [r4, #0]
   1033e:	bd10      	pop	{r4, pc}
   10340:	10000288 	.word	0x10000288
   10344:	00000000 	.word	0x00000000
   10348:	0001b34c 	.word	0x0001b34c

0001034c <frame_dummy>:
   1034c:	b508      	push	{r3, lr}
   1034e:	4b03      	ldr	r3, [pc, #12]	; (1035c <frame_dummy+0x10>)
   10350:	b11b      	cbz	r3, 1035a <frame_dummy+0xe>
   10352:	4903      	ldr	r1, [pc, #12]	; (10360 <frame_dummy+0x14>)
   10354:	4803      	ldr	r0, [pc, #12]	; (10364 <frame_dummy+0x18>)
   10356:	f3af 8000 	nop.w
   1035a:	bd08      	pop	{r3, pc}
   1035c:	00000000 	.word	0x00000000
   10360:	1000028c 	.word	0x1000028c
   10364:	0001b34c 	.word	0x0001b34c

00010368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>:
     }};
    //inline static volatile uint32_t *stat= &(LPC_GPIOINT->IntStatus);
    
    IsrPointer LabGPIO::pin_isr_map[kPorts][kPins]={ nullptr};
    
 LabGPIO::LabGPIO(uint8_t port, uint8_t pin){
   10368:	b530      	push	{r4, r5, lr}
   1036a:	b083      	sub	sp, #12
   1036c:	4675      	mov	r5, lr
   1036e:	9001      	str	r0, [sp, #4]
   10370:	460b      	mov	r3, r1
   10372:	f88d 3003 	strb.w	r3, [sp, #3]
   10376:	4613      	mov	r3, r2
   10378:	f88d 3002 	strb.w	r3, [sp, #2]
   1037c:	462b      	mov	r3, r5
   1037e:	4619      	mov	r1, r3
   10380:	480e      	ldr	r0, [pc, #56]	; (103bc <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x54>)
   10382:	f003 f8e5 	bl	13550 <__cyg_profile_func_enter>
    SelPort = port;
   10386:	9b01      	ldr	r3, [sp, #4]
   10388:	f89d 2003 	ldrb.w	r2, [sp, #3]
   1038c:	701a      	strb	r2, [r3, #0]
    SelPin = pin;
   1038e:	9b01      	ldr	r3, [sp, #4]
   10390:	f89d 2002 	ldrb.w	r2, [sp, #2]
   10394:	705a      	strb	r2, [r3, #1]
    
    interrupt_port = (port == 2) ? 1:0;
   10396:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1039a:	2b02      	cmp	r3, #2
   1039c:	d101      	bne.n	103a2 <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x3a>
   1039e:	2201      	movs	r2, #1
   103a0:	e000      	b.n	103a4 <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x3c>
   103a2:	2200      	movs	r2, #0
   103a4:	9b01      	ldr	r3, [sp, #4]
   103a6:	709a      	strb	r2, [r3, #2]
 }
   103a8:	9c01      	ldr	r4, [sp, #4]
   103aa:	462b      	mov	r3, r5
   103ac:	4619      	mov	r1, r3
   103ae:	4803      	ldr	r0, [pc, #12]	; (103bc <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x54>)
   103b0:	f003 f8e2 	bl	13578 <__cyg_profile_func_exit>
   103b4:	4623      	mov	r3, r4
   103b6:	4618      	mov	r0, r3
   103b8:	b003      	add	sp, #12
   103ba:	bd30      	pop	{r4, r5, pc}
   103bc:	00010369 	.word	0x00010369

000103c0 <LabGPIO::SetHigh()>:
    if(direction == Direction::kOutput) SetAsOutput();
    else SetAsInput();
   }
  

  void LabGPIO::SetHigh(){
   103c0:	b510      	push	{r4, lr}
   103c2:	b082      	sub	sp, #8
   103c4:	4674      	mov	r4, lr
   103c6:	9001      	str	r0, [sp, #4]
   103c8:	4623      	mov	r3, r4
   103ca:	4619      	mov	r1, r3
   103cc:	480b      	ldr	r0, [pc, #44]	; (103fc <LabGPIO::SetHigh()+0x3c>)
   103ce:	f003 f8bf 	bl	13550 <__cyg_profile_func_enter>
       /// Set voltage of pin to HIGH
        GPIO[SelPort]-> SET = (1<<SelPin);
   103d2:	9b01      	ldr	r3, [sp, #4]
   103d4:	785b      	ldrb	r3, [r3, #1]
   103d6:	461a      	mov	r2, r3
   103d8:	2301      	movs	r3, #1
   103da:	fa03 f202 	lsl.w	r2, r3, r2
   103de:	9b01      	ldr	r3, [sp, #4]
   103e0:	781b      	ldrb	r3, [r3, #0]
   103e2:	4619      	mov	r1, r3
   103e4:	4b06      	ldr	r3, [pc, #24]	; (10400 <LabGPIO::SetHigh()+0x40>)
   103e6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   103ea:	619a      	str	r2, [r3, #24]
   103ec:	4623      	mov	r3, r4
   103ee:	4619      	mov	r1, r3
   103f0:	4802      	ldr	r0, [pc, #8]	; (103fc <LabGPIO::SetHigh()+0x3c>)
   103f2:	f003 f8c1 	bl	13578 <__cyg_profile_func_exit>
    
  }
   103f6:	bf00      	nop
   103f8:	b002      	add	sp, #8
   103fa:	bd10      	pop	{r4, pc}
   103fc:	000103c1 	.word	0x000103c1
   10400:	10000000 	.word	0x10000000

00010404 <LabGPIO::SetLow()>:
  void LabGPIO::SetLow(){
   10404:	b510      	push	{r4, lr}
   10406:	b082      	sub	sp, #8
   10408:	4674      	mov	r4, lr
   1040a:	9001      	str	r0, [sp, #4]
   1040c:	4623      	mov	r3, r4
   1040e:	4619      	mov	r1, r3
   10410:	480b      	ldr	r0, [pc, #44]	; (10440 <LabGPIO::SetLow()+0x3c>)
   10412:	f003 f89d 	bl	13550 <__cyg_profile_func_enter>
        /// Set voltage of pin to LOW
            GPIO[SelPort]-> CLR = (1<<SelPin);
   10416:	9b01      	ldr	r3, [sp, #4]
   10418:	785b      	ldrb	r3, [r3, #1]
   1041a:	461a      	mov	r2, r3
   1041c:	2301      	movs	r3, #1
   1041e:	fa03 f202 	lsl.w	r2, r3, r2
   10422:	9b01      	ldr	r3, [sp, #4]
   10424:	781b      	ldrb	r3, [r3, #0]
   10426:	4619      	mov	r1, r3
   10428:	4b06      	ldr	r3, [pc, #24]	; (10444 <LabGPIO::SetLow()+0x40>)
   1042a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1042e:	61da      	str	r2, [r3, #28]
   10430:	4623      	mov	r3, r4
   10432:	4619      	mov	r1, r3
   10434:	4802      	ldr	r0, [pc, #8]	; (10440 <LabGPIO::SetLow()+0x3c>)
   10436:	f003 f89f 	bl	13578 <__cyg_profile_func_exit>
   
  }
   1043a:	bf00      	nop
   1043c:	b002      	add	sp, #8
   1043e:	bd10      	pop	{r4, pc}
   10440:	00010405 	.word	0x00010405
   10444:	10000000 	.word	0x10000000

00010448 <LabGPIO::ReadBool()>:
      /// @return level of pin high => true, low => false
     
     return (GPIO[SelPort]->PIN & (1<<SelPin)) ? State::kHigh : State::kLow;
    
  }
 bool LabGPIO::ReadBool(){
   10448:	b530      	push	{r4, r5, lr}
   1044a:	b083      	sub	sp, #12
   1044c:	4675      	mov	r5, lr
   1044e:	9001      	str	r0, [sp, #4]
   10450:	462b      	mov	r3, r5
   10452:	4619      	mov	r1, r3
   10454:	480e      	ldr	r0, [pc, #56]	; (10490 <LabGPIO::ReadBool()+0x48>)
   10456:	f003 f87b 	bl	13550 <__cyg_profile_func_enter>
  /// Should return the state of the pin (input or output, doesn't matter)
  ///
  /// @return level of pin high => true, low => false
  return(GPIO[SelPort]->PIN & (1<<SelPin));
   1045a:	9b01      	ldr	r3, [sp, #4]
   1045c:	781b      	ldrb	r3, [r3, #0]
   1045e:	461a      	mov	r2, r3
   10460:	4b0c      	ldr	r3, [pc, #48]	; (10494 <LabGPIO::ReadBool()+0x4c>)
   10462:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10466:	695b      	ldr	r3, [r3, #20]
   10468:	9a01      	ldr	r2, [sp, #4]
   1046a:	7852      	ldrb	r2, [r2, #1]
   1046c:	4611      	mov	r1, r2
   1046e:	2201      	movs	r2, #1
   10470:	408a      	lsls	r2, r1
   10472:	4013      	ands	r3, r2
   10474:	2b00      	cmp	r3, #0
   10476:	bf14      	ite	ne
   10478:	2301      	movne	r3, #1
   1047a:	2300      	moveq	r3, #0
   1047c:	b2dc      	uxtb	r4, r3
   1047e:	462b      	mov	r3, r5
   10480:	4619      	mov	r1, r3
   10482:	4803      	ldr	r0, [pc, #12]	; (10490 <LabGPIO::ReadBool()+0x48>)
   10484:	f003 f878 	bl	13578 <__cyg_profile_func_exit>
   10488:	4623      	mov	r3, r4
 
  
  }
   1048a:	4618      	mov	r0, r3
   1048c:	b003      	add	sp, #12
   1048e:	bd30      	pop	{r4, r5, pc}
   10490:	00010449 	.word	0x00010449
   10494:	10000000 	.word	0x10000000

00010498 <LabGPIO::toggle()>:
 void LabGPIO::toggle(){
   10498:	b510      	push	{r4, lr}
   1049a:	b082      	sub	sp, #8
   1049c:	4674      	mov	r4, lr
   1049e:	9001      	str	r0, [sp, #4]
   104a0:	4623      	mov	r3, r4
   104a2:	4619      	mov	r1, r3
   104a4:	480d      	ldr	r0, [pc, #52]	; (104dc <LabGPIO::toggle()+0x44>)
   104a6:	f003 f853 	bl	13550 <__cyg_profile_func_enter>
      if(!ReadBool())
   104aa:	9801      	ldr	r0, [sp, #4]
   104ac:	f7ff ffcc 	bl	10448 <LabGPIO::ReadBool()>
   104b0:	4603      	mov	r3, r0
   104b2:	f083 0301 	eor.w	r3, r3, #1
   104b6:	b2db      	uxtb	r3, r3
   104b8:	2b00      	cmp	r3, #0
   104ba:	d003      	beq.n	104c4 <LabGPIO::toggle()+0x2c>
           SetHigh();
   104bc:	9801      	ldr	r0, [sp, #4]
   104be:	f7ff ff7f 	bl	103c0 <LabGPIO::SetHigh()>
   104c2:	e002      	b.n	104ca <LabGPIO::toggle()+0x32>
       else SetLow();
   104c4:	9801      	ldr	r0, [sp, #4]
   104c6:	f7ff ff9d 	bl	10404 <LabGPIO::SetLow()>
   104ca:	4623      	mov	r3, r4
   104cc:	4619      	mov	r1, r3
   104ce:	4803      	ldr	r0, [pc, #12]	; (104dc <LabGPIO::toggle()+0x44>)
   104d0:	f003 f852 	bl	13578 <__cyg_profile_func_exit>
   
  }
   104d4:	bf00      	nop
   104d6:	b002      	add	sp, #8
   104d8:	bd10      	pop	{r4, pc}
   104da:	bf00      	nop
   104dc:	00010499 	.word	0x00010499

000104e0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>:
    pc->pc_inactive(SelPort, SelPin);
  }
void LabGPIO::setRepeater(){
   pc->pc_repeater(SelPort, SelPin);
  }
 void LabGPIO::AttachInterruptHandler(IsrPointer isr, Edge edge){
   104e0:	b510      	push	{r4, lr}
   104e2:	b084      	sub	sp, #16
   104e4:	4674      	mov	r4, lr
   104e6:	9003      	str	r0, [sp, #12]
   104e8:	9102      	str	r1, [sp, #8]
   104ea:	9201      	str	r2, [sp, #4]
   104ec:	4623      	mov	r3, r4
   104ee:	4619      	mov	r1, r3
   104f0:	480d      	ldr	r0, [pc, #52]	; (10528 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x48>)
   104f2:	f003 f82d 	bl	13550 <__cyg_profile_func_enter>
    pin_isr_map[interrupt_port][SelPin]=isr;
   104f6:	9b03      	ldr	r3, [sp, #12]
   104f8:	789b      	ldrb	r3, [r3, #2]
   104fa:	4618      	mov	r0, r3
   104fc:	9b03      	ldr	r3, [sp, #12]
   104fe:	785b      	ldrb	r3, [r3, #1]
   10500:	461a      	mov	r2, r3
   10502:	490a      	ldr	r1, [pc, #40]	; (1052c <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x4c>)
   10504:	0143      	lsls	r3, r0, #5
   10506:	4413      	add	r3, r2
   10508:	9a02      	ldr	r2, [sp, #8]
   1050a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    //printf("%i %i\n",interrupt_port,SelPin);
    IntEdge(edge);
   1050e:	9901      	ldr	r1, [sp, #4]
   10510:	9803      	ldr	r0, [sp, #12]
   10512:	f000 f88b 	bl	1062c <LabGPIO::IntEdge(LabGPIO::Edge)>
   10516:	4623      	mov	r3, r4
   10518:	4619      	mov	r1, r3
   1051a:	4803      	ldr	r0, [pc, #12]	; (10528 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x48>)
   1051c:	f003 f82c 	bl	13578 <__cyg_profile_func_exit>
  
 }
   10520:	bf00      	nop
   10522:	b004      	add	sp, #16
   10524:	bd10      	pop	{r4, pc}
   10526:	bf00      	nop
   10528:	000104e1 	.word	0x000104e1
   1052c:	100002a4 	.word	0x100002a4

00010530 <LabGPIO::GpioInterruptHandler()>:
 void LabGPIO::GpioInterruptHandler(){
   10530:	b510      	push	{r4, lr}
   10532:	b082      	sub	sp, #8
   10534:	4674      	mov	r4, lr
   10536:	4623      	mov	r3, r4
   10538:	4619      	mov	r1, r3
   1053a:	482c      	ldr	r0, [pc, #176]	; (105ec <LabGPIO::GpioInterruptHandler()+0xbc>)
   1053c:	f003 f808 	bl	13550 <__cyg_profile_func_enter>
    uint32_t selPin_local;

  
    if((LPC_GPIOINT->IO0IntStatR) | (LPC_GPIOINT->IO0IntStatF)){
   10540:	4b2b      	ldr	r3, [pc, #172]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10542:	685a      	ldr	r2, [r3, #4]
   10544:	4b2a      	ldr	r3, [pc, #168]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10546:	689b      	ldr	r3, [r3, #8]
   10548:	4313      	orrs	r3, r2
   1054a:	2b00      	cmp	r3, #0
   1054c:	bf14      	ite	ne
   1054e:	2301      	movne	r3, #1
   10550:	2300      	moveq	r3, #0
   10552:	b2db      	uxtb	r3, r3
   10554:	2b00      	cmp	r3, #0
   10556:	d019      	beq.n	1058c <LabGPIO::GpioInterruptHandler()+0x5c>
    selPin_local = __builtin_ctz(LPC_GPIOINT->IO0IntStatR | LPC_GPIOINT->IO0IntStatF);
   10558:	4b25      	ldr	r3, [pc, #148]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   1055a:	685a      	ldr	r2, [r3, #4]
   1055c:	4b24      	ldr	r3, [pc, #144]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   1055e:	689b      	ldr	r3, [r3, #8]
   10560:	4313      	orrs	r3, r2
   10562:	fa93 f3a3 	rbit	r3, r3
   10566:	fab3 f383 	clz	r3, r3
   1056a:	9301      	str	r3, [sp, #4]
    //printf("%i\n",selPin_local);
    pin_isr_map[0][selPin_local]();
   1056c:	4a21      	ldr	r2, [pc, #132]	; (105f4 <LabGPIO::GpioInterruptHandler()+0xc4>)
   1056e:	9b01      	ldr	r3, [sp, #4]
   10570:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10574:	4798      	blx	r3
    LPC_GPIOINT -> IO0IntClr &= ~(1<< selPin_local);
   10576:	4b1e      	ldr	r3, [pc, #120]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10578:	68db      	ldr	r3, [r3, #12]
   1057a:	2101      	movs	r1, #1
   1057c:	9a01      	ldr	r2, [sp, #4]
   1057e:	fa01 f202 	lsl.w	r2, r1, r2
   10582:	43d2      	mvns	r2, r2
   10584:	4611      	mov	r1, r2
   10586:	4a1a      	ldr	r2, [pc, #104]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10588:	400b      	ands	r3, r1
   1058a:	60d3      	str	r3, [r2, #12]
    }
    
   
  
    if((LPC_GPIOINT->IO2IntStatR) | (LPC_GPIOINT->IO2IntStatF)) {
   1058c:	4b18      	ldr	r3, [pc, #96]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   1058e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   10590:	4b17      	ldr	r3, [pc, #92]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10592:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10594:	4313      	orrs	r3, r2
   10596:	2b00      	cmp	r3, #0
   10598:	bf14      	ite	ne
   1059a:	2301      	movne	r3, #1
   1059c:	2300      	moveq	r3, #0
   1059e:	b2db      	uxtb	r3, r3
   105a0:	2b00      	cmp	r3, #0
   105a2:	d01a      	beq.n	105da <LabGPIO::GpioInterruptHandler()+0xaa>
    selPin_local = __builtin_ctz((LPC_GPIOINT->IO2IntStatR)|(LPC_GPIOINT->IO2IntStatF));
   105a4:	4b12      	ldr	r3, [pc, #72]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105a6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   105a8:	4b11      	ldr	r3, [pc, #68]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   105ac:	4313      	orrs	r3, r2
   105ae:	fa93 f3a3 	rbit	r3, r3
   105b2:	fab3 f383 	clz	r3, r3
   105b6:	9301      	str	r3, [sp, #4]
    pin_isr_map[1][selPin_local]();
   105b8:	4a0e      	ldr	r2, [pc, #56]	; (105f4 <LabGPIO::GpioInterruptHandler()+0xc4>)
   105ba:	9b01      	ldr	r3, [sp, #4]
   105bc:	3320      	adds	r3, #32
   105be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   105c2:	4798      	blx	r3
    LPC_GPIOINT -> IO2IntClr &= ~(1<< selPin_local);
   105c4:	4b0a      	ldr	r3, [pc, #40]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   105c8:	2101      	movs	r1, #1
   105ca:	9a01      	ldr	r2, [sp, #4]
   105cc:	fa01 f202 	lsl.w	r2, r1, r2
   105d0:	43d2      	mvns	r2, r2
   105d2:	4611      	mov	r1, r2
   105d4:	4a06      	ldr	r2, [pc, #24]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105d6:	400b      	ands	r3, r1
   105d8:	62d3      	str	r3, [r2, #44]	; 0x2c
   105da:	4623      	mov	r3, r4
   105dc:	4619      	mov	r1, r3
   105de:	4803      	ldr	r0, [pc, #12]	; (105ec <LabGPIO::GpioInterruptHandler()+0xbc>)
   105e0:	f002 ffca 	bl	13578 <__cyg_profile_func_exit>
    }
 }
   105e4:	bf00      	nop
   105e6:	b002      	add	sp, #8
   105e8:	bd10      	pop	{r4, pc}
   105ea:	bf00      	nop
   105ec:	00010531 	.word	0x00010531
   105f0:	40028080 	.word	0x40028080
   105f4:	100002a4 	.word	0x100002a4

000105f8 <LabGPIO::EnableInterrupts()>:
 
void LabGPIO::EnableInterrupts(){
   105f8:	b510      	push	{r4, lr}
   105fa:	4674      	mov	r4, lr
   105fc:	4623      	mov	r3, r4
   105fe:	4619      	mov	r1, r3
   10600:	4808      	ldr	r0, [pc, #32]	; (10624 <LabGPIO::EnableInterrupts()+0x2c>)
   10602:	f002 ffa5 	bl	13550 <__cyg_profile_func_enter>
  // Register GPIO_IRQn here
        RegisterIsr(GPIO_IRQn, GpioInterruptHandler );
   10606:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1060a:	2201      	movs	r2, #1
   1060c:	4906      	ldr	r1, [pc, #24]	; (10628 <LabGPIO::EnableInterrupts()+0x30>)
   1060e:	2026      	movs	r0, #38	; 0x26
   10610:	f002 fe4a 	bl	132a8 <RegisterIsr(IRQn, void (*)(), bool, long)>
   10614:	4623      	mov	r3, r4
   10616:	4619      	mov	r1, r3
   10618:	4802      	ldr	r0, [pc, #8]	; (10624 <LabGPIO::EnableInterrupts()+0x2c>)
   1061a:	f002 ffad 	bl	13578 <__cyg_profile_func_exit>
 }
   1061e:	bf00      	nop
   10620:	bd10      	pop	{r4, pc}
   10622:	bf00      	nop
   10624:	000105f9 	.word	0x000105f9
   10628:	00010531 	.word	0x00010531

0001062c <LabGPIO::IntEdge(LabGPIO::Edge)>:
 
 void LabGPIO::IntEdge(Edge edge){
   1062c:	b510      	push	{r4, lr}
   1062e:	b082      	sub	sp, #8
   10630:	4674      	mov	r4, lr
   10632:	9001      	str	r0, [sp, #4]
   10634:	9100      	str	r1, [sp, #0]
   10636:	4623      	mov	r3, r4
   10638:	4619      	mov	r1, r3
   1063a:	4817      	ldr	r0, [pc, #92]	; (10698 <LabGPIO::IntEdge(LabGPIO::Edge)+0x6c>)
   1063c:	f002 ff88 	bl	13550 <__cyg_profile_func_enter>
    switch(edge)
   10640:	9b00      	ldr	r3, [sp, #0]
   10642:	2b03      	cmp	r3, #3
   10644:	d820      	bhi.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
   10646:	a201      	add	r2, pc, #4	; (adr r2, 1064c <LabGPIO::IntEdge(LabGPIO::Edge)+0x20>)
   10648:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1064c:	0001065d 	.word	0x0001065d
   10650:	0001066b 	.word	0x0001066b
   10654:	00010673 	.word	0x00010673
   10658:	0001067b 	.word	0x0001067b
    {   case Edge::kNone:
                LOG_INFO("No edge selected");
   1065c:	2389      	movs	r3, #137	; 0x89
   1065e:	4a0f      	ldr	r2, [pc, #60]	; (1069c <LabGPIO::IntEdge(LabGPIO::Edge)+0x70>)
   10660:	490f      	ldr	r1, [pc, #60]	; (106a0 <LabGPIO::IntEdge(LabGPIO::Edge)+0x74>)
   10662:	4810      	ldr	r0, [pc, #64]	; (106a4 <LabGPIO::IntEdge(LabGPIO::Edge)+0x78>)
   10664:	f005 fd12 	bl	1608c <printf>
                break;
   10668:	e00e      	b.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
        case Edge::kRising:
            setRisingEdge();
   1066a:	9801      	ldr	r0, [sp, #4]
   1066c:	f000 f844 	bl	106f8 <LabGPIO::setRisingEdge()>
            break;
   10670:	e00a      	b.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
        case Edge::kFalling:
            setFallingEdge();
   10672:	9801      	ldr	r0, [sp, #4]
   10674:	f000 f818 	bl	106a8 <LabGPIO::setFallingEdge()>
            break;
   10678:	e006      	b.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
        case Edge::kBoth:
            setRisingEdge();
   1067a:	9801      	ldr	r0, [sp, #4]
   1067c:	f000 f83c 	bl	106f8 <LabGPIO::setRisingEdge()>
            setFallingEdge();
   10680:	9801      	ldr	r0, [sp, #4]
   10682:	f000 f811 	bl	106a8 <LabGPIO::setFallingEdge()>
            break;   
   10686:	bf00      	nop
   10688:	4623      	mov	r3, r4
   1068a:	4619      	mov	r1, r3
   1068c:	4802      	ldr	r0, [pc, #8]	; (10698 <LabGPIO::IntEdge(LabGPIO::Edge)+0x6c>)
   1068e:	f002 ff73 	bl	13578 <__cyg_profile_func_exit>
    }
 }
   10692:	bf00      	nop
   10694:	b002      	add	sp, #8
   10696:	bd10      	pop	{r4, pc}
   10698:	0001062d 	.word	0x0001062d
   1069c:	0001902c 	.word	0x0001902c
   106a0:	00018fc8 	.word	0x00018fc8
   106a4:	00018fd4 	.word	0x00018fd4

000106a8 <LabGPIO::setFallingEdge()>:
 void LabGPIO::setFallingEdge(){
   106a8:	b510      	push	{r4, lr}
   106aa:	b082      	sub	sp, #8
   106ac:	4674      	mov	r4, lr
   106ae:	9001      	str	r0, [sp, #4]
   106b0:	4623      	mov	r3, r4
   106b2:	4619      	mov	r1, r3
   106b4:	480e      	ldr	r0, [pc, #56]	; (106f0 <LabGPIO::setFallingEdge()+0x48>)
   106b6:	f002 ff4b 	bl	13550 <__cyg_profile_func_enter>
    *interrupts[interrupt_port][4] = (1<<SelPin);
   106ba:	9b01      	ldr	r3, [sp, #4]
   106bc:	785b      	ldrb	r3, [r3, #1]
   106be:	461a      	mov	r2, r3
   106c0:	2301      	movs	r3, #1
   106c2:	fa03 f002 	lsl.w	r0, r3, r2
   106c6:	9b01      	ldr	r3, [sp, #4]
   106c8:	789b      	ldrb	r3, [r3, #2]
   106ca:	4619      	mov	r1, r3
   106cc:	4a09      	ldr	r2, [pc, #36]	; (106f4 <LabGPIO::setFallingEdge()+0x4c>)
   106ce:	460b      	mov	r3, r1
   106d0:	009b      	lsls	r3, r3, #2
   106d2:	440b      	add	r3, r1
   106d4:	009b      	lsls	r3, r3, #2
   106d6:	4413      	add	r3, r2
   106d8:	3310      	adds	r3, #16
   106da:	681b      	ldr	r3, [r3, #0]
   106dc:	4602      	mov	r2, r0
   106de:	601a      	str	r2, [r3, #0]
   106e0:	4623      	mov	r3, r4
   106e2:	4619      	mov	r1, r3
   106e4:	4802      	ldr	r0, [pc, #8]	; (106f0 <LabGPIO::setFallingEdge()+0x48>)
   106e6:	f002 ff47 	bl	13578 <__cyg_profile_func_exit>
 }
   106ea:	bf00      	nop
   106ec:	b002      	add	sp, #8
   106ee:	bd10      	pop	{r4, pc}
   106f0:	000106a9 	.word	0x000106a9
   106f4:	10000018 	.word	0x10000018

000106f8 <LabGPIO::setRisingEdge()>:
 void LabGPIO::setRisingEdge(){
   106f8:	b510      	push	{r4, lr}
   106fa:	b082      	sub	sp, #8
   106fc:	4674      	mov	r4, lr
   106fe:	9001      	str	r0, [sp, #4]
   10700:	4623      	mov	r3, r4
   10702:	4619      	mov	r1, r3
   10704:	480e      	ldr	r0, [pc, #56]	; (10740 <LabGPIO::setRisingEdge()+0x48>)
   10706:	f002 ff23 	bl	13550 <__cyg_profile_func_enter>
    *interrupts[interrupt_port][3] = (1<<SelPin);
   1070a:	9b01      	ldr	r3, [sp, #4]
   1070c:	785b      	ldrb	r3, [r3, #1]
   1070e:	461a      	mov	r2, r3
   10710:	2301      	movs	r3, #1
   10712:	fa03 f002 	lsl.w	r0, r3, r2
   10716:	9b01      	ldr	r3, [sp, #4]
   10718:	789b      	ldrb	r3, [r3, #2]
   1071a:	4619      	mov	r1, r3
   1071c:	4a09      	ldr	r2, [pc, #36]	; (10744 <LabGPIO::setRisingEdge()+0x4c>)
   1071e:	460b      	mov	r3, r1
   10720:	009b      	lsls	r3, r3, #2
   10722:	440b      	add	r3, r1
   10724:	009b      	lsls	r3, r3, #2
   10726:	4413      	add	r3, r2
   10728:	330c      	adds	r3, #12
   1072a:	681b      	ldr	r3, [r3, #0]
   1072c:	4602      	mov	r2, r0
   1072e:	601a      	str	r2, [r3, #0]
   10730:	4623      	mov	r3, r4
   10732:	4619      	mov	r1, r3
   10734:	4802      	ldr	r0, [pc, #8]	; (10740 <LabGPIO::setRisingEdge()+0x48>)
   10736:	f002 ff1f 	bl	13578 <__cyg_profile_func_exit>
 }
   1073a:	bf00      	nop
   1073c:	b002      	add	sp, #8
   1073e:	bd10      	pop	{r4, pc}
   10740:	000106f9 	.word	0x000106f9
   10744:	10000018 	.word	0x10000018

00010748 <LabGPIO::ClrFallingEdge()>:
 void LabGPIO::ClrFallingEdge(){
   10748:	b510      	push	{r4, lr}
   1074a:	b082      	sub	sp, #8
   1074c:	4674      	mov	r4, lr
   1074e:	9001      	str	r0, [sp, #4]
   10750:	4623      	mov	r3, r4
   10752:	4619      	mov	r1, r3
   10754:	480e      	ldr	r0, [pc, #56]	; (10790 <LabGPIO::ClrFallingEdge()+0x48>)
   10756:	f002 fefb 	bl	13550 <__cyg_profile_func_enter>
    *interrupts[interrupt_port][2] = (1<<SelPin);
   1075a:	9b01      	ldr	r3, [sp, #4]
   1075c:	785b      	ldrb	r3, [r3, #1]
   1075e:	461a      	mov	r2, r3
   10760:	2301      	movs	r3, #1
   10762:	fa03 f002 	lsl.w	r0, r3, r2
   10766:	9b01      	ldr	r3, [sp, #4]
   10768:	789b      	ldrb	r3, [r3, #2]
   1076a:	4619      	mov	r1, r3
   1076c:	4a09      	ldr	r2, [pc, #36]	; (10794 <LabGPIO::ClrFallingEdge()+0x4c>)
   1076e:	460b      	mov	r3, r1
   10770:	009b      	lsls	r3, r3, #2
   10772:	440b      	add	r3, r1
   10774:	009b      	lsls	r3, r3, #2
   10776:	4413      	add	r3, r2
   10778:	3308      	adds	r3, #8
   1077a:	681b      	ldr	r3, [r3, #0]
   1077c:	4602      	mov	r2, r0
   1077e:	601a      	str	r2, [r3, #0]
   10780:	4623      	mov	r3, r4
   10782:	4619      	mov	r1, r3
   10784:	4802      	ldr	r0, [pc, #8]	; (10790 <LabGPIO::ClrFallingEdge()+0x48>)
   10786:	f002 fef7 	bl	13578 <__cyg_profile_func_exit>
 }
   1078a:	bf00      	nop
   1078c:	b002      	add	sp, #8
   1078e:	bd10      	pop	{r4, pc}
   10790:	00010749 	.word	0x00010749
   10794:	10000018 	.word	0x10000018

00010798 <LabGPIO::ClrRisingEdge()>:
 void LabGPIO::ClrRisingEdge(){
   10798:	b510      	push	{r4, lr}
   1079a:	b082      	sub	sp, #8
   1079c:	4674      	mov	r4, lr
   1079e:	9001      	str	r0, [sp, #4]
   107a0:	4623      	mov	r3, r4
   107a2:	4619      	mov	r1, r3
   107a4:	480e      	ldr	r0, [pc, #56]	; (107e0 <LabGPIO::ClrRisingEdge()+0x48>)
   107a6:	f002 fed3 	bl	13550 <__cyg_profile_func_enter>
    *interrupts[interrupt_port][2] = (1<<SelPin);
   107aa:	9b01      	ldr	r3, [sp, #4]
   107ac:	785b      	ldrb	r3, [r3, #1]
   107ae:	461a      	mov	r2, r3
   107b0:	2301      	movs	r3, #1
   107b2:	fa03 f002 	lsl.w	r0, r3, r2
   107b6:	9b01      	ldr	r3, [sp, #4]
   107b8:	789b      	ldrb	r3, [r3, #2]
   107ba:	4619      	mov	r1, r3
   107bc:	4a09      	ldr	r2, [pc, #36]	; (107e4 <LabGPIO::ClrRisingEdge()+0x4c>)
   107be:	460b      	mov	r3, r1
   107c0:	009b      	lsls	r3, r3, #2
   107c2:	440b      	add	r3, r1
   107c4:	009b      	lsls	r3, r3, #2
   107c6:	4413      	add	r3, r2
   107c8:	3308      	adds	r3, #8
   107ca:	681b      	ldr	r3, [r3, #0]
   107cc:	4602      	mov	r2, r0
   107ce:	601a      	str	r2, [r3, #0]
   107d0:	4623      	mov	r3, r4
   107d2:	4619      	mov	r1, r3
   107d4:	4802      	ldr	r0, [pc, #8]	; (107e0 <LabGPIO::ClrRisingEdge()+0x48>)
   107d6:	f002 fecf 	bl	13578 <__cyg_profile_func_exit>
 }
   107da:	bf00      	nop
   107dc:	b002      	add	sp, #8
   107de:	bd10      	pop	{r4, pc}
   107e0:	00010799 	.word	0x00010799
   107e4:	10000018 	.word	0x10000018

000107e8 <LabGPIO::ClrEdge(LabGPIO::Edge)>:
 void LabGPIO::ClrEdge(Edge edge)
 {
   107e8:	b510      	push	{r4, lr}
   107ea:	b082      	sub	sp, #8
   107ec:	4674      	mov	r4, lr
   107ee:	9001      	str	r0, [sp, #4]
   107f0:	9100      	str	r1, [sp, #0]
   107f2:	4623      	mov	r3, r4
   107f4:	4619      	mov	r1, r3
   107f6:	4817      	ldr	r0, [pc, #92]	; (10854 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x6c>)
   107f8:	f002 feaa 	bl	13550 <__cyg_profile_func_enter>
     switch(edge)
   107fc:	9b00      	ldr	r3, [sp, #0]
   107fe:	2b03      	cmp	r3, #3
   10800:	d820      	bhi.n	10844 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x5c>
   10802:	a201      	add	r2, pc, #4	; (adr r2, 10808 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x20>)
   10804:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   10808:	00010819 	.word	0x00010819
   1080c:	00010827 	.word	0x00010827
   10810:	0001082f 	.word	0x0001082f
   10814:	00010837 	.word	0x00010837
    {   case Edge::kNone:
                LOG_INFO("No edge selected");
   10818:	23a7      	movs	r3, #167	; 0xa7
   1081a:	4a0f      	ldr	r2, [pc, #60]	; (10858 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x70>)
   1081c:	490f      	ldr	r1, [pc, #60]	; (1085c <LabGPIO::ClrEdge(LabGPIO::Edge)+0x74>)
   1081e:	4810      	ldr	r0, [pc, #64]	; (10860 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x78>)
   10820:	f005 fc34 	bl	1608c <printf>
                break;
   10824:	e00e      	b.n	10844 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x5c>
        case Edge::kRising:
            ClrRisingEdge();
   10826:	9801      	ldr	r0, [sp, #4]
   10828:	f7ff ffb6 	bl	10798 <LabGPIO::ClrRisingEdge()>
            break;
   1082c:	e00a      	b.n	10844 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x5c>
        case Edge::kFalling:
            ClrFallingEdge();
   1082e:	9801      	ldr	r0, [sp, #4]
   10830:	f7ff ff8a 	bl	10748 <LabGPIO::ClrFallingEdge()>
            break;
   10834:	e006      	b.n	10844 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x5c>
        case Edge::kBoth:
            ClrRisingEdge();
   10836:	9801      	ldr	r0, [sp, #4]
   10838:	f7ff ffae 	bl	10798 <LabGPIO::ClrRisingEdge()>
            ClrFallingEdge();
   1083c:	9801      	ldr	r0, [sp, #4]
   1083e:	f7ff ff83 	bl	10748 <LabGPIO::ClrFallingEdge()>
            break;   
   10842:	bf00      	nop
   10844:	4623      	mov	r3, r4
   10846:	4619      	mov	r1, r3
   10848:	4802      	ldr	r0, [pc, #8]	; (10854 <LabGPIO::ClrEdge(LabGPIO::Edge)+0x6c>)
   1084a:	f002 fe95 	bl	13578 <__cyg_profile_func_exit>
    }
 }
   1084e:	bf00      	nop
   10850:	b002      	add	sp, #8
   10852:	bd10      	pop	{r4, pc}
   10854:	000107e9 	.word	0x000107e9
   10858:	00019054 	.word	0x00019054
   1085c:	00019020 	.word	0x00019020
   10860:	00018fd4 	.word	0x00018fd4

00010864 <(anonymous namespace)::DefaultUptime()>:
{
// uptime in nanoseconds
inline uint64_t uptime = 0;
// Returns the system uptime in nanoseconds, do not use this function directly
[[gnu::always_inline]] inline uint64_t DefaultUptime()
{
   10864:	b570      	push	{r4, r5, r6, lr}
   10866:	4676      	mov	r6, lr
   10868:	4633      	mov	r3, r6
   1086a:	4619      	mov	r1, r3
   1086c:	4807      	ldr	r0, [pc, #28]	; (1088c <(anonymous namespace)::DefaultUptime()+0x28>)
   1086e:	f002 fe6f 	bl	13550 <__cyg_profile_func_enter>
  return uptime;
   10872:	4b07      	ldr	r3, [pc, #28]	; (10890 <(anonymous namespace)::DefaultUptime()+0x2c>)
   10874:	e9d3 4500 	ldrd	r4, r5, [r3]
   10878:	4633      	mov	r3, r6
   1087a:	4619      	mov	r1, r3
   1087c:	4803      	ldr	r0, [pc, #12]	; (1088c <(anonymous namespace)::DefaultUptime()+0x28>)
   1087e:	f002 fe7b 	bl	13578 <__cyg_profile_func_exit>
   10882:	4623      	mov	r3, r4
   10884:	462c      	mov	r4, r5
}
   10886:	4618      	mov	r0, r3
   10888:	4621      	mov	r1, r4
   1088a:	bd70      	pop	{r4, r5, r6, pc}
   1088c:	00010865 	.word	0x00010865
   10890:	100003a8 	.word	0x100003a8

00010894 <Milliseconds()>:
{
  Uptime = uptime_function;
}
// Get system uptime in milliseconds as a 64-bit integer
inline uint64_t Milliseconds()
{
   10894:	b570      	push	{r4, r5, r6, lr}
   10896:	4674      	mov	r4, lr
   10898:	4623      	mov	r3, r4
   1089a:	4619      	mov	r1, r3
   1089c:	480c      	ldr	r0, [pc, #48]	; (108d0 <Milliseconds()+0x3c>)
   1089e:	f002 fe57 	bl	13550 <__cyg_profile_func_enter>
  return Uptime() / 1'000;
   108a2:	4b0c      	ldr	r3, [pc, #48]	; (108d4 <Milliseconds()+0x40>)
   108a4:	681b      	ldr	r3, [r3, #0]
   108a6:	4798      	blx	r3
   108a8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   108ac:	f04f 0300 	mov.w	r3, #0
   108b0:	f008 f8bc 	bl	18a2c <__aeabi_uldivmod>
   108b4:	4602      	mov	r2, r0
   108b6:	460b      	mov	r3, r1
   108b8:	4615      	mov	r5, r2
   108ba:	461e      	mov	r6, r3
   108bc:	4623      	mov	r3, r4
   108be:	4619      	mov	r1, r3
   108c0:	4803      	ldr	r0, [pc, #12]	; (108d0 <Milliseconds()+0x3c>)
   108c2:	f002 fe59 	bl	13578 <__cyg_profile_func_exit>
   108c6:	462b      	mov	r3, r5
   108c8:	4634      	mov	r4, r6
}
   108ca:	4618      	mov	r0, r3
   108cc:	4621      	mov	r1, r4
   108ce:	bd70      	pop	{r4, r5, r6, pc}
   108d0:	00010895 	.word	0x00010895
   108d4:	10000040 	.word	0x10000040

000108d8 <Wait(unsigned long long)::{lambda()#1}::operator()() const>:
  return status;
}

inline Status Wait(uint64_t timeout)
{
  return Wait(timeout, []() -> bool { return false; });
   108d8:	b530      	push	{r4, r5, lr}
   108da:	b083      	sub	sp, #12
   108dc:	4675      	mov	r5, lr
   108de:	9001      	str	r0, [sp, #4]
   108e0:	462b      	mov	r3, r5
   108e2:	4619      	mov	r1, r3
   108e4:	4806      	ldr	r0, [pc, #24]	; (10900 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   108e6:	f002 fe33 	bl	13550 <__cyg_profile_func_enter>
   108ea:	2400      	movs	r4, #0
   108ec:	462b      	mov	r3, r5
   108ee:	4619      	mov	r1, r3
   108f0:	4803      	ldr	r0, [pc, #12]	; (10900 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   108f2:	f002 fe41 	bl	13578 <__cyg_profile_func_exit>
   108f6:	4623      	mov	r3, r4
   108f8:	4618      	mov	r0, r3
   108fa:	b003      	add	sp, #12
   108fc:	bd30      	pop	{r4, r5, pc}
   108fe:	bf00      	nop
   10900:	000108d9 	.word	0x000108d9

00010904 <Wait(unsigned long long)::{lambda()#1}::_FUN()>:
   10904:	b538      	push	{r3, r4, r5, lr}
   10906:	4674      	mov	r4, lr
   10908:	4623      	mov	r3, r4
   1090a:	4619      	mov	r1, r3
   1090c:	4807      	ldr	r0, [pc, #28]	; (1092c <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   1090e:	f002 fe1f 	bl	13550 <__cyg_profile_func_enter>
   10912:	2000      	movs	r0, #0
   10914:	f7ff ffe0 	bl	108d8 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10918:	4603      	mov	r3, r0
   1091a:	461d      	mov	r5, r3
   1091c:	4623      	mov	r3, r4
   1091e:	4619      	mov	r1, r3
   10920:	4802      	ldr	r0, [pc, #8]	; (1092c <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   10922:	f002 fe29 	bl	13578 <__cyg_profile_func_exit>
   10926:	462b      	mov	r3, r5
   10928:	4618      	mov	r0, r3
   1092a:	bd38      	pop	{r3, r4, r5, pc}
   1092c:	00010905 	.word	0x00010905

00010930 <Wait(unsigned long long)>:
{
   10930:	b5f0      	push	{r4, r5, r6, r7, lr}
   10932:	b089      	sub	sp, #36	; 0x24
   10934:	4675      	mov	r5, lr
   10936:	e9cd 0100 	strd	r0, r1, [sp]
   1093a:	462b      	mov	r3, r5
   1093c:	4619      	mov	r1, r3
   1093e:	482b      	ldr	r0, [pc, #172]	; (109ec <Wait(unsigned long long)+0xbc>)
   10940:	f002 fe06 	bl	13550 <__cyg_profile_func_enter>
   10944:	e9dd 3400 	ldrd	r3, r4, [sp]
   10948:	e9cd 3406 	strd	r3, r4, [sp, #24]
   1094c:	f88d 6008 	strb.w	r6, [sp, #8]
   10950:	462b      	mov	r3, r5
   10952:	4619      	mov	r1, r3
   10954:	4826      	ldr	r0, [pc, #152]	; (109f0 <Wait(unsigned long long)+0xc0>)
   10956:	f002 fdfb 	bl	13550 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   1095a:	f04f 0300 	mov.w	r3, #0
   1095e:	f04f 0400 	mov.w	r4, #0
   10962:	e9cd 3404 	strd	r3, r4, [sp, #16]
  if (timeout == kMaxWait)
   10966:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   1096a:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   1096e:	bf08      	it	eq
   10970:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   10974:	d106      	bne.n	10984 <Wait(unsigned long long)+0x54>
    timeout_time = kMaxWait;
   10976:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1097a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1097e:	e9cd 3404 	strd	r3, r4, [sp, #16]
   10982:	e00a      	b.n	1099a <Wait(unsigned long long)+0x6a>
    timeout_time = Milliseconds() + timeout;
   10984:	f7ff ff86 	bl	10894 <Milliseconds()>
   10988:	460a      	mov	r2, r1
   1098a:	4601      	mov	r1, r0
   1098c:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   10990:	185e      	adds	r6, r3, r1
   10992:	eb44 0702 	adc.w	r7, r4, r2
   10996:	e9cd 6704 	strd	r6, r7, [sp, #16]
  Status status = Status::kTimedOut;
   1099a:	2301      	movs	r3, #1
   1099c:	9303      	str	r3, [sp, #12]
  while (Milliseconds() < timeout_time)
   1099e:	f7ff ff79 	bl	10894 <Milliseconds()>
   109a2:	460a      	mov	r2, r1
   109a4:	4601      	mov	r1, r0
   109a6:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   109aa:	42a2      	cmp	r2, r4
   109ac:	bf08      	it	eq
   109ae:	4299      	cmpeq	r1, r3
   109b0:	bf34      	ite	cc
   109b2:	2301      	movcc	r3, #1
   109b4:	2300      	movcs	r3, #0
   109b6:	b2db      	uxtb	r3, r3
   109b8:	2b00      	cmp	r3, #0
   109ba:	d008      	beq.n	109ce <Wait(unsigned long long)+0x9e>
    if (is_done())
   109bc:	ab02      	add	r3, sp, #8
   109be:	4618      	mov	r0, r3
   109c0:	f7ff ff8a 	bl	108d8 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   109c4:	4603      	mov	r3, r0
   109c6:	2b00      	cmp	r3, #0
   109c8:	d0e9      	beq.n	1099e <Wait(unsigned long long)+0x6e>
      status = Status::kSuccess;
   109ca:	2300      	movs	r3, #0
   109cc:	9303      	str	r3, [sp, #12]
  return status;
   109ce:	9c03      	ldr	r4, [sp, #12]
   109d0:	462b      	mov	r3, r5
   109d2:	4619      	mov	r1, r3
   109d4:	4806      	ldr	r0, [pc, #24]	; (109f0 <Wait(unsigned long long)+0xc0>)
   109d6:	f002 fdcf 	bl	13578 <__cyg_profile_func_exit>
   109da:	462b      	mov	r3, r5
   109dc:	4619      	mov	r1, r3
   109de:	4803      	ldr	r0, [pc, #12]	; (109ec <Wait(unsigned long long)+0xbc>)
   109e0:	f002 fdca 	bl	13578 <__cyg_profile_func_exit>
  return Wait(timeout, []() -> bool { return false; });
   109e4:	4623      	mov	r3, r4
}
   109e6:	4618      	mov	r0, r3
   109e8:	b009      	add	sp, #36	; 0x24
   109ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   109ec:	00010931 	.word	0x00010931
   109f0:	00010e99 	.word	0x00010e99

000109f4 <Delay(unsigned long long)>:

// Delay the system for a duration of time
inline void Delay([[maybe_unused]] uint64_t delay_time_ms)
{
   109f4:	b510      	push	{r4, lr}
   109f6:	b082      	sub	sp, #8
   109f8:	4674      	mov	r4, lr
   109fa:	e9cd 0100 	strd	r0, r1, [sp]
   109fe:	4623      	mov	r3, r4
   10a00:	4619      	mov	r1, r3
   10a02:	4807      	ldr	r0, [pc, #28]	; (10a20 <Delay(unsigned long long)+0x2c>)
   10a04:	f002 fda4 	bl	13550 <__cyg_profile_func_enter>
#if defined(HOST_TEST)
  return;
#else
  Wait(delay_time_ms);
   10a08:	e9dd 0100 	ldrd	r0, r1, [sp]
   10a0c:	f7ff ff90 	bl	10930 <Wait(unsigned long long)>
   10a10:	4623      	mov	r3, r4
   10a12:	4619      	mov	r1, r3
   10a14:	4802      	ldr	r0, [pc, #8]	; (10a20 <Delay(unsigned long long)+0x2c>)
   10a16:	f002 fdaf 	bl	13578 <__cyg_profile_func_exit>
#endif  // HOST_TEST
}
   10a1a:	bf00      	nop
   10a1c:	b002      	add	sp, #8
   10a1e:	bd10      	pop	{r4, pc}
   10a20:	000109f5 	.word	0x000109f5

00010a24 <Gpio::SetHigh()>:
  inline void SetDirection(Direction direction) override
  {
    (direction) ? SetAsOutput() : SetAsInput();
  }
  // Sets the GPIO output pin to high
  void SetHigh(void) override
   10a24:	b530      	push	{r4, r5, lr}
   10a26:	b083      	sub	sp, #12
   10a28:	4675      	mov	r5, lr
   10a2a:	9001      	str	r0, [sp, #4]
   10a2c:	462b      	mov	r3, r5
   10a2e:	4619      	mov	r1, r3
   10a30:	4813      	ldr	r0, [pc, #76]	; (10a80 <Gpio::SetHigh()+0x5c>)
   10a32:	f002 fd8d 	bl	13550 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->SET = (1 << pin_->GetPin());
   10a36:	9b01      	ldr	r3, [sp, #4]
   10a38:	689a      	ldr	r2, [r3, #8]
   10a3a:	9b01      	ldr	r3, [sp, #4]
   10a3c:	689b      	ldr	r3, [r3, #8]
   10a3e:	681b      	ldr	r3, [r3, #0]
   10a40:	3330      	adds	r3, #48	; 0x30
   10a42:	681b      	ldr	r3, [r3, #0]
   10a44:	4610      	mov	r0, r2
   10a46:	4798      	blx	r3
   10a48:	4603      	mov	r3, r0
   10a4a:	461a      	mov	r2, r3
   10a4c:	2301      	movs	r3, #1
   10a4e:	4093      	lsls	r3, r2
   10a50:	461c      	mov	r4, r3
   10a52:	9b01      	ldr	r3, [sp, #4]
   10a54:	689a      	ldr	r2, [r3, #8]
   10a56:	9b01      	ldr	r3, [sp, #4]
   10a58:	689b      	ldr	r3, [r3, #8]
   10a5a:	681b      	ldr	r3, [r3, #0]
   10a5c:	332c      	adds	r3, #44	; 0x2c
   10a5e:	681b      	ldr	r3, [r3, #0]
   10a60:	4610      	mov	r0, r2
   10a62:	4798      	blx	r3
   10a64:	4603      	mov	r3, r0
   10a66:	461a      	mov	r2, r3
   10a68:	4b06      	ldr	r3, [pc, #24]	; (10a84 <Gpio::SetHigh()+0x60>)
   10a6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10a6e:	619c      	str	r4, [r3, #24]
   10a70:	462b      	mov	r3, r5
   10a72:	4619      	mov	r1, r3
   10a74:	4802      	ldr	r0, [pc, #8]	; (10a80 <Gpio::SetHigh()+0x5c>)
   10a76:	f002 fd7f 	bl	13578 <__cyg_profile_func_exit>
  }
   10a7a:	bf00      	nop
   10a7c:	b003      	add	sp, #12
   10a7e:	bd30      	pop	{r4, r5, pc}
   10a80:	00010a25 	.word	0x00010a25
   10a84:	10000044 	.word	0x10000044

00010a88 <Gpio::SetLow()>:
  // Sets the GPIO output pin to low
  void SetLow(void) override
   10a88:	b530      	push	{r4, r5, lr}
   10a8a:	b083      	sub	sp, #12
   10a8c:	4675      	mov	r5, lr
   10a8e:	9001      	str	r0, [sp, #4]
   10a90:	462b      	mov	r3, r5
   10a92:	4619      	mov	r1, r3
   10a94:	4813      	ldr	r0, [pc, #76]	; (10ae4 <Gpio::SetLow()+0x5c>)
   10a96:	f002 fd5b 	bl	13550 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->CLR = (1 << pin_->GetPin());
   10a9a:	9b01      	ldr	r3, [sp, #4]
   10a9c:	689a      	ldr	r2, [r3, #8]
   10a9e:	9b01      	ldr	r3, [sp, #4]
   10aa0:	689b      	ldr	r3, [r3, #8]
   10aa2:	681b      	ldr	r3, [r3, #0]
   10aa4:	3330      	adds	r3, #48	; 0x30
   10aa6:	681b      	ldr	r3, [r3, #0]
   10aa8:	4610      	mov	r0, r2
   10aaa:	4798      	blx	r3
   10aac:	4603      	mov	r3, r0
   10aae:	461a      	mov	r2, r3
   10ab0:	2301      	movs	r3, #1
   10ab2:	4093      	lsls	r3, r2
   10ab4:	461c      	mov	r4, r3
   10ab6:	9b01      	ldr	r3, [sp, #4]
   10ab8:	689a      	ldr	r2, [r3, #8]
   10aba:	9b01      	ldr	r3, [sp, #4]
   10abc:	689b      	ldr	r3, [r3, #8]
   10abe:	681b      	ldr	r3, [r3, #0]
   10ac0:	332c      	adds	r3, #44	; 0x2c
   10ac2:	681b      	ldr	r3, [r3, #0]
   10ac4:	4610      	mov	r0, r2
   10ac6:	4798      	blx	r3
   10ac8:	4603      	mov	r3, r0
   10aca:	461a      	mov	r2, r3
   10acc:	4b06      	ldr	r3, [pc, #24]	; (10ae8 <Gpio::SetLow()+0x60>)
   10ace:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10ad2:	61dc      	str	r4, [r3, #28]
   10ad4:	462b      	mov	r3, r5
   10ad6:	4619      	mov	r1, r3
   10ad8:	4802      	ldr	r0, [pc, #8]	; (10ae4 <Gpio::SetLow()+0x5c>)
   10ada:	f002 fd4d 	bl	13578 <__cyg_profile_func_exit>
  }
   10ade:	bf00      	nop
   10ae0:	b003      	add	sp, #12
   10ae2:	bd30      	pop	{r4, r5, pc}
   10ae4:	00010a89 	.word	0x00010a89
   10ae8:	10000044 	.word	0x10000044

00010aec <Gpio::Set(GpioInterface::State)>:
  // Sets the GPIO output pin to high or low depending on the State enum
  // parameter
  void Set(State output = kHigh) override
   10aec:	b510      	push	{r4, lr}
   10aee:	b082      	sub	sp, #8
   10af0:	4674      	mov	r4, lr
   10af2:	9001      	str	r0, [sp, #4]
   10af4:	460b      	mov	r3, r1
   10af6:	f88d 3003 	strb.w	r3, [sp, #3]
   10afa:	4623      	mov	r3, r4
   10afc:	4619      	mov	r1, r3
   10afe:	480b      	ldr	r0, [pc, #44]	; (10b2c <Gpio::Set(GpioInterface::State)+0x40>)
   10b00:	f002 fd26 	bl	13550 <__cyg_profile_func_enter>
  {
    (output) ? SetHigh() : SetLow();
   10b04:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10b08:	2b00      	cmp	r3, #0
   10b0a:	d003      	beq.n	10b14 <Gpio::Set(GpioInterface::State)+0x28>
   10b0c:	9801      	ldr	r0, [sp, #4]
   10b0e:	f7ff ff89 	bl	10a24 <Gpio::SetHigh()>
   10b12:	e002      	b.n	10b1a <Gpio::Set(GpioInterface::State)+0x2e>
   10b14:	9801      	ldr	r0, [sp, #4]
   10b16:	f7ff ffb7 	bl	10a88 <Gpio::SetLow()>
   10b1a:	4623      	mov	r3, r4
   10b1c:	4619      	mov	r1, r3
   10b1e:	4803      	ldr	r0, [pc, #12]	; (10b2c <Gpio::Set(GpioInterface::State)+0x40>)
   10b20:	f002 fd2a 	bl	13578 <__cyg_profile_func_exit>
  }
   10b24:	bf00      	nop
   10b26:	b002      	add	sp, #8
   10b28:	bd10      	pop	{r4, pc}
   10b2a:	bf00      	nop
   10b2c:	00010aed 	.word	0x00010aed

00010b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>:
//
// @param enum_type_value variable you would like to get the value of.
// @return the value of the enum class type variable of with the underlying
//         type of the enum class.
template <typename Enum, typename Type = typename std::underlying_type_t<Enum>>
constexpr Type Value(Enum enum_type_value)
   10b30:	b530      	push	{r4, r5, lr}
   10b32:	b083      	sub	sp, #12
   10b34:	4675      	mov	r5, lr
   10b36:	9001      	str	r0, [sp, #4]
   10b38:	462b      	mov	r3, r5
   10b3a:	4619      	mov	r1, r3
   10b3c:	4806      	ldr	r0, [pc, #24]	; (10b58 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   10b3e:	f002 fd07 	bl	13550 <__cyg_profile_func_enter>
{
  return static_cast<Type>(enum_type_value);
   10b42:	9c01      	ldr	r4, [sp, #4]
   10b44:	462b      	mov	r3, r5
   10b46:	4619      	mov	r1, r3
   10b48:	4803      	ldr	r0, [pc, #12]	; (10b58 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   10b4a:	f002 fd15 	bl	13578 <__cyg_profile_func_exit>
   10b4e:	4623      	mov	r3, r4
}
   10b50:	4618      	mov	r0, r3
   10b52:	b003      	add	sp, #12
   10b54:	bd30      	pop	{r4, r5, pc}
   10b56:	bf00      	nop
   10b58:	00010b31 	.word	0x00010b31

00010b5c <Ssp::IsTransferRegBusy()>:
  }

  /// Checks if the SSP controller is idle.
  /// @returns true if the controller is sending or receiving a data frame and
  /// false if it is idle.
  bool IsTransferRegBusy() override
   10b5c:	b530      	push	{r4, r5, lr}
   10b5e:	b085      	sub	sp, #20
   10b60:	4675      	mov	r5, lr
   10b62:	9001      	str	r0, [sp, #4]
   10b64:	462b      	mov	r3, r5
   10b66:	4619      	mov	r1, r3
   10b68:	4817      	ldr	r0, [pc, #92]	; (10bc8 <Ssp::IsTransferRegBusy()+0x6c>)
   10b6a:	f002 fcf1 	bl	13550 <__cyg_profile_func_enter>
  {
    return (bit::Read(ssp_registers[util::Value(pssp_)]->SR, kDataLineIdleBit));
   10b6e:	9b01      	ldr	r3, [sp, #4]
   10b70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10b72:	4618      	mov	r0, r3
   10b74:	f7ff ffdc 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   10b78:	4602      	mov	r2, r0
   10b7a:	4b14      	ldr	r3, [pc, #80]	; (10bcc <Ssp::IsTransferRegBusy()+0x70>)
   10b7c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10b80:	68db      	ldr	r3, [r3, #12]
   10b82:	9303      	str	r3, [sp, #12]
   10b84:	2304      	movs	r3, #4
   10b86:	9302      	str	r3, [sp, #8]
   10b88:	462b      	mov	r3, r5
   10b8a:	4619      	mov	r1, r3
   10b8c:	4810      	ldr	r0, [pc, #64]	; (10bd0 <Ssp::IsTransferRegBusy()+0x74>)
   10b8e:	f002 fcdf 	bl	13550 <__cyg_profile_func_enter>
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
                                                        uint32_t position)
{
  static_assert(std::numeric_limits<T>::is_integer,
                "Read only accepts intergers.");
  return static_cast<bool>(target & (1 << position));
   10b92:	2201      	movs	r2, #1
   10b94:	9b02      	ldr	r3, [sp, #8]
   10b96:	fa02 f303 	lsl.w	r3, r2, r3
   10b9a:	461a      	mov	r2, r3
   10b9c:	9b03      	ldr	r3, [sp, #12]
   10b9e:	4013      	ands	r3, r2
   10ba0:	2b00      	cmp	r3, #0
   10ba2:	bf14      	ite	ne
   10ba4:	2301      	movne	r3, #1
   10ba6:	2300      	moveq	r3, #0
   10ba8:	b2dc      	uxtb	r4, r3
   10baa:	462b      	mov	r3, r5
   10bac:	4619      	mov	r1, r3
   10bae:	4808      	ldr	r0, [pc, #32]	; (10bd0 <Ssp::IsTransferRegBusy()+0x74>)
   10bb0:	f002 fce2 	bl	13578 <__cyg_profile_func_exit>
   10bb4:	462b      	mov	r3, r5
   10bb6:	4619      	mov	r1, r3
   10bb8:	4803      	ldr	r0, [pc, #12]	; (10bc8 <Ssp::IsTransferRegBusy()+0x6c>)
   10bba:	f002 fcdd 	bl	13578 <__cyg_profile_func_exit>
   10bbe:	4623      	mov	r3, r4
  }
   10bc0:	4618      	mov	r0, r3
   10bc2:	b005      	add	sp, #20
   10bc4:	bd30      	pop	{r4, r5, pc}
   10bc6:	bf00      	nop
   10bc8:	00010b5d 	.word	0x00010b5d
   10bcc:	1000005c 	.word	0x1000005c
   10bd0:	00010f45 	.word	0x00010f45

00010bd4 <Ssp::Transfer(unsigned short)>:
  /// data register. This functions for both transmitting and
  /// receiving data. It is recommended this region be protected
  /// by a mutex.
  /// @param data - information to be placed in data register
  /// @return - received data from external device
  uint16_t Transfer(uint16_t data) override
   10bd4:	b530      	push	{r4, r5, lr}
   10bd6:	b085      	sub	sp, #20
   10bd8:	4675      	mov	r5, lr
   10bda:	9001      	str	r0, [sp, #4]
   10bdc:	460b      	mov	r3, r1
   10bde:	f8ad 3002 	strh.w	r3, [sp, #2]
   10be2:	462b      	mov	r3, r5
   10be4:	4619      	mov	r1, r3
   10be6:	4814      	ldr	r0, [pc, #80]	; (10c38 <Ssp::Transfer(unsigned short)+0x64>)
   10be8:	f002 fcb2 	bl	13550 <__cyg_profile_func_enter>
  {
    uint32_t pssp = util::Value(pssp_);
   10bec:	9b01      	ldr	r3, [sp, #4]
   10bee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10bf0:	4618      	mov	r0, r3
   10bf2:	f7ff ff9d 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   10bf6:	4603      	mov	r3, r0
   10bf8:	9303      	str	r3, [sp, #12]

    ssp_registers[pssp]->DR = data;
   10bfa:	4a10      	ldr	r2, [pc, #64]	; (10c3c <Ssp::Transfer(unsigned short)+0x68>)
   10bfc:	9b03      	ldr	r3, [sp, #12]
   10bfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c02:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   10c06:	609a      	str	r2, [r3, #8]
    while (IsTransferRegBusy())
   10c08:	9801      	ldr	r0, [sp, #4]
   10c0a:	f7ff ffa7 	bl	10b5c <Ssp::IsTransferRegBusy()>
   10c0e:	4603      	mov	r3, r0
   10c10:	2b00      	cmp	r3, #0
   10c12:	d001      	beq.n	10c18 <Ssp::Transfer(unsigned short)+0x44>
    {
      continue;
   10c14:	bf00      	nop
    while (IsTransferRegBusy())
   10c16:	e7f7      	b.n	10c08 <Ssp::Transfer(unsigned short)+0x34>
    }
    return static_cast<uint16_t>(ssp_registers[pssp]->DR);
   10c18:	4a08      	ldr	r2, [pc, #32]	; (10c3c <Ssp::Transfer(unsigned short)+0x68>)
   10c1a:	9b03      	ldr	r3, [sp, #12]
   10c1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c20:	689b      	ldr	r3, [r3, #8]
   10c22:	b29c      	uxth	r4, r3
   10c24:	462b      	mov	r3, r5
   10c26:	4619      	mov	r1, r3
   10c28:	4803      	ldr	r0, [pc, #12]	; (10c38 <Ssp::Transfer(unsigned short)+0x64>)
   10c2a:	f002 fca5 	bl	13578 <__cyg_profile_func_exit>
   10c2e:	4623      	mov	r3, r4
  }
   10c30:	4618      	mov	r0, r3
   10c32:	b005      	add	sp, #20
   10c34:	bd30      	pop	{r4, r5, pc}
   10c36:	bf00      	nop
   10c38:	00010bd5 	.word	0x00010bd5
   10c3c:	1000005c 	.word	0x1000005c

00010c40 <main>:
LabGPIO Button3(0,29);
LabGPIO led3(1, 18);
LabGPIO Button2(0,30);
LabGPIO led2(1, 24);
int main() 
{ 
   10c40:	b500      	push	{lr}
   10c42:	b083      	sub	sp, #12
   10c44:	4673      	mov	r3, lr
   10c46:	4619      	mov	r1, r3
   10c48:	4825      	ldr	r0, [pc, #148]	; (10ce0 <main+0xa0>)
   10c4a:	f002 fc81 	bl	13550 <__cyg_profile_func_enter>
  LOG_INFO("Start");
   10c4e:	231a      	movs	r3, #26
   10c50:	4a24      	ldr	r2, [pc, #144]	; (10ce4 <main+0xa4>)
   10c52:	4925      	ldr	r1, [pc, #148]	; (10ce8 <main+0xa8>)
   10c54:	4825      	ldr	r0, [pc, #148]	; (10cec <main+0xac>)
   10c56:	f005 fa19 	bl	1608c <printf>
  /*LabGPIO Int(0,29);
  Int.SetAsInput();
  LPC_GPIOINT -> IO0IntEnR = (1<<29);
  RegisterIsr(GPIO_IRQn, GpioInterruptCallback);
  */
  vSemaphoreCreateBinary(binary_sem);
   10c5a:	2203      	movs	r2, #3
   10c5c:	2100      	movs	r1, #0
   10c5e:	2001      	movs	r0, #1
   10c60:	f003 fc58 	bl	14514 <xQueueGenericCreate>
   10c64:	4602      	mov	r2, r0
   10c66:	4b22      	ldr	r3, [pc, #136]	; (10cf0 <main+0xb0>)
   10c68:	601a      	str	r2, [r3, #0]
   10c6a:	4b21      	ldr	r3, [pc, #132]	; (10cf0 <main+0xb0>)
   10c6c:	681b      	ldr	r3, [r3, #0]
   10c6e:	2b00      	cmp	r3, #0
   10c70:	d006      	beq.n	10c80 <main+0x40>
   10c72:	4b1f      	ldr	r3, [pc, #124]	; (10cf0 <main+0xb0>)
   10c74:	6818      	ldr	r0, [r3, #0]
   10c76:	2300      	movs	r3, #0
   10c78:	2200      	movs	r2, #0
   10c7a:	2100      	movs	r1, #0
   10c7c:	f003 fca0 	bl	145c0 <xQueueGenericSend>
  vSemaphoreCreateBinary(binary_sema)
   10c80:	2203      	movs	r2, #3
   10c82:	2100      	movs	r1, #0
   10c84:	2001      	movs	r0, #1
   10c86:	f003 fc45 	bl	14514 <xQueueGenericCreate>
   10c8a:	4602      	mov	r2, r0
   10c8c:	4b19      	ldr	r3, [pc, #100]	; (10cf4 <main+0xb4>)
   10c8e:	601a      	str	r2, [r3, #0]
   10c90:	4b18      	ldr	r3, [pc, #96]	; (10cf4 <main+0xb4>)
   10c92:	681b      	ldr	r3, [r3, #0]
   10c94:	2b00      	cmp	r3, #0
   10c96:	d006      	beq.n	10ca6 <main+0x66>
   10c98:	4b16      	ldr	r3, [pc, #88]	; (10cf4 <main+0xb4>)
   10c9a:	6818      	ldr	r0, [r3, #0]
   10c9c:	2300      	movs	r3, #0
   10c9e:	2200      	movs	r2, #0
   10ca0:	2100      	movs	r1, #0
   10ca2:	f003 fc8d 	bl	145c0 <xQueueGenericSend>
  //gpio.SetAsInput();
  Button2.AttachInterruptHandler(&isr_toggle,LabGPIO::Edge::kFalling);
   10ca6:	2202      	movs	r2, #2
   10ca8:	4913      	ldr	r1, [pc, #76]	; (10cf8 <main+0xb8>)
   10caa:	4814      	ldr	r0, [pc, #80]	; (10cfc <main+0xbc>)
   10cac:	f7ff fc18 	bl	104e0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>
  Button2.EnableInterrupts();
   10cb0:	f7ff fca2 	bl	105f8 <LabGPIO::EnableInterrupts()>
  Button3.AttachInterruptHandler(&isr_toggle2,LabGPIO::Edge::kRising);
   10cb4:	2201      	movs	r2, #1
   10cb6:	4912      	ldr	r1, [pc, #72]	; (10d00 <main+0xc0>)
   10cb8:	4812      	ldr	r0, [pc, #72]	; (10d04 <main+0xc4>)
   10cba:	f7ff fc11 	bl	104e0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>
  Button3.EnableInterrupts();
   10cbe:	f7ff fc9b 	bl	105f8 <LabGPIO::EnableInterrupts()>
  xTaskCreate(led_task, (const char*)"t",1024, NULL, 1, NULL);
   10cc2:	2300      	movs	r3, #0
   10cc4:	9301      	str	r3, [sp, #4]
   10cc6:	2301      	movs	r3, #1
   10cc8:	9300      	str	r3, [sp, #0]
   10cca:	2300      	movs	r3, #0
   10ccc:	f44f 6280 	mov.w	r2, #1024	; 0x400
   10cd0:	490d      	ldr	r1, [pc, #52]	; (10d08 <main+0xc8>)
   10cd2:	480e      	ldr	r0, [pc, #56]	; (10d0c <main+0xcc>)
   10cd4:	f002 fd51 	bl	1377a <xTaskCreate>
  vTaskStartScheduler();
   10cd8:	f002 fe7e 	bl	139d8 <vTaskStartScheduler>
  while(true)
   10cdc:	e7fe      	b.n	10cdc <main+0x9c>
   10cde:	bf00      	nop
   10ce0:	00010c41 	.word	0x00010c41
   10ce4:	000192fc 	.word	0x000192fc
   10ce8:	0001907c 	.word	0x0001907c
   10cec:	00019088 	.word	0x00019088
   10cf0:	100003b0 	.word	0x100003b0
   10cf4:	100003b4 	.word	0x100003b4
   10cf8:	00010d11 	.word	0x00010d11
   10cfc:	100003c8 	.word	0x100003c8
   10d00:	00010d71 	.word	0x00010d71
   10d04:	100003b8 	.word	0x100003b8
   10d08:	000190c8 	.word	0x000190c8
   10d0c:	00010dd1 	.word	0x00010dd1

00010d10 <isr_toggle()>:
    Delay(500);
  // 4) For the callback, do anything such as printf or blink and LED here to test your ISR
  // 5) MUST! Clear the source of the GPIO interrupt
    LPC_GPIOINT->IO0IntClr = (1<<29);
}
void isr_toggle(){
   10d10:	b510      	push	{r4, lr}
   10d12:	4674      	mov	r4, lr
   10d14:	4623      	mov	r3, r4
   10d16:	4619      	mov	r1, r3
   10d18:	480f      	ldr	r0, [pc, #60]	; (10d58 <isr_toggle()+0x48>)
   10d1a:	f002 fc19 	bl	13550 <__cyg_profile_func_enter>
    LOG_INFO("In the interrupt");
   10d1e:	233e      	movs	r3, #62	; 0x3e
   10d20:	4a0e      	ldr	r2, [pc, #56]	; (10d5c <isr_toggle()+0x4c>)
   10d22:	490f      	ldr	r1, [pc, #60]	; (10d60 <isr_toggle()+0x50>)
   10d24:	480f      	ldr	r0, [pc, #60]	; (10d64 <isr_toggle()+0x54>)
   10d26:	f005 f9b1 	bl	1608c <printf>
    Delay(50);
   10d2a:	f04f 0032 	mov.w	r0, #50	; 0x32
   10d2e:	f04f 0100 	mov.w	r1, #0
   10d32:	f7ff fe5f 	bl	109f4 <Delay(unsigned long long)>
    xSemaphoreGiveFromISR(binary_sem,NULL);
   10d36:	4b0c      	ldr	r3, [pc, #48]	; (10d68 <isr_toggle()+0x58>)
   10d38:	681b      	ldr	r3, [r3, #0]
   10d3a:	2100      	movs	r1, #0
   10d3c:	4618      	mov	r0, r3
   10d3e:	f003 fce7 	bl	14710 <xQueueGiveFromISR>
    Button2.ClrEdge(LabGPIO::Edge::kFalling);
   10d42:	2102      	movs	r1, #2
   10d44:	4809      	ldr	r0, [pc, #36]	; (10d6c <isr_toggle()+0x5c>)
   10d46:	f7ff fd4f 	bl	107e8 <LabGPIO::ClrEdge(LabGPIO::Edge)>
   10d4a:	4623      	mov	r3, r4
   10d4c:	4619      	mov	r1, r3
   10d4e:	4802      	ldr	r0, [pc, #8]	; (10d58 <isr_toggle()+0x48>)
   10d50:	f002 fc12 	bl	13578 <__cyg_profile_func_exit>
    
}
   10d54:	bf00      	nop
   10d56:	bd10      	pop	{r4, pc}
   10d58:	00010d11 	.word	0x00010d11
   10d5c:	00019308 	.word	0x00019308
   10d60:	000192b4 	.word	0x000192b4
   10d64:	000190cc 	.word	0x000190cc
   10d68:	100003b0 	.word	0x100003b0
   10d6c:	100003c8 	.word	0x100003c8

00010d70 <isr_toggle2()>:
void isr_toggle2(){
   10d70:	b510      	push	{r4, lr}
   10d72:	4674      	mov	r4, lr
   10d74:	4623      	mov	r3, r4
   10d76:	4619      	mov	r1, r3
   10d78:	480f      	ldr	r0, [pc, #60]	; (10db8 <isr_toggle2()+0x48>)
   10d7a:	f002 fbe9 	bl	13550 <__cyg_profile_func_enter>
    LOG_INFO("In the second interrupt\n");
   10d7e:	2345      	movs	r3, #69	; 0x45
   10d80:	4a0e      	ldr	r2, [pc, #56]	; (10dbc <isr_toggle2()+0x4c>)
   10d82:	490f      	ldr	r1, [pc, #60]	; (10dc0 <isr_toggle2()+0x50>)
   10d84:	480f      	ldr	r0, [pc, #60]	; (10dc4 <isr_toggle2()+0x54>)
   10d86:	f005 f981 	bl	1608c <printf>
    Delay(50);
   10d8a:	f04f 0032 	mov.w	r0, #50	; 0x32
   10d8e:	f04f 0100 	mov.w	r1, #0
   10d92:	f7ff fe2f 	bl	109f4 <Delay(unsigned long long)>
    xSemaphoreGiveFromISR(binary_sema,NULL);
   10d96:	4b0c      	ldr	r3, [pc, #48]	; (10dc8 <isr_toggle2()+0x58>)
   10d98:	681b      	ldr	r3, [r3, #0]
   10d9a:	2100      	movs	r1, #0
   10d9c:	4618      	mov	r0, r3
   10d9e:	f003 fcb7 	bl	14710 <xQueueGiveFromISR>
    Button3.ClrEdge(LabGPIO::Edge::kRising);
   10da2:	2101      	movs	r1, #1
   10da4:	4809      	ldr	r0, [pc, #36]	; (10dcc <isr_toggle2()+0x5c>)
   10da6:	f7ff fd1f 	bl	107e8 <LabGPIO::ClrEdge(LabGPIO::Edge)>
   10daa:	4623      	mov	r3, r4
   10dac:	4619      	mov	r1, r3
   10dae:	4802      	ldr	r0, [pc, #8]	; (10db8 <isr_toggle2()+0x48>)
   10db0:	f002 fbe2 	bl	13578 <__cyg_profile_func_exit>
}
   10db4:	bf00      	nop
   10db6:	bd10      	pop	{r4, pc}
   10db8:	00010d71 	.word	0x00010d71
   10dbc:	0001931c 	.word	0x0001931c
   10dc0:	000192c0 	.word	0x000192c0
   10dc4:	00019118 	.word	0x00019118
   10dc8:	100003b4 	.word	0x100003b4
   10dcc:	100003b8 	.word	0x100003b8

00010dd0 <led_task(void*)>:
void led_task(void *p){
   10dd0:	b500      	push	{lr}
   10dd2:	b083      	sub	sp, #12
   10dd4:	4673      	mov	r3, lr
   10dd6:	9001      	str	r0, [sp, #4]
   10dd8:	4619      	mov	r1, r3
   10dda:	4821      	ldr	r0, [pc, #132]	; (10e60 <led_task(void*)+0x90>)
   10ddc:	f002 fbb8 	bl	13550 <__cyg_profile_func_enter>
      while(1){
      if(xSemaphoreTake(binary_sem,1000))
   10de0:	4b20      	ldr	r3, [pc, #128]	; (10e64 <led_task(void*)+0x94>)
   10de2:	681b      	ldr	r3, [r3, #0]
   10de4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   10de8:	4618      	mov	r0, r3
   10dea:	f003 fce5 	bl	147b8 <xQueueSemaphoreTake>
   10dee:	4603      	mov	r3, r0
   10df0:	2b00      	cmp	r3, #0
   10df2:	bf14      	ite	ne
   10df4:	2301      	movne	r3, #1
   10df6:	2300      	moveq	r3, #0
   10df8:	b2db      	uxtb	r3, r3
   10dfa:	2b00      	cmp	r3, #0
   10dfc:	d009      	beq.n	10e12 <led_task(void*)+0x42>
        {   
            LOG_INFO("Semaphore Recieved\n");
   10dfe:	234e      	movs	r3, #78	; 0x4e
   10e00:	4a19      	ldr	r2, [pc, #100]	; (10e68 <led_task(void*)+0x98>)
   10e02:	491a      	ldr	r1, [pc, #104]	; (10e6c <led_task(void*)+0x9c>)
   10e04:	481a      	ldr	r0, [pc, #104]	; (10e70 <led_task(void*)+0xa0>)
   10e06:	f005 f941 	bl	1608c <printf>
            led2.toggle();
   10e0a:	481a      	ldr	r0, [pc, #104]	; (10e74 <led_task(void*)+0xa4>)
   10e0c:	f7ff fb44 	bl	10498 <LabGPIO::toggle()>
   10e10:	e005      	b.n	10e1e <led_task(void*)+0x4e>
        }
        else LOG_INFO("Interrupt 1 Not Recieved\n");
   10e12:	2351      	movs	r3, #81	; 0x51
   10e14:	4a14      	ldr	r2, [pc, #80]	; (10e68 <led_task(void*)+0x98>)
   10e16:	4918      	ldr	r1, [pc, #96]	; (10e78 <led_task(void*)+0xa8>)
   10e18:	4818      	ldr	r0, [pc, #96]	; (10e7c <led_task(void*)+0xac>)
   10e1a:	f005 f937 	bl	1608c <printf>
      if(xSemaphoreTake(binary_sema, 1000))
   10e1e:	4b18      	ldr	r3, [pc, #96]	; (10e80 <led_task(void*)+0xb0>)
   10e20:	681b      	ldr	r3, [r3, #0]
   10e22:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   10e26:	4618      	mov	r0, r3
   10e28:	f003 fcc6 	bl	147b8 <xQueueSemaphoreTake>
   10e2c:	4603      	mov	r3, r0
   10e2e:	2b00      	cmp	r3, #0
   10e30:	bf14      	ite	ne
   10e32:	2301      	movne	r3, #1
   10e34:	2300      	moveq	r3, #0
   10e36:	b2db      	uxtb	r3, r3
   10e38:	2b00      	cmp	r3, #0
   10e3a:	d009      	beq.n	10e50 <led_task(void*)+0x80>
      {
          LOG_INFO("Semaphore 2 Recieved\n");
   10e3c:	2354      	movs	r3, #84	; 0x54
   10e3e:	4a0a      	ldr	r2, [pc, #40]	; (10e68 <led_task(void*)+0x98>)
   10e40:	4910      	ldr	r1, [pc, #64]	; (10e84 <led_task(void*)+0xb4>)
   10e42:	4811      	ldr	r0, [pc, #68]	; (10e88 <led_task(void*)+0xb8>)
   10e44:	f005 f922 	bl	1608c <printf>
          led3.toggle();
   10e48:	4810      	ldr	r0, [pc, #64]	; (10e8c <led_task(void*)+0xbc>)
   10e4a:	f7ff fb25 	bl	10498 <LabGPIO::toggle()>
   10e4e:	e7c7      	b.n	10de0 <led_task(void*)+0x10>
      }
        else LOG_INFO("Interrupt 2 Not Recieved\n");
   10e50:	2357      	movs	r3, #87	; 0x57
   10e52:	4a05      	ldr	r2, [pc, #20]	; (10e68 <led_task(void*)+0x98>)
   10e54:	490e      	ldr	r1, [pc, #56]	; (10e90 <led_task(void*)+0xc0>)
   10e56:	480f      	ldr	r0, [pc, #60]	; (10e94 <led_task(void*)+0xc4>)
   10e58:	f005 f918 	bl	1608c <printf>
        }
   10e5c:	e7c0      	b.n	10de0 <led_task(void*)+0x10>
   10e5e:	bf00      	nop
   10e60:	00010dd1 	.word	0x00010dd1
   10e64:	100003b0 	.word	0x100003b0
   10e68:	00019330 	.word	0x00019330
   10e6c:	000192cc 	.word	0x000192cc
   10e70:	0001916c 	.word	0x0001916c
   10e74:	100003d0 	.word	0x100003d0
   10e78:	000192d8 	.word	0x000192d8
   10e7c:	000191bc 	.word	0x000191bc
   10e80:	100003b4 	.word	0x100003b4
   10e84:	000192e4 	.word	0x000192e4
   10e88:	00019210 	.word	0x00019210
   10e8c:	100003c0 	.word	0x100003c0
   10e90:	000192f0 	.word	0x000192f0
   10e94:	00019260 	.word	0x00019260

00010e98 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   10e98:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   10e9c:	b088      	sub	sp, #32
   10e9e:	4675      	mov	r5, lr
   10ea0:	e9cd 0102 	strd	r0, r1, [sp, #8]
   10ea4:	f88d 2004 	strb.w	r2, [sp, #4]
   10ea8:	462b      	mov	r3, r5
   10eaa:	4619      	mov	r1, r3
   10eac:	4824      	ldr	r0, [pc, #144]	; (10f40 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   10eae:	f002 fb4f 	bl	13550 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   10eb2:	f04f 0300 	mov.w	r3, #0
   10eb6:	f04f 0400 	mov.w	r4, #0
   10eba:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   10ebe:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   10ec2:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   10ec6:	bf08      	it	eq
   10ec8:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   10ecc:	d106      	bne.n	10edc <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x44>
    timeout_time = kMaxWait;
   10ece:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   10ed2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   10ed6:	e9cd 3406 	strd	r3, r4, [sp, #24]
   10eda:	e00b      	b.n	10ef4 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x5c>
    timeout_time = Milliseconds() + timeout;
   10edc:	f7ff fcda 	bl	10894 <Milliseconds()>
   10ee0:	460a      	mov	r2, r1
   10ee2:	4601      	mov	r1, r0
   10ee4:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   10ee8:	eb13 0b01 	adds.w	fp, r3, r1
   10eec:	eb44 0c02 	adc.w	ip, r4, r2
   10ef0:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   10ef4:	2301      	movs	r3, #1
   10ef6:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   10ef8:	f7ff fccc 	bl	10894 <Milliseconds()>
   10efc:	460a      	mov	r2, r1
   10efe:	4601      	mov	r1, r0
   10f00:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   10f04:	42a2      	cmp	r2, r4
   10f06:	bf08      	it	eq
   10f08:	4299      	cmpeq	r1, r3
   10f0a:	bf34      	ite	cc
   10f0c:	2301      	movcc	r3, #1
   10f0e:	2300      	movcs	r3, #0
   10f10:	b2db      	uxtb	r3, r3
   10f12:	2b00      	cmp	r3, #0
   10f14:	d008      	beq.n	10f28 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x90>
    if (is_done())
   10f16:	ab01      	add	r3, sp, #4
   10f18:	4618      	mov	r0, r3
   10f1a:	f7ff fcdd 	bl	108d8 <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10f1e:	4603      	mov	r3, r0
   10f20:	2b00      	cmp	r3, #0
   10f22:	d0e9      	beq.n	10ef8 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x60>
      status = Status::kSuccess;
   10f24:	2300      	movs	r3, #0
   10f26:	9305      	str	r3, [sp, #20]
  return status;
   10f28:	9c05      	ldr	r4, [sp, #20]
   10f2a:	462b      	mov	r3, r5
   10f2c:	4619      	mov	r1, r3
   10f2e:	4804      	ldr	r0, [pc, #16]	; (10f40 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   10f30:	f002 fb22 	bl	13578 <__cyg_profile_func_exit>
   10f34:	4623      	mov	r3, r4
}
   10f36:	4618      	mov	r0, r3
   10f38:	b008      	add	sp, #32
   10f3a:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   10f3e:	bf00      	nop
   10f40:	00010e99 	.word	0x00010e99

00010f44 <bool bit::Read<unsigned long>(unsigned long, unsigned long)>:
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
   10f44:	b530      	push	{r4, r5, lr}
   10f46:	b083      	sub	sp, #12
   10f48:	4675      	mov	r5, lr
   10f4a:	9001      	str	r0, [sp, #4]
   10f4c:	9100      	str	r1, [sp, #0]
   10f4e:	462b      	mov	r3, r5
   10f50:	4619      	mov	r1, r3
   10f52:	480c      	ldr	r0, [pc, #48]	; (10f84 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   10f54:	f002 fafc 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   10f58:	2201      	movs	r2, #1
   10f5a:	9b00      	ldr	r3, [sp, #0]
   10f5c:	fa02 f303 	lsl.w	r3, r2, r3
   10f60:	461a      	mov	r2, r3
   10f62:	9b01      	ldr	r3, [sp, #4]
   10f64:	4013      	ands	r3, r2
   10f66:	2b00      	cmp	r3, #0
   10f68:	bf14      	ite	ne
   10f6a:	2301      	movne	r3, #1
   10f6c:	2300      	moveq	r3, #0
   10f6e:	b2dc      	uxtb	r4, r3
   10f70:	462b      	mov	r3, r5
   10f72:	4619      	mov	r1, r3
   10f74:	4803      	ldr	r0, [pc, #12]	; (10f84 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   10f76:	f002 faff 	bl	13578 <__cyg_profile_func_exit>
   10f7a:	4623      	mov	r3, r4
}
   10f7c:	4618      	mov	r0, r3
   10f7e:	b003      	add	sp, #12
   10f80:	bd30      	pop	{r4, r5, pc}
   10f82:	bf00      	nop
   10f84:	00010f45 	.word	0x00010f45

00010f88 <__static_initialization_and_destruction_0(int, int)>:
   10f88:	b510      	push	{r4, lr}
   10f8a:	b082      	sub	sp, #8
   10f8c:	4674      	mov	r4, lr
   10f8e:	9001      	str	r0, [sp, #4]
   10f90:	9100      	str	r1, [sp, #0]
   10f92:	4623      	mov	r3, r4
   10f94:	4619      	mov	r1, r3
   10f96:	4813      	ldr	r0, [pc, #76]	; (10fe4 <__static_initialization_and_destruction_0(int, int)+0x5c>)
   10f98:	f002 fada 	bl	13550 <__cyg_profile_func_enter>
   10f9c:	9b01      	ldr	r3, [sp, #4]
   10f9e:	2b01      	cmp	r3, #1
   10fa0:	d118      	bne.n	10fd4 <__static_initialization_and_destruction_0(int, int)+0x4c>
   10fa2:	9b00      	ldr	r3, [sp, #0]
   10fa4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10fa8:	4293      	cmp	r3, r2
   10faa:	d113      	bne.n	10fd4 <__static_initialization_and_destruction_0(int, int)+0x4c>
LabGPIO Button3(0,29);
   10fac:	221d      	movs	r2, #29
   10fae:	2100      	movs	r1, #0
   10fb0:	480d      	ldr	r0, [pc, #52]	; (10fe8 <__static_initialization_and_destruction_0(int, int)+0x60>)
   10fb2:	f7ff f9d9 	bl	10368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO led3(1, 18);
   10fb6:	2212      	movs	r2, #18
   10fb8:	2101      	movs	r1, #1
   10fba:	480c      	ldr	r0, [pc, #48]	; (10fec <__static_initialization_and_destruction_0(int, int)+0x64>)
   10fbc:	f7ff f9d4 	bl	10368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO Button2(0,30);
   10fc0:	221e      	movs	r2, #30
   10fc2:	2100      	movs	r1, #0
   10fc4:	480a      	ldr	r0, [pc, #40]	; (10ff0 <__static_initialization_and_destruction_0(int, int)+0x68>)
   10fc6:	f7ff f9cf 	bl	10368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO led2(1, 24);
   10fca:	2218      	movs	r2, #24
   10fcc:	2101      	movs	r1, #1
   10fce:	4809      	ldr	r0, [pc, #36]	; (10ff4 <__static_initialization_and_destruction_0(int, int)+0x6c>)
   10fd0:	f7ff f9ca 	bl	10368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>
   10fd4:	4623      	mov	r3, r4
   10fd6:	4619      	mov	r1, r3
   10fd8:	4802      	ldr	r0, [pc, #8]	; (10fe4 <__static_initialization_and_destruction_0(int, int)+0x5c>)
   10fda:	f002 facd 	bl	13578 <__cyg_profile_func_exit>
   10fde:	bf00      	nop
   10fe0:	b002      	add	sp, #8
   10fe2:	bd10      	pop	{r4, pc}
   10fe4:	00010f89 	.word	0x00010f89
   10fe8:	100003b8 	.word	0x100003b8
   10fec:	100003c0 	.word	0x100003c0
   10ff0:	100003c8 	.word	0x100003c8
   10ff4:	100003d0 	.word	0x100003d0

00010ff8 <_GLOBAL__sub_I_binary_sem>:
   10ff8:	b510      	push	{r4, lr}
   10ffa:	4674      	mov	r4, lr
   10ffc:	4623      	mov	r3, r4
   10ffe:	4619      	mov	r1, r3
   11000:	4806      	ldr	r0, [pc, #24]	; (1101c <_GLOBAL__sub_I_binary_sem+0x24>)
   11002:	f002 faa5 	bl	13550 <__cyg_profile_func_enter>
   11006:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1100a:	2001      	movs	r0, #1
   1100c:	f7ff ffbc 	bl	10f88 <__static_initialization_and_destruction_0(int, int)>
   11010:	4623      	mov	r3, r4
   11012:	4619      	mov	r1, r3
   11014:	4801      	ldr	r0, [pc, #4]	; (1101c <_GLOBAL__sub_I_binary_sem+0x24>)
   11016:	f002 faaf 	bl	13578 <__cyg_profile_func_exit>
   1101a:	bd10      	pop	{r4, pc}
   1101c:	00010ff9 	.word	0x00010ff9

00011020 <debug::PrintBacktrace(bool, void*)>:
}

[[gnu::no_instrument_function]]
inline void PrintBacktrace(bool show_make_command = false,
                           void * final_address   = nullptr)
{
   11020:	b500      	push	{lr}
   11022:	b08b      	sub	sp, #44	; 0x2c
   11024:	4603      	mov	r3, r0
   11026:	9100      	str	r1, [sp, #0]
   11028:	f88d 3007 	strb.w	r3, [sp, #7]
  printf("Stack Depth = %zd\n", GetStackDepth());
   1102c:	f002 fac6 	bl	135bc <GetStackDepth()>
   11030:	4603      	mov	r3, r0
   11032:	4619      	mov	r1, r3
   11034:	4831      	ldr	r0, [pc, #196]	; (110fc <debug::PrintBacktrace(bool, void*)+0xdc>)
   11036:	f005 f829 	bl	1608c <printf>
  // stack_depth-1 to ignore PrintBacktrace()
  // PrintBacktrace shouldn't be ignored in profiling because it causes
  // the exit to still fire, which can result in a negative stack_depth
  void ** list_of_called_functions = GetStackTrace();
   1103a:	f002 faab 	bl	13594 <GetStackTrace()>
   1103e:	9007      	str	r0, [sp, #28]
  size_t stack_depth               = GetStackDepth();
   11040:	f002 fabc 	bl	135bc <GetStackDepth()>
   11044:	9006      	str	r0, [sp, #24]
  // Ignore the last function as it is the Backtrace function
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   11046:	2300      	movs	r3, #0
   11048:	9309      	str	r3, [sp, #36]	; 0x24
   1104a:	9b06      	ldr	r3, [sp, #24]
   1104c:	3b01      	subs	r3, #1
   1104e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   11050:	429a      	cmp	r2, r3
   11052:	d20d      	bcs.n	11070 <debug::PrintBacktrace(bool, void*)+0x50>
  {
    printf("  #%zu: 0x%p\n", pos, list_of_called_functions[pos]);
   11054:	9b09      	ldr	r3, [sp, #36]	; 0x24
   11056:	009b      	lsls	r3, r3, #2
   11058:	9a07      	ldr	r2, [sp, #28]
   1105a:	4413      	add	r3, r2
   1105c:	681b      	ldr	r3, [r3, #0]
   1105e:	461a      	mov	r2, r3
   11060:	9909      	ldr	r1, [sp, #36]	; 0x24
   11062:	4827      	ldr	r0, [pc, #156]	; (11100 <debug::PrintBacktrace(bool, void*)+0xe0>)
   11064:	f005 f812 	bl	1608c <printf>
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   11068:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1106a:	3301      	adds	r3, #1
   1106c:	9309      	str	r3, [sp, #36]	; 0x24
   1106e:	e7ec      	b.n	1104a <debug::PrintBacktrace(bool, void*)+0x2a>
  }
  if (final_address != nullptr)
   11070:	9b00      	ldr	r3, [sp, #0]
   11072:	2b00      	cmp	r3, #0
   11074:	d006      	beq.n	11084 <debug::PrintBacktrace(bool, void*)+0x64>
  {
    printf("  #%zu: 0x%p\n", stack_depth - 1, final_address);
   11076:	9b06      	ldr	r3, [sp, #24]
   11078:	3b01      	subs	r3, #1
   1107a:	9a00      	ldr	r2, [sp, #0]
   1107c:	4619      	mov	r1, r3
   1107e:	4820      	ldr	r0, [pc, #128]	; (11100 <debug::PrintBacktrace(bool, void*)+0xe0>)
   11080:	f005 f804 	bl	1608c <printf>
  }
  if (show_make_command)
   11084:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11088:	2b00      	cmp	r3, #0
   1108a:	d033      	beq.n	110f4 <debug::PrintBacktrace(bool, void*)+0xd4>
  {
    constexpr const char kBuildType[] =
   1108c:	4a1d      	ldr	r2, [pc, #116]	; (11104 <debug::PrintBacktrace(bool, void*)+0xe4>)
   1108e:	ab03      	add	r3, sp, #12
   11090:	ca07      	ldmia	r2, {r0, r1, r2}
   11092:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#if defined(APPLICATION)
        "application";
#else
        "bootloader";
#endif
    puts("\nRun: the following command in your project directory");
   11096:	481c      	ldr	r0, [pc, #112]	; (11108 <debug::PrintBacktrace(bool, void*)+0xe8>)
   11098:	f002 fa2a 	bl	134f0 <puts>
    printf("\n  " SJ2_BOLD_WHITE "make stacktrace-%s TRACES=\"", kBuildType);
   1109c:	ab03      	add	r3, sp, #12
   1109e:	4619      	mov	r1, r3
   110a0:	481a      	ldr	r0, [pc, #104]	; (1110c <debug::PrintBacktrace(bool, void*)+0xec>)
   110a2:	f004 fff3 	bl	1608c <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   110a6:	2300      	movs	r3, #0
   110a8:	9308      	str	r3, [sp, #32]
   110aa:	9b06      	ldr	r3, [sp, #24]
   110ac:	3b01      	subs	r3, #1
   110ae:	9a08      	ldr	r2, [sp, #32]
   110b0:	429a      	cmp	r2, r3
   110b2:	d212      	bcs.n	110da <debug::PrintBacktrace(bool, void*)+0xba>
    {
      if (pos != 0)
   110b4:	9b08      	ldr	r3, [sp, #32]
   110b6:	2b00      	cmp	r3, #0
   110b8:	d002      	beq.n	110c0 <debug::PrintBacktrace(bool, void*)+0xa0>
      {
        putchar(' ');
   110ba:	2020      	movs	r0, #32
   110bc:	f002 f9fc 	bl	134b8 <putchar>
      }
      printf("0x%p", list_of_called_functions[pos]);
   110c0:	9b08      	ldr	r3, [sp, #32]
   110c2:	009b      	lsls	r3, r3, #2
   110c4:	9a07      	ldr	r2, [sp, #28]
   110c6:	4413      	add	r3, r2
   110c8:	681b      	ldr	r3, [r3, #0]
   110ca:	4619      	mov	r1, r3
   110cc:	4810      	ldr	r0, [pc, #64]	; (11110 <debug::PrintBacktrace(bool, void*)+0xf0>)
   110ce:	f004 ffdd 	bl	1608c <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   110d2:	9b08      	ldr	r3, [sp, #32]
   110d4:	3301      	adds	r3, #1
   110d6:	9308      	str	r3, [sp, #32]
   110d8:	e7e7      	b.n	110aa <debug::PrintBacktrace(bool, void*)+0x8a>
    }
    if (final_address != nullptr)
   110da:	9b00      	ldr	r3, [sp, #0]
   110dc:	2b00      	cmp	r3, #0
   110de:	d003      	beq.n	110e8 <debug::PrintBacktrace(bool, void*)+0xc8>
    {
      printf(" 0x%p", final_address);
   110e0:	9900      	ldr	r1, [sp, #0]
   110e2:	480c      	ldr	r0, [pc, #48]	; (11114 <debug::PrintBacktrace(bool, void*)+0xf4>)
   110e4:	f004 ffd2 	bl	1608c <printf>
    }
    puts("\"\n" SJ2_COLOR_RESET);
   110e8:	480b      	ldr	r0, [pc, #44]	; (11118 <debug::PrintBacktrace(bool, void*)+0xf8>)
   110ea:	f002 fa01 	bl	134f0 <puts>
    puts(
   110ee:	480b      	ldr	r0, [pc, #44]	; (1111c <debug::PrintBacktrace(bool, void*)+0xfc>)
   110f0:	f002 f9fe 	bl	134f0 <puts>
        "This will report the file and line number that led to this function "
        "being called.");
  }
}
   110f4:	bf00      	nop
   110f6:	b00b      	add	sp, #44	; 0x2c
   110f8:	f85d fb04 	ldr.w	pc, [sp], #4
   110fc:	00019348 	.word	0x00019348
   11100:	0001935c 	.word	0x0001935c
   11104:	00019438 	.word	0x00019438
   11108:	0001936c 	.word	0x0001936c
   1110c:	000193a4 	.word	0x000193a4
   11110:	000193cc 	.word	0x000193cc
   11114:	000193d4 	.word	0x000193d4
   11118:	000193dc 	.word	0x000193dc
   1111c:	000193e4 	.word	0x000193e4

00011120 <SetUptimeFunction(unsigned long long (*)())>:
{
   11120:	b510      	push	{r4, lr}
   11122:	b082      	sub	sp, #8
   11124:	4674      	mov	r4, lr
   11126:	9001      	str	r0, [sp, #4]
   11128:	4623      	mov	r3, r4
   1112a:	4619      	mov	r1, r3
   1112c:	4806      	ldr	r0, [pc, #24]	; (11148 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   1112e:	f002 fa0f 	bl	13550 <__cyg_profile_func_enter>
  Uptime = uptime_function;
   11132:	4a06      	ldr	r2, [pc, #24]	; (1114c <SetUptimeFunction(unsigned long long (*)())+0x2c>)
   11134:	9b01      	ldr	r3, [sp, #4]
   11136:	6013      	str	r3, [r2, #0]
   11138:	4623      	mov	r3, r4
   1113a:	4619      	mov	r1, r3
   1113c:	4802      	ldr	r0, [pc, #8]	; (11148 <SetUptimeFunction(unsigned long long (*)())+0x28>)
   1113e:	f002 fa1b 	bl	13578 <__cyg_profile_func_exit>
}
   11142:	bf00      	nop
   11144:	b002      	add	sp, #8
   11146:	bd10      	pop	{r4, pc}
   11148:	00011121 	.word	0x00011121
   1114c:	10000040 	.word	0x10000040

00011150 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>:

  inline static LPC_SC_TypeDef * system_controller = LPC_SC;

  constexpr Lpc40xxSystemController() {}

  uint32_t SetClockFrequency(uint8_t frequency_in_mhz) override
   11150:	b500      	push	{lr}
   11152:	b085      	sub	sp, #20
   11154:	9001      	str	r0, [sp, #4]
   11156:	460b      	mov	r3, r1
   11158:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    uint32_t offset = 0;
   1115c:	2300      	movs	r3, #0
   1115e:	9303      	str	r3, [sp, #12]
    SelectOscillatorSource(OscillatorSource::kIrc);
   11160:	2100      	movs	r1, #0
   11162:	9801      	ldr	r0, [sp, #4]
   11164:	f000 f8ce 	bl	11304 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    if (frequency_in_mhz > 12)
   11168:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1116c:	2b0c      	cmp	r3, #12
   1116e:	d916      	bls.n	1119e <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x4e>
    {
      offset = SetMainPll(PllInput::kIrc, frequency_in_mhz);
   11170:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11174:	b29b      	uxth	r3, r3
   11176:	461a      	mov	r2, r3
   11178:	210c      	movs	r1, #12
   1117a:	9801      	ldr	r0, [sp, #4]
   1117c:	f000 f9ac 	bl	114d8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>
   11180:	9003      	str	r0, [sp, #12]
      SelectMainClockSource(MainClockSource::kPllClock);
   11182:	f44f 7180 	mov.w	r1, #256	; 0x100
   11186:	9801      	ldr	r0, [sp, #4]
   11188:	f000 f8d6 	bl	11338 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = frequency_in_mhz * 1'000'000;
   1118c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11190:	4a10      	ldr	r2, [pc, #64]	; (111d4 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x84>)
   11192:	fb02 f303 	mul.w	r3, r2, r3
   11196:	461a      	mov	r2, r3
   11198:	4b0f      	ldr	r3, [pc, #60]	; (111d8 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   1119a:	601a      	str	r2, [r3, #0]
   1119c:	e006      	b.n	111ac <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x5c>
    }
    else
    {
      SelectMainClockSource(MainClockSource::kBaseClock);
   1119e:	2100      	movs	r1, #0
   111a0:	9801      	ldr	r0, [sp, #4]
   111a2:	f000 f8c9 	bl	11338 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = kDefaultIRCFrequency;
   111a6:	4b0c      	ldr	r3, [pc, #48]	; (111d8 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   111a8:	4a0c      	ldr	r2, [pc, #48]	; (111dc <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x8c>)
   111aa:	601a      	str	r2, [r3, #0]
    }
    SetCpuClockDivider(kDivideInputBy1);
   111ac:	2101      	movs	r1, #1
   111ae:	9801      	ldr	r0, [sp, #4]
   111b0:	f000 fa4a 	bl	11648 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>
    SetPeripheralClockDivider(kDivideInputBy1);
   111b4:	9b01      	ldr	r3, [sp, #4]
   111b6:	681b      	ldr	r3, [r3, #0]
   111b8:	3304      	adds	r3, #4
   111ba:	681b      	ldr	r3, [r3, #0]
   111bc:	2101      	movs	r1, #1
   111be:	9801      	ldr	r0, [sp, #4]
   111c0:	4798      	blx	r3
    SetEmcClockDivider(EmcDivider::kSameSpeedAsCpu);
   111c2:	2100      	movs	r1, #0
   111c4:	9801      	ldr	r0, [sp, #4]
   111c6:	f000 fa73 	bl	116b0 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>
    return offset;
   111ca:	9b03      	ldr	r3, [sp, #12]
  }
   111cc:	4618      	mov	r0, r3
   111ce:	b005      	add	sp, #20
   111d0:	f85d fb04 	ldr.w	pc, [sp], #4
   111d4:	000f4240 	.word	0x000f4240
   111d8:	1000006c 	.word	0x1000006c
   111dc:	00b71b00 	.word	0x00b71b00

000111e0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>:

  void SetPeripheralClockDivider(uint8_t peripheral_divider) override
   111e0:	b500      	push	{lr}
   111e2:	b083      	sub	sp, #12
   111e4:	9001      	str	r0, [sp, #4]
   111e6:	460b      	mov	r3, r1
   111e8:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(peripheral_divider <= 4, "Divider mustn't exceed 32");
   111ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
   111f0:	2b04      	cmp	r3, #4
   111f2:	d90d      	bls.n	11210 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x30>
   111f4:	23ae      	movs	r3, #174	; 0xae
   111f6:	4a0b      	ldr	r2, [pc, #44]	; (11224 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x44>)
   111f8:	490b      	ldr	r1, [pc, #44]	; (11228 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x48>)
   111fa:	480c      	ldr	r0, [pc, #48]	; (1122c <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x4c>)
   111fc:	f004 ff46 	bl	1608c <printf>
   11200:	480b      	ldr	r0, [pc, #44]	; (11230 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x50>)
   11202:	f002 f975 	bl	134f0 <puts>
   11206:	2100      	movs	r1, #0
   11208:	2001      	movs	r0, #1
   1120a:	f7ff ff09 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   1120e:	e7fe      	b.n	1120e <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x2e>
    system_controller->PCLKSEL = peripheral_divider;
   11210:	4b08      	ldr	r3, [pc, #32]	; (11234 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x54>)
   11212:	681b      	ldr	r3, [r3, #0]
   11214:	f89d 2003 	ldrb.w	r2, [sp, #3]
   11218:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  }
   1121c:	bf00      	nop
   1121e:	b003      	add	sp, #12
   11220:	f85d fb04 	ldr.w	pc, [sp], #4
   11224:	00019ad0 	.word	0x00019ad0
   11228:	000198f8 	.word	0x000198f8
   1122c:	00019444 	.word	0x00019444
   11230:	000194e4 	.word	0x000194e4
   11234:	10000068 	.word	0x10000068

00011238 <Lpc40xxSystemController::GetPeripheralClockDivider() const>:

  uint32_t GetPeripheralClockDivider() const override
   11238:	b082      	sub	sp, #8
   1123a:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return 1;
#else
    return system_controller->PCLKSEL;
   1123c:	4b03      	ldr	r3, [pc, #12]	; (1124c <Lpc40xxSystemController::GetPeripheralClockDivider() const+0x14>)
   1123e:	681b      	ldr	r3, [r3, #0]
   11240:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
#endif
  }
   11244:	4618      	mov	r0, r3
   11246:	b002      	add	sp, #8
   11248:	4770      	bx	lr
   1124a:	bf00      	nop
   1124c:	10000068 	.word	0x10000068

00011250 <Lpc40xxSystemController::GetSystemFrequency() const>:

  uint32_t GetSystemFrequency() const override
   11250:	b082      	sub	sp, #8
   11252:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return config::kSystemClockRate;
#else
    return speed_in_hertz;
   11254:	4b02      	ldr	r3, [pc, #8]	; (11260 <Lpc40xxSystemController::GetSystemFrequency() const+0x10>)
   11256:	681b      	ldr	r3, [r3, #0]
#endif
  }
   11258:	4618      	mov	r0, r3
   1125a:	b002      	add	sp, #8
   1125c:	4770      	bx	lr
   1125e:	bf00      	nop
   11260:	1000006c 	.word	0x1000006c

00011264 <Lpc40xxSystemController::GetPeripheralFrequency() const>:

  uint32_t GetPeripheralFrequency() const override
   11264:	b500      	push	{lr}
   11266:	b085      	sub	sp, #20
   11268:	9001      	str	r0, [sp, #4]
  {
    uint32_t peripheral_clock_divider = GetPeripheralClockDivider();
   1126a:	9b01      	ldr	r3, [sp, #4]
   1126c:	681b      	ldr	r3, [r3, #0]
   1126e:	3308      	adds	r3, #8
   11270:	681b      	ldr	r3, [r3, #0]
   11272:	9801      	ldr	r0, [sp, #4]
   11274:	4798      	blx	r3
   11276:	9002      	str	r0, [sp, #8]
    uint32_t result = 0;  // return 0 if peripheral_clock_divider == 0
   11278:	2300      	movs	r3, #0
   1127a:	9303      	str	r3, [sp, #12]
    if (peripheral_clock_divider != 0)
   1127c:	9b02      	ldr	r3, [sp, #8]
   1127e:	2b00      	cmp	r3, #0
   11280:	d00a      	beq.n	11298 <Lpc40xxSystemController::GetPeripheralFrequency() const+0x34>
    {
      result = GetSystemFrequency() / peripheral_clock_divider;
   11282:	9b01      	ldr	r3, [sp, #4]
   11284:	681b      	ldr	r3, [r3, #0]
   11286:	330c      	adds	r3, #12
   11288:	681b      	ldr	r3, [r3, #0]
   1128a:	9801      	ldr	r0, [sp, #4]
   1128c:	4798      	blx	r3
   1128e:	4602      	mov	r2, r0
   11290:	9b02      	ldr	r3, [sp, #8]
   11292:	fbb2 f3f3 	udiv	r3, r2, r3
   11296:	9303      	str	r3, [sp, #12]
    }
    return result;
   11298:	9b03      	ldr	r3, [sp, #12]
  }
   1129a:	4618      	mov	r0, r3
   1129c:	b005      	add	sp, #20
   1129e:	f85d fb04 	ldr.w	pc, [sp], #4
   112a2:	Address 0x00000000000112a2 is out of bounds.


000112a4 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>:

  void PowerUpPeripheral(const PeripheralID & peripheral_select) override
   112a4:	b084      	sub	sp, #16
   112a6:	9001      	str	r0, [sp, #4]
   112a8:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_with_enabled_peripheral =
        system_controller->PCONP | (1 << peripheral_select.device_id);
   112aa:	4b09      	ldr	r3, [pc, #36]	; (112d0 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   112ac:	681b      	ldr	r3, [r3, #0]
   112ae:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   112b2:	9a00      	ldr	r2, [sp, #0]
   112b4:	6812      	ldr	r2, [r2, #0]
   112b6:	2101      	movs	r1, #1
   112b8:	fa01 f202 	lsl.w	r2, r1, r2
   112bc:	4313      	orrs	r3, r2
   112be:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_with_enabled_peripheral;
   112c0:	4b03      	ldr	r3, [pc, #12]	; (112d0 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   112c2:	681b      	ldr	r3, [r3, #0]
   112c4:	9a03      	ldr	r2, [sp, #12]
   112c6:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   112ca:	bf00      	nop
   112cc:	b004      	add	sp, #16
   112ce:	4770      	bx	lr
   112d0:	10000068 	.word	0x10000068

000112d4 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)>:
  void PowerDownPeripheral(const PeripheralID & peripheral_select) override
   112d4:	b084      	sub	sp, #16
   112d6:	9001      	str	r0, [sp, #4]
   112d8:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_without_enabled_peripheral =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   112da:	4b09      	ldr	r3, [pc, #36]	; (11300 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   112dc:	681b      	ldr	r3, [r3, #0]
   112de:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   112e2:	9a00      	ldr	r2, [sp, #0]
   112e4:	6812      	ldr	r2, [r2, #0]
   112e6:	2101      	movs	r1, #1
   112e8:	fa01 f202 	lsl.w	r2, r1, r2
   112ec:	4013      	ands	r3, r2
   112ee:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_without_enabled_peripheral;
   112f0:	4b03      	ldr	r3, [pc, #12]	; (11300 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   112f2:	681b      	ldr	r3, [r3, #0]
   112f4:	9a03      	ldr	r2, [sp, #12]
   112f6:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   112fa:	bf00      	nop
   112fc:	b004      	add	sp, #16
   112fe:	4770      	bx	lr
   11300:	10000068 	.word	0x10000068

00011304 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>:

 private:
  void SelectOscillatorSource(OscillatorSource source)
   11304:	b084      	sub	sp, #16
   11306:	9001      	str	r0, [sp, #4]
   11308:	460b      	mov	r3, r1
   1130a:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    uint32_t source_bit = static_cast<uint32_t>(source);
   1130e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   11312:	9303      	str	r3, [sp, #12]
    system_controller->CLKSRCSEL =
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   11314:	4b07      	ldr	r3, [pc, #28]	; (11334 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   11316:	681b      	ldr	r3, [r3, #0]
   11318:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   1131c:	f023 0101 	bic.w	r1, r3, #1
    system_controller->CLKSRCSEL =
   11320:	4b04      	ldr	r3, [pc, #16]	; (11334 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   11322:	681b      	ldr	r3, [r3, #0]
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   11324:	9a03      	ldr	r2, [sp, #12]
   11326:	430a      	orrs	r2, r1
    system_controller->CLKSRCSEL =
   11328:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  }
   1132c:	bf00      	nop
   1132e:	b004      	add	sp, #16
   11330:	4770      	bx	lr
   11332:	bf00      	nop
   11334:	10000068 	.word	0x10000068

00011338 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>:

  void SelectMainClockSource(MainClockSource source)
   11338:	b082      	sub	sp, #8
   1133a:	9001      	str	r0, [sp, #4]
   1133c:	460b      	mov	r3, r1
   1133e:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   11342:	4b08      	ldr	r3, [pc, #32]	; (11364 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   11344:	681b      	ldr	r3, [r3, #0]
   11346:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   1134a:	f423 7180 	bic.w	r1, r3, #256	; 0x100
        static_cast<uint32_t>(source);
   1134e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->CCLKSEL =
   11352:	4b04      	ldr	r3, [pc, #16]	; (11364 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   11354:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   11356:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11358:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   1135c:	bf00      	nop
   1135e:	b002      	add	sp, #8
   11360:	4770      	bx	lr
   11362:	bf00      	nop
   11364:	10000068 	.word	0x10000068

00011368 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>:

  void SelectUsbClockSource(UsbSource usb_clock)
   11368:	b082      	sub	sp, #8
   1136a:	9001      	str	r0, [sp, #4]
   1136c:	460b      	mov	r3, r1
   1136e:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->USBCLKSEL =
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11372:	4b08      	ldr	r3, [pc, #32]	; (11394 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11374:	681b      	ldr	r3, [r3, #0]
   11376:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   1137a:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(usb_clock);
   1137e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->USBCLKSEL =
   11382:	4b04      	ldr	r3, [pc, #16]	; (11394 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11384:	681b      	ldr	r3, [r3, #0]
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11386:	430a      	orrs	r2, r1
    system_controller->USBCLKSEL =
   11388:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
   1138c:	bf00      	nop
   1138e:	b002      	add	sp, #8
   11390:	4770      	bx	lr
   11392:	bf00      	nop
   11394:	10000068 	.word	0x10000068

00011398 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>:

  void SelectSpifiClockSource(SpifiSource spifi_clock)
   11398:	b082      	sub	sp, #8
   1139a:	9001      	str	r0, [sp, #4]
   1139c:	460b      	mov	r3, r1
   1139e:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->SPIFISEL =
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   113a2:	4b08      	ldr	r3, [pc, #32]	; (113c4 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   113a4:	681b      	ldr	r3, [r3, #0]
   113a6:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
   113aa:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(spifi_clock);
   113ae:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->SPIFISEL =
   113b2:	4b04      	ldr	r3, [pc, #16]	; (113c4 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   113b4:	681b      	ldr	r3, [r3, #0]
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   113b6:	430a      	orrs	r2, r1
    system_controller->SPIFISEL =
   113b8:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  }
   113bc:	bf00      	nop
   113be:	b002      	add	sp, #8
   113c0:	4770      	bx	lr
   113c2:	bf00      	nop
   113c4:	10000068 	.word	0x10000068

000113c8 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t CalculatePll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   113c8:	b500      	push	{lr}
   113ca:	b087      	sub	sp, #28
   113cc:	9001      	str	r0, [sp, #4]
   113ce:	460b      	mov	r3, r1
   113d0:	f8ad 3002 	strh.w	r3, [sp, #2]
   113d4:	4613      	mov	r3, r2
   113d6:	f8ad 3000 	strh.w	r3, [sp]
  {
    SJ2_ASSERT_FATAL(desired_speed_in_mhz < 384 && desired_speed_in_mhz > 12,
   113da:	f8bd 3000 	ldrh.w	r3, [sp]
   113de:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
   113e2:	d203      	bcs.n	113ec <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x24>
   113e4:	f8bd 3000 	ldrh.w	r3, [sp]
   113e8:	2b0c      	cmp	r3, #12
   113ea:	d80d      	bhi.n	11408 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x40>
   113ec:	23ff      	movs	r3, #255	; 0xff
   113ee:	4a34      	ldr	r2, [pc, #208]	; (114c0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   113f0:	4934      	ldr	r1, [pc, #208]	; (114c4 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xfc>)
   113f2:	4835      	ldr	r0, [pc, #212]	; (114c8 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x100>)
   113f4:	f004 fe4a 	bl	1608c <printf>
   113f8:	4834      	ldr	r0, [pc, #208]	; (114cc <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   113fa:	f002 f879 	bl	134f0 <puts>
   113fe:	2100      	movs	r1, #0
   11400:	2001      	movs	r0, #1
   11402:	f7ff fe0d 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   11406:	e7fe      	b.n	11406 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x3e>
                     "Frequency must be lower than 384 MHz"
                     "and greater than or equal to 12 MHz");
    bool calculating = true;
   11408:	2301      	movs	r3, #1
   1140a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32_t multiplier_value;
    if ((desired_speed_in_mhz % static_cast<uint16_t>(input_frequency)) >= 1)
   1140e:	f8bd 3000 	ldrh.w	r3, [sp]
   11412:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11416:	fbb3 f1f2 	udiv	r1, r3, r2
   1141a:	fb02 f201 	mul.w	r2, r2, r1
   1141e:	1a9b      	subs	r3, r3, r2
   11420:	b29b      	uxth	r3, r3
   11422:	2b00      	cmp	r3, #0
   11424:	d009      	beq.n	1143a <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x72>
    {
      multiplier_value = static_cast<uint32_t>(
          (desired_speed_in_mhz / static_cast<uint16_t>(input_frequency)) + 1);
   11426:	f8bd 2000 	ldrh.w	r2, [sp]
   1142a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   1142e:	fbb2 f3f3 	udiv	r3, r2, r3
   11432:	b29b      	uxth	r3, r3
   11434:	3301      	adds	r3, #1
      multiplier_value = static_cast<uint32_t>(
   11436:	9304      	str	r3, [sp, #16]
   11438:	e007      	b.n	1144a <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x82>
    }
    else
    {
      multiplier_value = static_cast<uint32_t>(
          desired_speed_in_mhz / static_cast<uint16_t>(input_frequency));
   1143a:	f8bd 2000 	ldrh.w	r2, [sp]
   1143e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   11442:	fbb2 f3f3 	udiv	r3, r2, r3
   11446:	b29b      	uxth	r3, r3
      multiplier_value = static_cast<uint32_t>(
   11448:	9304      	str	r3, [sp, #16]
    }
    uint16_t divider_value = 1;
   1144a:	2301      	movs	r3, #1
   1144c:	f8ad 300e 	strh.w	r3, [sp, #14]
    while (calculating)
   11450:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11454:	2b00      	cmp	r3, #0
   11456:	d02e      	beq.n	114b6 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xee>
    {
      uint16_t current_controlled_oscillator_frequency;
      current_controlled_oscillator_frequency = static_cast<uint16_t>(
   11458:	9b04      	ldr	r3, [sp, #16]
   1145a:	b29b      	uxth	r3, r3
   1145c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11460:	fb12 f303 	smulbb	r3, r2, r3
   11464:	b29b      	uxth	r3, r3
   11466:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   1146a:	fb12 f303 	smulbb	r3, r2, r3
   1146e:	b29b      	uxth	r3, r3
   11470:	005b      	lsls	r3, r3, #1
   11472:	f8ad 300c 	strh.w	r3, [sp, #12]
          (static_cast<uint16_t>(input_frequency) * multiplier_value * 2) *
          divider_value);
      if (current_controlled_oscillator_frequency >= 156)
   11476:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1147a:	2b9b      	cmp	r3, #155	; 0x9b
   1147c:	d903      	bls.n	11486 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xbe>
      {
        calculating = false;
   1147e:	2300      	movs	r3, #0
   11480:	f88d 3017 	strb.w	r3, [sp, #23]
   11484:	e7e4      	b.n	11450 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
      }
      else
      {
        divider_value = static_cast<uint16_t>(divider_value * 2);
   11486:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1148a:	005b      	lsls	r3, r3, #1
   1148c:	f8ad 300e 	strh.w	r3, [sp, #14]
        SJ2_ASSERT_FATAL(divider_value < 8,
   11490:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   11494:	2b07      	cmp	r3, #7
   11496:	d9db      	bls.n	11450 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
   11498:	f240 131b 	movw	r3, #283	; 0x11b
   1149c:	4a08      	ldr	r2, [pc, #32]	; (114c0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   1149e:	490c      	ldr	r1, [pc, #48]	; (114d0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x108>)
   114a0:	480c      	ldr	r0, [pc, #48]	; (114d4 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x10c>)
   114a2:	f004 fdf3 	bl	1608c <printf>
   114a6:	4809      	ldr	r0, [pc, #36]	; (114cc <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   114a8:	f002 f822 	bl	134f0 <puts>
   114ac:	2100      	movs	r1, #0
   114ae:	2001      	movs	r0, #1
   114b0:	f7ff fdb6 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   114b4:	e7fe      	b.n	114b4 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xec>
                         "PLL divider value went out of bounds");
      }
    }

    return multiplier_value;
   114b6:	9b04      	ldr	r3, [sp, #16]
  }
   114b8:	4618      	mov	r0, r3
   114ba:	b007      	add	sp, #28
   114bc:	f85d fb04 	ldr.w	pc, [sp], #4
   114c0:	00019b78 	.word	0x00019b78
   114c4:	00019910 	.word	0x00019910
   114c8:	000194fc 	.word	0x000194fc
   114cc:	000194e4 	.word	0x000194e4
   114d0:	00019928 	.word	0x00019928
   114d4:	000195ec 	.word	0x000195ec

000114d8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t SetMainPll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   114d8:	b510      	push	{r4, lr}
   114da:	b08a      	sub	sp, #40	; 0x28
   114dc:	9001      	str	r0, [sp, #4]
   114de:	460b      	mov	r3, r1
   114e0:	f8ad 3002 	strh.w	r3, [sp, #2]
   114e4:	4613      	mov	r3, r2
   114e6:	f8ad 3000 	strh.w	r3, [sp]
  {
    uint16_t divider_value = 1;
   114ea:	2301      	movs	r3, #1
   114ec:	f8ad 301a 	strh.w	r3, [sp, #26]
    uint64_t timeout_time  = Milliseconds() + kDefaultTimeout;
   114f0:	f7ff f9d0 	bl	10894 <Milliseconds()>
   114f4:	460a      	mov	r2, r1
   114f6:	4601      	mov	r1, r0
   114f8:	f511 737a 	adds.w	r3, r1, #1000	; 0x3e8
   114fc:	f142 0400 	adc.w	r4, r2, #0
   11500:	e9cd 3404 	strd	r3, r4, [sp, #16]
    uint64_t current_time  = Milliseconds();
   11504:	f7ff f9c6 	bl	10894 <Milliseconds()>
   11508:	e9cd 0108 	strd	r0, r1, [sp, #32]
    uint32_t multiplier_value =
        CalculatePll(input_frequency, desired_speed_in_mhz);
   1150c:	f8bd 2000 	ldrh.w	r2, [sp]
   11510:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   11514:	4619      	mov	r1, r3
   11516:	9801      	ldr	r0, [sp, #4]
   11518:	f7ff ff56 	bl	113c8 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>
   1151c:	9003      	str	r0, [sp, #12]
    uint32_t actual_speed =
        static_cast<uint32_t>(input_frequency) * multiplier_value;
   1151e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    uint32_t actual_speed =
   11522:	9b03      	ldr	r3, [sp, #12]
   11524:	fb02 f303 	mul.w	r3, r2, r3
   11528:	9307      	str	r3, [sp, #28]
    // TO DO: use registers to retreive values
    SelectOscillatorSource(OscillatorSource::kIrc);
   1152a:	2100      	movs	r1, #0
   1152c:	9801      	ldr	r0, [sp, #4]
   1152e:	f7ff fee9 	bl	11304 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    SelectMainClockSource(MainClockSource::kBaseClock);
   11532:	2100      	movs	r1, #0
   11534:	9801      	ldr	r0, [sp, #4]
   11536:	f7ff feff 	bl	11338 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
    SelectUsbClockSource(UsbSource::kBaseClock);
   1153a:	2100      	movs	r1, #0
   1153c:	9801      	ldr	r0, [sp, #4]
   1153e:	f7ff ff13 	bl	11368 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>
    SelectSpifiClockSource(SpifiSource::kBaseClock);
   11542:	2100      	movs	r1, #0
   11544:	9801      	ldr	r0, [sp, #4]
   11546:	f7ff ff27 	bl	11398 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>
    // must subtract 1 from multiplier value as specified in datasheet
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   1154a:	4b3a      	ldr	r3, [pc, #232]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1154c:	681b      	ldr	r3, [r3, #0]
   1154e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   11552:	f023 011f 	bic.w	r1, r3, #31
        (multiplier_value - 1);
   11556:	9b03      	ldr	r3, [sp, #12]
   11558:	1e5a      	subs	r2, r3, #1
    system_controller->PLL0CFG =
   1155a:	4b36      	ldr	r3, [pc, #216]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1155c:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   1155e:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   11560:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   11564:	4b33      	ldr	r3, [pc, #204]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11566:	681b      	ldr	r3, [r3, #0]
   11568:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   1156c:	f023 0260 	bic.w	r2, r3, #96	; 0x60
   11570:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   11574:	015b      	lsls	r3, r3, #5
   11576:	4619      	mov	r1, r3
    system_controller->PLL0CFG =
   11578:	4b2e      	ldr	r3, [pc, #184]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1157a:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   1157c:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   1157e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CON |= kEnablePll;
   11582:	4b2c      	ldr	r3, [pc, #176]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11584:	681b      	ldr	r3, [r3, #0]
   11586:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   1158a:	4b2a      	ldr	r3, [pc, #168]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1158c:	681b      	ldr	r3, [r3, #0]
   1158e:	f042 0201 	orr.w	r2, r2, #1
   11592:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // nessecary feed sequence to ensure the changes are intentional
    system_controller->PLL0FEED = 0xAA;
   11596:	4b27      	ldr	r3, [pc, #156]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11598:	681b      	ldr	r3, [r3, #0]
   1159a:	22aa      	movs	r2, #170	; 0xaa
   1159c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    system_controller->PLL0FEED = 0x55;
   115a0:	4b24      	ldr	r3, [pc, #144]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   115a2:	681b      	ldr	r3, [r3, #0]
   115a4:	2255      	movs	r2, #85	; 0x55
   115a6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   115aa:	4b22      	ldr	r3, [pc, #136]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   115ac:	681b      	ldr	r3, [r3, #0]
   115ae:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   115b2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   115b6:	2b00      	cmp	r3, #0
   115b8:	d109      	bne.n	115ce <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   115ba:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   115be:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   115c2:	42a2      	cmp	r2, r4
   115c4:	bf08      	it	eq
   115c6:	4299      	cmpeq	r1, r3
   115c8:	d201      	bcs.n	115ce <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   115ca:	2301      	movs	r3, #1
   115cc:	e000      	b.n	115d0 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>
   115ce:	2300      	movs	r3, #0
   115d0:	2b00      	cmp	r3, #0
   115d2:	d004      	beq.n	115de <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x106>
           (current_time < timeout_time))
    {
      current_time = Milliseconds();
   115d4:	f7ff f95e 	bl	10894 <Milliseconds()>
   115d8:	e9cd 0108 	strd	r0, r1, [sp, #32]
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   115dc:	e7e5      	b.n	115aa <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xd2>
    }
    if (!(system_controller->PLL0STAT >> kPlock & 1) &&
   115de:	4b15      	ldr	r3, [pc, #84]	; (11634 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   115e0:	681b      	ldr	r3, [r3, #0]
   115e2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   115e6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   115ea:	2b00      	cmp	r3, #0
   115ec:	d109      	bne.n	11602 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   115ee:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   115f2:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   115f6:	42a2      	cmp	r2, r4
   115f8:	bf08      	it	eq
   115fa:	4299      	cmpeq	r1, r3
   115fc:	d301      	bcc.n	11602 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   115fe:	2301      	movs	r3, #1
   11600:	e000      	b.n	11604 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12c>
   11602:	2300      	movs	r3, #0
   11604:	2b00      	cmp	r3, #0
   11606:	d00e      	beq.n	11626 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14e>
        (current_time >= timeout_time))
    {
      SJ2_ASSERT_FATAL(false,
   11608:	f240 1343 	movw	r3, #323	; 0x143
   1160c:	4a0a      	ldr	r2, [pc, #40]	; (11638 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x160>)
   1160e:	490b      	ldr	r1, [pc, #44]	; (1163c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x164>)
   11610:	480b      	ldr	r0, [pc, #44]	; (11640 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x168>)
   11612:	f004 fd3b 	bl	1608c <printf>
   11616:	480b      	ldr	r0, [pc, #44]	; (11644 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x16c>)
   11618:	f001 ff6a 	bl	134f0 <puts>
   1161c:	2100      	movs	r1, #0
   1161e:	2001      	movs	r0, #1
   11620:	f7ff fcfe 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   11624:	e7fe      	b.n	11624 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14c>
                       "PLL lock could not be established before timeout");
      actual_speed = kDefaultIRCFrequency;
    }
    return (actual_speed - desired_speed_in_mhz);
   11626:	f8bd 3000 	ldrh.w	r3, [sp]
   1162a:	9a07      	ldr	r2, [sp, #28]
   1162c:	1ad3      	subs	r3, r2, r3
  }
   1162e:	4618      	mov	r0, r3
   11630:	b00a      	add	sp, #40	; 0x28
   11632:	bd10      	pop	{r4, pc}
   11634:	10000068 	.word	0x10000068
   11638:	00019b1c 	.word	0x00019b1c
   1163c:	00019940 	.word	0x00019940
   11640:	00019694 	.word	0x00019694
   11644:	000194e4 	.word	0x000194e4

00011648 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>:
                       "PLL lock could not be established before timeout");
    }
    return (actual_speed - desired_speed_in_mhz);
  }

  void SetCpuClockDivider(uint8_t cpu_divider)
   11648:	b500      	push	{lr}
   1164a:	b083      	sub	sp, #12
   1164c:	9001      	str	r0, [sp, #4]
   1164e:	460b      	mov	r3, r1
   11650:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(cpu_divider < 32, "Divider mustn't exceed 32");
   11654:	f89d 3003 	ldrb.w	r3, [sp, #3]
   11658:	2b1f      	cmp	r3, #31
   1165a:	d90e      	bls.n	1167a <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x32>
   1165c:	f240 136f 	movw	r3, #367	; 0x16f
   11660:	4a0e      	ldr	r2, [pc, #56]	; (1169c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x54>)
   11662:	490f      	ldr	r1, [pc, #60]	; (116a0 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x58>)
   11664:	480f      	ldr	r0, [pc, #60]	; (116a4 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x5c>)
   11666:	f004 fd11 	bl	1608c <printf>
   1166a:	480f      	ldr	r0, [pc, #60]	; (116a8 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x60>)
   1166c:	f001 ff40 	bl	134f0 <puts>
   11670:	2100      	movs	r1, #0
   11672:	2001      	movs	r0, #1
   11674:	f7ff fcd4 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   11678:	e7fe      	b.n	11678 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x30>
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   1167a:	4b0c      	ldr	r3, [pc, #48]	; (116ac <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   1167c:	681b      	ldr	r3, [r3, #0]
   1167e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   11682:	f023 011f 	bic.w	r1, r3, #31
   11686:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->CCLKSEL =
   1168a:	4b08      	ldr	r3, [pc, #32]	; (116ac <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   1168c:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   1168e:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11690:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   11694:	bf00      	nop
   11696:	b003      	add	sp, #12
   11698:	f85d fb04 	ldr.w	pc, [sp], #4
   1169c:	00019bd4 	.word	0x00019bd4
   116a0:	00019958 	.word	0x00019958
   116a4:	0001973c 	.word	0x0001973c
   116a8:	000194e4 	.word	0x000194e4
   116ac:	10000068 	.word	0x10000068

000116b0 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>:

  void SetEmcClockDivider(EmcDivider emc_divider)
   116b0:	b082      	sub	sp, #8
   116b2:	9001      	str	r0, [sp, #4]
   116b4:	460b      	mov	r3, r1
   116b6:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    system_controller->EMCCLKSEL =
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   116ba:	4b08      	ldr	r3, [pc, #32]	; (116dc <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   116bc:	681b      	ldr	r3, [r3, #0]
   116be:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   116c2:	f023 0101 	bic.w	r1, r3, #1
        static_cast<uint8_t>(emc_divider);
   116c6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->EMCCLKSEL =
   116ca:	4b04      	ldr	r3, [pc, #16]	; (116dc <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   116cc:	681b      	ldr	r3, [r3, #0]
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   116ce:	430a      	orrs	r2, r1
    system_controller->EMCCLKSEL =
   116d0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
   116d4:	bf00      	nop
   116d6:	b002      	add	sp, #8
   116d8:	4770      	bx	lr
   116da:	bf00      	nop
   116dc:	10000068 	.word	0x10000068

000116e0 <SystemTimer::DisableTimer()>:
  /// system_timer_isr defaults to nullptr. The actual SystemTickHandler should
  /// check if the isr is set to nullptr, and if it is, turn off the timer, if
  /// set a proper function then execute it.
  inline static IsrPointer system_timer_isr = nullptr;
  /// WARNING: Doing so will most likely disable FreeRTOS
  static void DisableTimer()
   116e0:	b510      	push	{r4, lr}
   116e2:	4674      	mov	r4, lr
   116e4:	4623      	mov	r3, r4
   116e6:	4619      	mov	r1, r3
   116e8:	480a      	ldr	r0, [pc, #40]	; (11714 <SystemTimer::DisableTimer()+0x34>)
   116ea:	f001 ff31 	bl	13550 <__cyg_profile_func_enter>
  {
    sys_tick->LOAD = 0;
   116ee:	4b0a      	ldr	r3, [pc, #40]	; (11718 <SystemTimer::DisableTimer()+0x38>)
   116f0:	681b      	ldr	r3, [r3, #0]
   116f2:	2200      	movs	r2, #0
   116f4:	605a      	str	r2, [r3, #4]
    sys_tick->VAL  = 0;
   116f6:	4b08      	ldr	r3, [pc, #32]	; (11718 <SystemTimer::DisableTimer()+0x38>)
   116f8:	681b      	ldr	r3, [r3, #0]
   116fa:	2200      	movs	r2, #0
   116fc:	609a      	str	r2, [r3, #8]
    sys_tick->CTRL = 0;
   116fe:	4b06      	ldr	r3, [pc, #24]	; (11718 <SystemTimer::DisableTimer()+0x38>)
   11700:	681b      	ldr	r3, [r3, #0]
   11702:	2200      	movs	r2, #0
   11704:	601a      	str	r2, [r3, #0]
   11706:	4623      	mov	r3, r4
   11708:	4619      	mov	r1, r3
   1170a:	4802      	ldr	r0, [pc, #8]	; (11714 <SystemTimer::DisableTimer()+0x34>)
   1170c:	f001 ff34 	bl	13578 <__cyg_profile_func_exit>
  }
   11710:	bf00      	nop
   11712:	bd10      	pop	{r4, pc}
   11714:	000116e1 	.word	0x000116e1
   11718:	10000070 	.word	0x10000070

0001171c <SystemTimer::SystemTimerHandler()>:
  static void SystemTimerHandler()
   1171c:	b510      	push	{r4, lr}
   1171e:	4674      	mov	r4, lr
   11720:	4623      	mov	r3, r4
   11722:	4619      	mov	r1, r3
   11724:	4808      	ldr	r0, [pc, #32]	; (11748 <SystemTimer::SystemTimerHandler()+0x2c>)
   11726:	f001 ff13 	bl	13550 <__cyg_profile_func_enter>
  {
    // This assumes that SysTickHandler is called every millisecond.
    // Changing that frequency will distort the milliseconds time.
    if (system_timer_isr != nullptr)
   1172a:	4b08      	ldr	r3, [pc, #32]	; (1174c <SystemTimer::SystemTimerHandler()+0x30>)
   1172c:	681b      	ldr	r3, [r3, #0]
   1172e:	2b00      	cmp	r3, #0
   11730:	d002      	beq.n	11738 <SystemTimer::SystemTimerHandler()+0x1c>
    {
      system_timer_isr();
   11732:	4b06      	ldr	r3, [pc, #24]	; (1174c <SystemTimer::SystemTimerHandler()+0x30>)
   11734:	681b      	ldr	r3, [r3, #0]
   11736:	4798      	blx	r3
   11738:	4623      	mov	r3, r4
   1173a:	4619      	mov	r1, r3
   1173c:	4802      	ldr	r0, [pc, #8]	; (11748 <SystemTimer::SystemTimerHandler()+0x2c>)
   1173e:	f001 ff1b 	bl	13578 <__cyg_profile_func_exit>
    }
  }
   11742:	bf00      	nop
   11744:	bd10      	pop	{r4, pc}
   11746:	bf00      	nop
   11748:	0001171d 	.word	0x0001171d
   1174c:	100003d8 	.word	0x100003d8

00011750 <SystemTimer::SetIsrFunction(void (*)())>:
  constexpr SystemTimer() {}
  void SetIsrFunction(IsrPointer isr) override
   11750:	b510      	push	{r4, lr}
   11752:	b082      	sub	sp, #8
   11754:	4674      	mov	r4, lr
   11756:	9001      	str	r0, [sp, #4]
   11758:	9100      	str	r1, [sp, #0]
   1175a:	4623      	mov	r3, r4
   1175c:	4619      	mov	r1, r3
   1175e:	4807      	ldr	r0, [pc, #28]	; (1177c <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   11760:	f001 fef6 	bl	13550 <__cyg_profile_func_enter>
  {
    system_timer_isr = isr;
   11764:	4a06      	ldr	r2, [pc, #24]	; (11780 <SystemTimer::SetIsrFunction(void (*)())+0x30>)
   11766:	9b00      	ldr	r3, [sp, #0]
   11768:	6013      	str	r3, [r2, #0]
   1176a:	4623      	mov	r3, r4
   1176c:	4619      	mov	r1, r3
   1176e:	4803      	ldr	r0, [pc, #12]	; (1177c <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   11770:	f001 ff02 	bl	13578 <__cyg_profile_func_exit>
  }
   11774:	bf00      	nop
   11776:	b002      	add	sp, #8
   11778:	bd10      	pop	{r4, pc}
   1177a:	bf00      	nop
   1177c:	00011751 	.word	0x00011751
   11780:	100003d8 	.word	0x100003d8

00011784 <SystemTimer::StartTimer()>:
  bool StartTimer() override
   11784:	b530      	push	{r4, r5, lr}
   11786:	b085      	sub	sp, #20
   11788:	4675      	mov	r5, lr
   1178a:	9001      	str	r0, [sp, #4]
   1178c:	462b      	mov	r3, r5
   1178e:	4619      	mov	r1, r3
   11790:	4820      	ldr	r0, [pc, #128]	; (11814 <SystemTimer::StartTimer()+0x90>)
   11792:	f001 fedd 	bl	13550 <__cyg_profile_func_enter>
  {
    bool successful = false;
   11796:	2300      	movs	r3, #0
   11798:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sys_tick->LOAD != 0)
   1179c:	4b1e      	ldr	r3, [pc, #120]	; (11818 <SystemTimer::StartTimer()+0x94>)
   1179e:	681b      	ldr	r3, [r3, #0]
   117a0:	685b      	ldr	r3, [r3, #4]
   117a2:	2b00      	cmp	r3, #0
   117a4:	bf14      	ite	ne
   117a6:	2301      	movne	r3, #1
   117a8:	2300      	moveq	r3, #0
   117aa:	b2db      	uxtb	r3, r3
   117ac:	2b00      	cmp	r3, #0
   117ae:	d01e      	beq.n	117ee <SystemTimer::StartTimer()+0x6a>
    {
      sys_tick->VAL = 0;
   117b0:	4b19      	ldr	r3, [pc, #100]	; (11818 <SystemTimer::StartTimer()+0x94>)
   117b2:	681b      	ldr	r3, [r3, #0]
   117b4:	2200      	movs	r2, #0
   117b6:	609a      	str	r2, [r3, #8]
      sys_tick->CTRL |= (1 << ControlBitMap::kTickInterupt);
   117b8:	4b17      	ldr	r3, [pc, #92]	; (11818 <SystemTimer::StartTimer()+0x94>)
   117ba:	681b      	ldr	r3, [r3, #0]
   117bc:	681a      	ldr	r2, [r3, #0]
   117be:	4b16      	ldr	r3, [pc, #88]	; (11818 <SystemTimer::StartTimer()+0x94>)
   117c0:	681b      	ldr	r3, [r3, #0]
   117c2:	f042 0202 	orr.w	r2, r2, #2
   117c6:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kEnableCounter);
   117c8:	4b13      	ldr	r3, [pc, #76]	; (11818 <SystemTimer::StartTimer()+0x94>)
   117ca:	681b      	ldr	r3, [r3, #0]
   117cc:	681a      	ldr	r2, [r3, #0]
   117ce:	4b12      	ldr	r3, [pc, #72]	; (11818 <SystemTimer::StartTimer()+0x94>)
   117d0:	681b      	ldr	r3, [r3, #0]
   117d2:	f042 0201 	orr.w	r2, r2, #1
   117d6:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kClkSource);
   117d8:	4b0f      	ldr	r3, [pc, #60]	; (11818 <SystemTimer::StartTimer()+0x94>)
   117da:	681b      	ldr	r3, [r3, #0]
   117dc:	681a      	ldr	r2, [r3, #0]
   117de:	4b0e      	ldr	r3, [pc, #56]	; (11818 <SystemTimer::StartTimer()+0x94>)
   117e0:	681b      	ldr	r3, [r3, #0]
   117e2:	f042 0204 	orr.w	r2, r2, #4
   117e6:	601a      	str	r2, [r3, #0]
      successful = true;
   117e8:	2301      	movs	r3, #1
   117ea:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    RegisterIsr(SysTick_IRQn, SystemTimerHandler);
   117ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   117f2:	2201      	movs	r2, #1
   117f4:	4909      	ldr	r1, [pc, #36]	; (1181c <SystemTimer::StartTimer()+0x98>)
   117f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   117fa:	f001 fd55 	bl	132a8 <RegisterIsr(IRQn, void (*)(), bool, long)>
    return successful;
   117fe:	f89d 400f 	ldrb.w	r4, [sp, #15]
   11802:	462b      	mov	r3, r5
   11804:	4619      	mov	r1, r3
   11806:	4803      	ldr	r0, [pc, #12]	; (11814 <SystemTimer::StartTimer()+0x90>)
   11808:	f001 feb6 	bl	13578 <__cyg_profile_func_exit>
   1180c:	4623      	mov	r3, r4
  }
   1180e:	4618      	mov	r0, r3
   11810:	b005      	add	sp, #20
   11812:	bd30      	pop	{r4, r5, pc}
   11814:	00011785 	.word	0x00011785
   11818:	10000070 	.word	0x10000070
   1181c:	0001171d 	.word	0x0001171d

00011820 <SystemTimer::SetTickFrequency(unsigned long)>:
  ///          remainder will be returned.
  ///          If the freqency supplied is less then 2Hz, the function will
  ///          return without changing any hardware.
  ///          If the reload value exceeds the SysTick_LOAD_RELOAD_Msk, the
  ///          returned value is the SysTick_LOAD_RELOAD_Msk.
  uint32_t SetTickFrequency(uint32_t frequency) override
   11820:	b530      	push	{r4, r5, lr}
   11822:	b085      	sub	sp, #20
   11824:	4675      	mov	r5, lr
   11826:	9001      	str	r0, [sp, #4]
   11828:	9100      	str	r1, [sp, #0]
   1182a:	462b      	mov	r3, r5
   1182c:	4619      	mov	r1, r3
   1182e:	481f      	ldr	r0, [pc, #124]	; (118ac <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   11830:	f001 fe8e 	bl	13550 <__cyg_profile_func_enter>
  {
    if (frequency <= 1)
   11834:	9b00      	ldr	r3, [sp, #0]
   11836:	2b01      	cmp	r3, #1
   11838:	d801      	bhi.n	1183e <SystemTimer::SetTickFrequency(unsigned long)+0x1e>
    {
      return 0;
   1183a:	2400      	movs	r4, #0
   1183c:	e02d      	b.n	1189a <SystemTimer::SetTickFrequency(unsigned long)+0x7a>
    }
    uint32_t reload_value = (GetSystemFrequency() / frequency) - 1;
   1183e:	9b01      	ldr	r3, [sp, #4]
   11840:	1d1a      	adds	r2, r3, #4
   11842:	9b01      	ldr	r3, [sp, #4]
   11844:	685b      	ldr	r3, [r3, #4]
   11846:	330c      	adds	r3, #12
   11848:	681b      	ldr	r3, [r3, #0]
   1184a:	4610      	mov	r0, r2
   1184c:	4798      	blx	r3
   1184e:	4602      	mov	r2, r0
   11850:	9b00      	ldr	r3, [sp, #0]
   11852:	fbb2 f3f3 	udiv	r3, r2, r3
   11856:	3b01      	subs	r3, #1
   11858:	9303      	str	r3, [sp, #12]
    int remainder         = (GetSystemFrequency() % frequency);
   1185a:	9b01      	ldr	r3, [sp, #4]
   1185c:	1d1a      	adds	r2, r3, #4
   1185e:	9b01      	ldr	r3, [sp, #4]
   11860:	685b      	ldr	r3, [r3, #4]
   11862:	330c      	adds	r3, #12
   11864:	681b      	ldr	r3, [r3, #0]
   11866:	4610      	mov	r0, r2
   11868:	4798      	blx	r3
   1186a:	4603      	mov	r3, r0
   1186c:	9a00      	ldr	r2, [sp, #0]
   1186e:	fbb3 f2f2 	udiv	r2, r3, r2
   11872:	9900      	ldr	r1, [sp, #0]
   11874:	fb01 f202 	mul.w	r2, r1, r2
   11878:	1a9b      	subs	r3, r3, r2
   1187a:	9302      	str	r3, [sp, #8]
    if (reload_value > SysTick_LOAD_RELOAD_Msk)
   1187c:	9b03      	ldr	r3, [sp, #12]
   1187e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   11882:	d305      	bcc.n	11890 <SystemTimer::SetTickFrequency(unsigned long)+0x70>
    {
      reload_value = SysTick_LOAD_RELOAD_Msk;
   11884:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   11888:	9303      	str	r3, [sp, #12]
      remainder    = SysTick_LOAD_RELOAD_Msk;
   1188a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   1188e:	9302      	str	r3, [sp, #8]
    }
    sys_tick->LOAD = reload_value;
   11890:	4b07      	ldr	r3, [pc, #28]	; (118b0 <SystemTimer::SetTickFrequency(unsigned long)+0x90>)
   11892:	681b      	ldr	r3, [r3, #0]
   11894:	9a03      	ldr	r2, [sp, #12]
   11896:	605a      	str	r2, [r3, #4]
    return remainder;
   11898:	9c02      	ldr	r4, [sp, #8]
   1189a:	462b      	mov	r3, r5
   1189c:	4619      	mov	r1, r3
   1189e:	4803      	ldr	r0, [pc, #12]	; (118ac <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   118a0:	f001 fe6a 	bl	13578 <__cyg_profile_func_exit>
   118a4:	4623      	mov	r3, r4
  }
   118a6:	4618      	mov	r0, r3
   118a8:	b005      	add	sp, #20
   118aa:	bd30      	pop	{r4, r5, pc}
   118ac:	00011821 	.word	0x00011821
   118b0:	10000070 	.word	0x10000070

000118b4 <Pin::SetPinFunction(unsigned char)>:
  }
  constexpr Pin(uint8_t port_number, uint8_t pin_number)
      : port_(port_number), pin_(pin_number)
  {
  }
  void SetPinFunction(uint8_t function) override
   118b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   118b6:	b085      	sub	sp, #20
   118b8:	4677      	mov	r7, lr
   118ba:	9003      	str	r0, [sp, #12]
   118bc:	460b      	mov	r3, r1
   118be:	f88d 300b 	strb.w	r3, [sp, #11]
   118c2:	463b      	mov	r3, r7
   118c4:	4619      	mov	r1, r3
   118c6:	4817      	ldr	r0, [pc, #92]	; (11924 <Pin::SetPinFunction(unsigned char)+0x70>)
   118c8:	f001 fe42 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   118cc:	4b16      	ldr	r3, [pc, #88]	; (11928 <Pin::SetPinFunction(unsigned char)+0x74>)
   118ce:	681b      	ldr	r3, [r3, #0]
   118d0:	9a03      	ldr	r2, [sp, #12]
   118d2:	7912      	ldrb	r2, [r2, #4]
   118d4:	4610      	mov	r0, r2
   118d6:	9a03      	ldr	r2, [sp, #12]
   118d8:	7952      	ldrb	r2, [r2, #5]
   118da:	4611      	mov	r1, r2
   118dc:	0142      	lsls	r2, r0, #5
   118de:	440a      	add	r2, r1
   118e0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 function & 0b111, 3);
   118e4:	f89d 300b 	ldrb.w	r3, [sp, #11]
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   118e8:	f003 0207 	and.w	r2, r3, #7
    pin_map->_register[port_][pin_] =
   118ec:	4b0e      	ldr	r3, [pc, #56]	; (11928 <Pin::SetPinFunction(unsigned char)+0x74>)
   118ee:	681c      	ldr	r4, [r3, #0]
   118f0:	9b03      	ldr	r3, [sp, #12]
   118f2:	791b      	ldrb	r3, [r3, #4]
   118f4:	461e      	mov	r6, r3
   118f6:	9b03      	ldr	r3, [sp, #12]
   118f8:	795b      	ldrb	r3, [r3, #5]
   118fa:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   118fc:	2303      	movs	r3, #3
   118fe:	9300      	str	r3, [sp, #0]
   11900:	4613      	mov	r3, r2
   11902:	2200      	movs	r2, #0
   11904:	9803      	ldr	r0, [sp, #12]
   11906:	f000 fa67 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1190a:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   1190c:	0173      	lsls	r3, r6, #5
   1190e:	442b      	add	r3, r5
   11910:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11914:	463b      	mov	r3, r7
   11916:	4619      	mov	r1, r3
   11918:	4802      	ldr	r0, [pc, #8]	; (11924 <Pin::SetPinFunction(unsigned char)+0x70>)
   1191a:	f001 fe2d 	bl	13578 <__cyg_profile_func_exit>
  }
   1191e:	bf00      	nop
   11920:	b005      	add	sp, #20
   11922:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11924:	000118b5 	.word	0x000118b5
   11928:	10000074 	.word	0x10000074

0001192c <Pin::SetMode(PinInterface::Mode)>:
  void SetMode(PinInterface::Mode mode) override
   1192c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1192e:	b087      	sub	sp, #28
   11930:	4677      	mov	r7, lr
   11932:	9003      	str	r0, [sp, #12]
   11934:	460b      	mov	r3, r1
   11936:	f88d 300b 	strb.w	r3, [sp, #11]
   1193a:	463b      	mov	r3, r7
   1193c:	4619      	mov	r1, r3
   1193e:	4819      	ldr	r0, [pc, #100]	; (119a4 <Pin::SetMode(PinInterface::Mode)+0x78>)
   11940:	f001 fe06 	bl	13550 <__cyg_profile_func_enter>
  {
    uint8_t ui_mode                 = static_cast<uint8_t>(mode);
   11944:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11948:	f88d 3017 	strb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   1194c:	4b16      	ldr	r3, [pc, #88]	; (119a8 <Pin::SetMode(PinInterface::Mode)+0x7c>)
   1194e:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   11950:	9a03      	ldr	r2, [sp, #12]
   11952:	7912      	ldrb	r2, [r2, #4]
   11954:	4610      	mov	r0, r2
   11956:	9a03      	ldr	r2, [sp, #12]
   11958:	7952      	ldrb	r2, [r2, #5]
   1195a:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   1195c:	0142      	lsls	r2, r0, #5
   1195e:	440a      	add	r2, r1
   11960:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   11964:	f89d 3017 	ldrb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   11968:	f003 0203 	and.w	r2, r3, #3
   1196c:	4b0e      	ldr	r3, [pc, #56]	; (119a8 <Pin::SetMode(PinInterface::Mode)+0x7c>)
   1196e:	681c      	ldr	r4, [r3, #0]
   11970:	9b03      	ldr	r3, [sp, #12]
   11972:	791b      	ldrb	r3, [r3, #4]
   11974:	461e      	mov	r6, r3
   11976:	9b03      	ldr	r3, [sp, #12]
   11978:	795b      	ldrb	r3, [r3, #5]
   1197a:	461d      	mov	r5, r3
   1197c:	2302      	movs	r3, #2
   1197e:	9300      	str	r3, [sp, #0]
   11980:	4613      	mov	r3, r2
   11982:	2203      	movs	r2, #3
   11984:	9803      	ldr	r0, [sp, #12]
   11986:	f000 fa27 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1198a:	4602      	mov	r2, r0
   1198c:	0173      	lsls	r3, r6, #5
   1198e:	442b      	add	r3, r5
   11990:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11994:	463b      	mov	r3, r7
   11996:	4619      	mov	r1, r3
   11998:	4802      	ldr	r0, [pc, #8]	; (119a4 <Pin::SetMode(PinInterface::Mode)+0x78>)
   1199a:	f001 fded 	bl	13578 <__cyg_profile_func_exit>
  }
   1199e:	bf00      	nop
   119a0:	b007      	add	sp, #28
   119a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   119a4:	0001192d 	.word	0x0001192d
   119a8:	10000074 	.word	0x10000074

000119ac <Pin::EnableHysteresis(bool)>:
  void EnableHysteresis(bool enable_hysteresis = true) override
   119ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   119ae:	b085      	sub	sp, #20
   119b0:	4677      	mov	r7, lr
   119b2:	9003      	str	r0, [sp, #12]
   119b4:	460b      	mov	r3, r1
   119b6:	f88d 300b 	strb.w	r3, [sp, #11]
   119ba:	463b      	mov	r3, r7
   119bc:	4619      	mov	r1, r3
   119be:	4816      	ldr	r0, [pc, #88]	; (11a18 <Pin::EnableHysteresis(bool)+0x6c>)
   119c0:	f001 fdc6 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   119c4:	4b15      	ldr	r3, [pc, #84]	; (11a1c <Pin::EnableHysteresis(bool)+0x70>)
   119c6:	681b      	ldr	r3, [r3, #0]
   119c8:	9a03      	ldr	r2, [sp, #12]
   119ca:	7912      	ldrb	r2, [r2, #4]
   119cc:	4610      	mov	r0, r2
   119ce:	9a03      	ldr	r2, [sp, #12]
   119d0:	7952      	ldrb	r2, [r2, #5]
   119d2:	4611      	mov	r1, r2
   119d4:	0142      	lsls	r2, r0, #5
   119d6:	440a      	add	r2, r1
   119d8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   119dc:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   119e0:	4b0e      	ldr	r3, [pc, #56]	; (11a1c <Pin::EnableHysteresis(bool)+0x70>)
   119e2:	681c      	ldr	r4, [r3, #0]
   119e4:	9b03      	ldr	r3, [sp, #12]
   119e6:	791b      	ldrb	r3, [r3, #4]
   119e8:	461e      	mov	r6, r3
   119ea:	9b03      	ldr	r3, [sp, #12]
   119ec:	795b      	ldrb	r3, [r3, #5]
   119ee:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   119f0:	2301      	movs	r3, #1
   119f2:	9300      	str	r3, [sp, #0]
   119f4:	4613      	mov	r3, r2
   119f6:	2205      	movs	r2, #5
   119f8:	9803      	ldr	r0, [sp, #12]
   119fa:	f000 f9ed 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   119fe:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11a00:	0173      	lsls	r3, r6, #5
   11a02:	442b      	add	r3, r5
   11a04:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11a08:	463b      	mov	r3, r7
   11a0a:	4619      	mov	r1, r3
   11a0c:	4802      	ldr	r0, [pc, #8]	; (11a18 <Pin::EnableHysteresis(bool)+0x6c>)
   11a0e:	f001 fdb3 	bl	13578 <__cyg_profile_func_exit>
                 enable_hysteresis, 1);
  }
   11a12:	bf00      	nop
   11a14:	b005      	add	sp, #20
   11a16:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11a18:	000119ad 	.word	0x000119ad
   11a1c:	10000074 	.word	0x10000074

00011a20 <Pin::SetAsActiveLow(bool)>:
  void SetAsActiveLow(bool set_as_active_low = true) override
   11a20:	b5f0      	push	{r4, r5, r6, r7, lr}
   11a22:	b085      	sub	sp, #20
   11a24:	4677      	mov	r7, lr
   11a26:	9003      	str	r0, [sp, #12]
   11a28:	460b      	mov	r3, r1
   11a2a:	f88d 300b 	strb.w	r3, [sp, #11]
   11a2e:	463b      	mov	r3, r7
   11a30:	4619      	mov	r1, r3
   11a32:	4816      	ldr	r0, [pc, #88]	; (11a8c <Pin::SetAsActiveLow(bool)+0x6c>)
   11a34:	f001 fd8c 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   11a38:	4b15      	ldr	r3, [pc, #84]	; (11a90 <Pin::SetAsActiveLow(bool)+0x70>)
   11a3a:	681b      	ldr	r3, [r3, #0]
   11a3c:	9a03      	ldr	r2, [sp, #12]
   11a3e:	7912      	ldrb	r2, [r2, #4]
   11a40:	4610      	mov	r0, r2
   11a42:	9a03      	ldr	r2, [sp, #12]
   11a44:	7952      	ldrb	r2, [r2, #5]
   11a46:	4611      	mov	r1, r2
   11a48:	0142      	lsls	r2, r0, #5
   11a4a:	440a      	add	r2, r1
   11a4c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11a50:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11a54:	4b0e      	ldr	r3, [pc, #56]	; (11a90 <Pin::SetAsActiveLow(bool)+0x70>)
   11a56:	681c      	ldr	r4, [r3, #0]
   11a58:	9b03      	ldr	r3, [sp, #12]
   11a5a:	791b      	ldrb	r3, [r3, #4]
   11a5c:	461e      	mov	r6, r3
   11a5e:	9b03      	ldr	r3, [sp, #12]
   11a60:	795b      	ldrb	r3, [r3, #5]
   11a62:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   11a64:	2301      	movs	r3, #1
   11a66:	9300      	str	r3, [sp, #0]
   11a68:	4613      	mov	r3, r2
   11a6a:	2206      	movs	r2, #6
   11a6c:	9803      	ldr	r0, [sp, #12]
   11a6e:	f000 f9b3 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11a72:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11a74:	0173      	lsls	r3, r6, #5
   11a76:	442b      	add	r3, r5
   11a78:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11a7c:	463b      	mov	r3, r7
   11a7e:	4619      	mov	r1, r3
   11a80:	4802      	ldr	r0, [pc, #8]	; (11a8c <Pin::SetAsActiveLow(bool)+0x6c>)
   11a82:	f001 fd79 	bl	13578 <__cyg_profile_func_exit>
                 set_as_active_low, 1);
  }
   11a86:	bf00      	nop
   11a88:	b005      	add	sp, #20
   11a8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11a8c:	00011a21 	.word	0x00011a21
   11a90:	10000074 	.word	0x10000074

00011a94 <Pin::SetAsAnalogMode(bool)>:
  // Set bit to 0 to enable analog mode
  void SetAsAnalogMode(bool set_as_analog = true) override
   11a94:	b5f0      	push	{r4, r5, r6, r7, lr}
   11a96:	b085      	sub	sp, #20
   11a98:	4677      	mov	r7, lr
   11a9a:	9003      	str	r0, [sp, #12]
   11a9c:	460b      	mov	r3, r1
   11a9e:	f88d 300b 	strb.w	r3, [sp, #11]
   11aa2:	463b      	mov	r3, r7
   11aa4:	4619      	mov	r1, r3
   11aa6:	4818      	ldr	r0, [pc, #96]	; (11b08 <Pin::SetAsAnalogMode(bool)+0x74>)
   11aa8:	f001 fd52 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   11aac:	4b17      	ldr	r3, [pc, #92]	; (11b0c <Pin::SetAsAnalogMode(bool)+0x78>)
   11aae:	681b      	ldr	r3, [r3, #0]
   11ab0:	9a03      	ldr	r2, [sp, #12]
   11ab2:	7912      	ldrb	r2, [r2, #4]
   11ab4:	4610      	mov	r0, r2
   11ab6:	9a03      	ldr	r2, [sp, #12]
   11ab8:	7952      	ldrb	r2, [r2, #5]
   11aba:	4611      	mov	r1, r2
   11abc:	0142      	lsls	r2, r0, #5
   11abe:	440a      	add	r2, r1
   11ac0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !set_as_analog, 1);
   11ac4:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11ac8:	f083 0301 	eor.w	r3, r3, #1
   11acc:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   11ace:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11ad0:	4b0e      	ldr	r3, [pc, #56]	; (11b0c <Pin::SetAsAnalogMode(bool)+0x78>)
   11ad2:	681c      	ldr	r4, [r3, #0]
   11ad4:	9b03      	ldr	r3, [sp, #12]
   11ad6:	791b      	ldrb	r3, [r3, #4]
   11ad8:	461e      	mov	r6, r3
   11ada:	9b03      	ldr	r3, [sp, #12]
   11adc:	795b      	ldrb	r3, [r3, #5]
   11ade:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   11ae0:	2301      	movs	r3, #1
   11ae2:	9300      	str	r3, [sp, #0]
   11ae4:	4613      	mov	r3, r2
   11ae6:	2207      	movs	r2, #7
   11ae8:	9803      	ldr	r0, [sp, #12]
   11aea:	f000 f975 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11aee:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11af0:	0173      	lsls	r3, r6, #5
   11af2:	442b      	add	r3, r5
   11af4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11af8:	463b      	mov	r3, r7
   11afa:	4619      	mov	r1, r3
   11afc:	4802      	ldr	r0, [pc, #8]	; (11b08 <Pin::SetAsAnalogMode(bool)+0x74>)
   11afe:	f001 fd3b 	bl	13578 <__cyg_profile_func_exit>
  }
   11b02:	bf00      	nop
   11b04:	b005      	add	sp, #20
   11b06:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11b08:	00011a95 	.word	0x00011a95
   11b0c:	10000074 	.word	0x10000074

00011b10 <Pin::EnableDigitalFilter(bool)>:
  // Enable by setting bit to 0 to enable digital filter.
  void EnableDigitalFilter(bool enable_digital_filter = true) override
   11b10:	b5f0      	push	{r4, r5, r6, r7, lr}
   11b12:	b085      	sub	sp, #20
   11b14:	4677      	mov	r7, lr
   11b16:	9003      	str	r0, [sp, #12]
   11b18:	460b      	mov	r3, r1
   11b1a:	f88d 300b 	strb.w	r3, [sp, #11]
   11b1e:	463b      	mov	r3, r7
   11b20:	4619      	mov	r1, r3
   11b22:	4818      	ldr	r0, [pc, #96]	; (11b84 <Pin::EnableDigitalFilter(bool)+0x74>)
   11b24:	f001 fd14 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   11b28:	4b17      	ldr	r3, [pc, #92]	; (11b88 <Pin::EnableDigitalFilter(bool)+0x78>)
   11b2a:	681b      	ldr	r3, [r3, #0]
   11b2c:	9a03      	ldr	r2, [sp, #12]
   11b2e:	7912      	ldrb	r2, [r2, #4]
   11b30:	4610      	mov	r0, r2
   11b32:	9a03      	ldr	r2, [sp, #12]
   11b34:	7952      	ldrb	r2, [r2, #5]
   11b36:	4611      	mov	r1, r2
   11b38:	0142      	lsls	r2, r0, #5
   11b3a:	440a      	add	r2, r1
   11b3c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_digital_filter, 1);
   11b40:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11b44:	f083 0301 	eor.w	r3, r3, #1
   11b48:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   11b4a:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11b4c:	4b0e      	ldr	r3, [pc, #56]	; (11b88 <Pin::EnableDigitalFilter(bool)+0x78>)
   11b4e:	681c      	ldr	r4, [r3, #0]
   11b50:	9b03      	ldr	r3, [sp, #12]
   11b52:	791b      	ldrb	r3, [r3, #4]
   11b54:	461e      	mov	r6, r3
   11b56:	9b03      	ldr	r3, [sp, #12]
   11b58:	795b      	ldrb	r3, [r3, #5]
   11b5a:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   11b5c:	2301      	movs	r3, #1
   11b5e:	9300      	str	r3, [sp, #0]
   11b60:	4613      	mov	r3, r2
   11b62:	2208      	movs	r2, #8
   11b64:	9803      	ldr	r0, [sp, #12]
   11b66:	f000 f937 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11b6a:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11b6c:	0173      	lsls	r3, r6, #5
   11b6e:	442b      	add	r3, r5
   11b70:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11b74:	463b      	mov	r3, r7
   11b76:	4619      	mov	r1, r3
   11b78:	4802      	ldr	r0, [pc, #8]	; (11b84 <Pin::EnableDigitalFilter(bool)+0x74>)
   11b7a:	f001 fcfd 	bl	13578 <__cyg_profile_func_exit>
  }
   11b7e:	bf00      	nop
   11b80:	b005      	add	sp, #20
   11b82:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11b84:	00011b11 	.word	0x00011b11
   11b88:	10000074 	.word	0x10000074

00011b8c <Pin::EnableFastMode(bool)>:
  void EnableFastMode(bool enable_fast_mode = true) override
   11b8c:	b5f0      	push	{r4, r5, r6, r7, lr}
   11b8e:	b085      	sub	sp, #20
   11b90:	4677      	mov	r7, lr
   11b92:	9003      	str	r0, [sp, #12]
   11b94:	460b      	mov	r3, r1
   11b96:	f88d 300b 	strb.w	r3, [sp, #11]
   11b9a:	463b      	mov	r3, r7
   11b9c:	4619      	mov	r1, r3
   11b9e:	4816      	ldr	r0, [pc, #88]	; (11bf8 <Pin::EnableFastMode(bool)+0x6c>)
   11ba0:	f001 fcd6 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   11ba4:	4b15      	ldr	r3, [pc, #84]	; (11bfc <Pin::EnableFastMode(bool)+0x70>)
   11ba6:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kSlew, enable_fast_mode, 1);
   11ba8:	9a03      	ldr	r2, [sp, #12]
   11baa:	7912      	ldrb	r2, [r2, #4]
   11bac:	4610      	mov	r0, r2
   11bae:	9a03      	ldr	r2, [sp, #12]
   11bb0:	7952      	ldrb	r2, [r2, #5]
   11bb2:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   11bb4:	0142      	lsls	r2, r0, #5
   11bb6:	440a      	add	r2, r1
   11bb8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11bbc:	f89d 200b 	ldrb.w	r2, [sp, #11]
   11bc0:	4b0e      	ldr	r3, [pc, #56]	; (11bfc <Pin::EnableFastMode(bool)+0x70>)
   11bc2:	681c      	ldr	r4, [r3, #0]
   11bc4:	9b03      	ldr	r3, [sp, #12]
   11bc6:	791b      	ldrb	r3, [r3, #4]
   11bc8:	461e      	mov	r6, r3
   11bca:	9b03      	ldr	r3, [sp, #12]
   11bcc:	795b      	ldrb	r3, [r3, #5]
   11bce:	461d      	mov	r5, r3
   11bd0:	2301      	movs	r3, #1
   11bd2:	9300      	str	r3, [sp, #0]
   11bd4:	4613      	mov	r3, r2
   11bd6:	2209      	movs	r2, #9
   11bd8:	9803      	ldr	r0, [sp, #12]
   11bda:	f000 f8fd 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11bde:	4602      	mov	r2, r0
   11be0:	0173      	lsls	r3, r6, #5
   11be2:	442b      	add	r3, r5
   11be4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11be8:	463b      	mov	r3, r7
   11bea:	4619      	mov	r1, r3
   11bec:	4802      	ldr	r0, [pc, #8]	; (11bf8 <Pin::EnableFastMode(bool)+0x6c>)
   11bee:	f001 fcc3 	bl	13578 <__cyg_profile_func_exit>
  }
   11bf2:	bf00      	nop
   11bf4:	b005      	add	sp, #20
   11bf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11bf8:	00011b8d 	.word	0x00011b8d
   11bfc:	10000074 	.word	0x10000074

00011c00 <Pin::EnableI2cHighSpeedMode(bool)>:
  // Enable by setting bit to 0 for i2c high speed mode
  void EnableI2cHighSpeedMode(bool enable_high_speed = true) override
   11c00:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c02:	b085      	sub	sp, #20
   11c04:	4677      	mov	r7, lr
   11c06:	9003      	str	r0, [sp, #12]
   11c08:	460b      	mov	r3, r1
   11c0a:	f88d 300b 	strb.w	r3, [sp, #11]
   11c0e:	463b      	mov	r3, r7
   11c10:	4619      	mov	r1, r3
   11c12:	4818      	ldr	r0, [pc, #96]	; (11c74 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   11c14:	f001 fc9c 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11c18:	4b17      	ldr	r3, [pc, #92]	; (11c78 <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   11c1a:	681b      	ldr	r3, [r3, #0]
   11c1c:	9a03      	ldr	r2, [sp, #12]
   11c1e:	7912      	ldrb	r2, [r2, #4]
   11c20:	4610      	mov	r0, r2
   11c22:	9a03      	ldr	r2, [sp, #12]
   11c24:	7952      	ldrb	r2, [r2, #5]
   11c26:	4611      	mov	r1, r2
   11c28:	0142      	lsls	r2, r0, #5
   11c2a:	440a      	add	r2, r1
   11c2c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_high_speed, 1);
   11c30:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11c34:	f083 0301 	eor.w	r3, r3, #1
   11c38:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11c3a:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11c3c:	4b0e      	ldr	r3, [pc, #56]	; (11c78 <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   11c3e:	681c      	ldr	r4, [r3, #0]
   11c40:	9b03      	ldr	r3, [sp, #12]
   11c42:	791b      	ldrb	r3, [r3, #4]
   11c44:	461e      	mov	r6, r3
   11c46:	9b03      	ldr	r3, [sp, #12]
   11c48:	795b      	ldrb	r3, [r3, #5]
   11c4a:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11c4c:	2301      	movs	r3, #1
   11c4e:	9300      	str	r3, [sp, #0]
   11c50:	4613      	mov	r3, r2
   11c52:	2208      	movs	r2, #8
   11c54:	9803      	ldr	r0, [sp, #12]
   11c56:	f000 f8bf 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11c5a:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11c5c:	0173      	lsls	r3, r6, #5
   11c5e:	442b      	add	r3, r5
   11c60:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11c64:	463b      	mov	r3, r7
   11c66:	4619      	mov	r1, r3
   11c68:	4802      	ldr	r0, [pc, #8]	; (11c74 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   11c6a:	f001 fc85 	bl	13578 <__cyg_profile_func_exit>
  }
   11c6e:	bf00      	nop
   11c70:	b005      	add	sp, #20
   11c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11c74:	00011c01 	.word	0x00011c01
   11c78:	10000074 	.word	0x10000074

00011c7c <Pin::EnableI2cHighCurrentDrive(bool)>:
  void EnableI2cHighCurrentDrive(bool enable_high_current = true) override
   11c7c:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c7e:	b085      	sub	sp, #20
   11c80:	4677      	mov	r7, lr
   11c82:	9003      	str	r0, [sp, #12]
   11c84:	460b      	mov	r3, r1
   11c86:	f88d 300b 	strb.w	r3, [sp, #11]
   11c8a:	463b      	mov	r3, r7
   11c8c:	4619      	mov	r1, r3
   11c8e:	4816      	ldr	r0, [pc, #88]	; (11ce8 <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   11c90:	f001 fc5e 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_],
   11c94:	4b15      	ldr	r3, [pc, #84]	; (11cec <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   11c96:	681b      	ldr	r3, [r3, #0]
   11c98:	9a03      	ldr	r2, [sp, #12]
   11c9a:	7912      	ldrb	r2, [r2, #4]
   11c9c:	4610      	mov	r0, r2
   11c9e:	9a03      	ldr	r2, [sp, #12]
   11ca0:	7952      	ldrb	r2, [r2, #5]
   11ca2:	4611      	mov	r1, r2
   11ca4:	0142      	lsls	r2, r0, #5
   11ca6:	440a      	add	r2, r1
   11ca8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11cac:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11cb0:	4b0e      	ldr	r3, [pc, #56]	; (11cec <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   11cb2:	681c      	ldr	r4, [r3, #0]
   11cb4:	9b03      	ldr	r3, [sp, #12]
   11cb6:	791b      	ldrb	r3, [r3, #4]
   11cb8:	461e      	mov	r6, r3
   11cba:	9b03      	ldr	r3, [sp, #12]
   11cbc:	795b      	ldrb	r3, [r3, #5]
   11cbe:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_],
   11cc0:	2301      	movs	r3, #1
   11cc2:	9300      	str	r3, [sp, #0]
   11cc4:	4613      	mov	r3, r2
   11cc6:	2209      	movs	r2, #9
   11cc8:	9803      	ldr	r0, [sp, #12]
   11cca:	f000 f885 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11cce:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11cd0:	0173      	lsls	r3, r6, #5
   11cd2:	442b      	add	r3, r5
   11cd4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11cd8:	463b      	mov	r3, r7
   11cda:	4619      	mov	r1, r3
   11cdc:	4802      	ldr	r0, [pc, #8]	; (11ce8 <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   11cde:	f001 fc4b 	bl	13578 <__cyg_profile_func_exit>
                 PinBitMap::kI2cHighCurrentDrive, enable_high_current, 1);
  }
   11ce2:	bf00      	nop
   11ce4:	b005      	add	sp, #20
   11ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11ce8:	00011c7d 	.word	0x00011c7d
   11cec:	10000074 	.word	0x10000074

00011cf0 <Pin::SetAsOpenDrain(bool)>:
  void SetAsOpenDrain(bool set_as_open_drain = true) override
   11cf0:	b5f0      	push	{r4, r5, r6, r7, lr}
   11cf2:	b085      	sub	sp, #20
   11cf4:	4677      	mov	r7, lr
   11cf6:	9003      	str	r0, [sp, #12]
   11cf8:	460b      	mov	r3, r1
   11cfa:	f88d 300b 	strb.w	r3, [sp, #11]
   11cfe:	463b      	mov	r3, r7
   11d00:	4619      	mov	r1, r3
   11d02:	4816      	ldr	r0, [pc, #88]	; (11d5c <Pin::SetAsOpenDrain(bool)+0x6c>)
   11d04:	f001 fc24 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   11d08:	4b15      	ldr	r3, [pc, #84]	; (11d60 <Pin::SetAsOpenDrain(bool)+0x70>)
   11d0a:	681b      	ldr	r3, [r3, #0]
   11d0c:	9a03      	ldr	r2, [sp, #12]
   11d0e:	7912      	ldrb	r2, [r2, #4]
   11d10:	4610      	mov	r0, r2
   11d12:	9a03      	ldr	r2, [sp, #12]
   11d14:	7952      	ldrb	r2, [r2, #5]
   11d16:	4611      	mov	r1, r2
   11d18:	0142      	lsls	r2, r0, #5
   11d1a:	440a      	add	r2, r1
   11d1c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11d20:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11d24:	4b0e      	ldr	r3, [pc, #56]	; (11d60 <Pin::SetAsOpenDrain(bool)+0x70>)
   11d26:	681c      	ldr	r4, [r3, #0]
   11d28:	9b03      	ldr	r3, [sp, #12]
   11d2a:	791b      	ldrb	r3, [r3, #4]
   11d2c:	461e      	mov	r6, r3
   11d2e:	9b03      	ldr	r3, [sp, #12]
   11d30:	795b      	ldrb	r3, [r3, #5]
   11d32:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   11d34:	2301      	movs	r3, #1
   11d36:	9300      	str	r3, [sp, #0]
   11d38:	4613      	mov	r3, r2
   11d3a:	220a      	movs	r2, #10
   11d3c:	9803      	ldr	r0, [sp, #12]
   11d3e:	f000 f84b 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11d42:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11d44:	0173      	lsls	r3, r6, #5
   11d46:	442b      	add	r3, r5
   11d48:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11d4c:	463b      	mov	r3, r7
   11d4e:	4619      	mov	r1, r3
   11d50:	4802      	ldr	r0, [pc, #8]	; (11d5c <Pin::SetAsOpenDrain(bool)+0x6c>)
   11d52:	f001 fc11 	bl	13578 <__cyg_profile_func_exit>
                 set_as_open_drain, 1);
  }
   11d56:	bf00      	nop
   11d58:	b005      	add	sp, #20
   11d5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11d5c:	00011cf1 	.word	0x00011cf1
   11d60:	10000074 	.word	0x10000074

00011d64 <Pin::EnableDac(bool)>:
  void EnableDac(bool enable_dac = true) override
   11d64:	b5f0      	push	{r4, r5, r6, r7, lr}
   11d66:	b085      	sub	sp, #20
   11d68:	4677      	mov	r7, lr
   11d6a:	9003      	str	r0, [sp, #12]
   11d6c:	460b      	mov	r3, r1
   11d6e:	f88d 300b 	strb.w	r3, [sp, #11]
   11d72:	463b      	mov	r3, r7
   11d74:	4619      	mov	r1, r3
   11d76:	4816      	ldr	r0, [pc, #88]	; (11dd0 <Pin::EnableDac(bool)+0x6c>)
   11d78:	f001 fbea 	bl	13550 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   11d7c:	4b15      	ldr	r3, [pc, #84]	; (11dd4 <Pin::EnableDac(bool)+0x70>)
   11d7e:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kDacEnable, enable_dac, 1);
   11d80:	9a03      	ldr	r2, [sp, #12]
   11d82:	7912      	ldrb	r2, [r2, #4]
   11d84:	4610      	mov	r0, r2
   11d86:	9a03      	ldr	r2, [sp, #12]
   11d88:	7952      	ldrb	r2, [r2, #5]
   11d8a:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   11d8c:	0142      	lsls	r2, r0, #5
   11d8e:	440a      	add	r2, r1
   11d90:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11d94:	f89d 200b 	ldrb.w	r2, [sp, #11]
   11d98:	4b0e      	ldr	r3, [pc, #56]	; (11dd4 <Pin::EnableDac(bool)+0x70>)
   11d9a:	681c      	ldr	r4, [r3, #0]
   11d9c:	9b03      	ldr	r3, [sp, #12]
   11d9e:	791b      	ldrb	r3, [r3, #4]
   11da0:	461e      	mov	r6, r3
   11da2:	9b03      	ldr	r3, [sp, #12]
   11da4:	795b      	ldrb	r3, [r3, #5]
   11da6:	461d      	mov	r5, r3
   11da8:	2301      	movs	r3, #1
   11daa:	9300      	str	r3, [sp, #0]
   11dac:	4613      	mov	r3, r2
   11dae:	2210      	movs	r2, #16
   11db0:	9803      	ldr	r0, [sp, #12]
   11db2:	f000 f811 	bl	11dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11db6:	4602      	mov	r2, r0
   11db8:	0173      	lsls	r3, r6, #5
   11dba:	442b      	add	r3, r5
   11dbc:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11dc0:	463b      	mov	r3, r7
   11dc2:	4619      	mov	r1, r3
   11dc4:	4802      	ldr	r0, [pc, #8]	; (11dd0 <Pin::EnableDac(bool)+0x6c>)
   11dc6:	f001 fbd7 	bl	13578 <__cyg_profile_func_exit>
  }
   11dca:	bf00      	nop
   11dcc:	b005      	add	sp, #20
   11dce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11dd0:	00011d65 	.word	0x00011d65
   11dd4:	10000074 	.word	0x10000074

00011dd8 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>:
  inline uint32_t BitPlace(uint32_t target, uint32_t position, uint32_t value,
   11dd8:	b530      	push	{r4, r5, lr}
   11dda:	b087      	sub	sp, #28
   11ddc:	4675      	mov	r5, lr
   11dde:	9003      	str	r0, [sp, #12]
   11de0:	9102      	str	r1, [sp, #8]
   11de2:	9201      	str	r2, [sp, #4]
   11de4:	9300      	str	r3, [sp, #0]
   11de6:	462b      	mov	r3, r5
   11de8:	4619      	mov	r1, r3
   11dea:	4813      	ldr	r0, [pc, #76]	; (11e38 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   11dec:	f001 fbb0 	bl	13550 <__cyg_profile_func_enter>
                           uint32_t value_width)
  {
    // Generate mask with all 1s
    uint32_t mask = 0xFFFFFFFF >> (32 - value_width);
   11df0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   11df2:	f1c3 0320 	rsb	r3, r3, #32
   11df6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11dfa:	fa22 f303 	lsr.w	r3, r2, r3
   11dfe:	9305      	str	r3, [sp, #20]
    target &= ~(mask << position);
   11e00:	9a05      	ldr	r2, [sp, #20]
   11e02:	9b01      	ldr	r3, [sp, #4]
   11e04:	fa02 f303 	lsl.w	r3, r2, r3
   11e08:	43db      	mvns	r3, r3
   11e0a:	9a02      	ldr	r2, [sp, #8]
   11e0c:	4013      	ands	r3, r2
   11e0e:	9302      	str	r3, [sp, #8]
    target |= (value & mask) << position;
   11e10:	9a00      	ldr	r2, [sp, #0]
   11e12:	9b05      	ldr	r3, [sp, #20]
   11e14:	401a      	ands	r2, r3
   11e16:	9b01      	ldr	r3, [sp, #4]
   11e18:	fa02 f303 	lsl.w	r3, r2, r3
   11e1c:	9a02      	ldr	r2, [sp, #8]
   11e1e:	4313      	orrs	r3, r2
   11e20:	9302      	str	r3, [sp, #8]
    return target;
   11e22:	9c02      	ldr	r4, [sp, #8]
   11e24:	462b      	mov	r3, r5
   11e26:	4619      	mov	r1, r3
   11e28:	4803      	ldr	r0, [pc, #12]	; (11e38 <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   11e2a:	f001 fba5 	bl	13578 <__cyg_profile_func_exit>
   11e2e:	4623      	mov	r3, r4
  }
   11e30:	4618      	mov	r0, r3
   11e32:	b007      	add	sp, #28
   11e34:	bd30      	pop	{r4, r5, pc}
   11e36:	bf00      	nop
   11e38:	00011dd9 	.word	0x00011dd9

00011e3c <Pin::GetPort() const>:
  uint8_t GetPort() const override
   11e3c:	b530      	push	{r4, r5, lr}
   11e3e:	b083      	sub	sp, #12
   11e40:	4675      	mov	r5, lr
   11e42:	9001      	str	r0, [sp, #4]
   11e44:	462b      	mov	r3, r5
   11e46:	4619      	mov	r1, r3
   11e48:	4806      	ldr	r0, [pc, #24]	; (11e64 <Pin::GetPort() const+0x28>)
   11e4a:	f001 fb81 	bl	13550 <__cyg_profile_func_enter>
  {
    return port_;
   11e4e:	9b01      	ldr	r3, [sp, #4]
   11e50:	791c      	ldrb	r4, [r3, #4]
   11e52:	462b      	mov	r3, r5
   11e54:	4619      	mov	r1, r3
   11e56:	4803      	ldr	r0, [pc, #12]	; (11e64 <Pin::GetPort() const+0x28>)
   11e58:	f001 fb8e 	bl	13578 <__cyg_profile_func_exit>
   11e5c:	4623      	mov	r3, r4
  }
   11e5e:	4618      	mov	r0, r3
   11e60:	b003      	add	sp, #12
   11e62:	bd30      	pop	{r4, r5, pc}
   11e64:	00011e3d 	.word	0x00011e3d

00011e68 <Pin::GetPin() const>:
  uint8_t GetPin() const override
   11e68:	b530      	push	{r4, r5, lr}
   11e6a:	b083      	sub	sp, #12
   11e6c:	4675      	mov	r5, lr
   11e6e:	9001      	str	r0, [sp, #4]
   11e70:	462b      	mov	r3, r5
   11e72:	4619      	mov	r1, r3
   11e74:	4806      	ldr	r0, [pc, #24]	; (11e90 <Pin::GetPin() const+0x28>)
   11e76:	f001 fb6b 	bl	13550 <__cyg_profile_func_enter>
  {
    return pin_;
   11e7a:	9b01      	ldr	r3, [sp, #4]
   11e7c:	795c      	ldrb	r4, [r3, #5]
   11e7e:	462b      	mov	r3, r5
   11e80:	4619      	mov	r1, r3
   11e82:	4803      	ldr	r0, [pc, #12]	; (11e90 <Pin::GetPin() const+0x28>)
   11e84:	f001 fb78 	bl	13578 <__cyg_profile_func_exit>
   11e88:	4623      	mov	r3, r4
  }
   11e8a:	4618      	mov	r0, r3
   11e8c:	b003      	add	sp, #12
   11e8e:	bd30      	pop	{r4, r5, pc}
   11e90:	00011e69 	.word	0x00011e69

00011e94 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>:
constexpr Type Value(Enum enum_type_value)
   11e94:	b530      	push	{r4, r5, lr}
   11e96:	b083      	sub	sp, #12
   11e98:	4675      	mov	r5, lr
   11e9a:	4603      	mov	r3, r0
   11e9c:	f88d 3007 	strb.w	r3, [sp, #7]
   11ea0:	462b      	mov	r3, r5
   11ea2:	4619      	mov	r1, r3
   11ea4:	4806      	ldr	r0, [pc, #24]	; (11ec0 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   11ea6:	f001 fb53 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11eaa:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11eae:	462b      	mov	r3, r5
   11eb0:	4619      	mov	r1, r3
   11eb2:	4803      	ldr	r0, [pc, #12]	; (11ec0 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   11eb4:	f001 fb60 	bl	13578 <__cyg_profile_func_exit>
   11eb8:	4623      	mov	r3, r4
}
   11eba:	4618      	mov	r0, r3
   11ebc:	b003      	add	sp, #12
   11ebe:	bd30      	pop	{r4, r5, pc}
   11ec0:	00011e95 	.word	0x00011e95

00011ec4 <Timer::DoNothingIsr()>:
    Lpc40xxSystemController::Peripherals::kTimer3
  };

  static constexpr IRQn kTimerIrq[] = { IRQn::TIMER0_IRQn, IRQn::TIMER1_IRQn,
                                        IRQn::TIMER2_IRQn, IRQn::TIMER3_IRQn };
  static void DoNothingIsr() {}
   11ec4:	b510      	push	{r4, lr}
   11ec6:	4674      	mov	r4, lr
   11ec8:	4623      	mov	r3, r4
   11eca:	4619      	mov	r1, r3
   11ecc:	4804      	ldr	r0, [pc, #16]	; (11ee0 <Timer::DoNothingIsr()+0x1c>)
   11ece:	f001 fb3f 	bl	13550 <__cyg_profile_func_enter>
   11ed2:	4623      	mov	r3, r4
   11ed4:	4619      	mov	r1, r3
   11ed6:	4802      	ldr	r0, [pc, #8]	; (11ee0 <Timer::DoNothingIsr()+0x1c>)
   11ed8:	f001 fb4e 	bl	13578 <__cyg_profile_func_exit>
   11edc:	bf00      	nop
   11ede:	bd10      	pop	{r4, pc}
   11ee0:	00011ec5 	.word	0x00011ec5

00011ee4 <Timer::Initialize(unsigned long, void (*)(), long)>:
  ///                  register will be 10 ms.
  /// @param isr an ISR that will fire when the condition set by SetTimer
  ///            method is achieved.
  /// @param priority sets the Timer interrupt's priority level, defaults to -1
  ///                 which uses the platforms default priority.
  void Initialize(uint32_t frequency, IsrPointer isr = DoNothingIsr,
   11ee4:	b510      	push	{r4, lr}
   11ee6:	b086      	sub	sp, #24
   11ee8:	4674      	mov	r4, lr
   11eea:	9003      	str	r0, [sp, #12]
   11eec:	9102      	str	r1, [sp, #8]
   11eee:	9201      	str	r2, [sp, #4]
   11ef0:	9300      	str	r3, [sp, #0]
   11ef2:	4623      	mov	r3, r4
   11ef4:	4619      	mov	r1, r3
   11ef6:	483e      	ldr	r0, [pc, #248]	; (11ff0 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   11ef8:	f001 fb2a 	bl	13550 <__cyg_profile_func_enter>
                  int32_t priority = -1) override final
  {
    PowerUpPeripheral(kPowerbit[channel_]);
   11efc:	9b03      	ldr	r3, [sp, #12]
   11efe:	1d18      	adds	r0, r3, #4
   11f00:	9b03      	ldr	r3, [sp, #12]
   11f02:	685b      	ldr	r3, [r3, #4]
   11f04:	3314      	adds	r3, #20
   11f06:	681b      	ldr	r3, [r3, #0]
   11f08:	9a03      	ldr	r2, [sp, #12]
   11f0a:	7a12      	ldrb	r2, [r2, #8]
   11f0c:	0092      	lsls	r2, r2, #2
   11f0e:	4939      	ldr	r1, [pc, #228]	; (11ff4 <Timer::Initialize(unsigned long, void (*)(), long)+0x110>)
   11f10:	440a      	add	r2, r1
   11f12:	4611      	mov	r1, r2
   11f14:	4798      	blx	r3
    SJ2_ASSERT_FATAL(
   11f16:	9b02      	ldr	r3, [sp, #8]
   11f18:	2b00      	cmp	r3, #0
   11f1a:	d10d      	bne.n	11f38 <Timer::Initialize(unsigned long, void (*)(), long)+0x54>
   11f1c:	2384      	movs	r3, #132	; 0x84
   11f1e:	4a36      	ldr	r2, [pc, #216]	; (11ff8 <Timer::Initialize(unsigned long, void (*)(), long)+0x114>)
   11f20:	4936      	ldr	r1, [pc, #216]	; (11ffc <Timer::Initialize(unsigned long, void (*)(), long)+0x118>)
   11f22:	4837      	ldr	r0, [pc, #220]	; (12000 <Timer::Initialize(unsigned long, void (*)(), long)+0x11c>)
   11f24:	f004 f8b2 	bl	1608c <printf>
   11f28:	4836      	ldr	r0, [pc, #216]	; (12004 <Timer::Initialize(unsigned long, void (*)(), long)+0x120>)
   11f2a:	f001 fae1 	bl	134f0 <puts>
   11f2e:	2100      	movs	r1, #0
   11f30:	2001      	movs	r0, #1
   11f32:	f7ff f875 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   11f36:	e7fe      	b.n	11f36 <Timer::Initialize(unsigned long, void (*)(), long)+0x52>
        frequency != 0,
        "Cannot have zero ticks per microsecond, please choose 1 or more.");
    // Set Prescale register for Prescale Counter to milliseconds
    uint32_t prescaler = GetPeripheralFrequency() / frequency;
   11f38:	9b03      	ldr	r3, [sp, #12]
   11f3a:	1d1a      	adds	r2, r3, #4
   11f3c:	9b03      	ldr	r3, [sp, #12]
   11f3e:	685b      	ldr	r3, [r3, #4]
   11f40:	3310      	adds	r3, #16
   11f42:	681b      	ldr	r3, [r3, #0]
   11f44:	4610      	mov	r0, r2
   11f46:	4798      	blx	r3
   11f48:	4602      	mov	r2, r0
   11f4a:	9b02      	ldr	r3, [sp, #8]
   11f4c:	fbb2 f3f3 	udiv	r3, r2, r3
   11f50:	9305      	str	r3, [sp, #20]
    tim_register[channel_]->PR &= ~(kClear << 1);
   11f52:	9b03      	ldr	r3, [sp, #12]
   11f54:	7a1b      	ldrb	r3, [r3, #8]
   11f56:	461a      	mov	r2, r3
   11f58:	4b2b      	ldr	r3, [pc, #172]	; (12008 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11f5a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11f5e:	68da      	ldr	r2, [r3, #12]
   11f60:	9b03      	ldr	r3, [sp, #12]
   11f62:	7a1b      	ldrb	r3, [r3, #8]
   11f64:	4619      	mov	r1, r3
   11f66:	4b28      	ldr	r3, [pc, #160]	; (12008 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11f68:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   11f6c:	f002 0201 	and.w	r2, r2, #1
   11f70:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->PR |= (prescaler << 1);
   11f72:	9b03      	ldr	r3, [sp, #12]
   11f74:	7a1b      	ldrb	r3, [r3, #8]
   11f76:	461a      	mov	r2, r3
   11f78:	4b23      	ldr	r3, [pc, #140]	; (12008 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11f7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11f7e:	68d9      	ldr	r1, [r3, #12]
   11f80:	9b05      	ldr	r3, [sp, #20]
   11f82:	005a      	lsls	r2, r3, #1
   11f84:	9b03      	ldr	r3, [sp, #12]
   11f86:	7a1b      	ldrb	r3, [r3, #8]
   11f88:	4618      	mov	r0, r3
   11f8a:	4b1f      	ldr	r3, [pc, #124]	; (12008 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11f8c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   11f90:	430a      	orrs	r2, r1
   11f92:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->TCR |= (1 << 0);
   11f94:	9b03      	ldr	r3, [sp, #12]
   11f96:	7a1b      	ldrb	r3, [r3, #8]
   11f98:	461a      	mov	r2, r3
   11f9a:	4b1b      	ldr	r3, [pc, #108]	; (12008 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11f9c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11fa0:	685a      	ldr	r2, [r3, #4]
   11fa2:	9b03      	ldr	r3, [sp, #12]
   11fa4:	7a1b      	ldrb	r3, [r3, #8]
   11fa6:	4619      	mov	r1, r3
   11fa8:	4b17      	ldr	r3, [pc, #92]	; (12008 <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11faa:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   11fae:	f042 0201 	orr.w	r2, r2, #1
   11fb2:	605a      	str	r2, [r3, #4]
    user_timer_isr[channel_] = isr;
   11fb4:	9b03      	ldr	r3, [sp, #12]
   11fb6:	7a1b      	ldrb	r3, [r3, #8]
   11fb8:	4619      	mov	r1, r3
   11fba:	4a14      	ldr	r2, [pc, #80]	; (1200c <Timer::Initialize(unsigned long, void (*)(), long)+0x128>)
   11fbc:	9b01      	ldr	r3, [sp, #4]
   11fbe:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    RegisterIsr(kTimerIrq[channel_], kTimerIsr[channel_], true, priority);
   11fc2:	9b03      	ldr	r3, [sp, #12]
   11fc4:	7a1b      	ldrb	r3, [r3, #8]
   11fc6:	461a      	mov	r2, r3
   11fc8:	4b11      	ldr	r3, [pc, #68]	; (12010 <Timer::Initialize(unsigned long, void (*)(), long)+0x12c>)
   11fca:	5698      	ldrsb	r0, [r3, r2]
   11fcc:	9b03      	ldr	r3, [sp, #12]
   11fce:	7a1b      	ldrb	r3, [r3, #8]
   11fd0:	461a      	mov	r2, r3
   11fd2:	4b10      	ldr	r3, [pc, #64]	; (12014 <Timer::Initialize(unsigned long, void (*)(), long)+0x130>)
   11fd4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11fd8:	9b00      	ldr	r3, [sp, #0]
   11fda:	2201      	movs	r2, #1
   11fdc:	f001 f964 	bl	132a8 <RegisterIsr(IRQn, void (*)(), bool, long)>
   11fe0:	4623      	mov	r3, r4
   11fe2:	4619      	mov	r1, r3
   11fe4:	4802      	ldr	r0, [pc, #8]	; (11ff0 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   11fe6:	f001 fac7 	bl	13578 <__cyg_profile_func_exit>
  }
   11fea:	bf00      	nop
   11fec:	b006      	add	sp, #24
   11fee:	bd10      	pop	{r4, pc}
   11ff0:	00011ee5 	.word	0x00011ee5
   11ff4:	00019970 	.word	0x00019970
   11ff8:	00019c10 	.word	0x00019c10
   11ffc:	00019994 	.word	0x00019994
   12000:	000197d8 	.word	0x000197d8
   12004:	000194e4 	.word	0x000194e4
   12008:	10000078 	.word	0x10000078
   1200c:	1000041c 	.word	0x1000041c
   12010:	00019980 	.word	0x00019980
   12014:	00019984 	.word	0x00019984

00012018 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>:
constexpr Type Value(Enum enum_type_value)
   12018:	b530      	push	{r4, r5, lr}
   1201a:	b083      	sub	sp, #12
   1201c:	4675      	mov	r5, lr
   1201e:	4603      	mov	r3, r0
   12020:	f88d 3007 	strb.w	r3, [sp, #7]
   12024:	462b      	mov	r3, r5
   12026:	4619      	mov	r1, r3
   12028:	4806      	ldr	r0, [pc, #24]	; (12044 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   1202a:	f001 fa91 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   1202e:	f89d 4007 	ldrb.w	r4, [sp, #7]
   12032:	462b      	mov	r3, r5
   12034:	4619      	mov	r1, r3
   12036:	4803      	ldr	r0, [pc, #12]	; (12044 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   12038:	f001 fa9e 	bl	13578 <__cyg_profile_func_exit>
   1203c:	4623      	mov	r3, r4
}
   1203e:	4618      	mov	r0, r3
   12040:	b003      	add	sp, #12
   12042:	bd30      	pop	{r4, r5, pc}
   12044:	00012019 	.word	0x00012019

00012048 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)>:
  ///
  /// @param ticks the count of the timer register (TC) to have an ISR fire
  /// @param condition the condition for which a timer interrupt will occur
  /// @param match_register which match register (from 0 to 3) should be used
  ///                       for holding the ticks for the condition.
  void SetTimer(uint32_t ticks, TimerIsrCondition condition,
   12048:	b570      	push	{r4, r5, r6, lr}
   1204a:	b086      	sub	sp, #24
   1204c:	4676      	mov	r6, lr
   1204e:	9003      	str	r0, [sp, #12]
   12050:	9102      	str	r1, [sp, #8]
   12052:	4611      	mov	r1, r2
   12054:	461a      	mov	r2, r3
   12056:	460b      	mov	r3, r1
   12058:	f88d 3007 	strb.w	r3, [sp, #7]
   1205c:	4613      	mov	r3, r2
   1205e:	f88d 3006 	strb.w	r3, [sp, #6]
   12062:	4633      	mov	r3, r6
   12064:	4619      	mov	r1, r3
   12066:	4832      	ldr	r0, [pc, #200]	; (12130 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   12068:	f001 fa72 	bl	13550 <__cyg_profile_func_enter>
                MatchControlRegister match_register = kMat0) override final
  {
    static constexpr uint8_t kClearMode = 0b0111;

    uint8_t match_value = util::Value(match_register);
   1206c:	f89d 3006 	ldrb.w	r3, [sp, #6]
   12070:	4618      	mov	r0, r3
   12072:	f7ff ffd1 	bl	12018 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>
   12076:	4603      	mov	r3, r0
   12078:	f88d 3017 	strb.w	r3, [sp, #23]
    tim_register[channel_]->MCR &= ~(kClearMode << match_value);
   1207c:	9b03      	ldr	r3, [sp, #12]
   1207e:	7a1b      	ldrb	r3, [r3, #8]
   12080:	461a      	mov	r2, r3
   12082:	4b2c      	ldr	r3, [pc, #176]	; (12134 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   12084:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12088:	695a      	ldr	r2, [r3, #20]
   1208a:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1208e:	2107      	movs	r1, #7
   12090:	fa01 f303 	lsl.w	r3, r1, r3
   12094:	43db      	mvns	r3, r3
   12096:	4619      	mov	r1, r3
   12098:	9b03      	ldr	r3, [sp, #12]
   1209a:	7a1b      	ldrb	r3, [r3, #8]
   1209c:	4618      	mov	r0, r3
   1209e:	4b25      	ldr	r3, [pc, #148]	; (12134 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   120a0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   120a4:	400a      	ands	r2, r1
   120a6:	615a      	str	r2, [r3, #20]
    tim_register[channel_]->MCR |= condition << match_value;
   120a8:	9b03      	ldr	r3, [sp, #12]
   120aa:	7a1b      	ldrb	r3, [r3, #8]
   120ac:	461a      	mov	r2, r3
   120ae:	4b21      	ldr	r3, [pc, #132]	; (12134 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   120b0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   120b4:	695a      	ldr	r2, [r3, #20]
   120b6:	f89d 1007 	ldrb.w	r1, [sp, #7]
   120ba:	f89d 3017 	ldrb.w	r3, [sp, #23]
   120be:	fa01 f303 	lsl.w	r3, r1, r3
   120c2:	4619      	mov	r1, r3
   120c4:	9b03      	ldr	r3, [sp, #12]
   120c6:	7a1b      	ldrb	r3, [r3, #8]
   120c8:	4618      	mov	r0, r3
   120ca:	4b1a      	ldr	r3, [pc, #104]	; (12134 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   120cc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   120d0:	430a      	orrs	r2, r1
   120d2:	615a      	str	r2, [r3, #20]
    *match[channel_][match_value / 3] |= (((ticks / 2)) << 0);
   120d4:	9b03      	ldr	r3, [sp, #12]
   120d6:	7a1b      	ldrb	r3, [r3, #8]
   120d8:	4618      	mov	r0, r3
   120da:	f89d 3017 	ldrb.w	r3, [sp, #23]
   120de:	4a16      	ldr	r2, [pc, #88]	; (12138 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   120e0:	fba2 2303 	umull	r2, r3, r2, r3
   120e4:	085b      	lsrs	r3, r3, #1
   120e6:	b2db      	uxtb	r3, r3
   120e8:	4619      	mov	r1, r3
   120ea:	4a14      	ldr	r2, [pc, #80]	; (1213c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   120ec:	0083      	lsls	r3, r0, #2
   120ee:	440b      	add	r3, r1
   120f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   120f4:	6819      	ldr	r1, [r3, #0]
   120f6:	9b02      	ldr	r3, [sp, #8]
   120f8:	085a      	lsrs	r2, r3, #1
   120fa:	9b03      	ldr	r3, [sp, #12]
   120fc:	7a1b      	ldrb	r3, [r3, #8]
   120fe:	461d      	mov	r5, r3
   12100:	f89d 3017 	ldrb.w	r3, [sp, #23]
   12104:	480c      	ldr	r0, [pc, #48]	; (12138 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   12106:	fba0 0303 	umull	r0, r3, r0, r3
   1210a:	085b      	lsrs	r3, r3, #1
   1210c:	b2db      	uxtb	r3, r3
   1210e:	461c      	mov	r4, r3
   12110:	480a      	ldr	r0, [pc, #40]	; (1213c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   12112:	00ab      	lsls	r3, r5, #2
   12114:	4423      	add	r3, r4
   12116:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   1211a:	430a      	orrs	r2, r1
   1211c:	601a      	str	r2, [r3, #0]
   1211e:	4633      	mov	r3, r6
   12120:	4619      	mov	r1, r3
   12122:	4803      	ldr	r0, [pc, #12]	; (12130 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   12124:	f001 fa28 	bl	13578 <__cyg_profile_func_exit>
  }
   12128:	bf00      	nop
   1212a:	b006      	add	sp, #24
   1212c:	bd70      	pop	{r4, r5, r6, pc}
   1212e:	bf00      	nop
   12130:	00012049 	.word	0x00012049
   12134:	10000078 	.word	0x10000078
   12138:	aaaaaaab 	.word	0xaaaaaaab
   1213c:	100003dc 	.word	0x100003dc

00012140 <Timer::GetTimer()>:

  [[gnu::always_inline]] uint32_t GetTimer() override final {
   12140:	b530      	push	{r4, r5, lr}
   12142:	b083      	sub	sp, #12
   12144:	4675      	mov	r5, lr
   12146:	9001      	str	r0, [sp, #4]
   12148:	462b      	mov	r3, r5
   1214a:	4619      	mov	r1, r3
   1214c:	4809      	ldr	r0, [pc, #36]	; (12174 <Timer::GetTimer()+0x34>)
   1214e:	f001 f9ff 	bl	13550 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   12152:	9b01      	ldr	r3, [sp, #4]
   12154:	7a1b      	ldrb	r3, [r3, #8]
   12156:	461a      	mov	r2, r3
   12158:	4b07      	ldr	r3, [pc, #28]	; (12178 <Timer::GetTimer()+0x38>)
   1215a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1215e:	689c      	ldr	r4, [r3, #8]
   12160:	462b      	mov	r3, r5
   12162:	4619      	mov	r1, r3
   12164:	4803      	ldr	r0, [pc, #12]	; (12174 <Timer::GetTimer()+0x34>)
   12166:	f001 fa07 	bl	13578 <__cyg_profile_func_exit>
   1216a:	4623      	mov	r3, r4
  }
   1216c:	4618      	mov	r0, r3
   1216e:	b003      	add	sp, #12
   12170:	bd30      	pop	{r4, r5, pc}
   12172:	bf00      	nop
   12174:	00012141 	.word	0x00012141
   12178:	10000078 	.word	0x10000078

0001217c <Uart::SetBaudRate(unsigned long)>:
  constexpr Uart(Channels mode, PinInterface * tx_pin, PinInterface * rx_pin)
      : channel_(static_cast<uint8_t>(mode)), tx_(tx_pin), rx_(rx_pin)
  {
  }

  void SetBaudRate(uint32_t baud_rate) override
   1217c:	b510      	push	{r4, lr}
   1217e:	b088      	sub	sp, #32
   12180:	4674      	mov	r4, lr
   12182:	9001      	str	r0, [sp, #4]
   12184:	9100      	str	r1, [sp, #0]
   12186:	4623      	mov	r3, r4
   12188:	4619      	mov	r1, r3
   1218a:	482d      	ldr	r0, [pc, #180]	; (12240 <Uart::SetBaudRate(unsigned long)+0xc4>)
   1218c:	f001 f9e0 	bl	13550 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kDlabBit = (1 << 7);
   12190:	2380      	movs	r3, #128	; 0x80
   12192:	f88d 301f 	strb.w	r3, [sp, #31]
    float baudrate             = static_cast<float>(baud_rate);
   12196:	9b00      	ldr	r3, [sp, #0]
   12198:	ee07 3a90 	vmov	s15, r3
   1219c:	eef8 7a67 	vcvt.f32.u32	s15, s15
   121a0:	edcd 7a06 	vstr	s15, [sp, #24]
    UartCalibration_t dividers = GenerateUartCalibration(baudrate);
   121a4:	ab02      	add	r3, sp, #8
   121a6:	ed9d 0a06 	vldr	s0, [sp, #24]
   121aa:	9901      	ldr	r1, [sp, #4]
   121ac:	4618      	mov	r0, r3
   121ae:	f000 fb2d 	bl	1280c <Uart::GenerateUartCalibration(float)>

    uint8_t dlm = static_cast<uint8_t>((dividers.divide_latch >> 8) & 0xFF);
   121b2:	9b02      	ldr	r3, [sp, #8]
   121b4:	0a1b      	lsrs	r3, r3, #8
   121b6:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8_t dll = static_cast<uint8_t>(dividers.divide_latch & 0xFF);
   121ba:	9b02      	ldr	r3, [sp, #8]
   121bc:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   121c0:	9b04      	ldr	r3, [sp, #16]
   121c2:	b2db      	uxtb	r3, r3
   121c4:	011b      	lsls	r3, r3, #4
   121c6:	b2da      	uxtb	r2, r3
                                       (dividers.divide_add & 0xF));
   121c8:	9b03      	ldr	r3, [sp, #12]
   121ca:	b2db      	uxtb	r3, r3
   121cc:	f003 030f 	and.w	r3, r3, #15
   121d0:	b2db      	uxtb	r3, r3
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   121d2:	4313      	orrs	r3, r2
   121d4:	f88d 3015 	strb.w	r3, [sp, #21]

    // Set baud rate
    uart[channel_]->LCR = kDlabBit;
   121d8:	9b01      	ldr	r3, [sp, #4]
   121da:	7a1b      	ldrb	r3, [r3, #8]
   121dc:	461a      	mov	r2, r3
   121de:	4b19      	ldr	r3, [pc, #100]	; (12244 <Uart::SetBaudRate(unsigned long)+0xc8>)
   121e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   121e4:	2280      	movs	r2, #128	; 0x80
   121e6:	731a      	strb	r2, [r3, #12]
    uart[channel_]->DLM = dlm;
   121e8:	9b01      	ldr	r3, [sp, #4]
   121ea:	7a1b      	ldrb	r3, [r3, #8]
   121ec:	461a      	mov	r2, r3
   121ee:	4b15      	ldr	r3, [pc, #84]	; (12244 <Uart::SetBaudRate(unsigned long)+0xc8>)
   121f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   121f4:	f89d 2017 	ldrb.w	r2, [sp, #23]
   121f8:	711a      	strb	r2, [r3, #4]
    uart[channel_]->DLL = dll;
   121fa:	9b01      	ldr	r3, [sp, #4]
   121fc:	7a1b      	ldrb	r3, [r3, #8]
   121fe:	461a      	mov	r2, r3
   12200:	4b10      	ldr	r3, [pc, #64]	; (12244 <Uart::SetBaudRate(unsigned long)+0xc8>)
   12202:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12206:	f89d 2016 	ldrb.w	r2, [sp, #22]
   1220a:	701a      	strb	r2, [r3, #0]
    uart[channel_]->FDR = fdr;
   1220c:	9b01      	ldr	r3, [sp, #4]
   1220e:	7a1b      	ldrb	r3, [r3, #8]
   12210:	461a      	mov	r2, r3
   12212:	4b0c      	ldr	r3, [pc, #48]	; (12244 <Uart::SetBaudRate(unsigned long)+0xc8>)
   12214:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12218:	f89d 2015 	ldrb.w	r2, [sp, #21]
   1221c:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    uart[channel_]->LCR = kStandardUart;
   12220:	9b01      	ldr	r3, [sp, #4]
   12222:	7a1b      	ldrb	r3, [r3, #8]
   12224:	461a      	mov	r2, r3
   12226:	4b07      	ldr	r3, [pc, #28]	; (12244 <Uart::SetBaudRate(unsigned long)+0xc8>)
   12228:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1222c:	2203      	movs	r2, #3
   1222e:	731a      	strb	r2, [r3, #12]
   12230:	4623      	mov	r3, r4
   12232:	4619      	mov	r1, r3
   12234:	4802      	ldr	r0, [pc, #8]	; (12240 <Uart::SetBaudRate(unsigned long)+0xc4>)
   12236:	f001 f99f 	bl	13578 <__cyg_profile_func_exit>
  }
   1223a:	bf00      	nop
   1223c:	b008      	add	sp, #32
   1223e:	bd10      	pop	{r4, pc}
   12240:	0001217d 	.word	0x0001217d
   12244:	10000088 	.word	0x10000088

00012248 <Uart::Initialize(unsigned long)>:

  bool Initialize(uint32_t baud_rate) override
   12248:	b530      	push	{r4, r5, lr}
   1224a:	b085      	sub	sp, #20
   1224c:	4675      	mov	r5, lr
   1224e:	9001      	str	r0, [sp, #4]
   12250:	9100      	str	r1, [sp, #0]
   12252:	462b      	mov	r3, r5
   12254:	4619      	mov	r1, r3
   12256:	4830      	ldr	r0, [pc, #192]	; (12318 <Uart::Initialize(unsigned long)+0xd0>)
   12258:	f001 f97a 	bl	13550 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kFIFOEnableAndReset = 0b111;
   1225c:	2307      	movs	r3, #7
   1225e:	f88d 300f 	strb.w	r3, [sp, #15]
    // Powering the port
    PowerUpPeripheral(kPowerbit[channel_]);
   12262:	9b01      	ldr	r3, [sp, #4]
   12264:	1d18      	adds	r0, r3, #4
   12266:	9b01      	ldr	r3, [sp, #4]
   12268:	685b      	ldr	r3, [r3, #4]
   1226a:	3314      	adds	r3, #20
   1226c:	681b      	ldr	r3, [r3, #0]
   1226e:	9a01      	ldr	r2, [sp, #4]
   12270:	7a12      	ldrb	r2, [r2, #8]
   12272:	0092      	lsls	r2, r2, #2
   12274:	4929      	ldr	r1, [pc, #164]	; (1231c <Uart::Initialize(unsigned long)+0xd4>)
   12276:	440a      	add	r2, r1
   12278:	4611      	mov	r1, r2
   1227a:	4798      	blx	r3
    // Setting the pin functions and modes
    rx_->SetPinFunction(kRxUartPortFunction[channel_]);
   1227c:	9b01      	ldr	r3, [sp, #4]
   1227e:	6918      	ldr	r0, [r3, #16]
   12280:	9b01      	ldr	r3, [sp, #4]
   12282:	691b      	ldr	r3, [r3, #16]
   12284:	681b      	ldr	r3, [r3, #0]
   12286:	681b      	ldr	r3, [r3, #0]
   12288:	9a01      	ldr	r2, [sp, #4]
   1228a:	7a12      	ldrb	r2, [r2, #8]
   1228c:	4611      	mov	r1, r2
   1228e:	4a24      	ldr	r2, [pc, #144]	; (12320 <Uart::Initialize(unsigned long)+0xd8>)
   12290:	5c52      	ldrb	r2, [r2, r1]
   12292:	4611      	mov	r1, r2
   12294:	4798      	blx	r3
    tx_->SetPinFunction(kTxUartPortFunction[channel_]);
   12296:	9b01      	ldr	r3, [sp, #4]
   12298:	68d8      	ldr	r0, [r3, #12]
   1229a:	9b01      	ldr	r3, [sp, #4]
   1229c:	68db      	ldr	r3, [r3, #12]
   1229e:	681b      	ldr	r3, [r3, #0]
   122a0:	681b      	ldr	r3, [r3, #0]
   122a2:	9a01      	ldr	r2, [sp, #4]
   122a4:	7a12      	ldrb	r2, [r2, #8]
   122a6:	4611      	mov	r1, r2
   122a8:	4a1e      	ldr	r2, [pc, #120]	; (12324 <Uart::Initialize(unsigned long)+0xdc>)
   122aa:	5c52      	ldrb	r2, [r2, r1]
   122ac:	4611      	mov	r1, r2
   122ae:	4798      	blx	r3
    rx_->SetMode(PinInterface::Mode::kPullUp);
   122b0:	9b01      	ldr	r3, [sp, #4]
   122b2:	691a      	ldr	r2, [r3, #16]
   122b4:	9b01      	ldr	r3, [sp, #4]
   122b6:	691b      	ldr	r3, [r3, #16]
   122b8:	681b      	ldr	r3, [r3, #0]
   122ba:	3304      	adds	r3, #4
   122bc:	681b      	ldr	r3, [r3, #0]
   122be:	2102      	movs	r1, #2
   122c0:	4610      	mov	r0, r2
   122c2:	4798      	blx	r3
    tx_->SetMode(PinInterface::Mode::kPullUp);
   122c4:	9b01      	ldr	r3, [sp, #4]
   122c6:	68da      	ldr	r2, [r3, #12]
   122c8:	9b01      	ldr	r3, [sp, #4]
   122ca:	68db      	ldr	r3, [r3, #12]
   122cc:	681b      	ldr	r3, [r3, #0]
   122ce:	3304      	adds	r3, #4
   122d0:	681b      	ldr	r3, [r3, #0]
   122d2:	2102      	movs	r1, #2
   122d4:	4610      	mov	r0, r2
   122d6:	4798      	blx	r3
    // Baud rate setting
    SetBaudRate(baud_rate);
   122d8:	9900      	ldr	r1, [sp, #0]
   122da:	9801      	ldr	r0, [sp, #4]
   122dc:	f7ff ff4e 	bl	1217c <Uart::SetBaudRate(unsigned long)>
    uart[channel_]->FCR |= kFIFOEnableAndReset;
   122e0:	9b01      	ldr	r3, [sp, #4]
   122e2:	7a1b      	ldrb	r3, [r3, #8]
   122e4:	461a      	mov	r2, r3
   122e6:	4b10      	ldr	r3, [pc, #64]	; (12328 <Uart::Initialize(unsigned long)+0xe0>)
   122e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   122ec:	7a1b      	ldrb	r3, [r3, #8]
   122ee:	b2da      	uxtb	r2, r3
   122f0:	9b01      	ldr	r3, [sp, #4]
   122f2:	7a1b      	ldrb	r3, [r3, #8]
   122f4:	4619      	mov	r1, r3
   122f6:	4b0c      	ldr	r3, [pc, #48]	; (12328 <Uart::Initialize(unsigned long)+0xe0>)
   122f8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   122fc:	f042 0207 	orr.w	r2, r2, #7
   12300:	b2d2      	uxtb	r2, r2
   12302:	721a      	strb	r2, [r3, #8]
    return true;
   12304:	2401      	movs	r4, #1
   12306:	462b      	mov	r3, r5
   12308:	4619      	mov	r1, r3
   1230a:	4803      	ldr	r0, [pc, #12]	; (12318 <Uart::Initialize(unsigned long)+0xd0>)
   1230c:	f001 f934 	bl	13578 <__cyg_profile_func_exit>
   12310:	4623      	mov	r3, r4
  }
   12312:	4618      	mov	r0, r3
   12314:	b005      	add	sp, #20
   12316:	bd30      	pop	{r4, r5, pc}
   12318:	00012249 	.word	0x00012249
   1231c:	000199a8 	.word	0x000199a8
   12320:	000199a4 	.word	0x000199a4
   12324:	000199a0 	.word	0x000199a0
   12328:	10000088 	.word	0x10000088

0001232c <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>:

  void Send(uint8_t data) override
  {
    uart[channel_]->THR              = data;
    auto wait_for_transfer_to_finish = [this]() -> bool {
   1232c:	b530      	push	{r4, r5, lr}
   1232e:	b083      	sub	sp, #12
   12330:	4675      	mov	r5, lr
   12332:	9001      	str	r0, [sp, #4]
   12334:	462b      	mov	r3, r5
   12336:	4619      	mov	r1, r3
   12338:	480d      	ldr	r0, [pc, #52]	; (12370 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   1233a:	f001 f909 	bl	13550 <__cyg_profile_func_enter>
   1233e:	9b01      	ldr	r3, [sp, #4]
   12340:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 5));
   12342:	7a1b      	ldrb	r3, [r3, #8]
   12344:	461a      	mov	r2, r3
   12346:	4b0b      	ldr	r3, [pc, #44]	; (12374 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x48>)
   12348:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1234c:	7d1b      	ldrb	r3, [r3, #20]
   1234e:	b2db      	uxtb	r3, r3
   12350:	f003 0320 	and.w	r3, r3, #32
   12354:	2b00      	cmp	r3, #0
   12356:	bf14      	ite	ne
   12358:	2301      	movne	r3, #1
   1235a:	2300      	moveq	r3, #0
   1235c:	b2dc      	uxtb	r4, r3
   1235e:	462b      	mov	r3, r5
   12360:	4619      	mov	r1, r3
   12362:	4803      	ldr	r0, [pc, #12]	; (12370 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   12364:	f001 f908 	bl	13578 <__cyg_profile_func_exit>
   12368:	4623      	mov	r3, r4
    };
   1236a:	4618      	mov	r0, r3
   1236c:	b003      	add	sp, #12
   1236e:	bd30      	pop	{r4, r5, pc}
   12370:	0001232d 	.word	0x0001232d
   12374:	10000088 	.word	0x10000088

00012378 <Uart::Send(unsigned char)>:
  void Send(uint8_t data) override
   12378:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   1237c:	b08a      	sub	sp, #40	; 0x28
   1237e:	4675      	mov	r5, lr
   12380:	9001      	str	r0, [sp, #4]
   12382:	460b      	mov	r3, r1
   12384:	f88d 3003 	strb.w	r3, [sp, #3]
   12388:	462b      	mov	r3, r5
   1238a:	4619      	mov	r1, r3
   1238c:	4831      	ldr	r0, [pc, #196]	; (12454 <Uart::Send(unsigned char)+0xdc>)
   1238e:	f001 f8df 	bl	13550 <__cyg_profile_func_enter>
    uart[channel_]->THR              = data;
   12392:	9b01      	ldr	r3, [sp, #4]
   12394:	7a1b      	ldrb	r3, [r3, #8]
   12396:	461a      	mov	r2, r3
   12398:	4b2f      	ldr	r3, [pc, #188]	; (12458 <Uart::Send(unsigned char)+0xe0>)
   1239a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1239e:	f89d 2003 	ldrb.w	r2, [sp, #3]
   123a2:	701a      	strb	r2, [r3, #0]
    };
   123a4:	9b01      	ldr	r3, [sp, #4]
   123a6:	9304      	str	r3, [sp, #16]
   123a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   123ac:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   123b0:	e9cd 3408 	strd	r3, r4, [sp, #32]
   123b4:	9b04      	ldr	r3, [sp, #16]
   123b6:	9303      	str	r3, [sp, #12]
   123b8:	462b      	mov	r3, r5
   123ba:	4619      	mov	r1, r3
   123bc:	4827      	ldr	r0, [pc, #156]	; (1245c <Uart::Send(unsigned char)+0xe4>)
   123be:	f001 f8c7 	bl	13550 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   123c2:	f04f 0300 	mov.w	r3, #0
   123c6:	f04f 0400 	mov.w	r4, #0
   123ca:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   123ce:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   123d2:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   123d6:	bf08      	it	eq
   123d8:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   123dc:	d106      	bne.n	123ec <Uart::Send(unsigned char)+0x74>
    timeout_time = kMaxWait;
   123de:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   123e2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   123e6:	e9cd 3406 	strd	r3, r4, [sp, #24]
   123ea:	e00b      	b.n	12404 <Uart::Send(unsigned char)+0x8c>
    timeout_time = Milliseconds() + timeout;
   123ec:	f7fe fa52 	bl	10894 <Milliseconds()>
   123f0:	460a      	mov	r2, r1
   123f2:	4601      	mov	r1, r0
   123f4:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   123f8:	eb13 0b01 	adds.w	fp, r3, r1
   123fc:	eb44 0c02 	adc.w	ip, r4, r2
   12400:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   12404:	2301      	movs	r3, #1
   12406:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   12408:	f7fe fa44 	bl	10894 <Milliseconds()>
   1240c:	460a      	mov	r2, r1
   1240e:	4601      	mov	r1, r0
   12410:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   12414:	42a2      	cmp	r2, r4
   12416:	bf08      	it	eq
   12418:	4299      	cmpeq	r1, r3
   1241a:	bf34      	ite	cc
   1241c:	2301      	movcc	r3, #1
   1241e:	2300      	movcs	r3, #0
   12420:	b2db      	uxtb	r3, r3
   12422:	2b00      	cmp	r3, #0
   12424:	d008      	beq.n	12438 <Uart::Send(unsigned char)+0xc0>
    if (is_done())
   12426:	ab03      	add	r3, sp, #12
   12428:	4618      	mov	r0, r3
   1242a:	f7ff ff7f 	bl	1232c <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   1242e:	4603      	mov	r3, r0
   12430:	2b00      	cmp	r3, #0
   12432:	d0e9      	beq.n	12408 <Uart::Send(unsigned char)+0x90>
      status = Status::kSuccess;
   12434:	2300      	movs	r3, #0
   12436:	9305      	str	r3, [sp, #20]
   12438:	462b      	mov	r3, r5
   1243a:	4619      	mov	r1, r3
   1243c:	4807      	ldr	r0, [pc, #28]	; (1245c <Uart::Send(unsigned char)+0xe4>)
   1243e:	f001 f89b 	bl	13578 <__cyg_profile_func_exit>
   12442:	462b      	mov	r3, r5
   12444:	4619      	mov	r1, r3
   12446:	4803      	ldr	r0, [pc, #12]	; (12454 <Uart::Send(unsigned char)+0xdc>)
   12448:	f001 f896 	bl	13578 <__cyg_profile_func_exit>
    Wait(kMaxWait, wait_for_transfer_to_finish);
  }
   1244c:	bf00      	nop
   1244e:	b00a      	add	sp, #40	; 0x28
   12450:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   12454:	00012379 	.word	0x00012379
   12458:	10000088 	.word	0x10000088
   1245c:	00012d01 	.word	0x00012d01

00012460 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>:

  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
  {
    uint8_t receiver   = '\xFF';
    auto byte_recieved = [this]() -> bool {
   12460:	b530      	push	{r4, r5, lr}
   12462:	b083      	sub	sp, #12
   12464:	4675      	mov	r5, lr
   12466:	9001      	str	r0, [sp, #4]
   12468:	462b      	mov	r3, r5
   1246a:	4619      	mov	r1, r3
   1246c:	480d      	ldr	r0, [pc, #52]	; (124a4 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   1246e:	f001 f86f 	bl	13550 <__cyg_profile_func_enter>
   12472:	9b01      	ldr	r3, [sp, #4]
   12474:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 0));
   12476:	7a1b      	ldrb	r3, [r3, #8]
   12478:	461a      	mov	r2, r3
   1247a:	4b0b      	ldr	r3, [pc, #44]	; (124a8 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x48>)
   1247c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12480:	7d1b      	ldrb	r3, [r3, #20]
   12482:	b2db      	uxtb	r3, r3
   12484:	f003 0301 	and.w	r3, r3, #1
   12488:	2b00      	cmp	r3, #0
   1248a:	bf14      	ite	ne
   1248c:	2301      	movne	r3, #1
   1248e:	2300      	moveq	r3, #0
   12490:	b2dc      	uxtb	r4, r3
   12492:	462b      	mov	r3, r5
   12494:	4619      	mov	r1, r3
   12496:	4803      	ldr	r0, [pc, #12]	; (124a4 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   12498:	f001 f86e 	bl	13578 <__cyg_profile_func_exit>
   1249c:	4623      	mov	r3, r4
    };
   1249e:	4618      	mov	r0, r3
   124a0:	b003      	add	sp, #12
   124a2:	bd30      	pop	{r4, r5, pc}
   124a4:	00012461 	.word	0x00012461
   124a8:	10000088 	.word	0x10000088

000124ac <Uart::Receive(unsigned long)>:
  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
   124ac:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   124b0:	b08c      	sub	sp, #48	; 0x30
   124b2:	4675      	mov	r5, lr
   124b4:	9001      	str	r0, [sp, #4]
   124b6:	9100      	str	r1, [sp, #0]
   124b8:	462b      	mov	r3, r5
   124ba:	4619      	mov	r1, r3
   124bc:	4836      	ldr	r0, [pc, #216]	; (12598 <Uart::Receive(unsigned long)+0xec>)
   124be:	f001 f847 	bl	13550 <__cyg_profile_func_enter>
    uint8_t receiver   = '\xFF';
   124c2:	23ff      	movs	r3, #255	; 0xff
   124c4:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    };
   124c8:	9b01      	ldr	r3, [sp, #4]
   124ca:	9304      	str	r3, [sp, #16]

    Status status = Wait(timeout, byte_recieved);
   124cc:	9b00      	ldr	r3, [sp, #0]
   124ce:	f04f 0400 	mov.w	r4, #0
   124d2:	e9cd 3408 	strd	r3, r4, [sp, #32]
   124d6:	9b04      	ldr	r3, [sp, #16]
   124d8:	9303      	str	r3, [sp, #12]
   124da:	462b      	mov	r3, r5
   124dc:	4619      	mov	r1, r3
   124de:	482f      	ldr	r0, [pc, #188]	; (1259c <Uart::Receive(unsigned long)+0xf0>)
   124e0:	f001 f836 	bl	13550 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   124e4:	f04f 0300 	mov.w	r3, #0
   124e8:	f04f 0400 	mov.w	r4, #0
   124ec:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   124f0:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   124f4:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   124f8:	bf08      	it	eq
   124fa:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   124fe:	d106      	bne.n	1250e <Uart::Receive(unsigned long)+0x62>
    timeout_time = kMaxWait;
   12500:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12504:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   12508:	e9cd 3406 	strd	r3, r4, [sp, #24]
   1250c:	e00b      	b.n	12526 <Uart::Receive(unsigned long)+0x7a>
    timeout_time = Milliseconds() + timeout;
   1250e:	f7fe f9c1 	bl	10894 <Milliseconds()>
   12512:	460a      	mov	r2, r1
   12514:	4601      	mov	r1, r0
   12516:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   1251a:	eb13 0b01 	adds.w	fp, r3, r1
   1251e:	eb44 0c02 	adc.w	ip, r4, r2
   12522:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   12526:	2301      	movs	r3, #1
   12528:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   1252a:	f7fe f9b3 	bl	10894 <Milliseconds()>
   1252e:	460a      	mov	r2, r1
   12530:	4601      	mov	r1, r0
   12532:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   12536:	42a2      	cmp	r2, r4
   12538:	bf08      	it	eq
   1253a:	4299      	cmpeq	r1, r3
   1253c:	bf34      	ite	cc
   1253e:	2301      	movcc	r3, #1
   12540:	2300      	movcs	r3, #0
   12542:	b2db      	uxtb	r3, r3
   12544:	2b00      	cmp	r3, #0
   12546:	d008      	beq.n	1255a <Uart::Receive(unsigned long)+0xae>
    if (is_done())
   12548:	ab03      	add	r3, sp, #12
   1254a:	4618      	mov	r0, r3
   1254c:	f7ff ff88 	bl	12460 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   12550:	4603      	mov	r3, r0
   12552:	2b00      	cmp	r3, #0
   12554:	d0e9      	beq.n	1252a <Uart::Receive(unsigned long)+0x7e>
      status = Status::kSuccess;
   12556:	2300      	movs	r3, #0
   12558:	9305      	str	r3, [sp, #20]
  return status;
   1255a:	9c05      	ldr	r4, [sp, #20]
   1255c:	462b      	mov	r3, r5
   1255e:	4619      	mov	r1, r3
   12560:	480e      	ldr	r0, [pc, #56]	; (1259c <Uart::Receive(unsigned long)+0xf0>)
   12562:	f001 f809 	bl	13578 <__cyg_profile_func_exit>
   12566:	940a      	str	r4, [sp, #40]	; 0x28

    if (status == Status::kSuccess)
   12568:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1256a:	2b00      	cmp	r3, #0
   1256c:	d108      	bne.n	12580 <Uart::Receive(unsigned long)+0xd4>
    {
      receiver = static_cast<uint8_t>(uart[channel_]->RBR);
   1256e:	9b01      	ldr	r3, [sp, #4]
   12570:	7a1b      	ldrb	r3, [r3, #8]
   12572:	461a      	mov	r2, r3
   12574:	4b0a      	ldr	r3, [pc, #40]	; (125a0 <Uart::Receive(unsigned long)+0xf4>)
   12576:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1257a:	781b      	ldrb	r3, [r3, #0]
   1257c:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    }
    return receiver;
   12580:	f89d 402f 	ldrb.w	r4, [sp, #47]	; 0x2f
   12584:	462b      	mov	r3, r5
   12586:	4619      	mov	r1, r3
   12588:	4803      	ldr	r0, [pc, #12]	; (12598 <Uart::Receive(unsigned long)+0xec>)
   1258a:	f000 fff5 	bl	13578 <__cyg_profile_func_exit>
   1258e:	4623      	mov	r3, r4
  }
   12590:	4618      	mov	r0, r3
   12592:	b00c      	add	sp, #48	; 0x30
   12594:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   12598:	000124ad 	.word	0x000124ad
   1259c:	00012da9 	.word	0x00012da9
   125a0:	10000088 	.word	0x10000088

000125a4 <Uart::FindClosestFractional(float)>:

 private:
  UartCalibration_t FindClosestFractional(float decimal)
   125a4:	b510      	push	{r4, lr}
   125a6:	b08a      	sub	sp, #40	; 0x28
   125a8:	4674      	mov	r4, lr
   125aa:	9003      	str	r0, [sp, #12]
   125ac:	9102      	str	r1, [sp, #8]
   125ae:	ed8d 0a01 	vstr	s0, [sp, #4]
   125b2:	4623      	mov	r3, r4
   125b4:	4619      	mov	r1, r3
   125b6:	4838      	ldr	r0, [pc, #224]	; (12698 <Uart::FindClosestFractional(float)+0xf4>)
   125b8:	f000 ffca 	bl	13550 <__cyg_profile_func_enter>
  {
    UartCalibration_t result;
   125bc:	9b03      	ldr	r3, [sp, #12]
   125be:	2200      	movs	r2, #0
   125c0:	601a      	str	r2, [r3, #0]
   125c2:	9b03      	ldr	r3, [sp, #12]
   125c4:	2200      	movs	r2, #0
   125c6:	605a      	str	r2, [r3, #4]
   125c8:	9b03      	ldr	r3, [sp, #12]
   125ca:	2201      	movs	r2, #1
   125cc:	609a      	str	r2, [r3, #8]
    bool finished = false;
   125ce:	2300      	movs	r3, #0
   125d0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (int div = 0; div < 15 && !finished; div++)
   125d4:	2300      	movs	r3, #0
   125d6:	9308      	str	r3, [sp, #32]
   125d8:	9b08      	ldr	r3, [sp, #32]
   125da:	2b0e      	cmp	r3, #14
   125dc:	dc52      	bgt.n	12684 <Uart::FindClosestFractional(float)+0xe0>
   125de:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   125e2:	2b00      	cmp	r3, #0
   125e4:	d14e      	bne.n	12684 <Uart::FindClosestFractional(float)+0xe0>
    {
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   125e6:	9b08      	ldr	r3, [sp, #32]
   125e8:	3301      	adds	r3, #1
   125ea:	9307      	str	r3, [sp, #28]
   125ec:	9b07      	ldr	r3, [sp, #28]
   125ee:	2b0e      	cmp	r3, #14
   125f0:	dc44      	bgt.n	1267c <Uart::FindClosestFractional(float)+0xd8>
   125f2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   125f6:	2b00      	cmp	r3, #0
   125f8:	d140      	bne.n	1267c <Uart::FindClosestFractional(float)+0xd8>
      {
        float divf         = static_cast<float>(div);
   125fa:	9b08      	ldr	r3, [sp, #32]
   125fc:	ee07 3a90 	vmov	s15, r3
   12600:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12604:	edcd 7a06 	vstr	s15, [sp, #24]
        float mulf         = static_cast<float>(mul);
   12608:	9b07      	ldr	r3, [sp, #28]
   1260a:	ee07 3a90 	vmov	s15, r3
   1260e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12612:	edcd 7a05 	vstr	s15, [sp, #20]
        float test_decimal = 1.0f + divf / mulf;
   12616:	eddd 6a06 	vldr	s13, [sp, #24]
   1261a:	ed9d 7a05 	vldr	s14, [sp, #20]
   1261e:	eec6 7a87 	vdiv.f32	s15, s13, s14
   12622:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   12626:	ee77 7a87 	vadd.f32	s15, s15, s14
   1262a:	edcd 7a04 	vstr	s15, [sp, #16]
        if (decimal <= test_decimal + kThreshold &&
   1262e:	eddd 7a04 	vldr	s15, [sp, #16]
   12632:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 1269c <Uart::FindClosestFractional(float)+0xf8>
   12636:	ee77 7a87 	vadd.f32	s15, s15, s14
   1263a:	ed9d 7a01 	vldr	s14, [sp, #4]
   1263e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   12642:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12646:	d815      	bhi.n	12674 <Uart::FindClosestFractional(float)+0xd0>
            decimal >= test_decimal - kThreshold)
   12648:	eddd 7a04 	vldr	s15, [sp, #16]
   1264c:	ed9f 7a13 	vldr	s14, [pc, #76]	; 1269c <Uart::FindClosestFractional(float)+0xf8>
   12650:	ee77 7ac7 	vsub.f32	s15, s15, s14
        if (decimal <= test_decimal + kThreshold &&
   12654:	ed9d 7a01 	vldr	s14, [sp, #4]
   12658:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1265c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12660:	db08      	blt.n	12674 <Uart::FindClosestFractional(float)+0xd0>
        {
          result.divide_add = div;
   12662:	9a08      	ldr	r2, [sp, #32]
   12664:	9b03      	ldr	r3, [sp, #12]
   12666:	605a      	str	r2, [r3, #4]
          result.multiply   = mul;
   12668:	9a07      	ldr	r2, [sp, #28]
   1266a:	9b03      	ldr	r3, [sp, #12]
   1266c:	609a      	str	r2, [r3, #8]
          finished          = true;
   1266e:	2301      	movs	r3, #1
   12670:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   12674:	9b07      	ldr	r3, [sp, #28]
   12676:	3301      	adds	r3, #1
   12678:	9307      	str	r3, [sp, #28]
   1267a:	e7b7      	b.n	125ec <Uart::FindClosestFractional(float)+0x48>
    for (int div = 0; div < 15 && !finished; div++)
   1267c:	9b08      	ldr	r3, [sp, #32]
   1267e:	3301      	adds	r3, #1
   12680:	9308      	str	r3, [sp, #32]
   12682:	e7a9      	b.n	125d8 <Uart::FindClosestFractional(float)+0x34>
        }
      }
    }
    return result;
   12684:	bf00      	nop
   12686:	4623      	mov	r3, r4
   12688:	4619      	mov	r1, r3
   1268a:	4803      	ldr	r0, [pc, #12]	; (12698 <Uart::FindClosestFractional(float)+0xf4>)
   1268c:	f000 ff74 	bl	13578 <__cyg_profile_func_exit>
   12690:	bf00      	nop
  }
   12692:	9803      	ldr	r0, [sp, #12]
   12694:	b00a      	add	sp, #40	; 0x28
   12696:	bd10      	pop	{r4, pc}
   12698:	000125a5 	.word	0x000125a5
   1269c:	3d4ccccd 	.word	0x3d4ccccd

000126a0 <Uart::DividerEstimate(float, float)>:

  float DividerEstimate(float baud_rate, float fraction_estimate = 1)
   126a0:	b510      	push	{r4, lr}
   126a2:	ed2d 8b02 	vpush	{d8}
   126a6:	b086      	sub	sp, #24
   126a8:	4674      	mov	r4, lr
   126aa:	9003      	str	r0, [sp, #12]
   126ac:	ed8d 0a02 	vstr	s0, [sp, #8]
   126b0:	edcd 0a01 	vstr	s1, [sp, #4]
   126b4:	4623      	mov	r3, r4
   126b6:	4619      	mov	r1, r3
   126b8:	4815      	ldr	r0, [pc, #84]	; (12710 <Uart::DividerEstimate(float, float)+0x70>)
   126ba:	f000 ff49 	bl	13550 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   126be:	9b03      	ldr	r3, [sp, #12]
   126c0:	1d1a      	adds	r2, r3, #4
   126c2:	9b03      	ldr	r3, [sp, #12]
   126c4:	685b      	ldr	r3, [r3, #4]
   126c6:	3310      	adds	r3, #16
   126c8:	681b      	ldr	r3, [r3, #0]
   126ca:	4610      	mov	r0, r2
   126cc:	4798      	blx	r3
   126ce:	ee07 0a90 	vmov	s15, r0
   126d2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   126d6:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * fraction_estimate);
   126da:	eddd 7a02 	vldr	s15, [sp, #8]
   126de:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   126e2:	ee27 7a87 	vmul.f32	s14, s15, s14
   126e6:	eddd 7a01 	vldr	s15, [sp, #4]
   126ea:	ee67 7a27 	vmul.f32	s15, s14, s15
   126ee:	ed9d 7a05 	vldr	s14, [sp, #20]
   126f2:	ee87 8a27 	vdiv.f32	s16, s14, s15
   126f6:	4623      	mov	r3, r4
   126f8:	4619      	mov	r1, r3
   126fa:	4805      	ldr	r0, [pc, #20]	; (12710 <Uart::DividerEstimate(float, float)+0x70>)
   126fc:	f000 ff3c 	bl	13578 <__cyg_profile_func_exit>
   12700:	eef0 7a48 	vmov.f32	s15, s16
  }
   12704:	eeb0 0a67 	vmov.f32	s0, s15
   12708:	b006      	add	sp, #24
   1270a:	ecbd 8b02 	vpop	{d8}
   1270e:	bd10      	pop	{r4, pc}
   12710:	000126a1 	.word	0x000126a1

00012714 <Uart::FractionalEstimate(float, float)>:

  float FractionalEstimate(float baud_rate, float divider)
   12714:	b510      	push	{r4, lr}
   12716:	ed2d 8b02 	vpush	{d8}
   1271a:	b086      	sub	sp, #24
   1271c:	4674      	mov	r4, lr
   1271e:	9003      	str	r0, [sp, #12]
   12720:	ed8d 0a02 	vstr	s0, [sp, #8]
   12724:	edcd 0a01 	vstr	s1, [sp, #4]
   12728:	4623      	mov	r3, r4
   1272a:	4619      	mov	r1, r3
   1272c:	4815      	ldr	r0, [pc, #84]	; (12784 <Uart::FractionalEstimate(float, float)+0x70>)
   1272e:	f000 ff0f 	bl	13550 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   12732:	9b03      	ldr	r3, [sp, #12]
   12734:	1d1a      	adds	r2, r3, #4
   12736:	9b03      	ldr	r3, [sp, #12]
   12738:	685b      	ldr	r3, [r3, #4]
   1273a:	3310      	adds	r3, #16
   1273c:	681b      	ldr	r3, [r3, #0]
   1273e:	4610      	mov	r0, r2
   12740:	4798      	blx	r3
   12742:	ee07 0a90 	vmov	s15, r0
   12746:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1274a:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * divider);
   1274e:	eddd 7a02 	vldr	s15, [sp, #8]
   12752:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   12756:	ee27 7a87 	vmul.f32	s14, s15, s14
   1275a:	eddd 7a01 	vldr	s15, [sp, #4]
   1275e:	ee67 7a27 	vmul.f32	s15, s14, s15
   12762:	ed9d 7a05 	vldr	s14, [sp, #20]
   12766:	ee87 8a27 	vdiv.f32	s16, s14, s15
   1276a:	4623      	mov	r3, r4
   1276c:	4619      	mov	r1, r3
   1276e:	4805      	ldr	r0, [pc, #20]	; (12784 <Uart::FractionalEstimate(float, float)+0x70>)
   12770:	f000 ff02 	bl	13578 <__cyg_profile_func_exit>
   12774:	eef0 7a48 	vmov.f32	s15, s16
  }
   12778:	eeb0 0a67 	vmov.f32	s0, s15
   1277c:	b006      	add	sp, #24
   1277e:	ecbd 8b02 	vpop	{d8}
   12782:	bd10      	pop	{r4, pc}
   12784:	00012715 	.word	0x00012715

00012788 <Uart::IsDecmial(float)>:

  bool IsDecmial(float value)
   12788:	b530      	push	{r4, r5, lr}
   1278a:	b087      	sub	sp, #28
   1278c:	4675      	mov	r5, lr
   1278e:	9001      	str	r0, [sp, #4]
   12790:	ed8d 0a00 	vstr	s0, [sp]
   12794:	462b      	mov	r3, r5
   12796:	4619      	mov	r1, r3
   12798:	4819      	ldr	r0, [pc, #100]	; (12800 <Uart::IsDecmial(float)+0x78>)
   1279a:	f000 fed9 	bl	13550 <__cyg_profile_func_enter>
  {
    bool result         = false;
   1279e:	2300      	movs	r3, #0
   127a0:	f88d 3017 	strb.w	r3, [sp, #23]
    float rounded_value = roundf(value);
   127a4:	ed9d 0a00 	vldr	s0, [sp]
   127a8:	f006 f8c0 	bl	1892c <roundf>
   127ac:	ed8d 0a04 	vstr	s0, [sp, #16]
    float error         = value - rounded_value;
   127b0:	ed9d 7a00 	vldr	s14, [sp]
   127b4:	eddd 7a04 	vldr	s15, [sp, #16]
   127b8:	ee77 7a67 	vsub.f32	s15, s14, s15
   127bc:	edcd 7a03 	vstr	s15, [sp, #12]
    if (-kThreshold <= error && error <= kThreshold)
   127c0:	eddd 7a03 	vldr	s15, [sp, #12]
   127c4:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 12804 <Uart::IsDecmial(float)+0x7c>
   127c8:	eef4 7ac7 	vcmpe.f32	s15, s14
   127cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   127d0:	db0b      	blt.n	127ea <Uart::IsDecmial(float)+0x62>
   127d2:	eddd 7a03 	vldr	s15, [sp, #12]
   127d6:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 12808 <Uart::IsDecmial(float)+0x80>
   127da:	eef4 7ac7 	vcmpe.f32	s15, s14
   127de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   127e2:	d802      	bhi.n	127ea <Uart::IsDecmial(float)+0x62>
    {
      result = true;
   127e4:	2301      	movs	r3, #1
   127e6:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return result;
   127ea:	f89d 4017 	ldrb.w	r4, [sp, #23]
   127ee:	462b      	mov	r3, r5
   127f0:	4619      	mov	r1, r3
   127f2:	4803      	ldr	r0, [pc, #12]	; (12800 <Uart::IsDecmial(float)+0x78>)
   127f4:	f000 fec0 	bl	13578 <__cyg_profile_func_exit>
   127f8:	4623      	mov	r3, r4
  }
   127fa:	4618      	mov	r0, r3
   127fc:	b007      	add	sp, #28
   127fe:	bd30      	pop	{r4, r5, pc}
   12800:	00012789 	.word	0x00012789
   12804:	bd4ccccd 	.word	0xbd4ccccd
   12808:	3d4ccccd 	.word	0x3d4ccccd

0001280c <Uart::GenerateUartCalibration(float)>:

  UartCalibration_t GenerateUartCalibration(float baud_rate)
   1280c:	b530      	push	{r4, r5, lr}
   1280e:	b08f      	sub	sp, #60	; 0x3c
   12810:	4675      	mov	r5, lr
   12812:	9007      	str	r0, [sp, #28]
   12814:	9106      	str	r1, [sp, #24]
   12816:	ed8d 0a05 	vstr	s0, [sp, #20]
   1281a:	462b      	mov	r3, r5
   1281c:	4619      	mov	r1, r3
   1281e:	4874      	ldr	r0, [pc, #464]	; (129f0 <Uart::GenerateUartCalibration(float)+0x1e4>)
   12820:	f000 fe96 	bl	13550 <__cyg_profile_func_enter>
  {
    States state = States::kCalculateIntegerDivideLatch;
   12824:	2300      	movs	r3, #0
   12826:	930d      	str	r3, [sp, #52]	; 0x34
    UartCalibration_t uart_calibration;
   12828:	9b07      	ldr	r3, [sp, #28]
   1282a:	2200      	movs	r2, #0
   1282c:	601a      	str	r2, [r3, #0]
   1282e:	9b07      	ldr	r3, [sp, #28]
   12830:	2200      	movs	r2, #0
   12832:	605a      	str	r2, [r3, #4]
   12834:	9b07      	ldr	r3, [sp, #28]
   12836:	2201      	movs	r2, #1
   12838:	609a      	str	r2, [r3, #8]
    float divide_estimate = 0;
   1283a:	f04f 0300 	mov.w	r3, #0
   1283e:	930c      	str	r3, [sp, #48]	; 0x30
    float decimal         = 1.5;
   12840:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
   12844:	930b      	str	r3, [sp, #44]	; 0x2c
    float div             = 1;
   12846:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   1284a:	930a      	str	r3, [sp, #40]	; 0x28
    float mul             = 2;
   1284c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   12850:	9309      	str	r3, [sp, #36]	; 0x24
    while (state != States::kDone)
   12852:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12854:	2b04      	cmp	r3, #4
   12856:	f000 80c1 	beq.w	129dc <Uart::GenerateUartCalibration(float)+0x1d0>
    {
      switch (state)
   1285a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1285c:	2b04      	cmp	r3, #4
   1285e:	f200 80bb 	bhi.w	129d8 <Uart::GenerateUartCalibration(float)+0x1cc>
   12862:	a201      	add	r2, pc, #4	; (adr r2, 12868 <Uart::GenerateUartCalibration(float)+0x5c>)
   12864:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   12868:	0001287d 	.word	0x0001287d
   1286c:	000128d9 	.word	0x000128d9
   12870:	00012939 	.word	0x00012939
   12874:	000129a9 	.word	0x000129a9
   12878:	000129d9 	.word	0x000129d9
      {
        case States::kCalculateIntegerDivideLatch:
        {
          divide_estimate = DividerEstimate(baud_rate);
   1287c:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   12880:	ed9d 0a05 	vldr	s0, [sp, #20]
   12884:	9806      	ldr	r0, [sp, #24]
   12886:	f7ff ff0b 	bl	126a0 <Uart::DividerEstimate(float, float)>
   1288a:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          if (divide_estimate < 1.0f)
   1288e:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   12892:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   12896:	eef4 7ac7 	vcmpe.f32	s15, s14
   1289a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1289e:	d505      	bpl.n	128ac <Uart::GenerateUartCalibration(float)+0xa0>
          {
            uart_calibration.divide_latch = 0;
   128a0:	9b07      	ldr	r3, [sp, #28]
   128a2:	2200      	movs	r2, #0
   128a4:	601a      	str	r2, [r3, #0]
            state                         = States::kDone;
   128a6:	2304      	movs	r3, #4
   128a8:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kCalculateDivideLatchWithDecimal;
          }
          break;
   128aa:	e096      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
          else if (IsDecmial(divide_estimate))
   128ac:	ed9d 0a0c 	vldr	s0, [sp, #48]	; 0x30
   128b0:	9806      	ldr	r0, [sp, #24]
   128b2:	f7ff ff69 	bl	12788 <Uart::IsDecmial(float)>
   128b6:	4603      	mov	r3, r0
   128b8:	2b00      	cmp	r3, #0
   128ba:	d00a      	beq.n	128d2 <Uart::GenerateUartCalibration(float)+0xc6>
                static_cast<uint32_t>(divide_estimate);
   128bc:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   128c0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   128c4:	ee17 2a90 	vmov	r2, s15
            uart_calibration.divide_latch =
   128c8:	9b07      	ldr	r3, [sp, #28]
   128ca:	601a      	str	r2, [r3, #0]
            state = States::kDone;
   128cc:	2304      	movs	r3, #4
   128ce:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   128d0:	e083      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kCalculateDivideLatchWithDecimal;
   128d2:	2301      	movs	r3, #1
   128d4:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   128d6:	e080      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kCalculateDivideLatchWithDecimal:
        {
          divide_estimate = roundf(DividerEstimate(baud_rate, decimal));
   128d8:	eddd 0a0b 	vldr	s1, [sp, #44]	; 0x2c
   128dc:	ed9d 0a05 	vldr	s0, [sp, #20]
   128e0:	9806      	ldr	r0, [sp, #24]
   128e2:	f7ff fedd 	bl	126a0 <Uart::DividerEstimate(float, float)>
   128e6:	eef0 7a40 	vmov.f32	s15, s0
   128ea:	eeb0 0a67 	vmov.f32	s0, s15
   128ee:	f006 f81d 	bl	1892c <roundf>
   128f2:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          decimal         = FractionalEstimate(baud_rate, divide_estimate);
   128f6:	eddd 0a0c 	vldr	s1, [sp, #48]	; 0x30
   128fa:	ed9d 0a05 	vldr	s0, [sp, #20]
   128fe:	9806      	ldr	r0, [sp, #24]
   12900:	f7ff ff08 	bl	12714 <Uart::FractionalEstimate(float, float)>
   12904:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
          if (1.1f <= decimal && decimal <= 1.9f)
   12908:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   1290c:	ed9f 7a39 	vldr	s14, [pc, #228]	; 129f4 <Uart::GenerateUartCalibration(float)+0x1e8>
   12910:	eef4 7ac7 	vcmpe.f32	s15, s14
   12914:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12918:	db0b      	blt.n	12932 <Uart::GenerateUartCalibration(float)+0x126>
   1291a:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   1291e:	ed9f 7a36 	vldr	s14, [pc, #216]	; 129f8 <Uart::GenerateUartCalibration(float)+0x1ec>
   12922:	eef4 7ac7 	vcmpe.f32	s15, s14
   12926:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1292a:	d802      	bhi.n	12932 <Uart::GenerateUartCalibration(float)+0x126>
          {
            state = States::kGenerateFractionFromDecimal;
   1292c:	2303      	movs	r3, #3
   1292e:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kDecimalFailedGenerateNewDecimal;
          }
          break;
   12930:	e053      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kDecimalFailedGenerateNewDecimal;
   12932:	2302      	movs	r3, #2
   12934:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   12936:	e050      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDecimalFailedGenerateNewDecimal:
        {
          mul += 1;
   12938:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   1293c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   12940:	ee77 7a87 	vadd.f32	s15, s15, s14
   12944:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24

          if (div > 15)
   12948:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   1294c:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   12950:	eef4 7ac7 	vcmpe.f32	s15, s14
   12954:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12958:	dd02      	ble.n	12960 <Uart::GenerateUartCalibration(float)+0x154>
          {
            state = States::kDone;
   1295a:	2304      	movs	r3, #4
   1295c:	930d      	str	r3, [sp, #52]	; 0x34
            break;
   1295e:	e03c      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
          }
          else if (mul > 15)
   12960:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   12964:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   12968:	eef4 7ac7 	vcmpe.f32	s15, s14
   1296c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12970:	dd0f      	ble.n	12992 <Uart::GenerateUartCalibration(float)+0x186>
          {
            div += 1;
   12972:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   12976:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1297a:	ee77 7a87 	vadd.f32	s15, s15, s14
   1297e:	edcd 7a0a 	vstr	s15, [sp, #40]	; 0x28
            mul = div + 1;
   12982:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   12986:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1298a:	ee77 7a87 	vadd.f32	s15, s15, s14
   1298e:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
          }
          decimal = div / mul;
   12992:	eddd 6a0a 	vldr	s13, [sp, #40]	; 0x28
   12996:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
   1299a:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1299e:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
          state   = States::kCalculateDivideLatchWithDecimal;
   129a2:	2301      	movs	r3, #1
   129a4:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   129a6:	e018      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kGenerateFractionFromDecimal:
        {
          uart_calibration = FindClosestFractional(decimal);
   129a8:	9c07      	ldr	r4, [sp, #28]
   129aa:	466b      	mov	r3, sp
   129ac:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
   129b0:	9906      	ldr	r1, [sp, #24]
   129b2:	4618      	mov	r0, r3
   129b4:	f7ff fdf6 	bl	125a4 <Uart::FindClosestFractional(float)>
   129b8:	466b      	mov	r3, sp
   129ba:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   129be:	e884 0007 	stmia.w	r4, {r0, r1, r2}
          uart_calibration.divide_latch =
              static_cast<uint32_t>(divide_estimate);
   129c2:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   129c6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   129ca:	ee17 2a90 	vmov	r2, s15
          uart_calibration.divide_latch =
   129ce:	9b07      	ldr	r3, [sp, #28]
   129d0:	601a      	str	r2, [r3, #0]
          state = States::kDone;
   129d2:	2304      	movs	r3, #4
   129d4:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   129d6:	e000      	b.n	129da <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDone: { break;
        }
        default: { break;
   129d8:	bf00      	nop
    while (state != States::kDone)
   129da:	e73a      	b.n	12852 <Uart::GenerateUartCalibration(float)+0x46>
        }
      }
    }
    return uart_calibration;
   129dc:	bf00      	nop
   129de:	462b      	mov	r3, r5
   129e0:	4619      	mov	r1, r3
   129e2:	4803      	ldr	r0, [pc, #12]	; (129f0 <Uart::GenerateUartCalibration(float)+0x1e4>)
   129e4:	f000 fdc8 	bl	13578 <__cyg_profile_func_exit>
   129e8:	bf00      	nop
  }
   129ea:	9807      	ldr	r0, [sp, #28]
   129ec:	b00f      	add	sp, #60	; 0x3c
   129ee:	bd30      	pop	{r4, r5, pc}
   129f0:	0001280d 	.word	0x0001280d
   129f4:	3f8ccccd 	.word	0x3f8ccccd
   129f8:	3ff33333 	.word	0x3ff33333

000129fc <(anonymous namespace)::Lpc40xxUptime()>:
{
   129fc:	b538      	push	{r3, r4, r5, lr}
   129fe:	4675      	mov	r5, lr
   12a00:	462b      	mov	r3, r5
   12a02:	4619      	mov	r1, r3
   12a04:	480a      	ldr	r0, [pc, #40]	; (12a30 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   12a06:	f000 fda3 	bl	13550 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   12a0a:	4b0a      	ldr	r3, [pc, #40]	; (12a34 <(anonymous namespace)::Lpc40xxUptime()+0x38>)
   12a0c:	7a1b      	ldrb	r3, [r3, #8]
   12a0e:	461a      	mov	r2, r3
   12a10:	4b09      	ldr	r3, [pc, #36]	; (12a38 <(anonymous namespace)::Lpc40xxUptime()+0x3c>)
   12a12:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12a16:	689c      	ldr	r4, [r3, #8]
   12a18:	462b      	mov	r3, r5
   12a1a:	4619      	mov	r1, r3
   12a1c:	4804      	ldr	r0, [pc, #16]	; (12a30 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   12a1e:	f000 fdab 	bl	13578 <__cyg_profile_func_exit>
  return timer0.GetTimer();
   12a22:	4623      	mov	r3, r4
   12a24:	f04f 0400 	mov.w	r4, #0
}
   12a28:	4618      	mov	r0, r3
   12a2a:	4621      	mov	r1, r4
   12a2c:	bd38      	pop	{r3, r4, r5, pc}
   12a2e:	bf00      	nop
   12a30:	00012141 	.word	0x00012141
   12a34:	100000f8 	.word	0x100000f8
   12a38:	10000078 	.word	0x10000078

00012a3c <UptimeRTOS>:
{
   12a3c:	b538      	push	{r3, r4, r5, lr}
   12a3e:	4675      	mov	r5, lr
   12a40:	462b      	mov	r3, r5
   12a42:	4619      	mov	r1, r3
   12a44:	480a      	ldr	r0, [pc, #40]	; (12a70 <UptimeRTOS+0x34>)
   12a46:	f000 fd83 	bl	13550 <__cyg_profile_func_enter>
   12a4a:	4b0a      	ldr	r3, [pc, #40]	; (12a74 <UptimeRTOS+0x38>)
   12a4c:	7a1b      	ldrb	r3, [r3, #8]
   12a4e:	461a      	mov	r2, r3
   12a50:	4b09      	ldr	r3, [pc, #36]	; (12a78 <UptimeRTOS+0x3c>)
   12a52:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12a56:	689c      	ldr	r4, [r3, #8]
   12a58:	462b      	mov	r3, r5
   12a5a:	4619      	mov	r1, r3
   12a5c:	4804      	ldr	r0, [pc, #16]	; (12a70 <UptimeRTOS+0x34>)
   12a5e:	f000 fd8b 	bl	13578 <__cyg_profile_func_exit>
  return timer0.GetTimer();
   12a62:	4623      	mov	r3, r4
   12a64:	f04f 0400 	mov.w	r4, #0
}
   12a68:	4618      	mov	r0, r3
   12a6a:	4621      	mov	r1, r4
   12a6c:	bd38      	pop	{r3, r4, r5, pc}
   12a6e:	bf00      	nop
   12a70:	00012141 	.word	0x00012141
   12a74:	100000f8 	.word	0x100000f8
   12a78:	10000078 	.word	0x10000078

00012a7c <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>:
   *  @brief  Return the size of an array.
   *  @param  __array  Array.
   */
  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (&/*__array*/)[_Nm]) noexcept
   12a7c:	b530      	push	{r4, r5, lr}
   12a7e:	b083      	sub	sp, #12
   12a80:	4675      	mov	r5, lr
   12a82:	9001      	str	r0, [sp, #4]
   12a84:	462b      	mov	r3, r5
   12a86:	4619      	mov	r1, r3
   12a88:	4806      	ldr	r0, [pc, #24]	; (12aa4 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   12a8a:	f000 fd61 	bl	13550 <__cyg_profile_func_enter>
    { return _Nm; }
   12a8e:	2450      	movs	r4, #80	; 0x50
   12a90:	462b      	mov	r3, r5
   12a92:	4619      	mov	r1, r3
   12a94:	4803      	ldr	r0, [pc, #12]	; (12aa4 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   12a96:	f000 fd6f 	bl	13578 <__cyg_profile_func_exit>
   12a9a:	4623      	mov	r3, r4
   12a9c:	4618      	mov	r0, r3
   12a9e:	b003      	add	sp, #12
   12aa0:	bd30      	pop	{r4, r5, pc}
   12aa2:	bf00      	nop
   12aa4:	00012a7d 	.word	0x00012a7d

00012aa8 <vApplicationGetIdleTaskMemory>:
  {
   12aa8:	b500      	push	{lr}
   12aaa:	b085      	sub	sp, #20
   12aac:	9003      	str	r0, [sp, #12]
   12aae:	9102      	str	r1, [sp, #8]
   12ab0:	9201      	str	r2, [sp, #4]
    *ppx_idle_task_tcb_buffer   = &idle_task_tcb;
   12ab2:	9b03      	ldr	r3, [sp, #12]
   12ab4:	4a07      	ldr	r2, [pc, #28]	; (12ad4 <vApplicationGetIdleTaskMemory+0x2c>)
   12ab6:	601a      	str	r2, [r3, #0]
    *ppx_idle_task_stack_buffer = idle_task_stack;
   12ab8:	9b02      	ldr	r3, [sp, #8]
   12aba:	4a07      	ldr	r2, [pc, #28]	; (12ad8 <vApplicationGetIdleTaskMemory+0x30>)
   12abc:	601a      	str	r2, [r3, #0]
    *pul_idle_task_stack_size   = std::size(idle_task_stack);
   12abe:	4806      	ldr	r0, [pc, #24]	; (12ad8 <vApplicationGetIdleTaskMemory+0x30>)
   12ac0:	f7ff ffdc 	bl	12a7c <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>
   12ac4:	4602      	mov	r2, r0
   12ac6:	9b01      	ldr	r3, [sp, #4]
   12ac8:	601a      	str	r2, [r3, #0]
  }
   12aca:	bf00      	nop
   12acc:	b005      	add	sp, #20
   12ace:	f85d fb04 	ldr.w	pc, [sp], #4
   12ad2:	bf00      	nop
   12ad4:	1000042c 	.word	0x1000042c
   12ad8:	1000048c 	.word	0x1000048c

00012adc <vPortSetupTimerInterrupt>:
  {
   12adc:	b508      	push	{r3, lr}
    system_timer.DisableTimer();
   12ade:	f7fe fdff 	bl	116e0 <SystemTimer::DisableTimer()>
    system_timer.SetTickFrequency(config::kRtosFrequency);
   12ae2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   12ae6:	4806      	ldr	r0, [pc, #24]	; (12b00 <vPortSetupTimerInterrupt+0x24>)
   12ae8:	f7fe fe9a 	bl	11820 <SystemTimer::SetTickFrequency(unsigned long)>
    system_timer.SetIsrFunction(xPortSysTickHandler);
   12aec:	4905      	ldr	r1, [pc, #20]	; (12b04 <vPortSetupTimerInterrupt+0x28>)
   12aee:	4804      	ldr	r0, [pc, #16]	; (12b00 <vPortSetupTimerInterrupt+0x24>)
   12af0:	f7fe fe2e 	bl	11750 <SystemTimer::SetIsrFunction(void (*)())>
    system_timer.StartTimer();
   12af4:	4802      	ldr	r0, [pc, #8]	; (12b00 <vPortSetupTimerInterrupt+0x24>)
   12af6:	f7fe fe45 	bl	11784 <SystemTimer::StartTimer()>
  }
   12afa:	bf00      	nop
   12afc:	bd08      	pop	{r3, pc}
   12afe:	bf00      	nop
   12b00:	100000ec 	.word	0x100000ec
   12b04:	00014d39 	.word	0x00014d39

00012b08 <LowLevelInit()>:

void LowLevelInit()
{
   12b08:	b500      	push	{lr}
   12b0a:	b083      	sub	sp, #12
  // Set the SystemTick frequency to the RTOS tick frequency
  // It is critical that this happens before you set the system_clock, since
  // The system_timer keeps the time that the system_clock uses to delay itself.
  system_timer.SetTickFrequency(config::kRtosFrequency);
   12b0c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   12b10:	4822      	ldr	r0, [pc, #136]	; (12b9c <LowLevelInit()+0x94>)
   12b12:	f7fe fe85 	bl	11820 <SystemTimer::SetTickFrequency(unsigned long)>
  bool timer_started_successfully = system_timer.StartTimer();
   12b16:	4821      	ldr	r0, [pc, #132]	; (12b9c <LowLevelInit()+0x94>)
   12b18:	f7fe fe34 	bl	11784 <SystemTimer::StartTimer()>
   12b1c:	4603      	mov	r3, r0
   12b1e:	f88d 3007 	strb.w	r3, [sp, #7]
  SJ2_ASSERT_WARNING(timer_started_successfully,
   12b22:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12b26:	f083 0301 	eor.w	r3, r3, #1
   12b2a:	b2db      	uxtb	r3, r3
   12b2c:	2b00      	cmp	r3, #0
   12b2e:	d005      	beq.n	12b3c <LowLevelInit()+0x34>
   12b30:	23ad      	movs	r3, #173	; 0xad
   12b32:	4a1b      	ldr	r2, [pc, #108]	; (12ba0 <LowLevelInit()+0x98>)
   12b34:	491b      	ldr	r1, [pc, #108]	; (12ba4 <LowLevelInit()+0x9c>)
   12b36:	481c      	ldr	r0, [pc, #112]	; (12ba8 <LowLevelInit()+0xa0>)
   12b38:	f003 faa8 	bl	1608c <printf>
                     "System Timer has FAILED to start!");
  // Set Clock Speed
  // SetClockFrequency will timeout return the offset between desire clockspeed
  // and actual clockspeed if the PLL doesn't get a frequency fix within a
  // defined timeout (see L1/system_clock.hpp:kDefaultTimeout)
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   12b3c:	2130      	movs	r1, #48	; 0x30
   12b3e:	481b      	ldr	r0, [pc, #108]	; (12bac <LowLevelInit()+0xa4>)
   12b40:	f7fe fb06 	bl	11150 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>
   12b44:	4603      	mov	r3, r0
   12b46:	2b00      	cmp	r3, #0
   12b48:	bf14      	ite	ne
   12b4a:	2301      	movne	r3, #1
   12b4c:	2300      	moveq	r3, #0
   12b4e:	b2db      	uxtb	r3, r3
   12b50:	2b00      	cmp	r3, #0
   12b52:	d001      	beq.n	12b58 <LowLevelInit()+0x50>
  {
    // Continually attempt to set the clock frequency to the desired until the
    // delta between desired and actual are 0.
    continue;
   12b54:	bf00      	nop
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   12b56:	e7f1      	b.n	12b3c <LowLevelInit()+0x34>
  }
  // Enable Peripheral Clock and set its divider to 1 meaning the clock speed
  // fed to all peripherals will be 48Mhz.
  system_controller.SetPeripheralClockDivider(1);
   12b58:	2101      	movs	r1, #1
   12b5a:	4814      	ldr	r0, [pc, #80]	; (12bac <LowLevelInit()+0xa4>)
   12b5c:	f7fe fb40 	bl	111e0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>
  // Set System Timer frequency again, since the clock speed has changed since
  // the last time we ran this.
  system_timer.DisableTimer();
   12b60:	f7fe fdbe 	bl	116e0 <SystemTimer::DisableTimer()>
  system_timer.SetTickFrequency(config::kRtosFrequency);
   12b64:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   12b68:	480c      	ldr	r0, [pc, #48]	; (12b9c <LowLevelInit()+0x94>)
   12b6a:	f7fe fe59 	bl	11820 <SystemTimer::SetTickFrequency(unsigned long)>
  system_timer.StartTimer();
   12b6e:	480b      	ldr	r0, [pc, #44]	; (12b9c <LowLevelInit()+0x94>)
   12b70:	f7fe fe08 	bl	11784 <SystemTimer::StartTimer()>
  // Set timer0 to 1 MHz (1,000,000 Hz) so that the timer increments every 1
  // micro second.
  timer0.Initialize(1'000'000);
   12b74:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12b78:	4a0d      	ldr	r2, [pc, #52]	; (12bb0 <LowLevelInit()+0xa8>)
   12b7a:	490e      	ldr	r1, [pc, #56]	; (12bb4 <LowLevelInit()+0xac>)
   12b7c:	480e      	ldr	r0, [pc, #56]	; (12bb8 <LowLevelInit()+0xb0>)
   12b7e:	f7ff f9b1 	bl	11ee4 <Timer::Initialize(unsigned long, void (*)(), long)>
  SetUptimeFunction(Lpc40xxUptime);
   12b82:	480e      	ldr	r0, [pc, #56]	; (12bbc <LowLevelInit()+0xb4>)
   12b84:	f7fe facc 	bl	11120 <SetUptimeFunction(unsigned long long (*)())>
  // Set UART0 baudrate, which is required for printf and scanf to work properly
  uart0.Initialize(config::kBaudRate);
   12b88:	f44f 4116 	mov.w	r1, #38400	; 0x9600
   12b8c:	480c      	ldr	r0, [pc, #48]	; (12bc0 <LowLevelInit()+0xb8>)
   12b8e:	f7ff fb5b 	bl	12248 <Uart::Initialize(unsigned long)>
}
   12b92:	bf00      	nop
   12b94:	b003      	add	sp, #12
   12b96:	f85d fb04 	ldr.w	pc, [sp], #4
   12b9a:	bf00      	nop
   12b9c:	100000ec 	.word	0x100000ec
   12ba0:	00019c50 	.word	0x00019c50
   12ba4:	000199b8 	.word	0x000199b8
   12ba8:	00019898 	.word	0x00019898
   12bac:	100000f4 	.word	0x100000f4
   12bb0:	00011ec5 	.word	0x00011ec5
   12bb4:	000f4240 	.word	0x000f4240
   12bb8:	100000f8 	.word	0x100000f8
   12bbc:	000129fd 	.word	0x000129fd
   12bc0:	100000d8 	.word	0x100000d8

00012bc4 <SystemInit>:

void SystemInit()
{
   12bc4:	b508      	push	{r3, lr}
  // Transfer data section values from flash to RAM
  InitDataSection();
   12bc6:	f7fd faa1 	bl	1010c <InitDataSection()>
  // Clear BSS section of RAM
  // This is required because the nano implementation of the standard C/C++
  // libraries assumes that the BSS section is initialized to 0.
  InitBssSection();
   12bca:	f7fd fae7 	bl	1019c <InitBssSection()>
  // Enable FPU (F.loating P.oint U.nit)
  // System will crash if floating point operations occur without
  // Initializing the FPU.
  InitFpu();
   12bce:	f7fd fb15 	bl	101fc <InitFpu()>
  // Initialisation C++ libraries
  __libc_init_array();
   12bd2:	f006 f8b3 	bl	18d3c <__libc_init_array>
  // Run LowLevel System Initialization
  LowLevelInit();
   12bd6:	f7ff ff97 	bl	12b08 <LowLevelInit()>
}
   12bda:	bf00      	nop
   12bdc:	bd08      	pop	{r3, pc}
   12bde:	Address 0x0000000000012bde is out of bounds.


00012be0 <ResetIsr>:
// Sets up a simple runtime environment and initializes the C/C++ library.

extern "C"
{
  void ResetIsr(void)
  {
   12be0:	b580      	push	{r7, lr}
   12be2:	b084      	sub	sp, #16
   12be4:	af00      	add	r7, sp, #0
    // The Hyperload bootloader takes up stack space to execute. The Hyperload
    // bootloader function launches this ISR manually, but it never returns thus
    // it never cleans up the memory it uses. To get that memory back, we have
    // to manually move the stack pointers back to the top of stack.
    const uint32_t kTopOfStack = reinterpret_cast<intptr_t>(&StackTop);
   12be6:	4b09      	ldr	r3, [pc, #36]	; (12c0c <ResetIsr+0x2c>)
   12be8:	60fb      	str	r3, [r7, #12]
   12bea:	68fb      	ldr	r3, [r7, #12]
   12bec:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
   12bee:	683b      	ldr	r3, [r7, #0]
   12bf0:	f383 8809 	msr	PSP, r3
   12bf4:	68fb      	ldr	r3, [r7, #12]
   12bf6:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
   12bf8:	687b      	ldr	r3, [r7, #4]
   12bfa:	f383 8808 	msr	MSP, r3
    __set_PSP(kTopOfStack);
    __set_MSP(kTopOfStack);

    SystemInit();
   12bfe:	f7ff ffe1 	bl	12bc4 <SystemInit>
// #pragma ignored "-Wpedantic" to suppress main function call warning
#pragma GCC diagnostic push ignored "-Wpedantic"
    [[maybe_unused]] int32_t result = main();
   12c02:	f7fe f81d 	bl	10c40 <main>
   12c06:	60b8      	str	r0, [r7, #8]
   12c08:	e7fe      	b.n	12c08 <ResetIsr+0x28>
   12c0a:	bf00      	nop
   12c0c:	10010000 	.word	0x10010000

00012c10 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()>:
  static void TimerHandler()
   12c10:	b510      	push	{r4, lr}
   12c12:	4674      	mov	r4, lr
   12c14:	4623      	mov	r3, r4
   12c16:	4619      	mov	r1, r3
   12c18:	480a      	ldr	r0, [pc, #40]	; (12c44 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   12c1a:	f000 fc99 	bl	13550 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   12c1e:	2000      	movs	r0, #0
   12c20:	f7ff f938 	bl	11e94 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   12c24:	4603      	mov	r3, r0
   12c26:	461a      	mov	r2, r3
   12c28:	4b07      	ldr	r3, [pc, #28]	; (12c48 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x38>)
   12c2a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12c2e:	4798      	blx	r3
    ClearInterrupts<port>();
   12c30:	f000 f90e 	bl	12e50 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>
   12c34:	4623      	mov	r3, r4
   12c36:	4619      	mov	r1, r3
   12c38:	4802      	ldr	r0, [pc, #8]	; (12c44 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   12c3a:	f000 fc9d 	bl	13578 <__cyg_profile_func_exit>
  }
   12c3e:	bf00      	nop
   12c40:	bd10      	pop	{r4, pc}
   12c42:	bf00      	nop
   12c44:	00012c11 	.word	0x00012c11
   12c48:	1000041c 	.word	0x1000041c

00012c4c <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()>:
  static void TimerHandler()
   12c4c:	b510      	push	{r4, lr}
   12c4e:	4674      	mov	r4, lr
   12c50:	4623      	mov	r3, r4
   12c52:	4619      	mov	r1, r3
   12c54:	480a      	ldr	r0, [pc, #40]	; (12c80 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   12c56:	f000 fc7b 	bl	13550 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   12c5a:	2001      	movs	r0, #1
   12c5c:	f7ff f91a 	bl	11e94 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   12c60:	4603      	mov	r3, r0
   12c62:	461a      	mov	r2, r3
   12c64:	4b07      	ldr	r3, [pc, #28]	; (12c84 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x38>)
   12c66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12c6a:	4798      	blx	r3
    ClearInterrupts<port>();
   12c6c:	f000 f940 	bl	12ef0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>
   12c70:	4623      	mov	r3, r4
   12c72:	4619      	mov	r1, r3
   12c74:	4802      	ldr	r0, [pc, #8]	; (12c80 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   12c76:	f000 fc7f 	bl	13578 <__cyg_profile_func_exit>
  }
   12c7a:	bf00      	nop
   12c7c:	bd10      	pop	{r4, pc}
   12c7e:	bf00      	nop
   12c80:	00012c4d 	.word	0x00012c4d
   12c84:	1000041c 	.word	0x1000041c

00012c88 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()>:
  static void TimerHandler()
   12c88:	b510      	push	{r4, lr}
   12c8a:	4674      	mov	r4, lr
   12c8c:	4623      	mov	r3, r4
   12c8e:	4619      	mov	r1, r3
   12c90:	480a      	ldr	r0, [pc, #40]	; (12cbc <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   12c92:	f000 fc5d 	bl	13550 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   12c96:	2002      	movs	r0, #2
   12c98:	f7ff f8fc 	bl	11e94 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   12c9c:	4603      	mov	r3, r0
   12c9e:	461a      	mov	r2, r3
   12ca0:	4b07      	ldr	r3, [pc, #28]	; (12cc0 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x38>)
   12ca2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12ca6:	4798      	blx	r3
    ClearInterrupts<port>();
   12ca8:	f000 f972 	bl	12f90 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>
   12cac:	4623      	mov	r3, r4
   12cae:	4619      	mov	r1, r3
   12cb0:	4802      	ldr	r0, [pc, #8]	; (12cbc <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   12cb2:	f000 fc61 	bl	13578 <__cyg_profile_func_exit>
  }
   12cb6:	bf00      	nop
   12cb8:	bd10      	pop	{r4, pc}
   12cba:	bf00      	nop
   12cbc:	00012c89 	.word	0x00012c89
   12cc0:	1000041c 	.word	0x1000041c

00012cc4 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()>:
  static void TimerHandler()
   12cc4:	b510      	push	{r4, lr}
   12cc6:	4674      	mov	r4, lr
   12cc8:	4623      	mov	r3, r4
   12cca:	4619      	mov	r1, r3
   12ccc:	480a      	ldr	r0, [pc, #40]	; (12cf8 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   12cce:	f000 fc3f 	bl	13550 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   12cd2:	2003      	movs	r0, #3
   12cd4:	f7ff f8de 	bl	11e94 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   12cd8:	4603      	mov	r3, r0
   12cda:	461a      	mov	r2, r3
   12cdc:	4b07      	ldr	r3, [pc, #28]	; (12cfc <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x38>)
   12cde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12ce2:	4798      	blx	r3
    ClearInterrupts<port>();
   12ce4:	f000 f9a4 	bl	13030 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>
   12ce8:	4623      	mov	r3, r4
   12cea:	4619      	mov	r1, r3
   12cec:	4802      	ldr	r0, [pc, #8]	; (12cf8 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   12cee:	f000 fc43 	bl	13578 <__cyg_profile_func_exit>
  }
   12cf2:	bf00      	nop
   12cf4:	bd10      	pop	{r4, pc}
   12cf6:	bf00      	nop
   12cf8:	00012cc5 	.word	0x00012cc5
   12cfc:	1000041c 	.word	0x1000041c

00012d00 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   12d00:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   12d04:	b088      	sub	sp, #32
   12d06:	4675      	mov	r5, lr
   12d08:	e9cd 0102 	strd	r0, r1, [sp, #8]
   12d0c:	9201      	str	r2, [sp, #4]
   12d0e:	462b      	mov	r3, r5
   12d10:	4619      	mov	r1, r3
   12d12:	4824      	ldr	r0, [pc, #144]	; (12da4 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   12d14:	f000 fc1c 	bl	13550 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   12d18:	f04f 0300 	mov.w	r3, #0
   12d1c:	f04f 0400 	mov.w	r4, #0
   12d20:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   12d24:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12d28:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   12d2c:	bf08      	it	eq
   12d2e:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   12d32:	d106      	bne.n	12d42 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   12d34:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12d38:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   12d3c:	e9cd 3406 	strd	r3, r4, [sp, #24]
   12d40:	e00b      	b.n	12d5a <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   12d42:	f7fd fda7 	bl	10894 <Milliseconds()>
   12d46:	460a      	mov	r2, r1
   12d48:	4601      	mov	r1, r0
   12d4a:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12d4e:	eb13 0b01 	adds.w	fp, r3, r1
   12d52:	eb44 0c02 	adc.w	ip, r4, r2
   12d56:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   12d5a:	2301      	movs	r3, #1
   12d5c:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   12d5e:	f7fd fd99 	bl	10894 <Milliseconds()>
   12d62:	460a      	mov	r2, r1
   12d64:	4601      	mov	r1, r0
   12d66:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   12d6a:	42a2      	cmp	r2, r4
   12d6c:	bf08      	it	eq
   12d6e:	4299      	cmpeq	r1, r3
   12d70:	bf34      	ite	cc
   12d72:	2301      	movcc	r3, #1
   12d74:	2300      	movcs	r3, #0
   12d76:	b2db      	uxtb	r3, r3
   12d78:	2b00      	cmp	r3, #0
   12d7a:	d008      	beq.n	12d8e <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x8e>
    if (is_done())
   12d7c:	ab01      	add	r3, sp, #4
   12d7e:	4618      	mov	r0, r3
   12d80:	f7ff fad4 	bl	1232c <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   12d84:	4603      	mov	r3, r0
   12d86:	2b00      	cmp	r3, #0
   12d88:	d0e9      	beq.n	12d5e <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   12d8a:	2300      	movs	r3, #0
   12d8c:	9305      	str	r3, [sp, #20]
  return status;
   12d8e:	9c05      	ldr	r4, [sp, #20]
   12d90:	462b      	mov	r3, r5
   12d92:	4619      	mov	r1, r3
   12d94:	4803      	ldr	r0, [pc, #12]	; (12da4 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   12d96:	f000 fbef 	bl	13578 <__cyg_profile_func_exit>
   12d9a:	4623      	mov	r3, r4
}
   12d9c:	4618      	mov	r0, r3
   12d9e:	b008      	add	sp, #32
   12da0:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   12da4:	00012d01 	.word	0x00012d01

00012da8 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   12da8:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   12dac:	b088      	sub	sp, #32
   12dae:	4675      	mov	r5, lr
   12db0:	e9cd 0102 	strd	r0, r1, [sp, #8]
   12db4:	9201      	str	r2, [sp, #4]
   12db6:	462b      	mov	r3, r5
   12db8:	4619      	mov	r1, r3
   12dba:	4824      	ldr	r0, [pc, #144]	; (12e4c <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   12dbc:	f000 fbc8 	bl	13550 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   12dc0:	f04f 0300 	mov.w	r3, #0
   12dc4:	f04f 0400 	mov.w	r4, #0
   12dc8:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   12dcc:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12dd0:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   12dd4:	bf08      	it	eq
   12dd6:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   12dda:	d106      	bne.n	12dea <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   12ddc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12de0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   12de4:	e9cd 3406 	strd	r3, r4, [sp, #24]
   12de8:	e00b      	b.n	12e02 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   12dea:	f7fd fd53 	bl	10894 <Milliseconds()>
   12dee:	460a      	mov	r2, r1
   12df0:	4601      	mov	r1, r0
   12df2:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12df6:	eb13 0b01 	adds.w	fp, r3, r1
   12dfa:	eb44 0c02 	adc.w	ip, r4, r2
   12dfe:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   12e02:	2301      	movs	r3, #1
   12e04:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   12e06:	f7fd fd45 	bl	10894 <Milliseconds()>
   12e0a:	460a      	mov	r2, r1
   12e0c:	4601      	mov	r1, r0
   12e0e:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   12e12:	42a2      	cmp	r2, r4
   12e14:	bf08      	it	eq
   12e16:	4299      	cmpeq	r1, r3
   12e18:	bf34      	ite	cc
   12e1a:	2301      	movcc	r3, #1
   12e1c:	2300      	movcs	r3, #0
   12e1e:	b2db      	uxtb	r3, r3
   12e20:	2b00      	cmp	r3, #0
   12e22:	d008      	beq.n	12e36 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x8e>
    if (is_done())
   12e24:	ab01      	add	r3, sp, #4
   12e26:	4618      	mov	r0, r3
   12e28:	f7ff fb1a 	bl	12460 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   12e2c:	4603      	mov	r3, r0
   12e2e:	2b00      	cmp	r3, #0
   12e30:	d0e9      	beq.n	12e06 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   12e32:	2300      	movs	r3, #0
   12e34:	9305      	str	r3, [sp, #20]
  return status;
   12e36:	9c05      	ldr	r4, [sp, #20]
   12e38:	462b      	mov	r3, r5
   12e3a:	4619      	mov	r1, r3
   12e3c:	4803      	ldr	r0, [pc, #12]	; (12e4c <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   12e3e:	f000 fb9b 	bl	13578 <__cyg_profile_func_exit>
   12e42:	4623      	mov	r3, r4
}
   12e44:	4618      	mov	r0, r3
   12e46:	b008      	add	sp, #32
   12e48:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   12e4c:	00012da9 	.word	0x00012da9

00012e50 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>:
  static void ClearInterrupts()
   12e50:	b510      	push	{r4, lr}
   12e52:	b082      	sub	sp, #8
   12e54:	4674      	mov	r4, lr
   12e56:	4623      	mov	r3, r4
   12e58:	4619      	mov	r1, r3
   12e5a:	4823      	ldr	r0, [pc, #140]	; (12ee8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   12e5c:	f000 fb78 	bl	13550 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   12e60:	2300      	movs	r3, #0
   12e62:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   12e66:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e6a:	4a20      	ldr	r2, [pc, #128]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12e6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e70:	681a      	ldr	r2, [r3, #0]
   12e72:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e76:	491d      	ldr	r1, [pc, #116]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12e78:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12e7c:	f042 0201 	orr.w	r2, r2, #1
   12e80:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   12e82:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e86:	4a19      	ldr	r2, [pc, #100]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12e88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e8c:	681a      	ldr	r2, [r3, #0]
   12e8e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e92:	4916      	ldr	r1, [pc, #88]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12e94:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12e98:	f042 0202 	orr.w	r2, r2, #2
   12e9c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   12e9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12ea2:	4a12      	ldr	r2, [pc, #72]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12ea4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ea8:	681a      	ldr	r2, [r3, #0]
   12eaa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12eae:	490f      	ldr	r1, [pc, #60]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12eb0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12eb4:	f042 0204 	orr.w	r2, r2, #4
   12eb8:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   12eba:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12ebe:	4a0b      	ldr	r2, [pc, #44]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12ec0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ec4:	681a      	ldr	r2, [r3, #0]
   12ec6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12eca:	4908      	ldr	r1, [pc, #32]	; (12eec <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12ecc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12ed0:	f042 0208 	orr.w	r2, r2, #8
   12ed4:	601a      	str	r2, [r3, #0]
   12ed6:	4623      	mov	r3, r4
   12ed8:	4619      	mov	r1, r3
   12eda:	4803      	ldr	r0, [pc, #12]	; (12ee8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   12edc:	f000 fb4c 	bl	13578 <__cyg_profile_func_exit>
  }
   12ee0:	bf00      	nop
   12ee2:	b002      	add	sp, #8
   12ee4:	bd10      	pop	{r4, pc}
   12ee6:	bf00      	nop
   12ee8:	00012e51 	.word	0x00012e51
   12eec:	10000078 	.word	0x10000078

00012ef0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>:
  static void ClearInterrupts()
   12ef0:	b510      	push	{r4, lr}
   12ef2:	b082      	sub	sp, #8
   12ef4:	4674      	mov	r4, lr
   12ef6:	4623      	mov	r3, r4
   12ef8:	4619      	mov	r1, r3
   12efa:	4823      	ldr	r0, [pc, #140]	; (12f88 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   12efc:	f000 fb28 	bl	13550 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   12f00:	2301      	movs	r3, #1
   12f02:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   12f06:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f0a:	4a20      	ldr	r2, [pc, #128]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f10:	681a      	ldr	r2, [r3, #0]
   12f12:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f16:	491d      	ldr	r1, [pc, #116]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f18:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12f1c:	f042 0201 	orr.w	r2, r2, #1
   12f20:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   12f22:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f26:	4a19      	ldr	r2, [pc, #100]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f2c:	681a      	ldr	r2, [r3, #0]
   12f2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f32:	4916      	ldr	r1, [pc, #88]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f34:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12f38:	f042 0202 	orr.w	r2, r2, #2
   12f3c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   12f3e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f42:	4a12      	ldr	r2, [pc, #72]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f48:	681a      	ldr	r2, [r3, #0]
   12f4a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f4e:	490f      	ldr	r1, [pc, #60]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f50:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12f54:	f042 0204 	orr.w	r2, r2, #4
   12f58:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   12f5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f5e:	4a0b      	ldr	r2, [pc, #44]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f64:	681a      	ldr	r2, [r3, #0]
   12f66:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12f6a:	4908      	ldr	r1, [pc, #32]	; (12f8c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12f6c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12f70:	f042 0208 	orr.w	r2, r2, #8
   12f74:	601a      	str	r2, [r3, #0]
   12f76:	4623      	mov	r3, r4
   12f78:	4619      	mov	r1, r3
   12f7a:	4803      	ldr	r0, [pc, #12]	; (12f88 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   12f7c:	f000 fafc 	bl	13578 <__cyg_profile_func_exit>
  }
   12f80:	bf00      	nop
   12f82:	b002      	add	sp, #8
   12f84:	bd10      	pop	{r4, pc}
   12f86:	bf00      	nop
   12f88:	00012ef1 	.word	0x00012ef1
   12f8c:	10000078 	.word	0x10000078

00012f90 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>:
  static void ClearInterrupts()
   12f90:	b510      	push	{r4, lr}
   12f92:	b082      	sub	sp, #8
   12f94:	4674      	mov	r4, lr
   12f96:	4623      	mov	r3, r4
   12f98:	4619      	mov	r1, r3
   12f9a:	4823      	ldr	r0, [pc, #140]	; (13028 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   12f9c:	f000 fad8 	bl	13550 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   12fa0:	2302      	movs	r3, #2
   12fa2:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   12fa6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12faa:	4a20      	ldr	r2, [pc, #128]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fb0:	681a      	ldr	r2, [r3, #0]
   12fb2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12fb6:	491d      	ldr	r1, [pc, #116]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12fb8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12fbc:	f042 0201 	orr.w	r2, r2, #1
   12fc0:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   12fc2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12fc6:	4a19      	ldr	r2, [pc, #100]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12fc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fcc:	681a      	ldr	r2, [r3, #0]
   12fce:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12fd2:	4916      	ldr	r1, [pc, #88]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12fd4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12fd8:	f042 0202 	orr.w	r2, r2, #2
   12fdc:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   12fde:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12fe2:	4a12      	ldr	r2, [pc, #72]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12fe4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fe8:	681a      	ldr	r2, [r3, #0]
   12fea:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12fee:	490f      	ldr	r1, [pc, #60]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12ff0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12ff4:	f042 0204 	orr.w	r2, r2, #4
   12ff8:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   12ffa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12ffe:	4a0b      	ldr	r2, [pc, #44]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   13000:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13004:	681a      	ldr	r2, [r3, #0]
   13006:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1300a:	4908      	ldr	r1, [pc, #32]	; (1302c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   1300c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13010:	f042 0208 	orr.w	r2, r2, #8
   13014:	601a      	str	r2, [r3, #0]
   13016:	4623      	mov	r3, r4
   13018:	4619      	mov	r1, r3
   1301a:	4803      	ldr	r0, [pc, #12]	; (13028 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   1301c:	f000 faac 	bl	13578 <__cyg_profile_func_exit>
  }
   13020:	bf00      	nop
   13022:	b002      	add	sp, #8
   13024:	bd10      	pop	{r4, pc}
   13026:	bf00      	nop
   13028:	00012f91 	.word	0x00012f91
   1302c:	10000078 	.word	0x10000078

00013030 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>:
  static void ClearInterrupts()
   13030:	b510      	push	{r4, lr}
   13032:	b082      	sub	sp, #8
   13034:	4674      	mov	r4, lr
   13036:	4623      	mov	r3, r4
   13038:	4619      	mov	r1, r3
   1303a:	4823      	ldr	r0, [pc, #140]	; (130c8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   1303c:	f000 fa88 	bl	13550 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   13040:	2303      	movs	r3, #3
   13042:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   13046:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1304a:	4a20      	ldr	r2, [pc, #128]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   1304c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13050:	681a      	ldr	r2, [r3, #0]
   13052:	f89d 3007 	ldrb.w	r3, [sp, #7]
   13056:	491d      	ldr	r1, [pc, #116]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   13058:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   1305c:	f042 0201 	orr.w	r2, r2, #1
   13060:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   13062:	f89d 3007 	ldrb.w	r3, [sp, #7]
   13066:	4a19      	ldr	r2, [pc, #100]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   13068:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1306c:	681a      	ldr	r2, [r3, #0]
   1306e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   13072:	4916      	ldr	r1, [pc, #88]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   13074:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13078:	f042 0202 	orr.w	r2, r2, #2
   1307c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   1307e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   13082:	4a12      	ldr	r2, [pc, #72]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   13084:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13088:	681a      	ldr	r2, [r3, #0]
   1308a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1308e:	490f      	ldr	r1, [pc, #60]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   13090:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   13094:	f042 0204 	orr.w	r2, r2, #4
   13098:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   1309a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1309e:	4a0b      	ldr	r2, [pc, #44]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   130a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   130a4:	681a      	ldr	r2, [r3, #0]
   130a6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   130aa:	4908      	ldr	r1, [pc, #32]	; (130cc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   130ac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   130b0:	f042 0208 	orr.w	r2, r2, #8
   130b4:	601a      	str	r2, [r3, #0]
   130b6:	4623      	mov	r3, r4
   130b8:	4619      	mov	r1, r3
   130ba:	4803      	ldr	r0, [pc, #12]	; (130c8 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   130bc:	f000 fa5c 	bl	13578 <__cyg_profile_func_exit>
  }
   130c0:	bf00      	nop
   130c2:	b002      	add	sp, #8
   130c4:	bd10      	pop	{r4, pc}
   130c6:	bf00      	nop
   130c8:	00013031 	.word	0x00013031
   130cc:	10000078 	.word	0x10000078

000130d0 <__static_initialization_and_destruction_0(int, int)>:
#pragma GCC diagnostic pop
    // main() shouldn't return, but if it does, we'll just enter an infinite
    // loop
    Halt();
  }
}
   130d0:	b082      	sub	sp, #8
   130d2:	9001      	str	r0, [sp, #4]
   130d4:	9100      	str	r1, [sp, #0]
   130d6:	9b01      	ldr	r3, [sp, #4]
   130d8:	2b01      	cmp	r3, #1
   130da:	d15d      	bne.n	13198 <__static_initialization_and_destruction_0(int, int)+0xc8>
   130dc:	9b00      	ldr	r3, [sp, #0]
   130de:	f64f 72ff 	movw	r2, #65535	; 0xffff
   130e2:	4293      	cmp	r3, r2
   130e4:	d158      	bne.n	13198 <__static_initialization_and_destruction_0(int, int)+0xc8>
  inline static volatile uint32_t * match[4][4] = {
   130e6:	4b2e      	ldr	r3, [pc, #184]	; (131a0 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   130e8:	681b      	ldr	r3, [r3, #0]
   130ea:	f003 0301 	and.w	r3, r3, #1
   130ee:	2b00      	cmp	r3, #0
   130f0:	d152      	bne.n	13198 <__static_initialization_and_destruction_0(int, int)+0xc8>
   130f2:	4b2b      	ldr	r3, [pc, #172]	; (131a0 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   130f4:	2201      	movs	r2, #1
   130f6:	601a      	str	r2, [r3, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   130f8:	4b2a      	ldr	r3, [pc, #168]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   130fa:	681b      	ldr	r3, [r3, #0]
   130fc:	3318      	adds	r3, #24
  };
   130fe:	4a2a      	ldr	r2, [pc, #168]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13100:	6013      	str	r3, [r2, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   13102:	4b28      	ldr	r3, [pc, #160]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13104:	681b      	ldr	r3, [r3, #0]
   13106:	331c      	adds	r3, #28
  };
   13108:	4a27      	ldr	r2, [pc, #156]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1310a:	6053      	str	r3, [r2, #4]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   1310c:	4b25      	ldr	r3, [pc, #148]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1310e:	681b      	ldr	r3, [r3, #0]
   13110:	3320      	adds	r3, #32
  };
   13112:	4a25      	ldr	r2, [pc, #148]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13114:	6093      	str	r3, [r2, #8]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   13116:	4b23      	ldr	r3, [pc, #140]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13118:	681b      	ldr	r3, [r3, #0]
   1311a:	3324      	adds	r3, #36	; 0x24
  };
   1311c:	4a22      	ldr	r2, [pc, #136]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1311e:	60d3      	str	r3, [r2, #12]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   13120:	4b20      	ldr	r3, [pc, #128]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13122:	685b      	ldr	r3, [r3, #4]
   13124:	3318      	adds	r3, #24
  };
   13126:	4a20      	ldr	r2, [pc, #128]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13128:	6113      	str	r3, [r2, #16]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   1312a:	4b1e      	ldr	r3, [pc, #120]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1312c:	685b      	ldr	r3, [r3, #4]
   1312e:	331c      	adds	r3, #28
  };
   13130:	4a1d      	ldr	r2, [pc, #116]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13132:	6153      	str	r3, [r2, #20]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   13134:	4b1b      	ldr	r3, [pc, #108]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13136:	685b      	ldr	r3, [r3, #4]
   13138:	3320      	adds	r3, #32
  };
   1313a:	4a1b      	ldr	r2, [pc, #108]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1313c:	6193      	str	r3, [r2, #24]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   1313e:	4b19      	ldr	r3, [pc, #100]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13140:	685b      	ldr	r3, [r3, #4]
   13142:	3324      	adds	r3, #36	; 0x24
  };
   13144:	4a18      	ldr	r2, [pc, #96]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13146:	61d3      	str	r3, [r2, #28]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   13148:	4b16      	ldr	r3, [pc, #88]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1314a:	689b      	ldr	r3, [r3, #8]
   1314c:	3318      	adds	r3, #24
  };
   1314e:	4a16      	ldr	r2, [pc, #88]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13150:	6213      	str	r3, [r2, #32]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   13152:	4b14      	ldr	r3, [pc, #80]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13154:	689b      	ldr	r3, [r3, #8]
   13156:	331c      	adds	r3, #28
  };
   13158:	4a13      	ldr	r2, [pc, #76]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1315a:	6253      	str	r3, [r2, #36]	; 0x24
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   1315c:	4b11      	ldr	r3, [pc, #68]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1315e:	689b      	ldr	r3, [r3, #8]
   13160:	3320      	adds	r3, #32
  };
   13162:	4a11      	ldr	r2, [pc, #68]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13164:	6293      	str	r3, [r2, #40]	; 0x28
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   13166:	4b0f      	ldr	r3, [pc, #60]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13168:	689b      	ldr	r3, [r3, #8]
   1316a:	3324      	adds	r3, #36	; 0x24
  };
   1316c:	4a0e      	ldr	r2, [pc, #56]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1316e:	62d3      	str	r3, [r2, #44]	; 0x2c
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   13170:	4b0c      	ldr	r3, [pc, #48]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13172:	68db      	ldr	r3, [r3, #12]
   13174:	3318      	adds	r3, #24
  };
   13176:	4a0c      	ldr	r2, [pc, #48]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13178:	6313      	str	r3, [r2, #48]	; 0x30
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   1317a:	4b0a      	ldr	r3, [pc, #40]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   1317c:	68db      	ldr	r3, [r3, #12]
   1317e:	331c      	adds	r3, #28
  };
   13180:	4a09      	ldr	r2, [pc, #36]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13182:	6353      	str	r3, [r2, #52]	; 0x34
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   13184:	4b07      	ldr	r3, [pc, #28]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13186:	68db      	ldr	r3, [r3, #12]
   13188:	3320      	adds	r3, #32
  };
   1318a:	4a07      	ldr	r2, [pc, #28]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   1318c:	6393      	str	r3, [r2, #56]	; 0x38
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   1318e:	4b05      	ldr	r3, [pc, #20]	; (131a4 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   13190:	68db      	ldr	r3, [r3, #12]
   13192:	3324      	adds	r3, #36	; 0x24
  };
   13194:	4a04      	ldr	r2, [pc, #16]	; (131a8 <__static_initialization_and_destruction_0(int, int)+0xd8>)
   13196:	63d3      	str	r3, [r2, #60]	; 0x3c
   13198:	bf00      	nop
   1319a:	b002      	add	sp, #8
   1319c:	4770      	bx	lr
   1319e:	bf00      	nop
   131a0:	100005cc 	.word	0x100005cc
   131a4:	10000078 	.word	0x10000078
   131a8:	100003dc 	.word	0x100003dc

000131ac <_GLOBAL__sub_I_UptimeRTOS>:
   131ac:	b508      	push	{r3, lr}
   131ae:	f64f 71ff 	movw	r1, #65535	; 0xffff
   131b2:	2001      	movs	r0, #1
   131b4:	f7ff ff8c 	bl	130d0 <__static_initialization_and_destruction_0(int, int)>
   131b8:	bd08      	pop	{r3, pc}
   131ba:	Address 0x00000000000131ba is out of bounds.


000131bc <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   131bc:	b082      	sub	sp, #8
   131be:	4603      	mov	r3, r0
   131c0:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   131c4:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   131c8:	f003 021f 	and.w	r2, r3, #31
   131cc:	4905      	ldr	r1, [pc, #20]	; (131e4 <NVIC_EnableIRQ+0x28>)
   131ce:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   131d2:	095b      	lsrs	r3, r3, #5
   131d4:	2001      	movs	r0, #1
   131d6:	fa00 f202 	lsl.w	r2, r0, r2
   131da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   131de:	bf00      	nop
   131e0:	b002      	add	sp, #8
   131e2:	4770      	bx	lr
   131e4:	e000e100 	.word	0xe000e100

000131e8 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   131e8:	b082      	sub	sp, #8
   131ea:	4603      	mov	r3, r0
   131ec:	9100      	str	r1, [sp, #0]
   131ee:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) < 0)
   131f2:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   131f6:	2b00      	cmp	r3, #0
   131f8:	da0c      	bge.n	13214 <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   131fa:	9b00      	ldr	r3, [sp, #0]
   131fc:	b2da      	uxtb	r2, r3
   131fe:	490d      	ldr	r1, [pc, #52]	; (13234 <NVIC_SetPriority+0x4c>)
   13200:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   13204:	f003 030f 	and.w	r3, r3, #15
   13208:	3b04      	subs	r3, #4
   1320a:	0152      	lsls	r2, r2, #5
   1320c:	b2d2      	uxtb	r2, r2
   1320e:	440b      	add	r3, r1
   13210:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   13212:	e00b      	b.n	1322c <NVIC_SetPriority+0x44>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   13214:	9b00      	ldr	r3, [sp, #0]
   13216:	b2db      	uxtb	r3, r3
   13218:	4a07      	ldr	r2, [pc, #28]	; (13238 <NVIC_SetPriority+0x50>)
   1321a:	f99d 1007 	ldrsb.w	r1, [sp, #7]
   1321e:	4608      	mov	r0, r1
   13220:	015b      	lsls	r3, r3, #5
   13222:	b2d9      	uxtb	r1, r3
   13224:	1813      	adds	r3, r2, r0
   13226:	460a      	mov	r2, r1
   13228:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   1322c:	bf00      	nop
   1322e:	b002      	add	sp, #8
   13230:	4770      	bx	lr
   13232:	bf00      	nop
   13234:	e000ed00 	.word	0xe000ed00
   13238:	e000e100 	.word	0xe000e100

0001323c <InterruptLookupHandler>:
{
   1323c:	b500      	push	{lr}
   1323e:	b085      	sub	sp, #20
  uint8_t active_isr = (SCB->ICSR & 0xFF);
   13240:	4b12      	ldr	r3, [pc, #72]	; (1328c <InterruptLookupHandler+0x50>)
   13242:	685b      	ldr	r3, [r3, #4]
   13244:	f88d 300f 	strb.w	r3, [sp, #15]
  IsrPointer isr     = dynamic_isr_vector_table[active_isr];
   13248:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1324c:	4a10      	ldr	r2, [pc, #64]	; (13290 <InterruptLookupHandler+0x54>)
   1324e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13252:	9302      	str	r3, [sp, #8]
  SJ2_ASSERT_FATAL(isr != InterruptLookupHandler,
   13254:	9b02      	ldr	r3, [sp, #8]
   13256:	4a0f      	ldr	r2, [pc, #60]	; (13294 <InterruptLookupHandler+0x58>)
   13258:	4293      	cmp	r3, r2
   1325a:	d110      	bne.n	1327e <InterruptLookupHandler+0x42>
   1325c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   13260:	9300      	str	r3, [sp, #0]
   13262:	23dd      	movs	r3, #221	; 0xdd
   13264:	4a0c      	ldr	r2, [pc, #48]	; (13298 <InterruptLookupHandler+0x5c>)
   13266:	490d      	ldr	r1, [pc, #52]	; (1329c <InterruptLookupHandler+0x60>)
   13268:	480d      	ldr	r0, [pc, #52]	; (132a0 <InterruptLookupHandler+0x64>)
   1326a:	f002 ff0f 	bl	1608c <printf>
   1326e:	480d      	ldr	r0, [pc, #52]	; (132a4 <InterruptLookupHandler+0x68>)
   13270:	f000 f93e 	bl	134f0 <puts>
   13274:	2100      	movs	r1, #0
   13276:	2001      	movs	r0, #1
   13278:	f7fd fed2 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   1327c:	e7fe      	b.n	1327c <InterruptLookupHandler+0x40>
  isr();
   1327e:	9b02      	ldr	r3, [sp, #8]
   13280:	4798      	blx	r3
}
   13282:	bf00      	nop
   13284:	b005      	add	sp, #20
   13286:	f85d fb04 	ldr.w	pc, [sp], #4
   1328a:	bf00      	nop
   1328c:	e000ed00 	.word	0xe000ed00
   13290:	10000104 	.word	0x10000104
   13294:	0001323d 	.word	0x0001323d
   13298:	00019ecc 	.word	0x00019ecc
   1329c:	00019ebc 	.word	0x00019ebc
   132a0:	00019d60 	.word	0x00019d60
   132a4:	00019e0c 	.word	0x00019e0c

000132a8 <RegisterIsr(IRQn, void (*)(), bool, long)>:
{
   132a8:	b500      	push	{lr}
   132aa:	b085      	sub	sp, #20
   132ac:	9102      	str	r1, [sp, #8]
   132ae:	9301      	str	r3, [sp, #4]
   132b0:	4603      	mov	r3, r0
   132b2:	f88d 300f 	strb.w	r3, [sp, #15]
   132b6:	4613      	mov	r3, r2
   132b8:	f88d 300e 	strb.w	r3, [sp, #14]
  dynamic_isr_vector_table[irq + kIrqOffset] = isr;
   132bc:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   132c0:	3310      	adds	r3, #16
   132c2:	490f      	ldr	r1, [pc, #60]	; (13300 <RegisterIsr(IRQn, void (*)(), bool, long)+0x58>)
   132c4:	9a02      	ldr	r2, [sp, #8]
   132c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  if (enable_interrupt && irq >= 0)
   132ca:	f89d 300e 	ldrb.w	r3, [sp, #14]
   132ce:	2b00      	cmp	r3, #0
   132d0:	d008      	beq.n	132e4 <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
   132d2:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   132d6:	2b00      	cmp	r3, #0
   132d8:	db04      	blt.n	132e4 <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
    NVIC_EnableIRQ(irq);
   132da:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   132de:	4618      	mov	r0, r3
   132e0:	f7ff ff6c 	bl	131bc <NVIC_EnableIRQ>
  if (priority > -1)
   132e4:	9b01      	ldr	r3, [sp, #4]
   132e6:	2b00      	cmp	r3, #0
   132e8:	db06      	blt.n	132f8 <RegisterIsr(IRQn, void (*)(), bool, long)+0x50>
    NVIC_SetPriority(irq, priority);
   132ea:	9a01      	ldr	r2, [sp, #4]
   132ec:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   132f0:	4611      	mov	r1, r2
   132f2:	4618      	mov	r0, r3
   132f4:	f7ff ff78 	bl	131e8 <NVIC_SetPriority>
}
   132f8:	bf00      	nop
   132fa:	b005      	add	sp, #20
   132fc:	f85d fb04 	ldr.w	pc, [sp], #4
   13300:	10000104 	.word	0x10000104

00013304 <GetRegistersFromStack>:
{
   13304:	b500      	push	{lr}
   13306:	b08d      	sub	sp, #52	; 0x34
   13308:	9003      	str	r0, [sp, #12]
  volatile uint32_t r0  = fault_stack_address[0];
   1330a:	9b03      	ldr	r3, [sp, #12]
   1330c:	681b      	ldr	r3, [r3, #0]
   1330e:	930b      	str	r3, [sp, #44]	; 0x2c
  volatile uint32_t r1  = fault_stack_address[1];
   13310:	9b03      	ldr	r3, [sp, #12]
   13312:	685b      	ldr	r3, [r3, #4]
   13314:	930a      	str	r3, [sp, #40]	; 0x28
  volatile uint32_t r2  = fault_stack_address[2];
   13316:	9b03      	ldr	r3, [sp, #12]
   13318:	689b      	ldr	r3, [r3, #8]
   1331a:	9309      	str	r3, [sp, #36]	; 0x24
  volatile uint32_t r3  = fault_stack_address[3];
   1331c:	9b03      	ldr	r3, [sp, #12]
   1331e:	68db      	ldr	r3, [r3, #12]
   13320:	9308      	str	r3, [sp, #32]
  volatile uint32_t r12 = fault_stack_address[4];
   13322:	9b03      	ldr	r3, [sp, #12]
   13324:	691b      	ldr	r3, [r3, #16]
   13326:	9307      	str	r3, [sp, #28]
  volatile uint32_t lr = fault_stack_address[5];
   13328:	9b03      	ldr	r3, [sp, #12]
   1332a:	695b      	ldr	r3, [r3, #20]
   1332c:	9306      	str	r3, [sp, #24]
  volatile uint32_t pc = fault_stack_address[6];
   1332e:	9b03      	ldr	r3, [sp, #12]
   13330:	699b      	ldr	r3, [r3, #24]
   13332:	9305      	str	r3, [sp, #20]
  volatile uint32_t psr = fault_stack_address[7];
   13334:	9b03      	ldr	r3, [sp, #12]
   13336:	69db      	ldr	r3, [r3, #28]
   13338:	9304      	str	r3, [sp, #16]
  printf(SJ2_BACKGROUND_RED "Hard Fault Exception Occurred!\n" SJ2_COLOR_RESET);
   1333a:	480d      	ldr	r0, [pc, #52]	; (13370 <GetRegistersFromStack+0x6c>)
   1333c:	f002 fea6 	bl	1608c <printf>
  printf("r0: 0x%08" PRIX32 ", r1: 0x%08" PRIX32
   13340:	990b      	ldr	r1, [sp, #44]	; 0x2c
   13342:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   13344:	9809      	ldr	r0, [sp, #36]	; 0x24
   13346:	9b08      	ldr	r3, [sp, #32]
   13348:	9300      	str	r3, [sp, #0]
   1334a:	4603      	mov	r3, r0
   1334c:	4809      	ldr	r0, [pc, #36]	; (13374 <GetRegistersFromStack+0x70>)
   1334e:	f002 fe9d 	bl	1608c <printf>
  printf("r12: 0x%08" PRIX32 ", lr: 0x%08" PRIX32
   13352:	9907      	ldr	r1, [sp, #28]
   13354:	9a06      	ldr	r2, [sp, #24]
   13356:	9805      	ldr	r0, [sp, #20]
   13358:	9b04      	ldr	r3, [sp, #16]
   1335a:	9300      	str	r3, [sp, #0]
   1335c:	4603      	mov	r3, r0
   1335e:	4806      	ldr	r0, [pc, #24]	; (13378 <GetRegistersFromStack+0x74>)
   13360:	f002 fe94 	bl	1608c <printf>
  debug::PrintBacktrace(true, reinterpret_cast<void *>(pc));
   13364:	9b05      	ldr	r3, [sp, #20]
   13366:	4619      	mov	r1, r3
   13368:	2001      	movs	r0, #1
   1336a:	f7fd fe59 	bl	11020 <debug::PrintBacktrace(bool, void*)>
   1336e:	e7fe      	b.n	1336e <GetRegistersFromStack+0x6a>
   13370:	00019e24 	.word	0x00019e24
   13374:	00019e50 	.word	0x00019e50
   13378:	00019e84 	.word	0x00019e84

0001337c <FirmwareStdOut(int)>:
}
Stdout out = HostWrite;
Stdin in   = HostRead;
#else
int FirmwareStdOut(int data)
{
   1337c:	b530      	push	{r4, r5, lr}
   1337e:	b083      	sub	sp, #12
   13380:	4675      	mov	r5, lr
   13382:	9001      	str	r0, [sp, #4]
   13384:	462b      	mov	r3, r5
   13386:	4619      	mov	r1, r3
   13388:	4809      	ldr	r0, [pc, #36]	; (133b0 <FirmwareStdOut(int)+0x34>)
   1338a:	f000 f8e1 	bl	13550 <__cyg_profile_func_enter>
  uart0.Send(static_cast<uint8_t>(data));
   1338e:	9b01      	ldr	r3, [sp, #4]
   13390:	b2db      	uxtb	r3, r3
   13392:	4619      	mov	r1, r3
   13394:	4807      	ldr	r0, [pc, #28]	; (133b4 <FirmwareStdOut(int)+0x38>)
   13396:	f7fe ffef 	bl	12378 <Uart::Send(unsigned char)>
  return 1;
   1339a:	2401      	movs	r4, #1
   1339c:	462b      	mov	r3, r5
   1339e:	4619      	mov	r1, r3
   133a0:	4803      	ldr	r0, [pc, #12]	; (133b0 <FirmwareStdOut(int)+0x34>)
   133a2:	f000 f8e9 	bl	13578 <__cyg_profile_func_exit>
   133a6:	4623      	mov	r3, r4
}
   133a8:	4618      	mov	r0, r3
   133aa:	b003      	add	sp, #12
   133ac:	bd30      	pop	{r4, r5, pc}
   133ae:	bf00      	nop
   133b0:	0001337d 	.word	0x0001337d
   133b4:	100000d8 	.word	0x100000d8

000133b8 <_exit>:
  }
  // Dummy implementation of exit with return code placed into
  // Arm register r3
  // NOLINTNEXTLINE(readability-identifier-naming)
  void _exit([[maybe_unused]] int rc)
  {
   133b8:	b500      	push	{lr}
   133ba:	b083      	sub	sp, #12
   133bc:	4673      	mov	r3, lr
   133be:	9001      	str	r0, [sp, #4]
   133c0:	4619      	mov	r1, r3
   133c2:	4802      	ldr	r0, [pc, #8]	; (133cc <_exit+0x14>)
   133c4:	f000 f8c4 	bl	13550 <__cyg_profile_func_enter>
    while (1)
    {
      continue;
   133c8:	bf00      	nop
    while (1)
   133ca:	e7fd      	b.n	133c8 <_exit+0x10>
   133cc:	000133b9 	.word	0x000133b9

000133d0 <_getpid>:
    }
  }
  // Dummy implementation of getpid
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _getpid()
  {
   133d0:	b538      	push	{r3, r4, r5, lr}
   133d2:	4675      	mov	r5, lr
   133d4:	462b      	mov	r3, r5
   133d6:	4619      	mov	r1, r3
   133d8:	4805      	ldr	r0, [pc, #20]	; (133f0 <_getpid+0x20>)
   133da:	f000 f8b9 	bl	13550 <__cyg_profile_func_enter>
    return 1;
   133de:	2401      	movs	r4, #1
   133e0:	462b      	mov	r3, r5
   133e2:	4619      	mov	r1, r3
   133e4:	4802      	ldr	r0, [pc, #8]	; (133f0 <_getpid+0x20>)
   133e6:	f000 f8c7 	bl	13578 <__cyg_profile_func_exit>
   133ea:	4623      	mov	r3, r4
  }
   133ec:	4618      	mov	r0, r3
   133ee:	bd38      	pop	{r3, r4, r5, pc}
   133f0:	000133d1 	.word	0x000133d1

000133f4 <_kill>:
  // Dummy implementation of kill
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _kill(int, int)
  {
   133f4:	b530      	push	{r4, r5, lr}
   133f6:	b083      	sub	sp, #12
   133f8:	4675      	mov	r5, lr
   133fa:	9001      	str	r0, [sp, #4]
   133fc:	9100      	str	r1, [sp, #0]
   133fe:	462b      	mov	r3, r5
   13400:	4619      	mov	r1, r3
   13402:	4807      	ldr	r0, [pc, #28]	; (13420 <_kill+0x2c>)
   13404:	f000 f8a4 	bl	13550 <__cyg_profile_func_enter>
    return -1;
   13408:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1340c:	462b      	mov	r3, r5
   1340e:	4619      	mov	r1, r3
   13410:	4803      	ldr	r0, [pc, #12]	; (13420 <_kill+0x2c>)
   13412:	f000 f8b1 	bl	13578 <__cyg_profile_func_exit>
   13416:	4623      	mov	r3, r4
  }
   13418:	4618      	mov	r0, r3
   1341a:	b003      	add	sp, #12
   1341c:	bd30      	pop	{r4, r5, pc}
   1341e:	bf00      	nop
   13420:	000133f5 	.word	0x000133f5

00013424 <_sbrk>:
    return 0;
  }
  // Implementation of sbrk for allocating and deallocating space for malloc.
  // NOLINTNEXTLINE(readability-identifier-naming)
  void * _sbrk(int increment)
  {
   13424:	b530      	push	{r4, r5, lr}
   13426:	b085      	sub	sp, #20
   13428:	4675      	mov	r5, lr
   1342a:	9001      	str	r0, [sp, #4]
   1342c:	462b      	mov	r3, r5
   1342e:	4619      	mov	r1, r3
   13430:	480f      	ldr	r0, [pc, #60]	; (13470 <_sbrk+0x4c>)
   13432:	f000 f88d 	bl	13550 <__cyg_profile_func_enter>
    void * previous_heap_position  = static_cast<void *>(heap_position);
   13436:	4b0f      	ldr	r3, [pc, #60]	; (13474 <_sbrk+0x50>)
   13438:	681b      	ldr	r3, [r3, #0]
   1343a:	9303      	str	r3, [sp, #12]
    // Check that by allocating this space, we do not exceed the heap area.
    if ((heap_position + increment) > &heap_end)
   1343c:	4b0d      	ldr	r3, [pc, #52]	; (13474 <_sbrk+0x50>)
   1343e:	681a      	ldr	r2, [r3, #0]
   13440:	9b01      	ldr	r3, [sp, #4]
   13442:	4413      	add	r3, r2
   13444:	4a0c      	ldr	r2, [pc, #48]	; (13478 <_sbrk+0x54>)
   13446:	4293      	cmp	r3, r2
   13448:	d901      	bls.n	1344e <_sbrk+0x2a>
    {
      previous_heap_position = nullptr;
   1344a:	2300      	movs	r3, #0
   1344c:	9303      	str	r3, [sp, #12]
    }
    heap_position += increment;
   1344e:	4b09      	ldr	r3, [pc, #36]	; (13474 <_sbrk+0x50>)
   13450:	681a      	ldr	r2, [r3, #0]
   13452:	9b01      	ldr	r3, [sp, #4]
   13454:	4413      	add	r3, r2
   13456:	4a07      	ldr	r2, [pc, #28]	; (13474 <_sbrk+0x50>)
   13458:	6013      	str	r3, [r2, #0]
    return previous_heap_position;
   1345a:	9c03      	ldr	r4, [sp, #12]
   1345c:	462b      	mov	r3, r5
   1345e:	4619      	mov	r1, r3
   13460:	4803      	ldr	r0, [pc, #12]	; (13470 <_sbrk+0x4c>)
   13462:	f000 f889 	bl	13578 <__cyg_profile_func_exit>
   13466:	4623      	mov	r3, r4
  }
   13468:	4618      	mov	r0, r3
   1346a:	b005      	add	sp, #20
   1346c:	bd30      	pop	{r4, r5, pc}
   1346e:	bf00      	nop
   13470:	00013425 	.word	0x00013425
   13474:	100001e8 	.word	0x100001e8
   13478:	20008000 	.word	0x20008000

0001347c <_putchar>:
    }
    return length;
  }
  // Needed by third party printf library
  void _putchar(char character)  // NOLINT
  {
   1347c:	b510      	push	{r4, lr}
   1347e:	b082      	sub	sp, #8
   13480:	4674      	mov	r4, lr
   13482:	4603      	mov	r3, r0
   13484:	f88d 3007 	strb.w	r3, [sp, #7]
   13488:	4623      	mov	r3, r4
   1348a:	4619      	mov	r1, r3
   1348c:	4808      	ldr	r0, [pc, #32]	; (134b0 <_putchar+0x34>)
   1348e:	f000 f85f 	bl	13550 <__cyg_profile_func_enter>
    out(character);
   13492:	4b08      	ldr	r3, [pc, #32]	; (134b4 <_putchar+0x38>)
   13494:	681b      	ldr	r3, [r3, #0]
   13496:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1349a:	4610      	mov	r0, r2
   1349c:	4798      	blx	r3
   1349e:	4623      	mov	r3, r4
   134a0:	4619      	mov	r1, r3
   134a2:	4803      	ldr	r0, [pc, #12]	; (134b0 <_putchar+0x34>)
   134a4:	f000 f868 	bl	13578 <__cyg_profile_func_exit>
  }
   134a8:	bf00      	nop
   134aa:	b002      	add	sp, #8
   134ac:	bd10      	pop	{r4, pc}
   134ae:	bf00      	nop
   134b0:	0001347d 	.word	0x0001347d
   134b4:	100001ec 	.word	0x100001ec

000134b8 <putchar>:

  // Overload default libnano putchar() with a more optimal version that does
  // not use dynamic memory
  int putchar(int character)  // NOLINT
  {
   134b8:	b530      	push	{r4, r5, lr}
   134ba:	b083      	sub	sp, #12
   134bc:	4674      	mov	r4, lr
   134be:	9001      	str	r0, [sp, #4]
   134c0:	4623      	mov	r3, r4
   134c2:	4619      	mov	r1, r3
   134c4:	4808      	ldr	r0, [pc, #32]	; (134e8 <putchar+0x30>)
   134c6:	f000 f843 	bl	13550 <__cyg_profile_func_enter>
    return out(character);
   134ca:	4b08      	ldr	r3, [pc, #32]	; (134ec <putchar+0x34>)
   134cc:	681b      	ldr	r3, [r3, #0]
   134ce:	9801      	ldr	r0, [sp, #4]
   134d0:	4798      	blx	r3
   134d2:	4605      	mov	r5, r0
   134d4:	4623      	mov	r3, r4
   134d6:	4619      	mov	r1, r3
   134d8:	4803      	ldr	r0, [pc, #12]	; (134e8 <putchar+0x30>)
   134da:	f000 f84d 	bl	13578 <__cyg_profile_func_exit>
   134de:	462b      	mov	r3, r5
  }
   134e0:	4618      	mov	r0, r3
   134e2:	b003      	add	sp, #12
   134e4:	bd30      	pop	{r4, r5, pc}
   134e6:	bf00      	nop
   134e8:	000134b9 	.word	0x000134b9
   134ec:	100001ec 	.word	0x100001ec

000134f0 <puts>:

  // Overload default libnano puts() with a more optimal version that does
  // not use dynamic memory
  int puts(const char * str)  // NOLINT
  {
   134f0:	b530      	push	{r4, r5, lr}
   134f2:	b085      	sub	sp, #20
   134f4:	4675      	mov	r5, lr
   134f6:	9001      	str	r0, [sp, #4]
   134f8:	462b      	mov	r3, r5
   134fa:	4619      	mov	r1, r3
   134fc:	4812      	ldr	r0, [pc, #72]	; (13548 <puts+0x58>)
   134fe:	f000 f827 	bl	13550 <__cyg_profile_func_enter>
    int i;
    for (i = 0; str[i] != '\0'; i++)
   13502:	2300      	movs	r3, #0
   13504:	9303      	str	r3, [sp, #12]
   13506:	9b03      	ldr	r3, [sp, #12]
   13508:	9a01      	ldr	r2, [sp, #4]
   1350a:	4413      	add	r3, r2
   1350c:	781b      	ldrb	r3, [r3, #0]
   1350e:	2b00      	cmp	r3, #0
   13510:	d00b      	beq.n	1352a <puts+0x3a>
    {
      out(str[i]);
   13512:	4b0e      	ldr	r3, [pc, #56]	; (1354c <puts+0x5c>)
   13514:	681b      	ldr	r3, [r3, #0]
   13516:	9a03      	ldr	r2, [sp, #12]
   13518:	9901      	ldr	r1, [sp, #4]
   1351a:	440a      	add	r2, r1
   1351c:	7812      	ldrb	r2, [r2, #0]
   1351e:	4610      	mov	r0, r2
   13520:	4798      	blx	r3
    for (i = 0; str[i] != '\0'; i++)
   13522:	9b03      	ldr	r3, [sp, #12]
   13524:	3301      	adds	r3, #1
   13526:	9303      	str	r3, [sp, #12]
   13528:	e7ed      	b.n	13506 <puts+0x16>
    }
    out('\n');
   1352a:	4b08      	ldr	r3, [pc, #32]	; (1354c <puts+0x5c>)
   1352c:	681b      	ldr	r3, [r3, #0]
   1352e:	200a      	movs	r0, #10
   13530:	4798      	blx	r3
    return i;
   13532:	9c03      	ldr	r4, [sp, #12]
   13534:	462b      	mov	r3, r5
   13536:	4619      	mov	r1, r3
   13538:	4803      	ldr	r0, [pc, #12]	; (13548 <puts+0x58>)
   1353a:	f000 f81d 	bl	13578 <__cyg_profile_func_exit>
   1353e:	4623      	mov	r3, r4
  }
   13540:	4618      	mov	r0, r3
   13542:	b005      	add	sp, #20
   13544:	bd30      	pop	{r4, r5, pc}
   13546:	bf00      	nop
   13548:	000134f1 	.word	0x000134f1
   1354c:	100001ec 	.word	0x100001ec

00013550 <__cyg_profile_func_enter>:
  // =============================
  void * stack_trace[config::kBacktraceDepth] = { nullptr };
  size_t stack_depth = 0;

  void __cyg_profile_func_enter(void *, void * call_site)  // NOLINT
  {
   13550:	b082      	sub	sp, #8
   13552:	9001      	str	r0, [sp, #4]
   13554:	9100      	str	r1, [sp, #0]
    stack_trace[stack_depth++] = call_site;
   13556:	9a00      	ldr	r2, [sp, #0]
   13558:	4b05      	ldr	r3, [pc, #20]	; (13570 <__cyg_profile_func_enter+0x20>)
   1355a:	681b      	ldr	r3, [r3, #0]
   1355c:	1c59      	adds	r1, r3, #1
   1355e:	4804      	ldr	r0, [pc, #16]	; (13570 <__cyg_profile_func_enter+0x20>)
   13560:	6001      	str	r1, [r0, #0]
   13562:	4904      	ldr	r1, [pc, #16]	; (13574 <__cyg_profile_func_enter+0x24>)
   13564:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
   13568:	bf00      	nop
   1356a:	b002      	add	sp, #8
   1356c:	4770      	bx	lr
   1356e:	bf00      	nop
   13570:	100006d0 	.word	0x100006d0
   13574:	100005d0 	.word	0x100005d0

00013578 <__cyg_profile_func_exit>:

  void __cyg_profile_func_exit(void *, void *)  // NOLINT
  {
   13578:	b082      	sub	sp, #8
   1357a:	9001      	str	r0, [sp, #4]
   1357c:	9100      	str	r1, [sp, #0]
    stack_depth--;
   1357e:	4b04      	ldr	r3, [pc, #16]	; (13590 <__cyg_profile_func_exit+0x18>)
   13580:	681b      	ldr	r3, [r3, #0]
   13582:	3b01      	subs	r3, #1
   13584:	4a02      	ldr	r2, [pc, #8]	; (13590 <__cyg_profile_func_exit+0x18>)
   13586:	6013      	str	r3, [r2, #0]
  }
   13588:	bf00      	nop
   1358a:	b002      	add	sp, #8
   1358c:	4770      	bx	lr
   1358e:	bf00      	nop
   13590:	100006d0 	.word	0x100006d0

00013594 <GetStackTrace()>:
}

void ** GetStackTrace()
{
   13594:	b538      	push	{r3, r4, r5, lr}
   13596:	4675      	mov	r5, lr
   13598:	462b      	mov	r3, r5
   1359a:	4619      	mov	r1, r3
   1359c:	4805      	ldr	r0, [pc, #20]	; (135b4 <GetStackTrace()+0x20>)
   1359e:	f7ff ffd7 	bl	13550 <__cyg_profile_func_enter>
  return stack_trace;
   135a2:	4c05      	ldr	r4, [pc, #20]	; (135b8 <GetStackTrace()+0x24>)
   135a4:	462b      	mov	r3, r5
   135a6:	4619      	mov	r1, r3
   135a8:	4802      	ldr	r0, [pc, #8]	; (135b4 <GetStackTrace()+0x20>)
   135aa:	f7ff ffe5 	bl	13578 <__cyg_profile_func_exit>
   135ae:	4623      	mov	r3, r4
}
   135b0:	4618      	mov	r0, r3
   135b2:	bd38      	pop	{r3, r4, r5, pc}
   135b4:	00013595 	.word	0x00013595
   135b8:	100005d0 	.word	0x100005d0

000135bc <GetStackDepth()>:

size_t GetStackDepth()
{
   135bc:	b538      	push	{r3, r4, r5, lr}
   135be:	4675      	mov	r5, lr
   135c0:	462b      	mov	r3, r5
   135c2:	4619      	mov	r1, r3
   135c4:	4806      	ldr	r0, [pc, #24]	; (135e0 <GetStackDepth()+0x24>)
   135c6:	f7ff ffc3 	bl	13550 <__cyg_profile_func_enter>
  return stack_depth;
   135ca:	4b06      	ldr	r3, [pc, #24]	; (135e4 <GetStackDepth()+0x28>)
   135cc:	681c      	ldr	r4, [r3, #0]
   135ce:	462b      	mov	r3, r5
   135d0:	4619      	mov	r1, r3
   135d2:	4803      	ldr	r0, [pc, #12]	; (135e0 <GetStackDepth()+0x24>)
   135d4:	f7ff ffd0 	bl	13578 <__cyg_profile_func_exit>
   135d8:	4623      	mov	r3, r4
}
   135da:	4618      	mov	r0, r3
   135dc:	bd38      	pop	{r3, r4, r5, pc}
   135de:	bf00      	nop
   135e0:	000135bd 	.word	0x000135bd
   135e4:	100006d0 	.word	0x100006d0

000135e8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   135e8:	b082      	sub	sp, #8
   135ea:	9001      	str	r0, [sp, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   135ec:	9b01      	ldr	r3, [sp, #4]
   135ee:	f103 0208 	add.w	r2, r3, #8
   135f2:	9b01      	ldr	r3, [sp, #4]
   135f4:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   135f6:	9b01      	ldr	r3, [sp, #4]
   135f8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   135fc:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   135fe:	9b01      	ldr	r3, [sp, #4]
   13600:	f103 0208 	add.w	r2, r3, #8
   13604:	9b01      	ldr	r3, [sp, #4]
   13606:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   13608:	9b01      	ldr	r3, [sp, #4]
   1360a:	f103 0208 	add.w	r2, r3, #8
   1360e:	9b01      	ldr	r3, [sp, #4]
   13610:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   13612:	9b01      	ldr	r3, [sp, #4]
   13614:	2200      	movs	r2, #0
   13616:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   13618:	bf00      	nop
   1361a:	b002      	add	sp, #8
   1361c:	4770      	bx	lr

0001361e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   1361e:	b082      	sub	sp, #8
   13620:	9001      	str	r0, [sp, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   13622:	9b01      	ldr	r3, [sp, #4]
   13624:	2200      	movs	r2, #0
   13626:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   13628:	bf00      	nop
   1362a:	b002      	add	sp, #8
   1362c:	4770      	bx	lr

0001362e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   1362e:	b084      	sub	sp, #16
   13630:	9001      	str	r0, [sp, #4]
   13632:	9100      	str	r1, [sp, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   13634:	9b01      	ldr	r3, [sp, #4]
   13636:	685b      	ldr	r3, [r3, #4]
   13638:	9303      	str	r3, [sp, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   1363a:	9b00      	ldr	r3, [sp, #0]
   1363c:	9a03      	ldr	r2, [sp, #12]
   1363e:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   13640:	9b03      	ldr	r3, [sp, #12]
   13642:	689a      	ldr	r2, [r3, #8]
   13644:	9b00      	ldr	r3, [sp, #0]
   13646:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   13648:	9b03      	ldr	r3, [sp, #12]
   1364a:	689b      	ldr	r3, [r3, #8]
   1364c:	9a00      	ldr	r2, [sp, #0]
   1364e:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   13650:	9b03      	ldr	r3, [sp, #12]
   13652:	9a00      	ldr	r2, [sp, #0]
   13654:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   13656:	9b00      	ldr	r3, [sp, #0]
   13658:	9a01      	ldr	r2, [sp, #4]
   1365a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   1365c:	9b01      	ldr	r3, [sp, #4]
   1365e:	681b      	ldr	r3, [r3, #0]
   13660:	1c5a      	adds	r2, r3, #1
   13662:	9b01      	ldr	r3, [sp, #4]
   13664:	601a      	str	r2, [r3, #0]
}
   13666:	bf00      	nop
   13668:	b004      	add	sp, #16
   1366a:	4770      	bx	lr

0001366c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   1366c:	b084      	sub	sp, #16
   1366e:	9001      	str	r0, [sp, #4]
   13670:	9100      	str	r1, [sp, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   13672:	9b00      	ldr	r3, [sp, #0]
   13674:	681b      	ldr	r3, [r3, #0]
   13676:	9302      	str	r3, [sp, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   13678:	9b02      	ldr	r3, [sp, #8]
   1367a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1367e:	d103      	bne.n	13688 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   13680:	9b01      	ldr	r3, [sp, #4]
   13682:	691b      	ldr	r3, [r3, #16]
   13684:	9303      	str	r3, [sp, #12]
   13686:	e00c      	b.n	136a2 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   13688:	9b01      	ldr	r3, [sp, #4]
   1368a:	3308      	adds	r3, #8
   1368c:	9303      	str	r3, [sp, #12]
   1368e:	e002      	b.n	13696 <vListInsert+0x2a>
   13690:	9b03      	ldr	r3, [sp, #12]
   13692:	685b      	ldr	r3, [r3, #4]
   13694:	9303      	str	r3, [sp, #12]
   13696:	9b03      	ldr	r3, [sp, #12]
   13698:	685b      	ldr	r3, [r3, #4]
   1369a:	681b      	ldr	r3, [r3, #0]
   1369c:	9a02      	ldr	r2, [sp, #8]
   1369e:	429a      	cmp	r2, r3
   136a0:	d2f6      	bcs.n	13690 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   136a2:	9b03      	ldr	r3, [sp, #12]
   136a4:	685a      	ldr	r2, [r3, #4]
   136a6:	9b00      	ldr	r3, [sp, #0]
   136a8:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   136aa:	9b00      	ldr	r3, [sp, #0]
   136ac:	685b      	ldr	r3, [r3, #4]
   136ae:	9a00      	ldr	r2, [sp, #0]
   136b0:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   136b2:	9b00      	ldr	r3, [sp, #0]
   136b4:	9a03      	ldr	r2, [sp, #12]
   136b6:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   136b8:	9b03      	ldr	r3, [sp, #12]
   136ba:	9a00      	ldr	r2, [sp, #0]
   136bc:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   136be:	9b00      	ldr	r3, [sp, #0]
   136c0:	9a01      	ldr	r2, [sp, #4]
   136c2:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   136c4:	9b01      	ldr	r3, [sp, #4]
   136c6:	681b      	ldr	r3, [r3, #0]
   136c8:	1c5a      	adds	r2, r3, #1
   136ca:	9b01      	ldr	r3, [sp, #4]
   136cc:	601a      	str	r2, [r3, #0]
}
   136ce:	bf00      	nop
   136d0:	b004      	add	sp, #16
   136d2:	4770      	bx	lr

000136d4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   136d4:	b084      	sub	sp, #16
   136d6:	9001      	str	r0, [sp, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   136d8:	9b01      	ldr	r3, [sp, #4]
   136da:	691b      	ldr	r3, [r3, #16]
   136dc:	9303      	str	r3, [sp, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   136de:	9b01      	ldr	r3, [sp, #4]
   136e0:	685b      	ldr	r3, [r3, #4]
   136e2:	9a01      	ldr	r2, [sp, #4]
   136e4:	6892      	ldr	r2, [r2, #8]
   136e6:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   136e8:	9b01      	ldr	r3, [sp, #4]
   136ea:	689b      	ldr	r3, [r3, #8]
   136ec:	9a01      	ldr	r2, [sp, #4]
   136ee:	6852      	ldr	r2, [r2, #4]
   136f0:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   136f2:	9b03      	ldr	r3, [sp, #12]
   136f4:	685b      	ldr	r3, [r3, #4]
   136f6:	9a01      	ldr	r2, [sp, #4]
   136f8:	429a      	cmp	r2, r3
   136fa:	d103      	bne.n	13704 <uxListRemove+0x30>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   136fc:	9b01      	ldr	r3, [sp, #4]
   136fe:	689a      	ldr	r2, [r3, #8]
   13700:	9b03      	ldr	r3, [sp, #12]
   13702:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   13704:	9b01      	ldr	r3, [sp, #4]
   13706:	2200      	movs	r2, #0
   13708:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   1370a:	9b03      	ldr	r3, [sp, #12]
   1370c:	681b      	ldr	r3, [r3, #0]
   1370e:	1e5a      	subs	r2, r3, #1
   13710:	9b03      	ldr	r3, [sp, #12]
   13712:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   13714:	9b03      	ldr	r3, [sp, #12]
   13716:	681b      	ldr	r3, [r3, #0]
}
   13718:	4618      	mov	r0, r3
   1371a:	b004      	add	sp, #16
   1371c:	4770      	bx	lr

0001371e <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
   1371e:	b500      	push	{lr}
   13720:	b08b      	sub	sp, #44	; 0x2c
   13722:	9007      	str	r0, [sp, #28]
   13724:	9106      	str	r1, [sp, #24]
   13726:	9205      	str	r2, [sp, #20]
   13728:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
   1372a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1372c:	2b00      	cmp	r3, #0
   1372e:	d01d      	beq.n	1376c <xTaskCreateStatic+0x4e>
   13730:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   13732:	2b00      	cmp	r3, #0
   13734:	d01a      	beq.n	1376c <xTaskCreateStatic+0x4e>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
   13736:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   13738:	9309      	str	r3, [sp, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
   1373a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1373c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1373e:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
   13740:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13742:	2202      	movs	r2, #2
   13744:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
   13748:	2300      	movs	r3, #0
   1374a:	9303      	str	r3, [sp, #12]
   1374c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1374e:	9302      	str	r3, [sp, #8]
   13750:	ab08      	add	r3, sp, #32
   13752:	9301      	str	r3, [sp, #4]
   13754:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   13756:	9300      	str	r3, [sp, #0]
   13758:	9b04      	ldr	r3, [sp, #16]
   1375a:	9a05      	ldr	r2, [sp, #20]
   1375c:	9906      	ldr	r1, [sp, #24]
   1375e:	9807      	ldr	r0, [sp, #28]
   13760:	f000 f852 	bl	13808 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   13764:	9809      	ldr	r0, [sp, #36]	; 0x24
   13766:	f000 f8c9 	bl	138fc <prvAddNewTaskToReadyList>
   1376a:	e001      	b.n	13770 <xTaskCreateStatic+0x52>
		}
		else
		{
			xReturn = NULL;
   1376c:	2300      	movs	r3, #0
   1376e:	9308      	str	r3, [sp, #32]
		}

		return xReturn;
   13770:	9b08      	ldr	r3, [sp, #32]
	}
   13772:	4618      	mov	r0, r3
   13774:	b00b      	add	sp, #44	; 0x2c
   13776:	f85d fb04 	ldr.w	pc, [sp], #4

0001377a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   1377a:	b500      	push	{lr}
   1377c:	b08d      	sub	sp, #52	; 0x34
   1377e:	9007      	str	r0, [sp, #28]
   13780:	9106      	str	r1, [sp, #24]
   13782:	9304      	str	r3, [sp, #16]
   13784:	4613      	mov	r3, r2
   13786:	f8ad 3016 	strh.w	r3, [sp, #22]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1378a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1378e:	009b      	lsls	r3, r3, #2
   13790:	4618      	mov	r0, r3
   13792:	f001 fafb 	bl	14d8c <pvPortMalloc>
   13796:	9009      	str	r0, [sp, #36]	; 0x24

			if( pxStack != NULL )
   13798:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1379a:	2b00      	cmp	r3, #0
   1379c:	d00e      	beq.n	137bc <xTaskCreate+0x42>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   1379e:	2060      	movs	r0, #96	; 0x60
   137a0:	f001 faf4 	bl	14d8c <pvPortMalloc>
   137a4:	900b      	str	r0, [sp, #44]	; 0x2c

				if( pxNewTCB != NULL )
   137a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   137a8:	2b00      	cmp	r3, #0
   137aa:	d003      	beq.n	137b4 <xTaskCreate+0x3a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   137ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   137ae:	9a09      	ldr	r2, [sp, #36]	; 0x24
   137b0:	631a      	str	r2, [r3, #48]	; 0x30
   137b2:	e005      	b.n	137c0 <xTaskCreate+0x46>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   137b4:	9809      	ldr	r0, [sp, #36]	; 0x24
   137b6:	f001 fafa 	bl	14dae <vPortFree>
   137ba:	e001      	b.n	137c0 <xTaskCreate+0x46>
				}
			}
			else
			{
				pxNewTCB = NULL;
   137bc:	2300      	movs	r3, #0
   137be:	930b      	str	r3, [sp, #44]	; 0x2c
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   137c0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   137c2:	2b00      	cmp	r3, #0
   137c4:	d018      	beq.n	137f8 <xTaskCreate+0x7e>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
   137c6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   137c8:	2200      	movs	r2, #0
   137ca:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   137ce:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   137d2:	2300      	movs	r3, #0
   137d4:	9303      	str	r3, [sp, #12]
   137d6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   137d8:	9302      	str	r3, [sp, #8]
   137da:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   137dc:	9301      	str	r3, [sp, #4]
   137de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   137e0:	9300      	str	r3, [sp, #0]
   137e2:	9b04      	ldr	r3, [sp, #16]
   137e4:	9906      	ldr	r1, [sp, #24]
   137e6:	9807      	ldr	r0, [sp, #28]
   137e8:	f000 f80e 	bl	13808 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   137ec:	980b      	ldr	r0, [sp, #44]	; 0x2c
   137ee:	f000 f885 	bl	138fc <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   137f2:	2301      	movs	r3, #1
   137f4:	930a      	str	r3, [sp, #40]	; 0x28
   137f6:	e002      	b.n	137fe <xTaskCreate+0x84>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   137f8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   137fc:	930a      	str	r3, [sp, #40]	; 0x28
		}

		return xReturn;
   137fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	}
   13800:	4618      	mov	r0, r3
   13802:	b00d      	add	sp, #52	; 0x34
   13804:	f85d fb04 	ldr.w	pc, [sp], #4

00013808 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   13808:	b500      	push	{lr}
   1380a:	b087      	sub	sp, #28
   1380c:	9003      	str	r0, [sp, #12]
   1380e:	9102      	str	r1, [sp, #8]
   13810:	9201      	str	r2, [sp, #4]
   13812:	9300      	str	r3, [sp, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   13814:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13816:	6b18      	ldr	r0, [r3, #48]	; 0x30
   13818:	9b01      	ldr	r3, [sp, #4]
   1381a:	009b      	lsls	r3, r3, #2
   1381c:	461a      	mov	r2, r3
   1381e:	21a5      	movs	r1, #165	; 0xa5
   13820:	f005 facb 	bl	18dba <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   13824:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13826:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   13828:	9b01      	ldr	r3, [sp, #4]
   1382a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1382e:	3b01      	subs	r3, #1
   13830:	009b      	lsls	r3, r3, #2
   13832:	4413      	add	r3, r2
   13834:	9304      	str	r3, [sp, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   13836:	9b04      	ldr	r3, [sp, #16]
   13838:	f023 0307 	bic.w	r3, r3, #7
   1383c:	9304      	str	r3, [sp, #16]
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   1383e:	2300      	movs	r3, #0
   13840:	9305      	str	r3, [sp, #20]
   13842:	e012      	b.n	1386a <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   13844:	9a02      	ldr	r2, [sp, #8]
   13846:	9b05      	ldr	r3, [sp, #20]
   13848:	4413      	add	r3, r2
   1384a:	7819      	ldrb	r1, [r3, #0]
   1384c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1384e:	9b05      	ldr	r3, [sp, #20]
   13850:	4413      	add	r3, r2
   13852:	3334      	adds	r3, #52	; 0x34
   13854:	460a      	mov	r2, r1
   13856:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   13858:	9a02      	ldr	r2, [sp, #8]
   1385a:	9b05      	ldr	r3, [sp, #20]
   1385c:	4413      	add	r3, r2
   1385e:	781b      	ldrb	r3, [r3, #0]
   13860:	2b00      	cmp	r3, #0
   13862:	d006      	beq.n	13872 <prvInitialiseNewTask+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   13864:	9b05      	ldr	r3, [sp, #20]
   13866:	3301      	adds	r3, #1
   13868:	9305      	str	r3, [sp, #20]
   1386a:	9b05      	ldr	r3, [sp, #20]
   1386c:	2b0f      	cmp	r3, #15
   1386e:	d9e9      	bls.n	13844 <prvInitialiseNewTask+0x3c>
   13870:	e000      	b.n	13874 <prvInitialiseNewTask+0x6c>
		{
			break;
   13872:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   13874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13876:	2200      	movs	r2, #0
   13878:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1387c:	9b08      	ldr	r3, [sp, #32]
   1387e:	2b04      	cmp	r3, #4
   13880:	d901      	bls.n	13886 <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   13882:	2304      	movs	r3, #4
   13884:	9308      	str	r3, [sp, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   13886:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13888:	9a08      	ldr	r2, [sp, #32]
   1388a:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   1388c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1388e:	9a08      	ldr	r2, [sp, #32]
   13890:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
   13892:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13894:	2200      	movs	r2, #0
   13896:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   13898:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1389a:	3304      	adds	r3, #4
   1389c:	4618      	mov	r0, r3
   1389e:	f7ff febe 	bl	1361e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   138a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138a4:	3318      	adds	r3, #24
   138a6:	4618      	mov	r0, r3
   138a8:	f7ff feb9 	bl	1361e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   138ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138ae:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   138b0:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   138b2:	9b08      	ldr	r3, [sp, #32]
   138b4:	f1c3 0205 	rsb	r2, r3, #5
   138b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138ba:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   138bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138be:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   138c0:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
   138c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138c4:	2200      	movs	r2, #0
   138c6:	655a      	str	r2, [r3, #84]	; 0x54
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   138c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138ca:	2200      	movs	r2, #0
   138cc:	659a      	str	r2, [r3, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   138ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138d0:	2200      	movs	r2, #0
   138d2:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   138d6:	9a00      	ldr	r2, [sp, #0]
   138d8:	9903      	ldr	r1, [sp, #12]
   138da:	9804      	ldr	r0, [sp, #16]
   138dc:	f001 f932 	bl	14b44 <pxPortInitialiseStack>
   138e0:	4602      	mov	r2, r0
   138e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138e4:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   138e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   138e8:	2b00      	cmp	r3, #0
   138ea:	d002      	beq.n	138f2 <prvInitialiseNewTask+0xea>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   138ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
   138ee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   138f0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   138f2:	bf00      	nop
   138f4:	b007      	add	sp, #28
   138f6:	f85d fb04 	ldr.w	pc, [sp], #4
   138fa:	Address 0x00000000000138fa is out of bounds.


000138fc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   138fc:	b500      	push	{lr}
   138fe:	b083      	sub	sp, #12
   13900:	9001      	str	r0, [sp, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   13902:	f001 f9b7 	bl	14c74 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   13906:	4b2d      	ldr	r3, [pc, #180]	; (139bc <prvAddNewTaskToReadyList+0xc0>)
   13908:	681b      	ldr	r3, [r3, #0]
   1390a:	3301      	adds	r3, #1
   1390c:	4a2b      	ldr	r2, [pc, #172]	; (139bc <prvAddNewTaskToReadyList+0xc0>)
   1390e:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   13910:	4b2b      	ldr	r3, [pc, #172]	; (139c0 <prvAddNewTaskToReadyList+0xc4>)
   13912:	681b      	ldr	r3, [r3, #0]
   13914:	2b00      	cmp	r3, #0
   13916:	d109      	bne.n	1392c <prvAddNewTaskToReadyList+0x30>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   13918:	4a29      	ldr	r2, [pc, #164]	; (139c0 <prvAddNewTaskToReadyList+0xc4>)
   1391a:	9b01      	ldr	r3, [sp, #4]
   1391c:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   1391e:	4b27      	ldr	r3, [pc, #156]	; (139bc <prvAddNewTaskToReadyList+0xc0>)
   13920:	681b      	ldr	r3, [r3, #0]
   13922:	2b01      	cmp	r3, #1
   13924:	d110      	bne.n	13948 <prvAddNewTaskToReadyList+0x4c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   13926:	f000 fb1b 	bl	13f60 <prvInitialiseTaskLists>
   1392a:	e00d      	b.n	13948 <prvAddNewTaskToReadyList+0x4c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   1392c:	4b25      	ldr	r3, [pc, #148]	; (139c4 <prvAddNewTaskToReadyList+0xc8>)
   1392e:	681b      	ldr	r3, [r3, #0]
   13930:	2b00      	cmp	r3, #0
   13932:	d109      	bne.n	13948 <prvAddNewTaskToReadyList+0x4c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   13934:	4b22      	ldr	r3, [pc, #136]	; (139c0 <prvAddNewTaskToReadyList+0xc4>)
   13936:	681b      	ldr	r3, [r3, #0]
   13938:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1393a:	9b01      	ldr	r3, [sp, #4]
   1393c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1393e:	429a      	cmp	r2, r3
   13940:	d802      	bhi.n	13948 <prvAddNewTaskToReadyList+0x4c>
				{
					pxCurrentTCB = pxNewTCB;
   13942:	4a1f      	ldr	r2, [pc, #124]	; (139c0 <prvAddNewTaskToReadyList+0xc4>)
   13944:	9b01      	ldr	r3, [sp, #4]
   13946:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   13948:	4b1f      	ldr	r3, [pc, #124]	; (139c8 <prvAddNewTaskToReadyList+0xcc>)
   1394a:	681b      	ldr	r3, [r3, #0]
   1394c:	3301      	adds	r3, #1
   1394e:	4a1e      	ldr	r2, [pc, #120]	; (139c8 <prvAddNewTaskToReadyList+0xcc>)
   13950:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   13952:	4b1d      	ldr	r3, [pc, #116]	; (139c8 <prvAddNewTaskToReadyList+0xcc>)
   13954:	681a      	ldr	r2, [r3, #0]
   13956:	9b01      	ldr	r3, [sp, #4]
   13958:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   1395a:	9b01      	ldr	r3, [sp, #4]
   1395c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1395e:	2201      	movs	r2, #1
   13960:	409a      	lsls	r2, r3
   13962:	4b1a      	ldr	r3, [pc, #104]	; (139cc <prvAddNewTaskToReadyList+0xd0>)
   13964:	681b      	ldr	r3, [r3, #0]
   13966:	4313      	orrs	r3, r2
   13968:	4a18      	ldr	r2, [pc, #96]	; (139cc <prvAddNewTaskToReadyList+0xd0>)
   1396a:	6013      	str	r3, [r2, #0]
   1396c:	9b01      	ldr	r3, [sp, #4]
   1396e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13970:	4613      	mov	r3, r2
   13972:	009b      	lsls	r3, r3, #2
   13974:	4413      	add	r3, r2
   13976:	009b      	lsls	r3, r3, #2
   13978:	4a15      	ldr	r2, [pc, #84]	; (139d0 <prvAddNewTaskToReadyList+0xd4>)
   1397a:	441a      	add	r2, r3
   1397c:	9b01      	ldr	r3, [sp, #4]
   1397e:	3304      	adds	r3, #4
   13980:	4619      	mov	r1, r3
   13982:	4610      	mov	r0, r2
   13984:	f7ff fe53 	bl	1362e <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   13988:	f001 f988 	bl	14c9c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   1398c:	4b0d      	ldr	r3, [pc, #52]	; (139c4 <prvAddNewTaskToReadyList+0xc8>)
   1398e:	681b      	ldr	r3, [r3, #0]
   13990:	2b00      	cmp	r3, #0
   13992:	d00e      	beq.n	139b2 <prvAddNewTaskToReadyList+0xb6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   13994:	4b0a      	ldr	r3, [pc, #40]	; (139c0 <prvAddNewTaskToReadyList+0xc4>)
   13996:	681b      	ldr	r3, [r3, #0]
   13998:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1399a:	9b01      	ldr	r3, [sp, #4]
   1399c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1399e:	429a      	cmp	r2, r3
   139a0:	d207      	bcs.n	139b2 <prvAddNewTaskToReadyList+0xb6>
		{
			taskYIELD_IF_USING_PREEMPTION();
   139a2:	4b0c      	ldr	r3, [pc, #48]	; (139d4 <prvAddNewTaskToReadyList+0xd8>)
   139a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   139a8:	601a      	str	r2, [r3, #0]
   139aa:	f3bf 8f4f 	dsb	sy
   139ae:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   139b2:	bf00      	nop
   139b4:	b003      	add	sp, #12
   139b6:	f85d fb04 	ldr.w	pc, [sp], #4
   139ba:	bf00      	nop
   139bc:	100007ac 	.word	0x100007ac
   139c0:	100006d4 	.word	0x100006d4
   139c4:	100007b8 	.word	0x100007b8
   139c8:	100007c8 	.word	0x100007c8
   139cc:	100007b4 	.word	0x100007b4
   139d0:	100006d8 	.word	0x100006d8
   139d4:	e000ed04 	.word	0xe000ed04

000139d8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   139d8:	b500      	push	{lr}
   139da:	b08b      	sub	sp, #44	; 0x2c
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   139dc:	2300      	movs	r3, #0
   139de:	9307      	str	r3, [sp, #28]
		StackType_t *pxIdleTaskStackBuffer = NULL;
   139e0:	2300      	movs	r3, #0
   139e2:	9306      	str	r3, [sp, #24]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   139e4:	aa05      	add	r2, sp, #20
   139e6:	a906      	add	r1, sp, #24
   139e8:	ab07      	add	r3, sp, #28
   139ea:	4618      	mov	r0, r3
   139ec:	f7ff f85c 	bl	12aa8 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   139f0:	9905      	ldr	r1, [sp, #20]
   139f2:	9b06      	ldr	r3, [sp, #24]
   139f4:	9a07      	ldr	r2, [sp, #28]
   139f6:	9202      	str	r2, [sp, #8]
   139f8:	9301      	str	r3, [sp, #4]
   139fa:	2300      	movs	r3, #0
   139fc:	9300      	str	r3, [sp, #0]
   139fe:	2300      	movs	r3, #0
   13a00:	460a      	mov	r2, r1
   13a02:	4916      	ldr	r1, [pc, #88]	; (13a5c <vTaskStartScheduler+0x84>)
   13a04:	4816      	ldr	r0, [pc, #88]	; (13a60 <vTaskStartScheduler+0x88>)
   13a06:	f7ff fe8a 	bl	1371e <xTaskCreateStatic>
   13a0a:	4602      	mov	r2, r0
   13a0c:	4b15      	ldr	r3, [pc, #84]	; (13a64 <vTaskStartScheduler+0x8c>)
   13a0e:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
   13a10:	4b14      	ldr	r3, [pc, #80]	; (13a64 <vTaskStartScheduler+0x8c>)
   13a12:	681b      	ldr	r3, [r3, #0]
   13a14:	2b00      	cmp	r3, #0
   13a16:	d002      	beq.n	13a1e <vTaskStartScheduler+0x46>
		{
			xReturn = pdPASS;
   13a18:	2301      	movs	r3, #1
   13a1a:	9309      	str	r3, [sp, #36]	; 0x24
   13a1c:	e001      	b.n	13a22 <vTaskStartScheduler+0x4a>
		}
		else
		{
			xReturn = pdFAIL;
   13a1e:	2300      	movs	r3, #0
   13a20:	9309      	str	r3, [sp, #36]	; 0x24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   13a22:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13a24:	2b01      	cmp	r3, #1
   13a26:	d114      	bne.n	13a52 <vTaskStartScheduler+0x7a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   13a28:	f04f 0328 	mov.w	r3, #40	; 0x28
   13a2c:	f383 8811 	msr	BASEPRI, r3
   13a30:	f3bf 8f6f 	isb	sy
   13a34:	f3bf 8f4f 	dsb	sy
   13a38:	9308      	str	r3, [sp, #32]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   13a3a:	4b0b      	ldr	r3, [pc, #44]	; (13a68 <vTaskStartScheduler+0x90>)
   13a3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13a40:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   13a42:	4b0a      	ldr	r3, [pc, #40]	; (13a6c <vTaskStartScheduler+0x94>)
   13a44:	2201      	movs	r2, #1
   13a46:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   13a48:	4b09      	ldr	r3, [pc, #36]	; (13a70 <vTaskStartScheduler+0x98>)
   13a4a:	2200      	movs	r2, #0
   13a4c:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   13a4e:	f001 f8e7 	bl	14c20 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   13a52:	bf00      	nop
   13a54:	b00b      	add	sp, #44	; 0x2c
   13a56:	f85d fb04 	ldr.w	pc, [sp], #4
   13a5a:	bf00      	nop
   13a5c:	00019eec 	.word	0x00019eec
   13a60:	00013f55 	.word	0x00013f55
   13a64:	100007d0 	.word	0x100007d0
   13a68:	100007cc 	.word	0x100007cc
   13a6c:	100007b8 	.word	0x100007b8
   13a70:	100007b0 	.word	0x100007b0

00013a74 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   13a74:	4b03      	ldr	r3, [pc, #12]	; (13a84 <vTaskSuspendAll+0x10>)
   13a76:	681b      	ldr	r3, [r3, #0]
   13a78:	3301      	adds	r3, #1
   13a7a:	4a02      	ldr	r2, [pc, #8]	; (13a84 <vTaskSuspendAll+0x10>)
   13a7c:	6013      	str	r3, [r2, #0]
}
   13a7e:	bf00      	nop
   13a80:	4770      	bx	lr
   13a82:	bf00      	nop
   13a84:	100007d4 	.word	0x100007d4

00013a88 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   13a88:	b500      	push	{lr}
   13a8a:	b085      	sub	sp, #20
TCB_t *pxTCB = NULL;
   13a8c:	2300      	movs	r3, #0
   13a8e:	9303      	str	r3, [sp, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   13a90:	2300      	movs	r3, #0
   13a92:	9302      	str	r3, [sp, #8]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   13a94:	f001 f8ee 	bl	14c74 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   13a98:	4b38      	ldr	r3, [pc, #224]	; (13b7c <xTaskResumeAll+0xf4>)
   13a9a:	681b      	ldr	r3, [r3, #0]
   13a9c:	3b01      	subs	r3, #1
   13a9e:	4a37      	ldr	r2, [pc, #220]	; (13b7c <xTaskResumeAll+0xf4>)
   13aa0:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13aa2:	4b36      	ldr	r3, [pc, #216]	; (13b7c <xTaskResumeAll+0xf4>)
   13aa4:	681b      	ldr	r3, [r3, #0]
   13aa6:	2b00      	cmp	r3, #0
   13aa8:	d161      	bne.n	13b6e <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   13aaa:	4b35      	ldr	r3, [pc, #212]	; (13b80 <xTaskResumeAll+0xf8>)
   13aac:	681b      	ldr	r3, [r3, #0]
   13aae:	2b00      	cmp	r3, #0
   13ab0:	d05d      	beq.n	13b6e <xTaskResumeAll+0xe6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   13ab2:	e02e      	b.n	13b12 <xTaskResumeAll+0x8a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   13ab4:	4b33      	ldr	r3, [pc, #204]	; (13b84 <xTaskResumeAll+0xfc>)
   13ab6:	68db      	ldr	r3, [r3, #12]
   13ab8:	68db      	ldr	r3, [r3, #12]
   13aba:	9303      	str	r3, [sp, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   13abc:	9b03      	ldr	r3, [sp, #12]
   13abe:	3318      	adds	r3, #24
   13ac0:	4618      	mov	r0, r3
   13ac2:	f7ff fe07 	bl	136d4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13ac6:	9b03      	ldr	r3, [sp, #12]
   13ac8:	3304      	adds	r3, #4
   13aca:	4618      	mov	r0, r3
   13acc:	f7ff fe02 	bl	136d4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   13ad0:	9b03      	ldr	r3, [sp, #12]
   13ad2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13ad4:	2201      	movs	r2, #1
   13ad6:	409a      	lsls	r2, r3
   13ad8:	4b2b      	ldr	r3, [pc, #172]	; (13b88 <xTaskResumeAll+0x100>)
   13ada:	681b      	ldr	r3, [r3, #0]
   13adc:	4313      	orrs	r3, r2
   13ade:	4a2a      	ldr	r2, [pc, #168]	; (13b88 <xTaskResumeAll+0x100>)
   13ae0:	6013      	str	r3, [r2, #0]
   13ae2:	9b03      	ldr	r3, [sp, #12]
   13ae4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13ae6:	4613      	mov	r3, r2
   13ae8:	009b      	lsls	r3, r3, #2
   13aea:	4413      	add	r3, r2
   13aec:	009b      	lsls	r3, r3, #2
   13aee:	4a27      	ldr	r2, [pc, #156]	; (13b8c <xTaskResumeAll+0x104>)
   13af0:	441a      	add	r2, r3
   13af2:	9b03      	ldr	r3, [sp, #12]
   13af4:	3304      	adds	r3, #4
   13af6:	4619      	mov	r1, r3
   13af8:	4610      	mov	r0, r2
   13afa:	f7ff fd98 	bl	1362e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   13afe:	9b03      	ldr	r3, [sp, #12]
   13b00:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13b02:	4b23      	ldr	r3, [pc, #140]	; (13b90 <xTaskResumeAll+0x108>)
   13b04:	681b      	ldr	r3, [r3, #0]
   13b06:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13b08:	429a      	cmp	r2, r3
   13b0a:	d302      	bcc.n	13b12 <xTaskResumeAll+0x8a>
					{
						xYieldPending = pdTRUE;
   13b0c:	4b21      	ldr	r3, [pc, #132]	; (13b94 <xTaskResumeAll+0x10c>)
   13b0e:	2201      	movs	r2, #1
   13b10:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   13b12:	4b1c      	ldr	r3, [pc, #112]	; (13b84 <xTaskResumeAll+0xfc>)
   13b14:	681b      	ldr	r3, [r3, #0]
   13b16:	2b00      	cmp	r3, #0
   13b18:	d1cc      	bne.n	13ab4 <xTaskResumeAll+0x2c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   13b1a:	9b03      	ldr	r3, [sp, #12]
   13b1c:	2b00      	cmp	r3, #0
   13b1e:	d001      	beq.n	13b24 <xTaskResumeAll+0x9c>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   13b20:	f000 faa6 	bl	14070 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   13b24:	4b1c      	ldr	r3, [pc, #112]	; (13b98 <xTaskResumeAll+0x110>)
   13b26:	681b      	ldr	r3, [r3, #0]
   13b28:	9301      	str	r3, [sp, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   13b2a:	9b01      	ldr	r3, [sp, #4]
   13b2c:	2b00      	cmp	r3, #0
   13b2e:	d010      	beq.n	13b52 <xTaskResumeAll+0xca>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   13b30:	f000 f836 	bl	13ba0 <xTaskIncrementTick>
   13b34:	4603      	mov	r3, r0
   13b36:	2b00      	cmp	r3, #0
   13b38:	d002      	beq.n	13b40 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
   13b3a:	4b16      	ldr	r3, [pc, #88]	; (13b94 <xTaskResumeAll+0x10c>)
   13b3c:	2201      	movs	r2, #1
   13b3e:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   13b40:	9b01      	ldr	r3, [sp, #4]
   13b42:	3b01      	subs	r3, #1
   13b44:	9301      	str	r3, [sp, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   13b46:	9b01      	ldr	r3, [sp, #4]
   13b48:	2b00      	cmp	r3, #0
   13b4a:	d1f1      	bne.n	13b30 <xTaskResumeAll+0xa8>

						uxPendedTicks = 0;
   13b4c:	4b12      	ldr	r3, [pc, #72]	; (13b98 <xTaskResumeAll+0x110>)
   13b4e:	2200      	movs	r2, #0
   13b50:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   13b52:	4b10      	ldr	r3, [pc, #64]	; (13b94 <xTaskResumeAll+0x10c>)
   13b54:	681b      	ldr	r3, [r3, #0]
   13b56:	2b00      	cmp	r3, #0
   13b58:	d009      	beq.n	13b6e <xTaskResumeAll+0xe6>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   13b5a:	2301      	movs	r3, #1
   13b5c:	9302      	str	r3, [sp, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   13b5e:	4b0f      	ldr	r3, [pc, #60]	; (13b9c <xTaskResumeAll+0x114>)
   13b60:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   13b64:	601a      	str	r2, [r3, #0]
   13b66:	f3bf 8f4f 	dsb	sy
   13b6a:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   13b6e:	f001 f895 	bl	14c9c <vPortExitCritical>

	return xAlreadyYielded;
   13b72:	9b02      	ldr	r3, [sp, #8]
}
   13b74:	4618      	mov	r0, r3
   13b76:	b005      	add	sp, #20
   13b78:	f85d fb04 	ldr.w	pc, [sp], #4
   13b7c:	100007d4 	.word	0x100007d4
   13b80:	100007ac 	.word	0x100007ac
   13b84:	1000076c 	.word	0x1000076c
   13b88:	100007b4 	.word	0x100007b4
   13b8c:	100006d8 	.word	0x100006d8
   13b90:	100006d4 	.word	0x100006d4
   13b94:	100007c0 	.word	0x100007c0
   13b98:	100007bc 	.word	0x100007bc
   13b9c:	e000ed04 	.word	0xe000ed04

00013ba0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   13ba0:	b500      	push	{lr}
   13ba2:	b087      	sub	sp, #28
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   13ba4:	2300      	movs	r3, #0
   13ba6:	9305      	str	r3, [sp, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13ba8:	4b48      	ldr	r3, [pc, #288]	; (13ccc <xTaskIncrementTick+0x12c>)
   13baa:	681b      	ldr	r3, [r3, #0]
   13bac:	2b00      	cmp	r3, #0
   13bae:	d17c      	bne.n	13caa <xTaskIncrementTick+0x10a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   13bb0:	4b47      	ldr	r3, [pc, #284]	; (13cd0 <xTaskIncrementTick+0x130>)
   13bb2:	681b      	ldr	r3, [r3, #0]
   13bb4:	3301      	adds	r3, #1
   13bb6:	9304      	str	r3, [sp, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   13bb8:	4a45      	ldr	r2, [pc, #276]	; (13cd0 <xTaskIncrementTick+0x130>)
   13bba:	9b04      	ldr	r3, [sp, #16]
   13bbc:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   13bbe:	9b04      	ldr	r3, [sp, #16]
   13bc0:	2b00      	cmp	r3, #0
   13bc2:	d110      	bne.n	13be6 <xTaskIncrementTick+0x46>
		{
			taskSWITCH_DELAYED_LISTS();
   13bc4:	4b43      	ldr	r3, [pc, #268]	; (13cd4 <xTaskIncrementTick+0x134>)
   13bc6:	681b      	ldr	r3, [r3, #0]
   13bc8:	9303      	str	r3, [sp, #12]
   13bca:	4b43      	ldr	r3, [pc, #268]	; (13cd8 <xTaskIncrementTick+0x138>)
   13bcc:	681b      	ldr	r3, [r3, #0]
   13bce:	4a41      	ldr	r2, [pc, #260]	; (13cd4 <xTaskIncrementTick+0x134>)
   13bd0:	6013      	str	r3, [r2, #0]
   13bd2:	4a41      	ldr	r2, [pc, #260]	; (13cd8 <xTaskIncrementTick+0x138>)
   13bd4:	9b03      	ldr	r3, [sp, #12]
   13bd6:	6013      	str	r3, [r2, #0]
   13bd8:	4b40      	ldr	r3, [pc, #256]	; (13cdc <xTaskIncrementTick+0x13c>)
   13bda:	681b      	ldr	r3, [r3, #0]
   13bdc:	3301      	adds	r3, #1
   13bde:	4a3f      	ldr	r2, [pc, #252]	; (13cdc <xTaskIncrementTick+0x13c>)
   13be0:	6013      	str	r3, [r2, #0]
   13be2:	f000 fa45 	bl	14070 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   13be6:	4b3e      	ldr	r3, [pc, #248]	; (13ce0 <xTaskIncrementTick+0x140>)
   13be8:	681b      	ldr	r3, [r3, #0]
   13bea:	9a04      	ldr	r2, [sp, #16]
   13bec:	429a      	cmp	r2, r3
   13bee:	d34d      	bcc.n	13c8c <xTaskIncrementTick+0xec>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   13bf0:	4b38      	ldr	r3, [pc, #224]	; (13cd4 <xTaskIncrementTick+0x134>)
   13bf2:	681b      	ldr	r3, [r3, #0]
   13bf4:	681b      	ldr	r3, [r3, #0]
   13bf6:	2b00      	cmp	r3, #0
   13bf8:	d101      	bne.n	13bfe <xTaskIncrementTick+0x5e>
   13bfa:	2301      	movs	r3, #1
   13bfc:	e000      	b.n	13c00 <xTaskIncrementTick+0x60>
   13bfe:	2300      	movs	r3, #0
   13c00:	2b00      	cmp	r3, #0
   13c02:	d004      	beq.n	13c0e <xTaskIncrementTick+0x6e>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   13c04:	4b36      	ldr	r3, [pc, #216]	; (13ce0 <xTaskIncrementTick+0x140>)
   13c06:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13c0a:	601a      	str	r2, [r3, #0]
					break;
   13c0c:	e03e      	b.n	13c8c <xTaskIncrementTick+0xec>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   13c0e:	4b31      	ldr	r3, [pc, #196]	; (13cd4 <xTaskIncrementTick+0x134>)
   13c10:	681b      	ldr	r3, [r3, #0]
   13c12:	68db      	ldr	r3, [r3, #12]
   13c14:	68db      	ldr	r3, [r3, #12]
   13c16:	9302      	str	r3, [sp, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   13c18:	9b02      	ldr	r3, [sp, #8]
   13c1a:	685b      	ldr	r3, [r3, #4]
   13c1c:	9301      	str	r3, [sp, #4]

					if( xConstTickCount < xItemValue )
   13c1e:	9a04      	ldr	r2, [sp, #16]
   13c20:	9b01      	ldr	r3, [sp, #4]
   13c22:	429a      	cmp	r2, r3
   13c24:	d203      	bcs.n	13c2e <xTaskIncrementTick+0x8e>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   13c26:	4a2e      	ldr	r2, [pc, #184]	; (13ce0 <xTaskIncrementTick+0x140>)
   13c28:	9b01      	ldr	r3, [sp, #4]
   13c2a:	6013      	str	r3, [r2, #0]
						break;
   13c2c:	e02e      	b.n	13c8c <xTaskIncrementTick+0xec>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13c2e:	9b02      	ldr	r3, [sp, #8]
   13c30:	3304      	adds	r3, #4
   13c32:	4618      	mov	r0, r3
   13c34:	f7ff fd4e 	bl	136d4 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   13c38:	9b02      	ldr	r3, [sp, #8]
   13c3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13c3c:	2b00      	cmp	r3, #0
   13c3e:	d004      	beq.n	13c4a <xTaskIncrementTick+0xaa>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   13c40:	9b02      	ldr	r3, [sp, #8]
   13c42:	3318      	adds	r3, #24
   13c44:	4618      	mov	r0, r3
   13c46:	f7ff fd45 	bl	136d4 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   13c4a:	9b02      	ldr	r3, [sp, #8]
   13c4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13c4e:	2201      	movs	r2, #1
   13c50:	409a      	lsls	r2, r3
   13c52:	4b24      	ldr	r3, [pc, #144]	; (13ce4 <xTaskIncrementTick+0x144>)
   13c54:	681b      	ldr	r3, [r3, #0]
   13c56:	4313      	orrs	r3, r2
   13c58:	4a22      	ldr	r2, [pc, #136]	; (13ce4 <xTaskIncrementTick+0x144>)
   13c5a:	6013      	str	r3, [r2, #0]
   13c5c:	9b02      	ldr	r3, [sp, #8]
   13c5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13c60:	4613      	mov	r3, r2
   13c62:	009b      	lsls	r3, r3, #2
   13c64:	4413      	add	r3, r2
   13c66:	009b      	lsls	r3, r3, #2
   13c68:	4a1f      	ldr	r2, [pc, #124]	; (13ce8 <xTaskIncrementTick+0x148>)
   13c6a:	441a      	add	r2, r3
   13c6c:	9b02      	ldr	r3, [sp, #8]
   13c6e:	3304      	adds	r3, #4
   13c70:	4619      	mov	r1, r3
   13c72:	4610      	mov	r0, r2
   13c74:	f7ff fcdb 	bl	1362e <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   13c78:	9b02      	ldr	r3, [sp, #8]
   13c7a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13c7c:	4b1b      	ldr	r3, [pc, #108]	; (13cec <xTaskIncrementTick+0x14c>)
   13c7e:	681b      	ldr	r3, [r3, #0]
   13c80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13c82:	429a      	cmp	r2, r3
   13c84:	d3b4      	bcc.n	13bf0 <xTaskIncrementTick+0x50>
						{
							xSwitchRequired = pdTRUE;
   13c86:	2301      	movs	r3, #1
   13c88:	9305      	str	r3, [sp, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   13c8a:	e7b1      	b.n	13bf0 <xTaskIncrementTick+0x50>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   13c8c:	4b17      	ldr	r3, [pc, #92]	; (13cec <xTaskIncrementTick+0x14c>)
   13c8e:	681b      	ldr	r3, [r3, #0]
   13c90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13c92:	4915      	ldr	r1, [pc, #84]	; (13ce8 <xTaskIncrementTick+0x148>)
   13c94:	4613      	mov	r3, r2
   13c96:	009b      	lsls	r3, r3, #2
   13c98:	4413      	add	r3, r2
   13c9a:	009b      	lsls	r3, r3, #2
   13c9c:	440b      	add	r3, r1
   13c9e:	681b      	ldr	r3, [r3, #0]
   13ca0:	2b01      	cmp	r3, #1
   13ca2:	d907      	bls.n	13cb4 <xTaskIncrementTick+0x114>
			{
				xSwitchRequired = pdTRUE;
   13ca4:	2301      	movs	r3, #1
   13ca6:	9305      	str	r3, [sp, #20]
   13ca8:	e004      	b.n	13cb4 <xTaskIncrementTick+0x114>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   13caa:	4b11      	ldr	r3, [pc, #68]	; (13cf0 <xTaskIncrementTick+0x150>)
   13cac:	681b      	ldr	r3, [r3, #0]
   13cae:	3301      	adds	r3, #1
   13cb0:	4a0f      	ldr	r2, [pc, #60]	; (13cf0 <xTaskIncrementTick+0x150>)
   13cb2:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   13cb4:	4b0f      	ldr	r3, [pc, #60]	; (13cf4 <xTaskIncrementTick+0x154>)
   13cb6:	681b      	ldr	r3, [r3, #0]
   13cb8:	2b00      	cmp	r3, #0
   13cba:	d001      	beq.n	13cc0 <xTaskIncrementTick+0x120>
		{
			xSwitchRequired = pdTRUE;
   13cbc:	2301      	movs	r3, #1
   13cbe:	9305      	str	r3, [sp, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   13cc0:	9b05      	ldr	r3, [sp, #20]
}
   13cc2:	4618      	mov	r0, r3
   13cc4:	b007      	add	sp, #28
   13cc6:	f85d fb04 	ldr.w	pc, [sp], #4
   13cca:	bf00      	nop
   13ccc:	100007d4 	.word	0x100007d4
   13cd0:	100007b0 	.word	0x100007b0
   13cd4:	10000764 	.word	0x10000764
   13cd8:	10000768 	.word	0x10000768
   13cdc:	100007c4 	.word	0x100007c4
   13ce0:	100007cc 	.word	0x100007cc
   13ce4:	100007b4 	.word	0x100007b4
   13ce8:	100006d8 	.word	0x100006d8
   13cec:	100006d4 	.word	0x100006d4
   13cf0:	100007bc 	.word	0x100007bc
   13cf4:	100007c0 	.word	0x100007c0

00013cf8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   13cf8:	b510      	push	{r4, lr}
   13cfa:	b084      	sub	sp, #16
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   13cfc:	4b29      	ldr	r3, [pc, #164]	; (13da4 <vTaskSwitchContext+0xac>)
   13cfe:	681b      	ldr	r3, [r3, #0]
   13d00:	2b00      	cmp	r3, #0
   13d02:	d003      	beq.n	13d0c <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   13d04:	4b28      	ldr	r3, [pc, #160]	; (13da8 <vTaskSwitchContext+0xb0>)
   13d06:	2201      	movs	r2, #1
   13d08:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   13d0a:	e047      	b.n	13d9c <vTaskSwitchContext+0xa4>
		xYieldPending = pdFALSE;
   13d0c:	4b26      	ldr	r3, [pc, #152]	; (13da8 <vTaskSwitchContext+0xb0>)
   13d0e:	2200      	movs	r2, #0
   13d10:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   13d12:	f7fe fe93 	bl	12a3c <UptimeRTOS>
   13d16:	4603      	mov	r3, r0
   13d18:	460c      	mov	r4, r1
   13d1a:	461a      	mov	r2, r3
   13d1c:	4b23      	ldr	r3, [pc, #140]	; (13dac <vTaskSwitchContext+0xb4>)
   13d1e:	601a      	str	r2, [r3, #0]
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   13d20:	4b22      	ldr	r3, [pc, #136]	; (13dac <vTaskSwitchContext+0xb4>)
   13d22:	681a      	ldr	r2, [r3, #0]
   13d24:	4b22      	ldr	r3, [pc, #136]	; (13db0 <vTaskSwitchContext+0xb8>)
   13d26:	681b      	ldr	r3, [r3, #0]
   13d28:	429a      	cmp	r2, r3
   13d2a:	d909      	bls.n	13d40 <vTaskSwitchContext+0x48>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   13d2c:	4b21      	ldr	r3, [pc, #132]	; (13db4 <vTaskSwitchContext+0xbc>)
   13d2e:	681b      	ldr	r3, [r3, #0]
   13d30:	6d59      	ldr	r1, [r3, #84]	; 0x54
   13d32:	4a1e      	ldr	r2, [pc, #120]	; (13dac <vTaskSwitchContext+0xb4>)
   13d34:	6810      	ldr	r0, [r2, #0]
   13d36:	4a1e      	ldr	r2, [pc, #120]	; (13db0 <vTaskSwitchContext+0xb8>)
   13d38:	6812      	ldr	r2, [r2, #0]
   13d3a:	1a82      	subs	r2, r0, r2
   13d3c:	440a      	add	r2, r1
   13d3e:	655a      	str	r2, [r3, #84]	; 0x54
				ulTaskSwitchedInTime = ulTotalRunTime;
   13d40:	4b1a      	ldr	r3, [pc, #104]	; (13dac <vTaskSwitchContext+0xb4>)
   13d42:	681b      	ldr	r3, [r3, #0]
   13d44:	4a1a      	ldr	r2, [pc, #104]	; (13db0 <vTaskSwitchContext+0xb8>)
   13d46:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   13d48:	4b1b      	ldr	r3, [pc, #108]	; (13db8 <vTaskSwitchContext+0xc0>)
   13d4a:	681b      	ldr	r3, [r3, #0]
   13d4c:	9301      	str	r3, [sp, #4]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   13d4e:	9b01      	ldr	r3, [sp, #4]
   13d50:	fab3 f383 	clz	r3, r3
   13d54:	f88d 3003 	strb.w	r3, [sp, #3]
		return ucReturn;
   13d58:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13d5c:	f1c3 031f 	rsb	r3, r3, #31
   13d60:	9303      	str	r3, [sp, #12]
   13d62:	9a03      	ldr	r2, [sp, #12]
   13d64:	4613      	mov	r3, r2
   13d66:	009b      	lsls	r3, r3, #2
   13d68:	4413      	add	r3, r2
   13d6a:	009b      	lsls	r3, r3, #2
   13d6c:	4a13      	ldr	r2, [pc, #76]	; (13dbc <vTaskSwitchContext+0xc4>)
   13d6e:	4413      	add	r3, r2
   13d70:	9302      	str	r3, [sp, #8]
   13d72:	9b02      	ldr	r3, [sp, #8]
   13d74:	685b      	ldr	r3, [r3, #4]
   13d76:	685a      	ldr	r2, [r3, #4]
   13d78:	9b02      	ldr	r3, [sp, #8]
   13d7a:	605a      	str	r2, [r3, #4]
   13d7c:	9b02      	ldr	r3, [sp, #8]
   13d7e:	685a      	ldr	r2, [r3, #4]
   13d80:	9b02      	ldr	r3, [sp, #8]
   13d82:	3308      	adds	r3, #8
   13d84:	429a      	cmp	r2, r3
   13d86:	d104      	bne.n	13d92 <vTaskSwitchContext+0x9a>
   13d88:	9b02      	ldr	r3, [sp, #8]
   13d8a:	685b      	ldr	r3, [r3, #4]
   13d8c:	685a      	ldr	r2, [r3, #4]
   13d8e:	9b02      	ldr	r3, [sp, #8]
   13d90:	605a      	str	r2, [r3, #4]
   13d92:	9b02      	ldr	r3, [sp, #8]
   13d94:	685b      	ldr	r3, [r3, #4]
   13d96:	68db      	ldr	r3, [r3, #12]
   13d98:	4a06      	ldr	r2, [pc, #24]	; (13db4 <vTaskSwitchContext+0xbc>)
   13d9a:	6013      	str	r3, [r2, #0]
}
   13d9c:	bf00      	nop
   13d9e:	b004      	add	sp, #16
   13da0:	bd10      	pop	{r4, pc}
   13da2:	bf00      	nop
   13da4:	100007d4 	.word	0x100007d4
   13da8:	100007c0 	.word	0x100007c0
   13dac:	100007dc 	.word	0x100007dc
   13db0:	100007d8 	.word	0x100007d8
   13db4:	100006d4 	.word	0x100006d4
   13db8:	100007b4 	.word	0x100007b4
   13dbc:	100006d8 	.word	0x100006d8

00013dc0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   13dc0:	b500      	push	{lr}
   13dc2:	b083      	sub	sp, #12
   13dc4:	9001      	str	r0, [sp, #4]
   13dc6:	9100      	str	r1, [sp, #0]

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   13dc8:	4b07      	ldr	r3, [pc, #28]	; (13de8 <vTaskPlaceOnEventList+0x28>)
   13dca:	681b      	ldr	r3, [r3, #0]
   13dcc:	3318      	adds	r3, #24
   13dce:	4619      	mov	r1, r3
   13dd0:	9801      	ldr	r0, [sp, #4]
   13dd2:	f7ff fc4b 	bl	1366c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   13dd6:	2101      	movs	r1, #1
   13dd8:	9800      	ldr	r0, [sp, #0]
   13dda:	f000 fadd 	bl	14398 <prvAddCurrentTaskToDelayedList>
}
   13dde:	bf00      	nop
   13de0:	b003      	add	sp, #12
   13de2:	f85d fb04 	ldr.w	pc, [sp], #4
   13de6:	bf00      	nop
   13de8:	100006d4 	.word	0x100006d4

00013dec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   13dec:	b500      	push	{lr}
   13dee:	b085      	sub	sp, #20
   13df0:	9001      	str	r0, [sp, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   13df2:	9b01      	ldr	r3, [sp, #4]
   13df4:	68db      	ldr	r3, [r3, #12]
   13df6:	68db      	ldr	r3, [r3, #12]
   13df8:	9302      	str	r3, [sp, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   13dfa:	9b02      	ldr	r3, [sp, #8]
   13dfc:	3318      	adds	r3, #24
   13dfe:	4618      	mov	r0, r3
   13e00:	f7ff fc68 	bl	136d4 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13e04:	4b1d      	ldr	r3, [pc, #116]	; (13e7c <xTaskRemoveFromEventList+0x90>)
   13e06:	681b      	ldr	r3, [r3, #0]
   13e08:	2b00      	cmp	r3, #0
   13e0a:	d11c      	bne.n	13e46 <xTaskRemoveFromEventList+0x5a>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   13e0c:	9b02      	ldr	r3, [sp, #8]
   13e0e:	3304      	adds	r3, #4
   13e10:	4618      	mov	r0, r3
   13e12:	f7ff fc5f 	bl	136d4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   13e16:	9b02      	ldr	r3, [sp, #8]
   13e18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13e1a:	2201      	movs	r2, #1
   13e1c:	409a      	lsls	r2, r3
   13e1e:	4b18      	ldr	r3, [pc, #96]	; (13e80 <xTaskRemoveFromEventList+0x94>)
   13e20:	681b      	ldr	r3, [r3, #0]
   13e22:	4313      	orrs	r3, r2
   13e24:	4a16      	ldr	r2, [pc, #88]	; (13e80 <xTaskRemoveFromEventList+0x94>)
   13e26:	6013      	str	r3, [r2, #0]
   13e28:	9b02      	ldr	r3, [sp, #8]
   13e2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13e2c:	4613      	mov	r3, r2
   13e2e:	009b      	lsls	r3, r3, #2
   13e30:	4413      	add	r3, r2
   13e32:	009b      	lsls	r3, r3, #2
   13e34:	4a13      	ldr	r2, [pc, #76]	; (13e84 <xTaskRemoveFromEventList+0x98>)
   13e36:	441a      	add	r2, r3
   13e38:	9b02      	ldr	r3, [sp, #8]
   13e3a:	3304      	adds	r3, #4
   13e3c:	4619      	mov	r1, r3
   13e3e:	4610      	mov	r0, r2
   13e40:	f7ff fbf5 	bl	1362e <vListInsertEnd>
   13e44:	e005      	b.n	13e52 <xTaskRemoveFromEventList+0x66>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   13e46:	9b02      	ldr	r3, [sp, #8]
   13e48:	3318      	adds	r3, #24
   13e4a:	4619      	mov	r1, r3
   13e4c:	480e      	ldr	r0, [pc, #56]	; (13e88 <xTaskRemoveFromEventList+0x9c>)
   13e4e:	f7ff fbee 	bl	1362e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   13e52:	9b02      	ldr	r3, [sp, #8]
   13e54:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13e56:	4b0d      	ldr	r3, [pc, #52]	; (13e8c <xTaskRemoveFromEventList+0xa0>)
   13e58:	681b      	ldr	r3, [r3, #0]
   13e5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13e5c:	429a      	cmp	r2, r3
   13e5e:	d905      	bls.n	13e6c <xTaskRemoveFromEventList+0x80>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   13e60:	2301      	movs	r3, #1
   13e62:	9303      	str	r3, [sp, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   13e64:	4b0a      	ldr	r3, [pc, #40]	; (13e90 <xTaskRemoveFromEventList+0xa4>)
   13e66:	2201      	movs	r2, #1
   13e68:	601a      	str	r2, [r3, #0]
   13e6a:	e001      	b.n	13e70 <xTaskRemoveFromEventList+0x84>
	}
	else
	{
		xReturn = pdFALSE;
   13e6c:	2300      	movs	r3, #0
   13e6e:	9303      	str	r3, [sp, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   13e70:	9b03      	ldr	r3, [sp, #12]
}
   13e72:	4618      	mov	r0, r3
   13e74:	b005      	add	sp, #20
   13e76:	f85d fb04 	ldr.w	pc, [sp], #4
   13e7a:	bf00      	nop
   13e7c:	100007d4 	.word	0x100007d4
   13e80:	100007b4 	.word	0x100007b4
   13e84:	100006d8 	.word	0x100006d8
   13e88:	1000076c 	.word	0x1000076c
   13e8c:	100006d4 	.word	0x100006d4
   13e90:	100007c0 	.word	0x100007c0

00013e94 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   13e94:	b082      	sub	sp, #8
   13e96:	9001      	str	r0, [sp, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   13e98:	4b05      	ldr	r3, [pc, #20]	; (13eb0 <vTaskInternalSetTimeOutState+0x1c>)
   13e9a:	681a      	ldr	r2, [r3, #0]
   13e9c:	9b01      	ldr	r3, [sp, #4]
   13e9e:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   13ea0:	4b04      	ldr	r3, [pc, #16]	; (13eb4 <vTaskInternalSetTimeOutState+0x20>)
   13ea2:	681a      	ldr	r2, [r3, #0]
   13ea4:	9b01      	ldr	r3, [sp, #4]
   13ea6:	605a      	str	r2, [r3, #4]
}
   13ea8:	bf00      	nop
   13eaa:	b002      	add	sp, #8
   13eac:	4770      	bx	lr
   13eae:	bf00      	nop
   13eb0:	100007c4 	.word	0x100007c4
   13eb4:	100007b0 	.word	0x100007b0

00013eb8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   13eb8:	b500      	push	{lr}
   13eba:	b087      	sub	sp, #28
   13ebc:	9001      	str	r0, [sp, #4]
   13ebe:	9100      	str	r1, [sp, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   13ec0:	f000 fed8 	bl	14c74 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   13ec4:	4b1d      	ldr	r3, [pc, #116]	; (13f3c <xTaskCheckForTimeOut+0x84>)
   13ec6:	681b      	ldr	r3, [r3, #0]
   13ec8:	9304      	str	r3, [sp, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   13eca:	9b01      	ldr	r3, [sp, #4]
   13ecc:	685b      	ldr	r3, [r3, #4]
   13ece:	9a04      	ldr	r2, [sp, #16]
   13ed0:	1ad3      	subs	r3, r2, r3
   13ed2:	9303      	str	r3, [sp, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   13ed4:	9b00      	ldr	r3, [sp, #0]
   13ed6:	681b      	ldr	r3, [r3, #0]
   13ed8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   13edc:	d102      	bne.n	13ee4 <xTaskCheckForTimeOut+0x2c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   13ede:	2300      	movs	r3, #0
   13ee0:	9305      	str	r3, [sp, #20]
   13ee2:	e023      	b.n	13f2c <xTaskCheckForTimeOut+0x74>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   13ee4:	9b01      	ldr	r3, [sp, #4]
   13ee6:	681a      	ldr	r2, [r3, #0]
   13ee8:	4b15      	ldr	r3, [pc, #84]	; (13f40 <xTaskCheckForTimeOut+0x88>)
   13eea:	681b      	ldr	r3, [r3, #0]
   13eec:	429a      	cmp	r2, r3
   13eee:	d007      	beq.n	13f00 <xTaskCheckForTimeOut+0x48>
   13ef0:	9b01      	ldr	r3, [sp, #4]
   13ef2:	685b      	ldr	r3, [r3, #4]
   13ef4:	9a04      	ldr	r2, [sp, #16]
   13ef6:	429a      	cmp	r2, r3
   13ef8:	d302      	bcc.n	13f00 <xTaskCheckForTimeOut+0x48>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   13efa:	2301      	movs	r3, #1
   13efc:	9305      	str	r3, [sp, #20]
   13efe:	e015      	b.n	13f2c <xTaskCheckForTimeOut+0x74>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   13f00:	9b00      	ldr	r3, [sp, #0]
   13f02:	681b      	ldr	r3, [r3, #0]
   13f04:	9a03      	ldr	r2, [sp, #12]
   13f06:	429a      	cmp	r2, r3
   13f08:	d20b      	bcs.n	13f22 <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   13f0a:	9b00      	ldr	r3, [sp, #0]
   13f0c:	681a      	ldr	r2, [r3, #0]
   13f0e:	9b03      	ldr	r3, [sp, #12]
   13f10:	1ad2      	subs	r2, r2, r3
   13f12:	9b00      	ldr	r3, [sp, #0]
   13f14:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   13f16:	9801      	ldr	r0, [sp, #4]
   13f18:	f7ff ffbc 	bl	13e94 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   13f1c:	2300      	movs	r3, #0
   13f1e:	9305      	str	r3, [sp, #20]
   13f20:	e004      	b.n	13f2c <xTaskCheckForTimeOut+0x74>
		}
		else
		{
			*pxTicksToWait = 0;
   13f22:	9b00      	ldr	r3, [sp, #0]
   13f24:	2200      	movs	r2, #0
   13f26:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   13f28:	2301      	movs	r3, #1
   13f2a:	9305      	str	r3, [sp, #20]
		}
	}
	taskEXIT_CRITICAL();
   13f2c:	f000 feb6 	bl	14c9c <vPortExitCritical>

	return xReturn;
   13f30:	9b05      	ldr	r3, [sp, #20]
}
   13f32:	4618      	mov	r0, r3
   13f34:	b007      	add	sp, #28
   13f36:	f85d fb04 	ldr.w	pc, [sp], #4
   13f3a:	bf00      	nop
   13f3c:	100007b0 	.word	0x100007b0
   13f40:	100007c4 	.word	0x100007c4

00013f44 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
   13f44:	4b02      	ldr	r3, [pc, #8]	; (13f50 <vTaskMissedYield+0xc>)
   13f46:	2201      	movs	r2, #1
   13f48:	601a      	str	r2, [r3, #0]
}
   13f4a:	bf00      	nop
   13f4c:	4770      	bx	lr
   13f4e:	bf00      	nop
   13f50:	100007c0 	.word	0x100007c0

00013f54 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   13f54:	b500      	push	{lr}
   13f56:	b083      	sub	sp, #12
   13f58:	9001      	str	r0, [sp, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   13f5a:	f000 f83f 	bl	13fdc <prvCheckTasksWaitingTermination>
   13f5e:	e7fc      	b.n	13f5a <prvIdleTask+0x6>

00013f60 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   13f60:	b500      	push	{lr}
   13f62:	b083      	sub	sp, #12
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   13f64:	2300      	movs	r3, #0
   13f66:	9301      	str	r3, [sp, #4]
   13f68:	e00c      	b.n	13f84 <prvInitialiseTaskLists+0x24>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   13f6a:	9a01      	ldr	r2, [sp, #4]
   13f6c:	4613      	mov	r3, r2
   13f6e:	009b      	lsls	r3, r3, #2
   13f70:	4413      	add	r3, r2
   13f72:	009b      	lsls	r3, r3, #2
   13f74:	4a11      	ldr	r2, [pc, #68]	; (13fbc <prvInitialiseTaskLists+0x5c>)
   13f76:	4413      	add	r3, r2
   13f78:	4618      	mov	r0, r3
   13f7a:	f7ff fb35 	bl	135e8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   13f7e:	9b01      	ldr	r3, [sp, #4]
   13f80:	3301      	adds	r3, #1
   13f82:	9301      	str	r3, [sp, #4]
   13f84:	9b01      	ldr	r3, [sp, #4]
   13f86:	2b04      	cmp	r3, #4
   13f88:	d9ef      	bls.n	13f6a <prvInitialiseTaskLists+0xa>
	}

	vListInitialise( &xDelayedTaskList1 );
   13f8a:	480d      	ldr	r0, [pc, #52]	; (13fc0 <prvInitialiseTaskLists+0x60>)
   13f8c:	f7ff fb2c 	bl	135e8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   13f90:	480c      	ldr	r0, [pc, #48]	; (13fc4 <prvInitialiseTaskLists+0x64>)
   13f92:	f7ff fb29 	bl	135e8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
   13f96:	480c      	ldr	r0, [pc, #48]	; (13fc8 <prvInitialiseTaskLists+0x68>)
   13f98:	f7ff fb26 	bl	135e8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   13f9c:	480b      	ldr	r0, [pc, #44]	; (13fcc <prvInitialiseTaskLists+0x6c>)
   13f9e:	f7ff fb23 	bl	135e8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   13fa2:	480b      	ldr	r0, [pc, #44]	; (13fd0 <prvInitialiseTaskLists+0x70>)
   13fa4:	f7ff fb20 	bl	135e8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   13fa8:	4b0a      	ldr	r3, [pc, #40]	; (13fd4 <prvInitialiseTaskLists+0x74>)
   13faa:	4a05      	ldr	r2, [pc, #20]	; (13fc0 <prvInitialiseTaskLists+0x60>)
   13fac:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   13fae:	4b0a      	ldr	r3, [pc, #40]	; (13fd8 <prvInitialiseTaskLists+0x78>)
   13fb0:	4a04      	ldr	r2, [pc, #16]	; (13fc4 <prvInitialiseTaskLists+0x64>)
   13fb2:	601a      	str	r2, [r3, #0]
}
   13fb4:	bf00      	nop
   13fb6:	b003      	add	sp, #12
   13fb8:	f85d fb04 	ldr.w	pc, [sp], #4
   13fbc:	100006d8 	.word	0x100006d8
   13fc0:	1000073c 	.word	0x1000073c
   13fc4:	10000750 	.word	0x10000750
   13fc8:	1000076c 	.word	0x1000076c
   13fcc:	10000780 	.word	0x10000780
   13fd0:	10000798 	.word	0x10000798
   13fd4:	10000764 	.word	0x10000764
   13fd8:	10000768 	.word	0x10000768

00013fdc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   13fdc:	b500      	push	{lr}
   13fde:	b083      	sub	sp, #12
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   13fe0:	e019      	b.n	14016 <prvCheckTasksWaitingTermination+0x3a>
		{
			taskENTER_CRITICAL();
   13fe2:	f000 fe47 	bl	14c74 <vPortEnterCritical>
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   13fe6:	4b10      	ldr	r3, [pc, #64]	; (14028 <prvCheckTasksWaitingTermination+0x4c>)
   13fe8:	68db      	ldr	r3, [r3, #12]
   13fea:	68db      	ldr	r3, [r3, #12]
   13fec:	9301      	str	r3, [sp, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13fee:	9b01      	ldr	r3, [sp, #4]
   13ff0:	3304      	adds	r3, #4
   13ff2:	4618      	mov	r0, r3
   13ff4:	f7ff fb6e 	bl	136d4 <uxListRemove>
				--uxCurrentNumberOfTasks;
   13ff8:	4b0c      	ldr	r3, [pc, #48]	; (1402c <prvCheckTasksWaitingTermination+0x50>)
   13ffa:	681b      	ldr	r3, [r3, #0]
   13ffc:	3b01      	subs	r3, #1
   13ffe:	4a0b      	ldr	r2, [pc, #44]	; (1402c <prvCheckTasksWaitingTermination+0x50>)
   14000:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
   14002:	4b0b      	ldr	r3, [pc, #44]	; (14030 <prvCheckTasksWaitingTermination+0x54>)
   14004:	681b      	ldr	r3, [r3, #0]
   14006:	3b01      	subs	r3, #1
   14008:	4a09      	ldr	r2, [pc, #36]	; (14030 <prvCheckTasksWaitingTermination+0x54>)
   1400a:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
   1400c:	f000 fe46 	bl	14c9c <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   14010:	9801      	ldr	r0, [sp, #4]
   14012:	f000 f80f 	bl	14034 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   14016:	4b06      	ldr	r3, [pc, #24]	; (14030 <prvCheckTasksWaitingTermination+0x54>)
   14018:	681b      	ldr	r3, [r3, #0]
   1401a:	2b00      	cmp	r3, #0
   1401c:	d1e1      	bne.n	13fe2 <prvCheckTasksWaitingTermination+0x6>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   1401e:	bf00      	nop
   14020:	b003      	add	sp, #12
   14022:	f85d fb04 	ldr.w	pc, [sp], #4
   14026:	bf00      	nop
   14028:	10000780 	.word	0x10000780
   1402c:	100007ac 	.word	0x100007ac
   14030:	10000794 	.word	0x10000794

00014034 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   14034:	b500      	push	{lr}
   14036:	b083      	sub	sp, #12
   14038:	9001      	str	r0, [sp, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   1403a:	9b01      	ldr	r3, [sp, #4]
   1403c:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   14040:	2b00      	cmp	r3, #0
   14042:	d108      	bne.n	14056 <prvDeleteTCB+0x22>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
   14044:	9b01      	ldr	r3, [sp, #4]
   14046:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   14048:	4618      	mov	r0, r3
   1404a:	f000 feb0 	bl	14dae <vPortFree>
				vPortFree( pxTCB );
   1404e:	9801      	ldr	r0, [sp, #4]
   14050:	f000 fead 	bl	14dae <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   14054:	e007      	b.n	14066 <prvDeleteTCB+0x32>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   14056:	9b01      	ldr	r3, [sp, #4]
   14058:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   1405c:	2b01      	cmp	r3, #1
   1405e:	d102      	bne.n	14066 <prvDeleteTCB+0x32>
				vPortFree( pxTCB );
   14060:	9801      	ldr	r0, [sp, #4]
   14062:	f000 fea4 	bl	14dae <vPortFree>
	}
   14066:	bf00      	nop
   14068:	b003      	add	sp, #12
   1406a:	f85d fb04 	ldr.w	pc, [sp], #4
   1406e:	Address 0x000000000001406e is out of bounds.


00014070 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   14070:	b082      	sub	sp, #8
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   14072:	4b0d      	ldr	r3, [pc, #52]	; (140a8 <prvResetNextTaskUnblockTime+0x38>)
   14074:	681b      	ldr	r3, [r3, #0]
   14076:	681b      	ldr	r3, [r3, #0]
   14078:	2b00      	cmp	r3, #0
   1407a:	d101      	bne.n	14080 <prvResetNextTaskUnblockTime+0x10>
   1407c:	2301      	movs	r3, #1
   1407e:	e000      	b.n	14082 <prvResetNextTaskUnblockTime+0x12>
   14080:	2300      	movs	r3, #0
   14082:	2b00      	cmp	r3, #0
   14084:	d004      	beq.n	14090 <prvResetNextTaskUnblockTime+0x20>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   14086:	4b09      	ldr	r3, [pc, #36]	; (140ac <prvResetNextTaskUnblockTime+0x3c>)
   14088:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1408c:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   1408e:	e008      	b.n	140a2 <prvResetNextTaskUnblockTime+0x32>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   14090:	4b05      	ldr	r3, [pc, #20]	; (140a8 <prvResetNextTaskUnblockTime+0x38>)
   14092:	681b      	ldr	r3, [r3, #0]
   14094:	68db      	ldr	r3, [r3, #12]
   14096:	68db      	ldr	r3, [r3, #12]
   14098:	9301      	str	r3, [sp, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   1409a:	9b01      	ldr	r3, [sp, #4]
   1409c:	685b      	ldr	r3, [r3, #4]
   1409e:	4a03      	ldr	r2, [pc, #12]	; (140ac <prvResetNextTaskUnblockTime+0x3c>)
   140a0:	6013      	str	r3, [r2, #0]
}
   140a2:	bf00      	nop
   140a4:	b002      	add	sp, #8
   140a6:	4770      	bx	lr
   140a8:	10000764 	.word	0x10000764
   140ac:	100007cc 	.word	0x100007cc

000140b0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
   140b0:	b500      	push	{lr}
   140b2:	b085      	sub	sp, #20
   140b4:	9001      	str	r0, [sp, #4]
	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
   140b6:	9b01      	ldr	r3, [sp, #4]
   140b8:	9302      	str	r3, [sp, #8]
	BaseType_t xReturn = pdFALSE;
   140ba:	2300      	movs	r3, #0
   140bc:	9303      	str	r3, [sp, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
   140be:	9b01      	ldr	r3, [sp, #4]
   140c0:	2b00      	cmp	r3, #0
   140c2:	d06e      	beq.n	141a2 <xTaskPriorityInherit+0xf2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   140c4:	9b02      	ldr	r3, [sp, #8]
   140c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   140c8:	4b38      	ldr	r3, [pc, #224]	; (141ac <xTaskPriorityInherit+0xfc>)
   140ca:	681b      	ldr	r3, [r3, #0]
   140cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   140ce:	429a      	cmp	r2, r3
   140d0:	d25e      	bcs.n	14190 <xTaskPriorityInherit+0xe0>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   140d2:	9b02      	ldr	r3, [sp, #8]
   140d4:	699b      	ldr	r3, [r3, #24]
   140d6:	2b00      	cmp	r3, #0
   140d8:	db06      	blt.n	140e8 <xTaskPriorityInherit+0x38>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   140da:	4b34      	ldr	r3, [pc, #208]	; (141ac <xTaskPriorityInherit+0xfc>)
   140dc:	681b      	ldr	r3, [r3, #0]
   140de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   140e0:	f1c3 0205 	rsb	r2, r3, #5
   140e4:	9b02      	ldr	r3, [sp, #8]
   140e6:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   140e8:	9b02      	ldr	r3, [sp, #8]
   140ea:	6959      	ldr	r1, [r3, #20]
   140ec:	9b02      	ldr	r3, [sp, #8]
   140ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   140f0:	4613      	mov	r3, r2
   140f2:	009b      	lsls	r3, r3, #2
   140f4:	4413      	add	r3, r2
   140f6:	009b      	lsls	r3, r3, #2
   140f8:	4a2d      	ldr	r2, [pc, #180]	; (141b0 <xTaskPriorityInherit+0x100>)
   140fa:	4413      	add	r3, r2
   140fc:	4299      	cmp	r1, r3
   140fe:	d101      	bne.n	14104 <xTaskPriorityInherit+0x54>
   14100:	2301      	movs	r3, #1
   14102:	e000      	b.n	14106 <xTaskPriorityInherit+0x56>
   14104:	2300      	movs	r3, #0
   14106:	2b00      	cmp	r3, #0
   14108:	d03a      	beq.n	14180 <xTaskPriorityInherit+0xd0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1410a:	9b02      	ldr	r3, [sp, #8]
   1410c:	3304      	adds	r3, #4
   1410e:	4618      	mov	r0, r3
   14110:	f7ff fae0 	bl	136d4 <uxListRemove>
   14114:	4603      	mov	r3, r0
   14116:	2b00      	cmp	r3, #0
   14118:	d115      	bne.n	14146 <xTaskPriorityInherit+0x96>
					{
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
   1411a:	9b02      	ldr	r3, [sp, #8]
   1411c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1411e:	4924      	ldr	r1, [pc, #144]	; (141b0 <xTaskPriorityInherit+0x100>)
   14120:	4613      	mov	r3, r2
   14122:	009b      	lsls	r3, r3, #2
   14124:	4413      	add	r3, r2
   14126:	009b      	lsls	r3, r3, #2
   14128:	440b      	add	r3, r1
   1412a:	681b      	ldr	r3, [r3, #0]
   1412c:	2b00      	cmp	r3, #0
   1412e:	d10a      	bne.n	14146 <xTaskPriorityInherit+0x96>
   14130:	9b02      	ldr	r3, [sp, #8]
   14132:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14134:	2201      	movs	r2, #1
   14136:	fa02 f303 	lsl.w	r3, r2, r3
   1413a:	43da      	mvns	r2, r3
   1413c:	4b1d      	ldr	r3, [pc, #116]	; (141b4 <xTaskPriorityInherit+0x104>)
   1413e:	681b      	ldr	r3, [r3, #0]
   14140:	4013      	ands	r3, r2
   14142:	4a1c      	ldr	r2, [pc, #112]	; (141b4 <xTaskPriorityInherit+0x104>)
   14144:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   14146:	4b19      	ldr	r3, [pc, #100]	; (141ac <xTaskPriorityInherit+0xfc>)
   14148:	681b      	ldr	r3, [r3, #0]
   1414a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1414c:	9b02      	ldr	r3, [sp, #8]
   1414e:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   14150:	9b02      	ldr	r3, [sp, #8]
   14152:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14154:	2201      	movs	r2, #1
   14156:	409a      	lsls	r2, r3
   14158:	4b16      	ldr	r3, [pc, #88]	; (141b4 <xTaskPriorityInherit+0x104>)
   1415a:	681b      	ldr	r3, [r3, #0]
   1415c:	4313      	orrs	r3, r2
   1415e:	4a15      	ldr	r2, [pc, #84]	; (141b4 <xTaskPriorityInherit+0x104>)
   14160:	6013      	str	r3, [r2, #0]
   14162:	9b02      	ldr	r3, [sp, #8]
   14164:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   14166:	4613      	mov	r3, r2
   14168:	009b      	lsls	r3, r3, #2
   1416a:	4413      	add	r3, r2
   1416c:	009b      	lsls	r3, r3, #2
   1416e:	4a10      	ldr	r2, [pc, #64]	; (141b0 <xTaskPriorityInherit+0x100>)
   14170:	441a      	add	r2, r3
   14172:	9b02      	ldr	r3, [sp, #8]
   14174:	3304      	adds	r3, #4
   14176:	4619      	mov	r1, r3
   14178:	4610      	mov	r0, r2
   1417a:	f7ff fa58 	bl	1362e <vListInsertEnd>
   1417e:	e004      	b.n	1418a <xTaskPriorityInherit+0xda>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   14180:	4b0a      	ldr	r3, [pc, #40]	; (141ac <xTaskPriorityInherit+0xfc>)
   14182:	681b      	ldr	r3, [r3, #0]
   14184:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   14186:	9b02      	ldr	r3, [sp, #8]
   14188:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
   1418a:	2301      	movs	r3, #1
   1418c:	9303      	str	r3, [sp, #12]
   1418e:	e008      	b.n	141a2 <xTaskPriorityInherit+0xf2>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   14190:	9b02      	ldr	r3, [sp, #8]
   14192:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   14194:	4b05      	ldr	r3, [pc, #20]	; (141ac <xTaskPriorityInherit+0xfc>)
   14196:	681b      	ldr	r3, [r3, #0]
   14198:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1419a:	429a      	cmp	r2, r3
   1419c:	d201      	bcs.n	141a2 <xTaskPriorityInherit+0xf2>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
   1419e:	2301      	movs	r3, #1
   141a0:	9303      	str	r3, [sp, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   141a2:	9b03      	ldr	r3, [sp, #12]
	}
   141a4:	4618      	mov	r0, r3
   141a6:	b005      	add	sp, #20
   141a8:	f85d fb04 	ldr.w	pc, [sp], #4
   141ac:	100006d4 	.word	0x100006d4
   141b0:	100006d8 	.word	0x100006d8
   141b4:	100007b4 	.word	0x100007b4

000141b8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   141b8:	b500      	push	{lr}
   141ba:	b085      	sub	sp, #20
   141bc:	9001      	str	r0, [sp, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   141be:	9b01      	ldr	r3, [sp, #4]
   141c0:	9302      	str	r3, [sp, #8]
	BaseType_t xReturn = pdFALSE;
   141c2:	2300      	movs	r3, #0
   141c4:	9303      	str	r3, [sp, #12]

		if( pxMutexHolder != NULL )
   141c6:	9b01      	ldr	r3, [sp, #4]
   141c8:	2b00      	cmp	r3, #0
   141ca:	d04f      	beq.n	1426c <xTaskPriorityDisinherit+0xb4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
   141cc:	9b02      	ldr	r3, [sp, #8]
   141ce:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   141d0:	1e5a      	subs	r2, r3, #1
   141d2:	9b02      	ldr	r3, [sp, #8]
   141d4:	651a      	str	r2, [r3, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   141d6:	9b02      	ldr	r3, [sp, #8]
   141d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   141da:	9b02      	ldr	r3, [sp, #8]
   141dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   141de:	429a      	cmp	r2, r3
   141e0:	d044      	beq.n	1426c <xTaskPriorityDisinherit+0xb4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   141e2:	9b02      	ldr	r3, [sp, #8]
   141e4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   141e6:	2b00      	cmp	r3, #0
   141e8:	d140      	bne.n	1426c <xTaskPriorityDisinherit+0xb4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   141ea:	9b02      	ldr	r3, [sp, #8]
   141ec:	3304      	adds	r3, #4
   141ee:	4618      	mov	r0, r3
   141f0:	f7ff fa70 	bl	136d4 <uxListRemove>
   141f4:	4603      	mov	r3, r0
   141f6:	2b00      	cmp	r3, #0
   141f8:	d115      	bne.n	14226 <xTaskPriorityDisinherit+0x6e>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   141fa:	9b02      	ldr	r3, [sp, #8]
   141fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   141fe:	491e      	ldr	r1, [pc, #120]	; (14278 <xTaskPriorityDisinherit+0xc0>)
   14200:	4613      	mov	r3, r2
   14202:	009b      	lsls	r3, r3, #2
   14204:	4413      	add	r3, r2
   14206:	009b      	lsls	r3, r3, #2
   14208:	440b      	add	r3, r1
   1420a:	681b      	ldr	r3, [r3, #0]
   1420c:	2b00      	cmp	r3, #0
   1420e:	d10a      	bne.n	14226 <xTaskPriorityDisinherit+0x6e>
   14210:	9b02      	ldr	r3, [sp, #8]
   14212:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14214:	2201      	movs	r2, #1
   14216:	fa02 f303 	lsl.w	r3, r2, r3
   1421a:	43da      	mvns	r2, r3
   1421c:	4b17      	ldr	r3, [pc, #92]	; (1427c <xTaskPriorityDisinherit+0xc4>)
   1421e:	681b      	ldr	r3, [r3, #0]
   14220:	4013      	ands	r3, r2
   14222:	4a16      	ldr	r2, [pc, #88]	; (1427c <xTaskPriorityDisinherit+0xc4>)
   14224:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   14226:	9b02      	ldr	r3, [sp, #8]
   14228:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   1422a:	9b02      	ldr	r3, [sp, #8]
   1422c:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1422e:	9b02      	ldr	r3, [sp, #8]
   14230:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14232:	f1c3 0205 	rsb	r2, r3, #5
   14236:	9b02      	ldr	r3, [sp, #8]
   14238:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   1423a:	9b02      	ldr	r3, [sp, #8]
   1423c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1423e:	2201      	movs	r2, #1
   14240:	409a      	lsls	r2, r3
   14242:	4b0e      	ldr	r3, [pc, #56]	; (1427c <xTaskPriorityDisinherit+0xc4>)
   14244:	681b      	ldr	r3, [r3, #0]
   14246:	4313      	orrs	r3, r2
   14248:	4a0c      	ldr	r2, [pc, #48]	; (1427c <xTaskPriorityDisinherit+0xc4>)
   1424a:	6013      	str	r3, [r2, #0]
   1424c:	9b02      	ldr	r3, [sp, #8]
   1424e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   14250:	4613      	mov	r3, r2
   14252:	009b      	lsls	r3, r3, #2
   14254:	4413      	add	r3, r2
   14256:	009b      	lsls	r3, r3, #2
   14258:	4a07      	ldr	r2, [pc, #28]	; (14278 <xTaskPriorityDisinherit+0xc0>)
   1425a:	441a      	add	r2, r3
   1425c:	9b02      	ldr	r3, [sp, #8]
   1425e:	3304      	adds	r3, #4
   14260:	4619      	mov	r1, r3
   14262:	4610      	mov	r0, r2
   14264:	f7ff f9e3 	bl	1362e <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
   14268:	2301      	movs	r3, #1
   1426a:	9303      	str	r3, [sp, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   1426c:	9b03      	ldr	r3, [sp, #12]
	}
   1426e:	4618      	mov	r0, r3
   14270:	b005      	add	sp, #20
   14272:	f85d fb04 	ldr.w	pc, [sp], #4
   14276:	bf00      	nop
   14278:	100006d8 	.word	0x100006d8
   1427c:	100007b4 	.word	0x100007b4

00014280 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
   14280:	b500      	push	{lr}
   14282:	b087      	sub	sp, #28
   14284:	9001      	str	r0, [sp, #4]
   14286:	9100      	str	r1, [sp, #0]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   14288:	9b01      	ldr	r3, [sp, #4]
   1428a:	9304      	str	r3, [sp, #16]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
   1428c:	2301      	movs	r3, #1
   1428e:	9303      	str	r3, [sp, #12]

		if( pxMutexHolder != NULL )
   14290:	9b01      	ldr	r3, [sp, #4]
   14292:	2b00      	cmp	r3, #0
   14294:	d068      	beq.n	14368 <vTaskPriorityDisinheritAfterTimeout+0xe8>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   14296:	9b04      	ldr	r3, [sp, #16]
   14298:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   1429a:	9a00      	ldr	r2, [sp, #0]
   1429c:	429a      	cmp	r2, r3
   1429e:	d902      	bls.n	142a6 <vTaskPriorityDisinheritAfterTimeout+0x26>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
   142a0:	9b00      	ldr	r3, [sp, #0]
   142a2:	9305      	str	r3, [sp, #20]
   142a4:	e002      	b.n	142ac <vTaskPriorityDisinheritAfterTimeout+0x2c>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
   142a6:	9b04      	ldr	r3, [sp, #16]
   142a8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   142aa:	9305      	str	r3, [sp, #20]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
   142ac:	9b04      	ldr	r3, [sp, #16]
   142ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   142b0:	9a05      	ldr	r2, [sp, #20]
   142b2:	429a      	cmp	r2, r3
   142b4:	d058      	beq.n	14368 <vTaskPriorityDisinheritAfterTimeout+0xe8>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   142b6:	9b04      	ldr	r3, [sp, #16]
   142b8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   142ba:	9a03      	ldr	r2, [sp, #12]
   142bc:	429a      	cmp	r2, r3
   142be:	d153      	bne.n	14368 <vTaskPriorityDisinheritAfterTimeout+0xe8>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   142c0:	9b04      	ldr	r3, [sp, #16]
   142c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   142c4:	9302      	str	r3, [sp, #8]
					pxTCB->uxPriority = uxPriorityToUse;
   142c6:	9b04      	ldr	r3, [sp, #16]
   142c8:	9a05      	ldr	r2, [sp, #20]
   142ca:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   142cc:	9b04      	ldr	r3, [sp, #16]
   142ce:	699b      	ldr	r3, [r3, #24]
   142d0:	2b00      	cmp	r3, #0
   142d2:	db04      	blt.n	142de <vTaskPriorityDisinheritAfterTimeout+0x5e>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   142d4:	9b05      	ldr	r3, [sp, #20]
   142d6:	f1c3 0205 	rsb	r2, r3, #5
   142da:	9b04      	ldr	r3, [sp, #16]
   142dc:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   142de:	9b04      	ldr	r3, [sp, #16]
   142e0:	6959      	ldr	r1, [r3, #20]
   142e2:	9a02      	ldr	r2, [sp, #8]
   142e4:	4613      	mov	r3, r2
   142e6:	009b      	lsls	r3, r3, #2
   142e8:	4413      	add	r3, r2
   142ea:	009b      	lsls	r3, r3, #2
   142ec:	4a20      	ldr	r2, [pc, #128]	; (14370 <vTaskPriorityDisinheritAfterTimeout+0xf0>)
   142ee:	4413      	add	r3, r2
   142f0:	4299      	cmp	r1, r3
   142f2:	d101      	bne.n	142f8 <vTaskPriorityDisinheritAfterTimeout+0x78>
   142f4:	2301      	movs	r3, #1
   142f6:	e000      	b.n	142fa <vTaskPriorityDisinheritAfterTimeout+0x7a>
   142f8:	2300      	movs	r3, #0
   142fa:	2b00      	cmp	r3, #0
   142fc:	d034      	beq.n	14368 <vTaskPriorityDisinheritAfterTimeout+0xe8>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   142fe:	9b04      	ldr	r3, [sp, #16]
   14300:	3304      	adds	r3, #4
   14302:	4618      	mov	r0, r3
   14304:	f7ff f9e6 	bl	136d4 <uxListRemove>
   14308:	4603      	mov	r3, r0
   1430a:	2b00      	cmp	r3, #0
   1430c:	d115      	bne.n	1433a <vTaskPriorityDisinheritAfterTimeout+0xba>
						{
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1430e:	9b04      	ldr	r3, [sp, #16]
   14310:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   14312:	4917      	ldr	r1, [pc, #92]	; (14370 <vTaskPriorityDisinheritAfterTimeout+0xf0>)
   14314:	4613      	mov	r3, r2
   14316:	009b      	lsls	r3, r3, #2
   14318:	4413      	add	r3, r2
   1431a:	009b      	lsls	r3, r3, #2
   1431c:	440b      	add	r3, r1
   1431e:	681b      	ldr	r3, [r3, #0]
   14320:	2b00      	cmp	r3, #0
   14322:	d10a      	bne.n	1433a <vTaskPriorityDisinheritAfterTimeout+0xba>
   14324:	9b04      	ldr	r3, [sp, #16]
   14326:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14328:	2201      	movs	r2, #1
   1432a:	fa02 f303 	lsl.w	r3, r2, r3
   1432e:	43da      	mvns	r2, r3
   14330:	4b10      	ldr	r3, [pc, #64]	; (14374 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   14332:	681b      	ldr	r3, [r3, #0]
   14334:	4013      	ands	r3, r2
   14336:	4a0f      	ldr	r2, [pc, #60]	; (14374 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   14338:	6013      	str	r3, [r2, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
   1433a:	9b04      	ldr	r3, [sp, #16]
   1433c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1433e:	2201      	movs	r2, #1
   14340:	409a      	lsls	r2, r3
   14342:	4b0c      	ldr	r3, [pc, #48]	; (14374 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   14344:	681b      	ldr	r3, [r3, #0]
   14346:	4313      	orrs	r3, r2
   14348:	4a0a      	ldr	r2, [pc, #40]	; (14374 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   1434a:	6013      	str	r3, [r2, #0]
   1434c:	9b04      	ldr	r3, [sp, #16]
   1434e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   14350:	4613      	mov	r3, r2
   14352:	009b      	lsls	r3, r3, #2
   14354:	4413      	add	r3, r2
   14356:	009b      	lsls	r3, r3, #2
   14358:	4a05      	ldr	r2, [pc, #20]	; (14370 <vTaskPriorityDisinheritAfterTimeout+0xf0>)
   1435a:	441a      	add	r2, r3
   1435c:	9b04      	ldr	r3, [sp, #16]
   1435e:	3304      	adds	r3, #4
   14360:	4619      	mov	r1, r3
   14362:	4610      	mov	r0, r2
   14364:	f7ff f963 	bl	1362e <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   14368:	bf00      	nop
   1436a:	b007      	add	sp, #28
   1436c:	f85d fb04 	ldr.w	pc, [sp], #4
   14370:	100006d8 	.word	0x100006d8
   14374:	100007b4 	.word	0x100007b4

00014378 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
   14378:	4b06      	ldr	r3, [pc, #24]	; (14394 <pvTaskIncrementMutexHeldCount+0x1c>)
   1437a:	681b      	ldr	r3, [r3, #0]
   1437c:	2b00      	cmp	r3, #0
   1437e:	d004      	beq.n	1438a <pvTaskIncrementMutexHeldCount+0x12>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
   14380:	4b04      	ldr	r3, [pc, #16]	; (14394 <pvTaskIncrementMutexHeldCount+0x1c>)
   14382:	681b      	ldr	r3, [r3, #0]
   14384:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   14386:	3201      	adds	r2, #1
   14388:	651a      	str	r2, [r3, #80]	; 0x50
		}

		return pxCurrentTCB;
   1438a:	4b02      	ldr	r3, [pc, #8]	; (14394 <pvTaskIncrementMutexHeldCount+0x1c>)
   1438c:	681b      	ldr	r3, [r3, #0]
	}
   1438e:	4618      	mov	r0, r3
   14390:	4770      	bx	lr
   14392:	bf00      	nop
   14394:	100006d4 	.word	0x100006d4

00014398 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   14398:	b500      	push	{lr}
   1439a:	b085      	sub	sp, #20
   1439c:	9001      	str	r0, [sp, #4]
   1439e:	9100      	str	r1, [sp, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   143a0:	4b28      	ldr	r3, [pc, #160]	; (14444 <prvAddCurrentTaskToDelayedList+0xac>)
   143a2:	681b      	ldr	r3, [r3, #0]
   143a4:	9303      	str	r3, [sp, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   143a6:	4b28      	ldr	r3, [pc, #160]	; (14448 <prvAddCurrentTaskToDelayedList+0xb0>)
   143a8:	681b      	ldr	r3, [r3, #0]
   143aa:	3304      	adds	r3, #4
   143ac:	4618      	mov	r0, r3
   143ae:	f7ff f991 	bl	136d4 <uxListRemove>
   143b2:	4603      	mov	r3, r0
   143b4:	2b00      	cmp	r3, #0
   143b6:	d10b      	bne.n	143d0 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   143b8:	4b23      	ldr	r3, [pc, #140]	; (14448 <prvAddCurrentTaskToDelayedList+0xb0>)
   143ba:	681b      	ldr	r3, [r3, #0]
   143bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   143be:	2201      	movs	r2, #1
   143c0:	fa02 f303 	lsl.w	r3, r2, r3
   143c4:	43da      	mvns	r2, r3
   143c6:	4b21      	ldr	r3, [pc, #132]	; (1444c <prvAddCurrentTaskToDelayedList+0xb4>)
   143c8:	681b      	ldr	r3, [r3, #0]
   143ca:	4013      	ands	r3, r2
   143cc:	4a1f      	ldr	r2, [pc, #124]	; (1444c <prvAddCurrentTaskToDelayedList+0xb4>)
   143ce:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   143d0:	9b01      	ldr	r3, [sp, #4]
   143d2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   143d6:	d10a      	bne.n	143ee <prvAddCurrentTaskToDelayedList+0x56>
   143d8:	9b00      	ldr	r3, [sp, #0]
   143da:	2b00      	cmp	r3, #0
   143dc:	d007      	beq.n	143ee <prvAddCurrentTaskToDelayedList+0x56>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   143de:	4b1a      	ldr	r3, [pc, #104]	; (14448 <prvAddCurrentTaskToDelayedList+0xb0>)
   143e0:	681b      	ldr	r3, [r3, #0]
   143e2:	3304      	adds	r3, #4
   143e4:	4619      	mov	r1, r3
   143e6:	481a      	ldr	r0, [pc, #104]	; (14450 <prvAddCurrentTaskToDelayedList+0xb8>)
   143e8:	f7ff f921 	bl	1362e <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   143ec:	e026      	b.n	1443c <prvAddCurrentTaskToDelayedList+0xa4>
			xTimeToWake = xConstTickCount + xTicksToWait;
   143ee:	9a03      	ldr	r2, [sp, #12]
   143f0:	9b01      	ldr	r3, [sp, #4]
   143f2:	4413      	add	r3, r2
   143f4:	9302      	str	r3, [sp, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   143f6:	4b14      	ldr	r3, [pc, #80]	; (14448 <prvAddCurrentTaskToDelayedList+0xb0>)
   143f8:	681b      	ldr	r3, [r3, #0]
   143fa:	9a02      	ldr	r2, [sp, #8]
   143fc:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
   143fe:	9a02      	ldr	r2, [sp, #8]
   14400:	9b03      	ldr	r3, [sp, #12]
   14402:	429a      	cmp	r2, r3
   14404:	d209      	bcs.n	1441a <prvAddCurrentTaskToDelayedList+0x82>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   14406:	4b13      	ldr	r3, [pc, #76]	; (14454 <prvAddCurrentTaskToDelayedList+0xbc>)
   14408:	681a      	ldr	r2, [r3, #0]
   1440a:	4b0f      	ldr	r3, [pc, #60]	; (14448 <prvAddCurrentTaskToDelayedList+0xb0>)
   1440c:	681b      	ldr	r3, [r3, #0]
   1440e:	3304      	adds	r3, #4
   14410:	4619      	mov	r1, r3
   14412:	4610      	mov	r0, r2
   14414:	f7ff f92a 	bl	1366c <vListInsert>
}
   14418:	e010      	b.n	1443c <prvAddCurrentTaskToDelayedList+0xa4>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   1441a:	4b0f      	ldr	r3, [pc, #60]	; (14458 <prvAddCurrentTaskToDelayedList+0xc0>)
   1441c:	681a      	ldr	r2, [r3, #0]
   1441e:	4b0a      	ldr	r3, [pc, #40]	; (14448 <prvAddCurrentTaskToDelayedList+0xb0>)
   14420:	681b      	ldr	r3, [r3, #0]
   14422:	3304      	adds	r3, #4
   14424:	4619      	mov	r1, r3
   14426:	4610      	mov	r0, r2
   14428:	f7ff f920 	bl	1366c <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   1442c:	4b0b      	ldr	r3, [pc, #44]	; (1445c <prvAddCurrentTaskToDelayedList+0xc4>)
   1442e:	681b      	ldr	r3, [r3, #0]
   14430:	9a02      	ldr	r2, [sp, #8]
   14432:	429a      	cmp	r2, r3
   14434:	d202      	bcs.n	1443c <prvAddCurrentTaskToDelayedList+0xa4>
					xNextTaskUnblockTime = xTimeToWake;
   14436:	4a09      	ldr	r2, [pc, #36]	; (1445c <prvAddCurrentTaskToDelayedList+0xc4>)
   14438:	9b02      	ldr	r3, [sp, #8]
   1443a:	6013      	str	r3, [r2, #0]
}
   1443c:	bf00      	nop
   1443e:	b005      	add	sp, #20
   14440:	f85d fb04 	ldr.w	pc, [sp], #4
   14444:	100007b0 	.word	0x100007b0
   14448:	100006d4 	.word	0x100006d4
   1444c:	100007b4 	.word	0x100007b4
   14450:	10000798 	.word	0x10000798
   14454:	10000768 	.word	0x10000768
   14458:	10000764 	.word	0x10000764
   1445c:	100007cc 	.word	0x100007cc

00014460 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   14460:	b500      	push	{lr}
   14462:	b085      	sub	sp, #20
   14464:	9001      	str	r0, [sp, #4]
   14466:	9100      	str	r1, [sp, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   14468:	9b01      	ldr	r3, [sp, #4]
   1446a:	9303      	str	r3, [sp, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   1446c:	f000 fc02 	bl	14c74 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   14470:	9b03      	ldr	r3, [sp, #12]
   14472:	681a      	ldr	r2, [r3, #0]
   14474:	9b03      	ldr	r3, [sp, #12]
   14476:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   14478:	9903      	ldr	r1, [sp, #12]
   1447a:	6c09      	ldr	r1, [r1, #64]	; 0x40
   1447c:	fb01 f303 	mul.w	r3, r1, r3
   14480:	441a      	add	r2, r3
   14482:	9b03      	ldr	r3, [sp, #12]
   14484:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   14486:	9b03      	ldr	r3, [sp, #12]
   14488:	2200      	movs	r2, #0
   1448a:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   1448c:	9b03      	ldr	r3, [sp, #12]
   1448e:	681a      	ldr	r2, [r3, #0]
   14490:	9b03      	ldr	r3, [sp, #12]
   14492:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   14494:	9b03      	ldr	r3, [sp, #12]
   14496:	681a      	ldr	r2, [r3, #0]
   14498:	9b03      	ldr	r3, [sp, #12]
   1449a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1449c:	3b01      	subs	r3, #1
   1449e:	9903      	ldr	r1, [sp, #12]
   144a0:	6c09      	ldr	r1, [r1, #64]	; 0x40
   144a2:	fb01 f303 	mul.w	r3, r1, r3
   144a6:	441a      	add	r2, r3
   144a8:	9b03      	ldr	r3, [sp, #12]
   144aa:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   144ac:	9b03      	ldr	r3, [sp, #12]
   144ae:	22ff      	movs	r2, #255	; 0xff
   144b0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   144b4:	9b03      	ldr	r3, [sp, #12]
   144b6:	22ff      	movs	r2, #255	; 0xff
   144b8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
   144bc:	9b00      	ldr	r3, [sp, #0]
   144be:	2b00      	cmp	r3, #0
   144c0:	d114      	bne.n	144ec <xQueueGenericReset+0x8c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   144c2:	9b03      	ldr	r3, [sp, #12]
   144c4:	691b      	ldr	r3, [r3, #16]
   144c6:	2b00      	cmp	r3, #0
   144c8:	d01a      	beq.n	14500 <xQueueGenericReset+0xa0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   144ca:	9b03      	ldr	r3, [sp, #12]
   144cc:	3310      	adds	r3, #16
   144ce:	4618      	mov	r0, r3
   144d0:	f7ff fc8c 	bl	13dec <xTaskRemoveFromEventList>
   144d4:	4603      	mov	r3, r0
   144d6:	2b00      	cmp	r3, #0
   144d8:	d012      	beq.n	14500 <xQueueGenericReset+0xa0>
				{
					queueYIELD_IF_USING_PREEMPTION();
   144da:	4b0d      	ldr	r3, [pc, #52]	; (14510 <xQueueGenericReset+0xb0>)
   144dc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   144e0:	601a      	str	r2, [r3, #0]
   144e2:	f3bf 8f4f 	dsb	sy
   144e6:	f3bf 8f6f 	isb	sy
   144ea:	e009      	b.n	14500 <xQueueGenericReset+0xa0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   144ec:	9b03      	ldr	r3, [sp, #12]
   144ee:	3310      	adds	r3, #16
   144f0:	4618      	mov	r0, r3
   144f2:	f7ff f879 	bl	135e8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   144f6:	9b03      	ldr	r3, [sp, #12]
   144f8:	3324      	adds	r3, #36	; 0x24
   144fa:	4618      	mov	r0, r3
   144fc:	f7ff f874 	bl	135e8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   14500:	f000 fbcc 	bl	14c9c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   14504:	2301      	movs	r3, #1
}
   14506:	4618      	mov	r0, r3
   14508:	b005      	add	sp, #20
   1450a:	f85d fb04 	ldr.w	pc, [sp], #4
   1450e:	bf00      	nop
   14510:	e000ed04 	.word	0xe000ed04

00014514 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
   14514:	b500      	push	{lr}
   14516:	b08b      	sub	sp, #44	; 0x2c
   14518:	9005      	str	r0, [sp, #20]
   1451a:	9104      	str	r1, [sp, #16]
   1451c:	4613      	mov	r3, r2
   1451e:	f88d 300f 	strb.w	r3, [sp, #15]
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
   14522:	9b04      	ldr	r3, [sp, #16]
   14524:	2b00      	cmp	r3, #0
   14526:	d102      	bne.n	1452e <xQueueGenericCreate+0x1a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
   14528:	2300      	movs	r3, #0
   1452a:	9309      	str	r3, [sp, #36]	; 0x24
   1452c:	e004      	b.n	14538 <xQueueGenericCreate+0x24>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1452e:	9b05      	ldr	r3, [sp, #20]
   14530:	9a04      	ldr	r2, [sp, #16]
   14532:	fb02 f303 	mul.w	r3, r2, r3
   14536:	9309      	str	r3, [sp, #36]	; 0x24
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   14538:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1453a:	3350      	adds	r3, #80	; 0x50
   1453c:	4618      	mov	r0, r3
   1453e:	f000 fc25 	bl	14d8c <pvPortMalloc>
   14542:	9008      	str	r0, [sp, #32]

		if( pxNewQueue != NULL )
   14544:	9b08      	ldr	r3, [sp, #32]
   14546:	2b00      	cmp	r3, #0
   14548:	d010      	beq.n	1456c <xQueueGenericCreate+0x58>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   1454a:	9b08      	ldr	r3, [sp, #32]
   1454c:	3350      	adds	r3, #80	; 0x50
   1454e:	9307      	str	r3, [sp, #28]
			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
   14550:	9b08      	ldr	r3, [sp, #32]
   14552:	2200      	movs	r2, #0
   14554:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   14558:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1455c:	9b08      	ldr	r3, [sp, #32]
   1455e:	9300      	str	r3, [sp, #0]
   14560:	4613      	mov	r3, r2
   14562:	9a07      	ldr	r2, [sp, #28]
   14564:	9904      	ldr	r1, [sp, #16]
   14566:	9805      	ldr	r0, [sp, #20]
   14568:	f000 f805 	bl	14576 <prvInitialiseNewQueue>
		else
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
   1456c:	9b08      	ldr	r3, [sp, #32]
	}
   1456e:	4618      	mov	r0, r3
   14570:	b00b      	add	sp, #44	; 0x2c
   14572:	f85d fb04 	ldr.w	pc, [sp], #4

00014576 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
   14576:	b500      	push	{lr}
   14578:	b085      	sub	sp, #20
   1457a:	9003      	str	r0, [sp, #12]
   1457c:	9102      	str	r1, [sp, #8]
   1457e:	9201      	str	r2, [sp, #4]
   14580:	f88d 3003 	strb.w	r3, [sp, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
   14584:	9b02      	ldr	r3, [sp, #8]
   14586:	2b00      	cmp	r3, #0
   14588:	d103      	bne.n	14592 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   1458a:	9b06      	ldr	r3, [sp, #24]
   1458c:	9a06      	ldr	r2, [sp, #24]
   1458e:	601a      	str	r2, [r3, #0]
   14590:	e002      	b.n	14598 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   14592:	9b06      	ldr	r3, [sp, #24]
   14594:	9a01      	ldr	r2, [sp, #4]
   14596:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
   14598:	9b06      	ldr	r3, [sp, #24]
   1459a:	9a03      	ldr	r2, [sp, #12]
   1459c:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   1459e:	9b06      	ldr	r3, [sp, #24]
   145a0:	9a02      	ldr	r2, [sp, #8]
   145a2:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   145a4:	2101      	movs	r1, #1
   145a6:	9806      	ldr	r0, [sp, #24]
   145a8:	f7ff ff5a 	bl	14460 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
   145ac:	9b06      	ldr	r3, [sp, #24]
   145ae:	f89d 2003 	ldrb.w	r2, [sp, #3]
   145b2:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
   145b6:	bf00      	nop
   145b8:	b005      	add	sp, #20
   145ba:	f85d fb04 	ldr.w	pc, [sp], #4
   145be:	Address 0x00000000000145be is out of bounds.


000145c0 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
   145c0:	b500      	push	{lr}
   145c2:	b08b      	sub	sp, #44	; 0x2c
   145c4:	9003      	str	r0, [sp, #12]
   145c6:	9102      	str	r1, [sp, #8]
   145c8:	9201      	str	r2, [sp, #4]
   145ca:	9300      	str	r3, [sp, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   145cc:	2300      	movs	r3, #0
   145ce:	9309      	str	r3, [sp, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   145d0:	9b03      	ldr	r3, [sp, #12]
   145d2:	9308      	str	r3, [sp, #32]
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   145d4:	f000 fb4e 	bl	14c74 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   145d8:	9b08      	ldr	r3, [sp, #32]
   145da:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   145dc:	9b08      	ldr	r3, [sp, #32]
   145de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   145e0:	429a      	cmp	r2, r3
   145e2:	d302      	bcc.n	145ea <xQueueGenericSend+0x2a>
   145e4:	9b00      	ldr	r3, [sp, #0]
   145e6:	2b02      	cmp	r3, #2
   145e8:	d129      	bne.n	1463e <xQueueGenericSend+0x7e>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   145ea:	9a00      	ldr	r2, [sp, #0]
   145ec:	9902      	ldr	r1, [sp, #8]
   145ee:	9808      	ldr	r0, [sp, #32]
   145f0:	f000 f9bb 	bl	1496a <prvCopyDataToQueue>
   145f4:	9007      	str	r0, [sp, #28]
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   145f6:	9b08      	ldr	r3, [sp, #32]
   145f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   145fa:	2b00      	cmp	r3, #0
   145fc:	d010      	beq.n	14620 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   145fe:	9b08      	ldr	r3, [sp, #32]
   14600:	3324      	adds	r3, #36	; 0x24
   14602:	4618      	mov	r0, r3
   14604:	f7ff fbf2 	bl	13dec <xTaskRemoveFromEventList>
   14608:	4603      	mov	r3, r0
   1460a:	2b00      	cmp	r3, #0
   1460c:	d013      	beq.n	14636 <xQueueGenericSend+0x76>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
   1460e:	4b3f      	ldr	r3, [pc, #252]	; (1470c <xQueueGenericSend+0x14c>)
   14610:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   14614:	601a      	str	r2, [r3, #0]
   14616:	f3bf 8f4f 	dsb	sy
   1461a:	f3bf 8f6f 	isb	sy
   1461e:	e00a      	b.n	14636 <xQueueGenericSend+0x76>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
   14620:	9b07      	ldr	r3, [sp, #28]
   14622:	2b00      	cmp	r3, #0
   14624:	d007      	beq.n	14636 <xQueueGenericSend+0x76>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
   14626:	4b39      	ldr	r3, [pc, #228]	; (1470c <xQueueGenericSend+0x14c>)
   14628:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1462c:	601a      	str	r2, [r3, #0]
   1462e:	f3bf 8f4f 	dsb	sy
   14632:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
   14636:	f000 fb31 	bl	14c9c <vPortExitCritical>
				return pdPASS;
   1463a:	2301      	movs	r3, #1
   1463c:	e061      	b.n	14702 <xQueueGenericSend+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   1463e:	9b01      	ldr	r3, [sp, #4]
   14640:	2b00      	cmp	r3, #0
   14642:	d103      	bne.n	1464c <xQueueGenericSend+0x8c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   14644:	f000 fb2a 	bl	14c9c <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   14648:	2300      	movs	r3, #0
   1464a:	e05a      	b.n	14702 <xQueueGenericSend+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
   1464c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1464e:	2b00      	cmp	r3, #0
   14650:	d105      	bne.n	1465e <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   14652:	ab05      	add	r3, sp, #20
   14654:	4618      	mov	r0, r3
   14656:	f7ff fc1d 	bl	13e94 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   1465a:	2301      	movs	r3, #1
   1465c:	9309      	str	r3, [sp, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   1465e:	f000 fb1d 	bl	14c9c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   14662:	f7ff fa07 	bl	13a74 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   14666:	f000 fb05 	bl	14c74 <vPortEnterCritical>
   1466a:	9b08      	ldr	r3, [sp, #32]
   1466c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   14670:	b25b      	sxtb	r3, r3
   14672:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   14676:	d103      	bne.n	14680 <xQueueGenericSend+0xc0>
   14678:	9b08      	ldr	r3, [sp, #32]
   1467a:	2200      	movs	r2, #0
   1467c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   14680:	9b08      	ldr	r3, [sp, #32]
   14682:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   14686:	b25b      	sxtb	r3, r3
   14688:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1468c:	d103      	bne.n	14696 <xQueueGenericSend+0xd6>
   1468e:	9b08      	ldr	r3, [sp, #32]
   14690:	2200      	movs	r2, #0
   14692:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   14696:	f000 fb01 	bl	14c9c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1469a:	aa01      	add	r2, sp, #4
   1469c:	ab05      	add	r3, sp, #20
   1469e:	4611      	mov	r1, r2
   146a0:	4618      	mov	r0, r3
   146a2:	f7ff fc09 	bl	13eb8 <xTaskCheckForTimeOut>
   146a6:	4603      	mov	r3, r0
   146a8:	2b00      	cmp	r3, #0
   146aa:	d124      	bne.n	146f6 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   146ac:	9808      	ldr	r0, [sp, #32]
   146ae:	f000 fa31 	bl	14b14 <prvIsQueueFull>
   146b2:	4603      	mov	r3, r0
   146b4:	2b00      	cmp	r3, #0
   146b6:	d018      	beq.n	146ea <xQueueGenericSend+0x12a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   146b8:	9b08      	ldr	r3, [sp, #32]
   146ba:	3310      	adds	r3, #16
   146bc:	9a01      	ldr	r2, [sp, #4]
   146be:	4611      	mov	r1, r2
   146c0:	4618      	mov	r0, r3
   146c2:	f7ff fb7d 	bl	13dc0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   146c6:	9808      	ldr	r0, [sp, #32]
   146c8:	f000 f9b8 	bl	14a3c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   146cc:	f7ff f9dc 	bl	13a88 <xTaskResumeAll>
   146d0:	4603      	mov	r3, r0
   146d2:	2b00      	cmp	r3, #0
   146d4:	f47f af7e 	bne.w	145d4 <xQueueGenericSend+0x14>
				{
					portYIELD_WITHIN_API();
   146d8:	4b0c      	ldr	r3, [pc, #48]	; (1470c <xQueueGenericSend+0x14c>)
   146da:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   146de:	601a      	str	r2, [r3, #0]
   146e0:	f3bf 8f4f 	dsb	sy
   146e4:	f3bf 8f6f 	isb	sy
   146e8:	e774      	b.n	145d4 <xQueueGenericSend+0x14>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   146ea:	9808      	ldr	r0, [sp, #32]
   146ec:	f000 f9a6 	bl	14a3c <prvUnlockQueue>
				( void ) xTaskResumeAll();
   146f0:	f7ff f9ca 	bl	13a88 <xTaskResumeAll>
   146f4:	e76e      	b.n	145d4 <xQueueGenericSend+0x14>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   146f6:	9808      	ldr	r0, [sp, #32]
   146f8:	f000 f9a0 	bl	14a3c <prvUnlockQueue>
			( void ) xTaskResumeAll();
   146fc:	f7ff f9c4 	bl	13a88 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   14700:	2300      	movs	r3, #0
		}
	}
}
   14702:	4618      	mov	r0, r3
   14704:	b00b      	add	sp, #44	; 0x2c
   14706:	f85d fb04 	ldr.w	pc, [sp], #4
   1470a:	bf00      	nop
   1470c:	e000ed04 	.word	0xe000ed04

00014710 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
   14710:	b500      	push	{lr}
   14712:	b08b      	sub	sp, #44	; 0x2c
   14714:	9001      	str	r0, [sp, #4]
   14716:	9100      	str	r1, [sp, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   14718:	9b01      	ldr	r3, [sp, #4]
   1471a:	9308      	str	r3, [sp, #32]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   1471c:	f3ef 8211 	mrs	r2, BASEPRI
   14720:	f04f 0328 	mov.w	r3, #40	; 0x28
   14724:	f383 8811 	msr	BASEPRI, r3
   14728:	f3bf 8f6f 	isb	sy
   1472c:	f3bf 8f4f 	dsb	sy
   14730:	9204      	str	r2, [sp, #16]
   14732:	9303      	str	r3, [sp, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   14734:	9b04      	ldr	r3, [sp, #16]
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   14736:	9307      	str	r3, [sp, #28]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   14738:	9b08      	ldr	r3, [sp, #32]
   1473a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1473c:	9306      	str	r3, [sp, #24]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
   1473e:	9b08      	ldr	r3, [sp, #32]
   14740:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   14742:	9a06      	ldr	r2, [sp, #24]
   14744:	429a      	cmp	r2, r3
   14746:	d22b      	bcs.n	147a0 <xQueueGiveFromISR+0x90>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   14748:	9b08      	ldr	r3, [sp, #32]
   1474a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   1474e:	f88d 3017 	strb.w	r3, [sp, #23]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   14752:	9b06      	ldr	r3, [sp, #24]
   14754:	1c5a      	adds	r2, r3, #1
   14756:	9b08      	ldr	r3, [sp, #32]
   14758:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   1475a:	f99d 3017 	ldrsb.w	r3, [sp, #23]
   1475e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   14762:	d112      	bne.n	1478a <xQueueGiveFromISR+0x7a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   14764:	9b08      	ldr	r3, [sp, #32]
   14766:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   14768:	2b00      	cmp	r3, #0
   1476a:	d016      	beq.n	1479a <xQueueGiveFromISR+0x8a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1476c:	9b08      	ldr	r3, [sp, #32]
   1476e:	3324      	adds	r3, #36	; 0x24
   14770:	4618      	mov	r0, r3
   14772:	f7ff fb3b 	bl	13dec <xTaskRemoveFromEventList>
   14776:	4603      	mov	r3, r0
   14778:	2b00      	cmp	r3, #0
   1477a:	d00e      	beq.n	1479a <xQueueGiveFromISR+0x8a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   1477c:	9b00      	ldr	r3, [sp, #0]
   1477e:	2b00      	cmp	r3, #0
   14780:	d00b      	beq.n	1479a <xQueueGiveFromISR+0x8a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   14782:	9b00      	ldr	r3, [sp, #0]
   14784:	2201      	movs	r2, #1
   14786:	601a      	str	r2, [r3, #0]
   14788:	e007      	b.n	1479a <xQueueGiveFromISR+0x8a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   1478a:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1478e:	3301      	adds	r3, #1
   14790:	b2db      	uxtb	r3, r3
   14792:	b25a      	sxtb	r2, r3
   14794:	9b08      	ldr	r3, [sp, #32]
   14796:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
   1479a:	2301      	movs	r3, #1
   1479c:	9309      	str	r3, [sp, #36]	; 0x24
   1479e:	e001      	b.n	147a4 <xQueueGiveFromISR+0x94>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   147a0:	2300      	movs	r3, #0
   147a2:	9309      	str	r3, [sp, #36]	; 0x24
   147a4:	9b07      	ldr	r3, [sp, #28]
   147a6:	9302      	str	r3, [sp, #8]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   147a8:	9b02      	ldr	r3, [sp, #8]
   147aa:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   147ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
   147b0:	4618      	mov	r0, r3
   147b2:	b00b      	add	sp, #44	; 0x2c
   147b4:	f85d fb04 	ldr.w	pc, [sp], #4

000147b8 <xQueueSemaphoreTake>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
   147b8:	b500      	push	{lr}
   147ba:	b08b      	sub	sp, #44	; 0x2c
   147bc:	9001      	str	r0, [sp, #4]
   147be:	9100      	str	r1, [sp, #0]
BaseType_t xEntryTimeSet = pdFALSE;
   147c0:	2300      	movs	r3, #0
   147c2:	9309      	str	r3, [sp, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   147c4:	9b01      	ldr	r3, [sp, #4]
   147c6:	9307      	str	r3, [sp, #28]

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
   147c8:	2300      	movs	r3, #0
   147ca:	9308      	str	r3, [sp, #32]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   147cc:	f000 fa52 	bl	14c74 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   147d0:	9b07      	ldr	r3, [sp, #28]
   147d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   147d4:	9306      	str	r3, [sp, #24]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   147d6:	9b06      	ldr	r3, [sp, #24]
   147d8:	2b00      	cmp	r3, #0
   147da:	d024      	beq.n	14826 <xQueueSemaphoreTake+0x6e>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   147dc:	9b06      	ldr	r3, [sp, #24]
   147de:	1e5a      	subs	r2, r3, #1
   147e0:	9b07      	ldr	r3, [sp, #28]
   147e2:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   147e4:	9b07      	ldr	r3, [sp, #28]
   147e6:	681b      	ldr	r3, [r3, #0]
   147e8:	2b00      	cmp	r3, #0
   147ea:	d104      	bne.n	147f6 <xQueueSemaphoreTake+0x3e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
   147ec:	f7ff fdc4 	bl	14378 <pvTaskIncrementMutexHeldCount>
   147f0:	4602      	mov	r2, r0
   147f2:	9b07      	ldr	r3, [sp, #28]
   147f4:	605a      	str	r2, [r3, #4]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   147f6:	9b07      	ldr	r3, [sp, #28]
   147f8:	691b      	ldr	r3, [r3, #16]
   147fa:	2b00      	cmp	r3, #0
   147fc:	d00f      	beq.n	1481e <xQueueSemaphoreTake+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   147fe:	9b07      	ldr	r3, [sp, #28]
   14800:	3310      	adds	r3, #16
   14802:	4618      	mov	r0, r3
   14804:	f7ff faf2 	bl	13dec <xTaskRemoveFromEventList>
   14808:	4603      	mov	r3, r0
   1480a:	2b00      	cmp	r3, #0
   1480c:	d007      	beq.n	1481e <xQueueSemaphoreTake+0x66>
					{
						queueYIELD_IF_USING_PREEMPTION();
   1480e:	4b4c      	ldr	r3, [pc, #304]	; (14940 <xQueueSemaphoreTake+0x188>)
   14810:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   14814:	601a      	str	r2, [r3, #0]
   14816:	f3bf 8f4f 	dsb	sy
   1481a:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   1481e:	f000 fa3d 	bl	14c9c <vPortExitCritical>
				return pdPASS;
   14822:	2301      	movs	r3, #1
   14824:	e087      	b.n	14936 <xQueueSemaphoreTake+0x17e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   14826:	9b00      	ldr	r3, [sp, #0]
   14828:	2b00      	cmp	r3, #0
   1482a:	d103      	bne.n	14834 <xQueueSemaphoreTake+0x7c>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
   1482c:	f000 fa36 	bl	14c9c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   14830:	2300      	movs	r3, #0
   14832:	e080      	b.n	14936 <xQueueSemaphoreTake+0x17e>
				}
				else if( xEntryTimeSet == pdFALSE )
   14834:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14836:	2b00      	cmp	r3, #0
   14838:	d105      	bne.n	14846 <xQueueSemaphoreTake+0x8e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   1483a:	ab03      	add	r3, sp, #12
   1483c:	4618      	mov	r0, r3
   1483e:	f7ff fb29 	bl	13e94 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   14842:	2301      	movs	r3, #1
   14844:	9309      	str	r3, [sp, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   14846:	f000 fa29 	bl	14c9c <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
   1484a:	f7ff f913 	bl	13a74 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   1484e:	f000 fa11 	bl	14c74 <vPortEnterCritical>
   14852:	9b07      	ldr	r3, [sp, #28]
   14854:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   14858:	b25b      	sxtb	r3, r3
   1485a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1485e:	d103      	bne.n	14868 <xQueueSemaphoreTake+0xb0>
   14860:	9b07      	ldr	r3, [sp, #28]
   14862:	2200      	movs	r2, #0
   14864:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   14868:	9b07      	ldr	r3, [sp, #28]
   1486a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   1486e:	b25b      	sxtb	r3, r3
   14870:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   14874:	d103      	bne.n	1487e <xQueueSemaphoreTake+0xc6>
   14876:	9b07      	ldr	r3, [sp, #28]
   14878:	2200      	movs	r2, #0
   1487a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   1487e:	f000 fa0d 	bl	14c9c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   14882:	466a      	mov	r2, sp
   14884:	ab03      	add	r3, sp, #12
   14886:	4611      	mov	r1, r2
   14888:	4618      	mov	r0, r3
   1488a:	f7ff fb15 	bl	13eb8 <xTaskCheckForTimeOut>
   1488e:	4603      	mov	r3, r0
   14890:	2b00      	cmp	r3, #0
   14892:	d132      	bne.n	148fa <xQueueSemaphoreTake+0x142>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   14894:	9807      	ldr	r0, [sp, #28]
   14896:	f000 f928 	bl	14aea <prvIsQueueEmpty>
   1489a:	4603      	mov	r3, r0
   1489c:	2b00      	cmp	r3, #0
   1489e:	d026      	beq.n	148ee <xQueueSemaphoreTake+0x136>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   148a0:	9b07      	ldr	r3, [sp, #28]
   148a2:	681b      	ldr	r3, [r3, #0]
   148a4:	2b00      	cmp	r3, #0
   148a6:	d109      	bne.n	148bc <xQueueSemaphoreTake+0x104>
					{
						taskENTER_CRITICAL();
   148a8:	f000 f9e4 	bl	14c74 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   148ac:	9b07      	ldr	r3, [sp, #28]
   148ae:	685b      	ldr	r3, [r3, #4]
   148b0:	4618      	mov	r0, r3
   148b2:	f7ff fbfd 	bl	140b0 <xTaskPriorityInherit>
   148b6:	9008      	str	r0, [sp, #32]
						}
						taskEXIT_CRITICAL();
   148b8:	f000 f9f0 	bl	14c9c <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   148bc:	9b07      	ldr	r3, [sp, #28]
   148be:	3324      	adds	r3, #36	; 0x24
   148c0:	9a00      	ldr	r2, [sp, #0]
   148c2:	4611      	mov	r1, r2
   148c4:	4618      	mov	r0, r3
   148c6:	f7ff fa7b 	bl	13dc0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   148ca:	9807      	ldr	r0, [sp, #28]
   148cc:	f000 f8b6 	bl	14a3c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   148d0:	f7ff f8da 	bl	13a88 <xTaskResumeAll>
   148d4:	4603      	mov	r3, r0
   148d6:	2b00      	cmp	r3, #0
   148d8:	f47f af78 	bne.w	147cc <xQueueSemaphoreTake+0x14>
				{
					portYIELD_WITHIN_API();
   148dc:	4b18      	ldr	r3, [pc, #96]	; (14940 <xQueueSemaphoreTake+0x188>)
   148de:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   148e2:	601a      	str	r2, [r3, #0]
   148e4:	f3bf 8f4f 	dsb	sy
   148e8:	f3bf 8f6f 	isb	sy
   148ec:	e76e      	b.n	147cc <xQueueSemaphoreTake+0x14>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
   148ee:	9807      	ldr	r0, [sp, #28]
   148f0:	f000 f8a4 	bl	14a3c <prvUnlockQueue>
				( void ) xTaskResumeAll();
   148f4:	f7ff f8c8 	bl	13a88 <xTaskResumeAll>
   148f8:	e768      	b.n	147cc <xQueueSemaphoreTake+0x14>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
   148fa:	9807      	ldr	r0, [sp, #28]
   148fc:	f000 f89e 	bl	14a3c <prvUnlockQueue>
			( void ) xTaskResumeAll();
   14900:	f7ff f8c2 	bl	13a88 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   14904:	9807      	ldr	r0, [sp, #28]
   14906:	f000 f8f0 	bl	14aea <prvIsQueueEmpty>
   1490a:	4603      	mov	r3, r0
   1490c:	2b00      	cmp	r3, #0
   1490e:	f43f af5d 	beq.w	147cc <xQueueSemaphoreTake+0x14>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
   14912:	9b08      	ldr	r3, [sp, #32]
   14914:	2b00      	cmp	r3, #0
   14916:	d00d      	beq.n	14934 <xQueueSemaphoreTake+0x17c>
					{
						taskENTER_CRITICAL();
   14918:	f000 f9ac 	bl	14c74 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
   1491c:	9807      	ldr	r0, [sp, #28]
   1491e:	f000 f811 	bl	14944 <prvGetDisinheritPriorityAfterTimeout>
   14922:	9005      	str	r0, [sp, #20]
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
   14924:	9b07      	ldr	r3, [sp, #28]
   14926:	685b      	ldr	r3, [r3, #4]
   14928:	9905      	ldr	r1, [sp, #20]
   1492a:	4618      	mov	r0, r3
   1492c:	f7ff fca8 	bl	14280 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
   14930:	f000 f9b4 	bl	14c9c <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   14934:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
   14936:	4618      	mov	r0, r3
   14938:	b00b      	add	sp, #44	; 0x2c
   1493a:	f85d fb04 	ldr.w	pc, [sp], #4
   1493e:	bf00      	nop
   14940:	e000ed04 	.word	0xe000ed04

00014944 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
   14944:	b084      	sub	sp, #16
   14946:	9001      	str	r0, [sp, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
   14948:	9b01      	ldr	r3, [sp, #4]
   1494a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1494c:	2b00      	cmp	r3, #0
   1494e:	d006      	beq.n	1495e <prvGetDisinheritPriorityAfterTimeout+0x1a>
		{
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   14950:	9b01      	ldr	r3, [sp, #4]
   14952:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   14954:	681b      	ldr	r3, [r3, #0]
   14956:	f1c3 0305 	rsb	r3, r3, #5
   1495a:	9303      	str	r3, [sp, #12]
   1495c:	e001      	b.n	14962 <prvGetDisinheritPriorityAfterTimeout+0x1e>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   1495e:	2300      	movs	r3, #0
   14960:	9303      	str	r3, [sp, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
   14962:	9b03      	ldr	r3, [sp, #12]
	}
   14964:	4618      	mov	r0, r3
   14966:	b004      	add	sp, #16
   14968:	4770      	bx	lr

0001496a <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   1496a:	b500      	push	{lr}
   1496c:	b087      	sub	sp, #28
   1496e:	9003      	str	r0, [sp, #12]
   14970:	9102      	str	r1, [sp, #8]
   14972:	9201      	str	r2, [sp, #4]
BaseType_t xReturn = pdFALSE;
   14974:	2300      	movs	r3, #0
   14976:	9305      	str	r3, [sp, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   14978:	9b03      	ldr	r3, [sp, #12]
   1497a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1497c:	9304      	str	r3, [sp, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   1497e:	9b03      	ldr	r3, [sp, #12]
   14980:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   14982:	2b00      	cmp	r3, #0
   14984:	d10d      	bne.n	149a2 <prvCopyDataToQueue+0x38>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   14986:	9b03      	ldr	r3, [sp, #12]
   14988:	681b      	ldr	r3, [r3, #0]
   1498a:	2b00      	cmp	r3, #0
   1498c:	d14d      	bne.n	14a2a <prvCopyDataToQueue+0xc0>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   1498e:	9b03      	ldr	r3, [sp, #12]
   14990:	685b      	ldr	r3, [r3, #4]
   14992:	4618      	mov	r0, r3
   14994:	f7ff fc10 	bl	141b8 <xTaskPriorityDisinherit>
   14998:	9005      	str	r0, [sp, #20]
				pxQueue->pxMutexHolder = NULL;
   1499a:	9b03      	ldr	r3, [sp, #12]
   1499c:	2200      	movs	r2, #0
   1499e:	605a      	str	r2, [r3, #4]
   149a0:	e043      	b.n	14a2a <prvCopyDataToQueue+0xc0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   149a2:	9b01      	ldr	r3, [sp, #4]
   149a4:	2b00      	cmp	r3, #0
   149a6:	d119      	bne.n	149dc <prvCopyDataToQueue+0x72>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   149a8:	9b03      	ldr	r3, [sp, #12]
   149aa:	6898      	ldr	r0, [r3, #8]
   149ac:	9b03      	ldr	r3, [sp, #12]
   149ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   149b0:	461a      	mov	r2, r3
   149b2:	9902      	ldr	r1, [sp, #8]
   149b4:	f004 f9f6 	bl	18da4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   149b8:	9b03      	ldr	r3, [sp, #12]
   149ba:	689a      	ldr	r2, [r3, #8]
   149bc:	9b03      	ldr	r3, [sp, #12]
   149be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   149c0:	441a      	add	r2, r3
   149c2:	9b03      	ldr	r3, [sp, #12]
   149c4:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   149c6:	9b03      	ldr	r3, [sp, #12]
   149c8:	689a      	ldr	r2, [r3, #8]
   149ca:	9b03      	ldr	r3, [sp, #12]
   149cc:	685b      	ldr	r3, [r3, #4]
   149ce:	429a      	cmp	r2, r3
   149d0:	d32b      	bcc.n	14a2a <prvCopyDataToQueue+0xc0>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   149d2:	9b03      	ldr	r3, [sp, #12]
   149d4:	681a      	ldr	r2, [r3, #0]
   149d6:	9b03      	ldr	r3, [sp, #12]
   149d8:	609a      	str	r2, [r3, #8]
   149da:	e026      	b.n	14a2a <prvCopyDataToQueue+0xc0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   149dc:	9b03      	ldr	r3, [sp, #12]
   149de:	68d8      	ldr	r0, [r3, #12]
   149e0:	9b03      	ldr	r3, [sp, #12]
   149e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   149e4:	461a      	mov	r2, r3
   149e6:	9902      	ldr	r1, [sp, #8]
   149e8:	f004 f9dc 	bl	18da4 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   149ec:	9b03      	ldr	r3, [sp, #12]
   149ee:	68da      	ldr	r2, [r3, #12]
   149f0:	9b03      	ldr	r3, [sp, #12]
   149f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   149f4:	425b      	negs	r3, r3
   149f6:	441a      	add	r2, r3
   149f8:	9b03      	ldr	r3, [sp, #12]
   149fa:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   149fc:	9b03      	ldr	r3, [sp, #12]
   149fe:	68da      	ldr	r2, [r3, #12]
   14a00:	9b03      	ldr	r3, [sp, #12]
   14a02:	681b      	ldr	r3, [r3, #0]
   14a04:	429a      	cmp	r2, r3
   14a06:	d207      	bcs.n	14a18 <prvCopyDataToQueue+0xae>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   14a08:	9b03      	ldr	r3, [sp, #12]
   14a0a:	685a      	ldr	r2, [r3, #4]
   14a0c:	9b03      	ldr	r3, [sp, #12]
   14a0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   14a10:	425b      	negs	r3, r3
   14a12:	441a      	add	r2, r3
   14a14:	9b03      	ldr	r3, [sp, #12]
   14a16:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   14a18:	9b01      	ldr	r3, [sp, #4]
   14a1a:	2b02      	cmp	r3, #2
   14a1c:	d105      	bne.n	14a2a <prvCopyDataToQueue+0xc0>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   14a1e:	9b04      	ldr	r3, [sp, #16]
   14a20:	2b00      	cmp	r3, #0
   14a22:	d002      	beq.n	14a2a <prvCopyDataToQueue+0xc0>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   14a24:	9b04      	ldr	r3, [sp, #16]
   14a26:	3b01      	subs	r3, #1
   14a28:	9304      	str	r3, [sp, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   14a2a:	9b04      	ldr	r3, [sp, #16]
   14a2c:	1c5a      	adds	r2, r3, #1
   14a2e:	9b03      	ldr	r3, [sp, #12]
   14a30:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   14a32:	9b05      	ldr	r3, [sp, #20]
}
   14a34:	4618      	mov	r0, r3
   14a36:	b007      	add	sp, #28
   14a38:	f85d fb04 	ldr.w	pc, [sp], #4

00014a3c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   14a3c:	b500      	push	{lr}
   14a3e:	b085      	sub	sp, #20
   14a40:	9001      	str	r0, [sp, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   14a42:	f000 f917 	bl	14c74 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   14a46:	9b01      	ldr	r3, [sp, #4]
   14a48:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   14a4c:	f88d 300f 	strb.w	r3, [sp, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   14a50:	e013      	b.n	14a7a <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   14a52:	9b01      	ldr	r3, [sp, #4]
   14a54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   14a56:	2b00      	cmp	r3, #0
   14a58:	d014      	beq.n	14a84 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   14a5a:	9b01      	ldr	r3, [sp, #4]
   14a5c:	3324      	adds	r3, #36	; 0x24
   14a5e:	4618      	mov	r0, r3
   14a60:	f7ff f9c4 	bl	13dec <xTaskRemoveFromEventList>
   14a64:	4603      	mov	r3, r0
   14a66:	2b00      	cmp	r3, #0
   14a68:	d001      	beq.n	14a6e <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   14a6a:	f7ff fa6b 	bl	13f44 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   14a6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14a72:	3b01      	subs	r3, #1
   14a74:	b2db      	uxtb	r3, r3
   14a76:	f88d 300f 	strb.w	r3, [sp, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
   14a7a:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   14a7e:	2b00      	cmp	r3, #0
   14a80:	dce7      	bgt.n	14a52 <prvUnlockQueue+0x16>
   14a82:	e000      	b.n	14a86 <prvUnlockQueue+0x4a>
					break;
   14a84:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
   14a86:	9b01      	ldr	r3, [sp, #4]
   14a88:	22ff      	movs	r2, #255	; 0xff
   14a8a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
   14a8e:	f000 f905 	bl	14c9c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   14a92:	f000 f8ef 	bl	14c74 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   14a96:	9b01      	ldr	r3, [sp, #4]
   14a98:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   14a9c:	f88d 300e 	strb.w	r3, [sp, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   14aa0:	e013      	b.n	14aca <prvUnlockQueue+0x8e>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   14aa2:	9b01      	ldr	r3, [sp, #4]
   14aa4:	691b      	ldr	r3, [r3, #16]
   14aa6:	2b00      	cmp	r3, #0
   14aa8:	d014      	beq.n	14ad4 <prvUnlockQueue+0x98>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   14aaa:	9b01      	ldr	r3, [sp, #4]
   14aac:	3310      	adds	r3, #16
   14aae:	4618      	mov	r0, r3
   14ab0:	f7ff f99c 	bl	13dec <xTaskRemoveFromEventList>
   14ab4:	4603      	mov	r3, r0
   14ab6:	2b00      	cmp	r3, #0
   14ab8:	d001      	beq.n	14abe <prvUnlockQueue+0x82>
				{
					vTaskMissedYield();
   14aba:	f7ff fa43 	bl	13f44 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   14abe:	f89d 300e 	ldrb.w	r3, [sp, #14]
   14ac2:	3b01      	subs	r3, #1
   14ac4:	b2db      	uxtb	r3, r3
   14ac6:	f88d 300e 	strb.w	r3, [sp, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
   14aca:	f99d 300e 	ldrsb.w	r3, [sp, #14]
   14ace:	2b00      	cmp	r3, #0
   14ad0:	dce7      	bgt.n	14aa2 <prvUnlockQueue+0x66>
   14ad2:	e000      	b.n	14ad6 <prvUnlockQueue+0x9a>
			}
			else
			{
				break;
   14ad4:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   14ad6:	9b01      	ldr	r3, [sp, #4]
   14ad8:	22ff      	movs	r2, #255	; 0xff
   14ada:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   14ade:	f000 f8dd 	bl	14c9c <vPortExitCritical>
}
   14ae2:	bf00      	nop
   14ae4:	b005      	add	sp, #20
   14ae6:	f85d fb04 	ldr.w	pc, [sp], #4

00014aea <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   14aea:	b500      	push	{lr}
   14aec:	b085      	sub	sp, #20
   14aee:	9001      	str	r0, [sp, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   14af0:	f000 f8c0 	bl	14c74 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   14af4:	9b01      	ldr	r3, [sp, #4]
   14af6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   14af8:	2b00      	cmp	r3, #0
   14afa:	d102      	bne.n	14b02 <prvIsQueueEmpty+0x18>
		{
			xReturn = pdTRUE;
   14afc:	2301      	movs	r3, #1
   14afe:	9303      	str	r3, [sp, #12]
   14b00:	e001      	b.n	14b06 <prvIsQueueEmpty+0x1c>
		}
		else
		{
			xReturn = pdFALSE;
   14b02:	2300      	movs	r3, #0
   14b04:	9303      	str	r3, [sp, #12]
		}
	}
	taskEXIT_CRITICAL();
   14b06:	f000 f8c9 	bl	14c9c <vPortExitCritical>

	return xReturn;
   14b0a:	9b03      	ldr	r3, [sp, #12]
}
   14b0c:	4618      	mov	r0, r3
   14b0e:	b005      	add	sp, #20
   14b10:	f85d fb04 	ldr.w	pc, [sp], #4

00014b14 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   14b14:	b500      	push	{lr}
   14b16:	b085      	sub	sp, #20
   14b18:	9001      	str	r0, [sp, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   14b1a:	f000 f8ab 	bl	14c74 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   14b1e:	9b01      	ldr	r3, [sp, #4]
   14b20:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   14b22:	9b01      	ldr	r3, [sp, #4]
   14b24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   14b26:	429a      	cmp	r2, r3
   14b28:	d102      	bne.n	14b30 <prvIsQueueFull+0x1c>
		{
			xReturn = pdTRUE;
   14b2a:	2301      	movs	r3, #1
   14b2c:	9303      	str	r3, [sp, #12]
   14b2e:	e001      	b.n	14b34 <prvIsQueueFull+0x20>
		}
		else
		{
			xReturn = pdFALSE;
   14b30:	2300      	movs	r3, #0
   14b32:	9303      	str	r3, [sp, #12]
		}
	}
	taskEXIT_CRITICAL();
   14b34:	f000 f8b2 	bl	14c9c <vPortExitCritical>

	return xReturn;
   14b38:	9b03      	ldr	r3, [sp, #12]
}
   14b3a:	4618      	mov	r0, r3
   14b3c:	b005      	add	sp, #20
   14b3e:	f85d fb04 	ldr.w	pc, [sp], #4
   14b42:	Address 0x0000000000014b42 is out of bounds.


00014b44 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   14b44:	b084      	sub	sp, #16
   14b46:	9003      	str	r0, [sp, #12]
   14b48:	9102      	str	r1, [sp, #8]
   14b4a:	9201      	str	r2, [sp, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
   14b4c:	9b03      	ldr	r3, [sp, #12]
   14b4e:	3b04      	subs	r3, #4
   14b50:	9303      	str	r3, [sp, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   14b52:	9b03      	ldr	r3, [sp, #12]
   14b54:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   14b58:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   14b5a:	9b03      	ldr	r3, [sp, #12]
   14b5c:	3b04      	subs	r3, #4
   14b5e:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   14b60:	9b02      	ldr	r3, [sp, #8]
   14b62:	f023 0201 	bic.w	r2, r3, #1
   14b66:	9b03      	ldr	r3, [sp, #12]
   14b68:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   14b6a:	9b03      	ldr	r3, [sp, #12]
   14b6c:	3b04      	subs	r3, #4
   14b6e:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   14b70:	4a0b      	ldr	r2, [pc, #44]	; (14ba0 <pxPortInitialiseStack+0x5c>)
   14b72:	9b03      	ldr	r3, [sp, #12]
   14b74:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   14b76:	9b03      	ldr	r3, [sp, #12]
   14b78:	3b14      	subs	r3, #20
   14b7a:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   14b7c:	9a01      	ldr	r2, [sp, #4]
   14b7e:	9b03      	ldr	r3, [sp, #12]
   14b80:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
   14b82:	9b03      	ldr	r3, [sp, #12]
   14b84:	3b04      	subs	r3, #4
   14b86:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   14b88:	9b03      	ldr	r3, [sp, #12]
   14b8a:	f06f 0202 	mvn.w	r2, #2
   14b8e:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   14b90:	9b03      	ldr	r3, [sp, #12]
   14b92:	3b20      	subs	r3, #32
   14b94:	9303      	str	r3, [sp, #12]

	return pxTopOfStack;
   14b96:	9b03      	ldr	r3, [sp, #12]
}
   14b98:	4618      	mov	r0, r3
   14b9a:	b004      	add	sp, #16
   14b9c:	4770      	bx	lr
   14b9e:	bf00      	nop
   14ba0:	00014ba5 	.word	0x00014ba5

00014ba4 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   14ba4:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   14ba6:	2300      	movs	r3, #0
   14ba8:	9300      	str	r3, [sp, #0]
	__asm volatile
   14baa:	f04f 0328 	mov.w	r3, #40	; 0x28
   14bae:	f383 8811 	msr	BASEPRI, r3
   14bb2:	f3bf 8f6f 	isb	sy
   14bb6:	f3bf 8f4f 	dsb	sy
   14bba:	9301      	str	r3, [sp, #4]

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   14bbc:	bf00      	nop
   14bbe:	9b00      	ldr	r3, [sp, #0]
   14bc0:	2b00      	cmp	r3, #0
   14bc2:	d0fc      	beq.n	14bbe <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   14bc4:	bf00      	nop
   14bc6:	b002      	add	sp, #8
   14bc8:	4770      	bx	lr
   14bca:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   14bce:	Address 0x0000000000014bce is out of bounds.


00014bd0 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   14bd0:	4b07      	ldr	r3, [pc, #28]	; (14bf0 <pxCurrentTCBConst2>)
   14bd2:	6819      	ldr	r1, [r3, #0]
   14bd4:	6808      	ldr	r0, [r1, #0]
   14bd6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14bda:	f380 8809 	msr	PSP, r0
   14bde:	f3bf 8f6f 	isb	sy
   14be2:	f04f 0000 	mov.w	r0, #0
   14be6:	f380 8811 	msr	BASEPRI, r0
   14bea:	4770      	bx	lr
   14bec:	f3af 8000 	nop.w

00014bf0 <pxCurrentTCBConst2>:
   14bf0:	100006d4 	.word	0x100006d4
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   14bf4:	bf00      	nop
   14bf6:	bf00      	nop

00014bf8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
   14bf8:	4808      	ldr	r0, [pc, #32]	; (14c1c <prvPortStartFirstTask+0x24>)
   14bfa:	6800      	ldr	r0, [r0, #0]
   14bfc:	6800      	ldr	r0, [r0, #0]
   14bfe:	f380 8808 	msr	MSP, r0
   14c02:	f04f 0000 	mov.w	r0, #0
   14c06:	f380 8814 	msr	CONTROL, r0
   14c0a:	b662      	cpsie	i
   14c0c:	b661      	cpsie	f
   14c0e:	f3bf 8f4f 	dsb	sy
   14c12:	f3bf 8f6f 	isb	sy
   14c16:	df00      	svc	0
   14c18:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
   14c1a:	bf00      	nop
   14c1c:	e000ed08 	.word	0xe000ed08

00014c20 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   14c20:	b508      	push	{r3, lr}
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   14c22:	4b11      	ldr	r3, [pc, #68]	; (14c68 <xPortStartScheduler+0x48>)
   14c24:	681b      	ldr	r3, [r3, #0]
   14c26:	4a10      	ldr	r2, [pc, #64]	; (14c68 <xPortStartScheduler+0x48>)
   14c28:	f443 0378 	orr.w	r3, r3, #16252928	; 0xf80000
   14c2c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   14c2e:	4b0e      	ldr	r3, [pc, #56]	; (14c68 <xPortStartScheduler+0x48>)
   14c30:	681b      	ldr	r3, [r3, #0]
   14c32:	4a0d      	ldr	r2, [pc, #52]	; (14c68 <xPortStartScheduler+0x48>)
   14c34:	f043 4378 	orr.w	r3, r3, #4160749568	; 0xf8000000
   14c38:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   14c3a:	f7fd ff4f 	bl	12adc <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   14c3e:	4b0b      	ldr	r3, [pc, #44]	; (14c6c <xPortStartScheduler+0x4c>)
   14c40:	2200      	movs	r2, #0
   14c42:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
   14c44:	f000 f898 	bl	14d78 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   14c48:	4b09      	ldr	r3, [pc, #36]	; (14c70 <xPortStartScheduler+0x50>)
   14c4a:	681b      	ldr	r3, [r3, #0]
   14c4c:	4a08      	ldr	r2, [pc, #32]	; (14c70 <xPortStartScheduler+0x50>)
   14c4e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   14c52:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   14c54:	f7ff ffd0 	bl	14bf8 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   14c58:	f7ff f84e 	bl	13cf8 <vTaskSwitchContext>
	prvTaskExitError();
   14c5c:	f7ff ffa2 	bl	14ba4 <prvTaskExitError>

	/* Should not get here! */
	return 0;
   14c60:	2300      	movs	r3, #0
}
   14c62:	4618      	mov	r0, r3
   14c64:	bd08      	pop	{r3, pc}
   14c66:	bf00      	nop
   14c68:	e000ed20 	.word	0xe000ed20
   14c6c:	100001f0 	.word	0x100001f0
   14c70:	e000ef34 	.word	0xe000ef34

00014c74 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   14c74:	b082      	sub	sp, #8
   14c76:	f04f 0328 	mov.w	r3, #40	; 0x28
   14c7a:	f383 8811 	msr	BASEPRI, r3
   14c7e:	f3bf 8f6f 	isb	sy
   14c82:	f3bf 8f4f 	dsb	sy
   14c86:	9301      	str	r3, [sp, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   14c88:	4b03      	ldr	r3, [pc, #12]	; (14c98 <vPortEnterCritical+0x24>)
   14c8a:	681b      	ldr	r3, [r3, #0]
   14c8c:	3301      	adds	r3, #1
   14c8e:	4a02      	ldr	r2, [pc, #8]	; (14c98 <vPortEnterCritical+0x24>)
   14c90:	6013      	str	r3, [r2, #0]
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
   14c92:	bf00      	nop
   14c94:	b002      	add	sp, #8
   14c96:	4770      	bx	lr
   14c98:	100001f0 	.word	0x100001f0

00014c9c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   14c9c:	b082      	sub	sp, #8
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
   14c9e:	4b08      	ldr	r3, [pc, #32]	; (14cc0 <vPortExitCritical+0x24>)
   14ca0:	681b      	ldr	r3, [r3, #0]
   14ca2:	3b01      	subs	r3, #1
   14ca4:	4a06      	ldr	r2, [pc, #24]	; (14cc0 <vPortExitCritical+0x24>)
   14ca6:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   14ca8:	4b05      	ldr	r3, [pc, #20]	; (14cc0 <vPortExitCritical+0x24>)
   14caa:	681b      	ldr	r3, [r3, #0]
   14cac:	2b00      	cmp	r3, #0
   14cae:	d104      	bne.n	14cba <vPortExitCritical+0x1e>
   14cb0:	2300      	movs	r3, #0
   14cb2:	9301      	str	r3, [sp, #4]
	__asm volatile
   14cb4:	9b01      	ldr	r3, [sp, #4]
   14cb6:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   14cba:	bf00      	nop
   14cbc:	b002      	add	sp, #8
   14cbe:	4770      	bx	lr
   14cc0:	100001f0 	.word	0x100001f0
   14cc4:	ffffffff 	.word	0xffffffff
   14cc8:	ffffffff 	.word	0xffffffff
   14ccc:	ffffffff 	.word	0xffffffff

00014cd0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   14cd0:	f3ef 8009 	mrs	r0, PSP
   14cd4:	f3bf 8f6f 	isb	sy
   14cd8:	4b15      	ldr	r3, [pc, #84]	; (14d30 <pxCurrentTCBConst>)
   14cda:	681a      	ldr	r2, [r3, #0]
   14cdc:	f01e 0f10 	tst.w	lr, #16
   14ce0:	bf08      	it	eq
   14ce2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   14ce6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14cea:	6010      	str	r0, [r2, #0]
   14cec:	e92d 0009 	stmdb	sp!, {r0, r3}
   14cf0:	f04f 0028 	mov.w	r0, #40	; 0x28
   14cf4:	f380 8811 	msr	BASEPRI, r0
   14cf8:	f3bf 8f4f 	dsb	sy
   14cfc:	f3bf 8f6f 	isb	sy
   14d00:	f7fe fffa 	bl	13cf8 <vTaskSwitchContext>
   14d04:	f04f 0000 	mov.w	r0, #0
   14d08:	f380 8811 	msr	BASEPRI, r0
   14d0c:	bc09      	pop	{r0, r3}
   14d0e:	6819      	ldr	r1, [r3, #0]
   14d10:	6808      	ldr	r0, [r1, #0]
   14d12:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14d16:	f01e 0f10 	tst.w	lr, #16
   14d1a:	bf08      	it	eq
   14d1c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   14d20:	f380 8809 	msr	PSP, r0
   14d24:	f3bf 8f6f 	isb	sy
   14d28:	4770      	bx	lr
   14d2a:	bf00      	nop
   14d2c:	f3af 8000 	nop.w

00014d30 <pxCurrentTCBConst>:
   14d30:	100006d4 	.word	0x100006d4
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   14d34:	bf00      	nop
   14d36:	bf00      	nop

00014d38 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   14d38:	b500      	push	{lr}
   14d3a:	b083      	sub	sp, #12
	__asm volatile
   14d3c:	f04f 0328 	mov.w	r3, #40	; 0x28
   14d40:	f383 8811 	msr	BASEPRI, r3
   14d44:	f3bf 8f6f 	isb	sy
   14d48:	f3bf 8f4f 	dsb	sy
   14d4c:	9301      	str	r3, [sp, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   14d4e:	f7fe ff27 	bl	13ba0 <xTaskIncrementTick>
   14d52:	4603      	mov	r3, r0
   14d54:	2b00      	cmp	r3, #0
   14d56:	d003      	beq.n	14d60 <xPortSysTickHandler+0x28>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   14d58:	4b06      	ldr	r3, [pc, #24]	; (14d74 <xPortSysTickHandler+0x3c>)
   14d5a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   14d5e:	601a      	str	r2, [r3, #0]
   14d60:	2300      	movs	r3, #0
   14d62:	9300      	str	r3, [sp, #0]
	__asm volatile
   14d64:	9b00      	ldr	r3, [sp, #0]
   14d66:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   14d6a:	bf00      	nop
   14d6c:	b003      	add	sp, #12
   14d6e:	f85d fb04 	ldr.w	pc, [sp], #4
   14d72:	bf00      	nop
   14d74:	e000ed04 	.word	0xe000ed04

00014d78 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   14d78:	f8df 000c 	ldr.w	r0, [pc, #12]	; 14d88 <vPortEnableVFP+0x10>
   14d7c:	6801      	ldr	r1, [r0, #0]
   14d7e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14d82:	6001      	str	r1, [r0, #0]
   14d84:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   14d86:	bf00      	nop
   14d88:	e000ed88 	.word	0xe000ed88

00014d8c <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   14d8c:	b500      	push	{lr}
   14d8e:	b085      	sub	sp, #20
   14d90:	9001      	str	r0, [sp, #4]
void *pvReturn;

	vTaskSuspendAll();
   14d92:	f7fe fe6f 	bl	13a74 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
   14d96:	9801      	ldr	r0, [sp, #4]
   14d98:	f003 fff4 	bl	18d84 <malloc>
   14d9c:	4603      	mov	r3, r0
   14d9e:	9303      	str	r3, [sp, #12]
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   14da0:	f7fe fe72 	bl	13a88 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
   14da4:	9b03      	ldr	r3, [sp, #12]
}
   14da6:	4618      	mov	r0, r3
   14da8:	b005      	add	sp, #20
   14daa:	f85d fb04 	ldr.w	pc, [sp], #4

00014dae <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   14dae:	b500      	push	{lr}
   14db0:	b083      	sub	sp, #12
   14db2:	9001      	str	r0, [sp, #4]
	if( pv )
   14db4:	9b01      	ldr	r3, [sp, #4]
   14db6:	2b00      	cmp	r3, #0
   14db8:	d006      	beq.n	14dc8 <vPortFree+0x1a>
	{
		vTaskSuspendAll();
   14dba:	f7fe fe5b 	bl	13a74 <vTaskSuspendAll>
		{
			free( pv );
   14dbe:	9801      	ldr	r0, [sp, #4]
   14dc0:	f003 ffe8 	bl	18d94 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
   14dc4:	f7fe fe60 	bl	13a88 <xTaskResumeAll>
	}
}
   14dc8:	bf00      	nop
   14dca:	b003      	add	sp, #12
   14dcc:	f85d fb04 	ldr.w	pc, [sp], #4

00014dd0 <_out_null(char, void*, unsigned int, unsigned int)>:
}


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
   14dd0:	b510      	push	{r4, lr}
   14dd2:	b084      	sub	sp, #16
   14dd4:	4674      	mov	r4, lr
   14dd6:	9102      	str	r1, [sp, #8]
   14dd8:	9201      	str	r2, [sp, #4]
   14dda:	9300      	str	r3, [sp, #0]
   14ddc:	4603      	mov	r3, r0
   14dde:	f88d 300f 	strb.w	r3, [sp, #15]
   14de2:	4623      	mov	r3, r4
   14de4:	4619      	mov	r1, r3
   14de6:	4805      	ldr	r0, [pc, #20]	; (14dfc <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   14de8:	f7fe fbb2 	bl	13550 <__cyg_profile_func_enter>
   14dec:	4623      	mov	r3, r4
   14dee:	4619      	mov	r1, r3
   14df0:	4802      	ldr	r0, [pc, #8]	; (14dfc <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   14df2:	f7fe fbc1 	bl	13578 <__cyg_profile_func_exit>
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
   14df6:	bf00      	nop
   14df8:	b004      	add	sp, #16
   14dfa:	bd10      	pop	{r4, pc}
   14dfc:	00014dd1 	.word	0x00014dd1

00014e00 <_out_char(char, void*, unsigned int, unsigned int)>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
   14e00:	b510      	push	{r4, lr}
   14e02:	b084      	sub	sp, #16
   14e04:	4674      	mov	r4, lr
   14e06:	9102      	str	r1, [sp, #8]
   14e08:	9201      	str	r2, [sp, #4]
   14e0a:	9300      	str	r3, [sp, #0]
   14e0c:	4603      	mov	r3, r0
   14e0e:	f88d 300f 	strb.w	r3, [sp, #15]
   14e12:	4623      	mov	r3, r4
   14e14:	4619      	mov	r1, r3
   14e16:	480a      	ldr	r0, [pc, #40]	; (14e40 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   14e18:	f7fe fb9a 	bl	13550 <__cyg_profile_func_enter>
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
   14e1c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14e20:	2b00      	cmp	r3, #0
   14e22:	d004      	beq.n	14e2e <_out_char(char, void*, unsigned int, unsigned int)+0x2e>
    _putchar(character);
   14e24:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14e28:	4618      	mov	r0, r3
   14e2a:	f7fe fb27 	bl	1347c <_putchar>
   14e2e:	4623      	mov	r3, r4
   14e30:	4619      	mov	r1, r3
   14e32:	4803      	ldr	r0, [pc, #12]	; (14e40 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   14e34:	f7fe fba0 	bl	13578 <__cyg_profile_func_exit>
  }
}
   14e38:	bf00      	nop
   14e3a:	b004      	add	sp, #16
   14e3c:	bd10      	pop	{r4, pc}
   14e3e:	bf00      	nop
   14e40:	00014e01 	.word	0x00014e01

00014e44 <_strlen(char const*)>:


// internal strlen
// \return The length of the string (excluding the terminating 0)
static inline unsigned int _strlen(const char* str)
{
   14e44:	b530      	push	{r4, r5, lr}
   14e46:	b085      	sub	sp, #20
   14e48:	4674      	mov	r4, lr
   14e4a:	9001      	str	r0, [sp, #4]
   14e4c:	4623      	mov	r3, r4
   14e4e:	4619      	mov	r1, r3
   14e50:	480c      	ldr	r0, [pc, #48]	; (14e84 <_strlen(char const*)+0x40>)
   14e52:	f7fe fb7d 	bl	13550 <__cyg_profile_func_enter>
  const char* s;
  for (s = str; *s; ++s);
   14e56:	9b01      	ldr	r3, [sp, #4]
   14e58:	9303      	str	r3, [sp, #12]
   14e5a:	9b03      	ldr	r3, [sp, #12]
   14e5c:	781b      	ldrb	r3, [r3, #0]
   14e5e:	2b00      	cmp	r3, #0
   14e60:	d003      	beq.n	14e6a <_strlen(char const*)+0x26>
   14e62:	9b03      	ldr	r3, [sp, #12]
   14e64:	3301      	adds	r3, #1
   14e66:	9303      	str	r3, [sp, #12]
   14e68:	e7f7      	b.n	14e5a <_strlen(char const*)+0x16>
  return (unsigned int)(s - str);
   14e6a:	9a03      	ldr	r2, [sp, #12]
   14e6c:	9b01      	ldr	r3, [sp, #4]
   14e6e:	1ad3      	subs	r3, r2, r3
   14e70:	461d      	mov	r5, r3
   14e72:	4623      	mov	r3, r4
   14e74:	4619      	mov	r1, r3
   14e76:	4803      	ldr	r0, [pc, #12]	; (14e84 <_strlen(char const*)+0x40>)
   14e78:	f7fe fb7e 	bl	13578 <__cyg_profile_func_exit>
   14e7c:	462b      	mov	r3, r5
}
   14e7e:	4618      	mov	r0, r3
   14e80:	b005      	add	sp, #20
   14e82:	bd30      	pop	{r4, r5, pc}
   14e84:	00014e45 	.word	0x00014e45

00014e88 <_is_digit(char)>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
   14e88:	b530      	push	{r4, r5, lr}
   14e8a:	b083      	sub	sp, #12
   14e8c:	4675      	mov	r5, lr
   14e8e:	4603      	mov	r3, r0
   14e90:	f88d 3007 	strb.w	r3, [sp, #7]
   14e94:	462b      	mov	r3, r5
   14e96:	4619      	mov	r1, r3
   14e98:	480b      	ldr	r0, [pc, #44]	; (14ec8 <_is_digit(char)+0x40>)
   14e9a:	f7fe fb59 	bl	13550 <__cyg_profile_func_enter>
  return (ch >= '0') && (ch <= '9');
   14e9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14ea2:	2b2f      	cmp	r3, #47	; 0x2f
   14ea4:	d905      	bls.n	14eb2 <_is_digit(char)+0x2a>
   14ea6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14eaa:	2b39      	cmp	r3, #57	; 0x39
   14eac:	d801      	bhi.n	14eb2 <_is_digit(char)+0x2a>
   14eae:	2401      	movs	r4, #1
   14eb0:	e000      	b.n	14eb4 <_is_digit(char)+0x2c>
   14eb2:	2400      	movs	r4, #0
   14eb4:	462b      	mov	r3, r5
   14eb6:	4619      	mov	r1, r3
   14eb8:	4803      	ldr	r0, [pc, #12]	; (14ec8 <_is_digit(char)+0x40>)
   14eba:	f7fe fb5d 	bl	13578 <__cyg_profile_func_exit>
   14ebe:	4623      	mov	r3, r4
}
   14ec0:	4618      	mov	r0, r3
   14ec2:	b003      	add	sp, #12
   14ec4:	bd30      	pop	{r4, r5, pc}
   14ec6:	bf00      	nop
   14ec8:	00014e89 	.word	0x00014e89

00014ecc <_atoi(char const**)>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
   14ecc:	b530      	push	{r4, r5, lr}
   14ece:	b085      	sub	sp, #20
   14ed0:	4675      	mov	r5, lr
   14ed2:	9001      	str	r0, [sp, #4]
   14ed4:	462b      	mov	r3, r5
   14ed6:	4619      	mov	r1, r3
   14ed8:	4813      	ldr	r0, [pc, #76]	; (14f28 <_atoi(char const**)+0x5c>)
   14eda:	f7fe fb39 	bl	13550 <__cyg_profile_func_enter>
  unsigned int i = 0U;
   14ede:	2300      	movs	r3, #0
   14ee0:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   14ee2:	9b01      	ldr	r3, [sp, #4]
   14ee4:	681b      	ldr	r3, [r3, #0]
   14ee6:	781b      	ldrb	r3, [r3, #0]
   14ee8:	4618      	mov	r0, r3
   14eea:	f7ff ffcd 	bl	14e88 <_is_digit(char)>
   14eee:	4603      	mov	r3, r0
   14ef0:	2b00      	cmp	r3, #0
   14ef2:	d00f      	beq.n	14f14 <_atoi(char const**)+0x48>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
   14ef4:	9a03      	ldr	r2, [sp, #12]
   14ef6:	4613      	mov	r3, r2
   14ef8:	009b      	lsls	r3, r3, #2
   14efa:	4413      	add	r3, r2
   14efc:	005b      	lsls	r3, r3, #1
   14efe:	4618      	mov	r0, r3
   14f00:	9b01      	ldr	r3, [sp, #4]
   14f02:	681b      	ldr	r3, [r3, #0]
   14f04:	1c59      	adds	r1, r3, #1
   14f06:	9a01      	ldr	r2, [sp, #4]
   14f08:	6011      	str	r1, [r2, #0]
   14f0a:	781b      	ldrb	r3, [r3, #0]
   14f0c:	4403      	add	r3, r0
   14f0e:	3b30      	subs	r3, #48	; 0x30
   14f10:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   14f12:	e7e6      	b.n	14ee2 <_atoi(char const**)+0x16>
  }
  return i;
   14f14:	9c03      	ldr	r4, [sp, #12]
   14f16:	462b      	mov	r3, r5
   14f18:	4619      	mov	r1, r3
   14f1a:	4803      	ldr	r0, [pc, #12]	; (14f28 <_atoi(char const**)+0x5c>)
   14f1c:	f7fe fb2c 	bl	13578 <__cyg_profile_func_exit>
   14f20:	4623      	mov	r3, r4
}
   14f22:	4618      	mov	r0, r3
   14f24:	b005      	add	sp, #20
   14f26:	bd30      	pop	{r4, r5, pc}
   14f28:	00014ecd 	.word	0x00014ecd

00014f2c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
   14f2c:	b530      	push	{r4, r5, lr}
   14f2e:	b089      	sub	sp, #36	; 0x24
   14f30:	4675      	mov	r5, lr
   14f32:	9003      	str	r0, [sp, #12]
   14f34:	9102      	str	r1, [sp, #8]
   14f36:	9201      	str	r2, [sp, #4]
   14f38:	9300      	str	r3, [sp, #0]
   14f3a:	462b      	mov	r3, r5
   14f3c:	4619      	mov	r1, r3
   14f3e:	4891      	ldr	r0, [pc, #580]	; (15184 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   14f40:	f7fe fb06 	bl	13550 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   14f44:	9b01      	ldr	r3, [sp, #4]
   14f46:	9305      	str	r3, [sp, #20]

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14f48:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14f4a:	f003 0302 	and.w	r3, r3, #2
   14f4e:	2b00      	cmp	r3, #0
   14f50:	d10e      	bne.n	14f70 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   14f52:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14f54:	9b10      	ldr	r3, [sp, #64]	; 0x40
   14f56:	429a      	cmp	r2, r3
   14f58:	d20a      	bcs.n	14f70 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   14f5a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14f5c:	2b1f      	cmp	r3, #31
   14f5e:	d807      	bhi.n	14f70 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
    buf[len++] = '0';
   14f60:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14f62:	1c5a      	adds	r2, r3, #1
   14f64:	920d      	str	r2, [sp, #52]	; 0x34
   14f66:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14f68:	4413      	add	r3, r2
   14f6a:	2230      	movs	r2, #48	; 0x30
   14f6c:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14f6e:	e7eb      	b.n	14f48 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1c>
  }
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14f70:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14f72:	f003 0302 	and.w	r3, r3, #2
   14f76:	2b00      	cmp	r3, #0
   14f78:	d113      	bne.n	14fa2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   14f7a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14f7c:	f003 0301 	and.w	r3, r3, #1
   14f80:	2b00      	cmp	r3, #0
   14f82:	d00e      	beq.n	14fa2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   14f84:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14f86:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14f88:	429a      	cmp	r2, r3
   14f8a:	d20a      	bcs.n	14fa2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   14f8c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14f8e:	2b1f      	cmp	r3, #31
   14f90:	d807      	bhi.n	14fa2 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
    buf[len++] = '0';
   14f92:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14f94:	1c5a      	adds	r2, r3, #1
   14f96:	920d      	str	r2, [sp, #52]	; 0x34
   14f98:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14f9a:	4413      	add	r3, r2
   14f9c:	2230      	movs	r2, #48	; 0x30
   14f9e:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14fa0:	e7e6      	b.n	14f70 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
  }

  // handle hash
  if (flags & FLAGS_HASH) {
   14fa2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14fa4:	f003 0310 	and.w	r3, r3, #16
   14fa8:	2b00      	cmp	r3, #0
   14faa:	d058      	beq.n	1505e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   14fac:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14fae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   14fb2:	2b00      	cmp	r3, #0
   14fb4:	d116      	bne.n	14fe4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   14fb6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14fb8:	2b00      	cmp	r3, #0
   14fba:	d013      	beq.n	14fe4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   14fbc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14fbe:	9b10      	ldr	r3, [sp, #64]	; 0x40
   14fc0:	429a      	cmp	r2, r3
   14fc2:	d003      	beq.n	14fcc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xa0>
   14fc4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14fc6:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14fc8:	429a      	cmp	r2, r3
   14fca:	d10b      	bne.n	14fe4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
      len--;
   14fcc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14fce:	3b01      	subs	r3, #1
   14fd0:	930d      	str	r3, [sp, #52]	; 0x34
      if (len && (base == 16U)) {
   14fd2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14fd4:	2b00      	cmp	r3, #0
   14fd6:	d005      	beq.n	14fe4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   14fd8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14fda:	2b10      	cmp	r3, #16
   14fdc:	d102      	bne.n	14fe4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
        len--;
   14fde:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14fe0:	3b01      	subs	r3, #1
   14fe2:	930d      	str	r3, [sp, #52]	; 0x34
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14fe4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14fe6:	2b10      	cmp	r3, #16
   14fe8:	d10f      	bne.n	1500a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   14fea:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14fec:	f003 0320 	and.w	r3, r3, #32
   14ff0:	2b00      	cmp	r3, #0
   14ff2:	d10a      	bne.n	1500a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   14ff4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14ff6:	2b1f      	cmp	r3, #31
   14ff8:	d807      	bhi.n	1500a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
      buf[len++] = 'x';
   14ffa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14ffc:	1c5a      	adds	r2, r3, #1
   14ffe:	920d      	str	r2, [sp, #52]	; 0x34
   15000:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   15002:	4413      	add	r3, r2
   15004:	2278      	movs	r2, #120	; 0x78
   15006:	701a      	strb	r2, [r3, #0]
   15008:	e01f      	b.n	1504a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   1500a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1500c:	2b10      	cmp	r3, #16
   1500e:	d10f      	bne.n	15030 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   15010:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15012:	f003 0320 	and.w	r3, r3, #32
   15016:	2b00      	cmp	r3, #0
   15018:	d00a      	beq.n	15030 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   1501a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1501c:	2b1f      	cmp	r3, #31
   1501e:	d807      	bhi.n	15030 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
      buf[len++] = 'X';
   15020:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15022:	1c5a      	adds	r2, r3, #1
   15024:	920d      	str	r2, [sp, #52]	; 0x34
   15026:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   15028:	4413      	add	r3, r2
   1502a:	2258      	movs	r2, #88	; 0x58
   1502c:	701a      	strb	r2, [r3, #0]
   1502e:	e00c      	b.n	1504a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   15030:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   15032:	2b02      	cmp	r3, #2
   15034:	d109      	bne.n	1504a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
   15036:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15038:	2b1f      	cmp	r3, #31
   1503a:	d806      	bhi.n	1504a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
      buf[len++] = 'b';
   1503c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1503e:	1c5a      	adds	r2, r3, #1
   15040:	920d      	str	r2, [sp, #52]	; 0x34
   15042:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   15044:	4413      	add	r3, r2
   15046:	2262      	movs	r2, #98	; 0x62
   15048:	701a      	strb	r2, [r3, #0]
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
   1504a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1504c:	2b1f      	cmp	r3, #31
   1504e:	d806      	bhi.n	1505e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
      buf[len++] = '0';
   15050:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15052:	1c5a      	adds	r2, r3, #1
   15054:	920d      	str	r2, [sp, #52]	; 0x34
   15056:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   15058:	4413      	add	r3, r2
   1505a:	2230      	movs	r2, #48	; 0x30
   1505c:	701a      	strb	r2, [r3, #0]
    }
  }

  // handle sign
  if (len && (len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   1505e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15060:	2b00      	cmp	r3, #0
   15062:	d014      	beq.n	1508e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   15064:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   15066:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15068:	429a      	cmp	r2, r3
   1506a:	d110      	bne.n	1508e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   1506c:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   15070:	2b00      	cmp	r3, #0
   15072:	d109      	bne.n	15088 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   15074:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15076:	f003 0304 	and.w	r3, r3, #4
   1507a:	2b00      	cmp	r3, #0
   1507c:	d104      	bne.n	15088 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   1507e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15080:	f003 0308 	and.w	r3, r3, #8
   15084:	2b00      	cmp	r3, #0
   15086:	d002      	beq.n	1508e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
    len--;
   15088:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1508a:	3b01      	subs	r3, #1
   1508c:	930d      	str	r3, [sp, #52]	; 0x34
  }
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
   1508e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15090:	2b1f      	cmp	r3, #31
   15092:	d824      	bhi.n	150de <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    if (negative) {
   15094:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   15098:	2b00      	cmp	r3, #0
   1509a:	d007      	beq.n	150ac <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x180>
      buf[len++] = '-';
   1509c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1509e:	1c5a      	adds	r2, r3, #1
   150a0:	920d      	str	r2, [sp, #52]	; 0x34
   150a2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   150a4:	4413      	add	r3, r2
   150a6:	222d      	movs	r2, #45	; 0x2d
   150a8:	701a      	strb	r2, [r3, #0]
   150aa:	e018      	b.n	150de <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_PLUS) {
   150ac:	9b12      	ldr	r3, [sp, #72]	; 0x48
   150ae:	f003 0304 	and.w	r3, r3, #4
   150b2:	2b00      	cmp	r3, #0
   150b4:	d007      	beq.n	150c6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x19a>
      buf[len++] = '+';  // ignore the space if the '+' exists
   150b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   150b8:	1c5a      	adds	r2, r3, #1
   150ba:	920d      	str	r2, [sp, #52]	; 0x34
   150bc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   150be:	4413      	add	r3, r2
   150c0:	222b      	movs	r2, #43	; 0x2b
   150c2:	701a      	strb	r2, [r3, #0]
   150c4:	e00b      	b.n	150de <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_SPACE) {
   150c6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   150c8:	f003 0308 	and.w	r3, r3, #8
   150cc:	2b00      	cmp	r3, #0
   150ce:	d006      	beq.n	150de <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
      buf[len++] = ' ';
   150d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   150d2:	1c5a      	adds	r2, r3, #1
   150d4:	920d      	str	r2, [sp, #52]	; 0x34
   150d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   150d8:	4413      	add	r3, r2
   150da:	2220      	movs	r2, #32
   150dc:	701a      	strb	r2, [r3, #0]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   150de:	9b12      	ldr	r3, [sp, #72]	; 0x48
   150e0:	f003 0302 	and.w	r3, r3, #2
   150e4:	2b00      	cmp	r3, #0
   150e6:	d116      	bne.n	15116 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
   150e8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   150ea:	f003 0301 	and.w	r3, r3, #1
   150ee:	2b00      	cmp	r3, #0
   150f0:	d111      	bne.n	15116 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
    for (size_t i = len; i < width; i++) {
   150f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   150f4:	9307      	str	r3, [sp, #28]
   150f6:	9a07      	ldr	r2, [sp, #28]
   150f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   150fa:	429a      	cmp	r2, r3
   150fc:	d20b      	bcs.n	15116 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
      out(' ', buffer, idx++, maxlen);
   150fe:	9a01      	ldr	r2, [sp, #4]
   15100:	1c53      	adds	r3, r2, #1
   15102:	9301      	str	r3, [sp, #4]
   15104:	9c03      	ldr	r4, [sp, #12]
   15106:	9b00      	ldr	r3, [sp, #0]
   15108:	9902      	ldr	r1, [sp, #8]
   1510a:	2020      	movs	r0, #32
   1510c:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   1510e:	9b07      	ldr	r3, [sp, #28]
   15110:	3301      	adds	r3, #1
   15112:	9307      	str	r3, [sp, #28]
   15114:	e7ef      	b.n	150f6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ca>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   15116:	2300      	movs	r3, #0
   15118:	9306      	str	r3, [sp, #24]
   1511a:	9a06      	ldr	r2, [sp, #24]
   1511c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1511e:	429a      	cmp	r2, r3
   15120:	d211      	bcs.n	15146 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x21a>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   15122:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   15124:	9b06      	ldr	r3, [sp, #24]
   15126:	1ad3      	subs	r3, r2, r3
   15128:	3b01      	subs	r3, #1
   1512a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1512c:	4413      	add	r3, r2
   1512e:	7818      	ldrb	r0, [r3, #0]
   15130:	9a01      	ldr	r2, [sp, #4]
   15132:	1c53      	adds	r3, r2, #1
   15134:	9301      	str	r3, [sp, #4]
   15136:	9c03      	ldr	r4, [sp, #12]
   15138:	9b00      	ldr	r3, [sp, #0]
   1513a:	9902      	ldr	r1, [sp, #8]
   1513c:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   1513e:	9b06      	ldr	r3, [sp, #24]
   15140:	3301      	adds	r3, #1
   15142:	9306      	str	r3, [sp, #24]
   15144:	e7e9      	b.n	1511a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ee>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   15146:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15148:	f003 0302 	and.w	r3, r3, #2
   1514c:	2b00      	cmp	r3, #0
   1514e:	d00e      	beq.n	1516e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
    while (idx - start_idx < width) {
   15150:	9a01      	ldr	r2, [sp, #4]
   15152:	9b05      	ldr	r3, [sp, #20]
   15154:	1ad3      	subs	r3, r2, r3
   15156:	9a11      	ldr	r2, [sp, #68]	; 0x44
   15158:	429a      	cmp	r2, r3
   1515a:	d908      	bls.n	1516e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
      out(' ', buffer, idx++, maxlen);
   1515c:	9a01      	ldr	r2, [sp, #4]
   1515e:	1c53      	adds	r3, r2, #1
   15160:	9301      	str	r3, [sp, #4]
   15162:	9c03      	ldr	r4, [sp, #12]
   15164:	9b00      	ldr	r3, [sp, #0]
   15166:	9902      	ldr	r1, [sp, #8]
   15168:	2020      	movs	r0, #32
   1516a:	47a0      	blx	r4
    while (idx - start_idx < width) {
   1516c:	e7f0      	b.n	15150 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x224>
    }
  }

  return idx;
   1516e:	9c01      	ldr	r4, [sp, #4]
   15170:	462b      	mov	r3, r5
   15172:	4619      	mov	r1, r3
   15174:	4803      	ldr	r0, [pc, #12]	; (15184 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   15176:	f7fe f9ff 	bl	13578 <__cyg_profile_func_exit>
   1517a:	4623      	mov	r3, r4
}
   1517c:	4618      	mov	r0, r3
   1517e:	b009      	add	sp, #36	; 0x24
   15180:	bd30      	pop	{r4, r5, pc}
   15182:	bf00      	nop
   15184:	00014f2d 	.word	0x00014f2d

00015188 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   15188:	b530      	push	{r4, r5, lr}
   1518a:	b097      	sub	sp, #92	; 0x5c
   1518c:	4674      	mov	r4, lr
   1518e:	900b      	str	r0, [sp, #44]	; 0x2c
   15190:	910a      	str	r1, [sp, #40]	; 0x28
   15192:	9209      	str	r2, [sp, #36]	; 0x24
   15194:	9308      	str	r3, [sp, #32]
   15196:	4623      	mov	r3, r4
   15198:	4619      	mov	r1, r3
   1519a:	4833      	ldr	r0, [pc, #204]	; (15268 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   1519c:	f7fe f9d8 	bl	13550 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   151a0:	2300      	movs	r3, #0
   151a2:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   151a4:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   151a6:	2b00      	cmp	r3, #0
   151a8:	d103      	bne.n	151b2 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x2a>
    flags &= ~FLAGS_HASH;
   151aa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   151ac:	f023 0310 	bic.w	r3, r3, #16
   151b0:	931f      	str	r3, [sp, #124]	; 0x7c
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   151b2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   151b4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   151b8:	2b00      	cmp	r3, #0
   151ba:	d002      	beq.n	151c2 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
   151bc:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   151be:	2b00      	cmp	r3, #0
   151c0:	d033      	beq.n	1522a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
      const char digit = (char)(value % base);
   151c2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   151c4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   151c6:	fbb3 f2f2 	udiv	r2, r3, r2
   151ca:	991c      	ldr	r1, [sp, #112]	; 0x70
   151cc:	fb01 f202 	mul.w	r2, r1, r2
   151d0:	1a9b      	subs	r3, r3, r2
   151d2:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   151d6:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   151da:	2b09      	cmp	r3, #9
   151dc:	d804      	bhi.n	151e8 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x60>
   151de:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   151e2:	3330      	adds	r3, #48	; 0x30
   151e4:	b2da      	uxtb	r2, r3
   151e6:	e00d      	b.n	15204 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x7c>
   151e8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   151ea:	f003 0320 	and.w	r3, r3, #32
   151ee:	2b00      	cmp	r3, #0
   151f0:	d001      	beq.n	151f6 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x6e>
   151f2:	2241      	movs	r2, #65	; 0x41
   151f4:	e000      	b.n	151f8 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x70>
   151f6:	2261      	movs	r2, #97	; 0x61
   151f8:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   151fc:	4413      	add	r3, r2
   151fe:	b2db      	uxtb	r3, r3
   15200:	3b0a      	subs	r3, #10
   15202:	b2da      	uxtb	r2, r3
   15204:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15206:	1c59      	adds	r1, r3, #1
   15208:	9115      	str	r1, [sp, #84]	; 0x54
   1520a:	a916      	add	r1, sp, #88	; 0x58
   1520c:	440b      	add	r3, r1
   1520e:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   15212:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15214:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   15216:	fbb2 f3f3 	udiv	r3, r2, r3
   1521a:	931a      	str	r3, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   1521c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   1521e:	2b00      	cmp	r3, #0
   15220:	d003      	beq.n	1522a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
   15222:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15224:	2b1f      	cmp	r3, #31
   15226:	d800      	bhi.n	1522a <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
   15228:	e7cb      	b.n	151c2 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   1522a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1522c:	9306      	str	r3, [sp, #24]
   1522e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15230:	9305      	str	r3, [sp, #20]
   15232:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15234:	9304      	str	r3, [sp, #16]
   15236:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   15238:	9303      	str	r3, [sp, #12]
   1523a:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
   1523e:	9302      	str	r3, [sp, #8]
   15240:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15242:	9301      	str	r3, [sp, #4]
   15244:	ab0c      	add	r3, sp, #48	; 0x30
   15246:	9300      	str	r3, [sp, #0]
   15248:	9b08      	ldr	r3, [sp, #32]
   1524a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1524c:	990a      	ldr	r1, [sp, #40]	; 0x28
   1524e:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15250:	f7ff fe6c 	bl	14f2c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   15254:	4605      	mov	r5, r0
   15256:	4623      	mov	r3, r4
   15258:	4619      	mov	r1, r3
   1525a:	4803      	ldr	r0, [pc, #12]	; (15268 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   1525c:	f7fe f98c 	bl	13578 <__cyg_profile_func_exit>
   15260:	462b      	mov	r3, r5
}
   15262:	4618      	mov	r0, r3
   15264:	b017      	add	sp, #92	; 0x5c
   15266:	bd30      	pop	{r4, r5, pc}
   15268:	00015189 	.word	0x00015189

0001526c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   1526c:	b530      	push	{r4, r5, lr}
   1526e:	b097      	sub	sp, #92	; 0x5c
   15270:	4675      	mov	r5, lr
   15272:	900b      	str	r0, [sp, #44]	; 0x2c
   15274:	910a      	str	r1, [sp, #40]	; 0x28
   15276:	9209      	str	r2, [sp, #36]	; 0x24
   15278:	9308      	str	r3, [sp, #32]
   1527a:	462b      	mov	r3, r5
   1527c:	4619      	mov	r1, r3
   1527e:	4837      	ldr	r0, [pc, #220]	; (1535c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   15280:	f7fe f966 	bl	13550 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   15284:	2300      	movs	r3, #0
   15286:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   15288:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   1528c:	4323      	orrs	r3, r4
   1528e:	d103      	bne.n	15298 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x2c>
    flags &= ~FLAGS_HASH;
   15290:	9b22      	ldr	r3, [sp, #136]	; 0x88
   15292:	f023 0310 	bic.w	r3, r3, #16
   15296:	9322      	str	r3, [sp, #136]	; 0x88
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   15298:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1529a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1529e:	2b00      	cmp	r3, #0
   152a0:	d003      	beq.n	152aa <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
   152a2:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   152a6:	4323      	orrs	r3, r4
   152a8:	d039      	beq.n	1531e <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
      const char digit = (char)(value % base);
   152aa:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   152ae:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   152b2:	f003 fbbb 	bl	18a2c <__aeabi_uldivmod>
   152b6:	461c      	mov	r4, r3
   152b8:	4613      	mov	r3, r2
   152ba:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   152be:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   152c2:	2b09      	cmp	r3, #9
   152c4:	d804      	bhi.n	152d0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x64>
   152c6:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   152ca:	3330      	adds	r3, #48	; 0x30
   152cc:	b2da      	uxtb	r2, r3
   152ce:	e00d      	b.n	152ec <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x80>
   152d0:	9b22      	ldr	r3, [sp, #136]	; 0x88
   152d2:	f003 0320 	and.w	r3, r3, #32
   152d6:	2b00      	cmp	r3, #0
   152d8:	d001      	beq.n	152de <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x72>
   152da:	2241      	movs	r2, #65	; 0x41
   152dc:	e000      	b.n	152e0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x74>
   152de:	2261      	movs	r2, #97	; 0x61
   152e0:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   152e4:	4413      	add	r3, r2
   152e6:	b2db      	uxtb	r3, r3
   152e8:	3b0a      	subs	r3, #10
   152ea:	b2da      	uxtb	r2, r3
   152ec:	9b15      	ldr	r3, [sp, #84]	; 0x54
   152ee:	1c59      	adds	r1, r3, #1
   152f0:	9115      	str	r1, [sp, #84]	; 0x54
   152f2:	a916      	add	r1, sp, #88	; 0x58
   152f4:	440b      	add	r3, r1
   152f6:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   152fa:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   152fe:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   15302:	f003 fb93 	bl	18a2c <__aeabi_uldivmod>
   15306:	4603      	mov	r3, r0
   15308:	460c      	mov	r4, r1
   1530a:	e9cd 341a 	strd	r3, r4, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   1530e:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   15312:	4323      	orrs	r3, r4
   15314:	d003      	beq.n	1531e <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
   15316:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15318:	2b1f      	cmp	r3, #31
   1531a:	d800      	bhi.n	1531e <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
   1531c:	e7c5      	b.n	152aa <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   1531e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15320:	9a22      	ldr	r2, [sp, #136]	; 0x88
   15322:	9206      	str	r2, [sp, #24]
   15324:	9a21      	ldr	r2, [sp, #132]	; 0x84
   15326:	9205      	str	r2, [sp, #20]
   15328:	9a20      	ldr	r2, [sp, #128]	; 0x80
   1532a:	9204      	str	r2, [sp, #16]
   1532c:	9303      	str	r3, [sp, #12]
   1532e:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
   15332:	9302      	str	r3, [sp, #8]
   15334:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15336:	9301      	str	r3, [sp, #4]
   15338:	ab0c      	add	r3, sp, #48	; 0x30
   1533a:	9300      	str	r3, [sp, #0]
   1533c:	9b08      	ldr	r3, [sp, #32]
   1533e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   15340:	990a      	ldr	r1, [sp, #40]	; 0x28
   15342:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15344:	f7ff fdf2 	bl	14f2c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   15348:	4604      	mov	r4, r0
   1534a:	462b      	mov	r3, r5
   1534c:	4619      	mov	r1, r3
   1534e:	4803      	ldr	r0, [pc, #12]	; (1535c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   15350:	f7fe f912 	bl	13578 <__cyg_profile_func_exit>
   15354:	4623      	mov	r3, r4
}
   15356:	4618      	mov	r0, r3
   15358:	b017      	add	sp, #92	; 0x5c
   1535a:	bd30      	pop	{r4, r5, pc}
   1535c:	0001526d 	.word	0x0001526d

00015360 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>:
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value_param, unsigned int prec, unsigned int width, unsigned int flags)
{
   15360:	b530      	push	{r4, r5, lr}
   15362:	b09b      	sub	sp, #108	; 0x6c
   15364:	4675      	mov	r5, lr
   15366:	9005      	str	r0, [sp, #20]
   15368:	9104      	str	r1, [sp, #16]
   1536a:	9203      	str	r2, [sp, #12]
   1536c:	9302      	str	r3, [sp, #8]
   1536e:	ed8d 0b00 	vstr	d0, [sp]
   15372:	462b      	mov	r3, r5
   15374:	4619      	mov	r1, r3
   15376:	48b7      	ldr	r0, [pc, #732]	; (15654 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f4>)
   15378:	f7fe f8ea 	bl	13550 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   1537c:	9b03      	ldr	r3, [sp, #12]
   1537e:	9311      	str	r3, [sp, #68]	; 0x44

  float value = static_cast<float>(value_param);
   15380:	e9dd 0100 	ldrd	r0, r1, [sp]
   15384:	f003 fb02 	bl	1898c <__aeabi_d2f>
   15388:	4603      	mov	r3, r0
   1538a:	9319      	str	r3, [sp, #100]	; 0x64

  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
   1538c:	2300      	movs	r3, #0
   1538e:	9318      	str	r3, [sp, #96]	; 0x60
  float diff = 0.0;
   15390:	f04f 0300 	mov.w	r3, #0
   15394:	9310      	str	r3, [sp, #64]	; 0x40

  // if input is larger than thres_max, revert to exponential
  const float thres_max = (float)0x7FFFFFFF;
   15396:	f04f 439e 	mov.w	r3, #1325400064	; 0x4f000000
   1539a:	930f      	str	r3, [sp, #60]	; 0x3c

  // powers of 10
  static const float pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for negative
  bool negative = false;
   1539c:	2300      	movs	r3, #0
   1539e:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
  if (value < 0) {
   153a2:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   153a6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   153aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   153ae:	d50a      	bpl.n	153c6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x66>
    negative = true;
   153b0:	2301      	movs	r3, #1
   153b2:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    value = 0 - value;
   153b6:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 15658 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f8>
   153ba:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   153be:	ee77 7a67 	vsub.f32	s15, s14, s15
   153c2:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
  }

  // set default precision to 6, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
   153c6:	9b20      	ldr	r3, [sp, #128]	; 0x80
   153c8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   153cc:	2b00      	cmp	r3, #0
   153ce:	d101      	bne.n	153d4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
    prec = 6U;
   153d0:	2306      	movs	r3, #6
   153d2:	931e      	str	r3, [sp, #120]	; 0x78
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   153d4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   153d6:	2b1f      	cmp	r3, #31
   153d8:	d80e      	bhi.n	153f8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
   153da:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   153dc:	2b09      	cmp	r3, #9
   153de:	d90b      	bls.n	153f8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
    buf[len++] = '0';
   153e0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   153e2:	1c5a      	adds	r2, r3, #1
   153e4:	9218      	str	r2, [sp, #96]	; 0x60
   153e6:	aa1a      	add	r2, sp, #104	; 0x68
   153e8:	4413      	add	r3, r2
   153ea:	2230      	movs	r2, #48	; 0x30
   153ec:	f803 2c50 	strb.w	r2, [r3, #-80]
    prec--;
   153f0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   153f2:	3b01      	subs	r3, #1
   153f4:	931e      	str	r3, [sp, #120]	; 0x78
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   153f6:	e7ed      	b.n	153d4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
  }

  int whole = (int)value;
   153f8:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   153fc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   15400:	ee17 3a90 	vmov	r3, s15
   15404:	9316      	str	r3, [sp, #88]	; 0x58
  float tmp = (value - whole) * pow10[prec];
   15406:	9b16      	ldr	r3, [sp, #88]	; 0x58
   15408:	ee07 3a90 	vmov	s15, r3
   1540c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   15410:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   15414:	ee37 7a67 	vsub.f32	s14, s14, s15
   15418:	4a90      	ldr	r2, [pc, #576]	; (1565c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   1541a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1541c:	009b      	lsls	r3, r3, #2
   1541e:	4413      	add	r3, r2
   15420:	edd3 7a00 	vldr	s15, [r3]
   15424:	ee67 7a27 	vmul.f32	s15, s14, s15
   15428:	edcd 7a0e 	vstr	s15, [sp, #56]	; 0x38
  unsigned long frac = (unsigned long)tmp;
   1542c:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   15430:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   15434:	ee17 3a90 	vmov	r3, s15
   15438:	9315      	str	r3, [sp, #84]	; 0x54
  diff = tmp - frac;
   1543a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1543c:	ee07 3a90 	vmov	s15, r3
   15440:	eef8 7a67 	vcvt.f32.u32	s15, s15
   15444:	ed9d 7a0e 	vldr	s14, [sp, #56]	; 0x38
   15448:	ee77 7a67 	vsub.f32	s15, s14, s15
   1544c:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40

  if (diff > 0.5) {
   15450:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   15454:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   15458:	eef4 7ac7 	vcmpe.f32	s15, s14
   1545c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15460:	dd18      	ble.n	15494 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x134>
    ++frac;
   15462:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15464:	3301      	adds	r3, #1
   15466:	9315      	str	r3, [sp, #84]	; 0x54
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
   15468:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1546a:	ee07 3a90 	vmov	s15, r3
   1546e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   15472:	4a7a      	ldr	r2, [pc, #488]	; (1565c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   15474:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15476:	009b      	lsls	r3, r3, #2
   15478:	4413      	add	r3, r2
   1547a:	edd3 7a00 	vldr	s15, [r3]
   1547e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   15482:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15486:	db19      	blt.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
      frac = 0;
   15488:	2300      	movs	r3, #0
   1548a:	9315      	str	r3, [sp, #84]	; 0x54
      ++whole;
   1548c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1548e:	3301      	adds	r3, #1
   15490:	9316      	str	r3, [sp, #88]	; 0x58
   15492:	e013      	b.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    }
  }
  else if ((diff == 0.5) && ((frac == 0U) || (frac & 1U))) {
   15494:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   15498:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   1549c:	eef4 7a47 	vcmp.f32	s15, s14
   154a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   154a4:	d10a      	bne.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
   154a6:	9b15      	ldr	r3, [sp, #84]	; 0x54
   154a8:	2b00      	cmp	r3, #0
   154aa:	d004      	beq.n	154b6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
   154ac:	9b15      	ldr	r3, [sp, #84]	; 0x54
   154ae:	f003 0301 	and.w	r3, r3, #1
   154b2:	2b00      	cmp	r3, #0
   154b4:	d002      	beq.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    // if halfway, round up if odd, OR if last digit is 0
    ++frac;
   154b6:	9b15      	ldr	r3, [sp, #84]	; 0x54
   154b8:	3301      	adds	r3, #1
   154ba:	9315      	str	r3, [sp, #84]	; 0x54
  }

  // TBD: for very large numbers switch back to native sprintf for exponentials. Anyone want to write code to replace this?
  // Normal printf behavior is to print EVERY whole number digit which can be 100s of characters overflowing your buffers == bad
  if (value > thres_max) {
   154bc:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   154c0:	ed9f 7a67 	vldr	s14, [pc, #412]	; 15660 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>
   154c4:	eef4 7ac7 	vcmpe.f32	s15, s14
   154c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   154cc:	dd01      	ble.n	154d2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x172>
    return 0U;
   154ce:	2400      	movs	r4, #0
   154d0:	e156      	b.n	15780 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x420>
  }

  if (prec == 0U) {
   154d2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   154d4:	2b00      	cmp	r3, #0
   154d6:	d129      	bne.n	1552c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1cc>
    diff = value - (float)whole;
   154d8:	9b16      	ldr	r3, [sp, #88]	; 0x58
   154da:	ee07 3a90 	vmov	s15, r3
   154de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   154e2:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   154e6:	ee77 7a67 	vsub.f32	s15, s14, s15
   154ea:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
    if (diff > 0.5) {
   154ee:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   154f2:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   154f6:	eef4 7ac7 	vcmpe.f32	s15, s14
   154fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   154fe:	dd03      	ble.n	15508 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1a8>
      // greater than 0.5, round up, e.g. 1.6 -> 2
      ++whole;
   15500:	9b16      	ldr	r3, [sp, #88]	; 0x58
   15502:	3301      	adds	r3, #1
   15504:	9316      	str	r3, [sp, #88]	; 0x58
   15506:	e05f      	b.n	155c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
    else if ((diff == 0.5) && (whole & 1)) {
   15508:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   1550c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   15510:	eef4 7a47 	vcmp.f32	s15, s14
   15514:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15518:	d156      	bne.n	155c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
   1551a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1551c:	f003 0301 	and.w	r3, r3, #1
   15520:	2b00      	cmp	r3, #0
   15522:	d051      	beq.n	155c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
   15524:	9b16      	ldr	r3, [sp, #88]	; 0x58
   15526:	3301      	adds	r3, #1
   15528:	9316      	str	r3, [sp, #88]	; 0x58
   1552a:	e04d      	b.n	155c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
  }
  else {
    unsigned int count = prec;
   1552c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1552e:	9314      	str	r3, [sp, #80]	; 0x50
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   15530:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15532:	2b1f      	cmp	r3, #31
   15534:	d827      	bhi.n	15586 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
      --count;
   15536:	9b14      	ldr	r3, [sp, #80]	; 0x50
   15538:	3b01      	subs	r3, #1
   1553a:	9314      	str	r3, [sp, #80]	; 0x50
      buf[len++] = (char)(48U + (frac % 10U));
   1553c:	9915      	ldr	r1, [sp, #84]	; 0x54
   1553e:	4b49      	ldr	r3, [pc, #292]	; (15664 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   15540:	fba3 2301 	umull	r2, r3, r3, r1
   15544:	08da      	lsrs	r2, r3, #3
   15546:	4613      	mov	r3, r2
   15548:	009b      	lsls	r3, r3, #2
   1554a:	4413      	add	r3, r2
   1554c:	005b      	lsls	r3, r3, #1
   1554e:	1aca      	subs	r2, r1, r3
   15550:	b2d3      	uxtb	r3, r2
   15552:	3330      	adds	r3, #48	; 0x30
   15554:	b2d9      	uxtb	r1, r3
   15556:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15558:	1c5a      	adds	r2, r3, #1
   1555a:	9218      	str	r2, [sp, #96]	; 0x60
   1555c:	aa1a      	add	r2, sp, #104	; 0x68
   1555e:	4413      	add	r3, r2
   15560:	460a      	mov	r2, r1
   15562:	f803 2c50 	strb.w	r2, [r3, #-80]
      if (!(frac /= 10U)) {
   15566:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15568:	4a3e      	ldr	r2, [pc, #248]	; (15664 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   1556a:	fba2 2303 	umull	r2, r3, r2, r3
   1556e:	08db      	lsrs	r3, r3, #3
   15570:	9315      	str	r3, [sp, #84]	; 0x54
   15572:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15574:	2b00      	cmp	r3, #0
   15576:	bf0c      	ite	eq
   15578:	2301      	moveq	r3, #1
   1557a:	2300      	movne	r3, #0
   1557c:	b2db      	uxtb	r3, r3
   1557e:	2b00      	cmp	r3, #0
   15580:	d100      	bne.n	15584 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x224>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   15582:	e7d5      	b.n	15530 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1d0>
        break;
   15584:	bf00      	nop
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   15586:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15588:	2b1f      	cmp	r3, #31
   1558a:	d806      	bhi.n	1559a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   1558c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1558e:	1e5a      	subs	r2, r3, #1
   15590:	9214      	str	r2, [sp, #80]	; 0x50
   15592:	2b00      	cmp	r3, #0
   15594:	d001      	beq.n	1559a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   15596:	2301      	movs	r3, #1
   15598:	e000      	b.n	1559c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23c>
   1559a:	2300      	movs	r3, #0
   1559c:	2b00      	cmp	r3, #0
   1559e:	d008      	beq.n	155b2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x252>
      buf[len++] = '0';
   155a0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   155a2:	1c5a      	adds	r2, r3, #1
   155a4:	9218      	str	r2, [sp, #96]	; 0x60
   155a6:	aa1a      	add	r2, sp, #104	; 0x68
   155a8:	4413      	add	r3, r2
   155aa:	2230      	movs	r2, #48	; 0x30
   155ac:	f803 2c50 	strb.w	r2, [r3, #-80]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   155b0:	e7e9      	b.n	15586 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
   155b2:	9b18      	ldr	r3, [sp, #96]	; 0x60
   155b4:	2b1f      	cmp	r3, #31
   155b6:	d807      	bhi.n	155c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // add decimal
      buf[len++] = '.';
   155b8:	9b18      	ldr	r3, [sp, #96]	; 0x60
   155ba:	1c5a      	adds	r2, r3, #1
   155bc:	9218      	str	r2, [sp, #96]	; 0x60
   155be:	aa1a      	add	r2, sp, #104	; 0x68
   155c0:	4413      	add	r3, r2
   155c2:	222e      	movs	r2, #46	; 0x2e
   155c4:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   155c8:	9b18      	ldr	r3, [sp, #96]	; 0x60
   155ca:	2b1f      	cmp	r3, #31
   155cc:	d828      	bhi.n	15620 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
    buf[len++] = (char)(48 + (whole % 10));
   155ce:	9a16      	ldr	r2, [sp, #88]	; 0x58
   155d0:	4b25      	ldr	r3, [pc, #148]	; (15668 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   155d2:	fb83 1302 	smull	r1, r3, r3, r2
   155d6:	1099      	asrs	r1, r3, #2
   155d8:	17d3      	asrs	r3, r2, #31
   155da:	1ac9      	subs	r1, r1, r3
   155dc:	460b      	mov	r3, r1
   155de:	009b      	lsls	r3, r3, #2
   155e0:	440b      	add	r3, r1
   155e2:	005b      	lsls	r3, r3, #1
   155e4:	1ad1      	subs	r1, r2, r3
   155e6:	b2cb      	uxtb	r3, r1
   155e8:	3330      	adds	r3, #48	; 0x30
   155ea:	b2d9      	uxtb	r1, r3
   155ec:	9b18      	ldr	r3, [sp, #96]	; 0x60
   155ee:	1c5a      	adds	r2, r3, #1
   155f0:	9218      	str	r2, [sp, #96]	; 0x60
   155f2:	aa1a      	add	r2, sp, #104	; 0x68
   155f4:	4413      	add	r3, r2
   155f6:	460a      	mov	r2, r1
   155f8:	f803 2c50 	strb.w	r2, [r3, #-80]
    if (!(whole /= 10)) {
   155fc:	9b16      	ldr	r3, [sp, #88]	; 0x58
   155fe:	4a1a      	ldr	r2, [pc, #104]	; (15668 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   15600:	fb82 1203 	smull	r1, r2, r2, r3
   15604:	1092      	asrs	r2, r2, #2
   15606:	17db      	asrs	r3, r3, #31
   15608:	1ad3      	subs	r3, r2, r3
   1560a:	9316      	str	r3, [sp, #88]	; 0x58
   1560c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1560e:	2b00      	cmp	r3, #0
   15610:	bf0c      	ite	eq
   15612:	2301      	moveq	r3, #1
   15614:	2300      	movne	r3, #0
   15616:	b2db      	uxtb	r3, r3
   15618:	2b00      	cmp	r3, #0
   1561a:	d100      	bne.n	1561e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2be>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   1561c:	e7d4      	b.n	155c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      break;
   1561e:	bf00      	nop
    }
  }

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   15620:	9b20      	ldr	r3, [sp, #128]	; 0x80
   15622:	f003 0302 	and.w	r3, r3, #2
   15626:	2b00      	cmp	r3, #0
   15628:	d120      	bne.n	1566c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   1562a:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1562c:	f003 0301 	and.w	r3, r3, #1
   15630:	2b00      	cmp	r3, #0
   15632:	d01b      	beq.n	1566c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   15634:	9a18      	ldr	r2, [sp, #96]	; 0x60
   15636:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15638:	429a      	cmp	r2, r3
   1563a:	d217      	bcs.n	1566c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   1563c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1563e:	2b1f      	cmp	r3, #31
   15640:	d814      	bhi.n	1566c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
    buf[len++] = '0';
   15642:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15644:	1c5a      	adds	r2, r3, #1
   15646:	9218      	str	r2, [sp, #96]	; 0x60
   15648:	aa1a      	add	r2, sp, #104	; 0x68
   1564a:	4413      	add	r3, r2
   1564c:	2230      	movs	r2, #48	; 0x30
   1564e:	f803 2c50 	strb.w	r2, [r3, #-80]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   15652:	e7e5      	b.n	15620 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
   15654:	00015361 	.word	0x00015361
   15658:	00000000 	.word	0x00000000
   1565c:	00019f1c 	.word	0x00019f1c
   15660:	4f000000 	.word	0x4f000000
   15664:	cccccccd 	.word	0xcccccccd
   15668:	66666667 	.word	0x66666667
  }

  // handle sign
  if ((len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   1566c:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1566e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15670:	429a      	cmp	r2, r3
   15672:	d110      	bne.n	15696 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
   15674:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   15678:	2b00      	cmp	r3, #0
   1567a:	d109      	bne.n	15690 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   1567c:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1567e:	f003 0304 	and.w	r3, r3, #4
   15682:	2b00      	cmp	r3, #0
   15684:	d104      	bne.n	15690 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   15686:	9b20      	ldr	r3, [sp, #128]	; 0x80
   15688:	f003 0308 	and.w	r3, r3, #8
   1568c:	2b00      	cmp	r3, #0
   1568e:	d002      	beq.n	15696 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
    len--;
   15690:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15692:	3b01      	subs	r3, #1
   15694:	9318      	str	r3, [sp, #96]	; 0x60
  }
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
   15696:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15698:	2b1f      	cmp	r3, #31
   1569a:	d827      	bhi.n	156ec <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    if (negative) {
   1569c:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   156a0:	2b00      	cmp	r3, #0
   156a2:	d008      	beq.n	156b6 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x356>
      buf[len++] = '-';
   156a4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   156a6:	1c5a      	adds	r2, r3, #1
   156a8:	9218      	str	r2, [sp, #96]	; 0x60
   156aa:	aa1a      	add	r2, sp, #104	; 0x68
   156ac:	4413      	add	r3, r2
   156ae:	222d      	movs	r2, #45	; 0x2d
   156b0:	f803 2c50 	strb.w	r2, [r3, #-80]
   156b4:	e01a      	b.n	156ec <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_PLUS) {
   156b6:	9b20      	ldr	r3, [sp, #128]	; 0x80
   156b8:	f003 0304 	and.w	r3, r3, #4
   156bc:	2b00      	cmp	r3, #0
   156be:	d008      	beq.n	156d2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x372>
      buf[len++] = '+';  // ignore the space if the '+' exists
   156c0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   156c2:	1c5a      	adds	r2, r3, #1
   156c4:	9218      	str	r2, [sp, #96]	; 0x60
   156c6:	aa1a      	add	r2, sp, #104	; 0x68
   156c8:	4413      	add	r3, r2
   156ca:	222b      	movs	r2, #43	; 0x2b
   156cc:	f803 2c50 	strb.w	r2, [r3, #-80]
   156d0:	e00c      	b.n	156ec <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_SPACE) {
   156d2:	9b20      	ldr	r3, [sp, #128]	; 0x80
   156d4:	f003 0308 	and.w	r3, r3, #8
   156d8:	2b00      	cmp	r3, #0
   156da:	d007      	beq.n	156ec <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
      buf[len++] = ' ';
   156dc:	9b18      	ldr	r3, [sp, #96]	; 0x60
   156de:	1c5a      	adds	r2, r3, #1
   156e0:	9218      	str	r2, [sp, #96]	; 0x60
   156e2:	aa1a      	add	r2, sp, #104	; 0x68
   156e4:	4413      	add	r3, r2
   156e6:	2220      	movs	r2, #32
   156e8:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   156ec:	9b20      	ldr	r3, [sp, #128]	; 0x80
   156ee:	f003 0302 	and.w	r3, r3, #2
   156f2:	2b00      	cmp	r3, #0
   156f4:	d116      	bne.n	15724 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
   156f6:	9b20      	ldr	r3, [sp, #128]	; 0x80
   156f8:	f003 0301 	and.w	r3, r3, #1
   156fc:	2b00      	cmp	r3, #0
   156fe:	d111      	bne.n	15724 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
    for (size_t i = len; i < width; i++) {
   15700:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15702:	9313      	str	r3, [sp, #76]	; 0x4c
   15704:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   15706:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15708:	429a      	cmp	r2, r3
   1570a:	d20b      	bcs.n	15724 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
      out(' ', buffer, idx++, maxlen);
   1570c:	9a03      	ldr	r2, [sp, #12]
   1570e:	1c53      	adds	r3, r2, #1
   15710:	9303      	str	r3, [sp, #12]
   15712:	9c05      	ldr	r4, [sp, #20]
   15714:	9b02      	ldr	r3, [sp, #8]
   15716:	9904      	ldr	r1, [sp, #16]
   15718:	2020      	movs	r0, #32
   1571a:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   1571c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1571e:	3301      	adds	r3, #1
   15720:	9313      	str	r3, [sp, #76]	; 0x4c
   15722:	e7ef      	b.n	15704 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3a4>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   15724:	2300      	movs	r3, #0
   15726:	9312      	str	r3, [sp, #72]	; 0x48
   15728:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1572a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1572c:	429a      	cmp	r2, r3
   1572e:	d212      	bcs.n	15756 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3f6>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   15730:	9a18      	ldr	r2, [sp, #96]	; 0x60
   15732:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15734:	1ad3      	subs	r3, r2, r3
   15736:	3b01      	subs	r3, #1
   15738:	aa1a      	add	r2, sp, #104	; 0x68
   1573a:	4413      	add	r3, r2
   1573c:	f813 0c50 	ldrb.w	r0, [r3, #-80]
   15740:	9a03      	ldr	r2, [sp, #12]
   15742:	1c53      	adds	r3, r2, #1
   15744:	9303      	str	r3, [sp, #12]
   15746:	9c05      	ldr	r4, [sp, #20]
   15748:	9b02      	ldr	r3, [sp, #8]
   1574a:	9904      	ldr	r1, [sp, #16]
   1574c:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   1574e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15750:	3301      	adds	r3, #1
   15752:	9312      	str	r3, [sp, #72]	; 0x48
   15754:	e7e8      	b.n	15728 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c8>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   15756:	9b20      	ldr	r3, [sp, #128]	; 0x80
   15758:	f003 0302 	and.w	r3, r3, #2
   1575c:	2b00      	cmp	r3, #0
   1575e:	d00e      	beq.n	1577e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
    while (idx - start_idx < width) {
   15760:	9a03      	ldr	r2, [sp, #12]
   15762:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15764:	1ad3      	subs	r3, r2, r3
   15766:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15768:	429a      	cmp	r2, r3
   1576a:	d908      	bls.n	1577e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
      out(' ', buffer, idx++, maxlen);
   1576c:	9a03      	ldr	r2, [sp, #12]
   1576e:	1c53      	adds	r3, r2, #1
   15770:	9303      	str	r3, [sp, #12]
   15772:	9c05      	ldr	r4, [sp, #20]
   15774:	9b02      	ldr	r3, [sp, #8]
   15776:	9904      	ldr	r1, [sp, #16]
   15778:	2020      	movs	r0, #32
   1577a:	47a0      	blx	r4
    while (idx - start_idx < width) {
   1577c:	e7f0      	b.n	15760 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x400>
    }
  }

  return idx;
   1577e:	9c03      	ldr	r4, [sp, #12]
   15780:	462b      	mov	r3, r5
   15782:	4619      	mov	r1, r3
   15784:	4803      	ldr	r0, [pc, #12]	; (15794 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x434>)
   15786:	f7fd fef7 	bl	13578 <__cyg_profile_func_exit>
   1578a:	4623      	mov	r3, r4
}
   1578c:	4618      	mov	r0, r3
   1578e:	b01b      	add	sp, #108	; 0x6c
   15790:	bd30      	pop	{r4, r5, pc}
   15792:	bf00      	nop
   15794:	00015361 	.word	0x00015361

00015798 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
   15798:	b570      	push	{r4, r5, r6, lr}
   1579a:	b0a0      	sub	sp, #128	; 0x80
   1579c:	4676      	mov	r6, lr
   1579e:	900d      	str	r0, [sp, #52]	; 0x34
   157a0:	910c      	str	r1, [sp, #48]	; 0x30
   157a2:	920b      	str	r2, [sp, #44]	; 0x2c
   157a4:	930a      	str	r3, [sp, #40]	; 0x28
   157a6:	4633      	mov	r3, r6
   157a8:	4619      	mov	r1, r3
   157aa:	48a7      	ldr	r0, [pc, #668]	; (15a48 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b0>)
   157ac:	f7fd fed0 	bl	13550 <__cyg_profile_func_enter>
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
   157b0:	2300      	movs	r3, #0
   157b2:	931b      	str	r3, [sp, #108]	; 0x6c

  if (!buffer) {
   157b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   157b6:	2b00      	cmp	r3, #0
   157b8:	d101      	bne.n	157be <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    // use null output function
    out = _out_null;
   157ba:	4ba4      	ldr	r3, [pc, #656]	; (15a4c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b4>)
   157bc:	930d      	str	r3, [sp, #52]	; 0x34
  }

  while (*format)
   157be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157c0:	781b      	ldrb	r3, [r3, #0]
   157c2:	2b00      	cmp	r3, #0
   157c4:	f000 8448 	beq.w	16058 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8c0>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
   157c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157ca:	781b      	ldrb	r3, [r3, #0]
   157cc:	2b25      	cmp	r3, #37	; 0x25
   157ce:	d00d      	beq.n	157ec <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x54>
      // no
      out(*format, buffer, idx++, maxlen);
   157d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157d2:	7818      	ldrb	r0, [r3, #0]
   157d4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   157d6:	1c53      	adds	r3, r2, #1
   157d8:	931b      	str	r3, [sp, #108]	; 0x6c
   157da:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   157dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   157de:	990c      	ldr	r1, [sp, #48]	; 0x30
   157e0:	47a0      	blx	r4
      format++;
   157e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157e4:	3301      	adds	r3, #1
   157e6:	930a      	str	r3, [sp, #40]	; 0x28
      continue;
   157e8:	f000 bc34 	b.w	16054 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
    }
    else {
      // yes, evaluate it
      format++;
   157ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157ee:	3301      	adds	r3, #1
   157f0:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate flags
    flags = 0U;
   157f2:	2300      	movs	r3, #0
   157f4:	931f      	str	r3, [sp, #124]	; 0x7c
    do {
      switch (*format) {
   157f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157f8:	781b      	ldrb	r3, [r3, #0]
   157fa:	3b20      	subs	r3, #32
   157fc:	2b10      	cmp	r3, #16
   157fe:	d857      	bhi.n	158b0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x118>
   15800:	a201      	add	r2, pc, #4	; (adr r2, 15808 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70>)
   15802:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   15806:	bf00      	nop
   15808:	00015889 	.word	0x00015889
   1580c:	000158b1 	.word	0x000158b1
   15810:	000158b1 	.word	0x000158b1
   15814:	0001589d 	.word	0x0001589d
   15818:	000158b1 	.word	0x000158b1
   1581c:	000158b1 	.word	0x000158b1
   15820:	000158b1 	.word	0x000158b1
   15824:	000158b1 	.word	0x000158b1
   15828:	000158b1 	.word	0x000158b1
   1582c:	000158b1 	.word	0x000158b1
   15830:	000158b1 	.word	0x000158b1
   15834:	00015875 	.word	0x00015875
   15838:	000158b1 	.word	0x000158b1
   1583c:	00015861 	.word	0x00015861
   15840:	000158b1 	.word	0x000158b1
   15844:	000158b1 	.word	0x000158b1
   15848:	0001584d 	.word	0x0001584d
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   1584c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1584e:	f043 0301 	orr.w	r3, r3, #1
   15852:	931f      	str	r3, [sp, #124]	; 0x7c
   15854:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15856:	3301      	adds	r3, #1
   15858:	930a      	str	r3, [sp, #40]	; 0x28
   1585a:	2301      	movs	r3, #1
   1585c:	931c      	str	r3, [sp, #112]	; 0x70
   1585e:	e02a      	b.n	158b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   15860:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15862:	f043 0302 	orr.w	r3, r3, #2
   15866:	931f      	str	r3, [sp, #124]	; 0x7c
   15868:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1586a:	3301      	adds	r3, #1
   1586c:	930a      	str	r3, [sp, #40]	; 0x28
   1586e:	2301      	movs	r3, #1
   15870:	931c      	str	r3, [sp, #112]	; 0x70
   15872:	e020      	b.n	158b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   15874:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15876:	f043 0304 	orr.w	r3, r3, #4
   1587a:	931f      	str	r3, [sp, #124]	; 0x7c
   1587c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1587e:	3301      	adds	r3, #1
   15880:	930a      	str	r3, [sp, #40]	; 0x28
   15882:	2301      	movs	r3, #1
   15884:	931c      	str	r3, [sp, #112]	; 0x70
   15886:	e016      	b.n	158b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   15888:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1588a:	f043 0308 	orr.w	r3, r3, #8
   1588e:	931f      	str	r3, [sp, #124]	; 0x7c
   15890:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15892:	3301      	adds	r3, #1
   15894:	930a      	str	r3, [sp, #40]	; 0x28
   15896:	2301      	movs	r3, #1
   15898:	931c      	str	r3, [sp, #112]	; 0x70
   1589a:	e00c      	b.n	158b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   1589c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1589e:	f043 0310 	orr.w	r3, r3, #16
   158a2:	931f      	str	r3, [sp, #124]	; 0x7c
   158a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   158a6:	3301      	adds	r3, #1
   158a8:	930a      	str	r3, [sp, #40]	; 0x28
   158aa:	2301      	movs	r3, #1
   158ac:	931c      	str	r3, [sp, #112]	; 0x70
   158ae:	e002      	b.n	158b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        default :                                   n = 0U; break;
   158b0:	2300      	movs	r3, #0
   158b2:	931c      	str	r3, [sp, #112]	; 0x70
   158b4:	bf00      	nop
      }
    } while (n);
   158b6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   158b8:	2b00      	cmp	r3, #0
   158ba:	d000      	beq.n	158be <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x126>
    do {
   158bc:	e79b      	b.n	157f6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5e>

    // evaluate width field
    width = 0U;
   158be:	2300      	movs	r3, #0
   158c0:	931e      	str	r3, [sp, #120]	; 0x78
    if (_is_digit(*format)) {
   158c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   158c4:	781b      	ldrb	r3, [r3, #0]
   158c6:	4618      	mov	r0, r3
   158c8:	f7ff fade 	bl	14e88 <_is_digit(char)>
   158cc:	4603      	mov	r3, r0
   158ce:	2b00      	cmp	r3, #0
   158d0:	d005      	beq.n	158de <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x146>
      width = _atoi(&format);
   158d2:	ab0a      	add	r3, sp, #40	; 0x28
   158d4:	4618      	mov	r0, r3
   158d6:	f7ff faf9 	bl	14ecc <_atoi(char const**)>
   158da:	901e      	str	r0, [sp, #120]	; 0x78
   158dc:	e018      	b.n	15910 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
    }
    else if (*format == '*') {
   158de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   158e0:	781b      	ldrb	r3, [r3, #0]
   158e2:	2b2a      	cmp	r3, #42	; 0x2a
   158e4:	d114      	bne.n	15910 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
      const int w = va_arg(va, int);
   158e6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   158e8:	1d1a      	adds	r2, r3, #4
   158ea:	9224      	str	r2, [sp, #144]	; 0x90
   158ec:	681b      	ldr	r3, [r3, #0]
   158ee:	9316      	str	r3, [sp, #88]	; 0x58
      if (w < 0) {
   158f0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   158f2:	2b00      	cmp	r3, #0
   158f4:	da07      	bge.n	15906 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16e>
        flags |= FLAGS_LEFT;    // reverse padding
   158f6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   158f8:	f043 0302 	orr.w	r3, r3, #2
   158fc:	931f      	str	r3, [sp, #124]	; 0x7c
        width = (unsigned int)-w;
   158fe:	9b16      	ldr	r3, [sp, #88]	; 0x58
   15900:	425b      	negs	r3, r3
   15902:	931e      	str	r3, [sp, #120]	; 0x78
   15904:	e001      	b.n	1590a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x172>
      }
      else {
        width = (unsigned int)w;
   15906:	9b16      	ldr	r3, [sp, #88]	; 0x58
   15908:	931e      	str	r3, [sp, #120]	; 0x78
      }
      format++;
   1590a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1590c:	3301      	adds	r3, #1
   1590e:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate precision field
    precision = 0U;
   15910:	2300      	movs	r3, #0
   15912:	931d      	str	r3, [sp, #116]	; 0x74
    if (*format == '.') {
   15914:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15916:	781b      	ldrb	r3, [r3, #0]
   15918:	2b2e      	cmp	r3, #46	; 0x2e
   1591a:	d124      	bne.n	15966 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      flags |= FLAGS_PRECISION;
   1591c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1591e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   15922:	931f      	str	r3, [sp, #124]	; 0x7c
      format++;
   15924:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15926:	3301      	adds	r3, #1
   15928:	930a      	str	r3, [sp, #40]	; 0x28
      if (_is_digit(*format)) {
   1592a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1592c:	781b      	ldrb	r3, [r3, #0]
   1592e:	4618      	mov	r0, r3
   15930:	f7ff faaa 	bl	14e88 <_is_digit(char)>
   15934:	4603      	mov	r3, r0
   15936:	2b00      	cmp	r3, #0
   15938:	d005      	beq.n	15946 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ae>
        precision = _atoi(&format);
   1593a:	ab0a      	add	r3, sp, #40	; 0x28
   1593c:	4618      	mov	r0, r3
   1593e:	f7ff fac5 	bl	14ecc <_atoi(char const**)>
   15942:	901d      	str	r0, [sp, #116]	; 0x74
   15944:	e00f      	b.n	15966 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      }
      else if (*format == '*') {
   15946:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15948:	781b      	ldrb	r3, [r3, #0]
   1594a:	2b2a      	cmp	r3, #42	; 0x2a
   1594c:	d10b      	bne.n	15966 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
        const int prec = (int)va_arg(va, int);
   1594e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15950:	1d1a      	adds	r2, r3, #4
   15952:	9224      	str	r2, [sp, #144]	; 0x90
   15954:	681b      	ldr	r3, [r3, #0]
   15956:	9315      	str	r3, [sp, #84]	; 0x54
        precision = prec > 0 ? (unsigned int)prec : 0U;
   15958:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1595a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   1595e:	931d      	str	r3, [sp, #116]	; 0x74
        format++;
   15960:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15962:	3301      	adds	r3, #1
   15964:	930a      	str	r3, [sp, #40]	; 0x28
      }
    }

    // evaluate length field
    switch (*format) {
   15966:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15968:	781b      	ldrb	r3, [r3, #0]
   1596a:	3b68      	subs	r3, #104	; 0x68
   1596c:	2b12      	cmp	r3, #18
   1596e:	d867      	bhi.n	15a40 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
   15970:	a201      	add	r2, pc, #4	; (adr r2, 15978 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1e0>)
   15972:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   15976:	bf00      	nop
   15978:	000159eb 	.word	0x000159eb
   1597c:	00015a41 	.word	0x00015a41
   15980:	00015a21 	.word	0x00015a21
   15984:	00015a41 	.word	0x00015a41
   15988:	000159c5 	.word	0x000159c5
   1598c:	00015a41 	.word	0x00015a41
   15990:	00015a41 	.word	0x00015a41
   15994:	00015a41 	.word	0x00015a41
   15998:	00015a41 	.word	0x00015a41
   1599c:	00015a41 	.word	0x00015a41
   159a0:	00015a41 	.word	0x00015a41
   159a4:	00015a41 	.word	0x00015a41
   159a8:	00015a11 	.word	0x00015a11
   159ac:	00015a41 	.word	0x00015a41
   159b0:	00015a41 	.word	0x00015a41
   159b4:	00015a41 	.word	0x00015a41
   159b8:	00015a41 	.word	0x00015a41
   159bc:	00015a41 	.word	0x00015a41
   159c0:	00015a31 	.word	0x00015a31
      case 'l' :
        flags |= FLAGS_LONG;
   159c4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159c6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   159ca:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   159cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159ce:	3301      	adds	r3, #1
   159d0:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'l') {
   159d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159d4:	781b      	ldrb	r3, [r3, #0]
   159d6:	2b6c      	cmp	r3, #108	; 0x6c
   159d8:	d134      	bne.n	15a44 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
          flags |= FLAGS_LONG_LONG;
   159da:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159dc:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   159e0:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   159e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159e4:	3301      	adds	r3, #1
   159e6:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   159e8:	e02c      	b.n	15a44 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
      case 'h' :
        flags |= FLAGS_SHORT;
   159ea:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   159f0:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   159f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159f4:	3301      	adds	r3, #1
   159f6:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'h') {
   159f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159fa:	781b      	ldrb	r3, [r3, #0]
   159fc:	2b68      	cmp	r3, #104	; 0x68
   159fe:	d127      	bne.n	15a50 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
          flags |= FLAGS_CHAR;
   15a00:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15a02:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   15a06:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   15a08:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a0a:	3301      	adds	r3, #1
   15a0c:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   15a0e:	e01f      	b.n	15a50 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   15a10:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15a12:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   15a16:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   15a18:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a1a:	3301      	adds	r3, #1
   15a1c:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15a1e:	e018      	b.n	15a52 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   15a20:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15a22:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   15a26:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   15a28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a2a:	3301      	adds	r3, #1
   15a2c:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15a2e:	e010      	b.n	15a52 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   15a30:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15a32:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   15a36:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   15a38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a3a:	3301      	adds	r3, #1
   15a3c:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15a3e:	e008      	b.n	15a52 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      default :
        break;
   15a40:	bf00      	nop
   15a42:	e006      	b.n	15a52 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
        break;
   15a44:	bf00      	nop
   15a46:	e004      	b.n	15a52 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
   15a48:	00015799 	.word	0x00015799
   15a4c:	00014dd1 	.word	0x00014dd1
        break;
   15a50:	bf00      	nop
    }

    // evaluate specifier
    switch (*format) {
   15a52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a54:	781b      	ldrb	r3, [r3, #0]
   15a56:	3b25      	subs	r3, #37	; 0x25
   15a58:	2b53      	cmp	r3, #83	; 0x53
   15a5a:	f200 82ee 	bhi.w	1603a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8a2>
   15a5e:	a201      	add	r2, pc, #4	; (adr r2, 15a64 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2cc>)
   15a60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   15a64:	00016023 	.word	0x00016023
   15a68:	0001603b 	.word	0x0001603b
   15a6c:	0001603b 	.word	0x0001603b
   15a70:	0001603b 	.word	0x0001603b
   15a74:	0001603b 	.word	0x0001603b
   15a78:	0001603b 	.word	0x0001603b
   15a7c:	0001603b 	.word	0x0001603b
   15a80:	0001603b 	.word	0x0001603b
   15a84:	0001603b 	.word	0x0001603b
   15a88:	0001603b 	.word	0x0001603b
   15a8c:	0001603b 	.word	0x0001603b
   15a90:	0001603b 	.word	0x0001603b
   15a94:	0001603b 	.word	0x0001603b
   15a98:	0001603b 	.word	0x0001603b
   15a9c:	0001603b 	.word	0x0001603b
   15aa0:	0001603b 	.word	0x0001603b
   15aa4:	0001603b 	.word	0x0001603b
   15aa8:	0001603b 	.word	0x0001603b
   15aac:	0001603b 	.word	0x0001603b
   15ab0:	0001603b 	.word	0x0001603b
   15ab4:	0001603b 	.word	0x0001603b
   15ab8:	0001603b 	.word	0x0001603b
   15abc:	0001603b 	.word	0x0001603b
   15ac0:	0001603b 	.word	0x0001603b
   15ac4:	0001603b 	.word	0x0001603b
   15ac8:	0001603b 	.word	0x0001603b
   15acc:	0001603b 	.word	0x0001603b
   15ad0:	0001603b 	.word	0x0001603b
   15ad4:	0001603b 	.word	0x0001603b
   15ad8:	0001603b 	.word	0x0001603b
   15adc:	0001603b 	.word	0x0001603b
   15ae0:	0001603b 	.word	0x0001603b
   15ae4:	0001603b 	.word	0x0001603b
   15ae8:	00015e41 	.word	0x00015e41
   15aec:	0001603b 	.word	0x0001603b
   15af0:	0001603b 	.word	0x0001603b
   15af4:	0001603b 	.word	0x0001603b
   15af8:	0001603b 	.word	0x0001603b
   15afc:	0001603b 	.word	0x0001603b
   15b00:	0001603b 	.word	0x0001603b
   15b04:	0001603b 	.word	0x0001603b
   15b08:	0001603b 	.word	0x0001603b
   15b0c:	0001603b 	.word	0x0001603b
   15b10:	0001603b 	.word	0x0001603b
   15b14:	0001603b 	.word	0x0001603b
   15b18:	0001603b 	.word	0x0001603b
   15b1c:	0001603b 	.word	0x0001603b
   15b20:	0001603b 	.word	0x0001603b
   15b24:	0001603b 	.word	0x0001603b
   15b28:	0001603b 	.word	0x0001603b
   15b2c:	0001603b 	.word	0x0001603b
   15b30:	00015bb5 	.word	0x00015bb5
   15b34:	0001603b 	.word	0x0001603b
   15b38:	0001603b 	.word	0x0001603b
   15b3c:	0001603b 	.word	0x0001603b
   15b40:	0001603b 	.word	0x0001603b
   15b44:	0001603b 	.word	0x0001603b
   15b48:	0001603b 	.word	0x0001603b
   15b4c:	0001603b 	.word	0x0001603b
   15b50:	0001603b 	.word	0x0001603b
   15b54:	0001603b 	.word	0x0001603b
   15b58:	00015bb5 	.word	0x00015bb5
   15b5c:	00015e7d 	.word	0x00015e7d
   15b60:	00015bb5 	.word	0x00015bb5
   15b64:	0001603b 	.word	0x0001603b
   15b68:	00015e41 	.word	0x00015e41
   15b6c:	0001603b 	.word	0x0001603b
   15b70:	0001603b 	.word	0x0001603b
   15b74:	00015bb5 	.word	0x00015bb5
   15b78:	0001603b 	.word	0x0001603b
   15b7c:	0001603b 	.word	0x0001603b
   15b80:	0001603b 	.word	0x0001603b
   15b84:	0001603b 	.word	0x0001603b
   15b88:	0001603b 	.word	0x0001603b
   15b8c:	00015bb5 	.word	0x00015bb5
   15b90:	00015fdb 	.word	0x00015fdb
   15b94:	0001603b 	.word	0x0001603b
   15b98:	0001603b 	.word	0x0001603b
   15b9c:	00015f05 	.word	0x00015f05
   15ba0:	0001603b 	.word	0x0001603b
   15ba4:	00015bb5 	.word	0x00015bb5
   15ba8:	0001603b 	.word	0x0001603b
   15bac:	0001603b 	.word	0x0001603b
   15bb0:	00015bb5 	.word	0x00015bb5
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
   15bb4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15bb6:	781b      	ldrb	r3, [r3, #0]
   15bb8:	2b78      	cmp	r3, #120	; 0x78
   15bba:	d003      	beq.n	15bc4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x42c>
   15bbc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15bbe:	781b      	ldrb	r3, [r3, #0]
   15bc0:	2b58      	cmp	r3, #88	; 0x58
   15bc2:	d102      	bne.n	15bca <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x432>
          base = 16U;
   15bc4:	2310      	movs	r3, #16
   15bc6:	931a      	str	r3, [sp, #104]	; 0x68
   15bc8:	e013      	b.n	15bf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'o') {
   15bca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15bcc:	781b      	ldrb	r3, [r3, #0]
   15bce:	2b6f      	cmp	r3, #111	; 0x6f
   15bd0:	d102      	bne.n	15bd8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x440>
          base =  8U;
   15bd2:	2308      	movs	r3, #8
   15bd4:	931a      	str	r3, [sp, #104]	; 0x68
   15bd6:	e00c      	b.n	15bf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'b') {
   15bd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15bda:	781b      	ldrb	r3, [r3, #0]
   15bdc:	2b62      	cmp	r3, #98	; 0x62
   15bde:	d102      	bne.n	15be6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44e>
          base =  2U;
   15be0:	2302      	movs	r3, #2
   15be2:	931a      	str	r3, [sp, #104]	; 0x68
   15be4:	e005      	b.n	15bf2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else {
          base = 10U;
   15be6:	230a      	movs	r3, #10
   15be8:	931a      	str	r3, [sp, #104]	; 0x68
          flags &= ~FLAGS_HASH;   // no hash for dec format
   15bea:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15bec:	f023 0310 	bic.w	r3, r3, #16
   15bf0:	931f      	str	r3, [sp, #124]	; 0x7c
        }
        // uppercase
        if (*format == 'X') {
   15bf2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15bf4:	781b      	ldrb	r3, [r3, #0]
   15bf6:	2b58      	cmp	r3, #88	; 0x58
   15bf8:	d103      	bne.n	15c02 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x46a>
          flags |= FLAGS_UPPERCASE;
   15bfa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15bfc:	f043 0320 	orr.w	r3, r3, #32
   15c00:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
   15c02:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15c04:	781b      	ldrb	r3, [r3, #0]
   15c06:	2b69      	cmp	r3, #105	; 0x69
   15c08:	d007      	beq.n	15c1a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
   15c0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15c0c:	781b      	ldrb	r3, [r3, #0]
   15c0e:	2b64      	cmp	r3, #100	; 0x64
   15c10:	d003      	beq.n	15c1a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   15c12:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15c14:	f023 030c 	bic.w	r3, r3, #12
   15c18:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
   15c1a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15c1c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   15c20:	2b00      	cmp	r3, #0
   15c22:	d003      	beq.n	15c2c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x494>
          flags &= ~FLAGS_ZEROPAD;
   15c24:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15c26:	f023 0301 	bic.w	r3, r3, #1
   15c2a:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
   15c2c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15c2e:	781b      	ldrb	r3, [r3, #0]
   15c30:	2b69      	cmp	r3, #105	; 0x69
   15c32:	d004      	beq.n	15c3e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4a6>
   15c34:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15c36:	781b      	ldrb	r3, [r3, #0]
   15c38:	2b64      	cmp	r3, #100	; 0x64
   15c3a:	f040 808d 	bne.w	15d58 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5c0>
          // signed
          if (flags & FLAGS_LONG_LONG) {
   15c3e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15c40:	f403 7300 	and.w	r3, r3, #512	; 0x200
   15c44:	2b00      	cmp	r3, #0
   15c46:	d02e      	beq.n	15ca6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x50e>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
   15c48:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15c4a:	3307      	adds	r3, #7
   15c4c:	f023 0307 	bic.w	r3, r3, #7
   15c50:	f103 0208 	add.w	r2, r3, #8
   15c54:	9224      	str	r2, [sp, #144]	; 0x90
   15c56:	e9d3 3400 	ldrd	r3, r4, [r3]
   15c5a:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   15c5e:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   15c62:	2b00      	cmp	r3, #0
   15c64:	f174 0200 	sbcs.w	r2, r4, #0
   15c68:	da02      	bge.n	15c70 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4d8>
   15c6a:	425b      	negs	r3, r3
   15c6c:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
   15c70:	4619      	mov	r1, r3
   15c72:	4622      	mov	r2, r4
   15c74:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   15c76:	0fdb      	lsrs	r3, r3, #31
   15c78:	b2d8      	uxtb	r0, r3
   15c7a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   15c7c:	f04f 0400 	mov.w	r4, #0
   15c80:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
   15c82:	9508      	str	r5, [sp, #32]
   15c84:	9d1e      	ldr	r5, [sp, #120]	; 0x78
   15c86:	9507      	str	r5, [sp, #28]
   15c88:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   15c8a:	9506      	str	r5, [sp, #24]
   15c8c:	e9cd 3404 	strd	r3, r4, [sp, #16]
   15c90:	9002      	str	r0, [sp, #8]
   15c92:	e9cd 1200 	strd	r1, r2, [sp]
   15c96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15c98:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15c9a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15c9c:	980d      	ldr	r0, [sp, #52]	; 0x34
   15c9e:	f7ff fae5 	bl	1526c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   15ca2:	901b      	str	r0, [sp, #108]	; 0x6c
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
   15ca4:	e0c8      	b.n	15e38 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          else if (flags & FLAGS_LONG) {
   15ca6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15ca8:	f403 7380 	and.w	r3, r3, #256	; 0x100
   15cac:	2b00      	cmp	r3, #0
   15cae:	d01e      	beq.n	15cee <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x556>
            const long value = va_arg(va, long);
   15cb0:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15cb2:	1d1a      	adds	r2, r3, #4
   15cb4:	9224      	str	r2, [sp, #144]	; 0x90
   15cb6:	681b      	ldr	r3, [r3, #0]
   15cb8:	9311      	str	r3, [sp, #68]	; 0x44
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   15cba:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15cbc:	2b00      	cmp	r3, #0
   15cbe:	bfb8      	it	lt
   15cc0:	425b      	neglt	r3, r3
   15cc2:	4619      	mov	r1, r3
   15cc4:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15cc6:	0fdb      	lsrs	r3, r3, #31
   15cc8:	b2db      	uxtb	r3, r3
   15cca:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15ccc:	9205      	str	r2, [sp, #20]
   15cce:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15cd0:	9204      	str	r2, [sp, #16]
   15cd2:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   15cd4:	9203      	str	r2, [sp, #12]
   15cd6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15cd8:	9202      	str	r2, [sp, #8]
   15cda:	9301      	str	r3, [sp, #4]
   15cdc:	9100      	str	r1, [sp, #0]
   15cde:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15ce0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15ce2:	990c      	ldr	r1, [sp, #48]	; 0x30
   15ce4:	980d      	ldr	r0, [sp, #52]	; 0x34
   15ce6:	f7ff fa4f 	bl	15188 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15cea:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   15cec:	e0a4      	b.n	15e38 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   15cee:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15cf0:	f003 0340 	and.w	r3, r3, #64	; 0x40
   15cf4:	2b00      	cmp	r3, #0
   15cf6:	d005      	beq.n	15d04 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x56c>
   15cf8:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15cfa:	1d1a      	adds	r2, r3, #4
   15cfc:	9224      	str	r2, [sp, #144]	; 0x90
   15cfe:	681b      	ldr	r3, [r3, #0]
   15d00:	b2db      	uxtb	r3, r3
   15d02:	e00e      	b.n	15d22 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   15d04:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15d06:	f003 0380 	and.w	r3, r3, #128	; 0x80
   15d0a:	2b00      	cmp	r3, #0
   15d0c:	d005      	beq.n	15d1a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x582>
   15d0e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15d10:	1d1a      	adds	r2, r3, #4
   15d12:	9224      	str	r2, [sp, #144]	; 0x90
   15d14:	681b      	ldr	r3, [r3, #0]
   15d16:	b21b      	sxth	r3, r3
   15d18:	e003      	b.n	15d22 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   15d1a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15d1c:	1d1a      	adds	r2, r3, #4
   15d1e:	9224      	str	r2, [sp, #144]	; 0x90
   15d20:	681b      	ldr	r3, [r3, #0]
   15d22:	9312      	str	r3, [sp, #72]	; 0x48
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   15d24:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15d26:	2b00      	cmp	r3, #0
   15d28:	bfb8      	it	lt
   15d2a:	425b      	neglt	r3, r3
   15d2c:	4619      	mov	r1, r3
   15d2e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15d30:	0fdb      	lsrs	r3, r3, #31
   15d32:	b2db      	uxtb	r3, r3
   15d34:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15d36:	9205      	str	r2, [sp, #20]
   15d38:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15d3a:	9204      	str	r2, [sp, #16]
   15d3c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   15d3e:	9203      	str	r2, [sp, #12]
   15d40:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15d42:	9202      	str	r2, [sp, #8]
   15d44:	9301      	str	r3, [sp, #4]
   15d46:	9100      	str	r1, [sp, #0]
   15d48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15d4a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15d4c:	990c      	ldr	r1, [sp, #48]	; 0x30
   15d4e:	980d      	ldr	r0, [sp, #52]	; 0x34
   15d50:	f7ff fa1a 	bl	15188 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15d54:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   15d56:	e06f      	b.n	15e38 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
   15d58:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15d5a:	f403 7300 	and.w	r3, r3, #512	; 0x200
   15d5e:	2b00      	cmp	r3, #0
   15d60:	d020      	beq.n	15da4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x60c>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   15d62:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15d64:	3307      	adds	r3, #7
   15d66:	f023 0307 	bic.w	r3, r3, #7
   15d6a:	f103 0208 	add.w	r2, r3, #8
   15d6e:	9224      	str	r2, [sp, #144]	; 0x90
   15d70:	e9d3 3400 	ldrd	r3, r4, [r3]
   15d74:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15d76:	4611      	mov	r1, r2
   15d78:	f04f 0200 	mov.w	r2, #0
   15d7c:	981f      	ldr	r0, [sp, #124]	; 0x7c
   15d7e:	9008      	str	r0, [sp, #32]
   15d80:	981e      	ldr	r0, [sp, #120]	; 0x78
   15d82:	9007      	str	r0, [sp, #28]
   15d84:	981d      	ldr	r0, [sp, #116]	; 0x74
   15d86:	9006      	str	r0, [sp, #24]
   15d88:	e9cd 1204 	strd	r1, r2, [sp, #16]
   15d8c:	2200      	movs	r2, #0
   15d8e:	9202      	str	r2, [sp, #8]
   15d90:	e9cd 3400 	strd	r3, r4, [sp]
   15d94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15d96:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15d98:	990c      	ldr	r1, [sp, #48]	; 0x30
   15d9a:	980d      	ldr	r0, [sp, #52]	; 0x34
   15d9c:	f7ff fa66 	bl	1526c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   15da0:	901b      	str	r0, [sp, #108]	; 0x6c
   15da2:	e049      	b.n	15e38 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
#endif
          }
          else if (flags & FLAGS_LONG) {
   15da4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15da6:	f403 7380 	and.w	r3, r3, #256	; 0x100
   15daa:	2b00      	cmp	r3, #0
   15dac:	d016      	beq.n	15ddc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x644>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   15dae:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15db0:	1d1a      	adds	r2, r3, #4
   15db2:	9224      	str	r2, [sp, #144]	; 0x90
   15db4:	681b      	ldr	r3, [r3, #0]
   15db6:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15db8:	9205      	str	r2, [sp, #20]
   15dba:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15dbc:	9204      	str	r2, [sp, #16]
   15dbe:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   15dc0:	9203      	str	r2, [sp, #12]
   15dc2:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15dc4:	9202      	str	r2, [sp, #8]
   15dc6:	2200      	movs	r2, #0
   15dc8:	9201      	str	r2, [sp, #4]
   15dca:	9300      	str	r3, [sp, #0]
   15dcc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15dce:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15dd0:	990c      	ldr	r1, [sp, #48]	; 0x30
   15dd2:	980d      	ldr	r0, [sp, #52]	; 0x34
   15dd4:	f7ff f9d8 	bl	15188 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15dd8:	901b      	str	r0, [sp, #108]	; 0x6c
   15dda:	e02d      	b.n	15e38 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   15ddc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15dde:	f003 0340 	and.w	r3, r3, #64	; 0x40
   15de2:	2b00      	cmp	r3, #0
   15de4:	d005      	beq.n	15df2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x65a>
   15de6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15de8:	1d1a      	adds	r2, r3, #4
   15dea:	9224      	str	r2, [sp, #144]	; 0x90
   15dec:	681b      	ldr	r3, [r3, #0]
   15dee:	b2db      	uxtb	r3, r3
   15df0:	e00e      	b.n	15e10 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   15df2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15df4:	f003 0380 	and.w	r3, r3, #128	; 0x80
   15df8:	2b00      	cmp	r3, #0
   15dfa:	d005      	beq.n	15e08 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x670>
   15dfc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15dfe:	1d1a      	adds	r2, r3, #4
   15e00:	9224      	str	r2, [sp, #144]	; 0x90
   15e02:	681b      	ldr	r3, [r3, #0]
   15e04:	b29b      	uxth	r3, r3
   15e06:	e003      	b.n	15e10 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   15e08:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15e0a:	1d1a      	adds	r2, r3, #4
   15e0c:	9224      	str	r2, [sp, #144]	; 0x90
   15e0e:	681b      	ldr	r3, [r3, #0]
   15e10:	9313      	str	r3, [sp, #76]	; 0x4c
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   15e12:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15e14:	9305      	str	r3, [sp, #20]
   15e16:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15e18:	9304      	str	r3, [sp, #16]
   15e1a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15e1c:	9303      	str	r3, [sp, #12]
   15e1e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   15e20:	9302      	str	r3, [sp, #8]
   15e22:	2300      	movs	r3, #0
   15e24:	9301      	str	r3, [sp, #4]
   15e26:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   15e28:	9300      	str	r3, [sp, #0]
   15e2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15e2c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15e2e:	990c      	ldr	r1, [sp, #48]	; 0x30
   15e30:	980d      	ldr	r0, [sp, #52]	; 0x34
   15e32:	f7ff f9a9 	bl	15188 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15e36:	901b      	str	r0, [sp, #108]	; 0x6c
          }
        }
        format++;
   15e38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15e3a:	3301      	adds	r3, #1
   15e3c:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15e3e:	e109      	b.n	16054 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   15e40:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15e42:	3307      	adds	r3, #7
   15e44:	f023 0307 	bic.w	r3, r3, #7
   15e48:	f103 0208 	add.w	r2, r3, #8
   15e4c:	9224      	str	r2, [sp, #144]	; 0x90
   15e4e:	ed93 7b00 	vldr	d7, [r3]
   15e52:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15e54:	9302      	str	r3, [sp, #8]
   15e56:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15e58:	9301      	str	r3, [sp, #4]
   15e5a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15e5c:	9300      	str	r3, [sp, #0]
   15e5e:	eeb0 0a47 	vmov.f32	s0, s14
   15e62:	eef0 0a67 	vmov.f32	s1, s15
   15e66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15e68:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15e6a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15e6c:	980d      	ldr	r0, [sp, #52]	; 0x34
   15e6e:	f7ff fa77 	bl	15360 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>
   15e72:	901b      	str	r0, [sp, #108]	; 0x6c
        format++;
   15e74:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15e76:	3301      	adds	r3, #1
   15e78:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15e7a:	e0eb      	b.n	16054 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
   15e7c:	2301      	movs	r3, #1
   15e7e:	9319      	str	r3, [sp, #100]	; 0x64
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
   15e80:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15e82:	f003 0302 	and.w	r3, r3, #2
   15e86:	2b00      	cmp	r3, #0
   15e88:	d113      	bne.n	15eb2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
          while (l++ < width) {
   15e8a:	9b19      	ldr	r3, [sp, #100]	; 0x64
   15e8c:	1c5a      	adds	r2, r3, #1
   15e8e:	9219      	str	r2, [sp, #100]	; 0x64
   15e90:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15e92:	429a      	cmp	r2, r3
   15e94:	bf8c      	ite	hi
   15e96:	2301      	movhi	r3, #1
   15e98:	2300      	movls	r3, #0
   15e9a:	b2db      	uxtb	r3, r3
   15e9c:	2b00      	cmp	r3, #0
   15e9e:	d008      	beq.n	15eb2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
            out(' ', buffer, idx++, maxlen);
   15ea0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15ea2:	1c53      	adds	r3, r2, #1
   15ea4:	931b      	str	r3, [sp, #108]	; 0x6c
   15ea6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15ea8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15eaa:	990c      	ldr	r1, [sp, #48]	; 0x30
   15eac:	2020      	movs	r0, #32
   15eae:	47a0      	blx	r4
          while (l++ < width) {
   15eb0:	e7eb      	b.n	15e8a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6f2>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
   15eb2:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15eb4:	1d1a      	adds	r2, r3, #4
   15eb6:	9224      	str	r2, [sp, #144]	; 0x90
   15eb8:	681b      	ldr	r3, [r3, #0]
   15eba:	b2d8      	uxtb	r0, r3
   15ebc:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15ebe:	1c53      	adds	r3, r2, #1
   15ec0:	931b      	str	r3, [sp, #108]	; 0x6c
   15ec2:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15ec4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15ec6:	990c      	ldr	r1, [sp, #48]	; 0x30
   15ec8:	47a0      	blx	r4
        // post padding
        if (flags & FLAGS_LEFT) {
   15eca:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15ecc:	f003 0302 	and.w	r3, r3, #2
   15ed0:	2b00      	cmp	r3, #0
   15ed2:	d013      	beq.n	15efc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
          while (l++ < width) {
   15ed4:	9b19      	ldr	r3, [sp, #100]	; 0x64
   15ed6:	1c5a      	adds	r2, r3, #1
   15ed8:	9219      	str	r2, [sp, #100]	; 0x64
   15eda:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15edc:	429a      	cmp	r2, r3
   15ede:	bf8c      	ite	hi
   15ee0:	2301      	movhi	r3, #1
   15ee2:	2300      	movls	r3, #0
   15ee4:	b2db      	uxtb	r3, r3
   15ee6:	2b00      	cmp	r3, #0
   15ee8:	d008      	beq.n	15efc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
            out(' ', buffer, idx++, maxlen);
   15eea:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15eec:	1c53      	adds	r3, r2, #1
   15eee:	931b      	str	r3, [sp, #108]	; 0x6c
   15ef0:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15ef2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15ef4:	990c      	ldr	r1, [sp, #48]	; 0x30
   15ef6:	2020      	movs	r0, #32
   15ef8:	47a0      	blx	r4
          while (l++ < width) {
   15efa:	e7eb      	b.n	15ed4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x73c>
          }
        }
        format++;
   15efc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15efe:	3301      	adds	r3, #1
   15f00:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15f02:	e0a7      	b.n	16054 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 's' : {
        char* p = va_arg(va, char*);
   15f04:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15f06:	1d1a      	adds	r2, r3, #4
   15f08:	9224      	str	r2, [sp, #144]	; 0x90
   15f0a:	681b      	ldr	r3, [r3, #0]
   15f0c:	9318      	str	r3, [sp, #96]	; 0x60
        unsigned int l = _strlen(p);
   15f0e:	9818      	ldr	r0, [sp, #96]	; 0x60
   15f10:	f7fe ff98 	bl	14e44 <_strlen(char const*)>
   15f14:	9017      	str	r0, [sp, #92]	; 0x5c
        // pre padding
        if (flags & FLAGS_PRECISION) {
   15f16:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15f18:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   15f1c:	2b00      	cmp	r3, #0
   15f1e:	d007      	beq.n	15f30 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x798>
          l = (l < precision ? l : precision);
   15f20:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   15f22:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15f24:	429a      	cmp	r2, r3
   15f26:	d201      	bcs.n	15f2c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x794>
   15f28:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   15f2a:	e000      	b.n	15f2e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x796>
   15f2c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15f2e:	9317      	str	r3, [sp, #92]	; 0x5c
        }
        if (!(flags & FLAGS_LEFT)) {
   15f30:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15f32:	f003 0302 	and.w	r3, r3, #2
   15f36:	2b00      	cmp	r3, #0
   15f38:	d113      	bne.n	15f62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
          while (l++ < width) {
   15f3a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   15f3c:	1c5a      	adds	r2, r3, #1
   15f3e:	9217      	str	r2, [sp, #92]	; 0x5c
   15f40:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15f42:	429a      	cmp	r2, r3
   15f44:	bf8c      	ite	hi
   15f46:	2301      	movhi	r3, #1
   15f48:	2300      	movls	r3, #0
   15f4a:	b2db      	uxtb	r3, r3
   15f4c:	2b00      	cmp	r3, #0
   15f4e:	d008      	beq.n	15f62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
            out(' ', buffer, idx++, maxlen);
   15f50:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15f52:	1c53      	adds	r3, r2, #1
   15f54:	931b      	str	r3, [sp, #108]	; 0x6c
   15f56:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15f58:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15f5a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15f5c:	2020      	movs	r0, #32
   15f5e:	47a0      	blx	r4
          while (l++ < width) {
   15f60:	e7eb      	b.n	15f3a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7a2>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   15f62:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15f64:	781b      	ldrb	r3, [r3, #0]
   15f66:	2b00      	cmp	r3, #0
   15f68:	d00b      	beq.n	15f82 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   15f6a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15f6c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   15f70:	2b00      	cmp	r3, #0
   15f72:	d004      	beq.n	15f7e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7e6>
   15f74:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15f76:	1e5a      	subs	r2, r3, #1
   15f78:	921d      	str	r2, [sp, #116]	; 0x74
   15f7a:	2b00      	cmp	r3, #0
   15f7c:	d001      	beq.n	15f82 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   15f7e:	2301      	movs	r3, #1
   15f80:	e000      	b.n	15f84 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ec>
   15f82:	2300      	movs	r3, #0
   15f84:	2b00      	cmp	r3, #0
   15f86:	d00b      	beq.n	15fa0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x808>
          out(*(p++), buffer, idx++, maxlen);
   15f88:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15f8a:	1c5a      	adds	r2, r3, #1
   15f8c:	9218      	str	r2, [sp, #96]	; 0x60
   15f8e:	7818      	ldrb	r0, [r3, #0]
   15f90:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15f92:	1c53      	adds	r3, r2, #1
   15f94:	931b      	str	r3, [sp, #108]	; 0x6c
   15f96:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15f98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15f9a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15f9c:	47a0      	blx	r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   15f9e:	e7e0      	b.n	15f62 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
   15fa0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15fa2:	f003 0302 	and.w	r3, r3, #2
   15fa6:	2b00      	cmp	r3, #0
   15fa8:	d013      	beq.n	15fd2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
          while (l++ < width) {
   15faa:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   15fac:	1c5a      	adds	r2, r3, #1
   15fae:	9217      	str	r2, [sp, #92]	; 0x5c
   15fb0:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15fb2:	429a      	cmp	r2, r3
   15fb4:	bf8c      	ite	hi
   15fb6:	2301      	movhi	r3, #1
   15fb8:	2300      	movls	r3, #0
   15fba:	b2db      	uxtb	r3, r3
   15fbc:	2b00      	cmp	r3, #0
   15fbe:	d008      	beq.n	15fd2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
            out(' ', buffer, idx++, maxlen);
   15fc0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15fc2:	1c53      	adds	r3, r2, #1
   15fc4:	931b      	str	r3, [sp, #108]	; 0x6c
   15fc6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15fc8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15fca:	990c      	ldr	r1, [sp, #48]	; 0x30
   15fcc:	2020      	movs	r0, #32
   15fce:	47a0      	blx	r4
          while (l++ < width) {
   15fd0:	e7eb      	b.n	15faa <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x812>
          }
        }
        format++;
   15fd2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15fd4:	3301      	adds	r3, #1
   15fd6:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15fd8:	e03c      	b.n	16054 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
   15fda:	2308      	movs	r3, #8
   15fdc:	931e      	str	r3, [sp, #120]	; 0x78
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   15fde:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15fe0:	f043 0321 	orr.w	r3, r3, #33	; 0x21
   15fe4:	931f      	str	r3, [sp, #124]	; 0x7c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   15fe6:	2300      	movs	r3, #0
   15fe8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   15fec:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15fee:	1d1a      	adds	r2, r3, #4
   15ff0:	9224      	str	r2, [sp, #144]	; 0x90
   15ff2:	681b      	ldr	r3, [r3, #0]
   15ff4:	461a      	mov	r2, r3
   15ff6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15ff8:	9305      	str	r3, [sp, #20]
   15ffa:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15ffc:	9304      	str	r3, [sp, #16]
   15ffe:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   16000:	9303      	str	r3, [sp, #12]
   16002:	2310      	movs	r3, #16
   16004:	9302      	str	r3, [sp, #8]
   16006:	2300      	movs	r3, #0
   16008:	9301      	str	r3, [sp, #4]
   1600a:	9200      	str	r2, [sp, #0]
   1600c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1600e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   16010:	990c      	ldr	r1, [sp, #48]	; 0x30
   16012:	980d      	ldr	r0, [sp, #52]	; 0x34
   16014:	f7ff f8b8 	bl	15188 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   16018:	901b      	str	r0, [sp, #108]	; 0x6c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
   1601a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1601c:	3301      	adds	r3, #1
   1601e:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   16020:	e018      	b.n	16054 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
   16022:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   16024:	1c53      	adds	r3, r2, #1
   16026:	931b      	str	r3, [sp, #108]	; 0x6c
   16028:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1602a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1602c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1602e:	2025      	movs	r0, #37	; 0x25
   16030:	47a0      	blx	r4
        format++;
   16032:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16034:	3301      	adds	r3, #1
   16036:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   16038:	e00c      	b.n	16054 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>

      default :
        out(*format, buffer, idx++, maxlen);
   1603a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1603c:	7818      	ldrb	r0, [r3, #0]
   1603e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   16040:	1c53      	adds	r3, r2, #1
   16042:	931b      	str	r3, [sp, #108]	; 0x6c
   16044:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   16046:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16048:	990c      	ldr	r1, [sp, #48]	; 0x30
   1604a:	47a0      	blx	r4
        format++;
   1604c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1604e:	3301      	adds	r3, #1
   16050:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   16052:	bf00      	nop
  while (*format)
   16054:	f7ff bbb3 	b.w	157be <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   16058:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1605a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1605c:	429a      	cmp	r2, r3
   1605e:	d302      	bcc.n	16066 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ce>
   16060:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16062:	1e5a      	subs	r2, r3, #1
   16064:	e000      	b.n	16068 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8d0>
   16066:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   16068:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   1606a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1606c:	990c      	ldr	r1, [sp, #48]	; 0x30
   1606e:	2000      	movs	r0, #0
   16070:	47a0      	blx	r4

  // return written chars without terminating \0
  return (int)idx;
   16072:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   16074:	4633      	mov	r3, r6
   16076:	4619      	mov	r1, r3
   16078:	4803      	ldr	r0, [pc, #12]	; (16088 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8f0>)
   1607a:	f7fd fa7d 	bl	13578 <__cyg_profile_func_exit>
   1607e:	4623      	mov	r3, r4
}
   16080:	4618      	mov	r0, r3
   16082:	b020      	add	sp, #128	; 0x80
   16084:	bd70      	pop	{r4, r5, r6, pc}
   16086:	bf00      	nop
   16088:	00015799 	.word	0x00015799

0001608c <printf>:

///////////////////////////////////////////////////////////////////////////////


int printf(const char* format, ...)
{
   1608c:	b40f      	push	{r0, r1, r2, r3}
   1608e:	b530      	push	{r4, r5, lr}
   16090:	b087      	sub	sp, #28
   16092:	4675      	mov	r5, lr
   16094:	462b      	mov	r3, r5
   16096:	4619      	mov	r1, r3
   16098:	480d      	ldr	r0, [pc, #52]	; (160d0 <printf+0x44>)
   1609a:	f7fd fa59 	bl	13550 <__cyg_profile_func_enter>
  va_list va;
  va_start(va, format);
   1609e:	ab0b      	add	r3, sp, #44	; 0x2c
   160a0:	9304      	str	r3, [sp, #16]
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   160a2:	a903      	add	r1, sp, #12
   160a4:	9b04      	ldr	r3, [sp, #16]
   160a6:	9300      	str	r3, [sp, #0]
   160a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   160aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   160ae:	4809      	ldr	r0, [pc, #36]	; (160d4 <printf+0x48>)
   160b0:	f7ff fb72 	bl	15798 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   160b4:	9005      	str	r0, [sp, #20]
  va_end(va);
  return ret;
   160b6:	9c05      	ldr	r4, [sp, #20]
   160b8:	462b      	mov	r3, r5
   160ba:	4619      	mov	r1, r3
   160bc:	4804      	ldr	r0, [pc, #16]	; (160d0 <printf+0x44>)
   160be:	f7fd fa5b 	bl	13578 <__cyg_profile_func_exit>
   160c2:	4623      	mov	r3, r4
}
   160c4:	4618      	mov	r0, r3
   160c6:	b007      	add	sp, #28
   160c8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   160cc:	b004      	add	sp, #16
   160ce:	4770      	bx	lr
   160d0:	0001608d 	.word	0x0001608d
   160d4:	00014e01 	.word	0x00014e01

000160d8 <PinInterface::PinInterface()>:
class PinInterface
   160d8:	b530      	push	{r4, r5, lr}
   160da:	b083      	sub	sp, #12
   160dc:	4675      	mov	r5, lr
   160de:	9001      	str	r0, [sp, #4]
   160e0:	462b      	mov	r3, r5
   160e2:	4619      	mov	r1, r3
   160e4:	4807      	ldr	r0, [pc, #28]	; (16104 <PinInterface::PinInterface()+0x2c>)
   160e6:	f7fd fa33 	bl	13550 <__cyg_profile_func_enter>
   160ea:	4a07      	ldr	r2, [pc, #28]	; (16108 <PinInterface::PinInterface()+0x30>)
   160ec:	9b01      	ldr	r3, [sp, #4]
   160ee:	601a      	str	r2, [r3, #0]
   160f0:	9c01      	ldr	r4, [sp, #4]
   160f2:	462b      	mov	r3, r5
   160f4:	4619      	mov	r1, r3
   160f6:	4803      	ldr	r0, [pc, #12]	; (16104 <PinInterface::PinInterface()+0x2c>)
   160f8:	f7fd fa3e 	bl	13578 <__cyg_profile_func_exit>
   160fc:	4623      	mov	r3, r4
   160fe:	4618      	mov	r0, r3
   16100:	b003      	add	sp, #12
   16102:	bd30      	pop	{r4, r5, pc}
   16104:	000160d9 	.word	0x000160d9
   16108:	0001b10c 	.word	0x0001b10c

0001610c <Pin::Pin(unsigned char, unsigned char)>:
  constexpr Pin(uint8_t port_number, uint8_t pin_number)
   1610c:	b530      	push	{r4, r5, lr}
   1610e:	b083      	sub	sp, #12
   16110:	4675      	mov	r5, lr
   16112:	9001      	str	r0, [sp, #4]
   16114:	460b      	mov	r3, r1
   16116:	f88d 3003 	strb.w	r3, [sp, #3]
   1611a:	4613      	mov	r3, r2
   1611c:	f88d 3002 	strb.w	r3, [sp, #2]
   16120:	462b      	mov	r3, r5
   16122:	4619      	mov	r1, r3
   16124:	480d      	ldr	r0, [pc, #52]	; (1615c <Pin::Pin(unsigned char, unsigned char)+0x50>)
   16126:	f7fd fa13 	bl	13550 <__cyg_profile_func_enter>
      : port_(port_number), pin_(pin_number)
   1612a:	9b01      	ldr	r3, [sp, #4]
   1612c:	4618      	mov	r0, r3
   1612e:	f7ff ffd3 	bl	160d8 <PinInterface::PinInterface()>
   16132:	4a0b      	ldr	r2, [pc, #44]	; (16160 <Pin::Pin(unsigned char, unsigned char)+0x54>)
   16134:	9b01      	ldr	r3, [sp, #4]
   16136:	601a      	str	r2, [r3, #0]
   16138:	9b01      	ldr	r3, [sp, #4]
   1613a:	f89d 2003 	ldrb.w	r2, [sp, #3]
   1613e:	711a      	strb	r2, [r3, #4]
   16140:	9b01      	ldr	r3, [sp, #4]
   16142:	f89d 2002 	ldrb.w	r2, [sp, #2]
   16146:	715a      	strb	r2, [r3, #5]
  }
   16148:	9c01      	ldr	r4, [sp, #4]
   1614a:	462b      	mov	r3, r5
   1614c:	4619      	mov	r1, r3
   1614e:	4803      	ldr	r0, [pc, #12]	; (1615c <Pin::Pin(unsigned char, unsigned char)+0x50>)
   16150:	f7fd fa12 	bl	13578 <__cyg_profile_func_exit>
   16154:	4623      	mov	r3, r4
   16156:	4618      	mov	r0, r3
   16158:	b003      	add	sp, #12
   1615a:	bd30      	pop	{r4, r5, pc}
   1615c:	0001610d 	.word	0x0001610d
   16160:	00019a40 	.word	0x00019a40

00016164 <GpioInterface::GpioInterface()>:
class GpioInterface
   16164:	b530      	push	{r4, r5, lr}
   16166:	b083      	sub	sp, #12
   16168:	4675      	mov	r5, lr
   1616a:	9001      	str	r0, [sp, #4]
   1616c:	462b      	mov	r3, r5
   1616e:	4619      	mov	r1, r3
   16170:	4807      	ldr	r0, [pc, #28]	; (16190 <GpioInterface::GpioInterface()+0x2c>)
   16172:	f7fd f9ed 	bl	13550 <__cyg_profile_func_enter>
   16176:	4a07      	ldr	r2, [pc, #28]	; (16194 <GpioInterface::GpioInterface()+0x30>)
   16178:	9b01      	ldr	r3, [sp, #4]
   1617a:	601a      	str	r2, [r3, #0]
   1617c:	9c01      	ldr	r4, [sp, #4]
   1617e:	462b      	mov	r3, r5
   16180:	4619      	mov	r1, r3
   16182:	4803      	ldr	r0, [pc, #12]	; (16190 <GpioInterface::GpioInterface()+0x2c>)
   16184:	f7fd f9f8 	bl	13578 <__cyg_profile_func_exit>
   16188:	4623      	mov	r3, r4
   1618a:	4618      	mov	r0, r3
   1618c:	b003      	add	sp, #12
   1618e:	bd30      	pop	{r4, r5, pc}
   16190:	00016165 	.word	0x00016165
   16194:	0001b0c4 	.word	0x0001b0c4

00016198 <Gpio::Gpio(unsigned char, unsigned char)>:
  constexpr Gpio(uint8_t port_number, uint8_t pin_number)
   16198:	b530      	push	{r4, r5, lr}
   1619a:	b083      	sub	sp, #12
   1619c:	4675      	mov	r5, lr
   1619e:	9001      	str	r0, [sp, #4]
   161a0:	460b      	mov	r3, r1
   161a2:	f88d 3003 	strb.w	r3, [sp, #3]
   161a6:	4613      	mov	r3, r2
   161a8:	f88d 3002 	strb.w	r3, [sp, #2]
   161ac:	462b      	mov	r3, r5
   161ae:	4619      	mov	r1, r3
   161b0:	4816      	ldr	r0, [pc, #88]	; (1620c <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   161b2:	f7fd f9cd 	bl	13550 <__cyg_profile_func_enter>
        lpc40xx_pin_(port_number, pin_number)
   161b6:	9b01      	ldr	r3, [sp, #4]
   161b8:	4618      	mov	r0, r3
   161ba:	f7ff ffd3 	bl	16164 <GpioInterface::GpioInterface()>
   161be:	4a14      	ldr	r2, [pc, #80]	; (16210 <Gpio::Gpio(unsigned char, unsigned char)+0x78>)
   161c0:	9b01      	ldr	r3, [sp, #4]
   161c2:	601a      	str	r2, [r3, #0]
   161c4:	9b01      	ldr	r3, [sp, #4]
   161c6:	2200      	movs	r2, #0
   161c8:	711a      	strb	r2, [r3, #4]
   161ca:	9b01      	ldr	r3, [sp, #4]
   161cc:	f103 020c 	add.w	r2, r3, #12
   161d0:	9b01      	ldr	r3, [sp, #4]
   161d2:	609a      	str	r2, [r3, #8]
   161d4:	9b01      	ldr	r3, [sp, #4]
   161d6:	330c      	adds	r3, #12
   161d8:	f89d 2002 	ldrb.w	r2, [sp, #2]
   161dc:	f89d 1003 	ldrb.w	r1, [sp, #3]
   161e0:	4618      	mov	r0, r3
   161e2:	f7ff ff93 	bl	1610c <Pin::Pin(unsigned char, unsigned char)>
    interupt_port_ = (port_number == 2) ? 1 : 0;
   161e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
   161ea:	2b02      	cmp	r3, #2
   161ec:	d101      	bne.n	161f2 <Gpio::Gpio(unsigned char, unsigned char)+0x5a>
   161ee:	2201      	movs	r2, #1
   161f0:	e000      	b.n	161f4 <Gpio::Gpio(unsigned char, unsigned char)+0x5c>
   161f2:	2200      	movs	r2, #0
   161f4:	9b01      	ldr	r3, [sp, #4]
   161f6:	711a      	strb	r2, [r3, #4]
  }
   161f8:	9c01      	ldr	r4, [sp, #4]
   161fa:	462b      	mov	r3, r5
   161fc:	4619      	mov	r1, r3
   161fe:	4803      	ldr	r0, [pc, #12]	; (1620c <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   16200:	f7fd f9ba 	bl	13578 <__cyg_profile_func_exit>
   16204:	4623      	mov	r3, r4
   16206:	4618      	mov	r0, r3
   16208:	b003      	add	sp, #12
   1620a:	bd30      	pop	{r4, r5, pc}
   1620c:	00016199 	.word	0x00016199
   16210:	0001b07c 	.word	0x0001b07c

00016214 <Gpio::SetAsInput()>:
  void SetAsInput(void) override
   16214:	b530      	push	{r4, r5, lr}
   16216:	b083      	sub	sp, #12
   16218:	4675      	mov	r5, lr
   1621a:	9001      	str	r0, [sp, #4]
   1621c:	462b      	mov	r3, r5
   1621e:	4619      	mov	r1, r3
   16220:	4819      	ldr	r0, [pc, #100]	; (16288 <Gpio::SetAsInput()+0x74>)
   16222:	f7fd f995 	bl	13550 <__cyg_profile_func_enter>
    pin_->SetPinFunction(kGpioFunction);
   16226:	9b01      	ldr	r3, [sp, #4]
   16228:	689a      	ldr	r2, [r3, #8]
   1622a:	9b01      	ldr	r3, [sp, #4]
   1622c:	689b      	ldr	r3, [r3, #8]
   1622e:	681b      	ldr	r3, [r3, #0]
   16230:	681b      	ldr	r3, [r3, #0]
   16232:	2100      	movs	r1, #0
   16234:	4610      	mov	r0, r2
   16236:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR &= ~(1 << pin_->GetPin());
   16238:	9b01      	ldr	r3, [sp, #4]
   1623a:	689a      	ldr	r2, [r3, #8]
   1623c:	9b01      	ldr	r3, [sp, #4]
   1623e:	689b      	ldr	r3, [r3, #8]
   16240:	681b      	ldr	r3, [r3, #0]
   16242:	3330      	adds	r3, #48	; 0x30
   16244:	681b      	ldr	r3, [r3, #0]
   16246:	4610      	mov	r0, r2
   16248:	4798      	blx	r3
   1624a:	4603      	mov	r3, r0
   1624c:	461a      	mov	r2, r3
   1624e:	2301      	movs	r3, #1
   16250:	4093      	lsls	r3, r2
   16252:	43dc      	mvns	r4, r3
   16254:	9b01      	ldr	r3, [sp, #4]
   16256:	689a      	ldr	r2, [r3, #8]
   16258:	9b01      	ldr	r3, [sp, #4]
   1625a:	689b      	ldr	r3, [r3, #8]
   1625c:	681b      	ldr	r3, [r3, #0]
   1625e:	332c      	adds	r3, #44	; 0x2c
   16260:	681b      	ldr	r3, [r3, #0]
   16262:	4610      	mov	r0, r2
   16264:	4798      	blx	r3
   16266:	4603      	mov	r3, r0
   16268:	461a      	mov	r2, r3
   1626a:	4b08      	ldr	r3, [pc, #32]	; (1628c <Gpio::SetAsInput()+0x78>)
   1626c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16270:	681a      	ldr	r2, [r3, #0]
   16272:	4621      	mov	r1, r4
   16274:	400a      	ands	r2, r1
   16276:	601a      	str	r2, [r3, #0]
   16278:	462b      	mov	r3, r5
   1627a:	4619      	mov	r1, r3
   1627c:	4802      	ldr	r0, [pc, #8]	; (16288 <Gpio::SetAsInput()+0x74>)
   1627e:	f7fd f97b 	bl	13578 <__cyg_profile_func_exit>
  }
   16282:	bf00      	nop
   16284:	b003      	add	sp, #12
   16286:	bd30      	pop	{r4, r5, pc}
   16288:	00016215 	.word	0x00016215
   1628c:	10000044 	.word	0x10000044

00016290 <Gpio::SetAsOutput()>:
  void SetAsOutput(void) override
   16290:	b530      	push	{r4, r5, lr}
   16292:	b083      	sub	sp, #12
   16294:	4675      	mov	r5, lr
   16296:	9001      	str	r0, [sp, #4]
   16298:	462b      	mov	r3, r5
   1629a:	4619      	mov	r1, r3
   1629c:	4819      	ldr	r0, [pc, #100]	; (16304 <Gpio::SetAsOutput()+0x74>)
   1629e:	f7fd f957 	bl	13550 <__cyg_profile_func_enter>
    pin_->SetPinFunction(kGpioFunction);
   162a2:	9b01      	ldr	r3, [sp, #4]
   162a4:	689a      	ldr	r2, [r3, #8]
   162a6:	9b01      	ldr	r3, [sp, #4]
   162a8:	689b      	ldr	r3, [r3, #8]
   162aa:	681b      	ldr	r3, [r3, #0]
   162ac:	681b      	ldr	r3, [r3, #0]
   162ae:	2100      	movs	r1, #0
   162b0:	4610      	mov	r0, r2
   162b2:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR |= (1 << pin_->GetPin());
   162b4:	9b01      	ldr	r3, [sp, #4]
   162b6:	689a      	ldr	r2, [r3, #8]
   162b8:	9b01      	ldr	r3, [sp, #4]
   162ba:	689b      	ldr	r3, [r3, #8]
   162bc:	681b      	ldr	r3, [r3, #0]
   162be:	3330      	adds	r3, #48	; 0x30
   162c0:	681b      	ldr	r3, [r3, #0]
   162c2:	4610      	mov	r0, r2
   162c4:	4798      	blx	r3
   162c6:	4603      	mov	r3, r0
   162c8:	461a      	mov	r2, r3
   162ca:	2301      	movs	r3, #1
   162cc:	fa03 f402 	lsl.w	r4, r3, r2
   162d0:	9b01      	ldr	r3, [sp, #4]
   162d2:	689a      	ldr	r2, [r3, #8]
   162d4:	9b01      	ldr	r3, [sp, #4]
   162d6:	689b      	ldr	r3, [r3, #8]
   162d8:	681b      	ldr	r3, [r3, #0]
   162da:	332c      	adds	r3, #44	; 0x2c
   162dc:	681b      	ldr	r3, [r3, #0]
   162de:	4610      	mov	r0, r2
   162e0:	4798      	blx	r3
   162e2:	4603      	mov	r3, r0
   162e4:	461a      	mov	r2, r3
   162e6:	4b08      	ldr	r3, [pc, #32]	; (16308 <Gpio::SetAsOutput()+0x78>)
   162e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   162ec:	681a      	ldr	r2, [r3, #0]
   162ee:	4621      	mov	r1, r4
   162f0:	430a      	orrs	r2, r1
   162f2:	601a      	str	r2, [r3, #0]
   162f4:	462b      	mov	r3, r5
   162f6:	4619      	mov	r1, r3
   162f8:	4802      	ldr	r0, [pc, #8]	; (16304 <Gpio::SetAsOutput()+0x74>)
   162fa:	f7fd f93d 	bl	13578 <__cyg_profile_func_exit>
  }
   162fe:	bf00      	nop
   16300:	b003      	add	sp, #12
   16302:	bd30      	pop	{r4, r5, pc}
   16304:	00016291 	.word	0x00016291
   16308:	10000044 	.word	0x10000044

0001630c <Gpio::SetDirection(GpioInterface::Direction)>:
  inline void SetDirection(Direction direction) override
   1630c:	b510      	push	{r4, lr}
   1630e:	b082      	sub	sp, #8
   16310:	4674      	mov	r4, lr
   16312:	9001      	str	r0, [sp, #4]
   16314:	460b      	mov	r3, r1
   16316:	f88d 3003 	strb.w	r3, [sp, #3]
   1631a:	4623      	mov	r3, r4
   1631c:	4619      	mov	r1, r3
   1631e:	480b      	ldr	r0, [pc, #44]	; (1634c <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   16320:	f7fd f916 	bl	13550 <__cyg_profile_func_enter>
    (direction) ? SetAsOutput() : SetAsInput();
   16324:	f89d 3003 	ldrb.w	r3, [sp, #3]
   16328:	2b00      	cmp	r3, #0
   1632a:	d003      	beq.n	16334 <Gpio::SetDirection(GpioInterface::Direction)+0x28>
   1632c:	9801      	ldr	r0, [sp, #4]
   1632e:	f7ff ffaf 	bl	16290 <Gpio::SetAsOutput()>
   16332:	e002      	b.n	1633a <Gpio::SetDirection(GpioInterface::Direction)+0x2e>
   16334:	9801      	ldr	r0, [sp, #4]
   16336:	f7ff ff6d 	bl	16214 <Gpio::SetAsInput()>
   1633a:	4623      	mov	r3, r4
   1633c:	4619      	mov	r1, r3
   1633e:	4803      	ldr	r0, [pc, #12]	; (1634c <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   16340:	f7fd f91a 	bl	13578 <__cyg_profile_func_exit>
  }
   16344:	bf00      	nop
   16346:	b002      	add	sp, #8
   16348:	bd10      	pop	{r4, pc}
   1634a:	bf00      	nop
   1634c:	0001630d 	.word	0x0001630d

00016350 <Gpio::Toggle()>:
  // Toggle the output of a GPIO output pin
  void Toggle() override
   16350:	b530      	push	{r4, r5, lr}
   16352:	b083      	sub	sp, #12
   16354:	4675      	mov	r5, lr
   16356:	9001      	str	r0, [sp, #4]
   16358:	462b      	mov	r3, r5
   1635a:	4619      	mov	r1, r3
   1635c:	4815      	ldr	r0, [pc, #84]	; (163b4 <Gpio::Toggle()+0x64>)
   1635e:	f7fd f8f7 	bl	13550 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->PIN ^= (1 << pin_->GetPin());
   16362:	9b01      	ldr	r3, [sp, #4]
   16364:	689a      	ldr	r2, [r3, #8]
   16366:	9b01      	ldr	r3, [sp, #4]
   16368:	689b      	ldr	r3, [r3, #8]
   1636a:	681b      	ldr	r3, [r3, #0]
   1636c:	3330      	adds	r3, #48	; 0x30
   1636e:	681b      	ldr	r3, [r3, #0]
   16370:	4610      	mov	r0, r2
   16372:	4798      	blx	r3
   16374:	4603      	mov	r3, r0
   16376:	461a      	mov	r2, r3
   16378:	2301      	movs	r3, #1
   1637a:	fa03 f402 	lsl.w	r4, r3, r2
   1637e:	9b01      	ldr	r3, [sp, #4]
   16380:	689a      	ldr	r2, [r3, #8]
   16382:	9b01      	ldr	r3, [sp, #4]
   16384:	689b      	ldr	r3, [r3, #8]
   16386:	681b      	ldr	r3, [r3, #0]
   16388:	332c      	adds	r3, #44	; 0x2c
   1638a:	681b      	ldr	r3, [r3, #0]
   1638c:	4610      	mov	r0, r2
   1638e:	4798      	blx	r3
   16390:	4603      	mov	r3, r0
   16392:	461a      	mov	r2, r3
   16394:	4b08      	ldr	r3, [pc, #32]	; (163b8 <Gpio::Toggle()+0x68>)
   16396:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1639a:	695a      	ldr	r2, [r3, #20]
   1639c:	4621      	mov	r1, r4
   1639e:	404a      	eors	r2, r1
   163a0:	615a      	str	r2, [r3, #20]
   163a2:	462b      	mov	r3, r5
   163a4:	4619      	mov	r1, r3
   163a6:	4803      	ldr	r0, [pc, #12]	; (163b4 <Gpio::Toggle()+0x64>)
   163a8:	f7fd f8e6 	bl	13578 <__cyg_profile_func_exit>
  }
   163ac:	bf00      	nop
   163ae:	b003      	add	sp, #12
   163b0:	bd30      	pop	{r4, r5, pc}
   163b2:	bf00      	nop
   163b4:	00016351 	.word	0x00016351
   163b8:	10000044 	.word	0x10000044

000163bc <Gpio::ReadState()>:
  // Returns the current State state of the pin
  State ReadState(void) override
   163bc:	b530      	push	{r4, r5, lr}
   163be:	b085      	sub	sp, #20
   163c0:	4675      	mov	r5, lr
   163c2:	9001      	str	r0, [sp, #4]
   163c4:	462b      	mov	r3, r5
   163c6:	4619      	mov	r1, r3
   163c8:	4818      	ldr	r0, [pc, #96]	; (1642c <Gpio::ReadState()+0x70>)
   163ca:	f7fd f8c1 	bl	13550 <__cyg_profile_func_enter>
  {
    bool state = (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   163ce:	9b01      	ldr	r3, [sp, #4]
   163d0:	689a      	ldr	r2, [r3, #8]
   163d2:	9b01      	ldr	r3, [sp, #4]
   163d4:	689b      	ldr	r3, [r3, #8]
   163d6:	681b      	ldr	r3, [r3, #0]
   163d8:	332c      	adds	r3, #44	; 0x2c
   163da:	681b      	ldr	r3, [r3, #0]
   163dc:	4610      	mov	r0, r2
   163de:	4798      	blx	r3
   163e0:	4603      	mov	r3, r0
   163e2:	461a      	mov	r2, r3
   163e4:	4b12      	ldr	r3, [pc, #72]	; (16430 <Gpio::ReadState()+0x74>)
   163e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   163ea:	695c      	ldr	r4, [r3, #20]
   163ec:	9b01      	ldr	r3, [sp, #4]
   163ee:	689a      	ldr	r2, [r3, #8]
   163f0:	9b01      	ldr	r3, [sp, #4]
   163f2:	689b      	ldr	r3, [r3, #8]
   163f4:	681b      	ldr	r3, [r3, #0]
   163f6:	3330      	adds	r3, #48	; 0x30
   163f8:	681b      	ldr	r3, [r3, #0]
   163fa:	4610      	mov	r0, r2
   163fc:	4798      	blx	r3
   163fe:	4603      	mov	r3, r0
   16400:	fa24 f303 	lsr.w	r3, r4, r3
   16404:	f003 0301 	and.w	r3, r3, #1
   16408:	2b00      	cmp	r3, #0
   1640a:	bf14      	ite	ne
   1640c:	2301      	movne	r3, #1
   1640e:	2300      	moveq	r3, #0
   16410:	f88d 300f 	strb.w	r3, [sp, #15]
    return static_cast<State>(state);
   16414:	f89d 400f 	ldrb.w	r4, [sp, #15]
   16418:	462b      	mov	r3, r5
   1641a:	4619      	mov	r1, r3
   1641c:	4803      	ldr	r0, [pc, #12]	; (1642c <Gpio::ReadState()+0x70>)
   1641e:	f7fd f8ab 	bl	13578 <__cyg_profile_func_exit>
   16422:	4623      	mov	r3, r4
  }
   16424:	4618      	mov	r0, r3
   16426:	b005      	add	sp, #20
   16428:	bd30      	pop	{r4, r5, pc}
   1642a:	bf00      	nop
   1642c:	000163bd 	.word	0x000163bd
   16430:	10000044 	.word	0x10000044

00016434 <Gpio::Read()>:
  // Returns true if input or output pin is high
  bool Read(void) override
   16434:	b530      	push	{r4, r5, lr}
   16436:	b083      	sub	sp, #12
   16438:	4675      	mov	r5, lr
   1643a:	9001      	str	r0, [sp, #4]
   1643c:	462b      	mov	r3, r5
   1643e:	4619      	mov	r1, r3
   16440:	4816      	ldr	r0, [pc, #88]	; (1649c <Gpio::Read()+0x68>)
   16442:	f7fd f885 	bl	13550 <__cyg_profile_func_enter>
  {
    return (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   16446:	9b01      	ldr	r3, [sp, #4]
   16448:	689a      	ldr	r2, [r3, #8]
   1644a:	9b01      	ldr	r3, [sp, #4]
   1644c:	689b      	ldr	r3, [r3, #8]
   1644e:	681b      	ldr	r3, [r3, #0]
   16450:	332c      	adds	r3, #44	; 0x2c
   16452:	681b      	ldr	r3, [r3, #0]
   16454:	4610      	mov	r0, r2
   16456:	4798      	blx	r3
   16458:	4603      	mov	r3, r0
   1645a:	461a      	mov	r2, r3
   1645c:	4b10      	ldr	r3, [pc, #64]	; (164a0 <Gpio::Read()+0x6c>)
   1645e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16462:	695c      	ldr	r4, [r3, #20]
   16464:	9b01      	ldr	r3, [sp, #4]
   16466:	689a      	ldr	r2, [r3, #8]
   16468:	9b01      	ldr	r3, [sp, #4]
   1646a:	689b      	ldr	r3, [r3, #8]
   1646c:	681b      	ldr	r3, [r3, #0]
   1646e:	3330      	adds	r3, #48	; 0x30
   16470:	681b      	ldr	r3, [r3, #0]
   16472:	4610      	mov	r0, r2
   16474:	4798      	blx	r3
   16476:	4603      	mov	r3, r0
   16478:	fa24 f303 	lsr.w	r3, r4, r3
   1647c:	f003 0301 	and.w	r3, r3, #1
   16480:	2b00      	cmp	r3, #0
   16482:	bf14      	ite	ne
   16484:	2301      	movne	r3, #1
   16486:	2300      	moveq	r3, #0
   16488:	b2dc      	uxtb	r4, r3
   1648a:	462b      	mov	r3, r5
   1648c:	4619      	mov	r1, r3
   1648e:	4803      	ldr	r0, [pc, #12]	; (1649c <Gpio::Read()+0x68>)
   16490:	f7fd f872 	bl	13578 <__cyg_profile_func_exit>
   16494:	4623      	mov	r3, r4
  }
   16496:	4618      	mov	r0, r3
   16498:	b003      	add	sp, #12
   1649a:	bd30      	pop	{r4, r5, pc}
   1649c:	00016435 	.word	0x00016435
   164a0:	10000044 	.word	0x10000044

000164a4 <Gpio::GetPin()>:
  PinInterface & GetPin() override
   164a4:	b530      	push	{r4, r5, lr}
   164a6:	b083      	sub	sp, #12
   164a8:	4675      	mov	r5, lr
   164aa:	9001      	str	r0, [sp, #4]
   164ac:	462b      	mov	r3, r5
   164ae:	4619      	mov	r1, r3
   164b0:	4806      	ldr	r0, [pc, #24]	; (164cc <Gpio::GetPin()+0x28>)
   164b2:	f7fd f84d 	bl	13550 <__cyg_profile_func_enter>
  {
    return *pin_;
   164b6:	9b01      	ldr	r3, [sp, #4]
   164b8:	689c      	ldr	r4, [r3, #8]
   164ba:	462b      	mov	r3, r5
   164bc:	4619      	mov	r1, r3
   164be:	4803      	ldr	r0, [pc, #12]	; (164cc <Gpio::GetPin()+0x28>)
   164c0:	f7fd f85a 	bl	13578 <__cyg_profile_func_exit>
   164c4:	4623      	mov	r3, r4
  }
   164c6:	4618      	mov	r0, r3
   164c8:	b003      	add	sp, #12
   164ca:	bd30      	pop	{r4, r5, pc}
   164cc:	000164a5 	.word	0x000164a5

000164d0 <Gpio::ValidPortCheck()>:

  // Checks if the selected gpio port is valid for external interrupts.
  bool ValidPortCheck()
   164d0:	b530      	push	{r4, r5, lr}
   164d2:	b087      	sub	sp, #28
   164d4:	4675      	mov	r5, lr
   164d6:	9003      	str	r0, [sp, #12]
   164d8:	462b      	mov	r3, r5
   164da:	4619      	mov	r1, r3
   164dc:	4817      	ldr	r0, [pc, #92]	; (1653c <Gpio::ValidPortCheck()+0x6c>)
   164de:	f7fd f837 	bl	13550 <__cyg_profile_func_enter>
  {
    bool is_valid = (interupt_port_ <= 1);
   164e2:	9b03      	ldr	r3, [sp, #12]
   164e4:	791b      	ldrb	r3, [r3, #4]
   164e6:	2b01      	cmp	r3, #1
   164e8:	bf94      	ite	ls
   164ea:	2301      	movls	r3, #1
   164ec:	2300      	movhi	r3, #0
   164ee:	b2db      	uxtb	r3, r3
   164f0:	f88d 3017 	strb.w	r3, [sp, #23]
    SJ2_ASSERT_WARNING(is_valid,
   164f4:	f89d 3017 	ldrb.w	r3, [sp, #23]
   164f8:	f083 0301 	eor.w	r3, r3, #1
   164fc:	b2db      	uxtb	r3, r3
   164fe:	2b00      	cmp	r3, #0
   16500:	d010      	beq.n	16524 <Gpio::ValidPortCheck()+0x54>
   16502:	9b03      	ldr	r3, [sp, #12]
   16504:	689a      	ldr	r2, [r3, #8]
   16506:	9b03      	ldr	r3, [sp, #12]
   16508:	689b      	ldr	r3, [r3, #8]
   1650a:	681b      	ldr	r3, [r3, #0]
   1650c:	332c      	adds	r3, #44	; 0x2c
   1650e:	681b      	ldr	r3, [r3, #0]
   16510:	4610      	mov	r0, r2
   16512:	4798      	blx	r3
   16514:	4603      	mov	r3, r0
   16516:	9300      	str	r3, [sp, #0]
   16518:	23a6      	movs	r3, #166	; 0xa6
   1651a:	4a09      	ldr	r2, [pc, #36]	; (16540 <Gpio::ValidPortCheck()+0x70>)
   1651c:	4909      	ldr	r1, [pc, #36]	; (16544 <Gpio::ValidPortCheck()+0x74>)
   1651e:	480a      	ldr	r0, [pc, #40]	; (16548 <Gpio::ValidPortCheck()+0x78>)
   16520:	f7ff fdb4 	bl	1608c <printf>
                       "Port %d cannot be used for External Interrupts. Need "
                       "to use GPIO on Port 0 or 2.",
                       pin_->GetPort());
    return is_valid;
   16524:	f89d 4017 	ldrb.w	r4, [sp, #23]
   16528:	462b      	mov	r3, r5
   1652a:	4619      	mov	r1, r3
   1652c:	4803      	ldr	r0, [pc, #12]	; (1653c <Gpio::ValidPortCheck()+0x6c>)
   1652e:	f7fd f823 	bl	13578 <__cyg_profile_func_exit>
   16532:	4623      	mov	r3, r4
  }
   16534:	4618      	mov	r0, r3
   16536:	b007      	add	sp, #28
   16538:	bd30      	pop	{r4, r5, pc}
   1653a:	bf00      	nop
   1653c:	000164d1 	.word	0x000164d1
   16540:	0001b17c 	.word	0x0001b17c
   16544:	0001ab70 	.word	0x0001ab70
   16548:	0001a040 	.word	0x0001a040

0001654c <Gpio::SetInterruptRoutine(void (*)())>:

  // Assigns the developer's ISR function to the port/pin gpio instance.
  void SetInterruptRoutine(IsrPointer function) override
   1654c:	b570      	push	{r4, r5, r6, lr}
   1654e:	b082      	sub	sp, #8
   16550:	4676      	mov	r6, lr
   16552:	9001      	str	r0, [sp, #4]
   16554:	9100      	str	r1, [sp, #0]
   16556:	4633      	mov	r3, r6
   16558:	4619      	mov	r1, r3
   1655a:	4811      	ldr	r0, [pc, #68]	; (165a0 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   1655c:	f7fc fff8 	bl	13550 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16560:	9801      	ldr	r0, [sp, #4]
   16562:	f7ff ffb5 	bl	164d0 <Gpio::ValidPortCheck()>
    interrupthandlers[interupt_port_][pin_->GetPin()] = function;
   16566:	9c00      	ldr	r4, [sp, #0]
   16568:	9b01      	ldr	r3, [sp, #4]
   1656a:	791b      	ldrb	r3, [r3, #4]
   1656c:	461d      	mov	r5, r3
   1656e:	9b01      	ldr	r3, [sp, #4]
   16570:	689a      	ldr	r2, [r3, #8]
   16572:	9b01      	ldr	r3, [sp, #4]
   16574:	689b      	ldr	r3, [r3, #8]
   16576:	681b      	ldr	r3, [r3, #0]
   16578:	3330      	adds	r3, #48	; 0x30
   1657a:	681b      	ldr	r3, [r3, #0]
   1657c:	4610      	mov	r0, r2
   1657e:	4798      	blx	r3
   16580:	4603      	mov	r3, r0
   16582:	4619      	mov	r1, r3
   16584:	4a07      	ldr	r2, [pc, #28]	; (165a4 <Gpio::SetInterruptRoutine(void (*)())+0x58>)
   16586:	016b      	lsls	r3, r5, #5
   16588:	440b      	add	r3, r1
   1658a:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
   1658e:	4633      	mov	r3, r6
   16590:	4619      	mov	r1, r3
   16592:	4803      	ldr	r0, [pc, #12]	; (165a0 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   16594:	f7fc fff0 	bl	13578 <__cyg_profile_func_exit>
  }
   16598:	bf00      	nop
   1659a:	b002      	add	sp, #8
   1659c:	bd70      	pop	{r4, r5, r6, pc}
   1659e:	bf00      	nop
   165a0:	0001654d 	.word	0x0001654d
   165a4:	100007e0 	.word	0x100007e0

000165a8 <Gpio::ClearInterruptRoutine()>:

  // Clears the developers ISR function from the port/pin gio instance.
  void ClearInterruptRoutine() override
   165a8:	b530      	push	{r4, r5, lr}
   165aa:	b083      	sub	sp, #12
   165ac:	4675      	mov	r5, lr
   165ae:	9001      	str	r0, [sp, #4]
   165b0:	462b      	mov	r3, r5
   165b2:	4619      	mov	r1, r3
   165b4:	480f      	ldr	r0, [pc, #60]	; (165f4 <Gpio::ClearInterruptRoutine()+0x4c>)
   165b6:	f7fc ffcb 	bl	13550 <__cyg_profile_func_enter>
  {
    interrupthandlers[interupt_port_][pin_->GetPin()] = nullptr;
   165ba:	9b01      	ldr	r3, [sp, #4]
   165bc:	791b      	ldrb	r3, [r3, #4]
   165be:	461c      	mov	r4, r3
   165c0:	9b01      	ldr	r3, [sp, #4]
   165c2:	689a      	ldr	r2, [r3, #8]
   165c4:	9b01      	ldr	r3, [sp, #4]
   165c6:	689b      	ldr	r3, [r3, #8]
   165c8:	681b      	ldr	r3, [r3, #0]
   165ca:	3330      	adds	r3, #48	; 0x30
   165cc:	681b      	ldr	r3, [r3, #0]
   165ce:	4610      	mov	r0, r2
   165d0:	4798      	blx	r3
   165d2:	4603      	mov	r3, r0
   165d4:	4619      	mov	r1, r3
   165d6:	4a08      	ldr	r2, [pc, #32]	; (165f8 <Gpio::ClearInterruptRoutine()+0x50>)
   165d8:	0163      	lsls	r3, r4, #5
   165da:	440b      	add	r3, r1
   165dc:	2100      	movs	r1, #0
   165de:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   165e2:	462b      	mov	r3, r5
   165e4:	4619      	mov	r1, r3
   165e6:	4803      	ldr	r0, [pc, #12]	; (165f4 <Gpio::ClearInterruptRoutine()+0x4c>)
   165e8:	f7fc ffc6 	bl	13578 <__cyg_profile_func_exit>
  }
   165ec:	bf00      	nop
   165ee:	b003      	add	sp, #12
   165f0:	bd30      	pop	{r4, r5, pc}
   165f2:	bf00      	nop
   165f4:	000165a9 	.word	0x000165a9
   165f8:	100007e0 	.word	0x100007e0

000165fc <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>:
constexpr Type Value(Enum enum_type_value)
   165fc:	b530      	push	{r4, r5, lr}
   165fe:	b083      	sub	sp, #12
   16600:	4675      	mov	r5, lr
   16602:	4603      	mov	r3, r0
   16604:	f88d 3007 	strb.w	r3, [sp, #7]
   16608:	462b      	mov	r3, r5
   1660a:	4619      	mov	r1, r3
   1660c:	4806      	ldr	r0, [pc, #24]	; (16628 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   1660e:	f7fc ff9f 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   16612:	f89d 4007 	ldrb.w	r4, [sp, #7]
   16616:	462b      	mov	r3, r5
   16618:	4619      	mov	r1, r3
   1661a:	4803      	ldr	r0, [pc, #12]	; (16628 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   1661c:	f7fc ffac 	bl	13578 <__cyg_profile_func_exit>
   16620:	4623      	mov	r3, r4
}
   16622:	4618      	mov	r0, r3
   16624:	b003      	add	sp, #12
   16626:	bd30      	pop	{r4, r5, pc}
   16628:	000165fd 	.word	0x000165fd

0001662c <Gpio::SetInterruptEdge(GpioInterface::Edge)>:

  // Sets the selected edge that the gpio interrupt will be triggered on.
  void SetInterruptEdge(Edge edge) override
   1662c:	b510      	push	{r4, lr}
   1662e:	b084      	sub	sp, #16
   16630:	4674      	mov	r4, lr
   16632:	9003      	str	r0, [sp, #12]
   16634:	460b      	mov	r3, r1
   16636:	f88d 300b 	strb.w	r3, [sp, #11]
   1663a:	4623      	mov	r3, r4
   1663c:	4619      	mov	r1, r3
   1663e:	4819      	ldr	r0, [pc, #100]	; (166a4 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   16640:	f7fc ff86 	bl	13550 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16644:	9803      	ldr	r0, [sp, #12]
   16646:	f7ff ff43 	bl	164d0 <Gpio::ValidPortCheck()>
    switch (edge)
   1664a:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1664e:	2b01      	cmp	r3, #1
   16650:	d008      	beq.n	16664 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x38>
   16652:	2b01      	cmp	r3, #1
   16654:	d302      	bcc.n	1665c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x30>
   16656:	2b02      	cmp	r3, #2
   16658:	d008      	beq.n	1666c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x40>
   1665a:	e00e      	b.n	1667a <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        SetEdgeRising();
   1665c:	9803      	ldr	r0, [sp, #12]
   1665e:	f000 f8b1 	bl	167c4 <Gpio::SetEdgeRising()>
        break;
   16662:	e017      	b.n	16694 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        SetEdgeFalling();
   16664:	9803      	ldr	r0, [sp, #12]
   16666:	f000 f8eb 	bl	16840 <Gpio::SetEdgeFalling()>
        break;
   1666a:	e013      	b.n	16694 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        SetEdgeRising();
   1666c:	9803      	ldr	r0, [sp, #12]
   1666e:	f000 f8a9 	bl	167c4 <Gpio::SetEdgeRising()>
        SetEdgeFalling();
   16672:	9803      	ldr	r0, [sp, #12]
   16674:	f000 f8e4 	bl	16840 <Gpio::SetEdgeFalling()>
        break;
   16678:	e00c      	b.n	16694 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   1667a:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1667e:	4618      	mov	r0, r3
   16680:	f7ff ffbc 	bl	165fc <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   16684:	4603      	mov	r3, r0
   16686:	9300      	str	r3, [sp, #0]
   16688:	23d2      	movs	r3, #210	; 0xd2
   1668a:	4a07      	ldr	r2, [pc, #28]	; (166a8 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x7c>)
   1668c:	4907      	ldr	r1, [pc, #28]	; (166ac <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x80>)
   1668e:	4808      	ldr	r0, [pc, #32]	; (166b0 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x84>)
   16690:	f7ff fcfc 	bl	1608c <printf>
   16694:	4623      	mov	r3, r4
   16696:	4619      	mov	r1, r3
   16698:	4802      	ldr	r0, [pc, #8]	; (166a4 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   1669a:	f7fc ff6d 	bl	13578 <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
            util::Value(edge));
      }
    }
  }
   1669e:	bf00      	nop
   166a0:	b004      	add	sp, #16
   166a2:	bd10      	pop	{r4, pc}
   166a4:	0001662d 	.word	0x0001662d
   166a8:	0001b198 	.word	0x0001b198
   166ac:	0001ab7c 	.word	0x0001ab7c
   166b0:	0001a0d0 	.word	0x0001a0d0

000166b4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)>:

  // Clears the seleted edge of the gpio interrupt from being triggered.
  void ClearInterruptEdge(Edge edge) override
   166b4:	b510      	push	{r4, lr}
   166b6:	b084      	sub	sp, #16
   166b8:	4674      	mov	r4, lr
   166ba:	9003      	str	r0, [sp, #12]
   166bc:	460b      	mov	r3, r1
   166be:	f88d 300b 	strb.w	r3, [sp, #11]
   166c2:	4623      	mov	r3, r4
   166c4:	4619      	mov	r1, r3
   166c6:	4819      	ldr	r0, [pc, #100]	; (1672c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   166c8:	f7fc ff42 	bl	13550 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   166cc:	9803      	ldr	r0, [sp, #12]
   166ce:	f7ff feff 	bl	164d0 <Gpio::ValidPortCheck()>
    switch (edge)
   166d2:	f89d 300b 	ldrb.w	r3, [sp, #11]
   166d6:	2b01      	cmp	r3, #1
   166d8:	d008      	beq.n	166ec <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x38>
   166da:	2b01      	cmp	r3, #1
   166dc:	d302      	bcc.n	166e4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x30>
   166de:	2b02      	cmp	r3, #2
   166e0:	d008      	beq.n	166f4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x40>
   166e2:	e00e      	b.n	16702 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        ClearEdgeRising();
   166e4:	9803      	ldr	r0, [sp, #12]
   166e6:	f000 f8e9 	bl	168bc <Gpio::ClearEdgeRising()>
        break;
   166ea:	e017      	b.n	1671c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        ClearEdgeFalling();
   166ec:	9803      	ldr	r0, [sp, #12]
   166ee:	f000 f923 	bl	16938 <Gpio::ClearEdgeFalling()>
        break;
   166f2:	e013      	b.n	1671c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        ClearEdgeRising();
   166f4:	9803      	ldr	r0, [sp, #12]
   166f6:	f000 f8e1 	bl	168bc <Gpio::ClearEdgeRising()>
        ClearEdgeFalling();
   166fa:	9803      	ldr	r0, [sp, #12]
   166fc:	f000 f91c 	bl	16938 <Gpio::ClearEdgeFalling()>
        break;
   16700:	e00c      	b.n	1671c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   16702:	f89d 300b 	ldrb.w	r3, [sp, #11]
   16706:	4618      	mov	r0, r3
   16708:	f7ff ff78 	bl	165fc <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   1670c:	4603      	mov	r3, r0
   1670e:	9300      	str	r3, [sp, #0]
   16710:	23f2      	movs	r3, #242	; 0xf2
   16712:	4a07      	ldr	r2, [pc, #28]	; (16730 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x7c>)
   16714:	4907      	ldr	r1, [pc, #28]	; (16734 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x80>)
   16716:	4808      	ldr	r0, [pc, #32]	; (16738 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x84>)
   16718:	f7ff fcb8 	bl	1608c <printf>
   1671c:	4623      	mov	r3, r4
   1671e:	4619      	mov	r1, r3
   16720:	4802      	ldr	r0, [pc, #8]	; (1672c <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   16722:	f7fc ff29 	bl	13578 <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
           util::Value(edge));
      }
    }
  }
   16726:	bf00      	nop
   16728:	b004      	add	sp, #16
   1672a:	bd10      	pop	{r4, pc}
   1672c:	000166b5 	.word	0x000166b5
   16730:	0001b140 	.word	0x0001b140
   16734:	0001ab88 	.word	0x0001ab88
   16738:	0001a0d0 	.word	0x0001a0d0

0001673c <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)>:

  // Assign the developer's ISR and sets the selected edge that the gpio
  // interrupt will be triggered on.
  void AttachInterrupt(IsrPointer function, Edge edge) override
   1673c:	b510      	push	{r4, lr}
   1673e:	b084      	sub	sp, #16
   16740:	4674      	mov	r4, lr
   16742:	9003      	str	r0, [sp, #12]
   16744:	9102      	str	r1, [sp, #8]
   16746:	4613      	mov	r3, r2
   16748:	f88d 3007 	strb.w	r3, [sp, #7]
   1674c:	4623      	mov	r3, r4
   1674e:	4619      	mov	r1, r3
   16750:	480b      	ldr	r0, [pc, #44]	; (16780 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   16752:	f7fc fefd 	bl	13550 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16756:	9803      	ldr	r0, [sp, #12]
   16758:	f7ff feba 	bl	164d0 <Gpio::ValidPortCheck()>
    SetInterruptRoutine(function);
   1675c:	9902      	ldr	r1, [sp, #8]
   1675e:	9803      	ldr	r0, [sp, #12]
   16760:	f7ff fef4 	bl	1654c <Gpio::SetInterruptRoutine(void (*)())>
    SetInterruptEdge(edge);
   16764:	f89d 3007 	ldrb.w	r3, [sp, #7]
   16768:	4619      	mov	r1, r3
   1676a:	9803      	ldr	r0, [sp, #12]
   1676c:	f7ff ff5e 	bl	1662c <Gpio::SetInterruptEdge(GpioInterface::Edge)>
   16770:	4623      	mov	r3, r4
   16772:	4619      	mov	r1, r3
   16774:	4802      	ldr	r0, [pc, #8]	; (16780 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   16776:	f7fc feff 	bl	13578 <__cyg_profile_func_exit>
  }
   1677a:	bf00      	nop
   1677c:	b004      	add	sp, #16
   1677e:	bd10      	pop	{r4, pc}
   16780:	0001673d 	.word	0x0001673d

00016784 <Gpio::DetachInterrupt()>:

  // Removes the developer's ISR and clears the selected edge of the gpio
  // interrupt from being triggered.
  void DetachInterrupt() override
   16784:	b510      	push	{r4, lr}
   16786:	b082      	sub	sp, #8
   16788:	4674      	mov	r4, lr
   1678a:	9001      	str	r0, [sp, #4]
   1678c:	4623      	mov	r3, r4
   1678e:	4619      	mov	r1, r3
   16790:	480b      	ldr	r0, [pc, #44]	; (167c0 <Gpio::DetachInterrupt()+0x3c>)
   16792:	f7fc fedd 	bl	13550 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16796:	9801      	ldr	r0, [sp, #4]
   16798:	f7ff fe9a 	bl	164d0 <Gpio::ValidPortCheck()>
    ClearInterruptRoutine();
   1679c:	9801      	ldr	r0, [sp, #4]
   1679e:	f7ff ff03 	bl	165a8 <Gpio::ClearInterruptRoutine()>
    ClearEdgeRising();
   167a2:	9801      	ldr	r0, [sp, #4]
   167a4:	f000 f88a 	bl	168bc <Gpio::ClearEdgeRising()>
    ClearEdgeFalling();
   167a8:	9801      	ldr	r0, [sp, #4]
   167aa:	f000 f8c5 	bl	16938 <Gpio::ClearEdgeFalling()>
   167ae:	4623      	mov	r3, r4
   167b0:	4619      	mov	r1, r3
   167b2:	4803      	ldr	r0, [pc, #12]	; (167c0 <Gpio::DetachInterrupt()+0x3c>)
   167b4:	f7fc fee0 	bl	13578 <__cyg_profile_func_exit>
  }
   167b8:	bf00      	nop
   167ba:	b002      	add	sp, #8
   167bc:	bd10      	pop	{r4, pc}
   167be:	bf00      	nop
   167c0:	00016785 	.word	0x00016785

000167c4 <Gpio::SetEdgeRising()>:
    *interrupt[triggered_port].clear |= (1 << triggered_pin);
  }

 private:
  // Sets the gpio interrupt to trigger on a rising edge.
  void SetEdgeRising()
   167c4:	b530      	push	{r4, r5, lr}
   167c6:	b083      	sub	sp, #12
   167c8:	4675      	mov	r5, lr
   167ca:	9001      	str	r0, [sp, #4]
   167cc:	462b      	mov	r3, r5
   167ce:	4619      	mov	r1, r3
   167d0:	4819      	ldr	r0, [pc, #100]	; (16838 <Gpio::SetEdgeRising()+0x74>)
   167d2:	f7fc febd 	bl	13550 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge |= (1 << pin_->GetPin());
   167d6:	9b01      	ldr	r3, [sp, #4]
   167d8:	689a      	ldr	r2, [r3, #8]
   167da:	9b01      	ldr	r3, [sp, #4]
   167dc:	689b      	ldr	r3, [r3, #8]
   167de:	681b      	ldr	r3, [r3, #0]
   167e0:	3330      	adds	r3, #48	; 0x30
   167e2:	681b      	ldr	r3, [r3, #0]
   167e4:	4610      	mov	r0, r2
   167e6:	4798      	blx	r3
   167e8:	4603      	mov	r3, r0
   167ea:	461a      	mov	r2, r3
   167ec:	2301      	movs	r3, #1
   167ee:	fa03 f002 	lsl.w	r0, r3, r2
   167f2:	9b01      	ldr	r3, [sp, #4]
   167f4:	791b      	ldrb	r3, [r3, #4]
   167f6:	4619      	mov	r1, r3
   167f8:	4a10      	ldr	r2, [pc, #64]	; (1683c <Gpio::SetEdgeRising()+0x78>)
   167fa:	460b      	mov	r3, r1
   167fc:	009b      	lsls	r3, r3, #2
   167fe:	440b      	add	r3, r1
   16800:	009b      	lsls	r3, r3, #2
   16802:	4413      	add	r3, r2
   16804:	330c      	adds	r3, #12
   16806:	681b      	ldr	r3, [r3, #0]
   16808:	681a      	ldr	r2, [r3, #0]
   1680a:	4604      	mov	r4, r0
   1680c:	9b01      	ldr	r3, [sp, #4]
   1680e:	791b      	ldrb	r3, [r3, #4]
   16810:	4618      	mov	r0, r3
   16812:	490a      	ldr	r1, [pc, #40]	; (1683c <Gpio::SetEdgeRising()+0x78>)
   16814:	4603      	mov	r3, r0
   16816:	009b      	lsls	r3, r3, #2
   16818:	4403      	add	r3, r0
   1681a:	009b      	lsls	r3, r3, #2
   1681c:	440b      	add	r3, r1
   1681e:	330c      	adds	r3, #12
   16820:	681b      	ldr	r3, [r3, #0]
   16822:	4322      	orrs	r2, r4
   16824:	601a      	str	r2, [r3, #0]
   16826:	462b      	mov	r3, r5
   16828:	4619      	mov	r1, r3
   1682a:	4803      	ldr	r0, [pc, #12]	; (16838 <Gpio::SetEdgeRising()+0x74>)
   1682c:	f7fc fea4 	bl	13578 <__cyg_profile_func_exit>
  }
   16830:	bf00      	nop
   16832:	b003      	add	sp, #12
   16834:	bd30      	pop	{r4, r5, pc}
   16836:	bf00      	nop
   16838:	000167c5 	.word	0x000167c5
   1683c:	100001f4 	.word	0x100001f4

00016840 <Gpio::SetEdgeFalling()>:

  // Sets the gpio interrupt to trigger on a falling edge.
  void SetEdgeFalling()
   16840:	b530      	push	{r4, r5, lr}
   16842:	b083      	sub	sp, #12
   16844:	4675      	mov	r5, lr
   16846:	9001      	str	r0, [sp, #4]
   16848:	462b      	mov	r3, r5
   1684a:	4619      	mov	r1, r3
   1684c:	4819      	ldr	r0, [pc, #100]	; (168b4 <Gpio::SetEdgeFalling()+0x74>)
   1684e:	f7fc fe7f 	bl	13550 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge |= (1 << pin_->GetPin());
   16852:	9b01      	ldr	r3, [sp, #4]
   16854:	689a      	ldr	r2, [r3, #8]
   16856:	9b01      	ldr	r3, [sp, #4]
   16858:	689b      	ldr	r3, [r3, #8]
   1685a:	681b      	ldr	r3, [r3, #0]
   1685c:	3330      	adds	r3, #48	; 0x30
   1685e:	681b      	ldr	r3, [r3, #0]
   16860:	4610      	mov	r0, r2
   16862:	4798      	blx	r3
   16864:	4603      	mov	r3, r0
   16866:	461a      	mov	r2, r3
   16868:	2301      	movs	r3, #1
   1686a:	fa03 f002 	lsl.w	r0, r3, r2
   1686e:	9b01      	ldr	r3, [sp, #4]
   16870:	791b      	ldrb	r3, [r3, #4]
   16872:	4619      	mov	r1, r3
   16874:	4a10      	ldr	r2, [pc, #64]	; (168b8 <Gpio::SetEdgeFalling()+0x78>)
   16876:	460b      	mov	r3, r1
   16878:	009b      	lsls	r3, r3, #2
   1687a:	440b      	add	r3, r1
   1687c:	009b      	lsls	r3, r3, #2
   1687e:	4413      	add	r3, r2
   16880:	3310      	adds	r3, #16
   16882:	681b      	ldr	r3, [r3, #0]
   16884:	681a      	ldr	r2, [r3, #0]
   16886:	4604      	mov	r4, r0
   16888:	9b01      	ldr	r3, [sp, #4]
   1688a:	791b      	ldrb	r3, [r3, #4]
   1688c:	4618      	mov	r0, r3
   1688e:	490a      	ldr	r1, [pc, #40]	; (168b8 <Gpio::SetEdgeFalling()+0x78>)
   16890:	4603      	mov	r3, r0
   16892:	009b      	lsls	r3, r3, #2
   16894:	4403      	add	r3, r0
   16896:	009b      	lsls	r3, r3, #2
   16898:	440b      	add	r3, r1
   1689a:	3310      	adds	r3, #16
   1689c:	681b      	ldr	r3, [r3, #0]
   1689e:	4322      	orrs	r2, r4
   168a0:	601a      	str	r2, [r3, #0]
   168a2:	462b      	mov	r3, r5
   168a4:	4619      	mov	r1, r3
   168a6:	4803      	ldr	r0, [pc, #12]	; (168b4 <Gpio::SetEdgeFalling()+0x74>)
   168a8:	f7fc fe66 	bl	13578 <__cyg_profile_func_exit>
  }
   168ac:	bf00      	nop
   168ae:	b003      	add	sp, #12
   168b0:	bd30      	pop	{r4, r5, pc}
   168b2:	bf00      	nop
   168b4:	00016841 	.word	0x00016841
   168b8:	100001f4 	.word	0x100001f4

000168bc <Gpio::ClearEdgeRising()>:

  // Clears the gpio interrupt to no longer trigger on a rising edge.
  void ClearEdgeRising()
   168bc:	b530      	push	{r4, r5, lr}
   168be:	b083      	sub	sp, #12
   168c0:	4675      	mov	r5, lr
   168c2:	9001      	str	r0, [sp, #4]
   168c4:	462b      	mov	r3, r5
   168c6:	4619      	mov	r1, r3
   168c8:	4819      	ldr	r0, [pc, #100]	; (16930 <Gpio::ClearEdgeRising()+0x74>)
   168ca:	f7fc fe41 	bl	13550 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge &= ~(1 << pin_->GetPin());
   168ce:	9b01      	ldr	r3, [sp, #4]
   168d0:	689a      	ldr	r2, [r3, #8]
   168d2:	9b01      	ldr	r3, [sp, #4]
   168d4:	689b      	ldr	r3, [r3, #8]
   168d6:	681b      	ldr	r3, [r3, #0]
   168d8:	3330      	adds	r3, #48	; 0x30
   168da:	681b      	ldr	r3, [r3, #0]
   168dc:	4610      	mov	r0, r2
   168de:	4798      	blx	r3
   168e0:	4603      	mov	r3, r0
   168e2:	461a      	mov	r2, r3
   168e4:	2301      	movs	r3, #1
   168e6:	4093      	lsls	r3, r2
   168e8:	43d8      	mvns	r0, r3
   168ea:	9b01      	ldr	r3, [sp, #4]
   168ec:	791b      	ldrb	r3, [r3, #4]
   168ee:	4619      	mov	r1, r3
   168f0:	4a10      	ldr	r2, [pc, #64]	; (16934 <Gpio::ClearEdgeRising()+0x78>)
   168f2:	460b      	mov	r3, r1
   168f4:	009b      	lsls	r3, r3, #2
   168f6:	440b      	add	r3, r1
   168f8:	009b      	lsls	r3, r3, #2
   168fa:	4413      	add	r3, r2
   168fc:	330c      	adds	r3, #12
   168fe:	681b      	ldr	r3, [r3, #0]
   16900:	681a      	ldr	r2, [r3, #0]
   16902:	4604      	mov	r4, r0
   16904:	9b01      	ldr	r3, [sp, #4]
   16906:	791b      	ldrb	r3, [r3, #4]
   16908:	4618      	mov	r0, r3
   1690a:	490a      	ldr	r1, [pc, #40]	; (16934 <Gpio::ClearEdgeRising()+0x78>)
   1690c:	4603      	mov	r3, r0
   1690e:	009b      	lsls	r3, r3, #2
   16910:	4403      	add	r3, r0
   16912:	009b      	lsls	r3, r3, #2
   16914:	440b      	add	r3, r1
   16916:	330c      	adds	r3, #12
   16918:	681b      	ldr	r3, [r3, #0]
   1691a:	4022      	ands	r2, r4
   1691c:	601a      	str	r2, [r3, #0]
   1691e:	462b      	mov	r3, r5
   16920:	4619      	mov	r1, r3
   16922:	4803      	ldr	r0, [pc, #12]	; (16930 <Gpio::ClearEdgeRising()+0x74>)
   16924:	f7fc fe28 	bl	13578 <__cyg_profile_func_exit>
  }
   16928:	bf00      	nop
   1692a:	b003      	add	sp, #12
   1692c:	bd30      	pop	{r4, r5, pc}
   1692e:	bf00      	nop
   16930:	000168bd 	.word	0x000168bd
   16934:	100001f4 	.word	0x100001f4

00016938 <Gpio::ClearEdgeFalling()>:

  // Clears the gpio interrupt to no longer trigger on a falling edge.
  void ClearEdgeFalling()
   16938:	b530      	push	{r4, r5, lr}
   1693a:	b083      	sub	sp, #12
   1693c:	4675      	mov	r5, lr
   1693e:	9001      	str	r0, [sp, #4]
   16940:	462b      	mov	r3, r5
   16942:	4619      	mov	r1, r3
   16944:	4819      	ldr	r0, [pc, #100]	; (169ac <Gpio::ClearEdgeFalling()+0x74>)
   16946:	f7fc fe03 	bl	13550 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge &= ~(1 << pin_->GetPin());
   1694a:	9b01      	ldr	r3, [sp, #4]
   1694c:	689a      	ldr	r2, [r3, #8]
   1694e:	9b01      	ldr	r3, [sp, #4]
   16950:	689b      	ldr	r3, [r3, #8]
   16952:	681b      	ldr	r3, [r3, #0]
   16954:	3330      	adds	r3, #48	; 0x30
   16956:	681b      	ldr	r3, [r3, #0]
   16958:	4610      	mov	r0, r2
   1695a:	4798      	blx	r3
   1695c:	4603      	mov	r3, r0
   1695e:	461a      	mov	r2, r3
   16960:	2301      	movs	r3, #1
   16962:	4093      	lsls	r3, r2
   16964:	43d8      	mvns	r0, r3
   16966:	9b01      	ldr	r3, [sp, #4]
   16968:	791b      	ldrb	r3, [r3, #4]
   1696a:	4619      	mov	r1, r3
   1696c:	4a10      	ldr	r2, [pc, #64]	; (169b0 <Gpio::ClearEdgeFalling()+0x78>)
   1696e:	460b      	mov	r3, r1
   16970:	009b      	lsls	r3, r3, #2
   16972:	440b      	add	r3, r1
   16974:	009b      	lsls	r3, r3, #2
   16976:	4413      	add	r3, r2
   16978:	3310      	adds	r3, #16
   1697a:	681b      	ldr	r3, [r3, #0]
   1697c:	681a      	ldr	r2, [r3, #0]
   1697e:	4604      	mov	r4, r0
   16980:	9b01      	ldr	r3, [sp, #4]
   16982:	791b      	ldrb	r3, [r3, #4]
   16984:	4618      	mov	r0, r3
   16986:	490a      	ldr	r1, [pc, #40]	; (169b0 <Gpio::ClearEdgeFalling()+0x78>)
   16988:	4603      	mov	r3, r0
   1698a:	009b      	lsls	r3, r3, #2
   1698c:	4403      	add	r3, r0
   1698e:	009b      	lsls	r3, r3, #2
   16990:	440b      	add	r3, r1
   16992:	3310      	adds	r3, #16
   16994:	681b      	ldr	r3, [r3, #0]
   16996:	4022      	ands	r2, r4
   16998:	601a      	str	r2, [r3, #0]
   1699a:	462b      	mov	r3, r5
   1699c:	4619      	mov	r1, r3
   1699e:	4803      	ldr	r0, [pc, #12]	; (169ac <Gpio::ClearEdgeFalling()+0x74>)
   169a0:	f7fc fdea 	bl	13578 <__cyg_profile_func_exit>
  }
   169a4:	bf00      	nop
   169a6:	b003      	add	sp, #12
   169a8:	bd30      	pop	{r4, r5, pc}
   169aa:	bf00      	nop
   169ac:	00016939 	.word	0x00016939
   169b0:	100001f4 	.word	0x100001f4

000169b4 <SystemControllerInterface::SystemControllerInterface()>:
class SystemControllerInterface
   169b4:	b082      	sub	sp, #8
   169b6:	9001      	str	r0, [sp, #4]
   169b8:	4a03      	ldr	r2, [pc, #12]	; (169c8 <SystemControllerInterface::SystemControllerInterface()+0x14>)
   169ba:	9b01      	ldr	r3, [sp, #4]
   169bc:	601a      	str	r2, [r3, #0]
   169be:	9b01      	ldr	r3, [sp, #4]
   169c0:	4618      	mov	r0, r3
   169c2:	b002      	add	sp, #8
   169c4:	4770      	bx	lr
   169c6:	bf00      	nop
   169c8:	0001b058 	.word	0x0001b058

000169cc <Lpc40xxSystemController::Lpc40xxSystemController()>:
  constexpr Lpc40xxSystemController() {}
   169cc:	b500      	push	{lr}
   169ce:	b083      	sub	sp, #12
   169d0:	9001      	str	r0, [sp, #4]
   169d2:	9b01      	ldr	r3, [sp, #4]
   169d4:	4618      	mov	r0, r3
   169d6:	f7ff ffed 	bl	169b4 <SystemControllerInterface::SystemControllerInterface()>
   169da:	4a04      	ldr	r2, [pc, #16]	; (169ec <Lpc40xxSystemController::Lpc40xxSystemController()+0x20>)
   169dc:	9b01      	ldr	r3, [sp, #4]
   169de:	601a      	str	r2, [r3, #0]
   169e0:	9b01      	ldr	r3, [sp, #4]
   169e2:	4618      	mov	r0, r3
   169e4:	b003      	add	sp, #12
   169e6:	f85d fb04 	ldr.w	pc, [sp], #4
   169ea:	bf00      	nop
   169ec:	00019ab4 	.word	0x00019ab4

000169f0 <SspInterface::SspInterface()>:
class SspInterface
   169f0:	b530      	push	{r4, r5, lr}
   169f2:	b083      	sub	sp, #12
   169f4:	4675      	mov	r5, lr
   169f6:	9001      	str	r0, [sp, #4]
   169f8:	462b      	mov	r3, r5
   169fa:	4619      	mov	r1, r3
   169fc:	4807      	ldr	r0, [pc, #28]	; (16a1c <SspInterface::SspInterface()+0x2c>)
   169fe:	f7fc fda7 	bl	13550 <__cyg_profile_func_enter>
   16a02:	4a07      	ldr	r2, [pc, #28]	; (16a20 <SspInterface::SspInterface()+0x30>)
   16a04:	9b01      	ldr	r3, [sp, #4]
   16a06:	601a      	str	r2, [r3, #0]
   16a08:	9c01      	ldr	r4, [sp, #4]
   16a0a:	462b      	mov	r3, r5
   16a0c:	4619      	mov	r1, r3
   16a0e:	4803      	ldr	r0, [pc, #12]	; (16a1c <SspInterface::SspInterface()+0x2c>)
   16a10:	f7fc fdb2 	bl	13578 <__cyg_profile_func_exit>
   16a14:	4623      	mov	r3, r4
   16a16:	4618      	mov	r0, r3
   16a18:	b003      	add	sp, #12
   16a1a:	bd30      	pop	{r4, r5, pc}
   16a1c:	000169f1 	.word	0x000169f1
   16a20:	0001b030 	.word	0x0001b030

00016a24 <PinInterface::PinInterface(PinInterface const&)>:
class PinInterface
   16a24:	b530      	push	{r4, r5, lr}
   16a26:	b083      	sub	sp, #12
   16a28:	4675      	mov	r5, lr
   16a2a:	9001      	str	r0, [sp, #4]
   16a2c:	9100      	str	r1, [sp, #0]
   16a2e:	462b      	mov	r3, r5
   16a30:	4619      	mov	r1, r3
   16a32:	4808      	ldr	r0, [pc, #32]	; (16a54 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   16a34:	f7fc fd8c 	bl	13550 <__cyg_profile_func_enter>
   16a38:	4a07      	ldr	r2, [pc, #28]	; (16a58 <PinInterface::PinInterface(PinInterface const&)+0x34>)
   16a3a:	9b01      	ldr	r3, [sp, #4]
   16a3c:	601a      	str	r2, [r3, #0]
   16a3e:	9c01      	ldr	r4, [sp, #4]
   16a40:	462b      	mov	r3, r5
   16a42:	4619      	mov	r1, r3
   16a44:	4803      	ldr	r0, [pc, #12]	; (16a54 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   16a46:	f7fc fd97 	bl	13578 <__cyg_profile_func_exit>
   16a4a:	4623      	mov	r3, r4
   16a4c:	4618      	mov	r0, r3
   16a4e:	b003      	add	sp, #12
   16a50:	bd30      	pop	{r4, r5, pc}
   16a52:	bf00      	nop
   16a54:	00016a25 	.word	0x00016a25
   16a58:	0001b10c 	.word	0x0001b10c

00016a5c <Pin::Pin(Pin const&)>:
class Pin : public PinInterface
   16a5c:	b530      	push	{r4, r5, lr}
   16a5e:	b083      	sub	sp, #12
   16a60:	4675      	mov	r5, lr
   16a62:	9001      	str	r0, [sp, #4]
   16a64:	9100      	str	r1, [sp, #0]
   16a66:	462b      	mov	r3, r5
   16a68:	4619      	mov	r1, r3
   16a6a:	480f      	ldr	r0, [pc, #60]	; (16aa8 <Pin::Pin(Pin const&)+0x4c>)
   16a6c:	f7fc fd70 	bl	13550 <__cyg_profile_func_enter>
   16a70:	9b01      	ldr	r3, [sp, #4]
   16a72:	9a00      	ldr	r2, [sp, #0]
   16a74:	4611      	mov	r1, r2
   16a76:	4618      	mov	r0, r3
   16a78:	f7ff ffd4 	bl	16a24 <PinInterface::PinInterface(PinInterface const&)>
   16a7c:	4a0b      	ldr	r2, [pc, #44]	; (16aac <Pin::Pin(Pin const&)+0x50>)
   16a7e:	9b01      	ldr	r3, [sp, #4]
   16a80:	601a      	str	r2, [r3, #0]
   16a82:	9b00      	ldr	r3, [sp, #0]
   16a84:	791a      	ldrb	r2, [r3, #4]
   16a86:	9b01      	ldr	r3, [sp, #4]
   16a88:	711a      	strb	r2, [r3, #4]
   16a8a:	9b00      	ldr	r3, [sp, #0]
   16a8c:	795a      	ldrb	r2, [r3, #5]
   16a8e:	9b01      	ldr	r3, [sp, #4]
   16a90:	715a      	strb	r2, [r3, #5]
   16a92:	9c01      	ldr	r4, [sp, #4]
   16a94:	462b      	mov	r3, r5
   16a96:	4619      	mov	r1, r3
   16a98:	4803      	ldr	r0, [pc, #12]	; (16aa8 <Pin::Pin(Pin const&)+0x4c>)
   16a9a:	f7fc fd6d 	bl	13578 <__cyg_profile_func_exit>
   16a9e:	4623      	mov	r3, r4
   16aa0:	4618      	mov	r0, r3
   16aa2:	b003      	add	sp, #12
   16aa4:	bd30      	pop	{r4, r5, pc}
   16aa6:	bf00      	nop
   16aa8:	00016a5d 	.word	0x00016a5d
   16aac:	00019a40 	.word	0x00019a40

00016ab0 <Ssp::Ssp(Ssp::Peripheral)>:
  explicit constexpr Ssp(Peripheral set_pssp)
   16ab0:	b530      	push	{r4, r5, lr}
   16ab2:	b083      	sub	sp, #12
   16ab4:	4675      	mov	r5, lr
   16ab6:	9001      	str	r0, [sp, #4]
   16ab8:	9100      	str	r1, [sp, #0]
   16aba:	462b      	mov	r3, r5
   16abc:	4619      	mov	r1, r3
   16abe:	4831      	ldr	r0, [pc, #196]	; (16b84 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   16ac0:	f7fc fd46 	bl	13550 <__cyg_profile_func_enter>
        pssp_(set_pssp)
   16ac4:	9b01      	ldr	r3, [sp, #4]
   16ac6:	4618      	mov	r0, r3
   16ac8:	f7ff ff92 	bl	169f0 <SspInterface::SspInterface()>
   16acc:	9b01      	ldr	r3, [sp, #4]
   16ace:	3304      	adds	r3, #4
   16ad0:	4618      	mov	r0, r3
   16ad2:	f7ff ff7b 	bl	169cc <Lpc40xxSystemController::Lpc40xxSystemController()>
   16ad6:	4a2c      	ldr	r2, [pc, #176]	; (16b88 <Ssp::Ssp(Ssp::Peripheral)+0xd8>)
   16ad8:	9b01      	ldr	r3, [sp, #4]
   16ada:	601a      	str	r2, [r3, #0]
   16adc:	4a2b      	ldr	r2, [pc, #172]	; (16b8c <Ssp::Ssp(Ssp::Peripheral)+0xdc>)
   16ade:	9b01      	ldr	r3, [sp, #4]
   16ae0:	605a      	str	r2, [r3, #4]
   16ae2:	9b01      	ldr	r3, [sp, #4]
   16ae4:	f103 0214 	add.w	r2, r3, #20
   16ae8:	9b01      	ldr	r3, [sp, #4]
   16aea:	609a      	str	r2, [r3, #8]
   16aec:	9b01      	ldr	r3, [sp, #4]
   16aee:	f103 021c 	add.w	r2, r3, #28
   16af2:	9b01      	ldr	r3, [sp, #4]
   16af4:	60da      	str	r2, [r3, #12]
   16af6:	9b01      	ldr	r3, [sp, #4]
   16af8:	f103 0224 	add.w	r2, r3, #36	; 0x24
   16afc:	9b01      	ldr	r3, [sp, #4]
   16afe:	611a      	str	r2, [r3, #16]
   16b00:	9b01      	ldr	r3, [sp, #4]
   16b02:	f103 0414 	add.w	r4, r3, #20
        mosi_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMosi]),
   16b06:	9800      	ldr	r0, [sp, #0]
   16b08:	f7fa f812 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16b0c:	4602      	mov	r2, r0
        pssp_(set_pssp)
   16b0e:	4613      	mov	r3, r2
   16b10:	005b      	lsls	r3, r3, #1
   16b12:	4413      	add	r3, r2
   16b14:	00db      	lsls	r3, r3, #3
   16b16:	4a1e      	ldr	r2, [pc, #120]	; (16b90 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   16b18:	4413      	add	r3, r2
   16b1a:	4619      	mov	r1, r3
   16b1c:	4620      	mov	r0, r4
   16b1e:	f7ff ff9d 	bl	16a5c <Pin::Pin(Pin const&)>
   16b22:	9b01      	ldr	r3, [sp, #4]
   16b24:	f103 041c 	add.w	r4, r3, #28
        miso_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMiso]),
   16b28:	9800      	ldr	r0, [sp, #0]
   16b2a:	f7fa f801 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16b2e:	4602      	mov	r2, r0
        pssp_(set_pssp)
   16b30:	4613      	mov	r3, r2
   16b32:	005b      	lsls	r3, r3, #1
   16b34:	4413      	add	r3, r2
   16b36:	00db      	lsls	r3, r3, #3
   16b38:	3308      	adds	r3, #8
   16b3a:	4a15      	ldr	r2, [pc, #84]	; (16b90 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   16b3c:	4413      	add	r3, r2
   16b3e:	4619      	mov	r1, r3
   16b40:	4620      	mov	r0, r4
   16b42:	f7ff ff8b 	bl	16a5c <Pin::Pin(Pin const&)>
   16b46:	9b01      	ldr	r3, [sp, #4]
   16b48:	f103 0424 	add.w	r4, r3, #36	; 0x24
        sck_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kSck]),
   16b4c:	9800      	ldr	r0, [sp, #0]
   16b4e:	f7f9 ffef 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16b52:	4602      	mov	r2, r0
        pssp_(set_pssp)
   16b54:	4613      	mov	r3, r2
   16b56:	005b      	lsls	r3, r3, #1
   16b58:	4413      	add	r3, r2
   16b5a:	00db      	lsls	r3, r3, #3
   16b5c:	3310      	adds	r3, #16
   16b5e:	4a0c      	ldr	r2, [pc, #48]	; (16b90 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   16b60:	4413      	add	r3, r2
   16b62:	4619      	mov	r1, r3
   16b64:	4620      	mov	r0, r4
   16b66:	f7ff ff79 	bl	16a5c <Pin::Pin(Pin const&)>
   16b6a:	9b01      	ldr	r3, [sp, #4]
   16b6c:	9a00      	ldr	r2, [sp, #0]
   16b6e:	62da      	str	r2, [r3, #44]	; 0x2c
  }
   16b70:	9c01      	ldr	r4, [sp, #4]
   16b72:	462b      	mov	r3, r5
   16b74:	4619      	mov	r1, r3
   16b76:	4803      	ldr	r0, [pc, #12]	; (16b84 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   16b78:	f7fc fcfe 	bl	13578 <__cyg_profile_func_exit>
   16b7c:	4623      	mov	r3, r4
   16b7e:	4618      	mov	r0, r3
   16b80:	b003      	add	sp, #12
   16b82:	bd30      	pop	{r4, r5, pc}
   16b84:	00016ab1 	.word	0x00016ab1
   16b88:	0001afe4 	.word	0x0001afe4
   16b8c:	0001b00c 	.word	0x0001b00c
   16b90:	0001ab98 	.word	0x0001ab98

00016b94 <Ssp::Initialize()>:
  void Initialize() override
   16b94:	b570      	push	{r4, r5, r6, lr}
   16b96:	b086      	sub	sp, #24
   16b98:	4676      	mov	r6, lr
   16b9a:	9001      	str	r0, [sp, #4]
   16b9c:	4633      	mov	r3, r6
   16b9e:	4619      	mov	r1, r3
   16ba0:	4830      	ldr	r0, [pc, #192]	; (16c64 <Ssp::Initialize()+0xd0>)
   16ba2:	f7fc fcd5 	bl	13550 <__cyg_profile_func_enter>
    uint32_t pssp = util::Value(pssp_);
   16ba6:	9b01      	ldr	r3, [sp, #4]
   16ba8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16baa:	4618      	mov	r0, r3
   16bac:	f7f9 ffc0 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16bb0:	4603      	mov	r3, r0
   16bb2:	9305      	str	r3, [sp, #20]
    PowerUpPeripheral(kPowerBit[pssp]);
   16bb4:	9b01      	ldr	r3, [sp, #4]
   16bb6:	1d18      	adds	r0, r3, #4
   16bb8:	9b01      	ldr	r3, [sp, #4]
   16bba:	685b      	ldr	r3, [r3, #4]
   16bbc:	3314      	adds	r3, #20
   16bbe:	681b      	ldr	r3, [r3, #0]
   16bc0:	9a05      	ldr	r2, [sp, #20]
   16bc2:	0092      	lsls	r2, r2, #2
   16bc4:	4928      	ldr	r1, [pc, #160]	; (16c68 <Ssp::Initialize()+0xd4>)
   16bc6:	440a      	add	r2, r1
   16bc8:	4611      	mov	r1, r2
   16bca:	4798      	blx	r3
    mosi_->SetPinFunction(kPinSelect[pssp]);
   16bcc:	9b01      	ldr	r3, [sp, #4]
   16bce:	6898      	ldr	r0, [r3, #8]
   16bd0:	9b01      	ldr	r3, [sp, #4]
   16bd2:	689b      	ldr	r3, [r3, #8]
   16bd4:	681b      	ldr	r3, [r3, #0]
   16bd6:	681b      	ldr	r3, [r3, #0]
   16bd8:	4924      	ldr	r1, [pc, #144]	; (16c6c <Ssp::Initialize()+0xd8>)
   16bda:	9a05      	ldr	r2, [sp, #20]
   16bdc:	440a      	add	r2, r1
   16bde:	7812      	ldrb	r2, [r2, #0]
   16be0:	4611      	mov	r1, r2
   16be2:	4798      	blx	r3
    miso_->SetPinFunction(kPinSelect[pssp]);
   16be4:	9b01      	ldr	r3, [sp, #4]
   16be6:	68d8      	ldr	r0, [r3, #12]
   16be8:	9b01      	ldr	r3, [sp, #4]
   16bea:	68db      	ldr	r3, [r3, #12]
   16bec:	681b      	ldr	r3, [r3, #0]
   16bee:	681b      	ldr	r3, [r3, #0]
   16bf0:	491e      	ldr	r1, [pc, #120]	; (16c6c <Ssp::Initialize()+0xd8>)
   16bf2:	9a05      	ldr	r2, [sp, #20]
   16bf4:	440a      	add	r2, r1
   16bf6:	7812      	ldrb	r2, [r2, #0]
   16bf8:	4611      	mov	r1, r2
   16bfa:	4798      	blx	r3
    sck_->SetPinFunction(kPinSelect[pssp]);
   16bfc:	9b01      	ldr	r3, [sp, #4]
   16bfe:	6918      	ldr	r0, [r3, #16]
   16c00:	9b01      	ldr	r3, [sp, #4]
   16c02:	691b      	ldr	r3, [r3, #16]
   16c04:	681b      	ldr	r3, [r3, #0]
   16c06:	681b      	ldr	r3, [r3, #0]
   16c08:	4918      	ldr	r1, [pc, #96]	; (16c6c <Ssp::Initialize()+0xd8>)
   16c0a:	9a05      	ldr	r2, [sp, #20]
   16c0c:	440a      	add	r2, r1
   16c0e:	7812      	ldrb	r2, [r2, #0]
   16c10:	4611      	mov	r1, r2
   16c12:	4798      	blx	r3
    ssp_registers[pssp]->CR1 = bit::Set(ssp_registers[pssp]->CR1, kSspEnable);
   16c14:	4a16      	ldr	r2, [pc, #88]	; (16c70 <Ssp::Initialize()+0xdc>)
   16c16:	9b05      	ldr	r3, [sp, #20]
   16c18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16c1c:	685b      	ldr	r3, [r3, #4]
   16c1e:	4914      	ldr	r1, [pc, #80]	; (16c70 <Ssp::Initialize()+0xdc>)
   16c20:	9a05      	ldr	r2, [sp, #20]
   16c22:	f851 4022 	ldr.w	r4, [r1, r2, lsl #2]
   16c26:	9304      	str	r3, [sp, #16]
   16c28:	2301      	movs	r3, #1
   16c2a:	9303      	str	r3, [sp, #12]
   16c2c:	4633      	mov	r3, r6
   16c2e:	4619      	mov	r1, r3
   16c30:	4810      	ldr	r0, [pc, #64]	; (16c74 <Ssp::Initialize()+0xe0>)
   16c32:	f7fc fc8d 	bl	13550 <__cyg_profile_func_enter>
  return target | (1 << position);
   16c36:	2201      	movs	r2, #1
   16c38:	9b03      	ldr	r3, [sp, #12]
   16c3a:	fa02 f303 	lsl.w	r3, r2, r3
   16c3e:	461a      	mov	r2, r3
   16c40:	9b04      	ldr	r3, [sp, #16]
   16c42:	ea42 0503 	orr.w	r5, r2, r3
   16c46:	4633      	mov	r3, r6
   16c48:	4619      	mov	r1, r3
   16c4a:	480a      	ldr	r0, [pc, #40]	; (16c74 <Ssp::Initialize()+0xe0>)
   16c4c:	f7fc fc94 	bl	13578 <__cyg_profile_func_exit>
   16c50:	6065      	str	r5, [r4, #4]
   16c52:	4633      	mov	r3, r6
   16c54:	4619      	mov	r1, r3
   16c56:	4803      	ldr	r0, [pc, #12]	; (16c64 <Ssp::Initialize()+0xd0>)
   16c58:	f7fc fc8e 	bl	13578 <__cyg_profile_func_exit>
  }
   16c5c:	bf00      	nop
   16c5e:	b006      	add	sp, #24
   16c60:	bd70      	pop	{r4, r5, r6, pc}
   16c62:	bf00      	nop
   16c64:	00016b95 	.word	0x00016b95
   16c68:	0001abe0 	.word	0x0001abe0
   16c6c:	0001ab94 	.word	0x0001ab94
   16c70:	1000005c 	.word	0x1000005c
   16c74:	00018711 	.word	0x00018711

00016c78 <Ssp::SetSpiMasterDefault()>:

  /// Sets up SSP peripheral as SPI master
  void SetSpiMasterDefault() override
   16c78:	b510      	push	{r4, lr}
   16c7a:	b086      	sub	sp, #24
   16c7c:	4674      	mov	r4, lr
   16c7e:	9003      	str	r0, [sp, #12]
   16c80:	4623      	mov	r3, r4
   16c82:	4619      	mov	r1, r3
   16c84:	4812      	ldr	r0, [pc, #72]	; (16cd0 <Ssp::SetSpiMasterDefault()+0x58>)
   16c86:	f7fc fc63 	bl	13550 <__cyg_profile_func_enter>
  {
    constexpr bool kHighPolarity  = 1;
   16c8a:	2301      	movs	r3, #1
   16c8c:	f88d 3017 	strb.w	r3, [sp, #23]
    constexpr bool kPhase0        = 0;
   16c90:	2300      	movs	r3, #0
   16c92:	f88d 3016 	strb.w	r3, [sp, #22]
    constexpr uint8_t kScrDivider = 0;
   16c96:	2300      	movs	r3, #0
   16c98:	f88d 3015 	strb.w	r3, [sp, #21]
    constexpr uint8_t kPrescaler  = SJ2_SYSTEM_CLOCK_RATE_MHZ;
   16c9c:	2330      	movs	r3, #48	; 0x30
   16c9e:	f88d 3014 	strb.w	r3, [sp, #20]

    SetPeripheralMode(kMaster, kSpi, kEight);
   16ca2:	2307      	movs	r3, #7
   16ca4:	2200      	movs	r2, #0
   16ca6:	2100      	movs	r1, #0
   16ca8:	9803      	ldr	r0, [sp, #12]
   16caa:	f000 f85b 	bl	16d64 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
    SetClock(kHighPolarity, kPhase0, kScrDivider, kPrescaler);
   16cae:	2330      	movs	r3, #48	; 0x30
   16cb0:	9300      	str	r3, [sp, #0]
   16cb2:	2300      	movs	r3, #0
   16cb4:	2200      	movs	r2, #0
   16cb6:	2101      	movs	r1, #1
   16cb8:	9803      	ldr	r0, [sp, #12]
   16cba:	f000 fa09 	bl	170d0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
   16cbe:	4623      	mov	r3, r4
   16cc0:	4619      	mov	r1, r3
   16cc2:	4803      	ldr	r0, [pc, #12]	; (16cd0 <Ssp::SetSpiMasterDefault()+0x58>)
   16cc4:	f7fc fc58 	bl	13578 <__cyg_profile_func_exit>
  }
   16cc8:	bf00      	nop
   16cca:	b006      	add	sp, #24
   16ccc:	bd10      	pop	{r4, pc}
   16cce:	bf00      	nop
   16cd0:	00016c79 	.word	0x00016c79

00016cd4 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>:
constexpr Type Value(Enum enum_type_value)
   16cd4:	b530      	push	{r4, r5, lr}
   16cd6:	b083      	sub	sp, #12
   16cd8:	4675      	mov	r5, lr
   16cda:	4603      	mov	r3, r0
   16cdc:	f88d 3007 	strb.w	r3, [sp, #7]
   16ce0:	462b      	mov	r3, r5
   16ce2:	4619      	mov	r1, r3
   16ce4:	4806      	ldr	r0, [pc, #24]	; (16d00 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   16ce6:	f7fc fc33 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   16cea:	f89d 4007 	ldrb.w	r4, [sp, #7]
   16cee:	462b      	mov	r3, r5
   16cf0:	4619      	mov	r1, r3
   16cf2:	4803      	ldr	r0, [pc, #12]	; (16d00 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   16cf4:	f7fc fc40 	bl	13578 <__cyg_profile_func_exit>
   16cf8:	4623      	mov	r3, r4
}
   16cfa:	4618      	mov	r0, r3
   16cfc:	b003      	add	sp, #12
   16cfe:	bd30      	pop	{r4, r5, pc}
   16d00:	00016cd5 	.word	0x00016cd5

00016d04 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>:
constexpr Type Value(Enum enum_type_value)
   16d04:	b530      	push	{r4, r5, lr}
   16d06:	b083      	sub	sp, #12
   16d08:	4675      	mov	r5, lr
   16d0a:	4603      	mov	r3, r0
   16d0c:	f88d 3007 	strb.w	r3, [sp, #7]
   16d10:	462b      	mov	r3, r5
   16d12:	4619      	mov	r1, r3
   16d14:	4806      	ldr	r0, [pc, #24]	; (16d30 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   16d16:	f7fc fc1b 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   16d1a:	f89d 4007 	ldrb.w	r4, [sp, #7]
   16d1e:	462b      	mov	r3, r5
   16d20:	4619      	mov	r1, r3
   16d22:	4803      	ldr	r0, [pc, #12]	; (16d30 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   16d24:	f7fc fc28 	bl	13578 <__cyg_profile_func_exit>
   16d28:	4623      	mov	r3, r4
}
   16d2a:	4618      	mov	r0, r3
   16d2c:	b003      	add	sp, #12
   16d2e:	bd30      	pop	{r4, r5, pc}
   16d30:	00016d05 	.word	0x00016d05

00016d34 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>:
constexpr Type Value(Enum enum_type_value)
   16d34:	b530      	push	{r4, r5, lr}
   16d36:	b083      	sub	sp, #12
   16d38:	4675      	mov	r5, lr
   16d3a:	4603      	mov	r3, r0
   16d3c:	f88d 3007 	strb.w	r3, [sp, #7]
   16d40:	462b      	mov	r3, r5
   16d42:	4619      	mov	r1, r3
   16d44:	4806      	ldr	r0, [pc, #24]	; (16d60 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   16d46:	f7fc fc03 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   16d4a:	f89d 4007 	ldrb.w	r4, [sp, #7]
   16d4e:	462b      	mov	r3, r5
   16d50:	4619      	mov	r1, r3
   16d52:	4803      	ldr	r0, [pc, #12]	; (16d60 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   16d54:	f7fc fc10 	bl	13578 <__cyg_profile_func_exit>
   16d58:	4623      	mov	r3, r4
}
   16d5a:	4618      	mov	r0, r3
   16d5c:	b003      	add	sp, #12
   16d5e:	bd30      	pop	{r4, r5, pc}
   16d60:	00016d35 	.word	0x00016d35

00016d64 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>:

  /// Sets the various modes for the Peripheral
  /// @param mode - master or slave mode
  /// @param frame - format for Peripheral data to use
  /// @param size - number of bits per frame
  void SetPeripheralMode(MasterSlaveMode mode, FrameMode frame,
   16d64:	b570      	push	{r4, r5, r6, lr}
   16d66:	b098      	sub	sp, #96	; 0x60
   16d68:	4674      	mov	r4, lr
   16d6a:	9001      	str	r0, [sp, #4]
   16d6c:	4608      	mov	r0, r1
   16d6e:	4611      	mov	r1, r2
   16d70:	461a      	mov	r2, r3
   16d72:	4603      	mov	r3, r0
   16d74:	f88d 3003 	strb.w	r3, [sp, #3]
   16d78:	460b      	mov	r3, r1
   16d7a:	f88d 3002 	strb.w	r3, [sp, #2]
   16d7e:	4613      	mov	r3, r2
   16d80:	f88d 3001 	strb.w	r3, [sp, #1]
   16d84:	4623      	mov	r3, r4
   16d86:	4619      	mov	r1, r3
   16d88:	4875      	ldr	r0, [pc, #468]	; (16f60 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   16d8a:	f7fc fbe1 	bl	13550 <__cyg_profile_func_enter>
                         DataSize size) override
  {
    uint32_t pssp = util::Value(pssp_);
   16d8e:	9b01      	ldr	r3, [sp, #4]
   16d90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16d92:	4618      	mov	r0, r3
   16d94:	f7f9 fecc 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16d98:	4603      	mov	r3, r0
   16d9a:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   16d9c:	9b01      	ldr	r3, [sp, #4]
   16d9e:	1d18      	adds	r0, r3, #4
   16da0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16da2:	009b      	lsls	r3, r3, #2
   16da4:	4a6f      	ldr	r2, [pc, #444]	; (16f64 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x200>)
   16da6:	4413      	add	r3, r2
   16da8:	4619      	mov	r1, r3
   16daa:	f7fa fa7b 	bl	112a4 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    if (frame == kMicro)
   16dae:	f89d 3002 	ldrb.w	r3, [sp, #2]
   16db2:	2b02      	cmp	r3, #2
   16db4:	d102      	bne.n	16dbc <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x58>
    {
      size = kEight;
   16db6:	2307      	movs	r3, #7
   16db8:	f88d 3001 	strb.w	r3, [sp, #1]
    }
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(size), kDataBit, 4);
   16dbc:	4a6a      	ldr	r2, [pc, #424]	; (16f68 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16dbe:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16dc4:	681e      	ldr	r6, [r3, #0]
   16dc6:	f89d 3001 	ldrb.w	r3, [sp, #1]
   16dca:	4618      	mov	r0, r3
   16dcc:	f7ff ff82 	bl	16cd4 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>
   16dd0:	4603      	mov	r3, r0
   16dd2:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   16dd4:	4a64      	ldr	r2, [pc, #400]	; (16f68 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16dd6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16dd8:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   16ddc:	9608      	str	r6, [sp, #32]
   16dde:	460b      	mov	r3, r1
   16de0:	f88d 301f 	strb.w	r3, [sp, #31]
   16de4:	2300      	movs	r3, #0
   16de6:	9306      	str	r3, [sp, #24]
   16de8:	2304      	movs	r3, #4
   16dea:	9305      	str	r3, [sp, #20]
   16dec:	4623      	mov	r3, r4
   16dee:	4619      	mov	r1, r3
   16df0:	485e      	ldr	r0, [pc, #376]	; (16f6c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16df2:	f7fc fbad 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16df6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16dfa:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16dfc:	2320      	movs	r3, #32
   16dfe:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16e00:	9b05      	ldr	r3, [sp, #20]
   16e02:	f1c3 0320 	rsb	r3, r3, #32
   16e06:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16e0a:	fa22 f303 	lsr.w	r3, r2, r3
   16e0e:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   16e10:	9a02      	ldr	r2, [sp, #8]
   16e12:	9b06      	ldr	r3, [sp, #24]
   16e14:	fa02 f303 	lsl.w	r3, r2, r3
   16e18:	43db      	mvns	r3, r3
   16e1a:	9a08      	ldr	r2, [sp, #32]
   16e1c:	4013      	ands	r3, r2
   16e1e:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   16e20:	f89d 201f 	ldrb.w	r2, [sp, #31]
   16e24:	9b02      	ldr	r3, [sp, #8]
   16e26:	401a      	ands	r2, r3
   16e28:	9b06      	ldr	r3, [sp, #24]
   16e2a:	fa02 f303 	lsl.w	r3, r2, r3
   16e2e:	9a08      	ldr	r2, [sp, #32]
   16e30:	4313      	orrs	r3, r2
   16e32:	9308      	str	r3, [sp, #32]
  return target;
   16e34:	9e08      	ldr	r6, [sp, #32]
   16e36:	4623      	mov	r3, r4
   16e38:	4619      	mov	r1, r3
   16e3a:	484c      	ldr	r0, [pc, #304]	; (16f6c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16e3c:	f7fc fb9c 	bl	13578 <__cyg_profile_func_exit>
   16e40:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(frame), kFrameBit, 2);
   16e42:	4a49      	ldr	r2, [pc, #292]	; (16f68 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16e44:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16e46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16e4a:	681e      	ldr	r6, [r3, #0]
   16e4c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   16e50:	4618      	mov	r0, r3
   16e52:	f7ff ff57 	bl	16d04 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>
   16e56:	4603      	mov	r3, r0
   16e58:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   16e5a:	4a43      	ldr	r2, [pc, #268]	; (16f68 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16e5c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16e5e:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   16e62:	960f      	str	r6, [sp, #60]	; 0x3c
   16e64:	460b      	mov	r3, r1
   16e66:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   16e6a:	2304      	movs	r3, #4
   16e6c:	930d      	str	r3, [sp, #52]	; 0x34
   16e6e:	2302      	movs	r3, #2
   16e70:	930c      	str	r3, [sp, #48]	; 0x30
   16e72:	4623      	mov	r3, r4
   16e74:	4619      	mov	r1, r3
   16e76:	483d      	ldr	r0, [pc, #244]	; (16f6c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16e78:	f7fc fb6a 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16e7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16e80:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16e82:	2320      	movs	r3, #32
   16e84:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16e86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   16e88:	f1c3 0320 	rsb	r3, r3, #32
   16e8c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16e90:	fa22 f303 	lsr.w	r3, r2, r3
   16e94:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   16e96:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16e98:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16e9a:	fa02 f303 	lsl.w	r3, r2, r3
   16e9e:	43db      	mvns	r3, r3
   16ea0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16ea2:	4013      	ands	r3, r2
   16ea4:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   16ea6:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   16eaa:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16eac:	401a      	ands	r2, r3
   16eae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16eb0:	fa02 f303 	lsl.w	r3, r2, r3
   16eb4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16eb6:	4313      	orrs	r3, r2
   16eb8:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   16eba:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   16ebc:	4623      	mov	r3, r4
   16ebe:	4619      	mov	r1, r3
   16ec0:	482a      	ldr	r0, [pc, #168]	; (16f6c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16ec2:	f7fc fb59 	bl	13578 <__cyg_profile_func_exit>
   16ec6:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR1 = bit::Insert(
        ssp_registers[pssp]->CR1, util::Value(mode), kMasterModeBit, 1);
   16ec8:	4a27      	ldr	r2, [pc, #156]	; (16f68 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16eca:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16ecc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16ed0:	685e      	ldr	r6, [r3, #4]
    ssp_registers[pssp]->CR1 = bit::Insert(
   16ed2:	f89d 3003 	ldrb.w	r3, [sp, #3]
   16ed6:	4618      	mov	r0, r3
   16ed8:	f7ff ff2c 	bl	16d34 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>
   16edc:	4603      	mov	r3, r0
   16ede:	4619      	mov	r1, r3
   16ee0:	4a21      	ldr	r2, [pc, #132]	; (16f68 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16ee2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16ee4:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   16ee8:	9616      	str	r6, [sp, #88]	; 0x58
   16eea:	460b      	mov	r3, r1
   16eec:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   16ef0:	2302      	movs	r3, #2
   16ef2:	9314      	str	r3, [sp, #80]	; 0x50
   16ef4:	2301      	movs	r3, #1
   16ef6:	9313      	str	r3, [sp, #76]	; 0x4c
   16ef8:	4623      	mov	r3, r4
   16efa:	4619      	mov	r1, r3
   16efc:	481b      	ldr	r0, [pc, #108]	; (16f6c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16efe:	f7fc fb27 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16f02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16f06:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16f08:	2320      	movs	r3, #32
   16f0a:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16f0c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   16f0e:	f1c3 0320 	rsb	r3, r3, #32
   16f12:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16f16:	fa22 f303 	lsr.w	r3, r2, r3
   16f1a:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   16f1c:	9a10      	ldr	r2, [sp, #64]	; 0x40
   16f1e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16f20:	fa02 f303 	lsl.w	r3, r2, r3
   16f24:	43db      	mvns	r3, r3
   16f26:	9a16      	ldr	r2, [sp, #88]	; 0x58
   16f28:	4013      	ands	r3, r2
   16f2a:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   16f2c:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   16f30:	9b10      	ldr	r3, [sp, #64]	; 0x40
   16f32:	401a      	ands	r2, r3
   16f34:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16f36:	fa02 f303 	lsl.w	r3, r2, r3
   16f3a:	9a16      	ldr	r2, [sp, #88]	; 0x58
   16f3c:	4313      	orrs	r3, r2
   16f3e:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   16f40:	9e16      	ldr	r6, [sp, #88]	; 0x58
   16f42:	4623      	mov	r3, r4
   16f44:	4619      	mov	r1, r3
   16f46:	4809      	ldr	r0, [pc, #36]	; (16f6c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16f48:	f7fc fb16 	bl	13578 <__cyg_profile_func_exit>
   16f4c:	606e      	str	r6, [r5, #4]
   16f4e:	4623      	mov	r3, r4
   16f50:	4619      	mov	r1, r3
   16f52:	4803      	ldr	r0, [pc, #12]	; (16f60 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   16f54:	f7fc fb10 	bl	13578 <__cyg_profile_func_exit>
  }
   16f58:	bf00      	nop
   16f5a:	b018      	add	sp, #96	; 0x60
   16f5c:	bd70      	pop	{r4, r5, r6, pc}
   16f5e:	bf00      	nop
   16f60:	00016d65 	.word	0x00016d65
   16f64:	0001abe0 	.word	0x0001abe0
   16f68:	1000005c 	.word	0x1000005c
   16f6c:	0001874d 	.word	0x0001874d

00016f70 <Ssp::GetPeripheralMode()>:
  /// Gets the Peripheral modes from registers
  /// @return - returns a 16-bit value as follows: 0000_000x 0xx0_xxxx
  ///       MasterSlaveMode = 1-bit @ bit 8
  ///       FrameMode       = 2-bit @ bit 5
  ///       DataSize        = 4-bit @ bit 0
  uint16_t GetPeripheralMode() override
   16f70:	b570      	push	{r4, r5, r6, lr}
   16f72:	b096      	sub	sp, #88	; 0x58
   16f74:	4674      	mov	r4, lr
   16f76:	9001      	str	r0, [sp, #4]
   16f78:	4623      	mov	r3, r4
   16f7a:	4619      	mov	r1, r3
   16f7c:	4850      	ldr	r0, [pc, #320]	; (170c0 <Ssp::GetPeripheralMode()+0x150>)
   16f7e:	f7fc fae7 	bl	13550 <__cyg_profile_func_enter>
  {
    uint16_t return_val = 0;
   16f82:	2300      	movs	r3, #0
   16f84:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    uint32_t pssp       = util::Value(pssp_);
   16f88:	9b01      	ldr	r3, [sp, #4]
   16f8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16f8c:	4618      	mov	r0, r3
   16f8e:	f7f9 fdcf 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16f92:	4603      	mov	r3, r0
   16f94:	9314      	str	r3, [sp, #80]	; 0x50
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   16f96:	9b01      	ldr	r3, [sp, #4]
   16f98:	1d18      	adds	r0, r3, #4
   16f9a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16f9c:	009b      	lsls	r3, r3, #2
   16f9e:	4a49      	ldr	r2, [pc, #292]	; (170c4 <Ssp::GetPeripheralMode()+0x154>)
   16fa0:	4413      	add	r3, r2
   16fa2:	4619      	mov	r1, r3
   16fa4:	f7fa f97e 	bl	112a4 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val = static_cast<uint16_t>(
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   16fa8:	4a47      	ldr	r2, [pc, #284]	; (170c8 <Ssp::GetPeripheralMode()+0x158>)
   16faa:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16fb0:	681b      	ldr	r3, [r3, #0]
   16fb2:	9307      	str	r3, [sp, #28]
   16fb4:	2300      	movs	r3, #0
   16fb6:	9306      	str	r3, [sp, #24]
   16fb8:	2304      	movs	r3, #4
   16fba:	9305      	str	r3, [sp, #20]
   16fbc:	4623      	mov	r3, r4
   16fbe:	4619      	mov	r1, r3
   16fc0:	4842      	ldr	r0, [pc, #264]	; (170cc <Ssp::GetPeripheralMode()+0x15c>)
   16fc2:	f7fc fac5 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16fc6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16fca:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16fcc:	2320      	movs	r3, #32
   16fce:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16fd0:	9b05      	ldr	r3, [sp, #20]
   16fd2:	f1c3 0320 	rsb	r3, r3, #32
   16fd6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16fda:	fa22 f303 	lsr.w	r3, r2, r3
   16fde:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   16fe0:	9a07      	ldr	r2, [sp, #28]
   16fe2:	9b06      	ldr	r3, [sp, #24]
   16fe4:	40da      	lsrs	r2, r3
   16fe6:	9b02      	ldr	r3, [sp, #8]
   16fe8:	ea02 0503 	and.w	r5, r2, r3
   16fec:	4623      	mov	r3, r4
   16fee:	4619      	mov	r1, r3
   16ff0:	4836      	ldr	r0, [pc, #216]	; (170cc <Ssp::GetPeripheralMode()+0x15c>)
   16ff2:	f7fc fac1 	bl	13578 <__cyg_profile_func_exit>
   16ff6:	b2ad      	uxth	r5, r5
        ((bit::Extract(ssp_registers[pssp]->CR0, kFrameBit, 2)) << 5) +
   16ff8:	4a33      	ldr	r2, [pc, #204]	; (170c8 <Ssp::GetPeripheralMode()+0x158>)
   16ffa:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16ffc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17000:	681b      	ldr	r3, [r3, #0]
   17002:	930d      	str	r3, [sp, #52]	; 0x34
   17004:	2304      	movs	r3, #4
   17006:	930c      	str	r3, [sp, #48]	; 0x30
   17008:	2302      	movs	r3, #2
   1700a:	930b      	str	r3, [sp, #44]	; 0x2c
   1700c:	4623      	mov	r3, r4
   1700e:	4619      	mov	r1, r3
   17010:	482e      	ldr	r0, [pc, #184]	; (170cc <Ssp::GetPeripheralMode()+0x15c>)
   17012:	f7fc fa9d 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   17016:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1701a:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1701c:	2320      	movs	r3, #32
   1701e:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   17020:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17022:	f1c3 0320 	rsb	r3, r3, #32
   17026:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1702a:	fa22 f303 	lsr.w	r3, r2, r3
   1702e:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   17030:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   17032:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   17034:	40da      	lsrs	r2, r3
   17036:	9b08      	ldr	r3, [sp, #32]
   17038:	ea02 0603 	and.w	r6, r2, r3
   1703c:	4623      	mov	r3, r4
   1703e:	4619      	mov	r1, r3
   17040:	4822      	ldr	r0, [pc, #136]	; (170cc <Ssp::GetPeripheralMode()+0x15c>)
   17042:	f7fc fa99 	bl	13578 <__cyg_profile_func_exit>
   17046:	b2b3      	uxth	r3, r6
   17048:	015b      	lsls	r3, r3, #5
   1704a:	b29b      	uxth	r3, r3
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   1704c:	442b      	add	r3, r5
   1704e:	b29d      	uxth	r5, r3
        ((bit::Extract(ssp_registers[pssp]->CR1, kMasterModeBit)) << 8));
   17050:	4a1d      	ldr	r2, [pc, #116]	; (170c8 <Ssp::GetPeripheralMode()+0x158>)
   17052:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17054:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17058:	685b      	ldr	r3, [r3, #4]
   1705a:	9313      	str	r3, [sp, #76]	; 0x4c
   1705c:	2302      	movs	r3, #2
   1705e:	9312      	str	r3, [sp, #72]	; 0x48
   17060:	2301      	movs	r3, #1
   17062:	9311      	str	r3, [sp, #68]	; 0x44
   17064:	4623      	mov	r3, r4
   17066:	4619      	mov	r1, r3
   17068:	4818      	ldr	r0, [pc, #96]	; (170cc <Ssp::GetPeripheralMode()+0x15c>)
   1706a:	f7fc fa71 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1706e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17072:	9310      	str	r3, [sp, #64]	; 0x40
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   17074:	2320      	movs	r3, #32
   17076:	930f      	str	r3, [sp, #60]	; 0x3c
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   17078:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1707a:	f1c3 0320 	rsb	r3, r3, #32
   1707e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17082:	fa22 f303 	lsr.w	r3, r2, r3
   17086:	930e      	str	r3, [sp, #56]	; 0x38
  return (target >> position) & mask;
   17088:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   1708a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1708c:	40da      	lsrs	r2, r3
   1708e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   17090:	ea02 0603 	and.w	r6, r2, r3
   17094:	4623      	mov	r3, r4
   17096:	4619      	mov	r1, r3
   17098:	480c      	ldr	r0, [pc, #48]	; (170cc <Ssp::GetPeripheralMode()+0x15c>)
   1709a:	f7fc fa6d 	bl	13578 <__cyg_profile_func_exit>
   1709e:	b2b3      	uxth	r3, r6
   170a0:	021b      	lsls	r3, r3, #8
   170a2:	b29b      	uxth	r3, r3
    return_val = static_cast<uint16_t>(
   170a4:	442b      	add	r3, r5
   170a6:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    return return_val;
   170aa:	f8bd 5056 	ldrh.w	r5, [sp, #86]	; 0x56
   170ae:	4623      	mov	r3, r4
   170b0:	4619      	mov	r1, r3
   170b2:	4803      	ldr	r0, [pc, #12]	; (170c0 <Ssp::GetPeripheralMode()+0x150>)
   170b4:	f7fc fa60 	bl	13578 <__cyg_profile_func_exit>
   170b8:	462b      	mov	r3, r5
  }
   170ba:	4618      	mov	r0, r3
   170bc:	b016      	add	sp, #88	; 0x58
   170be:	bd70      	pop	{r4, r5, r6, pc}
   170c0:	00016f71 	.word	0x00016f71
   170c4:	0001abe0 	.word	0x0001abe0
   170c8:	1000005c 	.word	0x1000005c
   170cc:	000187c1 	.word	0x000187c1

000170d0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>:
  /// Sets the clock rate for the Peripheral
  /// @param polarity - maintain bus on clock 0=low or 1=high between frames
  /// @param phase - capture serial data on 0=first or 1=second clock cycle
  /// @param divider - see notes in SSP_Interface above
  /// @param prescaler - divides the PCLK, must be even value between 2-254
  void SetClock(bool polarity, bool phase, uint8_t divider,
   170d0:	b570      	push	{r4, r5, r6, lr}
   170d2:	b098      	sub	sp, #96	; 0x60
   170d4:	4674      	mov	r4, lr
   170d6:	9001      	str	r0, [sp, #4]
   170d8:	4608      	mov	r0, r1
   170da:	4611      	mov	r1, r2
   170dc:	461a      	mov	r2, r3
   170de:	4603      	mov	r3, r0
   170e0:	f88d 3003 	strb.w	r3, [sp, #3]
   170e4:	460b      	mov	r3, r1
   170e6:	f88d 3002 	strb.w	r3, [sp, #2]
   170ea:	4613      	mov	r3, r2
   170ec:	f88d 3001 	strb.w	r3, [sp, #1]
   170f0:	4623      	mov	r3, r4
   170f2:	4619      	mov	r1, r3
   170f4:	486c      	ldr	r0, [pc, #432]	; (172a8 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   170f6:	f7fc fa2b 	bl	13550 <__cyg_profile_func_enter>
                uint8_t prescaler) override
  {
    uint32_t pssp = util::Value(pssp_);
   170fa:	9b01      	ldr	r3, [sp, #4]
   170fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   170fe:	4618      	mov	r0, r3
   17100:	f7f9 fd16 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   17104:	4603      	mov	r3, r0
   17106:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   17108:	9b01      	ldr	r3, [sp, #4]
   1710a:	1d18      	adds	r0, r3, #4
   1710c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1710e:	009b      	lsls	r3, r3, #2
   17110:	4a66      	ldr	r2, [pc, #408]	; (172ac <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1dc>)
   17112:	4413      	add	r3, r2
   17114:	4619      	mov	r1, r3
   17116:	f7fa f8c5 	bl	112a4 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    // first clear the appropriate registers
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, polarity, kPolarityBit, 1);
   1711a:	4a65      	ldr	r2, [pc, #404]	; (172b0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1711c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1711e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17122:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   17124:	4962      	ldr	r1, [pc, #392]	; (172b0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   17126:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   17128:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   1712c:	9308      	str	r3, [sp, #32]
   1712e:	f89d 3003 	ldrb.w	r3, [sp, #3]
   17132:	f88d 301f 	strb.w	r3, [sp, #31]
   17136:	2306      	movs	r3, #6
   17138:	9306      	str	r3, [sp, #24]
   1713a:	2301      	movs	r3, #1
   1713c:	9305      	str	r3, [sp, #20]
   1713e:	4623      	mov	r3, r4
   17140:	4619      	mov	r1, r3
   17142:	485c      	ldr	r0, [pc, #368]	; (172b4 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   17144:	f7fc fa04 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   17148:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1714c:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1714e:	2320      	movs	r3, #32
   17150:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   17152:	9b05      	ldr	r3, [sp, #20]
   17154:	f1c3 0320 	rsb	r3, r3, #32
   17158:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1715c:	fa22 f303 	lsr.w	r3, r2, r3
   17160:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   17162:	9a02      	ldr	r2, [sp, #8]
   17164:	9b06      	ldr	r3, [sp, #24]
   17166:	fa02 f303 	lsl.w	r3, r2, r3
   1716a:	43db      	mvns	r3, r3
   1716c:	9a08      	ldr	r2, [sp, #32]
   1716e:	4013      	ands	r3, r2
   17170:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   17172:	f89d 201f 	ldrb.w	r2, [sp, #31]
   17176:	9b02      	ldr	r3, [sp, #8]
   17178:	401a      	ands	r2, r3
   1717a:	9b06      	ldr	r3, [sp, #24]
   1717c:	fa02 f303 	lsl.w	r3, r2, r3
   17180:	9a08      	ldr	r2, [sp, #32]
   17182:	4313      	orrs	r3, r2
   17184:	9308      	str	r3, [sp, #32]
  return target;
   17186:	9e08      	ldr	r6, [sp, #32]
   17188:	4623      	mov	r3, r4
   1718a:	4619      	mov	r1, r3
   1718c:	4849      	ldr	r0, [pc, #292]	; (172b4 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   1718e:	f7fc f9f3 	bl	13578 <__cyg_profile_func_exit>
   17192:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, phase, kPhaseBit, 1);
   17194:	4a46      	ldr	r2, [pc, #280]	; (172b0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   17196:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17198:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1719c:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   1719e:	4944      	ldr	r1, [pc, #272]	; (172b0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   171a0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   171a2:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   171a6:	930f      	str	r3, [sp, #60]	; 0x3c
   171a8:	f89d 3002 	ldrb.w	r3, [sp, #2]
   171ac:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   171b0:	2307      	movs	r3, #7
   171b2:	930d      	str	r3, [sp, #52]	; 0x34
   171b4:	2301      	movs	r3, #1
   171b6:	930c      	str	r3, [sp, #48]	; 0x30
   171b8:	4623      	mov	r3, r4
   171ba:	4619      	mov	r1, r3
   171bc:	483d      	ldr	r0, [pc, #244]	; (172b4 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   171be:	f7fc f9c7 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   171c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   171c6:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   171c8:	2320      	movs	r3, #32
   171ca:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   171cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   171ce:	f1c3 0320 	rsb	r3, r3, #32
   171d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   171d6:	fa22 f303 	lsr.w	r3, r2, r3
   171da:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   171dc:	9a09      	ldr	r2, [sp, #36]	; 0x24
   171de:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   171e0:	fa02 f303 	lsl.w	r3, r2, r3
   171e4:	43db      	mvns	r3, r3
   171e6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   171e8:	4013      	ands	r3, r2
   171ea:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   171ec:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   171f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   171f2:	401a      	ands	r2, r3
   171f4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   171f6:	fa02 f303 	lsl.w	r3, r2, r3
   171fa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   171fc:	4313      	orrs	r3, r2
   171fe:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   17200:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   17202:	4623      	mov	r3, r4
   17204:	4619      	mov	r1, r3
   17206:	482b      	ldr	r0, [pc, #172]	; (172b4 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   17208:	f7fc f9b6 	bl	13578 <__cyg_profile_func_exit>
   1720c:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, divider, kDividerBit, 8);
   1720e:	4a28      	ldr	r2, [pc, #160]	; (172b0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   17210:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17212:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17216:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   17218:	4925      	ldr	r1, [pc, #148]	; (172b0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1721a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   1721c:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   17220:	9316      	str	r3, [sp, #88]	; 0x58
   17222:	f89d 3001 	ldrb.w	r3, [sp, #1]
   17226:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   1722a:	2308      	movs	r3, #8
   1722c:	9314      	str	r3, [sp, #80]	; 0x50
   1722e:	2308      	movs	r3, #8
   17230:	9313      	str	r3, [sp, #76]	; 0x4c
   17232:	4623      	mov	r3, r4
   17234:	4619      	mov	r1, r3
   17236:	4820      	ldr	r0, [pc, #128]	; (172b8 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   17238:	f7fc f98a 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1723c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17240:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   17242:	2320      	movs	r3, #32
   17244:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   17246:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17248:	f1c3 0320 	rsb	r3, r3, #32
   1724c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17250:	fa22 f303 	lsr.w	r3, r2, r3
   17254:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   17256:	9a10      	ldr	r2, [sp, #64]	; 0x40
   17258:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1725a:	fa02 f303 	lsl.w	r3, r2, r3
   1725e:	43db      	mvns	r3, r3
   17260:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17262:	4013      	ands	r3, r2
   17264:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   17266:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   1726a:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1726c:	401a      	ands	r2, r3
   1726e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17270:	fa02 f303 	lsl.w	r3, r2, r3
   17274:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17276:	4313      	orrs	r3, r2
   17278:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   1727a:	9e16      	ldr	r6, [sp, #88]	; 0x58
   1727c:	4623      	mov	r3, r4
   1727e:	4619      	mov	r1, r3
   17280:	480d      	ldr	r0, [pc, #52]	; (172b8 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   17282:	f7fc f979 	bl	13578 <__cyg_profile_func_exit>
   17286:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CPSR = prescaler;
   17288:	4a09      	ldr	r2, [pc, #36]	; (172b0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1728a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1728c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17290:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   17294:	611a      	str	r2, [r3, #16]
   17296:	4623      	mov	r3, r4
   17298:	4619      	mov	r1, r3
   1729a:	4803      	ldr	r0, [pc, #12]	; (172a8 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   1729c:	f7fc f96c 	bl	13578 <__cyg_profile_func_exit>
  }
   172a0:	bf00      	nop
   172a2:	b018      	add	sp, #96	; 0x60
   172a4:	bd70      	pop	{r4, r5, r6, pc}
   172a6:	bf00      	nop
   172a8:	000170d1 	.word	0x000170d1
   172ac:	0001abe0 	.word	0x0001abe0
   172b0:	1000005c 	.word	0x1000005c
   172b4:	00018815 	.word	0x00018815
   172b8:	0001874d 	.word	0x0001874d

000172bc <Ssp::GetClock()>:
  ///   0000_0000 0000_0x0x xxxx_xxxx xxxx_xxxx
  ///       polarity    = 1-bit @ bit 18
  ///       phase       = 1-bit @ bit 16
  ///       divider     = 8-bits @ bit 8
  ///       prescaler   = 8-bits @ bit 0
  uint32_t GetClock() override
   172bc:	b570      	push	{r4, r5, r6, lr}
   172be:	b094      	sub	sp, #80	; 0x50
   172c0:	4674      	mov	r4, lr
   172c2:	9001      	str	r0, [sp, #4]
   172c4:	4623      	mov	r3, r4
   172c6:	4619      	mov	r1, r3
   172c8:	4858      	ldr	r0, [pc, #352]	; (1742c <Ssp::GetClock()+0x170>)
   172ca:	f7fc f941 	bl	13550 <__cyg_profile_func_enter>
  {
    uint32_t return_val = 0;
   172ce:	2300      	movs	r3, #0
   172d0:	9313      	str	r3, [sp, #76]	; 0x4c
    uint32_t pssp       = util::Value(pssp_);
   172d2:	9b01      	ldr	r3, [sp, #4]
   172d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   172d6:	4618      	mov	r0, r3
   172d8:	f7f9 fc2a 	bl	10b30 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   172dc:	4603      	mov	r3, r0
   172de:	9312      	str	r3, [sp, #72]	; 0x48
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   172e0:	9b01      	ldr	r3, [sp, #4]
   172e2:	1d18      	adds	r0, r3, #4
   172e4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   172e6:	009b      	lsls	r3, r3, #2
   172e8:	4a51      	ldr	r2, [pc, #324]	; (17430 <Ssp::GetClock()+0x174>)
   172ea:	4413      	add	r3, r2
   172ec:	4619      	mov	r1, r3
   172ee:	f7f9 ffd9 	bl	112a4 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val =
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   172f2:	4a50      	ldr	r2, [pc, #320]	; (17434 <Ssp::GetClock()+0x178>)
   172f4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   172f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   172fa:	691b      	ldr	r3, [r3, #16]
   172fc:	9307      	str	r3, [sp, #28]
   172fe:	2300      	movs	r3, #0
   17300:	9306      	str	r3, [sp, #24]
   17302:	2308      	movs	r3, #8
   17304:	9305      	str	r3, [sp, #20]
   17306:	4623      	mov	r3, r4
   17308:	4619      	mov	r1, r3
   1730a:	484b      	ldr	r0, [pc, #300]	; (17438 <Ssp::GetClock()+0x17c>)
   1730c:	f7fc f920 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   17310:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17314:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   17316:	2320      	movs	r3, #32
   17318:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1731a:	9b05      	ldr	r3, [sp, #20]
   1731c:	f1c3 0320 	rsb	r3, r3, #32
   17320:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17324:	fa22 f303 	lsr.w	r3, r2, r3
   17328:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   1732a:	9a07      	ldr	r2, [sp, #28]
   1732c:	9b06      	ldr	r3, [sp, #24]
   1732e:	40da      	lsrs	r2, r3
   17330:	9b02      	ldr	r3, [sp, #8]
   17332:	ea02 0503 	and.w	r5, r2, r3
   17336:	4623      	mov	r3, r4
   17338:	4619      	mov	r1, r3
   1733a:	483f      	ldr	r0, [pc, #252]	; (17438 <Ssp::GetClock()+0x17c>)
   1733c:	f7fc f91c 	bl	13578 <__cyg_profile_func_exit>
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   17340:	4a3c      	ldr	r2, [pc, #240]	; (17434 <Ssp::GetClock()+0x178>)
   17342:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17344:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17348:	681b      	ldr	r3, [r3, #0]
   1734a:	930d      	str	r3, [sp, #52]	; 0x34
   1734c:	2308      	movs	r3, #8
   1734e:	930c      	str	r3, [sp, #48]	; 0x30
   17350:	2308      	movs	r3, #8
   17352:	930b      	str	r3, [sp, #44]	; 0x2c
   17354:	4623      	mov	r3, r4
   17356:	4619      	mov	r1, r3
   17358:	4837      	ldr	r0, [pc, #220]	; (17438 <Ssp::GetClock()+0x17c>)
   1735a:	f7fc f8f9 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1735e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17362:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   17364:	2320      	movs	r3, #32
   17366:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   17368:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1736a:	f1c3 0320 	rsb	r3, r3, #32
   1736e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17372:	fa22 f303 	lsr.w	r3, r2, r3
   17376:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   17378:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1737a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1737c:	40da      	lsrs	r2, r3
   1737e:	9b08      	ldr	r3, [sp, #32]
   17380:	ea02 0603 	and.w	r6, r2, r3
   17384:	4623      	mov	r3, r4
   17386:	4619      	mov	r1, r3
   17388:	482b      	ldr	r0, [pc, #172]	; (17438 <Ssp::GetClock()+0x17c>)
   1738a:	f7fc f8f5 	bl	13578 <__cyg_profile_func_exit>
   1738e:	0233      	lsls	r3, r6, #8
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   17390:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPhaseBit)) << 16) +
   17392:	4a28      	ldr	r2, [pc, #160]	; (17434 <Ssp::GetClock()+0x178>)
   17394:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17396:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1739a:	681b      	ldr	r3, [r3, #0]
   1739c:	930f      	str	r3, [sp, #60]	; 0x3c
   1739e:	2307      	movs	r3, #7
   173a0:	930e      	str	r3, [sp, #56]	; 0x38
   173a2:	4623      	mov	r3, r4
   173a4:	4619      	mov	r1, r3
   173a6:	4825      	ldr	r0, [pc, #148]	; (1743c <Ssp::GetClock()+0x180>)
   173a8:	f7fc f8d2 	bl	13550 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   173ac:	2201      	movs	r2, #1
   173ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   173b0:	fa02 f303 	lsl.w	r3, r2, r3
   173b4:	461a      	mov	r2, r3
   173b6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   173b8:	4013      	ands	r3, r2
   173ba:	2b00      	cmp	r3, #0
   173bc:	bf14      	ite	ne
   173be:	2301      	movne	r3, #1
   173c0:	2300      	moveq	r3, #0
   173c2:	b2de      	uxtb	r6, r3
   173c4:	4623      	mov	r3, r4
   173c6:	4619      	mov	r1, r3
   173c8:	481c      	ldr	r0, [pc, #112]	; (1743c <Ssp::GetClock()+0x180>)
   173ca:	f7fc f8d5 	bl	13578 <__cyg_profile_func_exit>
   173ce:	4633      	mov	r3, r6
   173d0:	041b      	lsls	r3, r3, #16
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   173d2:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPolarityBit)) << 18);
   173d4:	4a17      	ldr	r2, [pc, #92]	; (17434 <Ssp::GetClock()+0x178>)
   173d6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   173d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   173dc:	681b      	ldr	r3, [r3, #0]
   173de:	9311      	str	r3, [sp, #68]	; 0x44
   173e0:	2306      	movs	r3, #6
   173e2:	9310      	str	r3, [sp, #64]	; 0x40
   173e4:	4623      	mov	r3, r4
   173e6:	4619      	mov	r1, r3
   173e8:	4814      	ldr	r0, [pc, #80]	; (1743c <Ssp::GetClock()+0x180>)
   173ea:	f7fc f8b1 	bl	13550 <__cyg_profile_func_enter>
   173ee:	2201      	movs	r2, #1
   173f0:	9b10      	ldr	r3, [sp, #64]	; 0x40
   173f2:	fa02 f303 	lsl.w	r3, r2, r3
   173f6:	461a      	mov	r2, r3
   173f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   173fa:	4013      	ands	r3, r2
   173fc:	2b00      	cmp	r3, #0
   173fe:	bf14      	ite	ne
   17400:	2301      	movne	r3, #1
   17402:	2300      	moveq	r3, #0
   17404:	b2de      	uxtb	r6, r3
   17406:	4623      	mov	r3, r4
   17408:	4619      	mov	r1, r3
   1740a:	480c      	ldr	r0, [pc, #48]	; (1743c <Ssp::GetClock()+0x180>)
   1740c:	f7fc f8b4 	bl	13578 <__cyg_profile_func_exit>
   17410:	4633      	mov	r3, r6
   17412:	049b      	lsls	r3, r3, #18
    return_val =
   17414:	442b      	add	r3, r5
   17416:	9313      	str	r3, [sp, #76]	; 0x4c

    return return_val;
   17418:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   1741a:	4623      	mov	r3, r4
   1741c:	4619      	mov	r1, r3
   1741e:	4803      	ldr	r0, [pc, #12]	; (1742c <Ssp::GetClock()+0x170>)
   17420:	f7fc f8aa 	bl	13578 <__cyg_profile_func_exit>
   17424:	462b      	mov	r3, r5
  }
   17426:	4618      	mov	r0, r3
   17428:	b014      	add	sp, #80	; 0x50
   1742a:	bd70      	pop	{r4, r5, r6, pc}
   1742c:	000172bd 	.word	0x000172bd
   17430:	0001abe0 	.word	0x0001abe0
   17434:	1000005c 	.word	0x1000005c
   17438:	000187c1 	.word	0x000187c1
   1743c:	00010f45 	.word	0x00010f45

00017440 <SdInterface::SdInterface()>:
// NOLINTNEXTLINE(readability-identifier-naming)
// Relevant Datasheet:
// https://www.sdcard.org/downloads/pls/pdf/index.php?p=Part1_Physical_Layer_Simplified_Specification_Ver6.00.jpg&f=Part1_Physical_Layer_Simplified_Specification_Ver6.00.pdf&e=EN_SS1
// TODO(#348):  Write a class to represent a single Sd Card Block to make use
//              of block-related functions easier.
class SdInterface
   17440:	b530      	push	{r4, r5, lr}
   17442:	b083      	sub	sp, #12
   17444:	4675      	mov	r5, lr
   17446:	9001      	str	r0, [sp, #4]
   17448:	462b      	mov	r3, r5
   1744a:	4619      	mov	r1, r3
   1744c:	4807      	ldr	r0, [pc, #28]	; (1746c <SdInterface::SdInterface()+0x2c>)
   1744e:	f7fc f87f 	bl	13550 <__cyg_profile_func_enter>
   17452:	4a07      	ldr	r2, [pc, #28]	; (17470 <SdInterface::SdInterface()+0x30>)
   17454:	9b01      	ldr	r3, [sp, #4]
   17456:	601a      	str	r2, [r3, #0]
   17458:	9c01      	ldr	r4, [sp, #4]
   1745a:	462b      	mov	r3, r5
   1745c:	4619      	mov	r1, r3
   1745e:	4803      	ldr	r0, [pc, #12]	; (1746c <SdInterface::SdInterface()+0x2c>)
   17460:	f7fc f88a 	bl	13578 <__cyg_profile_func_exit>
   17464:	4623      	mov	r3, r4
   17466:	4618      	mov	r0, r3
   17468:	b003      	add	sp, #12
   1746a:	bd30      	pop	{r4, r5, pc}
   1746c:	00017441 	.word	0x00017441
   17470:	0001afb8 	.word	0x0001afb8

00017474 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>:
  /// port that is broken out through the board's GPIO, allowing you to probe
  /// the chip select manually. To use this version instead of the main version,
  /// instantiate an Sd card instance like so:
  ///
  ///   Sd sdcard(Sd::DebugSdCard_t{});
  constexpr Sd(DebugSdCard_t, uint8_t port = 1, uint8_t pin = 8,
   17474:	b530      	push	{r4, r5, lr}
   17476:	b083      	sub	sp, #12
   17478:	4675      	mov	r5, lr
   1747a:	9001      	str	r0, [sp, #4]
   1747c:	f88d 1000 	strb.w	r1, [sp]
   17480:	4611      	mov	r1, r2
   17482:	461a      	mov	r2, r3
   17484:	460b      	mov	r3, r1
   17486:	f88d 3003 	strb.w	r3, [sp, #3]
   1748a:	4613      	mov	r3, r2
   1748c:	f88d 3002 	strb.w	r3, [sp, #2]
   17490:	462b      	mov	r3, r5
   17492:	4619      	mov	r1, r3
   17494:	481d      	ldr	r0, [pc, #116]	; (1750c <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   17496:	f7fc f85b 	bl	13550 <__cyg_profile_func_enter>
      : ssp_interface_(&ssp_),
        ssp_(Ssp::Peripheral::kSsp2),
        chip_select_(&chip_select_pin_),
        chip_select_external_(&chip_select_external_pin_),
        chip_select_pin_(port, pin),
        chip_select_external_pin_(extport, extpin)
   1749a:	9b01      	ldr	r3, [sp, #4]
   1749c:	4618      	mov	r0, r3
   1749e:	f7ff ffcf 	bl	17440 <SdInterface::SdInterface()>
   174a2:	4a1b      	ldr	r2, [pc, #108]	; (17510 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x9c>)
   174a4:	9b01      	ldr	r3, [sp, #4]
   174a6:	601a      	str	r2, [r3, #0]
   174a8:	9b01      	ldr	r3, [sp, #4]
   174aa:	f103 0208 	add.w	r2, r3, #8
   174ae:	9b01      	ldr	r3, [sp, #4]
   174b0:	605a      	str	r2, [r3, #4]
   174b2:	9b01      	ldr	r3, [sp, #4]
   174b4:	3308      	adds	r3, #8
   174b6:	2102      	movs	r1, #2
   174b8:	4618      	mov	r0, r3
   174ba:	f7ff faf9 	bl	16ab0 <Ssp::Ssp(Ssp::Peripheral)>
   174be:	9b01      	ldr	r3, [sp, #4]
   174c0:	f103 0240 	add.w	r2, r3, #64	; 0x40
   174c4:	9b01      	ldr	r3, [sp, #4]
   174c6:	639a      	str	r2, [r3, #56]	; 0x38
   174c8:	9b01      	ldr	r3, [sp, #4]
   174ca:	f103 0254 	add.w	r2, r3, #84	; 0x54
   174ce:	9b01      	ldr	r3, [sp, #4]
   174d0:	63da      	str	r2, [r3, #60]	; 0x3c
   174d2:	9b01      	ldr	r3, [sp, #4]
   174d4:	3340      	adds	r3, #64	; 0x40
   174d6:	f89d 2002 	ldrb.w	r2, [sp, #2]
   174da:	f89d 1003 	ldrb.w	r1, [sp, #3]
   174de:	4618      	mov	r0, r3
   174e0:	f7fe fe5a 	bl	16198 <Gpio::Gpio(unsigned char, unsigned char)>
   174e4:	9b01      	ldr	r3, [sp, #4]
   174e6:	3354      	adds	r3, #84	; 0x54
   174e8:	f89d 201c 	ldrb.w	r2, [sp, #28]
   174ec:	f89d 1018 	ldrb.w	r1, [sp, #24]
   174f0:	4618      	mov	r0, r3
   174f2:	f7fe fe51 	bl	16198 <Gpio::Gpio(unsigned char, unsigned char)>
  {
  }
   174f6:	9c01      	ldr	r4, [sp, #4]
   174f8:	462b      	mov	r3, r5
   174fa:	4619      	mov	r1, r3
   174fc:	4803      	ldr	r0, [pc, #12]	; (1750c <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   174fe:	f7fc f83b 	bl	13578 <__cyg_profile_func_exit>
   17502:	4623      	mov	r3, r4
   17504:	4618      	mov	r0, r3
   17506:	b003      	add	sp, #12
   17508:	bd30      	pop	{r4, r5, pc}
   1750a:	bf00      	nop
   1750c:	00017475 	.word	0x00017475
   17510:	0001af8c 	.word	0x0001af8c

00017514 <Sd::Initialize()>:

  void Initialize() override
   17514:	b530      	push	{r4, r5, lr}
   17516:	b085      	sub	sp, #20
   17518:	4675      	mov	r5, lr
   1751a:	9003      	str	r0, [sp, #12]
   1751c:	462b      	mov	r3, r5
   1751e:	4619      	mov	r1, r3
   17520:	4827      	ldr	r0, [pc, #156]	; (175c0 <Sd::Initialize()+0xac>)
   17522:	f7fc f815 	bl	13550 <__cyg_profile_func_enter>
  {
    LOG_DEBUG("Begin initialization:");
    LOG_DEBUG("Setting CS as output...");
    chip_select_->SetAsOutput();
   17526:	9b03      	ldr	r3, [sp, #12]
   17528:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   1752a:	9b03      	ldr	r3, [sp, #12]
   1752c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1752e:	681b      	ldr	r3, [r3, #0]
   17530:	3304      	adds	r3, #4
   17532:	681b      	ldr	r3, [r3, #0]
   17534:	4610      	mov	r0, r2
   17536:	4798      	blx	r3
    chip_select_->SetHigh();
   17538:	9b03      	ldr	r3, [sp, #12]
   1753a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   1753c:	9b03      	ldr	r3, [sp, #12]
   1753e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   17540:	681b      	ldr	r3, [r3, #0]
   17542:	330c      	adds	r3, #12
   17544:	681b      	ldr	r3, [r3, #0]
   17546:	4610      	mov	r0, r2
   17548:	4798      	blx	r3
    chip_select_external_->SetAsOutput();
   1754a:	9b03      	ldr	r3, [sp, #12]
   1754c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   1754e:	9b03      	ldr	r3, [sp, #12]
   17550:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   17552:	681b      	ldr	r3, [r3, #0]
   17554:	3304      	adds	r3, #4
   17556:	681b      	ldr	r3, [r3, #0]
   17558:	4610      	mov	r0, r2
   1755a:	4798      	blx	r3
    chip_select_external_->SetHigh();
   1755c:	9b03      	ldr	r3, [sp, #12]
   1755e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   17560:	9b03      	ldr	r3, [sp, #12]
   17562:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   17564:	681b      	ldr	r3, [r3, #0]
   17566:	330c      	adds	r3, #12
   17568:	681b      	ldr	r3, [r3, #0]
   1756a:	4610      	mov	r0, r2
   1756c:	4798      	blx	r3

    LOG_DEBUG("Setting SSP Clock Speed...");
    ssp_interface_->SetClock(false, false, 14, 2);  // 400kHz
   1756e:	9b03      	ldr	r3, [sp, #12]
   17570:	6858      	ldr	r0, [r3, #4]
   17572:	9b03      	ldr	r3, [sp, #12]
   17574:	685b      	ldr	r3, [r3, #4]
   17576:	681b      	ldr	r3, [r3, #0]
   17578:	3318      	adds	r3, #24
   1757a:	681c      	ldr	r4, [r3, #0]
   1757c:	2302      	movs	r3, #2
   1757e:	9300      	str	r3, [sp, #0]
   17580:	230e      	movs	r3, #14
   17582:	2200      	movs	r2, #0
   17584:	2100      	movs	r1, #0
   17586:	47a0      	blx	r4

    LOG_DEBUG("Setting Peripheral Mode...");
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   17588:	9b03      	ldr	r3, [sp, #12]
   1758a:	6858      	ldr	r0, [r3, #4]
   1758c:	9b03      	ldr	r3, [sp, #12]
   1758e:	685b      	ldr	r3, [r3, #4]
                                      Ssp::FrameMode::kSpi,
                                      Ssp::DataSize::kEight);
   17590:	681b      	ldr	r3, [r3, #0]
   17592:	3310      	adds	r3, #16
   17594:	681c      	ldr	r4, [r3, #0]
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   17596:	2307      	movs	r3, #7
   17598:	2200      	movs	r2, #0
   1759a:	2100      	movs	r1, #0
   1759c:	47a0      	blx	r4

    LOG_DEBUG("Starting SSP Peripheral...");
    ssp_interface_->Initialize();
   1759e:	9b03      	ldr	r3, [sp, #12]
   175a0:	685a      	ldr	r2, [r3, #4]
   175a2:	9b03      	ldr	r3, [sp, #12]
   175a4:	685b      	ldr	r3, [r3, #4]
   175a6:	681b      	ldr	r3, [r3, #0]
   175a8:	681b      	ldr	r3, [r3, #0]
   175aa:	4610      	mov	r0, r2
   175ac:	4798      	blx	r3
   175ae:	462b      	mov	r3, r5
   175b0:	4619      	mov	r1, r3
   175b2:	4803      	ldr	r0, [pc, #12]	; (175c0 <Sd::Initialize()+0xac>)
   175b4:	f7fb ffe0 	bl	13578 <__cyg_profile_func_exit>
  }
   175b8:	bf00      	nop
   175ba:	b005      	add	sp, #20
   175bc:	bd30      	pop	{r4, r5, pc}
   175be:	bf00      	nop
   175c0:	00017515 	.word	0x00017515

000175c4 <Sd::Mount(SdInterface::CardInfo_t*)>:

  // Initialize SD Card
  // TODO(#349): Split method into smaller piece with single jobs
  bool Mount(CardInfo_t * sd) override
   175c4:	b530      	push	{r4, r5, lr}
   175c6:	b08b      	sub	sp, #44	; 0x2c
   175c8:	4675      	mov	r5, lr
   175ca:	9003      	str	r0, [sp, #12]
   175cc:	9102      	str	r1, [sp, #8]
   175ce:	462b      	mov	r3, r5
   175d0:	4619      	mov	r1, r3
   175d2:	48a7      	ldr	r0, [pc, #668]	; (17870 <Sd::Mount(SdInterface::CardInfo_t*)+0x2ac>)
   175d4:	f7fb ffbc 	bl	13550 <__cyg_profile_func_enter>
  {
    uint8_t tries     = 0;
   175d8:	2300      	movs	r3, #0
   175da:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    bool card_is_idle = false;
   175de:	2300      	movs	r3, #0
   175e0:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26

    // Reset the card and force it to go to idle state at <400kHz with a
    // CMD0 + (active-low) CS
    LOG_DEBUG("Sending SD Card to Idle State...");
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   175e4:	9b03      	ldr	r3, [sp, #12]
   175e6:	681b      	ldr	r3, [r3, #0]
   175e8:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
   175ea:	9b02      	ldr	r3, [sp, #8]
   175ec:	f103 0208 	add.w	r2, r3, #8
   175f0:	2301      	movs	r3, #1
   175f2:	9301      	str	r3, [sp, #4]
   175f4:	2364      	movs	r3, #100	; 0x64
   175f6:	9300      	str	r3, [sp, #0]
   175f8:	4613      	mov	r3, r2
   175fa:	2200      	movs	r2, #0
   175fc:	2140      	movs	r1, #64	; 0x40
   175fe:	9803      	ldr	r0, [sp, #12]
   17600:	47a0      	blx	r4
   17602:	4602      	mov	r2, r0
   17604:	9b02      	ldr	r3, [sp, #8]
   17606:	611a      	str	r2, [r3, #16]

    // Reset the card again to trigger SPI mode
    LOG_DEBUG("Initializing SPI mode...");
    do
    {
      tries++;
   17608:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1760c:	3301      	adds	r3, #1
   1760e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      sd->response.length = SendCmd(
          Command::kReset, 0x00, sd->response.data.byte, 100, KeepAlive::kYes);
   17612:	9b03      	ldr	r3, [sp, #12]
   17614:	681b      	ldr	r3, [r3, #0]
   17616:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(
   17618:	9b02      	ldr	r3, [sp, #8]
   1761a:	f103 0208 	add.w	r2, r3, #8
   1761e:	2301      	movs	r3, #1
   17620:	9301      	str	r3, [sp, #4]
   17622:	2364      	movs	r3, #100	; 0x64
   17624:	9300      	str	r3, [sp, #0]
   17626:	4613      	mov	r3, r2
   17628:	2200      	movs	r2, #0
   1762a:	2140      	movs	r1, #64	; 0x40
   1762c:	9803      	ldr	r0, [sp, #12]
   1762e:	47a0      	blx	r4
   17630:	4602      	mov	r2, r0
   17632:	9b02      	ldr	r3, [sp, #8]
   17634:	611a      	str	r2, [r3, #16]

      // Check if R1 response frame's bit 1 is set (to ensure that
      // card is in idle state)
      if (sd->response.data.byte[0] != 0xFF &&
   17636:	9b02      	ldr	r3, [sp, #8]
   17638:	7a1b      	ldrb	r3, [r3, #8]
   1763a:	2bff      	cmp	r3, #255	; 0xff
   1763c:	d008      	beq.n	17650 <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
          (sd->response.data.byte[0] & 0x01) == 0x01)
   1763e:	9b02      	ldr	r3, [sp, #8]
   17640:	7a1b      	ldrb	r3, [r3, #8]
   17642:	f003 0301 	and.w	r3, r3, #1
      if (sd->response.data.byte[0] != 0xFF &&
   17646:	2b00      	cmp	r3, #0
   17648:	d002      	beq.n	17650 <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
      {
        // If it is, we can move on; otherwise, keep trying for a set
        // amount of tries
        card_is_idle = true;
   1764a:	2301      	movs	r3, #1
   1764c:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
      }
      Delay(10);
   17650:	f04f 000a 	mov.w	r0, #10
   17654:	f04f 0100 	mov.w	r1, #0
   17658:	f7f9 f9cc 	bl	109f4 <Delay(unsigned long long)>
    } while (tries < kBusTimeout && !card_is_idle);
   1765c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17660:	2bf9      	cmp	r3, #249	; 0xf9
   17662:	d804      	bhi.n	1766e <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
   17664:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   17668:	2b00      	cmp	r3, #0
   1766a:	d100      	bne.n	1766e <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
    do
   1766c:	e7cc      	b.n	17608 <Sd::Mount(SdInterface::CardInfo_t*)+0x44>
    LOG_DEBUG("%d tries", tries);
    if (tries >= kBusTimeout)
   1766e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17672:	2bf9      	cmp	r3, #249	; 0xf9
   17674:	d91b      	bls.n	176ae <Sd::Mount(SdInterface::CardInfo_t*)+0xea>
    {
      LOG_ERROR("Failed to initiate SPI mode within timeout. Aborting!");
   17676:	f240 13ff 	movw	r3, #511	; 0x1ff
   1767a:	4a7e      	ldr	r2, [pc, #504]	; (17874 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   1767c:	497e      	ldr	r1, [pc, #504]	; (17878 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b4>)
   1767e:	487f      	ldr	r0, [pc, #508]	; (1787c <Sd::Mount(SdInterface::CardInfo_t*)+0x2b8>)
   17680:	f7fe fd04 	bl	1608c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17684:	9b03      	ldr	r3, [sp, #12]
   17686:	681b      	ldr	r3, [r3, #0]
   17688:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   1768a:	9b02      	ldr	r3, [sp, #8]
   1768c:	f103 0208 	add.w	r2, r3, #8
   17690:	2300      	movs	r3, #0
   17692:	9301      	str	r3, [sp, #4]
   17694:	2300      	movs	r3, #0
   17696:	9300      	str	r3, [sp, #0]
   17698:	4613      	mov	r3, r2
   1769a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1769e:	21ff      	movs	r1, #255	; 0xff
   176a0:	9803      	ldr	r0, [sp, #12]
   176a2:	47a0      	blx	r4
   176a4:	4602      	mov	r2, r0
   176a6:	9b02      	ldr	r3, [sp, #8]
   176a8:	611a      	str	r2, [r3, #16]
      return false;
   176aa:	2400      	movs	r4, #0
   176ac:	e10c      	b.n	178c8 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Send the host's supported voltage (3.3V) and ask if the card
    // supports it
    LOG_DEBUG("Checking Current SD Card Voltage Level...");
    constexpr uint8_t kCheckPattern = 0xAB;
   176ae:	23ab      	movs	r3, #171	; 0xab
   176b0:	f88d 301f 	strb.w	r3, [sp, #31]
    uint64_t supported_voltage      = 0x00000001;
   176b4:	f04f 0301 	mov.w	r3, #1
   176b8:	f04f 0400 	mov.w	r4, #0
   176bc:	e9cd 3404 	strd	r3, r4, [sp, #16]
    sd->response.length =
        SendCmd(Command::kGetOp,
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
                sd->response.data.byte, 100, KeepAlive::kYes);
   176c0:	9b03      	ldr	r3, [sp, #12]
   176c2:	681b      	ldr	r3, [r3, #0]
   176c4:	681c      	ldr	r4, [r3, #0]
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
   176c6:	9b04      	ldr	r3, [sp, #16]
   176c8:	021b      	lsls	r3, r3, #8
        SendCmd(Command::kGetOp,
   176ca:	f043 02ab 	orr.w	r2, r3, #171	; 0xab
   176ce:	9b02      	ldr	r3, [sp, #8]
   176d0:	f103 0108 	add.w	r1, r3, #8
   176d4:	2301      	movs	r3, #1
   176d6:	9301      	str	r3, [sp, #4]
   176d8:	2364      	movs	r3, #100	; 0x64
   176da:	9300      	str	r3, [sp, #0]
   176dc:	460b      	mov	r3, r1
   176de:	2148      	movs	r1, #72	; 0x48
   176e0:	9803      	ldr	r0, [sp, #12]
   176e2:	47a0      	blx	r4
   176e4:	4602      	mov	r2, r0
    sd->response.length =
   176e6:	9b02      	ldr	r3, [sp, #8]
   176e8:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[4] != kCheckPattern)
   176ea:	9b02      	ldr	r3, [sp, #8]
   176ec:	7b1b      	ldrb	r3, [r3, #12]
   176ee:	2bab      	cmp	r3, #171	; 0xab
   176f0:	d01b      	beq.n	1772a <Sd::Mount(SdInterface::CardInfo_t*)+0x166>
    {
      // If the last byte is not an exact echo of the LSB of the kGetOp
      // command's argument, this response is invalid
      LOG_ERROR("Response integrity check failed. Aborting!");
   176f2:	f240 2312 	movw	r3, #530	; 0x212
   176f6:	4a5f      	ldr	r2, [pc, #380]	; (17874 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   176f8:	4961      	ldr	r1, [pc, #388]	; (17880 <Sd::Mount(SdInterface::CardInfo_t*)+0x2bc>)
   176fa:	4862      	ldr	r0, [pc, #392]	; (17884 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c0>)
   176fc:	f7fe fcc6 	bl	1608c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17700:	9b03      	ldr	r3, [sp, #12]
   17702:	681b      	ldr	r3, [r3, #0]
   17704:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   17706:	9b02      	ldr	r3, [sp, #8]
   17708:	f103 0208 	add.w	r2, r3, #8
   1770c:	2300      	movs	r3, #0
   1770e:	9301      	str	r3, [sp, #4]
   17710:	2300      	movs	r3, #0
   17712:	9300      	str	r3, [sp, #0]
   17714:	4613      	mov	r3, r2
   17716:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1771a:	21ff      	movs	r1, #255	; 0xff
   1771c:	9803      	ldr	r0, [sp, #12]
   1771e:	47a0      	blx	r4
   17720:	4602      	mov	r2, r0
   17722:	9b02      	ldr	r3, [sp, #8]
   17724:	611a      	str	r2, [r3, #16]
      return false;
   17726:	2400      	movs	r4, #0
   17728:	e0ce      	b.n	178c8 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }
    else if (sd->response.data.byte[3] &
   1772a:	9b02      	ldr	r3, [sp, #8]
   1772c:	7adb      	ldrb	r3, [r3, #11]
   1772e:	4619      	mov	r1, r3
             (supported_voltage == static_cast<uint64_t>(0x00)))
   17730:	9a04      	ldr	r2, [sp, #16]
   17732:	9b05      	ldr	r3, [sp, #20]
   17734:	4313      	orrs	r3, r2
   17736:	2b00      	cmp	r3, #0
   17738:	bf0c      	ite	eq
   1773a:	2301      	moveq	r3, #1
   1773c:	2300      	movne	r3, #0
   1773e:	b2db      	uxtb	r3, r3
    else if (sd->response.data.byte[3] &
   17740:	400b      	ands	r3, r1
   17742:	2b00      	cmp	r3, #0
   17744:	d01b      	beq.n	1777e <Sd::Mount(SdInterface::CardInfo_t*)+0x1ba>
    {
      // If the 2nd-to-last byte of the reponse AND'ed with our host
      // device's supported voltage range is 0x00, the SD card doesn't
      // support our device's operating voltage
      LOG_ERROR("Unsupported voltage in use. Aborting!");
   17746:	f240 231d 	movw	r3, #541	; 0x21d
   1774a:	4a4a      	ldr	r2, [pc, #296]	; (17874 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   1774c:	494e      	ldr	r1, [pc, #312]	; (17888 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c4>)
   1774e:	484f      	ldr	r0, [pc, #316]	; (1788c <Sd::Mount(SdInterface::CardInfo_t*)+0x2c8>)
   17750:	f7fe fc9c 	bl	1608c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17754:	9b03      	ldr	r3, [sp, #12]
   17756:	681b      	ldr	r3, [r3, #0]
   17758:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   1775a:	9b02      	ldr	r3, [sp, #8]
   1775c:	f103 0208 	add.w	r2, r3, #8
   17760:	2300      	movs	r3, #0
   17762:	9301      	str	r3, [sp, #4]
   17764:	2300      	movs	r3, #0
   17766:	9300      	str	r3, [sp, #0]
   17768:	4613      	mov	r3, r2
   1776a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1776e:	21ff      	movs	r1, #255	; 0xff
   17770:	9803      	ldr	r0, [sp, #12]
   17772:	47a0      	blx	r4
   17774:	4602      	mov	r2, r0
   17776:	9b02      	ldr	r3, [sp, #8]
   17778:	611a      	str	r2, [r3, #16]
      return false;
   1777a:	2400      	movs	r4, #0
   1777c:	e0a4      	b.n	178c8 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Indicate that the host supports SDHC/SDXC and wait for card to
    // shift out of idle state
    LOG_DEBUG("Expressing High-Capacity SD Card Support...");
    tries = 0;
   1777e:	2300      	movs	r3, #0
   17780:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    do
    {
      // Send host's operating conditions
      sd->response.length =
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
                  KeepAlive::kYes);
   17784:	9b03      	ldr	r3, [sp, #12]
   17786:	681b      	ldr	r3, [r3, #0]
   17788:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
   1778a:	9b02      	ldr	r3, [sp, #8]
   1778c:	f103 0208 	add.w	r2, r3, #8
   17790:	2301      	movs	r3, #1
   17792:	9301      	str	r3, [sp, #4]
   17794:	2364      	movs	r3, #100	; 0x64
   17796:	9300      	str	r3, [sp, #0]
   17798:	4613      	mov	r3, r2
   1779a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   1779e:	2141      	movs	r1, #65	; 0x41
   177a0:	9803      	ldr	r0, [sp, #12]
   177a2:	47a0      	blx	r4
   177a4:	4602      	mov	r2, r0
      sd->response.length =
   177a6:	9b02      	ldr	r3, [sp, #8]
   177a8:	611a      	str	r2, [r3, #16]
      tries++;
   177aa:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   177ae:	3301      	adds	r3, #1
   177b0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    } while (tries < kBusTimeout && sd->response.data.byte[0] & 0x01);
   177b4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   177b8:	2bf9      	cmp	r3, #249	; 0xf9
   177ba:	d806      	bhi.n	177ca <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
   177bc:	9b02      	ldr	r3, [sp, #8]
   177be:	7a1b      	ldrb	r3, [r3, #8]
   177c0:	f003 0301 	and.w	r3, r3, #1
   177c4:	2b00      	cmp	r3, #0
   177c6:	d000      	beq.n	177ca <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
    do
   177c8:	e7dc      	b.n	17784 <Sd::Mount(SdInterface::CardInfo_t*)+0x1c0>
    if (tries == kBusTimeout)
   177ca:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   177ce:	2bfa      	cmp	r3, #250	; 0xfa
   177d0:	d11b      	bne.n	1780a <Sd::Mount(SdInterface::CardInfo_t*)+0x246>
    {
      LOG_ERROR("SD Card timed out. Aborting!");
   177d2:	f240 2331 	movw	r3, #561	; 0x231
   177d6:	4a27      	ldr	r2, [pc, #156]	; (17874 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   177d8:	492d      	ldr	r1, [pc, #180]	; (17890 <Sd::Mount(SdInterface::CardInfo_t*)+0x2cc>)
   177da:	482e      	ldr	r0, [pc, #184]	; (17894 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d0>)
   177dc:	f7fe fc56 	bl	1608c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   177e0:	9b03      	ldr	r3, [sp, #12]
   177e2:	681b      	ldr	r3, [r3, #0]
   177e4:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   177e6:	9b02      	ldr	r3, [sp, #8]
   177e8:	f103 0208 	add.w	r2, r3, #8
   177ec:	2300      	movs	r3, #0
   177ee:	9301      	str	r3, [sp, #4]
   177f0:	2300      	movs	r3, #0
   177f2:	9300      	str	r3, [sp, #0]
   177f4:	4613      	mov	r3, r2
   177f6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   177fa:	21ff      	movs	r1, #255	; 0xff
   177fc:	9803      	ldr	r0, [sp, #12]
   177fe:	47a0      	blx	r4
   17800:	4602      	mov	r2, r0
   17802:	9b02      	ldr	r3, [sp, #8]
   17804:	611a      	str	r2, [r3, #16]
      return false;
   17806:	2400      	movs	r4, #0
   17808:	e05e      	b.n	178c8 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    // After card is ready, acquire card capacity info using kGetOcr a
    // second time
    LOG_DEBUG("Reading Card Capacity Information...");
    // Read CCS
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   1780a:	9b03      	ldr	r3, [sp, #12]
   1780c:	681b      	ldr	r3, [r3, #0]
   1780e:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
   17810:	9b02      	ldr	r3, [sp, #8]
   17812:	f103 0208 	add.w	r2, r3, #8
   17816:	2301      	movs	r3, #1
   17818:	9301      	str	r3, [sp, #4]
   1781a:	2364      	movs	r3, #100	; 0x64
   1781c:	9300      	str	r3, [sp, #0]
   1781e:	4613      	mov	r3, r2
   17820:	2200      	movs	r2, #0
   17822:	217a      	movs	r1, #122	; 0x7a
   17824:	9803      	ldr	r0, [sp, #12]
   17826:	47a0      	blx	r4
   17828:	4602      	mov	r2, r0
   1782a:	9b02      	ldr	r3, [sp, #8]
   1782c:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[1] & 0x40)
   1782e:	9b02      	ldr	r3, [sp, #8]
   17830:	7a5b      	ldrb	r3, [r3, #9]
   17832:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17836:	2b00      	cmp	r3, #0
   17838:	d003      	beq.n	17842 <Sd::Mount(SdInterface::CardInfo_t*)+0x27e>
    {
      // The card is either high or extended capacity
      LOG_DEBUG("SD Card is HC/XC");
      sd->type = Type::kSDHC;
   1783a:	9b02      	ldr	r3, [sp, #8]
   1783c:	2201      	movs	r2, #1
   1783e:	605a      	str	r2, [r3, #4]
   17840:	e002      	b.n	17848 <Sd::Mount(SdInterface::CardInfo_t*)+0x284>
    }
    else
    {
      // The card is standard capacity
      LOG_DEBUG("SD Card is SC");
      sd->type = Type::kSDSC;
   17842:	9b02      	ldr	r3, [sp, #8]
   17844:	2200      	movs	r2, #0
   17846:	605a      	str	r2, [r3, #4]
    }

    // Store OCR information
    for (int i = 0; i < 4; i++)
   17848:	2300      	movs	r3, #0
   1784a:	9308      	str	r3, [sp, #32]
   1784c:	9b08      	ldr	r3, [sp, #32]
   1784e:	2b03      	cmp	r3, #3
   17850:	dc22      	bgt.n	17898 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d4>
    {
      // ensure OCR doesn't capture the R1 section of the response
      sd->ocr.byte[i] = sd->response.data.byte[i + 1];
   17852:	9b08      	ldr	r3, [sp, #32]
   17854:	3301      	adds	r3, #1
   17856:	9a02      	ldr	r2, [sp, #8]
   17858:	4413      	add	r3, r2
   1785a:	7a19      	ldrb	r1, [r3, #8]
   1785c:	9a02      	ldr	r2, [sp, #8]
   1785e:	9b08      	ldr	r3, [sp, #32]
   17860:	4413      	add	r3, r2
   17862:	460a      	mov	r2, r1
   17864:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < 4; i++)
   17866:	9b08      	ldr	r3, [sp, #32]
   17868:	3301      	adds	r3, #1
   1786a:	9308      	str	r3, [sp, #32]
   1786c:	e7ee      	b.n	1784c <Sd::Mount(SdInterface::CardInfo_t*)+0x288>
   1786e:	bf00      	nop
   17870:	000175c5 	.word	0x000175c5
   17874:	0001b1d4 	.word	0x0001b1d4
   17878:	0001aeec 	.word	0x0001aeec
   1787c:	0001a504 	.word	0x0001a504
   17880:	0001aef4 	.word	0x0001aef4
   17884:	0001a574 	.word	0x0001a574
   17888:	0001aefc 	.word	0x0001aefc
   1788c:	0001a5d8 	.word	0x0001a5d8
   17890:	0001af04 	.word	0x0001af04
   17894:	0001a638 	.word	0x0001a638
    }

    // If card is SDSC, manually set its block size
    if (sd->type == Type::kSDSC)
   17898:	9b02      	ldr	r3, [sp, #8]
   1789a:	685b      	ldr	r3, [r3, #4]
   1789c:	2b00      	cmp	r3, #0
   1789e:	d112      	bne.n	178c6 <Sd::Mount(SdInterface::CardInfo_t*)+0x302>
    {
      // Send requested byte size
      sd->response.length =
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
                  sd->response.data.byte, 0, KeepAlive::kYes);
   178a0:	9b03      	ldr	r3, [sp, #12]
   178a2:	681b      	ldr	r3, [r3, #0]
   178a4:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
   178a6:	9b02      	ldr	r3, [sp, #8]
   178a8:	f103 0208 	add.w	r2, r3, #8
   178ac:	2301      	movs	r3, #1
   178ae:	9301      	str	r3, [sp, #4]
   178b0:	2300      	movs	r3, #0
   178b2:	9300      	str	r3, [sp, #0]
   178b4:	4613      	mov	r3, r2
   178b6:	f44f 7200 	mov.w	r2, #512	; 0x200
   178ba:	2150      	movs	r1, #80	; 0x50
   178bc:	9803      	ldr	r0, [sp, #12]
   178be:	47a0      	blx	r4
   178c0:	4602      	mov	r2, r0
      sd->response.length =
   178c2:	9b02      	ldr	r3, [sp, #8]
   178c4:	611a      	str	r2, [r3, #16]
    }

    return true;
   178c6:	2401      	movs	r4, #1
   178c8:	462b      	mov	r3, r5
   178ca:	4619      	mov	r1, r3
   178cc:	4803      	ldr	r0, [pc, #12]	; (178dc <Sd::Mount(SdInterface::CardInfo_t*)+0x318>)
   178ce:	f7fb fe53 	bl	13578 <__cyg_profile_func_exit>
   178d2:	4623      	mov	r3, r4
  }
   178d4:	4618      	mov	r0, r3
   178d6:	b00b      	add	sp, #44	; 0x2c
   178d8:	bd30      	pop	{r4, r5, pc}
   178da:	bf00      	nop
   178dc:	000175c5 	.word	0x000175c5

000178e0 <Sd::ToBool(bool)>:

  // Returns string to represent a boolean value
  const char * ToBool(bool condition)
   178e0:	b530      	push	{r4, r5, lr}
   178e2:	b083      	sub	sp, #12
   178e4:	4675      	mov	r5, lr
   178e6:	9001      	str	r0, [sp, #4]
   178e8:	460b      	mov	r3, r1
   178ea:	f88d 3003 	strb.w	r3, [sp, #3]
   178ee:	462b      	mov	r3, r5
   178f0:	4619      	mov	r1, r3
   178f2:	4809      	ldr	r0, [pc, #36]	; (17918 <Sd::ToBool(bool)+0x38>)
   178f4:	f7fb fe2c 	bl	13550 <__cyg_profile_func_enter>
  {
    return (condition) ? "true" : "false";
   178f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
   178fc:	2b00      	cmp	r3, #0
   178fe:	d001      	beq.n	17904 <Sd::ToBool(bool)+0x24>
   17900:	4c06      	ldr	r4, [pc, #24]	; (1791c <Sd::ToBool(bool)+0x3c>)
   17902:	e000      	b.n	17906 <Sd::ToBool(bool)+0x26>
   17904:	4c06      	ldr	r4, [pc, #24]	; (17920 <Sd::ToBool(bool)+0x40>)
   17906:	462b      	mov	r3, r5
   17908:	4619      	mov	r1, r3
   1790a:	4803      	ldr	r0, [pc, #12]	; (17918 <Sd::ToBool(bool)+0x38>)
   1790c:	f7fb fe34 	bl	13578 <__cyg_profile_func_exit>
   17910:	4623      	mov	r3, r4
  }
   17912:	4618      	mov	r0, r3
   17914:	b003      	add	sp, #12
   17916:	bd30      	pop	{r4, r5, pc}
   17918:	000178e1 	.word	0x000178e1
   1791c:	0001a690 	.word	0x0001a690
   17920:	0001a698 	.word	0x0001a698

00017924 <Sd::WaitToReadBlock()>:

  // Waits for the card to respond after a single or multi block read cmd is
  // sent.
  void WaitToReadBlock()
   17924:	b510      	push	{r4, lr}
   17926:	b084      	sub	sp, #16
   17928:	4674      	mov	r4, lr
   1792a:	9001      	str	r0, [sp, #4]
   1792c:	4623      	mov	r3, r4
   1792e:	4619      	mov	r1, r3
   17930:	4814      	ldr	r0, [pc, #80]	; (17984 <Sd::WaitToReadBlock()+0x60>)
   17932:	f7fb fe0d 	bl	13550 <__cyg_profile_func_enter>
    // Bit 4 -->  If set, card is locked
    // Bit 3 -->  If set, address is out or range
    // Bit 2 -->  If set, card ECC failed
    // Bit 1 -->  If set, CC error occurred
    // Bit 0 -->  If set, a generic error occurred
    uint8_t wait_byte = 0x00;
   17936:	2300      	movs	r3, #0
   17938:	f88d 300f 	strb.w	r3, [sp, #15]
    do
    {
      wait_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1793c:	9b01      	ldr	r3, [sp, #4]
   1793e:	685a      	ldr	r2, [r3, #4]
   17940:	9b01      	ldr	r3, [sp, #4]
   17942:	685b      	ldr	r3, [r3, #4]
   17944:	681b      	ldr	r3, [r3, #0]
   17946:	3308      	adds	r3, #8
   17948:	681b      	ldr	r3, [r3, #0]
   1794a:	21ff      	movs	r1, #255	; 0xff
   1794c:	4610      	mov	r0, r2
   1794e:	4798      	blx	r3
   17950:	4603      	mov	r3, r0
   17952:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (wait_byte != 0xFE && (wait_byte & 0xE0) != 0x00);
   17956:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1795a:	2bfe      	cmp	r3, #254	; 0xfe
   1795c:	d006      	beq.n	1796c <Sd::WaitToReadBlock()+0x48>
   1795e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   17962:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   17966:	2b00      	cmp	r3, #0
   17968:	d000      	beq.n	1796c <Sd::WaitToReadBlock()+0x48>
    do
   1796a:	e7e7      	b.n	1793c <Sd::WaitToReadBlock()+0x18>

    // DEBUG: Check the value of the wait byte
    if (wait_byte == 0xFE)
   1796c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   17970:	2bfe      	cmp	r3, #254	; 0xfe
   17972:	4623      	mov	r3, r4
   17974:	4619      	mov	r1, r3
   17976:	4803      	ldr	r0, [pc, #12]	; (17984 <Sd::WaitToReadBlock()+0x60>)
   17978:	f7fb fdfe 	bl	13578 <__cyg_profile_func_exit>
      LOG_DEBUG("Addr Out of Range?: %s", ToBool(wait_byte & 0x08));
      LOG_DEBUG("Card ECC Failed?: %s", ToBool(wait_byte & 0x04));
      LOG_DEBUG("CC Error?: %s", ToBool(wait_byte & 0x02));
      LOG_DEBUG("Error?: %s", ToBool(wait_byte & 0x01));
    }
  }
   1797c:	bf00      	nop
   1797e:	b004      	add	sp, #16
   17980:	bd10      	pop	{r4, pc}
   17982:	bf00      	nop
   17984:	00017925 	.word	0x00017925

00017988 <Sd::WaitWhileBusy()>:

  // Waits for the card to be ready to receive a new block after one has
  // been written or erased
  void WaitWhileBusy()
   17988:	b510      	push	{r4, lr}
   1798a:	b084      	sub	sp, #16
   1798c:	4674      	mov	r4, lr
   1798e:	9001      	str	r0, [sp, #4]
   17990:	4623      	mov	r3, r4
   17992:	4619      	mov	r1, r3
   17994:	480f      	ldr	r0, [pc, #60]	; (179d4 <Sd::WaitWhileBusy()+0x4c>)
   17996:	f7fb fddb 	bl	13550 <__cyg_profile_func_enter>
  {
    // Wait for the card to finish programming (i.e. when the
    // bytes return to 0xFF)
    uint8_t busy_byte = 0x00;
   1799a:	2300      	movs	r3, #0
   1799c:	f88d 300f 	strb.w	r3, [sp, #15]
    LOG_DEBUG("Card is busy. Waiting for it to finish...");
    do
    {
      busy_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   179a0:	9b01      	ldr	r3, [sp, #4]
   179a2:	685a      	ldr	r2, [r3, #4]
   179a4:	9b01      	ldr	r3, [sp, #4]
   179a6:	685b      	ldr	r3, [r3, #4]
   179a8:	681b      	ldr	r3, [r3, #0]
   179aa:	3308      	adds	r3, #8
   179ac:	681b      	ldr	r3, [r3, #0]
   179ae:	21ff      	movs	r1, #255	; 0xff
   179b0:	4610      	mov	r0, r2
   179b2:	4798      	blx	r3
   179b4:	4603      	mov	r3, r0
   179b6:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (busy_byte != 0xFF);
   179ba:	f89d 300f 	ldrb.w	r3, [sp, #15]
   179be:	2bff      	cmp	r3, #255	; 0xff
   179c0:	d000      	beq.n	179c4 <Sd::WaitWhileBusy()+0x3c>
    do
   179c2:	e7ed      	b.n	179a0 <Sd::WaitWhileBusy()+0x18>
   179c4:	4623      	mov	r3, r4
   179c6:	4619      	mov	r1, r3
   179c8:	4802      	ldr	r0, [pc, #8]	; (179d4 <Sd::WaitWhileBusy()+0x4c>)
   179ca:	f7fb fdd5 	bl	13578 <__cyg_profile_func_exit>
    LOG_DEBUG("Card finished!");
  }
   179ce:	bf00      	nop
   179d0:	b004      	add	sp, #16
   179d2:	bd10      	pop	{r4, pc}
   179d4:	00017989 	.word	0x00017989

000179d8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)>:

  // Read any number of blocks from the SD card
  uint8_t ReadBlock(uint32_t address, uint8_t * array,
   179d8:	b530      	push	{r4, r5, lr}
   179da:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
   179de:	4675      	mov	r5, lr
   179e0:	ac05      	add	r4, sp, #20
   179e2:	6020      	str	r0, [r4, #0]
   179e4:	a804      	add	r0, sp, #16
   179e6:	6001      	str	r1, [r0, #0]
   179e8:	a903      	add	r1, sp, #12
   179ea:	600a      	str	r2, [r1, #0]
   179ec:	aa02      	add	r2, sp, #8
   179ee:	6013      	str	r3, [r2, #0]
   179f0:	462b      	mov	r3, r5
   179f2:	4619      	mov	r1, r3
   179f4:	487d      	ldr	r0, [pc, #500]	; (17bec <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x214>)
   179f6:	f7fb fdab 	bl	13550 <__cyg_profile_func_enter>
                    uint32_t blocks = 1) override
  {
    LOG_DEBUG("Block %" PRId32 " :: 0x%" PRIX32 " for %" PRId32 " blocks",
              address, address, blocks);
    // Wait for a previous command to finish
    WaitWhileBusy();
   179fa:	ab05      	add	r3, sp, #20
   179fc:	6818      	ldr	r0, [r3, #0]
   179fe:	f7ff ffc3 	bl	17988 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool payload_had_bad_crc = false;
   17a02:	2300      	movs	r3, #0
   17a04:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247

    // Create a temporary place to store blocks of 512 bytes (this is now
    // possible because the constructor enforces block size cross-
    // compatibility)
    uint8_t block_store[512] = { 0 };
   17a08:	ab06      	add	r3, sp, #24
   17a0a:	4618      	mov	r0, r3
   17a0c:	f44f 7300 	mov.w	r3, #512	; 0x200
   17a10:	461a      	mov	r2, r3
   17a12:	2100      	movs	r1, #0
   17a14:	f001 f9d1 	bl	18dba <memset>

    // Determine appropriate command to send
    Command read_cmd;
    if (blocks > 1)
   17a18:	ab02      	add	r3, sp, #8
   17a1a:	681b      	ldr	r3, [r3, #0]
   17a1c:	2b01      	cmp	r3, #1
   17a1e:	d902      	bls.n	17a26 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x4e>
    {
      read_cmd = Command::kReadMulti;
   17a20:	2352      	movs	r3, #82	; 0x52
   17a22:	9390      	str	r3, [sp, #576]	; 0x240
   17a24:	e001      	b.n	17a2a <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x52>
    }
    else
    {
      read_cmd = Command::kReadSingle;
   17a26:	2351      	movs	r3, #81	; 0x51
   17a28:	9390      	str	r3, [sp, #576]	; 0x240
    }

    // Send initial read command
    sd.response.length =
        SendCmd(read_cmd, address, sd.response.data.byte, 100, KeepAlive::kYes);
   17a2a:	ab05      	add	r3, sp, #20
   17a2c:	681b      	ldr	r3, [r3, #0]
   17a2e:	681b      	ldr	r3, [r3, #0]
   17a30:	681c      	ldr	r4, [r3, #0]
   17a32:	ab86      	add	r3, sp, #536	; 0x218
   17a34:	f103 0108 	add.w	r1, r3, #8
   17a38:	aa04      	add	r2, sp, #16
   17a3a:	a805      	add	r0, sp, #20
   17a3c:	2301      	movs	r3, #1
   17a3e:	9301      	str	r3, [sp, #4]
   17a40:	2364      	movs	r3, #100	; 0x64
   17a42:	9300      	str	r3, [sp, #0]
   17a44:	460b      	mov	r3, r1
   17a46:	6812      	ldr	r2, [r2, #0]
   17a48:	9990      	ldr	r1, [sp, #576]	; 0x240
   17a4a:	6800      	ldr	r0, [r0, #0]
   17a4c:	47a0      	blx	r4
   17a4e:	4603      	mov	r3, r0
    sd.response.length =
   17a50:	938a      	str	r3, [sp, #552]	; 0x228
    LOG_DEBUG("Sent Read Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the command was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   17a52:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17a56:	2b00      	cmp	r3, #0
   17a58:	f040 80d8 	bne.w	17c0c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x234>
    {
      // For every block requested
      uint16_t block_count;
      for (block_count = 0; block_count < blocks; block_count++)
   17a5c:	2300      	movs	r3, #0
   17a5e:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   17a62:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   17a66:	aa02      	add	r2, sp, #8
   17a68:	6812      	ldr	r2, [r2, #0]
   17a6a:	429a      	cmp	r2, r3
   17a6c:	f240 8099 	bls.w	17ba2 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1ca>
      {
        // Wait for the card to respond with a ready signal
        WaitToReadBlock();
   17a70:	ab05      	add	r3, sp, #20
   17a72:	6818      	ldr	r0, [r3, #0]
   17a74:	f7ff ff56 	bl	17924 <Sd::WaitToReadBlock()>

        // Calculate the block address offset
        uint16_t block_addr_offset =
   17a78:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   17a7c:	025b      	lsls	r3, r3, #9
   17a7e:	f8ad 323a 	strh.w	r3, [sp, #570]	; 0x23a
            static_cast<uint16_t>(block_count * kBlockSize);

        // Read all the bytes of a single block
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   17a82:	2300      	movs	r3, #0
   17a84:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   17a88:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   17a8c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   17a90:	d22b      	bcs.n	17aea <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x112>
        {
          // Calculate the current storage index
          uint16_t storage_index =
   17a92:	f8bd 223a 	ldrh.w	r2, [sp, #570]	; 0x23a
   17a96:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   17a9a:	4413      	add	r3, r2
   17a9c:	f8ad 3238 	strh.w	r3, [sp, #568]	; 0x238
              static_cast<uint16_t>(block_addr_offset + byte_count);

          // Transfer a byte to read a block from the SD card
          array[storage_index] =
              static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   17aa0:	ab05      	add	r3, sp, #20
   17aa2:	681b      	ldr	r3, [r3, #0]
   17aa4:	685a      	ldr	r2, [r3, #4]
   17aa6:	ab05      	add	r3, sp, #20
   17aa8:	681b      	ldr	r3, [r3, #0]
   17aaa:	685b      	ldr	r3, [r3, #4]
   17aac:	681b      	ldr	r3, [r3, #0]
   17aae:	3308      	adds	r3, #8
   17ab0:	681b      	ldr	r3, [r3, #0]
   17ab2:	21ff      	movs	r1, #255	; 0xff
   17ab4:	4610      	mov	r0, r2
   17ab6:	4798      	blx	r3
   17ab8:	4603      	mov	r3, r0
   17aba:	4619      	mov	r1, r3
          array[storage_index] =
   17abc:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   17ac0:	aa03      	add	r2, sp, #12
   17ac2:	6812      	ldr	r2, [r2, #0]
   17ac4:	4413      	add	r3, r2
   17ac6:	b2ca      	uxtb	r2, r1
   17ac8:	701a      	strb	r2, [r3, #0]

          // Copy that byte into our temporary block store
          block_store[byte_count] = array[storage_index];
   17aca:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   17ace:	aa03      	add	r2, sp, #12
   17ad0:	6812      	ldr	r2, [r2, #0]
   17ad2:	441a      	add	r2, r3
   17ad4:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   17ad8:	7811      	ldrb	r1, [r2, #0]
   17ada:	aa06      	add	r2, sp, #24
   17adc:	54d1      	strb	r1, [r2, r3]
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   17ade:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   17ae2:	3301      	adds	r3, #1
   17ae4:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   17ae8:	e7ce      	b.n	17a88 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0xb0>
        }

        // Then read the block's 16-bit CRC (i.e. read two bytes)
        uint16_t block_crc =
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   17aea:	ab05      	add	r3, sp, #20
   17aec:	681b      	ldr	r3, [r3, #0]
   17aee:	685a      	ldr	r2, [r3, #4]
   17af0:	ab05      	add	r3, sp, #20
   17af2:	681b      	ldr	r3, [r3, #0]
   17af4:	685b      	ldr	r3, [r3, #4]
   17af6:	681b      	ldr	r3, [r3, #0]
   17af8:	3308      	adds	r3, #8
   17afa:	681b      	ldr	r3, [r3, #0]
   17afc:	21ff      	movs	r1, #255	; 0xff
   17afe:	4610      	mov	r0, r2
   17b00:	4798      	blx	r3
   17b02:	4603      	mov	r3, r0
   17b04:	021b      	lsls	r3, r3, #8
   17b06:	b21c      	sxth	r4, r3
                                  ssp_interface_->Transfer(0xFF));
   17b08:	ab05      	add	r3, sp, #20
   17b0a:	681b      	ldr	r3, [r3, #0]
   17b0c:	685a      	ldr	r2, [r3, #4]
   17b0e:	ab05      	add	r3, sp, #20
   17b10:	681b      	ldr	r3, [r3, #0]
   17b12:	685b      	ldr	r3, [r3, #4]
   17b14:	681b      	ldr	r3, [r3, #0]
   17b16:	3308      	adds	r3, #8
   17b18:	681b      	ldr	r3, [r3, #0]
   17b1a:	21ff      	movs	r1, #255	; 0xff
   17b1c:	4610      	mov	r0, r2
   17b1e:	4798      	blx	r3
   17b20:	4603      	mov	r3, r0
   17b22:	b21b      	sxth	r3, r3
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   17b24:	4323      	orrs	r3, r4
   17b26:	b21b      	sxth	r3, r3
                                  ssp_interface_->Transfer(0xFF));
   17b28:	f8ad 3236 	strh.w	r3, [sp, #566]	; 0x236

        // Run a CRC-16 calculation on the message to determine if the
        // received CRCs match (i.e. checks if the block data is
        // valid).
        uint16_t expected_block_crc = GetCrc16(block_store, 512);
   17b2c:	ab05      	add	r3, sp, #20
   17b2e:	681b      	ldr	r3, [r3, #0]
   17b30:	681b      	ldr	r3, [r3, #0]
   17b32:	3320      	adds	r3, #32
   17b34:	681b      	ldr	r3, [r3, #0]
   17b36:	a906      	add	r1, sp, #24
   17b38:	a805      	add	r0, sp, #20
   17b3a:	f44f 7200 	mov.w	r2, #512	; 0x200
   17b3e:	6800      	ldr	r0, [r0, #0]
   17b40:	4798      	blx	r3
   17b42:	4603      	mov	r3, r0
   17b44:	f8ad 3234 	strh.w	r3, [sp, #564]	; 0x234

        LOG_DEBUG("Block #%d @ 0x%" PRIX32 " acquired", block_count, address);
        LOG_DEBUG("Expecting block crc16 '0x%04X'", expected_block_crc);
        LOG_DEBUG("Got '0x%04X'", block_crc);
        if (expected_block_crc != block_crc)
   17b48:	f8bd 2234 	ldrh.w	r2, [sp, #564]	; 0x234
   17b4c:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   17b50:	429a      	cmp	r2, r3
   17b52:	d020      	beq.n	17b96 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1be>
        {
          // If they do not match, set the bad crc status
          payload_had_bad_crc = true;
   17b54:	2301      	movs	r3, #1
   17b56:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247
          LOG_ERROR("While Reading Block #%d CRC16:", block_count);
   17b5a:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   17b5e:	9300      	str	r3, [sp, #0]
   17b60:	f240 23ed 	movw	r3, #749	; 0x2ed
   17b64:	4a22      	ldr	r2, [pc, #136]	; (17bf0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   17b66:	4923      	ldr	r1, [pc, #140]	; (17bf4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x21c>)
   17b68:	4823      	ldr	r0, [pc, #140]	; (17bf8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x220>)
   17b6a:	f7fe fa8f 	bl	1608c <printf>
          LOG_ERROR("Expected '0x%04X'", expected_block_crc);
   17b6e:	f8bd 3234 	ldrh.w	r3, [sp, #564]	; 0x234
   17b72:	9300      	str	r3, [sp, #0]
   17b74:	f240 23ee 	movw	r3, #750	; 0x2ee
   17b78:	4a1d      	ldr	r2, [pc, #116]	; (17bf0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   17b7a:	4920      	ldr	r1, [pc, #128]	; (17bfc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x224>)
   17b7c:	4820      	ldr	r0, [pc, #128]	; (17c00 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x228>)
   17b7e:	f7fe fa85 	bl	1608c <printf>
          LOG_ERROR("Got '0x%04X'", block_crc);
   17b82:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   17b86:	9300      	str	r3, [sp, #0]
   17b88:	f240 23ef 	movw	r3, #751	; 0x2ef
   17b8c:	4a18      	ldr	r2, [pc, #96]	; (17bf0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   17b8e:	491d      	ldr	r1, [pc, #116]	; (17c04 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x22c>)
   17b90:	481d      	ldr	r0, [pc, #116]	; (17c08 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x230>)
   17b92:	f7fe fa7b 	bl	1608c <printf>
      for (block_count = 0; block_count < blocks; block_count++)
   17b96:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   17b9a:	3301      	adds	r3, #1
   17b9c:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   17ba0:	e75f      	b.n	17a62 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x8a>
        }
      }

      // After reading multiple blocks, send the stop command to terminate the
      // transaction (i.e. no keep-alive)
      if (blocks > 1)
   17ba2:	ab02      	add	r3, sp, #8
   17ba4:	681b      	ldr	r3, [r3, #0]
   17ba6:	2b01      	cmp	r3, #1
   17ba8:	d913      	bls.n	17bd2 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1fa>
      {
        sd.response.length =
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
                    KeepAlive::kNo);
   17baa:	ab05      	add	r3, sp, #20
   17bac:	681b      	ldr	r3, [r3, #0]
   17bae:	681b      	ldr	r3, [r3, #0]
   17bb0:	681c      	ldr	r4, [r3, #0]
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
   17bb2:	ab86      	add	r3, sp, #536	; 0x218
   17bb4:	f103 0208 	add.w	r2, r3, #8
   17bb8:	a805      	add	r0, sp, #20
   17bba:	2300      	movs	r3, #0
   17bbc:	9301      	str	r3, [sp, #4]
   17bbe:	2364      	movs	r3, #100	; 0x64
   17bc0:	9300      	str	r3, [sp, #0]
   17bc2:	4613      	mov	r3, r2
   17bc4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17bc8:	214c      	movs	r1, #76	; 0x4c
   17bca:	6800      	ldr	r0, [r0, #0]
   17bcc:	47a0      	blx	r4
   17bce:	4603      	mov	r3, r0
        sd.response.length =
   17bd0:	938a      	str	r3, [sp, #552]	; 0x228
      LOG_DEBUG("Response Byte");
      LOG_DEBUG("0x%02X", sd.response.data.byte[0]);

      // If there was a bad crc from the payload, manually set the
      // CRC error flag in the command response byte
      if (payload_had_bad_crc)
   17bd2:	f89d 3247 	ldrb.w	r3, [sp, #583]	; 0x247
   17bd6:	2b00      	cmp	r3, #0
   17bd8:	f000 80c0 	beq.w	17d5c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
      {
        sd.response.data.byte[0] |= 0x08;
   17bdc:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17be0:	f043 0308 	orr.w	r3, r3, #8
   17be4:	b2db      	uxtb	r3, r3
   17be6:	f88d 3220 	strb.w	r3, [sp, #544]	; 0x220
   17bea:	e0b7      	b.n	17d5c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
   17bec:	000179d9 	.word	0x000179d9
   17bf0:	0001b208 	.word	0x0001b208
   17bf4:	0001af0c 	.word	0x0001af0c
   17bf8:	0001a6a0 	.word	0x0001a6a0
   17bfc:	0001af14 	.word	0x0001af14
   17c00:	0001a6f8 	.word	0x0001a6f8
   17c04:	0001af1c 	.word	0x0001af1c
   17c08:	0001a744 	.word	0x0001a744
      }
    }
    else
    {
      LOG_ERROR("Read Cmd was not acknowledged properly!");
   17c0c:	f240 3309 	movw	r3, #777	; 0x309
   17c10:	4a65      	ldr	r2, [pc, #404]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17c12:	4966      	ldr	r1, [pc, #408]	; (17dac <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d4>)
   17c14:	4866      	ldr	r0, [pc, #408]	; (17db0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d8>)
   17c16:	f7fe fa39 	bl	1608c <printf>
      LOG_ERROR("Parameter Err: %s", ToBool(sd.response.data.byte[0] & 0x40));
   17c1a:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17c1e:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17c22:	2b00      	cmp	r3, #0
   17c24:	bf14      	ite	ne
   17c26:	2301      	movne	r3, #1
   17c28:	2300      	moveq	r3, #0
   17c2a:	b2da      	uxtb	r2, r3
   17c2c:	ab05      	add	r3, sp, #20
   17c2e:	4611      	mov	r1, r2
   17c30:	6818      	ldr	r0, [r3, #0]
   17c32:	f7ff fe55 	bl	178e0 <Sd::ToBool(bool)>
   17c36:	4603      	mov	r3, r0
   17c38:	9300      	str	r3, [sp, #0]
   17c3a:	f240 330a 	movw	r3, #778	; 0x30a
   17c3e:	4a5a      	ldr	r2, [pc, #360]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17c40:	495c      	ldr	r1, [pc, #368]	; (17db4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3dc>)
   17c42:	485d      	ldr	r0, [pc, #372]	; (17db8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e0>)
   17c44:	f7fe fa22 	bl	1608c <printf>
      LOG_ERROR("Addr Err: %s", ToBool(sd.response.data.byte[0] & 0x20));
   17c48:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17c4c:	f003 0320 	and.w	r3, r3, #32
   17c50:	2b00      	cmp	r3, #0
   17c52:	bf14      	ite	ne
   17c54:	2301      	movne	r3, #1
   17c56:	2300      	moveq	r3, #0
   17c58:	b2da      	uxtb	r2, r3
   17c5a:	ab05      	add	r3, sp, #20
   17c5c:	4611      	mov	r1, r2
   17c5e:	6818      	ldr	r0, [r3, #0]
   17c60:	f7ff fe3e 	bl	178e0 <Sd::ToBool(bool)>
   17c64:	4603      	mov	r3, r0
   17c66:	9300      	str	r3, [sp, #0]
   17c68:	f240 330b 	movw	r3, #779	; 0x30b
   17c6c:	4a4e      	ldr	r2, [pc, #312]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17c6e:	4953      	ldr	r1, [pc, #332]	; (17dbc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e4>)
   17c70:	4853      	ldr	r0, [pc, #332]	; (17dc0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e8>)
   17c72:	f7fe fa0b 	bl	1608c <printf>
      LOG_ERROR("Erase Seq Err: %s", ToBool(sd.response.data.byte[0] & 0x10));
   17c76:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17c7a:	f003 0310 	and.w	r3, r3, #16
   17c7e:	2b00      	cmp	r3, #0
   17c80:	bf14      	ite	ne
   17c82:	2301      	movne	r3, #1
   17c84:	2300      	moveq	r3, #0
   17c86:	b2da      	uxtb	r2, r3
   17c88:	ab05      	add	r3, sp, #20
   17c8a:	4611      	mov	r1, r2
   17c8c:	6818      	ldr	r0, [r3, #0]
   17c8e:	f7ff fe27 	bl	178e0 <Sd::ToBool(bool)>
   17c92:	4603      	mov	r3, r0
   17c94:	9300      	str	r3, [sp, #0]
   17c96:	f44f 7343 	mov.w	r3, #780	; 0x30c
   17c9a:	4a43      	ldr	r2, [pc, #268]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17c9c:	4949      	ldr	r1, [pc, #292]	; (17dc4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3ec>)
   17c9e:	484a      	ldr	r0, [pc, #296]	; (17dc8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f0>)
   17ca0:	f7fe f9f4 	bl	1608c <printf>
      LOG_ERROR("Com CRC Err: %s", ToBool(sd.response.data.byte[0] & 0x08));
   17ca4:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17ca8:	f003 0308 	and.w	r3, r3, #8
   17cac:	2b00      	cmp	r3, #0
   17cae:	bf14      	ite	ne
   17cb0:	2301      	movne	r3, #1
   17cb2:	2300      	moveq	r3, #0
   17cb4:	b2da      	uxtb	r2, r3
   17cb6:	ab05      	add	r3, sp, #20
   17cb8:	4611      	mov	r1, r2
   17cba:	6818      	ldr	r0, [r3, #0]
   17cbc:	f7ff fe10 	bl	178e0 <Sd::ToBool(bool)>
   17cc0:	4603      	mov	r3, r0
   17cc2:	9300      	str	r3, [sp, #0]
   17cc4:	f240 330d 	movw	r3, #781	; 0x30d
   17cc8:	4a37      	ldr	r2, [pc, #220]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17cca:	4940      	ldr	r1, [pc, #256]	; (17dcc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f4>)
   17ccc:	4840      	ldr	r0, [pc, #256]	; (17dd0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f8>)
   17cce:	f7fe f9dd 	bl	1608c <printf>
      LOG_ERROR("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
   17cd2:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17cd6:	f003 0304 	and.w	r3, r3, #4
   17cda:	2b00      	cmp	r3, #0
   17cdc:	bf14      	ite	ne
   17cde:	2301      	movne	r3, #1
   17ce0:	2300      	moveq	r3, #0
   17ce2:	b2da      	uxtb	r2, r3
   17ce4:	ab05      	add	r3, sp, #20
   17ce6:	4611      	mov	r1, r2
   17ce8:	6818      	ldr	r0, [r3, #0]
   17cea:	f7ff fdf9 	bl	178e0 <Sd::ToBool(bool)>
   17cee:	4603      	mov	r3, r0
   17cf0:	9300      	str	r3, [sp, #0]
   17cf2:	f240 330e 	movw	r3, #782	; 0x30e
   17cf6:	4a2c      	ldr	r2, [pc, #176]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17cf8:	4936      	ldr	r1, [pc, #216]	; (17dd4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3fc>)
   17cfa:	4837      	ldr	r0, [pc, #220]	; (17dd8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x400>)
   17cfc:	f7fe f9c6 	bl	1608c <printf>
      LOG_ERROR("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
   17d00:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17d04:	f003 0302 	and.w	r3, r3, #2
   17d08:	2b00      	cmp	r3, #0
   17d0a:	bf14      	ite	ne
   17d0c:	2301      	movne	r3, #1
   17d0e:	2300      	moveq	r3, #0
   17d10:	b2da      	uxtb	r2, r3
   17d12:	ab05      	add	r3, sp, #20
   17d14:	4611      	mov	r1, r2
   17d16:	6818      	ldr	r0, [r3, #0]
   17d18:	f7ff fde2 	bl	178e0 <Sd::ToBool(bool)>
   17d1c:	4603      	mov	r3, r0
   17d1e:	9300      	str	r3, [sp, #0]
   17d20:	f240 330f 	movw	r3, #783	; 0x30f
   17d24:	4a20      	ldr	r2, [pc, #128]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17d26:	492d      	ldr	r1, [pc, #180]	; (17ddc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x404>)
   17d28:	482d      	ldr	r0, [pc, #180]	; (17de0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x408>)
   17d2a:	f7fe f9af 	bl	1608c <printf>
      LOG_ERROR("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
   17d2e:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17d32:	f003 0301 	and.w	r3, r3, #1
   17d36:	2b00      	cmp	r3, #0
   17d38:	bf14      	ite	ne
   17d3a:	2301      	movne	r3, #1
   17d3c:	2300      	moveq	r3, #0
   17d3e:	b2da      	uxtb	r2, r3
   17d40:	ab05      	add	r3, sp, #20
   17d42:	4611      	mov	r1, r2
   17d44:	6818      	ldr	r0, [r3, #0]
   17d46:	f7ff fdcb 	bl	178e0 <Sd::ToBool(bool)>
   17d4a:	4603      	mov	r3, r0
   17d4c:	9300      	str	r3, [sp, #0]
   17d4e:	f44f 7344 	mov.w	r3, #784	; 0x310
   17d52:	4a15      	ldr	r2, [pc, #84]	; (17da8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17d54:	4923      	ldr	r1, [pc, #140]	; (17de4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x40c>)
   17d56:	4824      	ldr	r0, [pc, #144]	; (17de8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x410>)
   17d58:	f7fe f998 	bl	1608c <printf>
    LOG_DEBUG("Now waiting for SD Card to exit Idle Mode...");
    do
    {
      // Query the status register
      sd.response.length = SendCmd(Command::kGetStatus, 32,
                                   sd.response.data.byte, 0, KeepAlive::kNo);
   17d5c:	ab05      	add	r3, sp, #20
   17d5e:	681b      	ldr	r3, [r3, #0]
   17d60:	681b      	ldr	r3, [r3, #0]
   17d62:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kGetStatus, 32,
   17d64:	ab86      	add	r3, sp, #536	; 0x218
   17d66:	f103 0208 	add.w	r2, r3, #8
   17d6a:	a805      	add	r0, sp, #20
   17d6c:	2300      	movs	r3, #0
   17d6e:	9301      	str	r3, [sp, #4]
   17d70:	2300      	movs	r3, #0
   17d72:	9300      	str	r3, [sp, #0]
   17d74:	4613      	mov	r3, r2
   17d76:	2220      	movs	r2, #32
   17d78:	210d      	movs	r1, #13
   17d7a:	6800      	ldr	r0, [r0, #0]
   17d7c:	47a0      	blx	r4
   17d7e:	4603      	mov	r3, r0
   17d80:	938a      	str	r3, [sp, #552]	; 0x228
    } while (sd.response.data.byte[0] & 0x01);
   17d82:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17d86:	f003 0301 	and.w	r3, r3, #1
   17d8a:	2b00      	cmp	r3, #0
   17d8c:	d000      	beq.n	17d90 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3b8>
    do
   17d8e:	e7e5      	b.n	17d5c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
    LOG_DEBUG("SD Card is out of Idle Mode!");

    // Return the status
    LOG_DEBUG("Read Complete! [R1 Response: 0x%02X]", sd.response.data.byte[0]);
    return sd.response.data.byte[0];
   17d90:	f89d 4220 	ldrb.w	r4, [sp, #544]	; 0x220
   17d94:	462b      	mov	r3, r5
   17d96:	4619      	mov	r1, r3
   17d98:	4814      	ldr	r0, [pc, #80]	; (17dec <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x414>)
   17d9a:	f7fb fbed 	bl	13578 <__cyg_profile_func_exit>
   17d9e:	4623      	mov	r3, r4
  }
   17da0:	4618      	mov	r0, r3
   17da2:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
   17da6:	bd30      	pop	{r4, r5, pc}
   17da8:	0001b208 	.word	0x0001b208
   17dac:	0001af24 	.word	0x0001af24
   17db0:	0001a78c 	.word	0x0001a78c
   17db4:	0001af2c 	.word	0x0001af2c
   17db8:	0001a7f0 	.word	0x0001a7f0
   17dbc:	0001af34 	.word	0x0001af34
   17dc0:	0001a83c 	.word	0x0001a83c
   17dc4:	0001af3c 	.word	0x0001af3c
   17dc8:	0001a884 	.word	0x0001a884
   17dcc:	0001af44 	.word	0x0001af44
   17dd0:	0001a8d0 	.word	0x0001a8d0
   17dd4:	0001af4c 	.word	0x0001af4c
   17dd8:	0001a91c 	.word	0x0001a91c
   17ddc:	0001af54 	.word	0x0001af54
   17de0:	0001a96c 	.word	0x0001a96c
   17de4:	0001af5c 	.word	0x0001af5c
   17de8:	0001a9b8 	.word	0x0001a9b8
   17dec:	000179d9 	.word	0x000179d9

00017df0 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)>:

  // Writes any number of 512-byte blocks to the SD Card
  uint8_t WriteBlock(uint32_t address, const uint8_t * array,
   17df0:	b530      	push	{r4, r5, lr}
   17df2:	b095      	sub	sp, #84	; 0x54
   17df4:	4675      	mov	r5, lr
   17df6:	9005      	str	r0, [sp, #20]
   17df8:	9104      	str	r1, [sp, #16]
   17dfa:	9203      	str	r2, [sp, #12]
   17dfc:	9302      	str	r3, [sp, #8]
   17dfe:	462b      	mov	r3, r5
   17e00:	4619      	mov	r1, r3
   17e02:	4865      	ldr	r0, [pc, #404]	; (17f98 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   17e04:	f7fb fba4 	bl	13550 <__cyg_profile_func_enter>
                     uint32_t blocks = 1) override
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   17e08:	9805      	ldr	r0, [sp, #20]
   17e0a:	f7ff fdbd 	bl	17988 <Sd::WaitWhileBusy()>
    Sd::CardInfo_t sd;

    // Determine appropriate command and start token to send
    Command write_cmd;
    uint8_t write_start_tkn;
    if (blocks > 1)
   17e0e:	9b02      	ldr	r3, [sp, #8]
   17e10:	2b01      	cmp	r3, #1
   17e12:	d905      	bls.n	17e20 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x30>
    {
      write_cmd       = Command::kWriteMulti;
   17e14:	2359      	movs	r3, #89	; 0x59
   17e16:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFC;
   17e18:	23fc      	movs	r3, #252	; 0xfc
   17e1a:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
   17e1e:	e004      	b.n	17e2a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x3a>
    }
    else
    {
      write_cmd       = Command::kWriteSingle;
   17e20:	2358      	movs	r3, #88	; 0x58
   17e22:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFE;
   17e24:	23fe      	movs	r3, #254	; 0xfe
   17e26:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
    }

    // Send initial write command
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
                                 KeepAlive::kYes);
   17e2a:	9b05      	ldr	r3, [sp, #20]
   17e2c:	681b      	ldr	r3, [r3, #0]
   17e2e:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
   17e30:	ab06      	add	r3, sp, #24
   17e32:	f103 0208 	add.w	r2, r3, #8
   17e36:	2301      	movs	r3, #1
   17e38:	9301      	str	r3, [sp, #4]
   17e3a:	2364      	movs	r3, #100	; 0x64
   17e3c:	9300      	str	r3, [sp, #0]
   17e3e:	4613      	mov	r3, r2
   17e40:	9a04      	ldr	r2, [sp, #16]
   17e42:	9913      	ldr	r1, [sp, #76]	; 0x4c
   17e44:	9805      	ldr	r0, [sp, #20]
   17e46:	47a0      	blx	r4
   17e48:	4603      	mov	r3, r0
   17e4a:	930a      	str	r3, [sp, #40]	; 0x28
    LOG_DEBUG("Sent Write Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the response was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   17e4c:	f89d 3020 	ldrb.w	r3, [sp, #32]
   17e50:	2b00      	cmp	r3, #0
   17e52:	f040 8096 	bne.w	17f82 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
    {
      // If no errors, proceed write given block(s) to SD Card
      // For each given block
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   17e56:	2300      	movs	r3, #0
   17e58:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   17e5c:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   17e60:	9a02      	ldr	r2, [sp, #8]
   17e62:	429a      	cmp	r2, r3
   17e64:	d97a      	bls.n	17f5c <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x16c>
           current_block_num++)
      {
        // Calculate array offset
        uint64_t arr_offset = current_block_num * kBlockSize;
   17e66:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   17e6a:	025b      	lsls	r3, r3, #9
   17e6c:	ea4f 74e3 	mov.w	r4, r3, asr #31
   17e70:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38

        // Send the start token for the current block
        ssp_interface_->Transfer(write_start_tkn);
   17e74:	9b05      	ldr	r3, [sp, #20]
   17e76:	685a      	ldr	r2, [r3, #4]
   17e78:	9b05      	ldr	r3, [sp, #20]
   17e7a:	685b      	ldr	r3, [r3, #4]
   17e7c:	681b      	ldr	r3, [r3, #0]
   17e7e:	3308      	adds	r3, #8
   17e80:	681b      	ldr	r3, [r3, #0]
   17e82:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
   17e86:	b289      	uxth	r1, r1
   17e88:	4610      	mov	r0, r2
   17e8a:	4798      	blx	r3

        // Write all 512-bytes of the given block
        LOG_DEBUG("Writing block #%d", current_block_num);
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   17e8c:	2300      	movs	r3, #0
   17e8e:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   17e92:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   17e96:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   17e9a:	d216      	bcs.n	17eca <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xda>
             current_byte++)
        {
          ssp_interface_->Transfer(array[arr_offset + current_byte]);
   17e9c:	9b05      	ldr	r3, [sp, #20]
   17e9e:	6858      	ldr	r0, [r3, #4]
   17ea0:	9b05      	ldr	r3, [sp, #20]
   17ea2:	685b      	ldr	r3, [r3, #4]
   17ea4:	681b      	ldr	r3, [r3, #0]
   17ea6:	3308      	adds	r3, #8
   17ea8:	681b      	ldr	r3, [r3, #0]
   17eaa:	990e      	ldr	r1, [sp, #56]	; 0x38
   17eac:	f8bd 2046 	ldrh.w	r2, [sp, #70]	; 0x46
   17eb0:	440a      	add	r2, r1
   17eb2:	9903      	ldr	r1, [sp, #12]
   17eb4:	440a      	add	r2, r1
   17eb6:	7812      	ldrb	r2, [r2, #0]
   17eb8:	b292      	uxth	r2, r2
   17eba:	4611      	mov	r1, r2
   17ebc:	4798      	blx	r3
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   17ebe:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   17ec2:	3301      	adds	r3, #1
   17ec4:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   17ec8:	e7e3      	b.n	17e92 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xa2>
        }

        // Read the data response token after writing the block
        uint8_t data_response_tkn =
            static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   17eca:	9b05      	ldr	r3, [sp, #20]
   17ecc:	685a      	ldr	r2, [r3, #4]
   17ece:	9b05      	ldr	r3, [sp, #20]
   17ed0:	685b      	ldr	r3, [r3, #4]
   17ed2:	681b      	ldr	r3, [r3, #0]
   17ed4:	3308      	adds	r3, #8
   17ed6:	681b      	ldr	r3, [r3, #0]
   17ed8:	21ff      	movs	r1, #255	; 0xff
   17eda:	4610      	mov	r0, r2
   17edc:	4798      	blx	r3
   17ede:	4603      	mov	r3, r0
   17ee0:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
                  ToBool(data_response_tkn & 0x0B));
        LOG_DEBUG("Data Rejected (write err)?: %s",
                  ToBool(data_response_tkn & 0x0D));

        // If writing multiple blocks and the previous block was rejected
        if (blocks > 1 && !(data_response_tkn & 0x05))
   17ee4:	9b02      	ldr	r3, [sp, #8]
   17ee6:	2b01      	cmp	r3, #1
   17ee8:	d92f      	bls.n	17f4a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
   17eea:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   17eee:	f003 0305 	and.w	r3, r3, #5
   17ef2:	2b00      	cmp	r3, #0
   17ef4:	d129      	bne.n	17f4a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
        {
          // Send an immediate stop (CMD12)
          sd.response.length =
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
                      100, KeepAlive::kYes);
   17ef6:	9b05      	ldr	r3, [sp, #20]
   17ef8:	681b      	ldr	r3, [r3, #0]
   17efa:	681c      	ldr	r4, [r3, #0]
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
   17efc:	ab06      	add	r3, sp, #24
   17efe:	f103 0208 	add.w	r2, r3, #8
   17f02:	2301      	movs	r3, #1
   17f04:	9301      	str	r3, [sp, #4]
   17f06:	2364      	movs	r3, #100	; 0x64
   17f08:	9300      	str	r3, [sp, #0]
   17f0a:	4613      	mov	r3, r2
   17f0c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17f10:	214c      	movs	r1, #76	; 0x4c
   17f12:	9805      	ldr	r0, [sp, #20]
   17f14:	47a0      	blx	r4
   17f16:	4603      	mov	r3, r0
          sd.response.length =
   17f18:	930a      	str	r3, [sp, #40]	; 0x28
          LOG_DEBUG("Stopped Transmission due to rejection...");
          LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);

          // In the case of a write error, ask for the reason why
          if (data_response_tkn & 0x0D)
   17f1a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   17f1e:	f003 030d 	and.w	r3, r3, #13
   17f22:	2b00      	cmp	r3, #0
   17f24:	d011      	beq.n	17f4a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
          {
            sd.response.length =
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
                        100, KeepAlive::kYes);
   17f26:	9b05      	ldr	r3, [sp, #20]
   17f28:	681b      	ldr	r3, [r3, #0]
   17f2a:	681c      	ldr	r4, [r3, #0]
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
   17f2c:	ab06      	add	r3, sp, #24
   17f2e:	f103 0208 	add.w	r2, r3, #8
   17f32:	2301      	movs	r3, #1
   17f34:	9301      	str	r3, [sp, #4]
   17f36:	2364      	movs	r3, #100	; 0x64
   17f38:	9300      	str	r3, [sp, #0]
   17f3a:	4613      	mov	r3, r2
   17f3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17f40:	210d      	movs	r1, #13
   17f42:	9805      	ldr	r0, [sp, #20]
   17f44:	47a0      	blx	r4
   17f46:	4603      	mov	r3, r0
            sd.response.length =
   17f48:	930a      	str	r3, [sp, #40]	; 0x28
                "Checking Status Register to see cause of Write Error...");
            LOG_DEBUG("[R2 Response: 0x%04" PRIX32 "]",
                      sd.response.data.dWord.lo);
          }
        }
        WaitWhileBusy();
   17f4a:	9805      	ldr	r0, [sp, #20]
   17f4c:	f7ff fd1c 	bl	17988 <Sd::WaitWhileBusy()>
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   17f50:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   17f54:	3301      	adds	r3, #1
   17f56:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   17f5a:	e77f      	b.n	17e5c <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x6c>
      }

      if (blocks > 1)
   17f5c:	9b02      	ldr	r3, [sp, #8]
   17f5e:	2b01      	cmp	r3, #1
   17f60:	d90f      	bls.n	17f82 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
      {
        constexpr uint8_t kStopToken = 0xFD;
   17f62:	23fd      	movs	r3, #253	; 0xfd
   17f64:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
        ssp_interface_->Transfer(kStopToken);
   17f68:	9b05      	ldr	r3, [sp, #20]
   17f6a:	685a      	ldr	r2, [r3, #4]
   17f6c:	9b05      	ldr	r3, [sp, #20]
   17f6e:	685b      	ldr	r3, [r3, #4]
   17f70:	681b      	ldr	r3, [r3, #0]
   17f72:	3308      	adds	r3, #8
   17f74:	681b      	ldr	r3, [r3, #0]
   17f76:	21fd      	movs	r1, #253	; 0xfd
   17f78:	4610      	mov	r0, r2
   17f7a:	4798      	blx	r3

        // Wait for the card's programming to complete before
        // reselecting it (i.e. to prevent corruption)
        WaitWhileBusy();
   17f7c:	9805      	ldr	r0, [sp, #20]
   17f7e:	f7ff fd03 	bl	17988 <Sd::WaitWhileBusy()>
      LOG_DEBUG("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
      LOG_DEBUG("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
      LOG_DEBUG("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
    }

    return sd.response.data.byte[0];
   17f82:	f89d 4020 	ldrb.w	r4, [sp, #32]
   17f86:	462b      	mov	r3, r5
   17f88:	4619      	mov	r1, r3
   17f8a:	4803      	ldr	r0, [pc, #12]	; (17f98 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   17f8c:	f7fb faf4 	bl	13578 <__cyg_profile_func_exit>
   17f90:	4623      	mov	r3, r4
  }
   17f92:	4618      	mov	r0, r3
   17f94:	b015      	add	sp, #84	; 0x54
   17f96:	bd30      	pop	{r4, r5, pc}
   17f98:	00017df1 	.word	0x00017df1

00017f9c <Sd::DeleteBlock(unsigned long, unsigned long)>:

  // Deletes any number of blocks (inclusively) within a range of address.
  uint8_t DeleteBlock(uint32_t start, uint32_t end) override
   17f9c:	b530      	push	{r4, r5, lr}
   17f9e:	b08f      	sub	sp, #60	; 0x3c
   17fa0:	4675      	mov	r5, lr
   17fa2:	9005      	str	r0, [sp, #20]
   17fa4:	9104      	str	r1, [sp, #16]
   17fa6:	9203      	str	r2, [sp, #12]
   17fa8:	462b      	mov	r3, r5
   17faa:	4619      	mov	r1, r3
   17fac:	483d      	ldr	r0, [pc, #244]	; (180a4 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   17fae:	f7fb facf 	bl	13550 <__cyg_profile_func_enter>
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   17fb2:	9805      	ldr	r0, [sp, #20]
   17fb4:	f7ff fce8 	bl	17988 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool delete_failed = false;
   17fb8:	2300      	movs	r3, #0
   17fba:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37

    // Set the delete start address
    LOG_DEBUG("Setting Delete Start Address...");
    sd.response.length = SendCmd(Command::kDelFrom, start,
                                 sd.response.data.byte, 100, KeepAlive::kYes);
   17fbe:	9b05      	ldr	r3, [sp, #20]
   17fc0:	681b      	ldr	r3, [r3, #0]
   17fc2:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(Command::kDelFrom, start,
   17fc4:	ab06      	add	r3, sp, #24
   17fc6:	f103 0208 	add.w	r2, r3, #8
   17fca:	2301      	movs	r3, #1
   17fcc:	9301      	str	r3, [sp, #4]
   17fce:	2364      	movs	r3, #100	; 0x64
   17fd0:	9300      	str	r3, [sp, #0]
   17fd2:	4613      	mov	r3, r2
   17fd4:	9a04      	ldr	r2, [sp, #16]
   17fd6:	2160      	movs	r1, #96	; 0x60
   17fd8:	9805      	ldr	r0, [sp, #20]
   17fda:	47a0      	blx	r4
   17fdc:	4603      	mov	r3, r0
   17fde:	930a      	str	r3, [sp, #40]	; 0x28

    // Wait while the writing the start address
    WaitWhileBusy();
   17fe0:	9805      	ldr	r0, [sp, #20]
   17fe2:	f7ff fcd1 	bl	17988 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   17fe6:	f89d 3020 	ldrb.w	r3, [sp, #32]
   17fea:	2b00      	cmp	r3, #0
   17fec:	d009      	beq.n	18002 <Sd::DeleteBlock(unsigned long, unsigned long)+0x66>
    {
      LOG_ERROR("Failed to set Start Address!");
   17fee:	f44f 736a 	mov.w	r3, #936	; 0x3a8
   17ff2:	4a2d      	ldr	r2, [pc, #180]	; (180a8 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   17ff4:	492d      	ldr	r1, [pc, #180]	; (180ac <Sd::DeleteBlock(unsigned long, unsigned long)+0x110>)
   17ff6:	482e      	ldr	r0, [pc, #184]	; (180b0 <Sd::DeleteBlock(unsigned long, unsigned long)+0x114>)
   17ff8:	f7fe f848 	bl	1608c <printf>
      delete_failed = true;
   17ffc:	2301      	movs	r3, #1
   17ffe:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Set the delete end address
    if (!delete_failed)
   18002:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   18006:	f083 0301 	eor.w	r3, r3, #1
   1800a:	b2db      	uxtb	r3, r3
   1800c:	2b00      	cmp	r3, #0
   1800e:	d010      	beq.n	18032 <Sd::DeleteBlock(unsigned long, unsigned long)+0x96>
    {
      LOG_DEBUG("Setting Delete End Address...");
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
                                   100, KeepAlive::kYes);
   18010:	9b05      	ldr	r3, [sp, #20]
   18012:	681b      	ldr	r3, [r3, #0]
   18014:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
   18016:	ab06      	add	r3, sp, #24
   18018:	f103 0208 	add.w	r2, r3, #8
   1801c:	2301      	movs	r3, #1
   1801e:	9301      	str	r3, [sp, #4]
   18020:	2364      	movs	r3, #100	; 0x64
   18022:	9300      	str	r3, [sp, #0]
   18024:	4613      	mov	r3, r2
   18026:	9a03      	ldr	r2, [sp, #12]
   18028:	2161      	movs	r1, #97	; 0x61
   1802a:	9805      	ldr	r0, [sp, #20]
   1802c:	47a0      	blx	r4
   1802e:	4603      	mov	r3, r0
   18030:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // Wait while the writing the end address
    WaitWhileBusy();
   18032:	9805      	ldr	r0, [sp, #20]
   18034:	f7ff fca8 	bl	17988 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   18038:	f89d 3020 	ldrb.w	r3, [sp, #32]
   1803c:	2b00      	cmp	r3, #0
   1803e:	d009      	beq.n	18054 <Sd::DeleteBlock(unsigned long, unsigned long)+0xb8>
    {
      LOG_ERROR("Failed to set End Address!");
   18040:	f240 33ba 	movw	r3, #954	; 0x3ba
   18044:	4a18      	ldr	r2, [pc, #96]	; (180a8 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   18046:	491b      	ldr	r1, [pc, #108]	; (180b4 <Sd::DeleteBlock(unsigned long, unsigned long)+0x118>)
   18048:	481b      	ldr	r0, [pc, #108]	; (180b8 <Sd::DeleteBlock(unsigned long, unsigned long)+0x11c>)
   1804a:	f7fe f81f 	bl	1608c <printf>
      delete_failed = true;
   1804e:	2301      	movs	r3, #1
   18050:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Finally, attempt a delete
    if (!delete_failed)
   18054:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   18058:	f083 0301 	eor.w	r3, r3, #1
   1805c:	b2db      	uxtb	r3, r3
   1805e:	2b00      	cmp	r3, #0
   18060:	d014      	beq.n	1808c <Sd::DeleteBlock(unsigned long, unsigned long)+0xf0>
    {
      // Issue the delete command to delete from our from:to range
      LOG_DEBUG("Issuing Delete Command...");
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
                                   sd.response.data.byte, 100, KeepAlive::kYes);
   18062:	9b05      	ldr	r3, [sp, #20]
   18064:	681b      	ldr	r3, [r3, #0]
   18066:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
   18068:	ab06      	add	r3, sp, #24
   1806a:	f103 0208 	add.w	r2, r3, #8
   1806e:	2301      	movs	r3, #1
   18070:	9301      	str	r3, [sp, #4]
   18072:	2364      	movs	r3, #100	; 0x64
   18074:	9300      	str	r3, [sp, #0]
   18076:	4613      	mov	r3, r2
   18078:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1807c:	2166      	movs	r1, #102	; 0x66
   1807e:	9805      	ldr	r0, [sp, #20]
   18080:	47a0      	blx	r4
   18082:	4603      	mov	r3, r0
   18084:	930a      	str	r3, [sp, #40]	; 0x28

      // Wait while the deletion occurs
      WaitWhileBusy();
   18086:	9805      	ldr	r0, [sp, #20]
   18088:	f7ff fc7e 	bl	17988 <Sd::WaitWhileBusy()>
      LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);
      LOG_DEBUG("Deletion Complete...");
    }

    // Return status
    return sd.response.data.byte[0];
   1808c:	f89d 4020 	ldrb.w	r4, [sp, #32]
   18090:	462b      	mov	r3, r5
   18092:	4619      	mov	r1, r3
   18094:	4803      	ldr	r0, [pc, #12]	; (180a4 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   18096:	f7fb fa6f 	bl	13578 <__cyg_profile_func_exit>
   1809a:	4623      	mov	r3, r4
  }
   1809c:	4618      	mov	r0, r3
   1809e:	b00f      	add	sp, #60	; 0x3c
   180a0:	bd30      	pop	{r4, r5, pc}
   180a2:	bf00      	nop
   180a4:	00017f9d 	.word	0x00017f9d
   180a8:	0001b244 	.word	0x0001b244
   180ac:	0001af64 	.word	0x0001af64
   180b0:	0001aa00 	.word	0x0001aa00
   180b4:	0001af6c 	.word	0x0001af6c
   180b8:	0001aa58 	.word	0x0001aa58

000180bc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)>:

  // Send a command
  uint32_t SendCmd(Command sdc, uint32_t arg, uint8_t response_buffer[],
   180bc:	e92d 49f0 	stmdb	sp!, {r4, r5, r6, r7, r8, fp, lr}
   180c0:	b08f      	sub	sp, #60	; 0x3c
   180c2:	46f0      	mov	r8, lr
   180c4:	9003      	str	r0, [sp, #12]
   180c6:	9102      	str	r1, [sp, #8]
   180c8:	9201      	str	r2, [sp, #4]
   180ca:	9300      	str	r3, [sp, #0]
   180cc:	4643      	mov	r3, r8
   180ce:	4619      	mov	r1, r3
   180d0:	4840      	ldr	r0, [pc, #256]	; (181d4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x118>)
   180d2:	f7fb fa3d 	bl	13550 <__cyg_profile_func_enter>
                   uint32_t delay, KeepAlive keep_alive) override
  {
    ResponseType res_type;
    uint8_t res_len    = 0;
   180d6:	2300      	movs	r3, #0
   180d8:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    uint8_t crc        = 0;
   180dc:	2300      	movs	r3, #0
   180de:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    uint8_t tries      = 0;
   180e2:	2300      	movs	r3, #0
   180e4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    uint8_t bit_offset = 0;  // determines the distance of the response's
   180e8:	2300      	movs	r3, #0
   180ea:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                             // 0 bit from the MSB place
    uint8_t temp_byte = 0;
   180ee:	2300      	movs	r3, #0
   180f0:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f

    // Determine the response type of the set command
    switch (sdc)
   180f4:	9b02      	ldr	r3, [sp, #8]
   180f6:	2b58      	cmp	r3, #88	; 0x58
   180f8:	d052      	beq.n	181a0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xe4>
   180fa:	2b58      	cmp	r3, #88	; 0x58
   180fc:	dc16      	bgt.n	1812c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x70>
   180fe:	2b48      	cmp	r3, #72	; 0x48
   18100:	d033      	beq.n	1816a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xae>
   18102:	2b48      	cmp	r3, #72	; 0x48
   18104:	dc06      	bgt.n	18114 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x58>
   18106:	2b40      	cmp	r3, #64	; 0x40
   18108:	d029      	beq.n	1815e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa2>
   1810a:	2b41      	cmp	r3, #65	; 0x41
   1810c:	d02a      	beq.n	18164 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa8>
   1810e:	2b0d      	cmp	r3, #13
   18110:	d031      	beq.n	18176 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xba>
   18112:	e054      	b.n	181be <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18114:	2b50      	cmp	r3, #80	; 0x50
   18116:	d03a      	beq.n	1818e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd2>
   18118:	2b50      	cmp	r3, #80	; 0x50
   1811a:	dc02      	bgt.n	18122 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x66>
   1811c:	2b4c      	cmp	r3, #76	; 0x4c
   1811e:	d027      	beq.n	18170 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xb4>
   18120:	e04d      	b.n	181be <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18122:	2b51      	cmp	r3, #81	; 0x51
   18124:	d036      	beq.n	18194 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd8>
   18126:	2b52      	cmp	r3, #82	; 0x52
   18128:	d037      	beq.n	1819a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xde>
   1812a:	e048      	b.n	181be <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   1812c:	2b66      	cmp	r3, #102	; 0x66
   1812e:	d043      	beq.n	181b8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xfc>
   18130:	2b66      	cmp	r3, #102	; 0x66
   18132:	dc06      	bgt.n	18142 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x86>
   18134:	2b60      	cmp	r3, #96	; 0x60
   18136:	d039      	beq.n	181ac <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf0>
   18138:	2b61      	cmp	r3, #97	; 0x61
   1813a:	d03a      	beq.n	181b2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf6>
   1813c:	2b59      	cmp	r3, #89	; 0x59
   1813e:	d032      	beq.n	181a6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xea>
   18140:	e03d      	b.n	181be <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18142:	2b77      	cmp	r3, #119	; 0x77
   18144:	d01a      	beq.n	1817c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc0>
   18146:	2b77      	cmp	r3, #119	; 0x77
   18148:	dc02      	bgt.n	18150 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x94>
   1814a:	2b69      	cmp	r3, #105	; 0x69
   1814c:	d019      	beq.n	18182 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc6>
   1814e:	e036      	b.n	181be <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   18150:	2b7a      	cmp	r3, #122	; 0x7a
   18152:	d019      	beq.n	18188 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xcc>
   18154:	2bff      	cmp	r3, #255	; 0xff
   18156:	d132      	bne.n	181be <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
    {
      case Command::kGarbage: res_type = ResponseType::kR1; break;
   18158:	2300      	movs	r3, #0
   1815a:	930d      	str	r3, [sp, #52]	; 0x34
   1815c:	e042      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReset: res_type = ResponseType::kR1; break;
   1815e:	2300      	movs	r3, #0
   18160:	930d      	str	r3, [sp, #52]	; 0x34
   18162:	e03f      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kInit: res_type = ResponseType::kR1; break;
   18164:	2300      	movs	r3, #0
   18166:	930d      	str	r3, [sp, #52]	; 0x34
   18168:	e03c      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOp: res_type = ResponseType::kR7; break;
   1816a:	2307      	movs	r3, #7
   1816c:	930d      	str	r3, [sp, #52]	; 0x34
   1816e:	e039      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kStopTrans: res_type = ResponseType::kR1; break;
   18170:	2300      	movs	r3, #0
   18172:	930d      	str	r3, [sp, #52]	; 0x34
   18174:	e036      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetStatus: res_type = ResponseType::kR2; break;
   18176:	2302      	movs	r3, #2
   18178:	930d      	str	r3, [sp, #52]	; 0x34
   1817a:	e033      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcBegin: res_type = ResponseType::kR1; break;
   1817c:	2300      	movs	r3, #0
   1817e:	930d      	str	r3, [sp, #52]	; 0x34
   18180:	e030      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcInit: res_type = ResponseType::kR1; break;
   18182:	2300      	movs	r3, #0
   18184:	930d      	str	r3, [sp, #52]	; 0x34
   18186:	e02d      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOcr: res_type = ResponseType::kR3; break;
   18188:	2303      	movs	r3, #3
   1818a:	930d      	str	r3, [sp, #52]	; 0x34
   1818c:	e02a      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kChgBlkLen: res_type = ResponseType::kR1; break;
   1818e:	2300      	movs	r3, #0
   18190:	930d      	str	r3, [sp, #52]	; 0x34
   18192:	e027      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadSingle: res_type = ResponseType::kR1; break;
   18194:	2300      	movs	r3, #0
   18196:	930d      	str	r3, [sp, #52]	; 0x34
   18198:	e024      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadMulti: res_type = ResponseType::kR1; break;
   1819a:	2300      	movs	r3, #0
   1819c:	930d      	str	r3, [sp, #52]	; 0x34
   1819e:	e021      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteSingle: res_type = ResponseType::kR1; break;
   181a0:	2300      	movs	r3, #0
   181a2:	930d      	str	r3, [sp, #52]	; 0x34
   181a4:	e01e      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteMulti: res_type = ResponseType::kR1; break;
   181a6:	2300      	movs	r3, #0
   181a8:	930d      	str	r3, [sp, #52]	; 0x34
   181aa:	e01b      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelFrom: res_type = ResponseType::kR1; break;
   181ac:	2300      	movs	r3, #0
   181ae:	930d      	str	r3, [sp, #52]	; 0x34
   181b0:	e018      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelTo: res_type = ResponseType::kR1; break;
   181b2:	2300      	movs	r3, #0
   181b4:	930d      	str	r3, [sp, #52]	; 0x34
   181b6:	e015      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDel: res_type = ResponseType::kR1b; break;
   181b8:	2301      	movs	r3, #1
   181ba:	930d      	str	r3, [sp, #52]	; 0x34
   181bc:	e012      	b.n	181e4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      default:
        LOG_ERROR("Unknown response type. Aborting!");
   181be:	f240 33f3 	movw	r3, #1011	; 0x3f3
   181c2:	4a05      	ldr	r2, [pc, #20]	; (181d8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x11c>)
   181c4:	4905      	ldr	r1, [pc, #20]	; (181dc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x120>)
   181c6:	4806      	ldr	r0, [pc, #24]	; (181e0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x124>)
   181c8:	f7fd ff60 	bl	1608c <printf>
        return -1;
   181cc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   181d0:	e1b1      	b.n	18536 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
   181d2:	bf00      	nop
   181d4:	000180bd 	.word	0x000180bd
   181d8:	0001b278 	.word	0x0001b278
   181dc:	0001af74 	.word	0x0001af74
   181e0:	0001aaac 	.word	0x0001aaac
    // algorithm
    uint8_t msg[5] = { static_cast<uint8_t>(sdc),
                       static_cast<uint8_t>(arg >> 24),
                       static_cast<uint8_t>(arg >> 16),
                       static_cast<uint8_t>(arg >> 8),
                       static_cast<uint8_t>(arg >> 0) };
   181e4:	9b02      	ldr	r3, [sp, #8]
   181e6:	b2db      	uxtb	r3, r3
   181e8:	f88d 3010 	strb.w	r3, [sp, #16]
                       static_cast<uint8_t>(arg >> 24),
   181ec:	9b01      	ldr	r3, [sp, #4]
   181ee:	0e1b      	lsrs	r3, r3, #24
                       static_cast<uint8_t>(arg >> 0) };
   181f0:	b2db      	uxtb	r3, r3
   181f2:	f88d 3011 	strb.w	r3, [sp, #17]
                       static_cast<uint8_t>(arg >> 16),
   181f6:	9b01      	ldr	r3, [sp, #4]
   181f8:	0c1b      	lsrs	r3, r3, #16
                       static_cast<uint8_t>(arg >> 0) };
   181fa:	b2db      	uxtb	r3, r3
   181fc:	f88d 3012 	strb.w	r3, [sp, #18]
                       static_cast<uint8_t>(arg >> 8),
   18200:	9b01      	ldr	r3, [sp, #4]
   18202:	0a1b      	lsrs	r3, r3, #8
                       static_cast<uint8_t>(arg >> 0) };
   18204:	b2db      	uxtb	r3, r3
   18206:	f88d 3013 	strb.w	r3, [sp, #19]
   1820a:	9b01      	ldr	r3, [sp, #4]
   1820c:	b2db      	uxtb	r3, r3
   1820e:	f88d 3014 	strb.w	r3, [sp, #20]

    crc = GetCrc7(msg, sizeof(msg));
   18212:	9b03      	ldr	r3, [sp, #12]
   18214:	681b      	ldr	r3, [r3, #0]
   18216:	331c      	adds	r3, #28
   18218:	681b      	ldr	r3, [r3, #0]
   1821a:	a904      	add	r1, sp, #16
   1821c:	2205      	movs	r2, #5
   1821e:	9803      	ldr	r0, [sp, #12]
   18220:	4798      	blx	r3
   18222:	4603      	mov	r3, r0
   18224:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    if (sdc == Command::kGarbage)
   18228:	9b02      	ldr	r3, [sp, #8]
   1822a:	2bff      	cmp	r3, #255	; 0xff
   1822c:	d102      	bne.n	18234 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x178>
    {
      crc = 0xFF;
   1822e:	23ff      	movs	r3, #255	; 0xff
   18230:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    }

    // Select the SD Card
    chip_select_->SetLow();
   18234:	9b03      	ldr	r3, [sp, #12]
   18236:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18238:	9b03      	ldr	r3, [sp, #12]
   1823a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1823c:	681b      	ldr	r3, [r3, #0]
   1823e:	3310      	adds	r3, #16
   18240:	681b      	ldr	r3, [r3, #0]
   18242:	4610      	mov	r0, r2
   18244:	4798      	blx	r3
    chip_select_external_->SetLow();
   18246:	9b03      	ldr	r3, [sp, #12]
   18248:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   1824a:	9b03      	ldr	r3, [sp, #12]
   1824c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1824e:	681b      	ldr	r3, [r3, #0]
   18250:	3310      	adds	r3, #16
   18252:	681b      	ldr	r3, [r3, #0]
   18254:	4610      	mov	r0, r2
   18256:	4798      	blx	r3

    // If desired, wait a bit before talking
    if (delay > 0)
   18258:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1825a:	2b00      	cmp	r3, #0
   1825c:	d007      	beq.n	1826e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x1b2>
    {
      Delay(delay);
   1825e:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18260:	461a      	mov	r2, r3
   18262:	f04f 0300 	mov.w	r3, #0
   18266:	4610      	mov	r0, r2
   18268:	4619      	mov	r1, r3
   1826a:	f7f8 fbc3 	bl	109f4 <Delay(unsigned long long)>
    }

    // Send the desired command frame to the SD card board
    // Begin by transfering the command byte
    ssp_interface_->Transfer(static_cast<uint16_t>(sdc));
   1826e:	9b03      	ldr	r3, [sp, #12]
   18270:	685a      	ldr	r2, [r3, #4]
   18272:	9b03      	ldr	r3, [sp, #12]
   18274:	685b      	ldr	r3, [r3, #4]
   18276:	681b      	ldr	r3, [r3, #0]
   18278:	3308      	adds	r3, #8
   1827a:	681b      	ldr	r3, [r3, #0]
   1827c:	9902      	ldr	r1, [sp, #8]
   1827e:	b289      	uxth	r1, r1
   18280:	4610      	mov	r0, r2
   18282:	4798      	blx	r3
    // Send arg byte [31:24]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 24) & 0xFF);
   18284:	9b03      	ldr	r3, [sp, #12]
   18286:	6858      	ldr	r0, [r3, #4]
   18288:	9b03      	ldr	r3, [sp, #12]
   1828a:	685b      	ldr	r3, [r3, #4]
   1828c:	681b      	ldr	r3, [r3, #0]
   1828e:	3308      	adds	r3, #8
   18290:	681b      	ldr	r3, [r3, #0]
   18292:	9a01      	ldr	r2, [sp, #4]
   18294:	0e12      	lsrs	r2, r2, #24
   18296:	b292      	uxth	r2, r2
   18298:	b2d2      	uxtb	r2, r2
   1829a:	b292      	uxth	r2, r2
   1829c:	4611      	mov	r1, r2
   1829e:	4798      	blx	r3
    // Send arg byte [23:16]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 16) & 0xFF);
   182a0:	9b03      	ldr	r3, [sp, #12]
   182a2:	6858      	ldr	r0, [r3, #4]
   182a4:	9b03      	ldr	r3, [sp, #12]
   182a6:	685b      	ldr	r3, [r3, #4]
   182a8:	681b      	ldr	r3, [r3, #0]
   182aa:	3308      	adds	r3, #8
   182ac:	681b      	ldr	r3, [r3, #0]
   182ae:	9a01      	ldr	r2, [sp, #4]
   182b0:	0c12      	lsrs	r2, r2, #16
   182b2:	b292      	uxth	r2, r2
   182b4:	b2d2      	uxtb	r2, r2
   182b6:	b292      	uxth	r2, r2
   182b8:	4611      	mov	r1, r2
   182ba:	4798      	blx	r3
    // Send arg byte [15:8]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 8) & 0xFF);
   182bc:	9b03      	ldr	r3, [sp, #12]
   182be:	6858      	ldr	r0, [r3, #4]
   182c0:	9b03      	ldr	r3, [sp, #12]
   182c2:	685b      	ldr	r3, [r3, #4]
   182c4:	681b      	ldr	r3, [r3, #0]
   182c6:	3308      	adds	r3, #8
   182c8:	681b      	ldr	r3, [r3, #0]
   182ca:	9a01      	ldr	r2, [sp, #4]
   182cc:	0a12      	lsrs	r2, r2, #8
   182ce:	b292      	uxth	r2, r2
   182d0:	b2d2      	uxtb	r2, r2
   182d2:	b292      	uxth	r2, r2
   182d4:	4611      	mov	r1, r2
   182d6:	4798      	blx	r3
    // Send arg byte [7:0]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 0) & 0xFF);
   182d8:	9b03      	ldr	r3, [sp, #12]
   182da:	685a      	ldr	r2, [r3, #4]
   182dc:	9b03      	ldr	r3, [sp, #12]
   182de:	685b      	ldr	r3, [r3, #4]
   182e0:	681b      	ldr	r3, [r3, #0]
   182e2:	3308      	adds	r3, #8
   182e4:	681b      	ldr	r3, [r3, #0]
   182e6:	9901      	ldr	r1, [sp, #4]
   182e8:	b289      	uxth	r1, r1
   182ea:	b2c9      	uxtb	r1, r1
   182ec:	b289      	uxth	r1, r1
   182ee:	4610      	mov	r0, r2
   182f0:	4798      	blx	r3
    // Send 7-bit CRC and LSB stop addr (as b1)
    ssp_interface_->Transfer(static_cast<uint16_t>(crc << 1) | 0x01);
   182f2:	9b03      	ldr	r3, [sp, #12]
   182f4:	6858      	ldr	r0, [r3, #4]
   182f6:	9b03      	ldr	r3, [sp, #12]
   182f8:	685b      	ldr	r3, [r3, #4]
   182fa:	681b      	ldr	r3, [r3, #0]
   182fc:	3308      	adds	r3, #8
   182fe:	681b      	ldr	r3, [r3, #0]
   18300:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   18304:	b292      	uxth	r2, r2
   18306:	0052      	lsls	r2, r2, #1
   18308:	b292      	uxth	r2, r2
   1830a:	f042 0201 	orr.w	r2, r2, #1
   1830e:	b292      	uxth	r2, r2
   18310:	4611      	mov	r1, r2
   18312:	4798      	blx	r3

    // Write garbage while waiting for a response
    // Send at least 1 byte of garbage before checking for a response
    temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18314:	9b03      	ldr	r3, [sp, #12]
   18316:	685a      	ldr	r2, [r3, #4]
   18318:	9b03      	ldr	r3, [sp, #12]
   1831a:	685b      	ldr	r3, [r3, #4]
   1831c:	681b      	ldr	r3, [r3, #0]
   1831e:	3308      	adds	r3, #8
   18320:	681b      	ldr	r3, [r3, #0]
   18322:	21ff      	movs	r1, #255	; 0xff
   18324:	4610      	mov	r0, r2
   18326:	4798      	blx	r3
   18328:	4603      	mov	r3, r0
   1832a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (tries++ < kBusTimeout)
   1832e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   18332:	1c5a      	adds	r2, r3, #1
   18334:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   18338:	2bf9      	cmp	r3, #249	; 0xf9
   1833a:	bf94      	ite	ls
   1833c:	2301      	movls	r3, #1
   1833e:	2300      	movhi	r3, #0
   18340:	b2db      	uxtb	r3, r3
   18342:	2b00      	cmp	r3, #0
   18344:	d027      	beq.n	18396 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2da>
    {
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18346:	9b03      	ldr	r3, [sp, #12]
   18348:	685a      	ldr	r2, [r3, #4]
   1834a:	9b03      	ldr	r3, [sp, #12]
   1834c:	685b      	ldr	r3, [r3, #4]
   1834e:	681b      	ldr	r3, [r3, #0]
   18350:	3308      	adds	r3, #8
   18352:	681b      	ldr	r3, [r3, #0]
   18354:	21ff      	movs	r1, #255	; 0xff
   18356:	4610      	mov	r0, r2
   18358:	4798      	blx	r3
   1835a:	4603      	mov	r3, r0
   1835c:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
      if (temp_byte != 0xFF)
   18360:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   18364:	2bff      	cmp	r3, #255	; 0xff
   18366:	d00f      	beq.n	18388 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2cc>
      {
        // Determine the offset, since the first byte of a
        // response will always be 0.
        while (temp_byte & (0x80 >> bit_offset))
   18368:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   1836c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18370:	2180      	movs	r1, #128	; 0x80
   18372:	fa41 f303 	asr.w	r3, r1, r3
   18376:	4013      	ands	r3, r2
   18378:	2b00      	cmp	r3, #0
   1837a:	d00b      	beq.n	18394 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2d8>
        {
          bit_offset++;
   1837c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18380:	3301      	adds	r3, #1
   18382:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        while (temp_byte & (0x80 >> bit_offset))
   18386:	e7ef      	b.n	18368 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2ac>
        }
        break;
      }
      tries++;
   18388:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   1838c:	3301      	adds	r3, #1
   1838e:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    while (tries++ < kBusTimeout)
   18392:	e7cc      	b.n	1832e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x272>
        break;
   18394:	bf00      	nop
    }

    // Determine response length (in bytes) based on response type
    switch (res_type)
   18396:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18398:	2b07      	cmp	r3, #7
   1839a:	d827      	bhi.n	183ec <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x330>
   1839c:	a201      	add	r2, pc, #4	; (adr r2, 183a4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2e8>)
   1839e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   183a2:	bf00      	nop
   183a4:	000183c5 	.word	0x000183c5
   183a8:	000183cd 	.word	0x000183cd
   183ac:	000183d5 	.word	0x000183d5
   183b0:	000183dd 	.word	0x000183dd
   183b4:	000183ed 	.word	0x000183ed
   183b8:	000183ed 	.word	0x000183ed
   183bc:	000183ed 	.word	0x000183ed
   183c0:	000183e5 	.word	0x000183e5
    {
      case ResponseType::kR1: res_len = 1; break;
   183c4:	2301      	movs	r3, #1
   183c6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   183ca:	e019      	b.n	18400 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR1b: res_len = 1; break;
   183cc:	2301      	movs	r3, #1
   183ce:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   183d2:	e015      	b.n	18400 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR2: res_len = 2; break;
   183d4:	2302      	movs	r3, #2
   183d6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   183da:	e011      	b.n	18400 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR3: res_len = 5; break;
   183dc:	2305      	movs	r3, #5
   183de:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   183e2:	e00d      	b.n	18400 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR7: res_len = 5; break;
   183e4:	2305      	movs	r3, #5
   183e6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   183ea:	e009      	b.n	18400 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      default:
        LOG_ERROR("Response unsupported in SPI mode. Aborting!");
   183ec:	f240 433a 	movw	r3, #1082	; 0x43a
   183f0:	4a56      	ldr	r2, [pc, #344]	; (1854c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x490>)
   183f2:	4957      	ldr	r1, [pc, #348]	; (18550 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x494>)
   183f4:	4857      	ldr	r0, [pc, #348]	; (18554 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x498>)
   183f6:	f7fd fe49 	bl	1608c <printf>
        return -1;
   183fa:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   183fe:	e09a      	b.n	18536 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
        break;
    }

    // Acquire the response
    uint64_t temp_response = 0;
   18400:	f04f 0200 	mov.w	r2, #0
   18404:	f04f 0300 	mov.w	r3, #0
   18408:	e9cd 2308 	strd	r2, r3, [sp, #32]
    // Read an extra 8 bits since the response was offset
    uint8_t bytes_to_read =
   1840c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18410:	2b00      	cmp	r3, #0
   18412:	d004      	beq.n	1841e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x362>
   18414:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   18418:	3301      	adds	r3, #1
   1841a:	b2db      	uxtb	r3, r3
   1841c:	e001      	b.n	18422 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x366>
   1841e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   18422:	f88d 301f 	strb.w	r3, [sp, #31]
        static_cast<uint8_t>((bit_offset > 0) ? res_len + 1 : res_len);
    while (bytes_to_read-- > 0)
   18426:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1842a:	1e5a      	subs	r2, r3, #1
   1842c:	f88d 201f 	strb.w	r2, [sp, #31]
   18430:	2b00      	cmp	r3, #0
   18432:	bf14      	ite	ne
   18434:	2301      	movne	r3, #1
   18436:	2300      	moveq	r3, #0
   18438:	b2db      	uxtb	r3, r3
   1843a:	2b00      	cmp	r3, #0
   1843c:	d025      	beq.n	1848a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x3ce>
    {
      // Make space for the next byte
      temp_response = temp_response << 8;
   1843e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   18442:	f04f 0200 	mov.w	r2, #0
   18446:	f04f 0300 	mov.w	r3, #0
   1844a:	020b      	lsls	r3, r1, #8
   1844c:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
   18450:	0202      	lsls	r2, r0, #8
   18452:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_response |= temp_byte;
   18456:	f89d b02f 	ldrb.w	fp, [sp, #47]	; 0x2f
   1845a:	f04f 0c00 	mov.w	ip, #0
   1845e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   18462:	ea4b 0200 	orr.w	r2, fp, r0
   18466:	ea4c 0301 	orr.w	r3, ip, r1
   1846a:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1846e:	9b03      	ldr	r3, [sp, #12]
   18470:	685a      	ldr	r2, [r3, #4]
   18472:	9b03      	ldr	r3, [sp, #12]
   18474:	685b      	ldr	r3, [r3, #4]
   18476:	681b      	ldr	r3, [r3, #0]
   18478:	3308      	adds	r3, #8
   1847a:	681b      	ldr	r3, [r3, #0]
   1847c:	21ff      	movs	r1, #255	; 0xff
   1847e:	4610      	mov	r0, r2
   18480:	4798      	blx	r3
   18482:	4603      	mov	r3, r0
   18484:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (bytes_to_read-- > 0)
   18488:	e7cd      	b.n	18426 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x36a>
    }
    // Compensate for the bit offset
    temp_response = temp_response >> bit_offset;
   1848a:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
   1848e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   18492:	f1c1 0c20 	rsb	ip, r1, #32
   18496:	f1a1 0020 	sub.w	r0, r1, #32
   1849a:	fa22 f401 	lsr.w	r4, r2, r1
   1849e:	fa03 fc0c 	lsl.w	ip, r3, ip
   184a2:	ea44 040c 	orr.w	r4, r4, ip
   184a6:	fa23 f000 	lsr.w	r0, r3, r0
   184aa:	4304      	orrs	r4, r0
   184ac:	fa23 f501 	lsr.w	r5, r3, r1
   184b0:	e9cd 4508 	strd	r4, r5, [sp, #32]

    // Only write to the response buffer if it is provided
    if (response_buffer != nullptr)
   184b4:	9b00      	ldr	r3, [sp, #0]
   184b6:	2b00      	cmp	r3, #0
   184b8:	d025      	beq.n	18506 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
    {
      for (int i = 0; i < res_len; i++)
   184ba:	2300      	movs	r3, #0
   184bc:	9306      	str	r3, [sp, #24]
   184be:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   184c2:	9a06      	ldr	r2, [sp, #24]
   184c4:	429a      	cmp	r2, r3
   184c6:	da1e      	bge.n	18506 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
      {
        response_buffer[i] =
            static_cast<uint8_t>(temp_response >> 8 * (res_len - 1 - i));
   184c8:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   184cc:	1e5a      	subs	r2, r3, #1
   184ce:	9b06      	ldr	r3, [sp, #24]
   184d0:	1ad3      	subs	r3, r2, r3
   184d2:	00da      	lsls	r2, r3, #3
   184d4:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   184d8:	f1c2 0020 	rsb	r0, r2, #32
   184dc:	f1a2 0120 	sub.w	r1, r2, #32
   184e0:	fa23 f602 	lsr.w	r6, r3, r2
   184e4:	fa04 f000 	lsl.w	r0, r4, r0
   184e8:	4306      	orrs	r6, r0
   184ea:	fa24 f101 	lsr.w	r1, r4, r1
   184ee:	430e      	orrs	r6, r1
   184f0:	fa24 f702 	lsr.w	r7, r4, r2
        response_buffer[i] =
   184f4:	9b06      	ldr	r3, [sp, #24]
   184f6:	9a00      	ldr	r2, [sp, #0]
   184f8:	4413      	add	r3, r2
   184fa:	b2f2      	uxtb	r2, r6
   184fc:	701a      	strb	r2, [r3, #0]
      for (int i = 0; i < res_len; i++)
   184fe:	9b06      	ldr	r3, [sp, #24]
   18500:	3301      	adds	r3, #1
   18502:	9306      	str	r3, [sp, #24]
   18504:	e7db      	b.n	184be <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x402>
      }
    }

    // Only end the transaction if keep_alive isn't requested
    if (keep_alive == KeepAlive::kNo)
   18506:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
   1850a:	2b00      	cmp	r3, #0
   1850c:	d111      	bne.n	18532 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x476>
    {
      // Deselect the SPI comm board
      chip_select_->SetHigh();
   1850e:	9b03      	ldr	r3, [sp, #12]
   18510:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18512:	9b03      	ldr	r3, [sp, #12]
   18514:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   18516:	681b      	ldr	r3, [r3, #0]
   18518:	330c      	adds	r3, #12
   1851a:	681b      	ldr	r3, [r3, #0]
   1851c:	4610      	mov	r0, r2
   1851e:	4798      	blx	r3
      chip_select_external_->SetHigh();
   18520:	9b03      	ldr	r3, [sp, #12]
   18522:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   18524:	9b03      	ldr	r3, [sp, #12]
   18526:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   18528:	681b      	ldr	r3, [r3, #0]
   1852a:	330c      	adds	r3, #12
   1852c:	681b      	ldr	r3, [r3, #0]
   1852e:	4610      	mov	r0, r2
   18530:	4798      	blx	r3
    }
    return res_len;
   18532:	f89d 4033 	ldrb.w	r4, [sp, #51]	; 0x33
   18536:	4643      	mov	r3, r8
   18538:	4619      	mov	r1, r3
   1853a:	4807      	ldr	r0, [pc, #28]	; (18558 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x49c>)
   1853c:	f7fb f81c 	bl	13578 <__cyg_profile_func_exit>
   18540:	4623      	mov	r3, r4
  }
   18542:	4618      	mov	r0, r3
   18544:	b00f      	add	sp, #60	; 0x3c
   18546:	e8bd 89f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, fp, pc}
   1854a:	bf00      	nop
   1854c:	0001b278 	.word	0x0001b278
   18550:	0001af7c 	.word	0x0001af7c
   18554:	0001ab08 	.word	0x0001ab08
   18558:	000180bd 	.word	0x000180bd

0001855c <Sd::Crc7Add(unsigned char, unsigned char)>:

  // Adds a message byte to the current CRC-7 to get a the new CRC-7
  uint8_t Crc7Add(uint8_t crc, uint8_t message_byte) override
   1855c:	b530      	push	{r4, r5, lr}
   1855e:	b083      	sub	sp, #12
   18560:	4675      	mov	r5, lr
   18562:	9001      	str	r0, [sp, #4]
   18564:	460b      	mov	r3, r1
   18566:	f88d 3003 	strb.w	r3, [sp, #3]
   1856a:	4613      	mov	r3, r2
   1856c:	f88d 3002 	strb.w	r3, [sp, #2]
   18570:	462b      	mov	r3, r5
   18572:	4619      	mov	r1, r3
   18574:	4809      	ldr	r0, [pc, #36]	; (1859c <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   18576:	f7fa ffeb 	bl	13550 <__cyg_profile_func_enter>
  {
    return kCrcTable8.crc_table[(crc << 1) ^ message_byte];
   1857a:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1857e:	005a      	lsls	r2, r3, #1
   18580:	f89d 3002 	ldrb.w	r3, [sp, #2]
   18584:	4053      	eors	r3, r2
   18586:	4a06      	ldr	r2, [pc, #24]	; (185a0 <Sd::Crc7Add(unsigned char, unsigned char)+0x44>)
   18588:	5cd4      	ldrb	r4, [r2, r3]
   1858a:	462b      	mov	r3, r5
   1858c:	4619      	mov	r1, r3
   1858e:	4803      	ldr	r0, [pc, #12]	; (1859c <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   18590:	f7fa fff2 	bl	13578 <__cyg_profile_func_exit>
   18594:	4623      	mov	r3, r4
  }
   18596:	4618      	mov	r0, r3
   18598:	b003      	add	sp, #12
   1859a:	bd30      	pop	{r4, r5, pc}
   1859c:	0001855d 	.word	0x0001855d
   185a0:	0001abec 	.word	0x0001abec

000185a4 <Sd::GetCrc7(unsigned char*, unsigned char)>:

  // Returns the CRC-7 for a message of "length" bytes
  uint8_t GetCrc7(uint8_t * message, uint8_t length) override
   185a4:	b530      	push	{r4, r5, lr}
   185a6:	b087      	sub	sp, #28
   185a8:	4675      	mov	r5, lr
   185aa:	9003      	str	r0, [sp, #12]
   185ac:	9102      	str	r1, [sp, #8]
   185ae:	4613      	mov	r3, r2
   185b0:	f88d 3007 	strb.w	r3, [sp, #7]
   185b4:	462b      	mov	r3, r5
   185b6:	4619      	mov	r1, r3
   185b8:	4815      	ldr	r0, [pc, #84]	; (18610 <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   185ba:	f7fa ffc9 	bl	13550 <__cyg_profile_func_enter>
  {
    uint8_t crc = 0;
   185be:	2300      	movs	r3, #0
   185c0:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   185c4:	2300      	movs	r3, #0
   185c6:	9304      	str	r3, [sp, #16]
   185c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   185cc:	9a04      	ldr	r2, [sp, #16]
   185ce:	429a      	cmp	r2, r3
   185d0:	da12      	bge.n	185f8 <Sd::GetCrc7(unsigned char*, unsigned char)+0x54>
    {
      crc = Crc7Add(crc, message[i]);
   185d2:	9b03      	ldr	r3, [sp, #12]
   185d4:	681b      	ldr	r3, [r3, #0]
   185d6:	3318      	adds	r3, #24
   185d8:	681b      	ldr	r3, [r3, #0]
   185da:	9a04      	ldr	r2, [sp, #16]
   185dc:	9902      	ldr	r1, [sp, #8]
   185de:	440a      	add	r2, r1
   185e0:	7812      	ldrb	r2, [r2, #0]
   185e2:	f89d 1017 	ldrb.w	r1, [sp, #23]
   185e6:	9803      	ldr	r0, [sp, #12]
   185e8:	4798      	blx	r3
   185ea:	4603      	mov	r3, r0
   185ec:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   185f0:	9b04      	ldr	r3, [sp, #16]
   185f2:	3301      	adds	r3, #1
   185f4:	9304      	str	r3, [sp, #16]
   185f6:	e7e7      	b.n	185c8 <Sd::GetCrc7(unsigned char*, unsigned char)+0x24>
    }
    return crc;
   185f8:	f89d 4017 	ldrb.w	r4, [sp, #23]
   185fc:	462b      	mov	r3, r5
   185fe:	4619      	mov	r1, r3
   18600:	4803      	ldr	r0, [pc, #12]	; (18610 <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   18602:	f7fa ffb9 	bl	13578 <__cyg_profile_func_exit>
   18606:	4623      	mov	r3, r4
  }
   18608:	4618      	mov	r0, r3
   1860a:	b007      	add	sp, #28
   1860c:	bd30      	pop	{r4, r5, pc}
   1860e:	bf00      	nop
   18610:	000185a5 	.word	0x000185a5

00018614 <Sd::GetCrc16(unsigned char*, unsigned short)>:

  // Returns CCITT CRC-16 for a message of "length" bytes
  uint16_t GetCrc16(uint8_t * message, uint16_t length) override
   18614:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   18618:	b08c      	sub	sp, #48	; 0x30
   1861a:	4677      	mov	r7, lr
   1861c:	9003      	str	r0, [sp, #12]
   1861e:	9102      	str	r1, [sp, #8]
   18620:	4613      	mov	r3, r2
   18622:	f8ad 3006 	strh.w	r3, [sp, #6]
   18626:	463b      	mov	r3, r7
   18628:	4619      	mov	r1, r3
   1862a:	4837      	ldr	r0, [pc, #220]	; (18708 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   1862c:	f7fa ff90 	bl	13550 <__cyg_profile_func_enter>
  {
    uint64_t crc = 0x0000;
   18630:	f04f 0300 	mov.w	r3, #0
   18634:	f04f 0400 	mov.w	r4, #0
   18638:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    uint64_t temp;
    uint64_t final_value = 0;
   1863c:	f04f 0300 	mov.w	r3, #0
   18640:	f04f 0400 	mov.w	r4, #0
   18644:	e9cd 3406 	strd	r3, r4, [sp, #24]

    for (uint64_t count = 0; count < length; ++count)
   18648:	f04f 0300 	mov.w	r3, #0
   1864c:	f04f 0400 	mov.w	r4, #0
   18650:	e9cd 3408 	strd	r3, r4, [sp, #32]
   18654:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   18658:	f04f 0400 	mov.w	r4, #0
   1865c:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   18660:	42a2      	cmp	r2, r4
   18662:	bf08      	it	eq
   18664:	4299      	cmpeq	r1, r3
   18666:	d23f      	bcs.n	186e8 <Sd::GetCrc16(unsigned char*, unsigned short)+0xd4>
    {
      temp = (*message++ ^ (crc >> 8)) & 0xff;
   18668:	9b02      	ldr	r3, [sp, #8]
   1866a:	1c5a      	adds	r2, r3, #1
   1866c:	9202      	str	r2, [sp, #8]
   1866e:	781b      	ldrb	r3, [r3, #0]
   18670:	b2dd      	uxtb	r5, r3
   18672:	f04f 0600 	mov.w	r6, #0
   18676:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   1867a:	f04f 0300 	mov.w	r3, #0
   1867e:	f04f 0400 	mov.w	r4, #0
   18682:	0a0b      	lsrs	r3, r1, #8
   18684:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   18688:	0a14      	lsrs	r4, r2, #8
   1868a:	ea83 0b05 	eor.w	fp, r3, r5
   1868e:	ea84 0c06 	eor.w	ip, r4, r6
   18692:	f04f 01ff 	mov.w	r1, #255	; 0xff
   18696:	f04f 0200 	mov.w	r2, #0
   1869a:	ea0b 0301 	and.w	r3, fp, r1
   1869e:	ea0c 0402 	and.w	r4, ip, r2
   186a2:	e9cd 3404 	strd	r3, r4, [sp, #16]
      crc  = kCrcTable16.crc_table[temp] ^ (crc << 8);
   186a6:	4a19      	ldr	r2, [pc, #100]	; (1870c <Sd::GetCrc16(unsigned char*, unsigned short)+0xf8>)
   186a8:	9b04      	ldr	r3, [sp, #16]
   186aa:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   186ae:	b29d      	uxth	r5, r3
   186b0:	f04f 0600 	mov.w	r6, #0
   186b4:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   186b8:	f04f 0b00 	mov.w	fp, #0
   186bc:	f04f 0c00 	mov.w	ip, #0
   186c0:	ea4f 2c02 	mov.w	ip, r2, lsl #8
   186c4:	ea4c 6c11 	orr.w	ip, ip, r1, lsr #24
   186c8:	ea4f 2b01 	mov.w	fp, r1, lsl #8
   186cc:	ea8b 0305 	eor.w	r3, fp, r5
   186d0:	ea8c 0406 	eor.w	r4, ip, r6
   186d4:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    for (uint64_t count = 0; count < length; ++count)
   186d8:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   186dc:	1c59      	adds	r1, r3, #1
   186de:	f144 0200 	adc.w	r2, r4, #0
   186e2:	e9cd 1208 	strd	r1, r2, [sp, #32]
   186e6:	e7b5      	b.n	18654 <Sd::GetCrc16(unsigned char*, unsigned short)+0x40>
    }

    return static_cast<uint16_t>(crc ^ final_value);
   186e8:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   186ec:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   186f0:	4053      	eors	r3, r2
   186f2:	b29c      	uxth	r4, r3
   186f4:	463b      	mov	r3, r7
   186f6:	4619      	mov	r1, r3
   186f8:	4803      	ldr	r0, [pc, #12]	; (18708 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   186fa:	f7fa ff3d 	bl	13578 <__cyg_profile_func_exit>
   186fe:	4623      	mov	r3, r4
  }
   18700:	4618      	mov	r0, r3
   18702:	b00c      	add	sp, #48	; 0x30
   18704:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   18708:	00018615 	.word	0x00018615
   1870c:	0001acec 	.word	0x0001acec

00018710 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)>:
constexpr T Set(T target, uint32_t position)
   18710:	b530      	push	{r4, r5, lr}
   18712:	b083      	sub	sp, #12
   18714:	4675      	mov	r5, lr
   18716:	9001      	str	r0, [sp, #4]
   18718:	9100      	str	r1, [sp, #0]
   1871a:	462b      	mov	r3, r5
   1871c:	4619      	mov	r1, r3
   1871e:	480a      	ldr	r0, [pc, #40]	; (18748 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   18720:	f7fa ff16 	bl	13550 <__cyg_profile_func_enter>
  return target | (1 << position);
   18724:	2201      	movs	r2, #1
   18726:	9b00      	ldr	r3, [sp, #0]
   18728:	fa02 f303 	lsl.w	r3, r2, r3
   1872c:	461a      	mov	r2, r3
   1872e:	9b01      	ldr	r3, [sp, #4]
   18730:	ea42 0403 	orr.w	r4, r2, r3
   18734:	462b      	mov	r3, r5
   18736:	4619      	mov	r1, r3
   18738:	4803      	ldr	r0, [pc, #12]	; (18748 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   1873a:	f7fa ff1d 	bl	13578 <__cyg_profile_func_exit>
   1873e:	4623      	mov	r3, r4
}
   18740:	4618      	mov	r0, r3
   18742:	b003      	add	sp, #12
   18744:	bd30      	pop	{r4, r5, pc}
   18746:	bf00      	nop
   18748:	00018711 	.word	0x00018711

0001874c <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   1874c:	b530      	push	{r4, r5, lr}
   1874e:	b089      	sub	sp, #36	; 0x24
   18750:	4675      	mov	r5, lr
   18752:	9003      	str	r0, [sp, #12]
   18754:	9201      	str	r2, [sp, #4]
   18756:	9300      	str	r3, [sp, #0]
   18758:	460b      	mov	r3, r1
   1875a:	f88d 300b 	strb.w	r3, [sp, #11]
   1875e:	462b      	mov	r3, r5
   18760:	4619      	mov	r1, r3
   18762:	4816      	ldr	r0, [pc, #88]	; (187bc <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   18764:	f7fa fef4 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   18768:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1876c:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1876e:	2320      	movs	r3, #32
   18770:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   18772:	9b00      	ldr	r3, [sp, #0]
   18774:	f1c3 0320 	rsb	r3, r3, #32
   18778:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1877c:	fa22 f303 	lsr.w	r3, r2, r3
   18780:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   18782:	9a05      	ldr	r2, [sp, #20]
   18784:	9b01      	ldr	r3, [sp, #4]
   18786:	fa02 f303 	lsl.w	r3, r2, r3
   1878a:	43db      	mvns	r3, r3
   1878c:	9a03      	ldr	r2, [sp, #12]
   1878e:	4013      	ands	r3, r2
   18790:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   18792:	f89d 200b 	ldrb.w	r2, [sp, #11]
   18796:	9b05      	ldr	r3, [sp, #20]
   18798:	401a      	ands	r2, r3
   1879a:	9b01      	ldr	r3, [sp, #4]
   1879c:	fa02 f303 	lsl.w	r3, r2, r3
   187a0:	9a03      	ldr	r2, [sp, #12]
   187a2:	4313      	orrs	r3, r2
   187a4:	9303      	str	r3, [sp, #12]
  return target;
   187a6:	9c03      	ldr	r4, [sp, #12]
   187a8:	462b      	mov	r3, r5
   187aa:	4619      	mov	r1, r3
   187ac:	4803      	ldr	r0, [pc, #12]	; (187bc <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   187ae:	f7fa fee3 	bl	13578 <__cyg_profile_func_exit>
   187b2:	4623      	mov	r3, r4
}
   187b4:	4618      	mov	r0, r3
   187b6:	b009      	add	sp, #36	; 0x24
   187b8:	bd30      	pop	{r4, r5, pc}
   187ba:	bf00      	nop
   187bc:	0001874d 	.word	0x0001874d

000187c0 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)>:
constexpr T Extract(T target, uint32_t position, uint32_t width = 1)
   187c0:	b530      	push	{r4, r5, lr}
   187c2:	b089      	sub	sp, #36	; 0x24
   187c4:	4675      	mov	r5, lr
   187c6:	9003      	str	r0, [sp, #12]
   187c8:	9102      	str	r1, [sp, #8]
   187ca:	9201      	str	r2, [sp, #4]
   187cc:	462b      	mov	r3, r5
   187ce:	4619      	mov	r1, r3
   187d0:	480f      	ldr	r0, [pc, #60]	; (18810 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   187d2:	f7fa febd 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   187d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   187da:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   187dc:	2320      	movs	r3, #32
   187de:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   187e0:	9b01      	ldr	r3, [sp, #4]
   187e2:	f1c3 0320 	rsb	r3, r3, #32
   187e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   187ea:	fa22 f303 	lsr.w	r3, r2, r3
   187ee:	9305      	str	r3, [sp, #20]
  return (target >> position) & mask;
   187f0:	9a03      	ldr	r2, [sp, #12]
   187f2:	9b02      	ldr	r3, [sp, #8]
   187f4:	40da      	lsrs	r2, r3
   187f6:	9b05      	ldr	r3, [sp, #20]
   187f8:	ea02 0403 	and.w	r4, r2, r3
   187fc:	462b      	mov	r3, r5
   187fe:	4619      	mov	r1, r3
   18800:	4803      	ldr	r0, [pc, #12]	; (18810 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   18802:	f7fa feb9 	bl	13578 <__cyg_profile_func_exit>
   18806:	4623      	mov	r3, r4
}
   18808:	4618      	mov	r0, r3
   1880a:	b009      	add	sp, #36	; 0x24
   1880c:	bd30      	pop	{r4, r5, pc}
   1880e:	bf00      	nop
   18810:	000187c1 	.word	0x000187c1

00018814 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   18814:	b530      	push	{r4, r5, lr}
   18816:	b089      	sub	sp, #36	; 0x24
   18818:	4675      	mov	r5, lr
   1881a:	9003      	str	r0, [sp, #12]
   1881c:	9201      	str	r2, [sp, #4]
   1881e:	9300      	str	r3, [sp, #0]
   18820:	460b      	mov	r3, r1
   18822:	f88d 300b 	strb.w	r3, [sp, #11]
   18826:	462b      	mov	r3, r5
   18828:	4619      	mov	r1, r3
   1882a:	4816      	ldr	r0, [pc, #88]	; (18884 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   1882c:	f7fa fe90 	bl	13550 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   18830:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   18834:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   18836:	2320      	movs	r3, #32
   18838:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1883a:	9b00      	ldr	r3, [sp, #0]
   1883c:	f1c3 0320 	rsb	r3, r3, #32
   18840:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18844:	fa22 f303 	lsr.w	r3, r2, r3
   18848:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   1884a:	9a05      	ldr	r2, [sp, #20]
   1884c:	9b01      	ldr	r3, [sp, #4]
   1884e:	fa02 f303 	lsl.w	r3, r2, r3
   18852:	43db      	mvns	r3, r3
   18854:	9a03      	ldr	r2, [sp, #12]
   18856:	4013      	ands	r3, r2
   18858:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   1885a:	f89d 200b 	ldrb.w	r2, [sp, #11]
   1885e:	9b05      	ldr	r3, [sp, #20]
   18860:	401a      	ands	r2, r3
   18862:	9b01      	ldr	r3, [sp, #4]
   18864:	fa02 f303 	lsl.w	r3, r2, r3
   18868:	9a03      	ldr	r2, [sp, #12]
   1886a:	4313      	orrs	r3, r2
   1886c:	9303      	str	r3, [sp, #12]
  return target;
   1886e:	9c03      	ldr	r4, [sp, #12]
   18870:	462b      	mov	r3, r5
   18872:	4619      	mov	r1, r3
   18874:	4803      	ldr	r0, [pc, #12]	; (18884 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   18876:	f7fa fe7f 	bl	13578 <__cyg_profile_func_exit>
   1887a:	4623      	mov	r3, r4
}
   1887c:	4618      	mov	r0, r3
   1887e:	b009      	add	sp, #36	; 0x24
   18880:	bd30      	pop	{r4, r5, pc}
   18882:	bf00      	nop
   18884:	00018815 	.word	0x00018815

00018888 <__static_initialization_and_destruction_0(int, int)>:
extern "C" DRESULT disk_ioctl([[maybe_unused]] BYTE drive_number,
                              [[maybe_unused]] BYTE command,
                              [[maybe_unused]] void * buffer)
{
  return RES_PARERR;
}
   18888:	b530      	push	{r4, r5, lr}
   1888a:	b085      	sub	sp, #20
   1888c:	4674      	mov	r4, lr
   1888e:	9003      	str	r0, [sp, #12]
   18890:	9102      	str	r1, [sp, #8]
   18892:	4623      	mov	r3, r4
   18894:	4619      	mov	r1, r3
   18896:	480e      	ldr	r0, [pc, #56]	; (188d0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   18898:	f7fa fe5a 	bl	13550 <__cyg_profile_func_enter>
   1889c:	9b03      	ldr	r3, [sp, #12]
   1889e:	2b01      	cmp	r3, #1
   188a0:	d10e      	bne.n	188c0 <__static_initialization_and_destruction_0(int, int)+0x38>
   188a2:	9b02      	ldr	r3, [sp, #8]
   188a4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   188a8:	4293      	cmp	r3, r2
   188aa:	d109      	bne.n	188c0 <__static_initialization_and_destruction_0(int, int)+0x38>
Sd sd_card(Sd::DebugSdCard_t{});
   188ac:	2306      	movs	r3, #6
   188ae:	9301      	str	r3, [sp, #4]
   188b0:	2300      	movs	r3, #0
   188b2:	9300      	str	r3, [sp, #0]
   188b4:	2308      	movs	r3, #8
   188b6:	2201      	movs	r2, #1
   188b8:	4629      	mov	r1, r5
   188ba:	4806      	ldr	r0, [pc, #24]	; (188d4 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   188bc:	f7fe fdda 	bl	17474 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>
   188c0:	4623      	mov	r3, r4
   188c2:	4619      	mov	r1, r3
   188c4:	4802      	ldr	r0, [pc, #8]	; (188d0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   188c6:	f7fa fe57 	bl	13578 <__cyg_profile_func_exit>
}
   188ca:	bf00      	nop
   188cc:	b005      	add	sp, #20
   188ce:	bd30      	pop	{r4, r5, pc}
   188d0:	00018889 	.word	0x00018889
   188d4:	100008e0 	.word	0x100008e0

000188d8 <_GLOBAL__sub_I_disk_status>:
   188d8:	b510      	push	{r4, lr}
   188da:	4674      	mov	r4, lr
   188dc:	4623      	mov	r3, r4
   188de:	4619      	mov	r1, r3
   188e0:	4806      	ldr	r0, [pc, #24]	; (188fc <_GLOBAL__sub_I_disk_status+0x24>)
   188e2:	f7fa fe35 	bl	13550 <__cyg_profile_func_enter>
   188e6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   188ea:	2001      	movs	r0, #1
   188ec:	f7ff ffcc 	bl	18888 <__static_initialization_and_destruction_0(int, int)>
   188f0:	4623      	mov	r3, r4
   188f2:	4619      	mov	r1, r3
   188f4:	4801      	ldr	r0, [pc, #4]	; (188fc <_GLOBAL__sub_I_disk_status+0x24>)
   188f6:	f7fa fe3f 	bl	13578 <__cyg_profile_func_exit>
   188fa:	bd10      	pop	{r4, pc}
   188fc:	000188d9 	.word	0x000188d9

00018900 <__cxa_pure_virtual>:
   18900:	b508      	push	{r3, lr}
   18902:	f000 f80d 	bl	18920 <std::terminate()>

00018906 <__cxxabiv1::__terminate(void (*)())>:
   18906:	b508      	push	{r3, lr}
   18908:	4780      	blx	r0
   1890a:	f000 fa0f 	bl	18d2c <abort>
   1890e:	Address 0x000000000001890e is out of bounds.


00018910 <std::get_terminate()>:
   18910:	4b02      	ldr	r3, [pc, #8]	; (1891c <std::get_terminate()+0xc>)
   18912:	6818      	ldr	r0, [r3, #0]
   18914:	f3bf 8f5b 	dmb	ish
   18918:	4770      	bx	lr
   1891a:	bf00      	nop
   1891c:	1000021c 	.word	0x1000021c

00018920 <std::terminate()>:
   18920:	b508      	push	{r3, lr}
   18922:	f7ff fff5 	bl	18910 <std::get_terminate()>
   18926:	f7ff ffee 	bl	18906 <__cxxabiv1::__terminate(void (*)())>
   1892a:	Address 0x000000000001892a is out of bounds.


0001892c <roundf>:
   1892c:	b082      	sub	sp, #8
   1892e:	ed8d 0a01 	vstr	s0, [sp, #4]
   18932:	9901      	ldr	r1, [sp, #4]
   18934:	f3c1 53c7 	ubfx	r3, r1, #23, #8
   18938:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
   1893c:	2a16      	cmp	r2, #22
   1893e:	dc0c      	bgt.n	1895a <roundf+0x2e>
   18940:	2a00      	cmp	r2, #0
   18942:	db10      	blt.n	18966 <roundf+0x3a>
   18944:	4810      	ldr	r0, [pc, #64]	; (18988 <roundf+0x5c>)
   18946:	4110      	asrs	r0, r2
   18948:	4201      	tst	r1, r0
   1894a:	d008      	beq.n	1895e <roundf+0x32>
   1894c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   18950:	4113      	asrs	r3, r2
   18952:	440b      	add	r3, r1
   18954:	ea23 0300 	bic.w	r3, r3, r0
   18958:	e00b      	b.n	18972 <roundf+0x46>
   1895a:	2a80      	cmp	r2, #128	; 0x80
   1895c:	d00d      	beq.n	1897a <roundf+0x4e>
   1895e:	ed9d 0a01 	vldr	s0, [sp, #4]
   18962:	b002      	add	sp, #8
   18964:	4770      	bx	lr
   18966:	3201      	adds	r2, #1
   18968:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
   1896c:	d101      	bne.n	18972 <roundf+0x46>
   1896e:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
   18972:	ee00 3a10 	vmov	s0, r3
   18976:	b002      	add	sp, #8
   18978:	4770      	bx	lr
   1897a:	eddd 7a01 	vldr	s15, [sp, #4]
   1897e:	ee37 0aa7 	vadd.f32	s0, s15, s15
   18982:	b002      	add	sp, #8
   18984:	4770      	bx	lr
   18986:	bf00      	nop
   18988:	007fffff 	.word	0x007fffff

0001898c <__aeabi_d2f>:
   1898c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   18990:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   18994:	bf24      	itt	cs
   18996:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1899a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1899e:	d90d      	bls.n	189bc <__aeabi_d2f+0x30>
   189a0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   189a4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   189a8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   189ac:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   189b0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   189b4:	bf08      	it	eq
   189b6:	f020 0001 	biceq.w	r0, r0, #1
   189ba:	4770      	bx	lr
   189bc:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   189c0:	d121      	bne.n	18a06 <__aeabi_d2f+0x7a>
   189c2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   189c6:	bfbc      	itt	lt
   189c8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   189cc:	4770      	bxlt	lr
   189ce:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   189d2:	ea4f 5252 	mov.w	r2, r2, lsr #21
   189d6:	f1c2 0218 	rsb	r2, r2, #24
   189da:	f1c2 0c20 	rsb	ip, r2, #32
   189de:	fa10 f30c 	lsls.w	r3, r0, ip
   189e2:	fa20 f002 	lsr.w	r0, r0, r2
   189e6:	bf18      	it	ne
   189e8:	f040 0001 	orrne.w	r0, r0, #1
   189ec:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   189f0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   189f4:	fa03 fc0c 	lsl.w	ip, r3, ip
   189f8:	ea40 000c 	orr.w	r0, r0, ip
   189fc:	fa23 f302 	lsr.w	r3, r3, r2
   18a00:	ea4f 0343 	mov.w	r3, r3, lsl #1
   18a04:	e7cc      	b.n	189a0 <__aeabi_d2f+0x14>
   18a06:	ea7f 5362 	mvns.w	r3, r2, asr #21
   18a0a:	d107      	bne.n	18a1c <__aeabi_d2f+0x90>
   18a0c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   18a10:	bf1e      	ittt	ne
   18a12:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   18a16:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   18a1a:	4770      	bxne	lr
   18a1c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   18a20:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   18a24:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   18a28:	4770      	bx	lr
   18a2a:	bf00      	nop

00018a2c <__aeabi_uldivmod>:
   18a2c:	b953      	cbnz	r3, 18a44 <__aeabi_uldivmod+0x18>
   18a2e:	b94a      	cbnz	r2, 18a44 <__aeabi_uldivmod+0x18>
   18a30:	2900      	cmp	r1, #0
   18a32:	bf08      	it	eq
   18a34:	2800      	cmpeq	r0, #0
   18a36:	bf1c      	itt	ne
   18a38:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   18a3c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   18a40:	f000 b972 	b.w	18d28 <__aeabi_idiv0>
   18a44:	f1ad 0c08 	sub.w	ip, sp, #8
   18a48:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   18a4c:	f000 f806 	bl	18a5c <__udivmoddi4>
   18a50:	f8dd e004 	ldr.w	lr, [sp, #4]
   18a54:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   18a58:	b004      	add	sp, #16
   18a5a:	4770      	bx	lr

00018a5c <__udivmoddi4>:
   18a5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   18a60:	9e08      	ldr	r6, [sp, #32]
   18a62:	4604      	mov	r4, r0
   18a64:	4688      	mov	r8, r1
   18a66:	2b00      	cmp	r3, #0
   18a68:	d14b      	bne.n	18b02 <__udivmoddi4+0xa6>
   18a6a:	428a      	cmp	r2, r1
   18a6c:	4615      	mov	r5, r2
   18a6e:	d967      	bls.n	18b40 <__udivmoddi4+0xe4>
   18a70:	fab2 f282 	clz	r2, r2
   18a74:	b14a      	cbz	r2, 18a8a <__udivmoddi4+0x2e>
   18a76:	f1c2 0720 	rsb	r7, r2, #32
   18a7a:	fa01 f302 	lsl.w	r3, r1, r2
   18a7e:	fa20 f707 	lsr.w	r7, r0, r7
   18a82:	4095      	lsls	r5, r2
   18a84:	ea47 0803 	orr.w	r8, r7, r3
   18a88:	4094      	lsls	r4, r2
   18a8a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   18a8e:	0c23      	lsrs	r3, r4, #16
   18a90:	fbb8 f7fe 	udiv	r7, r8, lr
   18a94:	fa1f fc85 	uxth.w	ip, r5
   18a98:	fb0e 8817 	mls	r8, lr, r7, r8
   18a9c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   18aa0:	fb07 f10c 	mul.w	r1, r7, ip
   18aa4:	4299      	cmp	r1, r3
   18aa6:	d909      	bls.n	18abc <__udivmoddi4+0x60>
   18aa8:	18eb      	adds	r3, r5, r3
   18aaa:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   18aae:	f080 811b 	bcs.w	18ce8 <__udivmoddi4+0x28c>
   18ab2:	4299      	cmp	r1, r3
   18ab4:	f240 8118 	bls.w	18ce8 <__udivmoddi4+0x28c>
   18ab8:	3f02      	subs	r7, #2
   18aba:	442b      	add	r3, r5
   18abc:	1a5b      	subs	r3, r3, r1
   18abe:	b2a4      	uxth	r4, r4
   18ac0:	fbb3 f0fe 	udiv	r0, r3, lr
   18ac4:	fb0e 3310 	mls	r3, lr, r0, r3
   18ac8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   18acc:	fb00 fc0c 	mul.w	ip, r0, ip
   18ad0:	45a4      	cmp	ip, r4
   18ad2:	d909      	bls.n	18ae8 <__udivmoddi4+0x8c>
   18ad4:	192c      	adds	r4, r5, r4
   18ad6:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   18ada:	f080 8107 	bcs.w	18cec <__udivmoddi4+0x290>
   18ade:	45a4      	cmp	ip, r4
   18ae0:	f240 8104 	bls.w	18cec <__udivmoddi4+0x290>
   18ae4:	3802      	subs	r0, #2
   18ae6:	442c      	add	r4, r5
   18ae8:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   18aec:	eba4 040c 	sub.w	r4, r4, ip
   18af0:	2700      	movs	r7, #0
   18af2:	b11e      	cbz	r6, 18afc <__udivmoddi4+0xa0>
   18af4:	40d4      	lsrs	r4, r2
   18af6:	2300      	movs	r3, #0
   18af8:	e9c6 4300 	strd	r4, r3, [r6]
   18afc:	4639      	mov	r1, r7
   18afe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18b02:	428b      	cmp	r3, r1
   18b04:	d909      	bls.n	18b1a <__udivmoddi4+0xbe>
   18b06:	2e00      	cmp	r6, #0
   18b08:	f000 80eb 	beq.w	18ce2 <__udivmoddi4+0x286>
   18b0c:	2700      	movs	r7, #0
   18b0e:	e9c6 0100 	strd	r0, r1, [r6]
   18b12:	4638      	mov	r0, r7
   18b14:	4639      	mov	r1, r7
   18b16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18b1a:	fab3 f783 	clz	r7, r3
   18b1e:	2f00      	cmp	r7, #0
   18b20:	d147      	bne.n	18bb2 <__udivmoddi4+0x156>
   18b22:	428b      	cmp	r3, r1
   18b24:	d302      	bcc.n	18b2c <__udivmoddi4+0xd0>
   18b26:	4282      	cmp	r2, r0
   18b28:	f200 80fa 	bhi.w	18d20 <__udivmoddi4+0x2c4>
   18b2c:	1a84      	subs	r4, r0, r2
   18b2e:	eb61 0303 	sbc.w	r3, r1, r3
   18b32:	2001      	movs	r0, #1
   18b34:	4698      	mov	r8, r3
   18b36:	2e00      	cmp	r6, #0
   18b38:	d0e0      	beq.n	18afc <__udivmoddi4+0xa0>
   18b3a:	e9c6 4800 	strd	r4, r8, [r6]
   18b3e:	e7dd      	b.n	18afc <__udivmoddi4+0xa0>
   18b40:	b902      	cbnz	r2, 18b44 <__udivmoddi4+0xe8>
   18b42:	deff      	udf	#255	; 0xff
   18b44:	fab2 f282 	clz	r2, r2
   18b48:	2a00      	cmp	r2, #0
   18b4a:	f040 808f 	bne.w	18c6c <__udivmoddi4+0x210>
   18b4e:	1b49      	subs	r1, r1, r5
   18b50:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   18b54:	fa1f f885 	uxth.w	r8, r5
   18b58:	2701      	movs	r7, #1
   18b5a:	fbb1 fcfe 	udiv	ip, r1, lr
   18b5e:	0c23      	lsrs	r3, r4, #16
   18b60:	fb0e 111c 	mls	r1, lr, ip, r1
   18b64:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   18b68:	fb08 f10c 	mul.w	r1, r8, ip
   18b6c:	4299      	cmp	r1, r3
   18b6e:	d907      	bls.n	18b80 <__udivmoddi4+0x124>
   18b70:	18eb      	adds	r3, r5, r3
   18b72:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   18b76:	d202      	bcs.n	18b7e <__udivmoddi4+0x122>
   18b78:	4299      	cmp	r1, r3
   18b7a:	f200 80cd 	bhi.w	18d18 <__udivmoddi4+0x2bc>
   18b7e:	4684      	mov	ip, r0
   18b80:	1a59      	subs	r1, r3, r1
   18b82:	b2a3      	uxth	r3, r4
   18b84:	fbb1 f0fe 	udiv	r0, r1, lr
   18b88:	fb0e 1410 	mls	r4, lr, r0, r1
   18b8c:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   18b90:	fb08 f800 	mul.w	r8, r8, r0
   18b94:	45a0      	cmp	r8, r4
   18b96:	d907      	bls.n	18ba8 <__udivmoddi4+0x14c>
   18b98:	192c      	adds	r4, r5, r4
   18b9a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   18b9e:	d202      	bcs.n	18ba6 <__udivmoddi4+0x14a>
   18ba0:	45a0      	cmp	r8, r4
   18ba2:	f200 80b6 	bhi.w	18d12 <__udivmoddi4+0x2b6>
   18ba6:	4618      	mov	r0, r3
   18ba8:	eba4 0408 	sub.w	r4, r4, r8
   18bac:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   18bb0:	e79f      	b.n	18af2 <__udivmoddi4+0x96>
   18bb2:	f1c7 0c20 	rsb	ip, r7, #32
   18bb6:	40bb      	lsls	r3, r7
   18bb8:	fa22 fe0c 	lsr.w	lr, r2, ip
   18bbc:	ea4e 0e03 	orr.w	lr, lr, r3
   18bc0:	fa01 f407 	lsl.w	r4, r1, r7
   18bc4:	fa20 f50c 	lsr.w	r5, r0, ip
   18bc8:	fa21 f30c 	lsr.w	r3, r1, ip
   18bcc:	ea4f 481e 	mov.w	r8, lr, lsr #16
   18bd0:	4325      	orrs	r5, r4
   18bd2:	fbb3 f9f8 	udiv	r9, r3, r8
   18bd6:	0c2c      	lsrs	r4, r5, #16
   18bd8:	fb08 3319 	mls	r3, r8, r9, r3
   18bdc:	fa1f fa8e 	uxth.w	sl, lr
   18be0:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   18be4:	fb09 f40a 	mul.w	r4, r9, sl
   18be8:	429c      	cmp	r4, r3
   18bea:	fa02 f207 	lsl.w	r2, r2, r7
   18bee:	fa00 f107 	lsl.w	r1, r0, r7
   18bf2:	d90b      	bls.n	18c0c <__udivmoddi4+0x1b0>
   18bf4:	eb1e 0303 	adds.w	r3, lr, r3
   18bf8:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   18bfc:	f080 8087 	bcs.w	18d0e <__udivmoddi4+0x2b2>
   18c00:	429c      	cmp	r4, r3
   18c02:	f240 8084 	bls.w	18d0e <__udivmoddi4+0x2b2>
   18c06:	f1a9 0902 	sub.w	r9, r9, #2
   18c0a:	4473      	add	r3, lr
   18c0c:	1b1b      	subs	r3, r3, r4
   18c0e:	b2ad      	uxth	r5, r5
   18c10:	fbb3 f0f8 	udiv	r0, r3, r8
   18c14:	fb08 3310 	mls	r3, r8, r0, r3
   18c18:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   18c1c:	fb00 fa0a 	mul.w	sl, r0, sl
   18c20:	45a2      	cmp	sl, r4
   18c22:	d908      	bls.n	18c36 <__udivmoddi4+0x1da>
   18c24:	eb1e 0404 	adds.w	r4, lr, r4
   18c28:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   18c2c:	d26b      	bcs.n	18d06 <__udivmoddi4+0x2aa>
   18c2e:	45a2      	cmp	sl, r4
   18c30:	d969      	bls.n	18d06 <__udivmoddi4+0x2aa>
   18c32:	3802      	subs	r0, #2
   18c34:	4474      	add	r4, lr
   18c36:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   18c3a:	fba0 8902 	umull	r8, r9, r0, r2
   18c3e:	eba4 040a 	sub.w	r4, r4, sl
   18c42:	454c      	cmp	r4, r9
   18c44:	46c2      	mov	sl, r8
   18c46:	464b      	mov	r3, r9
   18c48:	d354      	bcc.n	18cf4 <__udivmoddi4+0x298>
   18c4a:	d051      	beq.n	18cf0 <__udivmoddi4+0x294>
   18c4c:	2e00      	cmp	r6, #0
   18c4e:	d069      	beq.n	18d24 <__udivmoddi4+0x2c8>
   18c50:	ebb1 050a 	subs.w	r5, r1, sl
   18c54:	eb64 0403 	sbc.w	r4, r4, r3
   18c58:	fa04 fc0c 	lsl.w	ip, r4, ip
   18c5c:	40fd      	lsrs	r5, r7
   18c5e:	40fc      	lsrs	r4, r7
   18c60:	ea4c 0505 	orr.w	r5, ip, r5
   18c64:	e9c6 5400 	strd	r5, r4, [r6]
   18c68:	2700      	movs	r7, #0
   18c6a:	e747      	b.n	18afc <__udivmoddi4+0xa0>
   18c6c:	f1c2 0320 	rsb	r3, r2, #32
   18c70:	fa20 f703 	lsr.w	r7, r0, r3
   18c74:	4095      	lsls	r5, r2
   18c76:	fa01 f002 	lsl.w	r0, r1, r2
   18c7a:	fa21 f303 	lsr.w	r3, r1, r3
   18c7e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   18c82:	4338      	orrs	r0, r7
   18c84:	0c01      	lsrs	r1, r0, #16
   18c86:	fbb3 f7fe 	udiv	r7, r3, lr
   18c8a:	fa1f f885 	uxth.w	r8, r5
   18c8e:	fb0e 3317 	mls	r3, lr, r7, r3
   18c92:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   18c96:	fb07 f308 	mul.w	r3, r7, r8
   18c9a:	428b      	cmp	r3, r1
   18c9c:	fa04 f402 	lsl.w	r4, r4, r2
   18ca0:	d907      	bls.n	18cb2 <__udivmoddi4+0x256>
   18ca2:	1869      	adds	r1, r5, r1
   18ca4:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   18ca8:	d22f      	bcs.n	18d0a <__udivmoddi4+0x2ae>
   18caa:	428b      	cmp	r3, r1
   18cac:	d92d      	bls.n	18d0a <__udivmoddi4+0x2ae>
   18cae:	3f02      	subs	r7, #2
   18cb0:	4429      	add	r1, r5
   18cb2:	1acb      	subs	r3, r1, r3
   18cb4:	b281      	uxth	r1, r0
   18cb6:	fbb3 f0fe 	udiv	r0, r3, lr
   18cba:	fb0e 3310 	mls	r3, lr, r0, r3
   18cbe:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   18cc2:	fb00 f308 	mul.w	r3, r0, r8
   18cc6:	428b      	cmp	r3, r1
   18cc8:	d907      	bls.n	18cda <__udivmoddi4+0x27e>
   18cca:	1869      	adds	r1, r5, r1
   18ccc:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   18cd0:	d217      	bcs.n	18d02 <__udivmoddi4+0x2a6>
   18cd2:	428b      	cmp	r3, r1
   18cd4:	d915      	bls.n	18d02 <__udivmoddi4+0x2a6>
   18cd6:	3802      	subs	r0, #2
   18cd8:	4429      	add	r1, r5
   18cda:	1ac9      	subs	r1, r1, r3
   18cdc:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   18ce0:	e73b      	b.n	18b5a <__udivmoddi4+0xfe>
   18ce2:	4637      	mov	r7, r6
   18ce4:	4630      	mov	r0, r6
   18ce6:	e709      	b.n	18afc <__udivmoddi4+0xa0>
   18ce8:	4607      	mov	r7, r0
   18cea:	e6e7      	b.n	18abc <__udivmoddi4+0x60>
   18cec:	4618      	mov	r0, r3
   18cee:	e6fb      	b.n	18ae8 <__udivmoddi4+0x8c>
   18cf0:	4541      	cmp	r1, r8
   18cf2:	d2ab      	bcs.n	18c4c <__udivmoddi4+0x1f0>
   18cf4:	ebb8 0a02 	subs.w	sl, r8, r2
   18cf8:	eb69 020e 	sbc.w	r2, r9, lr
   18cfc:	3801      	subs	r0, #1
   18cfe:	4613      	mov	r3, r2
   18d00:	e7a4      	b.n	18c4c <__udivmoddi4+0x1f0>
   18d02:	4660      	mov	r0, ip
   18d04:	e7e9      	b.n	18cda <__udivmoddi4+0x27e>
   18d06:	4618      	mov	r0, r3
   18d08:	e795      	b.n	18c36 <__udivmoddi4+0x1da>
   18d0a:	4667      	mov	r7, ip
   18d0c:	e7d1      	b.n	18cb2 <__udivmoddi4+0x256>
   18d0e:	4681      	mov	r9, r0
   18d10:	e77c      	b.n	18c0c <__udivmoddi4+0x1b0>
   18d12:	3802      	subs	r0, #2
   18d14:	442c      	add	r4, r5
   18d16:	e747      	b.n	18ba8 <__udivmoddi4+0x14c>
   18d18:	f1ac 0c02 	sub.w	ip, ip, #2
   18d1c:	442b      	add	r3, r5
   18d1e:	e72f      	b.n	18b80 <__udivmoddi4+0x124>
   18d20:	4638      	mov	r0, r7
   18d22:	e708      	b.n	18b36 <__udivmoddi4+0xda>
   18d24:	4637      	mov	r7, r6
   18d26:	e6e9      	b.n	18afc <__udivmoddi4+0xa0>

00018d28 <__aeabi_idiv0>:
   18d28:	4770      	bx	lr
   18d2a:	bf00      	nop

00018d2c <abort>:
   18d2c:	b508      	push	{r3, lr}
   18d2e:	2006      	movs	r0, #6
   18d30:	f000 f92c 	bl	18f8c <raise>
   18d34:	2001      	movs	r0, #1
   18d36:	f7fa fb3f 	bl	133b8 <_exit>
   18d3a:	Address 0x0000000000018d3a is out of bounds.


00018d3c <__libc_init_array>:
   18d3c:	b570      	push	{r4, r5, r6, lr}
   18d3e:	4e0d      	ldr	r6, [pc, #52]	; (18d74 <__libc_init_array+0x38>)
   18d40:	4c0d      	ldr	r4, [pc, #52]	; (18d78 <__libc_init_array+0x3c>)
   18d42:	1ba4      	subs	r4, r4, r6
   18d44:	10a4      	asrs	r4, r4, #2
   18d46:	2500      	movs	r5, #0
   18d48:	42a5      	cmp	r5, r4
   18d4a:	d109      	bne.n	18d60 <__libc_init_array+0x24>
   18d4c:	4e0b      	ldr	r6, [pc, #44]	; (18d7c <__libc_init_array+0x40>)
   18d4e:	4c0c      	ldr	r4, [pc, #48]	; (18d80 <__libc_init_array+0x44>)
   18d50:	f7f7 fad6 	bl	10300 <_init>
   18d54:	1ba4      	subs	r4, r4, r6
   18d56:	10a4      	asrs	r4, r4, #2
   18d58:	2500      	movs	r5, #0
   18d5a:	42a5      	cmp	r5, r4
   18d5c:	d105      	bne.n	18d6a <__libc_init_array+0x2e>
   18d5e:	bd70      	pop	{r4, r5, r6, pc}
   18d60:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   18d64:	4798      	blx	r3
   18d66:	3501      	adds	r5, #1
   18d68:	e7ee      	b.n	18d48 <__libc_init_array+0xc>
   18d6a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   18d6e:	4798      	blx	r3
   18d70:	3501      	adds	r5, #1
   18d72:	e7f2      	b.n	18d5a <__libc_init_array+0x1e>
   18d74:	0001030c 	.word	0x0001030c
   18d78:	0001030c 	.word	0x0001030c
   18d7c:	0001030c 	.word	0x0001030c
   18d80:	0001031c 	.word	0x0001031c

00018d84 <malloc>:
   18d84:	4b02      	ldr	r3, [pc, #8]	; (18d90 <malloc+0xc>)
   18d86:	4601      	mov	r1, r0
   18d88:	6818      	ldr	r0, [r3, #0]
   18d8a:	f000 b86d 	b.w	18e68 <_malloc_r>
   18d8e:	bf00      	nop
   18d90:	10000220 	.word	0x10000220

00018d94 <free>:
   18d94:	4b02      	ldr	r3, [pc, #8]	; (18da0 <free+0xc>)
   18d96:	4601      	mov	r1, r0
   18d98:	6818      	ldr	r0, [r3, #0]
   18d9a:	f000 b817 	b.w	18dcc <_free_r>
   18d9e:	bf00      	nop
   18da0:	10000220 	.word	0x10000220

00018da4 <memcpy>:
   18da4:	b510      	push	{r4, lr}
   18da6:	1e43      	subs	r3, r0, #1
   18da8:	440a      	add	r2, r1
   18daa:	4291      	cmp	r1, r2
   18dac:	d100      	bne.n	18db0 <memcpy+0xc>
   18dae:	bd10      	pop	{r4, pc}
   18db0:	f811 4b01 	ldrb.w	r4, [r1], #1
   18db4:	f803 4f01 	strb.w	r4, [r3, #1]!
   18db8:	e7f7      	b.n	18daa <memcpy+0x6>

00018dba <memset>:
   18dba:	4402      	add	r2, r0
   18dbc:	4603      	mov	r3, r0
   18dbe:	4293      	cmp	r3, r2
   18dc0:	d100      	bne.n	18dc4 <memset+0xa>
   18dc2:	4770      	bx	lr
   18dc4:	f803 1b01 	strb.w	r1, [r3], #1
   18dc8:	e7f9      	b.n	18dbe <memset+0x4>
   18dca:	Address 0x0000000000018dca is out of bounds.


00018dcc <_free_r>:
   18dcc:	b538      	push	{r3, r4, r5, lr}
   18dce:	4605      	mov	r5, r0
   18dd0:	2900      	cmp	r1, #0
   18dd2:	d045      	beq.n	18e60 <_free_r+0x94>
   18dd4:	f851 3c04 	ldr.w	r3, [r1, #-4]
   18dd8:	1f0c      	subs	r4, r1, #4
   18dda:	2b00      	cmp	r3, #0
   18ddc:	bfb8      	it	lt
   18dde:	18e4      	addlt	r4, r4, r3
   18de0:	f000 f8f0 	bl	18fc4 <__malloc_lock>
   18de4:	4a1f      	ldr	r2, [pc, #124]	; (18e64 <_free_r+0x98>)
   18de6:	6813      	ldr	r3, [r2, #0]
   18de8:	4610      	mov	r0, r2
   18dea:	b933      	cbnz	r3, 18dfa <_free_r+0x2e>
   18dec:	6063      	str	r3, [r4, #4]
   18dee:	6014      	str	r4, [r2, #0]
   18df0:	4628      	mov	r0, r5
   18df2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   18df6:	f000 b8e6 	b.w	18fc6 <__malloc_unlock>
   18dfa:	42a3      	cmp	r3, r4
   18dfc:	d90c      	bls.n	18e18 <_free_r+0x4c>
   18dfe:	6821      	ldr	r1, [r4, #0]
   18e00:	1862      	adds	r2, r4, r1
   18e02:	4293      	cmp	r3, r2
   18e04:	bf04      	itt	eq
   18e06:	681a      	ldreq	r2, [r3, #0]
   18e08:	685b      	ldreq	r3, [r3, #4]
   18e0a:	6063      	str	r3, [r4, #4]
   18e0c:	bf04      	itt	eq
   18e0e:	1852      	addeq	r2, r2, r1
   18e10:	6022      	streq	r2, [r4, #0]
   18e12:	6004      	str	r4, [r0, #0]
   18e14:	e7ec      	b.n	18df0 <_free_r+0x24>
   18e16:	4613      	mov	r3, r2
   18e18:	685a      	ldr	r2, [r3, #4]
   18e1a:	b10a      	cbz	r2, 18e20 <_free_r+0x54>
   18e1c:	42a2      	cmp	r2, r4
   18e1e:	d9fa      	bls.n	18e16 <_free_r+0x4a>
   18e20:	6819      	ldr	r1, [r3, #0]
   18e22:	1858      	adds	r0, r3, r1
   18e24:	42a0      	cmp	r0, r4
   18e26:	d10b      	bne.n	18e40 <_free_r+0x74>
   18e28:	6820      	ldr	r0, [r4, #0]
   18e2a:	4401      	add	r1, r0
   18e2c:	1858      	adds	r0, r3, r1
   18e2e:	4282      	cmp	r2, r0
   18e30:	6019      	str	r1, [r3, #0]
   18e32:	d1dd      	bne.n	18df0 <_free_r+0x24>
   18e34:	6810      	ldr	r0, [r2, #0]
   18e36:	6852      	ldr	r2, [r2, #4]
   18e38:	605a      	str	r2, [r3, #4]
   18e3a:	4401      	add	r1, r0
   18e3c:	6019      	str	r1, [r3, #0]
   18e3e:	e7d7      	b.n	18df0 <_free_r+0x24>
   18e40:	d902      	bls.n	18e48 <_free_r+0x7c>
   18e42:	230c      	movs	r3, #12
   18e44:	602b      	str	r3, [r5, #0]
   18e46:	e7d3      	b.n	18df0 <_free_r+0x24>
   18e48:	6820      	ldr	r0, [r4, #0]
   18e4a:	1821      	adds	r1, r4, r0
   18e4c:	428a      	cmp	r2, r1
   18e4e:	bf04      	itt	eq
   18e50:	6811      	ldreq	r1, [r2, #0]
   18e52:	6852      	ldreq	r2, [r2, #4]
   18e54:	6062      	str	r2, [r4, #4]
   18e56:	bf04      	itt	eq
   18e58:	1809      	addeq	r1, r1, r0
   18e5a:	6021      	streq	r1, [r4, #0]
   18e5c:	605c      	str	r4, [r3, #4]
   18e5e:	e7c7      	b.n	18df0 <_free_r+0x24>
   18e60:	bd38      	pop	{r3, r4, r5, pc}
   18e62:	bf00      	nop
   18e64:	10000948 	.word	0x10000948

00018e68 <_malloc_r>:
   18e68:	b570      	push	{r4, r5, r6, lr}
   18e6a:	1ccd      	adds	r5, r1, #3
   18e6c:	f025 0503 	bic.w	r5, r5, #3
   18e70:	3508      	adds	r5, #8
   18e72:	2d0c      	cmp	r5, #12
   18e74:	bf38      	it	cc
   18e76:	250c      	movcc	r5, #12
   18e78:	2d00      	cmp	r5, #0
   18e7a:	4606      	mov	r6, r0
   18e7c:	db01      	blt.n	18e82 <_malloc_r+0x1a>
   18e7e:	42a9      	cmp	r1, r5
   18e80:	d903      	bls.n	18e8a <_malloc_r+0x22>
   18e82:	230c      	movs	r3, #12
   18e84:	6033      	str	r3, [r6, #0]
   18e86:	2000      	movs	r0, #0
   18e88:	bd70      	pop	{r4, r5, r6, pc}
   18e8a:	f000 f89b 	bl	18fc4 <__malloc_lock>
   18e8e:	4a21      	ldr	r2, [pc, #132]	; (18f14 <_malloc_r+0xac>)
   18e90:	6814      	ldr	r4, [r2, #0]
   18e92:	4621      	mov	r1, r4
   18e94:	b991      	cbnz	r1, 18ebc <_malloc_r+0x54>
   18e96:	4c20      	ldr	r4, [pc, #128]	; (18f18 <_malloc_r+0xb0>)
   18e98:	6823      	ldr	r3, [r4, #0]
   18e9a:	b91b      	cbnz	r3, 18ea4 <_malloc_r+0x3c>
   18e9c:	4630      	mov	r0, r6
   18e9e:	f000 f83d 	bl	18f1c <_sbrk_r>
   18ea2:	6020      	str	r0, [r4, #0]
   18ea4:	4629      	mov	r1, r5
   18ea6:	4630      	mov	r0, r6
   18ea8:	f000 f838 	bl	18f1c <_sbrk_r>
   18eac:	1c43      	adds	r3, r0, #1
   18eae:	d124      	bne.n	18efa <_malloc_r+0x92>
   18eb0:	230c      	movs	r3, #12
   18eb2:	6033      	str	r3, [r6, #0]
   18eb4:	4630      	mov	r0, r6
   18eb6:	f000 f886 	bl	18fc6 <__malloc_unlock>
   18eba:	e7e4      	b.n	18e86 <_malloc_r+0x1e>
   18ebc:	680b      	ldr	r3, [r1, #0]
   18ebe:	1b5b      	subs	r3, r3, r5
   18ec0:	d418      	bmi.n	18ef4 <_malloc_r+0x8c>
   18ec2:	2b0b      	cmp	r3, #11
   18ec4:	d90f      	bls.n	18ee6 <_malloc_r+0x7e>
   18ec6:	600b      	str	r3, [r1, #0]
   18ec8:	50cd      	str	r5, [r1, r3]
   18eca:	18cc      	adds	r4, r1, r3
   18ecc:	4630      	mov	r0, r6
   18ece:	f000 f87a 	bl	18fc6 <__malloc_unlock>
   18ed2:	f104 000b 	add.w	r0, r4, #11
   18ed6:	1d23      	adds	r3, r4, #4
   18ed8:	f020 0007 	bic.w	r0, r0, #7
   18edc:	1ac3      	subs	r3, r0, r3
   18ede:	d0d3      	beq.n	18e88 <_malloc_r+0x20>
   18ee0:	425a      	negs	r2, r3
   18ee2:	50e2      	str	r2, [r4, r3]
   18ee4:	e7d0      	b.n	18e88 <_malloc_r+0x20>
   18ee6:	428c      	cmp	r4, r1
   18ee8:	684b      	ldr	r3, [r1, #4]
   18eea:	bf16      	itet	ne
   18eec:	6063      	strne	r3, [r4, #4]
   18eee:	6013      	streq	r3, [r2, #0]
   18ef0:	460c      	movne	r4, r1
   18ef2:	e7eb      	b.n	18ecc <_malloc_r+0x64>
   18ef4:	460c      	mov	r4, r1
   18ef6:	6849      	ldr	r1, [r1, #4]
   18ef8:	e7cc      	b.n	18e94 <_malloc_r+0x2c>
   18efa:	1cc4      	adds	r4, r0, #3
   18efc:	f024 0403 	bic.w	r4, r4, #3
   18f00:	42a0      	cmp	r0, r4
   18f02:	d005      	beq.n	18f10 <_malloc_r+0xa8>
   18f04:	1a21      	subs	r1, r4, r0
   18f06:	4630      	mov	r0, r6
   18f08:	f000 f808 	bl	18f1c <_sbrk_r>
   18f0c:	3001      	adds	r0, #1
   18f0e:	d0cf      	beq.n	18eb0 <_malloc_r+0x48>
   18f10:	6025      	str	r5, [r4, #0]
   18f12:	e7db      	b.n	18ecc <_malloc_r+0x64>
   18f14:	10000948 	.word	0x10000948
   18f18:	1000094c 	.word	0x1000094c

00018f1c <_sbrk_r>:
   18f1c:	b538      	push	{r3, r4, r5, lr}
   18f1e:	4c06      	ldr	r4, [pc, #24]	; (18f38 <_sbrk_r+0x1c>)
   18f20:	2300      	movs	r3, #0
   18f22:	4605      	mov	r5, r0
   18f24:	4608      	mov	r0, r1
   18f26:	6023      	str	r3, [r4, #0]
   18f28:	f7fa fa7c 	bl	13424 <_sbrk>
   18f2c:	1c43      	adds	r3, r0, #1
   18f2e:	d102      	bne.n	18f36 <_sbrk_r+0x1a>
   18f30:	6823      	ldr	r3, [r4, #0]
   18f32:	b103      	cbz	r3, 18f36 <_sbrk_r+0x1a>
   18f34:	602b      	str	r3, [r5, #0]
   18f36:	bd38      	pop	{r3, r4, r5, pc}
   18f38:	10000950 	.word	0x10000950

00018f3c <_raise_r>:
   18f3c:	291f      	cmp	r1, #31
   18f3e:	b538      	push	{r3, r4, r5, lr}
   18f40:	4604      	mov	r4, r0
   18f42:	460d      	mov	r5, r1
   18f44:	d904      	bls.n	18f50 <_raise_r+0x14>
   18f46:	2316      	movs	r3, #22
   18f48:	6003      	str	r3, [r0, #0]
   18f4a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   18f4e:	bd38      	pop	{r3, r4, r5, pc}
   18f50:	6c42      	ldr	r2, [r0, #68]	; 0x44
   18f52:	b112      	cbz	r2, 18f5a <_raise_r+0x1e>
   18f54:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   18f58:	b94b      	cbnz	r3, 18f6e <_raise_r+0x32>
   18f5a:	4620      	mov	r0, r4
   18f5c:	f000 f830 	bl	18fc0 <_getpid_r>
   18f60:	462a      	mov	r2, r5
   18f62:	4601      	mov	r1, r0
   18f64:	4620      	mov	r0, r4
   18f66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   18f6a:	f000 b817 	b.w	18f9c <_kill_r>
   18f6e:	2b01      	cmp	r3, #1
   18f70:	d00a      	beq.n	18f88 <_raise_r+0x4c>
   18f72:	1c59      	adds	r1, r3, #1
   18f74:	d103      	bne.n	18f7e <_raise_r+0x42>
   18f76:	2316      	movs	r3, #22
   18f78:	6003      	str	r3, [r0, #0]
   18f7a:	2001      	movs	r0, #1
   18f7c:	e7e7      	b.n	18f4e <_raise_r+0x12>
   18f7e:	2400      	movs	r4, #0
   18f80:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   18f84:	4628      	mov	r0, r5
   18f86:	4798      	blx	r3
   18f88:	2000      	movs	r0, #0
   18f8a:	e7e0      	b.n	18f4e <_raise_r+0x12>

00018f8c <raise>:
   18f8c:	4b02      	ldr	r3, [pc, #8]	; (18f98 <raise+0xc>)
   18f8e:	4601      	mov	r1, r0
   18f90:	6818      	ldr	r0, [r3, #0]
   18f92:	f7ff bfd3 	b.w	18f3c <_raise_r>
   18f96:	bf00      	nop
   18f98:	10000220 	.word	0x10000220

00018f9c <_kill_r>:
   18f9c:	b538      	push	{r3, r4, r5, lr}
   18f9e:	4c07      	ldr	r4, [pc, #28]	; (18fbc <_kill_r+0x20>)
   18fa0:	2300      	movs	r3, #0
   18fa2:	4605      	mov	r5, r0
   18fa4:	4608      	mov	r0, r1
   18fa6:	4611      	mov	r1, r2
   18fa8:	6023      	str	r3, [r4, #0]
   18faa:	f7fa fa23 	bl	133f4 <_kill>
   18fae:	1c43      	adds	r3, r0, #1
   18fb0:	d102      	bne.n	18fb8 <_kill_r+0x1c>
   18fb2:	6823      	ldr	r3, [r4, #0]
   18fb4:	b103      	cbz	r3, 18fb8 <_kill_r+0x1c>
   18fb6:	602b      	str	r3, [r5, #0]
   18fb8:	bd38      	pop	{r3, r4, r5, pc}
   18fba:	bf00      	nop
   18fbc:	10000950 	.word	0x10000950

00018fc0 <_getpid_r>:
   18fc0:	f7fa ba06 	b.w	133d0 <_getpid>

00018fc4 <__malloc_lock>:
   18fc4:	4770      	bx	lr

00018fc6 <__malloc_unlock>:
   18fc6:	4770      	bx	lr

00018fc8 <LabGPIO::IntEdge(LabGPIO::Edge)::file>:
   18fc8:	614c 4762 4950 2e4f 7063 0070 5b1b 3234     LabGPIO.cpp..[42
   18fd8:	206d 2020 4920 464e 1b4f 305b 393b 6d34     m    INFO.[0;94m
   18fe8:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   18ff8:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   19008:	6f4e 6520 6764 2065 6573 656c 7463 6465     No edge selected
   19018:	5b1b 6d30 000a ffff                         .[0m....

00019020 <LabGPIO::ClrEdge(LabGPIO::Edge)::file>:
   19020:	614c 4762 4950 2e4f 7063 0070               LabGPIO.cpp.

0001902c <LabGPIO::IntEdge(LabGPIO::Edge)::__PRETTY_FUNCTION__>:
   1902c:	6f76 6469 4c20 6261 5047 4f49 3a3a 6e49     void LabGPIO::In
   1903c:	4574 6764 2865 614c 4762 4950 3a4f 453a     tEdge(LabGPIO::E
   1904c:	6764 2965 ff00 ffff                         dge)....

00019054 <LabGPIO::ClrEdge(LabGPIO::Edge)::__PRETTY_FUNCTION__>:
   19054:	6f76 6469 4c20 6261 5047 4f49 3a3a 6c43     void LabGPIO::Cl
   19064:	4572 6764 2865 614c 4762 4950 3a4f 453a     rEdge(LabGPIO::E
   19074:	6764 2965 ff00 ffff                         dge)....

0001907c <main::file>:
   1907c:	616d 6e69 632e 7070 ff00 ffff 5b1b 3234     main.cpp.....[42
   1908c:	206d 2020 4920 464e 1b4f 305b 393b 6d34     m    INFO.[0;94m
   1909c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   190ac:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   190bc:	7453 7261 1b74 305b 0a6d 0000 0074 0000     Start.[0m...t...
   190cc:	5b1b 3234 206d 2020 4920 464e 1b4f 305b     .[42m    INFO.[0
   190dc:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   190ec:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   190fc:	333b 6d37 6e49 7420 6568 6920 746e 7265     ;37mIn the inter
   1910c:	7572 7470 5b1b 6d30 000a 0000 5b1b 3234     rupt.[0m.....[42
   1911c:	206d 2020 4920 464e 1b4f 305b 393b 6d34     m    INFO.[0;94m
   1912c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1913c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1914c:	6e49 7420 6568 7320 6365 6e6f 2064 6e69     In the second in
   1915c:	6574 7272 7075 0a74 5b1b 6d30 000a 0000     terrupt..[0m....
   1916c:	5b1b 3234 206d 2020 4920 464e 1b4f 305b     .[42m    INFO.[0
   1917c:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1918c:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1919c:	333b 6d37 6553 616d 6870 726f 2065 6552     ;37mSemaphore Re
   191ac:	6963 7665 6465 1b0a 305b 0a6d 0000 0000     cieved..[0m.....
   191bc:	5b1b 3234 206d 2020 4920 464e 1b4f 305b     .[42m    INFO.[0
   191cc:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   191dc:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   191ec:	333b 6d37 6e49 6574 7272 7075 2074 2031     ;37mInterrupt 1 
   191fc:	6f4e 2074 6552 6963 7665 6465 1b0a 305b     Not Recieved..[0
   1920c:	0a6d 0000 5b1b 3234 206d 2020 4920 464e     m....[42m    INF
   1921c:	1b4f 305b 393b 6d34 253a 3a73 5b1b 3b30     O.[0;94m:%s:.[0;
   1922c:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1923c:	1b20 305b 333b 6d37 6553 616d 6870 726f      .[0;37mSemaphor
   1924c:	2065 2032 6552 6963 7665 6465 1b0a 305b     e 2 Recieved..[0
   1925c:	0a6d 0000 5b1b 3234 206d 2020 4920 464e     m....[42m    INF
   1926c:	1b4f 305b 393b 6d34 253a 3a73 5b1b 3b30     O.[0;94m:%s:.[0;
   1927c:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1928c:	1b20 305b 333b 6d37 6e49 6574 7272 7075      .[0;37mInterrup
   1929c:	2074 2032 6f4e 2074 6552 6963 7665 6465     t 2 Not Recieved
   192ac:	1b0a 305b 0a6d ff00                         ..[0m...

000192b4 <isr_toggle()::file>:
   192b4:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

000192c0 <isr_toggle2()::file>:
   192c0:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

000192cc <led_task(void*)::file>:
   192cc:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

000192d8 <led_task(void*)::file>:
   192d8:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

000192e4 <led_task(void*)::file>:
   192e4:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

000192f0 <led_task(void*)::file>:
   192f0:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

000192fc <main::__PRETTY_FUNCTION__>:
   192fc:	6e69 2074 616d 6e69 2928 ff00               int main()..

00019308 <isr_toggle()::__PRETTY_FUNCTION__>:
   19308:	6f76 6469 6920 7273 745f 676f 6c67 2865     void isr_toggle(
   19318:	0029 ffff                                   )...

0001931c <isr_toggle2()::__PRETTY_FUNCTION__>:
   1931c:	6f76 6469 6920 7273 745f 676f 6c67 3265     void isr_toggle2
   1932c:	2928 ff00                                   ()..

00019330 <led_task(void*)::__PRETTY_FUNCTION__>:
   19330:	6f76 6469 6c20 6465 745f 7361 286b 6f76     void led_task(vo
   19340:	6469 292a ff00 ffff 7453 6361 206b 6544     id*)....Stack De
   19350:	7470 2068 203d 7a25 0a64 0000 2020 2523     pth = %zd...  #%
   19360:	757a 203a 7830 7025 000a 0000 520a 6e75     zu: 0x%p.....Run
   19370:	203a 6874 2065 6f66 6c6c 776f 6e69 2067     : the following 
   19380:	6f63 6d6d 6e61 2064 6e69 7920 756f 2072     command in your 
   19390:	7270 6a6f 6365 2074 6964 6572 7463 726f     project director
   193a0:	0079 0000 200a 1b20 315b 333b 6d37 616d     y....  .[1;37mma
   193b0:	656b 7320 6174 6b63 7274 6361 2d65 7325     ke stacktrace-%s
   193c0:	5420 4152 4543 3d53 0022 0000 7830 7025      TRACES="...0x%p
   193d0:	0000 0000 3020 2578 0070 0000 0a22 5b1b     .... 0x%p..."..[
   193e0:	6d30 0000 6854 7369 7720 6c69 206c 6572     0m..This will re
   193f0:	6f70 7472 7420 6568 6620 6c69 2065 6e61     port the file an
   19400:	2064 696c 656e 6e20 6d75 6562 2072 6874     d line number th
   19410:	7461 6c20 6465 7420 206f 6874 7369 6620     at led to this f
   19420:	6e75 7463 6f69 206e 6562 6e69 2067 6163     unction being ca
   19430:	6c6c 6465 002e 0000 7061 6c70 6369 7461     lled....applicat
   19440:	6f69 006e 5b1b 3134 436d 4952 4954 4143     ion..[41mCRITICA
   19450:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   19460:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   19470:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   19480:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   19490:	6974 6e6f 5420 7365 6574 3a64 2820 6570     tion Tested: (pe
   194a0:	6972 6870 7265 6c61 645f 7669 6469 7265     ripheral_divider
   194b0:	3c20 203d 2934 200a 2020 2020 2020 2020      <= 4).         
   194c0:	4420 7669 6469 7265 6d20 7375 6e74 7427      Divider mustn't
   194d0:	6520 6378 6565 2064 3233 5b1b 6d30 5b1b      exceed 32.[0m.[
   194e0:	6d30 000a 500a 6972 746e 6e69 2067 7453     0m...Printing St
   194f0:	6361 206b 7254 6361 3a65 000a 5b1b 3134     ack Trace:...[41
   19500:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   19510:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   19520:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   19530:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   19540:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   19550:	6574 3a64 2820 6564 6973 6572 5f64 7073     ted: (desired_sp
   19560:	6565 5f64 6e69 6d5f 7a68 3c20 3320 3438     eed_in_mhz < 384
   19570:	2620 2026 6564 6973 6572 5f64 7073 6565      && desired_spee
   19580:	5f64 6e69 6d5f 7a68 3e20 3120 2932 200a     d_in_mhz > 12). 
   19590:	2020 2020 2020 2020 4620 6572 7571 6e65              Frequen
   195a0:	7963 6d20 7375 2074 6562 6c20 776f 7265     cy must be lower
   195b0:	7420 6168 206e 3833 2034 484d 617a 646e      than 384 MHzand
   195c0:	6720 6572 7461 7265 7420 6168 206e 726f      greater than or
   195d0:	6520 7571 6c61 7420 206f 3231 4d20 7a48      equal to 12 MHz
   195e0:	5b1b 6d30 5b1b 6d30 000a 0000 5b1b 3134     .[0m.[0m.....[41
   195f0:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   19600:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   19610:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   19620:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   19630:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   19640:	6574 3a64 2820 6964 6976 6564 5f72 6176     ted: (divider_va
   19650:	756c 2065 203c 2938 200a 2020 2020 2020     lue < 8).       
   19660:	2020 5020 4c4c 6420 7669 6469 7265 7620        PLL divider v
   19670:	6c61 6575 7720 6e65 2074 756f 2074 666f     alue went out of
   19680:	6220 756f 646e 1b73 305b 1b6d 305b 0a6d      bounds.[0m.[0m.
   19690:	0000 0000 5b1b 3134 436d 4952 4954 4143     .....[41mCRITICA
   196a0:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   196b0:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   196c0:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   196d0:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   196e0:	6974 6e6f 5420 7365 6574 3a64 2820 6166     tion Tested: (fa
   196f0:	736c 2965 200a 2020 2020 2020 2020 5020     lse).          P
   19700:	4c4c 6c20 636f 206b 6f63 6c75 2064 6f6e     LL lock could no
   19710:	2074 6562 6520 7473 6261 696c 6873 6465     t be established
   19720:	6220 6665 726f 2065 6974 656d 756f 1b74      before timeout.
   19730:	305b 1b6d 305b 0a6d 0000 0000 5b1b 3134     [0m.[0m......[41
   19740:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   19750:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   19760:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   19770:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   19780:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   19790:	6574 3a64 2820 7063 5f75 6964 6976 6564     ted: (cpu_divide
   197a0:	2072 203c 3233 0a29 2020 2020 2020 2020     r < 32).        
   197b0:	2020 6944 6976 6564 2072 756d 7473 276e       Divider mustn'
   197c0:	2074 7865 6563 6465 3320 1b32 305b 1b6d     t exceed 32.[0m.
   197d0:	305b 0a6d 0000 0000 5b1b 3134 436d 4952     [0m......[41mCRI
   197e0:	4954 4143 1b4c 305b 393b 6d34 253a 3a73     TICAL.[0;94m:%s:
   197f0:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   19800:	256d 3e64 1b20 305b 333b 6d37 7341 6573     m%d> .[0;37mAsse
   19810:	7472 6f69 206e 6146 6c69 7275 2c65 4320     rtion Failure, C
   19820:	6e6f 6964 6974 6e6f 5420 7365 6574 3a64     ondition Tested:
   19830:	2820 7266 7165 6575 636e 2079 3d21 3020      (frequency != 0
   19840:	0a29 2020 2020 2020 2020 2020 6143 6e6e     ).          Cann
   19850:	746f 6820 7661 2065 657a 6f72 7420 6369     ot have zero tic
   19860:	736b 7020 7265 6d20 6369 6f72 6573 6f63     ks per microseco
   19870:	646e 202c 6c70 6165 6573 6320 6f68 736f     nd, please choos
   19880:	2065 2031 726f 6d20 726f 2e65 5b1b 6d30     e 1 or more..[0m
   19890:	5b1b 6d30 000a 0000 5b1b 3334 206d 4157     .[0m.....[43m WA
   198a0:	4e52 4e49 1b47 305b 393b 6d34 253a 3a73     RNING.[0;94m:%s:
   198b0:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   198c0:	256d 3e64 1b20 305b 333b 6d37 7953 7473     m%d> .[0;37mSyst
   198d0:	6d65 5420 6d69 7265 6820 7361 4620 4941     em Timer has FAI
   198e0:	454c 2044 6f74 7320 6174 7472 1b21 305b     LED to start!.[0
   198f0:	1b6d 305b 0a6d ff00                         m.[0m...

000198f8 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file>:
   198f8:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   19908:	2e72 7068 0070 ffff                         r.hpp...

00019910 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   19910:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   19920:	2e72 7068 0070 ffff                         r.hpp...

00019928 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   19928:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   19938:	2e72 7068 0070 ffff                         r.hpp...

00019940 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   19940:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   19950:	2e72 7068 0070 ffff                         r.hpp...

00019958 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file>:
   19958:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   19968:	2e72 7068 0070 ffff                         r.hpp...

00019970 <Timer::kPowerbit>:
   19970:	0001 0000 0002 0000 0016 0000 0017 0000     ................

00019980 <Timer::kTimerIrq>:
   19980:	0201 0403                                   ....

00019984 <Timer::kTimerIsr>:
   19984:	2c11 0001 2c4d 0001 2c89 0001 2cc5 0001     .,..M,...,...,..

00019994 <Timer::Initialize(unsigned long, void (*)(), long)::file>:
   19994:	6974 656d 2e72 7068 0070 ffff               timer.hpp...

000199a0 <Uart::kTxUartPortFunction>:
   199a0:	0201 0502                                   ....

000199a4 <Uart::kRxUartPortFunction>:
   199a4:	0201 0302                                   ....

000199a8 <Uart::kPowerbit>:
   199a8:	0003 0000 0018 0000 0019 0000 0008 0000     ................

000199b8 <LowLevelInit()::file>:
   199b8:	7473 7261 7574 2e70 7063 0070               startup.cpp.

000199c4 <vtable for Uart>:
	...
   199cc:	217d 0001 2249 0001 2379 0001 24ad 0001     }!..I"..y#...$..
   199dc:	fffc ffff 0000 0000 1151 0001 11e1 0001     ........Q.......
   199ec:	1239 0001 1251 0001 1265 0001 12a5 0001     9...Q...e.......
   199fc:	12d5 0001                                   ....

00019a00 <vtable for Timer>:
	...
   19a08:	1ee5 0001 2049 0001 2141 0001 fffc ffff     ....I ..A!......
   19a18:	0000 0000 1151 0001 11e1 0001 1239 0001     ....Q.......9...
   19a28:	1251 0001 1265 0001 12a5 0001 12d5 0001     Q...e...........

00019a38 <vtable for Pin>:
	...
   19a40:	18b5 0001 192d 0001 19ad 0001 1a21 0001     ....-.......!...
   19a50:	1a95 0001 1b11 0001 1b8d 0001 1c01 0001     ................
   19a60:	1c7d 0001 1cf1 0001 1d65 0001 1e3d 0001     }.......e...=...
   19a70:	1e69 0001                                   i...

00019a74 <vtable for SystemTimer>:
	...
   19a7c:	1751 0001 1785 0001 1821 0001 fffc ffff     Q.......!.......
   19a8c:	0000 0000 1151 0001 11e1 0001 1239 0001     ....Q.......9...
   19a9c:	1251 0001 1265 0001 12a5 0001 12d5 0001     Q...e...........

00019aac <vtable for Lpc40xxSystemController>:
	...
   19ab4:	1151 0001 11e1 0001 1239 0001 1251 0001     Q.......9...Q...
   19ac4:	1265 0001 12a5 0001 12d5 0001               e...........

00019ad0 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   19ad0:	6976 7472 6175 206c 6f76 6469 4c20 6370     virtual void Lpc
   19ae0:	3034 7878 7953 7473 6d65 6f43 746e 6f72     40xxSystemContro
   19af0:	6c6c 7265 3a3a 6553 5074 7265 7069 6568     ller::SetPeriphe
   19b00:	6172 436c 6f6c 6b63 6944 6976 6564 2872     ralClockDivider(
   19b10:	6975 746e 5f38 2974 ff00 ffff               uint8_t)....

00019b1c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   19b1c:	6975 746e 3233 745f 4c20 6370 3034 7878     uint32_t Lpc40xx
   19b2c:	7953 7473 6d65 6f43 746e 6f72 6c6c 7265     SystemController
   19b3c:	3a3a 6553 4d74 6961 506e 6c6c 4c28 6370     ::SetMainPll(Lpc
   19b4c:	3034 7878 7953 7473 6d65 6f43 746e 6f72     40xxSystemContro
   19b5c:	6c6c 7265 3a3a 6c50 496c 706e 7475 202c     ller::PllInput, 
   19b6c:	6975 746e 3631 745f 0029 ffff               uint16_t)...

00019b78 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   19b78:	6975 746e 3233 745f 4c20 6370 3034 7878     uint32_t Lpc40xx
   19b88:	7953 7473 6d65 6f43 746e 6f72 6c6c 7265     SystemController
   19b98:	3a3a 6143 636c 6c75 7461 5065 6c6c 4c28     ::CalculatePll(L
   19ba8:	6370 3034 7878 7953 7473 6d65 6f43 746e     pc40xxSystemCont
   19bb8:	6f72 6c6c 7265 3a3a 6c50 496c 706e 7475     roller::PllInput
   19bc8:	202c 6975 746e 3631 745f 0029               , uint16_t).

00019bd4 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   19bd4:	6f76 6469 4c20 6370 3034 7878 7953 7473     void Lpc40xxSyst
   19be4:	6d65 6f43 746e 6f72 6c6c 7265 3a3a 6553     emController::Se
   19bf4:	4374 7570 6c43 636f 446b 7669 6469 7265     tCpuClockDivider
   19c04:	7528 6e69 3874 745f 0029 ffff               (uint8_t)...

00019c10 <Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__>:
   19c10:	6976 7472 6175 206c 6f76 6469 5420 6d69     virtual void Tim
   19c20:	7265 3a3a 6e49 7469 6169 696c 657a 7528     er::Initialize(u
   19c30:	6e69 3374 5f32 2c74 4920 7273 6f50 6e69     int32_t, IsrPoin
   19c40:	6574 2c72 6920 746e 3233 745f 0029 ffff     ter, int32_t)...

00019c50 <LowLevelInit()::__PRETTY_FUNCTION__>:
   19c50:	6f76 6469 4c20 776f 654c 6576 496c 696e     void LowLevelIni
   19c60:	2874 0029 7453 6361 206b 6544 7470 2068     t().Stack Depth 
   19c70:	203d 7a25 0a64 0000 2020 2523 757a 203a     = %zd...  #%zu: 
   19c80:	7830 7025 000a 0000 520a 6e75 203a 6874     0x%p.....Run: th
   19c90:	2065 6f66 6c6c 776f 6e69 2067 6f63 6d6d     e following comm
   19ca0:	6e61 2064 6e69 7920 756f 2072 7270 6a6f     and in your proj
   19cb0:	6365 2074 6964 6572 7463 726f 0079 0000     ect directory...
   19cc0:	200a 1b20 315b 333b 6d37 616d 656b 7320     .  .[1;37mmake s
   19cd0:	6174 6b63 7274 6361 2d65 7325 5420 4152     tacktrace-%s TRA
   19ce0:	4543 3d53 0022 0000 7830 7025 0000 0000     CES="...0x%p....
   19cf0:	3020 2578 0070 0000 0a22 5b1b 6d30 0000      0x%p..."..[0m..
   19d00:	6854 7369 7720 6c69 206c 6572 6f70 7472     This will report
   19d10:	7420 6568 6620 6c69 2065 6e61 2064 696c      the file and li
   19d20:	656e 6e20 6d75 6562 2072 6874 7461 6c20     ne number that l
   19d30:	6465 7420 206f 6874 7369 6620 6e75 7463     ed to this funct
   19d40:	6f69 206e 6562 6e69 2067 6163 6c6c 6465     ion being called
   19d50:	002e 0000 7061 6c70 6369 7461 6f69 006e     ....application.
   19d60:	5b1b 3134 436d 4952 4954 4143 1b4c 305b     .[41mCRITICAL.[0
   19d70:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   19d80:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   19d90:	333b 6d37 7341 6573 7472 6f69 206e 6146     ;37mAssertion Fa
   19da0:	6c69 7275 2c65 4320 6e6f 6964 6974 6e6f     ilure, Condition
   19db0:	5420 7365 6574 3a64 2820 7369 2072 3d21      Tested: (isr !=
   19dc0:	4920 746e 7265 7572 7470 6f4c 6b6f 7075      InterruptLookup
   19dd0:	6148 646e 656c 2972 200a 2020 2020 2020     Handler).       
   19de0:	2020 4e20 206f 5349 2052 6f66 6e75 2064        No ISR found 
   19df0:	6f66 2072 6874 2065 6576 7463 726f 2520     for the vector %
   19e00:	1b75 305b 1b6d 305b 0a6d 0000 500a 6972     u.[0m.[0m....Pri
   19e10:	746e 6e69 2067 7453 6361 206b 7254 6361     nting Stack Trac
   19e20:	3a65 000a 5b1b 3134 486d 7261 2064 6146     e:...[41mHard Fa
   19e30:	6c75 2074 7845 6563 7470 6f69 206e 634f     ult Exception Oc
   19e40:	7563 7272 6465 0a21 5b1b 6d30 0000 0000     curred!..[0m....
   19e50:	3072 203a 7830 3025 6c38 2c58 7220 3a31     r0: 0x%08lX, r1:
   19e60:	3020 2578 3830 586c 202c 3272 203a 7830      0x%08lX, r2: 0x
   19e70:	3025 6c38 2c58 7220 3a33 3020 2578 3830     %08lX, r3: 0x%08
   19e80:	586c 000a 3172 3a32 3020 2578 3830 586c     lX..r12: 0x%08lX
   19e90:	202c 726c 203a 7830 3025 6c38 2c58 7020     , lr: 0x%08lX, p
   19ea0:	3a63 3020 2578 3830 586c 202c 7370 3a72     c: 0x%08lX, psr:
   19eb0:	3020 2578 3830 586c 000a ffff                0x%08lX....

00019ebc <InterruptLookupHandler::file>:
   19ebc:	6e69 6574 7272 7075 2e74 7063 0070 ffff     interrupt.cpp...

00019ecc <InterruptLookupHandler::__PRETTY_FUNCTION__>:
   19ecc:	6f76 6469 4920 746e 7265 7572 7470 6f4c     void InterruptLo
   19edc:	6b6f 7075 6148 646e 656c 2872 0029 ffff     okupHandler()...
   19eec:	4449 454c 0000 0000 2509 0963 7525 2509     IDLE.....%c.%u.%
   19efc:	0975 7525 0a0d 0000 2509 0975 2509 2575     u.%u.....%u..%u%
   19f0c:	0d25 000a 2509 0975 3c09 2531 0d25 000a     %....%u..<1%%...

00019f1c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10>:
   19f1c:	0000 3f80 0000 4120 0000 42c8 0000 447a     ...?.. A...B..zD
   19f2c:	4000 461c 5000 47c3 2400 4974 9680 4b18     .@.F.P.G.$tI...K
   19f3c:	bc20 4cbe 6b28 4e6e 7453 6361 206b 6544      ..L(knNStack De
   19f4c:	7470 2068 203d 7a25 0a64 0000 2020 2523     pth = %zd...  #%
   19f5c:	757a 203a 7830 7025 000a 0000 520a 6e75     zu: 0x%p.....Run
   19f6c:	203a 6874 2065 6f66 6c6c 776f 6e69 2067     : the following 
   19f7c:	6f63 6d6d 6e61 2064 6e69 7920 756f 2072     command in your 
   19f8c:	7270 6a6f 6365 2074 6964 6572 7463 726f     project director
   19f9c:	0079 0000 200a 1b20 315b 333b 6d37 616d     y....  .[1;37mma
   19fac:	656b 7320 6174 6b63 7274 6361 2d65 7325     ke stacktrace-%s
   19fbc:	5420 4152 4543 3d53 0022 0000 7830 7025      TRACES="...0x%p
   19fcc:	0000 0000 3020 2578 0070 0000 0a22 5b1b     .... 0x%p..."..[
   19fdc:	6d30 0000 6854 7369 7720 6c69 206c 6572     0m..This will re
   19fec:	6f70 7472 7420 6568 6620 6c69 2065 6e61     port the file an
   19ffc:	2064 696c 656e 6e20 6d75 6562 2072 6874     d line number th
   1a00c:	7461 6c20 6465 7420 206f 6874 7369 6620     at led to this f
   1a01c:	6e75 7463 6f69 206e 6562 6e69 2067 6163     unction being ca
   1a02c:	6c6c 6465 002e 0000 7061 6c70 6369 7461     lled....applicat
   1a03c:	6f69 006e 5b1b 3334 206d 4157 4e52 4e49     ion..[43m WARNIN
   1a04c:	1b47 305b 393b 6d34 253a 3a73 5b1b 3b30     G.[0;94m:%s:.[0;
   1a05c:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a06c:	1b20 305b 333b 6d37 6f50 7472 2520 2064      .[0;37mPort %d 
   1a07c:	6163 6e6e 746f 6220 2065 7375 6465 6620     cannot be used f
   1a08c:	726f 4520 7478 7265 616e 206c 6e49 6574     or External Inte
   1a09c:	7272 7075 7374 202e 654e 6465 7420 206f     rrupts. Need to 
   1a0ac:	7375 2065 5047 4f49 6f20 206e 6f50 7472     use GPIO on Port
   1a0bc:	3020 6f20 2072 2e32 5b1b 6d30 5b1b 6d30      0 or 2..[0m.[0m
   1a0cc:	000a 0000 5b1b 3334 206d 4157 4e52 4e49     .....[43m WARNIN
   1a0dc:	1b47 305b 393b 6d34 253a 3a73 5b1b 3b30     G.[0;94m:%s:.[0;
   1a0ec:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a0fc:	1b20 305b 333b 6d37 6445 6567 2520 2064      .[0;37mEdge %d 
   1a10c:	6163 6e6e 746f 6220 2065 7375 6465 6620     cannot be used f
   1a11c:	726f 4520 7478 7265 616e 206c 6e49 6574     or External Inte
   1a12c:	7272 7075 7374 4e2e 6565 2064 6f74 7520     rrupts.Need to u
   1a13c:	6573 6120 7220 7369 6e69 2c67 6620 6c61     se a rising, fal
   1a14c:	696c 676e 202c 726f 6220 746f 2068 6f63     ling, or both co
   1a15c:	666e 6769 7275 7461 6f69 2e6e 5b1b 6d30     nfiguration..[0m
   1a16c:	000a 0000 5b1b 3134 436d 4952 4954 4143     .....[41mCRITICA
   1a17c:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   1a18c:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a19c:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   1a1ac:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   1a1bc:	6974 6e6f 5420 7365 6574 3a64 2820 6570     tion Tested: (pe
   1a1cc:	6972 6870 7265 6c61 645f 7669 6469 7265     ripheral_divider
   1a1dc:	3c20 203d 2934 200a 2020 2020 2020 2020      <= 4).         
   1a1ec:	4420 7669 6469 7265 6d20 7375 6e74 7427      Divider mustn't
   1a1fc:	6520 6378 6565 2064 3233 5b1b 6d30 5b1b      exceed 32.[0m.[
   1a20c:	6d30 000a 500a 6972 746e 6e69 2067 7453     0m...Printing St
   1a21c:	6361 206b 7254 6361 3a65 000a 5b1b 3134     ack Trace:...[41
   1a22c:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   1a23c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a24c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a25c:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   1a26c:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   1a27c:	6574 3a64 2820 6564 6973 6572 5f64 7073     ted: (desired_sp
   1a28c:	6565 5f64 6e69 6d5f 7a68 3c20 3320 3438     eed_in_mhz < 384
   1a29c:	2620 2026 6564 6973 6572 5f64 7073 6565      && desired_spee
   1a2ac:	5f64 6e69 6d5f 7a68 3e20 3120 2932 200a     d_in_mhz > 12). 
   1a2bc:	2020 2020 2020 2020 4620 6572 7571 6e65              Frequen
   1a2cc:	7963 6d20 7375 2074 6562 6c20 776f 7265     cy must be lower
   1a2dc:	7420 6168 206e 3833 2034 484d 617a 646e      than 384 MHzand
   1a2ec:	6720 6572 7461 7265 7420 6168 206e 726f      greater than or
   1a2fc:	6520 7571 6c61 7420 206f 3231 4d20 7a48      equal to 12 MHz
   1a30c:	5b1b 6d30 5b1b 6d30 000a 0000 5b1b 3134     .[0m.[0m.....[41
   1a31c:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   1a32c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a33c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a34c:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   1a35c:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   1a36c:	6574 3a64 2820 6964 6976 6564 5f72 6176     ted: (divider_va
   1a37c:	756c 2065 203c 2938 200a 2020 2020 2020     lue < 8).       
   1a38c:	2020 5020 4c4c 6420 7669 6469 7265 7620        PLL divider v
   1a39c:	6c61 6575 7720 6e65 2074 756f 2074 666f     alue went out of
   1a3ac:	6220 756f 646e 1b73 305b 1b6d 305b 0a6d      bounds.[0m.[0m.
   1a3bc:	0000 0000 5b1b 3134 436d 4952 4954 4143     .....[41mCRITICA
   1a3cc:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   1a3dc:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a3ec:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   1a3fc:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   1a40c:	6974 6e6f 5420 7365 6574 3a64 2820 6166     tion Tested: (fa
   1a41c:	736c 2965 200a 2020 2020 2020 2020 5020     lse).          P
   1a42c:	4c4c 6c20 636f 206b 6f63 6c75 2064 6f6e     LL lock could no
   1a43c:	2074 6562 6520 7473 6261 696c 6873 6465     t be established
   1a44c:	6220 6665 726f 2065 6974 656d 756f 1b74      before timeout.
   1a45c:	305b 1b6d 305b 0a6d 0000 0000 5b1b 3134     [0m.[0m......[41
   1a46c:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   1a47c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a48c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a49c:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   1a4ac:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   1a4bc:	6574 3a64 2820 7063 5f75 6964 6976 6564     ted: (cpu_divide
   1a4cc:	2072 203c 3233 0a29 2020 2020 2020 2020     r < 32).        
   1a4dc:	2020 6944 6976 6564 2072 756d 7473 276e       Divider mustn'
   1a4ec:	2074 7865 6563 6465 3320 1b32 305b 1b6d     t exceed 32.[0m.
   1a4fc:	305b 0a6d 0000 0000 5b1b 3534 206d 2020     [0m......[45m   
   1a50c:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a51c:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a52c:	256d 3e64 1b20 305b 333b 6d37 6146 6c69     m%d> .[0;37mFail
   1a53c:	6465 7420 206f 6e69 7469 6169 6574 5320     ed to initiate S
   1a54c:	4950 6d20 646f 2065 6977 6874 6e69 7420     PI mode within t
   1a55c:	6d69 6f65 7475 202e 6241 726f 6974 676e     imeout. Aborting
   1a56c:	1b21 305b 0a6d 0000 5b1b 3534 206d 2020     !.[0m....[45m   
   1a57c:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a58c:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a59c:	256d 3e64 1b20 305b 333b 6d37 6552 7073     m%d> .[0;37mResp
   1a5ac:	6e6f 6573 6920 746e 6765 6972 7974 6320     onse integrity c
   1a5bc:	6568 6b63 6620 6961 656c 2e64 4120 6f62     heck failed. Abo
   1a5cc:	7472 6e69 2167 5b1b 6d30 000a 5b1b 3534     rting!.[0m...[45
   1a5dc:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a5ec:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a5fc:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a60c:	6e55 7573 7070 726f 6574 2064 6f76 746c     Unsupported volt
   1a61c:	6761 2065 6e69 7520 6573 202e 6241 726f     age in use. Abor
   1a62c:	6974 676e 1b21 305b 0a6d 0000 5b1b 3534     ting!.[0m....[45
   1a63c:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a64c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a65c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a66c:	4453 4320 7261 2064 6974 656d 2064 756f     SD Card timed ou
   1a67c:	2e74 4120 6f62 7472 6e69 2167 5b1b 6d30     t. Aborting!.[0m
   1a68c:	000a 0000 7274 6575 0000 0000 6166 736c     ....true....fals
   1a69c:	0065 0000 5b1b 3534 206d 2020 5245 4f52     e....[45m   ERRO
   1a6ac:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1a6bc:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a6cc:	1b20 305b 333b 6d37 6857 6c69 2065 6552      .[0;37mWhile Re
   1a6dc:	6461 6e69 2067 6c42 636f 206b 2523 2064     ading Block #%d 
   1a6ec:	5243 3143 3a36 5b1b 6d30 000a 5b1b 3534     CRC16:.[0m...[45
   1a6fc:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a70c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a71c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a72c:	7845 6570 7463 6465 2720 7830 3025 5834     Expected '0x%04X
   1a73c:	1b27 305b 0a6d 0000 5b1b 3534 206d 2020     '.[0m....[45m   
   1a74c:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a75c:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a76c:	256d 3e64 1b20 305b 333b 6d37 6f47 2074     m%d> .[0;37mGot 
   1a77c:	3027 2578 3430 2758 5b1b 6d30 000a 0000     '0x%04X'.[0m....
   1a78c:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a79c:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a7ac:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a7bc:	333b 6d37 6552 6461 4320 646d 7720 7361     ;37mRead Cmd was
   1a7cc:	6e20 746f 6120 6b63 6f6e 6c77 6465 6567      not acknowledge
   1a7dc:	2064 7270 706f 7265 796c 1b21 305b 0a6d     d properly!.[0m.
   1a7ec:	0000 0000 5b1b 3534 206d 2020 5245 4f52     .....[45m   ERRO
   1a7fc:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1a80c:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a81c:	1b20 305b 333b 6d37 6150 6172 656d 6574      .[0;37mParamete
   1a82c:	2072 7245 3a72 2520 1b73 305b 0a6d 0000     r Err: %s.[0m...
   1a83c:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a84c:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a85c:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a86c:	333b 6d37 6441 7264 4520 7272 203a 7325     ;37mAddr Err: %s
   1a87c:	5b1b 6d30 000a 0000 5b1b 3534 206d 2020     .[0m.....[45m   
   1a88c:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a89c:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a8ac:	256d 3e64 1b20 305b 333b 6d37 7245 7361     m%d> .[0;37mEras
   1a8bc:	2065 6553 2071 7245 3a72 2520 1b73 305b     e Seq Err: %s.[0
   1a8cc:	0a6d 0000 5b1b 3534 206d 2020 5245 4f52     m....[45m   ERRO
   1a8dc:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1a8ec:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a8fc:	1b20 305b 333b 6d37 6f43 206d 5243 2043      .[0;37mCom CRC 
   1a90c:	7245 3a72 2520 1b73 305b 0a6d 0000 0000     Err: %s.[0m.....
   1a91c:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a92c:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a93c:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a94c:	333b 6d37 6c49 656c 6167 206c 6d43 2064     ;37mIllegal Cmd 
   1a95c:	7245 3a72 2520 1b73 305b 0a6d 0000 0000     Err: %s.[0m.....
   1a96c:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a97c:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a98c:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a99c:	333b 6d37 7245 7361 2065 6552 6573 3a74     ;37mErase Reset:
   1a9ac:	2520 1b73 305b 0a6d 0000 0000 5b1b 3534      %s.[0m......[45
   1a9bc:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a9cc:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a9dc:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a9ec:	6e49 4920 6c64 3a65 2520 1b73 305b 0a6d     In Idle: %s.[0m.
   1a9fc:	0000 0000 5b1b 3534 206d 2020 5245 4f52     .....[45m   ERRO
   1aa0c:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1aa1c:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1aa2c:	1b20 305b 333b 6d37 6146 6c69 6465 7420      .[0;37mFailed t
   1aa3c:	206f 6573 2074 7453 7261 2074 6441 7264     o set Start Addr
   1aa4c:	7365 2173 5b1b 6d30 000a 0000 5b1b 3534     ess!.[0m.....[45
   1aa5c:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1aa6c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1aa7c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1aa8c:	6146 6c69 6465 7420 206f 6573 2074 6e45     Failed to set En
   1aa9c:	2064 6441 7264 7365 2173 5b1b 6d30 000a     d Address!.[0m..
   1aaac:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1aabc:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1aacc:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1aadc:	333b 6d37 6e55 6e6b 776f 206e 6572 7073     ;37mUnknown resp
   1aaec:	6e6f 6573 7420 7079 2e65 4120 6f62 7472     onse type. Abort
   1aafc:	6e69 2167 5b1b 6d30 000a 0000 5b1b 3534     ing!.[0m.....[45
   1ab0c:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1ab1c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1ab2c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1ab3c:	6552 7073 6e6f 6573 7520 736e 7075 6f70     Response unsuppo
   1ab4c:	7472 6465 6920 206e 5053 2049 6f6d 6564     rted in SPI mode
   1ab5c:	202e 6241 726f 6974 676e 1b21 305b 0a6d     . Aborting!.[0m.
   1ab6c:	ff00 ffff                                   ....

0001ab70 <Gpio::ValidPortCheck()::file>:
   1ab70:	7067 6f69 682e 7070 ff00 ffff               gpio.hpp....

0001ab7c <Gpio::SetInterruptEdge(GpioInterface::Edge)::file>:
   1ab7c:	7067 6f69 682e 7070 ff00 ffff               gpio.hpp....

0001ab88 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::file>:
   1ab88:	7067 6f69 682e 7070 ff00 ffff               gpio.hpp....

0001ab94 <Ssp::kPinSelect>:
   1ab94:	0202 ff04                                   ....

0001ab98 <Ssp::kSspPinMatrix>:
   1ab98:	9a40 0001 1200 0000 9a40 0001 1100 0000     @.......@.......
   1aba8:	9a40 0001 0f00 0000 9a40 0001 0900 0000     @.......@.......
   1abb8:	9a40 0001 0800 0000 9a40 0001 0700 0000     @.......@.......
   1abc8:	9a40 0001 0101 0000 9a40 0001 0401 0000     @.......@.......
   1abd8:	9a40 0001 0001 0000                         @.......

0001abe0 <Ssp::kPowerBit>:
   1abe0:	0015 0000 000a 0000 0014 0000               ............

0001abec <Sd::kCrcTable8>:
   1abec:	0900 1b12 2d24 3f36 4148 535a 656c 777e     ....$-6?HAZSle~w
   1abfc:	1019 020b 343d 262f 5851 4a43 7c75 6e67     ....=4/&QXCJu|gn
   1ac0c:	3b32 2920 1f16 0d04 737a 6168 575e 454c     2; )....zsha^WLE
   1ac1c:	222b 3039 060f 141d 6a63 7871 4e47 5c55     +"90....cjqxGNU\
   1ac2c:	6d64 7f76 4940 5b52 252c 373e 0108 131a     dmv.@IR[,%>7....
   1ac3c:	747d 666f 5059 424b 3c35 2e27 1811 0a03     }tofYPKB5<'.....
   1ac4c:	5f56 4d44 7b72 6960 171e 050c 333a 2128     V_DMr{`i....:3(!
   1ac5c:	464f 545d 626b 7079 0e07 1c15 2a23 3831     OF]Tkbyp....#*18
   1ac6c:	4841 5a53 6c65 7e77 0009 121b 242d 363f     AHSZelw~....-$?6
   1ac7c:	5158 434a 757c 676e 1910 0b02 3d34 2f26     XQJC|ung....4=&/
   1ac8c:	7a73 6861 5e57 4c45 323b 2029 161f 040d     szahW^EL;2) ....
   1ac9c:	636a 7178 474e 555c 2b22 3930 0f06 1d14     jcxqNG\U"+09....
   1acac:	2c25 3e37 0801 1a13 646d 767f 4049 525b     %,7>....md.vI@[R
   1acbc:	353c 272e 1118 030a 7d74 6f66 5950 4b42     <5.'....t}foPYBK
   1accc:	1e17 0c05 3a33 2821 565f 444d 727b 6069     ....3:!(_VMD{ri`
   1acdc:	070e 151c 232a 3138 4f46 5d54 6b62 0070     ....*#81FOT]bkp.

0001acec <Sd::kCrcTable16>:
   1acec:	0000 1021 2042 3063 4084 50a5 60c6 70e7     ..!.B c0.@.P.`.p
   1acfc:	8108 9129 a14a b16b c18c d1ad e1ce f1ef     ..).J.k.........
   1ad0c:	1231 0210 3273 2252 52b5 4294 72f7 62d6     1...s2R".R.B.r.b
   1ad1c:	9339 8318 b37b a35a d3bd c39c f3ff e3de     9...{.Z.........
   1ad2c:	2462 3443 0420 1401 64e6 74c7 44a4 5485     b$C4 ....d.t.D.T
   1ad3c:	a56a b54b 8528 9509 e5ee f5cf c5ac d58d     j.K.(...........
   1ad4c:	3653 2672 1611 0630 76d7 66f6 5695 46b4     S6r&..0..v.f.V.F
   1ad5c:	b75b a77a 9719 8738 f7df e7fe d79d c7bc     [.z...8.........
   1ad6c:	48c4 58e5 6886 78a7 0840 1861 2802 3823     .H.X.h.x@.a..(#8
   1ad7c:	c9cc d9ed e98e f9af 8948 9969 a90a b92b     ........H.i...+.
   1ad8c:	5af5 4ad4 7ab7 6a96 1a71 0a50 3a33 2a12     .Z.J.z.jq.P.3:.*
   1ad9c:	dbfd cbdc fbbf eb9e 9b79 8b58 bb3b ab1a     ........y.X.;...
   1adac:	6ca6 7c87 4ce4 5cc5 2c22 3c03 0c60 1c41     .l.|.L.\",.<`.A.
   1adbc:	edae fd8f cdec ddcd ad2a bd0b 8d68 9d49     ........*...h.I.
   1adcc:	7e97 6eb6 5ed5 4ef4 3e13 2e32 1e51 0e70     .~.n.^.N.>2.Q.p.
   1addc:	ff9f efbe dfdd cffc bf1b af3a 9f59 8f78     ..........:.Y.x.
   1adec:	9188 81a9 b1ca a1eb d10c c12d f14e e16f     ..........-.N.o.
   1adfc:	1080 00a1 30c2 20e3 5004 4025 7046 6067     .....0. .P%@Fpg`
   1ae0c:	83b9 9398 a3fb b3da c33d d31c e37f f35e     ........=.....^.
   1ae1c:	02b1 1290 22f3 32d2 4235 5214 6277 7256     .....".25B.RwbVr
   1ae2c:	b5ea a5cb 95a8 8589 f56e e54f d52c c50d     ........n.O.,...
   1ae3c:	34e2 24c3 14a0 0481 7466 6447 5424 4405     .4.$....ftGd$T.D
   1ae4c:	a7db b7fa 8799 97b8 e75f f77e c71d d73c     ........_.~...<.
   1ae5c:	26d3 36f2 0691 16b0 6657 7676 4615 5634     .&.6....Wfvv.F4V
   1ae6c:	d94c c96d f90e e92f 99c8 89e9 b98a a9ab     L.m.../.........
   1ae7c:	5844 4865 7806 6827 18c0 08e1 3882 28a3     DXeH.x'h.....8.(
   1ae8c:	cb7d db5c eb3f fb1e 8bf9 9bd8 abbb bb9a     }.\.?...........
   1ae9c:	4a75 5a54 6a37 7a16 0af1 1ad0 2ab3 3a92     uJTZ7j.z.....*.:
   1aeac:	fd2e ed0f dd6c cd4d bdaa ad8b 9de8 8dc9     ....l.M.........
   1aebc:	7c26 6c07 5c64 4c45 3ca2 2c83 1ce0 0cc1     &|.ld\EL.<.,....
   1aecc:	ef1f ff3e cf5d df7c af9b bfba 8fd9 9ff8     ..>.].|.........
   1aedc:	6e17 7e36 4e55 5e74 2e93 3eb2 0ed1 1ef0     .n6~UNt^...>....

0001aeec <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1aeec:	6473 682e 7070 ff00                         sd.hpp..

0001aef4 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1aef4:	6473 682e 7070 ff00                         sd.hpp..

0001aefc <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1aefc:	6473 682e 7070 ff00                         sd.hpp..

0001af04 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1af04:	6473 682e 7070 ff00                         sd.hpp..

0001af0c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af0c:	6473 682e 7070 ff00                         sd.hpp..

0001af14 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af14:	6473 682e 7070 ff00                         sd.hpp..

0001af1c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af1c:	6473 682e 7070 ff00                         sd.hpp..

0001af24 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af24:	6473 682e 7070 ff00                         sd.hpp..

0001af2c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af2c:	6473 682e 7070 ff00                         sd.hpp..

0001af34 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af34:	6473 682e 7070 ff00                         sd.hpp..

0001af3c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af3c:	6473 682e 7070 ff00                         sd.hpp..

0001af44 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af44:	6473 682e 7070 ff00                         sd.hpp..

0001af4c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af4c:	6473 682e 7070 ff00                         sd.hpp..

0001af54 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af54:	6473 682e 7070 ff00                         sd.hpp..

0001af5c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1af5c:	6473 682e 7070 ff00                         sd.hpp..

0001af64 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1af64:	6473 682e 7070 ff00                         sd.hpp..

0001af6c <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1af6c:	6473 682e 7070 ff00                         sd.hpp..

0001af74 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1af74:	6473 682e 7070 ff00                         sd.hpp..

0001af7c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1af7c:	6473 682e 7070 ff00                         sd.hpp..

0001af84 <vtable for Sd>:
	...
   1af8c:	80bd 0001 7515 0001 75c5 0001 79d9 0001     .....u...u...y..
   1af9c:	7df1 0001 7f9d 0001 855d 0001 85a5 0001     .}......].......
   1afac:	8615 0001                                   ....

0001afb0 <vtable for SdInterface>:
	...
   1afb8:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1afc8:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1afd8:	8901 0001                                   ....

0001afdc <vtable for Ssp>:
	...
   1afe4:	6b95 0001 0b5d 0001 0bd5 0001 6c79 0001     .k..].......yl..
   1aff4:	6d65 0001 6f71 0001 70d1 0001 72bd 0001     em..qo...p...r..
   1b004:	fffc ffff 0000 0000 1151 0001 11e1 0001     ........Q.......
   1b014:	1239 0001 1251 0001 1265 0001 12a5 0001     9...Q...e.......
   1b024:	12d5 0001                                   ....

0001b028 <vtable for SspInterface>:
	...
   1b030:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b040:	8901 0001 8901 0001 8901 0001 8901 0001     ................

0001b050 <vtable for SystemControllerInterface>:
	...
   1b058:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b068:	8901 0001 8901 0001 8901 0001               ............

0001b074 <vtable for Gpio>:
	...
   1b07c:	6215 0001 6291 0001 630d 0001 0a25 0001     .b...b...c..%...
   1b08c:	0a89 0001 0aed 0001 6351 0001 63bd 0001     ........Qc...c..
   1b09c:	6435 0001 64a5 0001 673d 0001 6785 0001     5d...d..=g...g..
   1b0ac:	654d 0001 65a9 0001 662d 0001 66b5 0001     Me...e..-f...f..

0001b0bc <vtable for GpioInterface>:
	...
   1b0c4:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b0d4:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b0e4:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b0f4:	8901 0001 8901 0001 8901 0001 8901 0001     ................

0001b104 <vtable for PinInterface>:
	...
   1b10c:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b11c:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b12c:	8901 0001 8901 0001 8901 0001 8901 0001     ................
   1b13c:	8901 0001                                   ....

0001b140 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1b140:	6976 7472 6175 206c 6f76 6469 4720 6970     virtual void Gpi
   1b150:	3a6f 433a 656c 7261 6e49 6574 7272 7075     o::ClearInterrup
   1b160:	4574 6764 2865 7047 6f69 6e49 6574 6672     tEdge(GpioInterf
   1b170:	6361 3a65 453a 6764 2965 ff00               ace::Edge)..

0001b17c <Gpio::ValidPortCheck()::__PRETTY_FUNCTION__>:
   1b17c:	6f62 6c6f 4720 6970 3a6f 563a 6c61 6469     bool Gpio::Valid
   1b18c:	6f50 7472 6843 6365 286b 0029               PortCheck().

0001b198 <Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1b198:	6976 7472 6175 206c 6f76 6469 4720 6970     virtual void Gpi
   1b1a8:	3a6f 533a 7465 6e49 6574 7272 7075 4574     o::SetInterruptE
   1b1b8:	6764 2865 7047 6f69 6e49 6574 6672 6361     dge(GpioInterfac
   1b1c8:	3a65 453a 6764 2965 ff00 ffff               e::Edge)....

0001b1d4 <Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__>:
   1b1d4:	6976 7472 6175 206c 6f62 6c6f 5320 3a64     virtual bool Sd:
   1b1e4:	4d3a 756f 746e 5328 4964 746e 7265 6166     :Mount(SdInterfa
   1b1f4:	6563 3a3a 6143 6472 6e49 6f66 745f 292a     ce::CardInfo_t*)
   1b204:	ff00 ffff                                   ....

0001b208 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__>:
   1b208:	6976 7472 6175 206c 6975 746e 5f38 2074     virtual uint8_t 
   1b218:	6453 3a3a 6552 6461 6c42 636f 286b 6975     Sd::ReadBlock(ui
   1b228:	746e 3233 745f 202c 6975 746e 5f38 2a74     nt32_t, uint8_t*
   1b238:	202c 6975 746e 3233 745f 0029               , uint32_t).

0001b244 <Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__>:
   1b244:	6976 7472 6175 206c 6975 746e 5f38 2074     virtual uint8_t 
   1b254:	6453 3a3a 6544 656c 6574 6c42 636f 286b     Sd::DeleteBlock(
   1b264:	6975 746e 3233 745f 202c 6975 746e 3233     uint32_t, uint32
   1b274:	745f 0029                                   _t).

0001b278 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__>:
   1b278:	6976 7472 6175 206c 6975 746e 3233 745f     virtual uint32_t
   1b288:	5320 3a64 533a 6e65 4364 646d 5328 4964      Sd::SendCmd(SdI
   1b298:	746e 7265 6166 6563 3a3a 6f43 6d6d 6e61     nterface::Comman
   1b2a8:	2c64 7520 6e69 3374 5f32 2c74 7520 6e69     d, uint32_t, uin
   1b2b8:	3874 745f 2c2a 7520 6e69 3374 5f32 2c74     t8_t*, uint32_t,
   1b2c8:	5320 4964 746e 7265 6166 6563 3a3a 654b      SdInterface::Ke
   1b2d8:	7065 6c41 7669 2965 ff00 ffff               epAlive)....

0001b2e4 <__sf_fake_stderr>:
	...

0001b304 <__sf_fake_stdin>:
	...

0001b324 <__sf_fake_stdout>:
	...
