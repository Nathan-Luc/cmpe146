
build/application/firmware.elf:     file format elf32-littlearm
build/application/firmware.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000129b5

Program Header:
0x70000001 off    0x0001afa0 vaddr 0x0001afa0 paddr 0x0001afa0 align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00010000 vaddr 0x00010000 paddr 0x00010000 align 2**16
         filesz 0x0000afa8 memsz 0x0000afa8 flags r-x
    LOAD off    0x00020000 vaddr 0x10000000 paddr 0x0001afa8 align 2**16
         filesz 0x00000284 memsz 0x00000284 flags rw-
    LOAD off    0x00020288 vaddr 0x10000288 paddr 0x10000288 align 2**16
         filesz 0x00000000 memsz 0x000006b8 flags rw-
private flags = 5000400: [Version5 EABI] [hard-float ABI]

Sections:
Idx Name             Size      VMA       LMA       File off  Algn  Flags
  0 .text            0000afa0  00010000  00010000  00010000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data            00000284  10000000  0001afa8  00020000  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .data_RAM2       00000000  20000000  20000000  00020284  2**2  CONTENTS
  3 .bss             000006b8  10000288  10000288  00020288  2**3  ALLOC
  4 .ARM.exidx       00000008  0001afa0  0001afa0  0001afa0  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .uninit_RESERVED 00000000  10000000  10000000  00020284  2**2  CONTENTS
  6 .noinit_RAM2     00000000  20000000  20000000  00020284  2**2  CONTENTS
  7 .noinit          00000000  10000940  10000940  00020284  2**2  CONTENTS
  8 .ARM.attributes  00000030  00000000  00000000  00020284  2**0  CONTENTS, READONLY
  9 .comment         0000007e  00000000  00000000  000202b4  2**0  CONTENTS, READONLY
 10 .debug_info      00044aff  00000000  00000000  00020332  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev    00005107  00000000  00000000  00064e31  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges   00000ee8  00000000  00000000  00069f38  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges    00000e28  00000000  00000000  0006ae20  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_line      0000791a  00000000  00000000  0006bc48  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_str       0001a9ee  00000000  00000000  00073562  2**0  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame     000039e0  00000000  00000000  0008df50  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
10000000 l    d  .data	00000000 .data
20000000 l    d  .data_RAM2	00000000 .data_RAM2
10000288 l    d  .bss	00000000 .bss
0001afa0 l    d  .ARM.exidx	00000000 .ARM.exidx
10000000 l    d  .uninit_RESERVED	00000000 .uninit_RESERVED
20000000 l    d  .noinit_RAM2	00000000 .noinit_RAM2
10000940 l    d  .noinit	00000000 .noinit
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 interrupt.cpp
00012f90 l     F .text	0000002c NVIC_EnableIRQ
00012fbc l     F .text	00000054 NVIC_SetPriority
00010000 l     O .text	000000e4 kInterruptVectorTable
00019b18 l     O .text	0000000e InterruptLookupHandler::file
00019b28 l     O .text	0000001e InterruptLookupHandler::__PRETTY_FUNCTION__
0001022c l       .text	00000000 handler2_address_const
00000000 l    df *ABS*	00000000 startup.cpp
0001972c l     O .text	00000049 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__
000197d4 l     O .text	0000005c Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
00019778 l     O .text	0000005a Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__
00019830 l     O .text	0000003a Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__
0001986c l     O .text	0000003e Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__
100000ec l     O .data	00000008 (anonymous namespace)::system_timer
100000f4 l     O .data	00000004 (anonymous namespace)::system_controller
100000f8 l     O .data	0000000c (anonymous namespace)::timer0
000127d0 l     F .text	00000040 (anonymous namespace)::Lpc40xxUptime()
10000418 l     O .bss	00000060 idle_task_tcb
10000478 l     O .bss	00000140 idle_task_stack
00019614 l     O .text	0000000c LowLevelInit()::file
000198ac l     O .text	00000014 LowLevelInit()::__PRETTY_FUNCTION__
000102fc l     O .text	00000004 kCrpWord
00012ea4 l     F .text	000000dc __static_initialization_and_destruction_0(int, int)
00012f80 l     F .text	0000000e _GLOBAL__sub_I_UptimeRTOS
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crti.o
00000000 l    df *ABS*	00000000 /mnt/c/SJSU_Dev2/SJSU-Dev2/tools/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/thumb/v7e-m/fpv4-sp/hard/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00010328 l     F .text	00000000 __do_global_dtors_aux
10000288 l       .bss	00000001 completed.9929
0001034c l     F .text	00000000 frame_dummy
1000028c l       .bss	00000018 object.9934
0001030c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
100003a8 l     O .bss	00000008 (anonymous namespace)::uptime
00010748 l     F .text	00000030 (anonymous namespace)::DefaultUptime()
00018e18 l     O .text	00000009 main::file
00018f6c l     O .text	0000000b main::__PRETTY_FUNCTION__
00018f48 l     O .text	00000009 isr_toggle()::file
00018f78 l     O .text	00000012 isr_toggle()::__PRETTY_FUNCTION__
00018f54 l     O .text	00000009 sem_task(void*)::file
00018f60 l     O .text	00000009 sem_task(void*)::file
00018f8c l     O .text	00000015 sem_task(void*)::__PRETTY_FUNCTION__
00010d78 l     F .text	00000054 __static_initialization_and_destruction_0(int, int)
00010dcc l     F .text	00000028 _GLOBAL__sub_I_binary_sem
00000000 l    df *ABS*	00000000 diskio.cpp
0001add8 l     O .text	0000001c Gpio::ValidPortCheck()::__PRETTY_FUNCTION__
0001adf4 l     O .text	00000039 Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001ad9c l     O .text	0000003b Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__
0001ae30 l     O .text	00000031 Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__
0001ae64 l     O .text	0000003c Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__
0001aea0 l     O .text	00000034 Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__
0001aed4 l     O .text	00000069 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__
100008cc l     O .bss	00000068 (anonymous namespace)::sd_card
00018658 l     F .text	00000050 __static_initialization_and_destruction_0(int, int)
000186a8 l     F .text	00000028 _GLOBAL__sub_I_disk_status
00000000 l    df *ABS*	00000000 LabGPIO.cpp
10000000 l     O .data	00000018 GPIO
10000018 l     O .data	00000028 interrupts
00018d98 l     O .text	0000000c LabGPIO::IntEdge(LabGPIO::Edge)::file
00018df0 l     O .text	00000025 LabGPIO::IntEdge(LabGPIO::Edge)::__PRETTY_FUNCTION__
00000000 l    df *ABS*	00000000 newlib.cpp
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 tasks.c
100006c4 l     O .bss	00000064 pxReadyTasksLists
10000728 l     O .bss	00000014 xDelayedTaskList1
1000073c l     O .bss	00000014 xDelayedTaskList2
10000750 l     O .bss	00000004 pxDelayedTaskList
10000754 l     O .bss	00000004 pxOverflowDelayedTaskList
10000758 l     O .bss	00000014 xPendingReadyList
1000076c l     O .bss	00000014 xTasksWaitingTermination
10000780 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
10000784 l     O .bss	00000014 xSuspendedTaskList
10000798 l     O .bss	00000004 uxCurrentNumberOfTasks
1000079c l     O .bss	00000004 xTickCount
100007a0 l     O .bss	00000004 uxTopReadyPriority
100007a4 l     O .bss	00000004 xSchedulerRunning
100007a8 l     O .bss	00000004 uxPendedTicks
100007ac l     O .bss	00000004 xYieldPending
100007b0 l     O .bss	00000004 xNumOfOverflows
100007b4 l     O .bss	00000004 uxTaskNumber
100007b8 l     O .bss	00000004 xNextTaskUnblockTime
100007bc l     O .bss	00000004 xIdleTaskHandle
100007c0 l     O .bss	00000004 uxSchedulerSuspended
100007c4 l     O .bss	00000004 ulTaskSwitchedInTime
100007c8 l     O .bss	00000004 ulTotalRunTime
000135dc l     F .text	000000f2 prvInitialiseNewTask
000136d0 l     F .text	000000dc prvAddNewTaskToReadyList
00013d34 l     F .text	0000007c prvInitialiseTaskLists
00013e08 l     F .text	0000003a prvDeleteTCB
00013e44 l     F .text	00000040 prvResetNextTaskUnblockTime
0001416c l     F .text	000000c8 prvAddCurrentTaskToDelayedList
00013d28 l     F .text	0000000c prvIdleTask
00013db0 l     F .text	00000058 prvCheckTasksWaitingTermination
00000000 l    df *ABS*	00000000 queue.c
0001434a l     F .text	00000048 prvInitialiseNewQueue
0001473e l     F .text	000000d2 prvCopyDataToQueue
000148e8 l     F .text	0000002e prvIsQueueFull
00014810 l     F .text	000000ae prvUnlockQueue
000148be l     F .text	0000002a prvIsQueueEmpty
00014718 l     F .text	00000026 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 port.c
100001f0 l     O .data	00000004 uxCriticalNesting
00014978 l     F .text	00000026 prvTaskExitError
000149c0 l       .text	00000000 pxCurrentTCBConst2
000149c8 l     F .text	00000024 prvPortStartFirstTask
00014b48 l     F .text	00000010 vPortEnableVFP
00014b00 l       .text	00000000 pxCurrentTCBConst
00000000 l    df *ABS*	00000000 heap_3.c
00000000 l    df *ABS*	00000000 printf.cpp
00014ba0 l     F .text	00000030 _out_null(char, void*, unsigned int, unsigned int)
00014bd0 l     F .text	00000044 _out_char(char, void*, unsigned int, unsigned int)
00014c14 l     F .text	00000044 _strlen(char const*)
00014c58 l     F .text	00000044 _is_digit(char)
00014c9c l     F .text	00000060 _atoi(char const**)
00014cfc l     F .text	0000025c _ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)
00014f58 l     F .text	000000e4 _ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)
0001503c l     F .text	000000f4 _ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)
00019b78 l     O .text	00000028 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10
00015130 l     F .text	00000438 _ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)
00015568 l     F .text	000008f4 _vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)
00000000 l    df *ABS*	00000000 pure.cc
00000000 l    df *ABS*	00000000 eh_terminate.cc
00000000 l    df *ABS*	00000000 sf_round.c
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcpy-stub.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 nano-mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 findfp.c
00000000 l    df *ABS*	00000000 eh_term_handler.cc
00000000 l    df *ABS*	00000000 impure.c
10000224 l     O .data	00000060 impure_data
00000000 l    df *ABS*	00000000 reent.c
00011038  w    F .text	0000003e Lpc40xxSystemController::GetPeripheralFrequency() const
0001328c g     F .text	00000038 putchar
00013010  w    F .text	0000006c Pwm0IrqHandler
0001a7d8  w    O .text	00000009 Gpio::SetInterruptEdge(GpioInterface::Edge)::file
00010218 g     F .text	0000001c HardFaultHandler
000131a4 g     F .text	00000024 _getpid
00013250 g     F .text	0000003c _putchar
00013010  w    F .text	0000006c EepromIrqHandler
00013010  w    F .text	0000006c Timer2IrqHandler
100000d8  w    O .data	00000014 uart0
00013390 g     F .text	0000002c GetStackDepth()
0001ab48  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001679c  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
000195dc  w    O .text	00000004 Timer::kTimerIrq
00014a6c g     F .text	00000028 vPortExitCritical
0001ab80  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00018d6c g     F .text	00000024 _kill_r
0001010c g       .text	00000000 bss_section_table_end
00015e5c g     F .text	0000004c printf
10000070  w    O .data	00000004 SystemTimer::sys_tick
00013010  w    F .text	0000006c I2c1IrqHandler
00012a5c  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)2>()
10000088  w    O .data	00000010 Uart::uart
0001abb0  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00010000 g       *ABS*	00000000 __vectors_start__
00018d96 g     F .text	00000002 __malloc_unlock
00010778  w    F .text	00000044 Milliseconds()
0001119c  w    F .text	00000110 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)
000167c0  w    F .text	00000034 SspInterface::SspInterface()
00013010  w    F .text	0000006c BusFaultHandler
100005bc g     O .bss	00000100 stack_trace
10000074  w    O .data	00000004 Pin::pin_map
0001201c  w    F .text	000000e4 Uart::Initialize(unsigned long)
20000000 g       *ABS*	00000000 __base_RAM2
0001afa8 g       .ARM.exidx	00000000 __exidx_end
0001668c  w    F .text	0000007c Gpio::ClearEdgeRising()
00011484  w    F .text	00000030 Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)
0001a7cc  w    O .text	00000009 Gpio::ValidPortCheck()::file
00010530 g     F .text	000000c8 LabGPIO::GpioInterruptHandler()
100006c0 g     O .bss	00000004 pxCurrentTCB
00015ea8  w    F .text	00000034 PinInterface::PinInterface()
000105f8 g     F .text	00000034 LabGPIO::EnableInterrupts()
0001334c g     F .text	0000001c __cyg_profile_func_exit
0001832c  w    F .text	00000048 Sd::Crc7Add(unsigned char, unsigned char)
00017244  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
00012cc4  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()
1000093c g     O .bss	00000004 errno
0001afa8 g       .ARM.exidx	00000000 _etext
10000068  w    O .data	00000004 Lpc40xxSystemController::system_controller
00010c14 g     F .text	00000074 sem_task(void*)
00010f24  w    F .text	00000090 Lpc40xxSystemController::SetClockFrequency(unsigned char)
00011dec  w    F .text	00000030 unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)
00011024  w    F .text	00000014 Lpc40xxSystemController::GetSystemFrequency() const
000125e0  w    F .text	000001f0 Uart::GenerateUartCalibration(float)
10000044  w    O .data	00000018 Gpio::gpio_port
00011e1c  w    F .text	000000f8 Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)
000128dc  w    F .text	000000bc LowLevelInit()
00013010  w    F .text	0000006c LcdIrqHandler
0001abd8  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
00080000 g       *ABS*	00000000 __top_MFlash512
00010ab8  w    F .text	0000006c Ssp::Transfer(unsigned short)
00013c68 g     F .text	00000024 vTaskInternalSetTimeOutState
00012280  w    F .text	000000f8 Uart::Receive(unsigned long)
0001113c  w    F .text	00000030 Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)
000108d8  w    F .text	00000030 Delay(unsigned long long)
00019604  w    O .text	00000010 Uart::kPowerbit
00013010  w    F .text	0000006c I2c2IrqHandler
100003c4  w    O .bss	00000004 SystemTimer::system_timer_isr
00016554  w    F .text	00000040 Gpio::DetachInterrupt()
00013010  w    F .text	0000006c CanIrqHandler
000149f0 g     F .text	00000054 xPortStartScheduler
00018b74 g     F .text	00000016 memcpy
00013b94 g     F .text	0000002c vTaskPlaceOnEventList
00011b38  w    F .text	00000074 Pin::EnableDac(bool)
00010448 g     F .text	00000050 LabGPIO::ReadBool()
000128b0 g     F .text	0000002c vPortSetupTimerInterrupt
00011868  w    F .text	0000007c Pin::SetAsAnalogMode(bool)
00014b08 g     F .text	00000040 xPortSysTickHandler
0001141c  w    F .text	00000068 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)
000183e4  w    F .text	000000fc Sd::GetCrc16(unsigned char*, unsigned short)
000187fc g     F .text	00000000 .hidden __aeabi_uldivmod
10000940 g       .noinit	00000000 _noinit
000132c4 g     F .text	00000060 puts
00014b7e g     F .text	00000022 vPortFree
10000104 g     O .data	000000e4 dynamic_isr_vector_table
00016274  w    F .text	0000002c Gpio::GetPin()
00010bb4 g     F .text	00000060 isr_toggle()
0001631c  w    F .text	0000005c Gpio::SetInterruptRoutine(void (*)())
00015f34  w    F .text	00000034 GpioInterface::GpioInterface()
000167c0  w    F .text	00000034 SspInterface::SspInterface()
0001458c g     F .text	0000018c xQueueSemaphoreTake
00013010  w    F .text	0000006c RitIrqHandler
00013010  w    F .text	0000006c Uart2IrqHandler
00011bac  w    F .text	00000064 Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)
000195b4  w    O .text	00000016 Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file
0001ab68  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00018b54 g     F .text	00000010 malloc
00016d40  w    F .text	00000160 Ssp::GetPeripheralMode()
00012d64  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()
000186fc g     F .text	00000060 roundf
00018d0c g     F .text	00000050 _raise_r
000107e8  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::_FUN()
00010a14  w    F .text	0000002c int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)
000167f4  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10010000 g       *ABS*	00000000 __top_RAM
00019600  w    O .text	00000004 Uart::kRxUartPortFunction
00014aa0 g     F .text	00000066 xPortPendSVHandler
00010814  w    F .text	000000c4 Wait(unsigned long long)
00017210  w    F .text	00000034 SdInterface::SdInterface()
00011f14  w    F .text	0000003c Timer::GetTimer()
10000000 g       *ABS*	00000000 __base_RamLoc64
00013368 g     F .text	00000028 GetStackTrace()
100001ec g     O .data	00000004 out
00013402 g     F .text	0000003e vListInsertEnd
1000006c  w    O .data	00000004 Lpc40xxSystemController::speed_in_hertz
0001abb8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001aba0  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00018d90 g     F .text	00000004 _getpid_r
00000000 g       *ABS*	00000000 __base_MFlash512
0001ac38  w    O .text	0000004c vtable for Ssp
10010000 g       *ABS*	00000000 StackTop
000176f4  w    F .text	00000064 Sd::WaitToReadBlock()
0001a7f0  w    O .text	00000003 Ssp::kPinSelect
0001882c g     F .text	000002cc .hidden __udivmoddi4
00013010  w    F .text	0000006c I2sIrqHandler
00018cec g     F .text	00000020 _sbrk_r
000100fc g       .text	00000000 bss_section_table
0001062c g     F .text	0000007c LabGPIO::IntEdge(LabGPIO::Edge)
00010300 g       .text	00000000 __CRP_WORD_END__
20008000 g       *ABS*	00000000 __top_RAM2
000129b4 g     F .text	00000030 ResetIsr
000133f2 g     F .text	00000010 vListInitialiseItem
000176b0  w    F .text	00000044 Sd::ToBool(bool)
0001ac84  w    O .text	00000028 vtable for SspInterface
00013010  w    F .text	0000006c PendSVHandler
00016aa4  w    F .text	00000030 unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)
00011524  w    F .text	00000034 SystemTimer::SetIsrFunction(void (*)())
00010d34  w    F .text	00000044 bool bit::Read<unsigned long>(unsigned long, unsigned long)
00010a40  w    F .text	00000078 Ssp::IsTransferRegBusy()
00013010  w    F .text	0000006c UsageFaultHandler
20000000 g       *ABS*	00000000 __user_heap_base
0001afa0 g       .text	00000000 __exidx_start
00011a50  w    F .text	00000074 Pin::EnableI2cHighCurrentDrive(bool)
00013010  w    F .text	0000006c Uart4IrqHandler
00016378  w    F .text	00000054 Gpio::ClearInterruptRoutine()
000119d4  w    F .text	0000007c Pin::EnableI2cHighSpeedMode(bool)
000101fc g     F .text	00000018 InitFpu()
000118e4  w    F .text	0000007c Pin::EnableDigitalFilter(bool)
00018b0c g     F .text	00000048 __libc_init_array
00013010 g     F .text	0000006c InterruptLookupHandler
0001116c  w    F .text	00000030 Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)
0001100c  w    F .text	00000018 Lpc40xxSystemController::GetPeripheralClockDivider() const
10000040  w    O .data	00000004 Uptime
0001ad18  w    O .text	00000048 vtable for GpioInterface
0001214c  w    F .text	000000e8 Uart::Send(unsigned char)
00018afc g     F .text	0000000e abort
00013010  w    F .text	0000006c BodIrqHandler
000131f8 g     F .text	00000058 _sbrk
00014b5c g     F .text	00000022 pvPortMalloc
0001708c  w    F .text	00000184 Ssp::GetClock()
00010300 g     F .text	00000000 _init
0001010c g       .text	00000000 section_table_end
00012e04  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()
000133bc g     F .text	00000036 vListInitialise
000186f0 g     F .text	0000000a std::terminate()
0001875c g     F .text	0000009e .hidden __aeabi_d2f
00014394 g     F .text	00000150 xQueueGenericSend
00016708  w    F .text	0000007c Gpio::ClearEdgeFalling()
00013010  w    F .text	0000006c SysTickHandler
000100e4 g       .text	00000000 section_table_start
10000940 g       .bss	00000000 _ebss
00016610  w    F .text	0000007c Gpio::SetEdgeFalling()
0001ab78  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
00013010  w    F .text	0000006c RtcIrqHandler
00013f8c g     F .text	000000c8 xTaskPriorityDisinherit
00016204  w    F .text	00000070 Gpio::Read()
00012ad4  w    F .text	000000a8 Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})
eff813ee g       *ABS*	00000000 ValidUserCodeChecksum
00013010  w    F .text	0000006c Uart0IrqHandler
000130d8 g     F .text	00000078 GetRegistersFromStack
000184e0  w    F .text	0000003c unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)
00013bc0 g     F .text	000000a8 xTaskRemoveFromEventList
0001ad60  w    O .text	0000003c vtable for PinInterface
00013010  w    F .text	0000006c UsbIrqHandler
00013010  w    F .text	0000006c AdcIrqHandler
00012234  w    F .text	0000004c Uart::Receive(unsigned long)::{lambda()#1}::operator()() const
00010ef4  w    F .text	00000030 SetUptimeFunction(unsigned long long (*)())
00010368 g     F .text	00000058 LabGPIO::LabGPIO(unsigned char, unsigned char)
0001af40 g     O .text	00000020 __sf_fake_stderr
0001a848  w    O .text	00000100 Sd::kCrcTable8
000186e0 g     F .text	00000010 std::get_terminate()
000124e8  w    F .text	00000074 Uart::FractionalEstimate(float, float)
000163fc  w    F .text	00000088 Gpio::SetInterruptEdge(GpioInterface::Edge)
00013010  w    F .text	0000006c EnetIrqHandler
00013010  w    F .text	0000006c DmaIrqHandler
0001010c g     F .text	00000090 InitDataSection()
0001307c g     F .text	0000005c RegisterIsr(IRQn, void (*)(), bool, long)
0001414c g     F .text	00000020 pvTaskIncrementMutexHeldCount
00000000 g       *ABS*	00000000 __base_Flash
00013010  w    F .text	0000006c Eint1IrqHandler
1000005c  w    O .data	0000000c Ssp::ssp_registers
00013010  w    F .text	0000006c SvcHandler
00013c8c g     F .text	0000008c xTaskCheckForTimeOut
00013010  w    F .text	0000006c GpioIrqHandler
00018b9c g     F .text	0000009c _free_r
100003b0 g     O .bss	00000004 binary_sem
0001abc8  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
00013e84 g     F .text	00000108 xTaskPriorityInherit
00013010  w    F .text	0000006c SdioIrqHandler
10010000 g       *ABS*	00000000 __top_RamLoc64
10000288 g       .bss	00000000 _bss
0001ab60  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
00013010  w    F .text	0000006c Pll1IrqHandler
00013010  w    F .text	0000006c MemManageHandler
00013848 g     F .text	00000014 vTaskSuspendAll
000186d0 g     F .text	00000006 __cxa_pure_virtual
00013010  w    F .text	0000006c Pwm1IrqHandler
000134a8 g     F .text	0000004a uxListRemove
000163cc  w    F .text	00000030 unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)
00013010  w    F .text	0000006c Timer0IrqHandler
00012b7c  w    F .text	000000a8 Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})
00080000 g       *ABS*	00000000 __top_Flash
0001255c  w    F .text	00000084 Uart::IsDecmial(float)
00016ea0  w    F .text	000001ec Ssp::SetClock(bool, bool, unsigned char, unsigned char)
000134f2 g     F .text	0000005c xTaskCreateStatic
10000940 g       .noinit	00000000 _end_noinit
000114b4  w    F .text	0000003c SystemTimer::DisableTimer()
00017d6c  w    F .text	00000120 Sd::DeleteBlock(unsigned long, unsigned long)
00013acc g     F .text	000000c8 vTaskSwitchContext
00018590  w    F .text	00000054 unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)
00015edc  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
00016b04  w    F .text	00000030 unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)
0001ab88  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000195fc  w    O .text	00000004 Uart::kTxUartPortFunction
00013010  w    F .text	0000006c Uart3IrqHandler
00016784  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
0001abc0  w    O .text	00000007 Sd::DeleteBlock(unsigned long, unsigned long)::file
20000000 g       *ABS*	00000000 __base_RamPeriph32
0001287c g     F .text	00000034 vApplicationGetIdleTaskMemory
0001a7e4  w    O .text	00000009 Gpio::ClearInterruptEdge(GpioInterface::Edge)::file
100006bc g     O .bss	00000004 stack_depth
00016120  w    F .text	0000006c Gpio::Toggle()
0001ab98  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
0001a948  w    O .text	00000200 Sd::kCrcTable16
100007cc  w    O .bss	00000100 Gpio::interrupthandlers
00018af8  w    F .text	00000002 .hidden __aeabi_ldiv0
00013010  w    F .text	0000006c Timer1IrqHandler
00012474  w    F .text	00000074 Uart::DividerEstimate(float, float)
00010908  w    F .text	00000064 Gpio::SetHigh()
000106f8 g     F .text	00000050 LabGPIO::setRisingEdge()
00012378  w    F .text	000000fc Uart::FindClosestFractional(float)
00016880  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
000100e4 g       .text	00000000 data_section_table
00011700  w    F .text	00000080 Pin::SetMode(PinInterface::Mode)
0001956c  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
00017758  w    F .text	00000050 Sd::WaitWhileBusy()
00018d94 g     F .text	00000002 __malloc_lock
000115f4  w    F .text	00000094 SystemTimer::SetTickFrequency(unsigned long)
0001af60 g     O .text	00000020 __sf_fake_stdin
000185e4  w    F .text	00000074 unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)
000102fc g       .text	00000000 __CRP_WORD_START__
000195e0  w    O .text	00000010 Timer::kTimerIsr
0001650c  w    F .text	00000048 Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)
00013010  w    F .text	0000006c Uart1IrqHandler
00015fe4  w    F .text	0000007c Gpio::SetAsInput()
00013324 g     F .text	00000028 __cyg_profile_func_enter
00018b8a g     F .text	00000010 memset
00010b24 g     F .text	00000090 main
00017244  w    F .text	000000a0 Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)
100003bc g     O .bss	00000008 led3
100001f4  w    O .data	00000028 Gpio::interrupt
00011c98  w    F .text	00000020 Timer::DoNothingIsr()
00013010  w    F .text	0000006c QeiIrqHandler
20000000 g       *ABS*	00000000 heap
00013440 g     F .text	00000068 vListInsert
00013010  w    F .text	0000006c Ssp2IrqHandler
00011c10  w    F .text	0000002c Pin::GetPort() const
00017bc0  w    F .text	000001ac Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)
00015edc  w    F .text	00000058 Pin::Pin(unsigned char, unsigned char)
0001875c g     F .text	0000009e .hidden __truncdfsf2
0001031c g       .text	00000000 __init_array_end
000149a0 g     F .text	00000026 vPortSVCHandler
00013150 g     F .text	0000003c FirmwareStdOut(int)
00018c38 g     F .text	000000b4 _malloc_r
0001abe0  w    O .text	0000002c vtable for Sd
00016484  w    F .text	00000088 Gpio::ClearInterruptEdge(GpioInterface::Edge)
00013010  w    F .text	0000006c Ssp1IrqHandler
000129e4  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)0>()
0001a83c  w    O .text	0000000c Ssp::kPowerBit
00011c3c  w    F .text	0000002c Pin::GetPin() const
000142e8 g     F .text	00000062 xQueueGenericCreate
00011f50  w    F .text	000000cc Uart::SetBaudRate(unsigned long)
000160dc  w    F .text	00000044 Gpio::SetDirection(GpioInterface::Direction)
00019620  w    O .text	0000003c vtable for Uart
00016060  w    F .text	0000007c Gpio::SetAsOutput()
0001aba8  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000112ac  w    F .text	00000170 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)
0001096c  w    F .text	00000064 Gpio::SetLow()
00019708  w    O .text	00000024 vtable for Lpc40xxSystemController
000177a8  w    F .text	00000418 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)
0001abd0  w    O .text	00000007 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file
00019554  w    O .text	00000016 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file
00012998 g     F .text	0000001a SystemInit
00011cb8  w    F .text	00000134 Timer::Initialize(unsigned long, void (*)(), long)
00011078  w    F .text	00000030 Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)
20008000 g       *ABS*	00000000 heap_end
00016964  w    F .text	000000e4 Ssp::Initialize()
0001965c  w    O .text	00000038 vtable for Timer
000167f4  w    F .text	00000038 PinInterface::PinInterface(PinInterface const&)
10000078  w    O .data	00000010 Timer::tim_register
00013010  w    F .text	0000006c Ssp0IrqHandler
00010368 g     F .text	00000058 LabGPIO::LabGPIO(unsigned char, unsigned char)
0001031c g     F .text	00000000 _fini
00013010  w    F .text	0000006c UsbactivityIrqHandler
000109d0  w    F .text	00000044 Gpio::Set(GpioInterface::State)
00013010  w    F .text	0000006c Pll0IrqHandler
0001385c g     F .text	00000118 xTaskResumeAll
0001682c  w    F .text	00000054 Pin::Pin(Pin const&)
000100fc g       .text	00000000 data_section_table_end
00013010  w    F .text	0000006c CanactivityIrqHandler
000137ac g     F .text	0000009c vTaskStartScheduler
00013010  w    F .text	0000006c NmiHandler
0001a7f4  w    O .text	00000048 Ssp::kSspPinMatrix
0001618c  w    F .text	00000078 Gpio::ReadState()
0001ab70  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
000106a8 g     F .text	00000050 LabGPIO::setFallingEdge()
10000220 g     O .data	00000004 _impure_ptr
00010c88  w    F .text	000000ac Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})
10000000 g       .uninit_RESERVED	00000000 _end_uninit_RESERVED
00018374  w    F .text	00000070 Sd::GetCrc7(unsigned char*, unsigned char)
00013010  w    F .text	0000006c McpwmIrqHandler
0001030c g       .text	00000000 __preinit_array_end
00013010  w    F .text	0000006c WdtIrqHandler
000107bc  w    F .text	0000002c Wait(unsigned long long)::{lambda()#1}::operator()() const
00017e8c  w    F .text	000004a0 Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)
0001679c  w    F .text	00000024 Lpc40xxSystemController::Lpc40xxSystemController()
00019694  w    O .text	0000003c vtable for Pin
10000000 g       .data	00000000 _data
000117f4  w    F .text	00000074 Pin::SetAsActiveLow(bool)
0001110c  w    F .text	00000030 Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)
00016594  w    F .text	0000007c Gpio::SetEdgeRising()
0001ab50  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
00013d18 g     F .text	00000010 vTaskMissedYield
00011c68  w    F .text	00000030 unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)
10000408  w    O .bss	00000010 Timer::user_timer_isr
00019584  w    O .text	00000016 Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file
100003c8  w    O .bss	00000040 Timer::match
00010404 g     F .text	00000044 LabGPIO::SetLow()
00012100  w    F .text	0000004c Uart::Send(unsigned char)::{lambda()#1}::operator()() const
00013974 g     F .text	00000158 xTaskIncrementTick
00017394  w    F .text	0000031c Sd::Mount(SdInterface::CardInfo_t*)
1000021c g     O .data	00000004 __cxxabiv1::__terminate_handler
00014234 g     F .text	000000b4 xQueueGenericReset
0001acac  w    O .text	00000024 vtable for SystemControllerInterface
0001acd0  w    O .text	00000048 vtable for Gpio
10000284 g       .data	00000000 _edata
000195cc  w    O .text	00000010 Timer::kPowerbit
00012a20  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)1>()
00011780  w    F .text	00000074 Pin::EnableHysteresis(bool)
00015f34  w    F .text	00000034 GpioInterface::GpioInterface()
00010498 g     F .text	00000048 LabGPIO::toggle()
00013010  w    F .text	0000006c DebugMonHandler
000162a0  w    F .text	0000007c Gpio::ValidPortCheck()
0001354e g     F .text	0000008e xTaskCreate
00013010  w    F .text	0000006c Eint2IrqHandler
20008000 g       *ABS*	00000000 __top_RamPeriph32
00016880  w    F .text	000000e4 Ssp::Ssp(Ssp::Peripheral)
00013010  w    F .text	0000006c Timer3IrqHandler
000103c0 g     F .text	00000044 LabGPIO::SetHigh()
10000000 g       *ABS*	00000000 __base_RAM
00013010  w    F .text	0000006c Eint3IrqHandler
000186d6 g     F .text	00000008 __cxxabiv1::__terminate(void (*)())
00012850  w    F .text	0000002c unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])
000131c8 g     F .text	00000030 _kill
00013010  w    F .text	0000006c I2c0IrqHandler
0001682c  w    F .text	00000054 Pin::Pin(Pin const&)
000195f0  w    O .text	0000000a Timer::Initialize(unsigned long, void (*)(), long)::file
000114f0  w    F .text	00000034 SystemTimer::SystemTimerHandler()
0001ab58  w    O .text	00000007 Sd::Mount(SdInterface::CardInfo_t*)::file
0001af80 g     O .text	00000020 __sf_fake_stdout
00010df4  w    F .text	00000100 debug::PrintBacktrace(bool, void*)
00014054 g     F .text	000000f8 vTaskPriorityDisinheritAfterTimeout
0001030c g       .text	00000000 __init_array_start
00018af8  w    F .text	00000002 .hidden __aeabi_idiv0
0001ac0c  w    O .text	0000002c vtable for SdInterface
000172e4  w    F .text	000000b0 Sd::Initialize()
0001318c g     F .text	00000018 _exit
00011960  w    F .text	00000074 Pin::EnableFastMode(bool)
00012c24  w    F .text	000000a0 void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()
00013010  w    F .text	0000006c Eint0IrqHandler
00011558  w    F .text	0000009c SystemTimer::StartTimer()
00016ad4  w    F .text	00000030 unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)
00014918 g     F .text	00000060 pxPortInitialiseStack
0001019c g     F .text	00000060 InitBssSection()
10000938 g     O .bss	00000004 __malloc_sbrk_start
00015f68  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
00012810 g     F .text	00000040 UptimeRTOS
00011ac4  w    F .text	00000074 Pin::SetAsOpenDrain(bool)
100002a4 g     O .bss	00000100 LabGPIO::pin_isr_map
00014a44 g     F .text	00000028 vPortEnterCritical
000196d0  w    O .text	00000038 vtable for SystemTimer
00013010  w    F .text	0000006c SpiIrqHandler
0001ab90  w    O .text	00000007 Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file
10000934 g     O .bss	00000004 __malloc_free_list
00016a48  w    F .text	0000005c Ssp::SetSpiMasterDefault()
10000098  w    O .data	00000040 Uart::pairs
00016784  w    F .text	00000018 SystemControllerInterface::SystemControllerInterface()
000110a8  w    F .text	00000030 Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)
00017210  w    F .text	00000034 SdInterface::SdInterface()
0001030c g       .text	00000000 __preinit_array_start
000104e0 g     F .text	00000050 LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)
100001e8  w    O .data	00000004 heap_position
0001959c  w    O .text	00000016 Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file
000110d8  w    F .text	00000034 Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)
100005b8  w    O .bss	00000004 guard variable for Timer::match
00016b34  w    F .text	0000020c Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)
100003b4 g     O .bss	00000008 Button3
00011688  w    F .text	00000078 Pin::SetPinFunction(unsigned char)
0001851c  w    F .text	00000074 unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)
00015ea8  w    F .text	00000034 PinInterface::PinInterface()
00010fb4  w    F .text	00000058 Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)
00015f68  w    F .text	0000007c Gpio::Gpio(unsigned char, unsigned char)
000144e4 g     F .text	000000a8 xQueueGiveFromISR
00012a98  w    F .text	0000003c void Timer::TimerHandler<(TimerInterface::TimerPort)3>()
00018d5c g     F .text	00000010 raise
00018b64 g     F .text	00000010 free



Disassembly of section .text:

00010000 <kInterruptVectorTable>:
   10000:	00 00 01 10 b5 29 01 00 11 30 01 00 19 02 01 00     .....)...0......
   10010:	11 30 01 00 11 30 01 00 11 30 01 00 ee 13 f8 ef     .0...0...0......
	...
   1002c:	a1 49 01 00 11 30 01 00 00 00 00 00 a1 4a 01 00     .I...0.......J..
   1003c:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   1004c:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   1005c:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   1006c:	11 30 01 00 11 30 01 00 00 00 00 00 11 30 01 00     .0...0.......0..
   1007c:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   1008c:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   1009c:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   100ac:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   100bc:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   100cc:	11 30 01 00 11 30 01 00 11 30 01 00 11 30 01 00     .0...0...0...0..
   100dc:	11 30 01 00 11 30 01 00                             .0...0..

000100e4 <data_section_table>:
   100e4:	0001afa8 	.word	0x0001afa8
   100e8:	10000000 	.word	0x10000000
   100ec:	00000284 	.word	0x00000284
   100f0:	0001afa8 	.word	0x0001afa8
   100f4:	20000000 	.word	0x20000000
   100f8:	00000000 	.word	0x00000000

000100fc <bss_section_table>:
   100fc:	10000288 	.word	0x10000288
   10100:	000006b8 	.word	0x000006b8
   10104:	20000000 	.word	0x20000000
   10108:	00000000 	.word	0x00000000

0001010c <InitDataSection()>:
SJ2_IGNORE_STACK_TRACE(void SystemInit());

// Functions to carry out the initialization of RW and BSS data sections.
SJ2_SECTION(".after_vectors")
void InitDataSection()
{
   1010c:	b086      	sub	sp, #24
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   1010e:	2300      	movs	r3, #0
   10110:	9305      	str	r3, [sp, #20]
   10112:	9a05      	ldr	r2, [sp, #20]
   10114:	4613      	mov	r3, r2
   10116:	005b      	lsls	r3, r3, #1
   10118:	4413      	add	r3, r2
   1011a:	009b      	lsls	r3, r3, #2
   1011c:	4a1d      	ldr	r2, [pc, #116]	; (10194 <InitDataSection()+0x88>)
   1011e:	4413      	add	r3, r2
   10120:	4a1d      	ldr	r2, [pc, #116]	; (10198 <InitDataSection()+0x8c>)
   10122:	4293      	cmp	r3, r2
   10124:	d233      	bcs.n	1018e <InitDataSection()+0x82>
  {
    uint32_t * rom_location = data_section_table[i].rom_location;
   10126:	491b      	ldr	r1, [pc, #108]	; (10194 <InitDataSection()+0x88>)
   10128:	9a05      	ldr	r2, [sp, #20]
   1012a:	4613      	mov	r3, r2
   1012c:	005b      	lsls	r3, r3, #1
   1012e:	4413      	add	r3, r2
   10130:	009b      	lsls	r3, r3, #2
   10132:	440b      	add	r3, r1
   10134:	681b      	ldr	r3, [r3, #0]
   10136:	9303      	str	r3, [sp, #12]
    uint32_t * ram_location = data_section_table[i].ram_location;
   10138:	4916      	ldr	r1, [pc, #88]	; (10194 <InitDataSection()+0x88>)
   1013a:	9a05      	ldr	r2, [sp, #20]
   1013c:	4613      	mov	r3, r2
   1013e:	005b      	lsls	r3, r3, #1
   10140:	4413      	add	r3, r2
   10142:	009b      	lsls	r3, r3, #2
   10144:	440b      	add	r3, r1
   10146:	685b      	ldr	r3, [r3, #4]
   10148:	9302      	str	r3, [sp, #8]
    uint32_t length         = data_section_table[i].length;
   1014a:	4912      	ldr	r1, [pc, #72]	; (10194 <InitDataSection()+0x88>)
   1014c:	9a05      	ldr	r2, [sp, #20]
   1014e:	4613      	mov	r3, r2
   10150:	005b      	lsls	r3, r3, #1
   10152:	4413      	add	r3, r2
   10154:	009b      	lsls	r3, r3, #2
   10156:	440b      	add	r3, r1
   10158:	3308      	adds	r3, #8
   1015a:	681b      	ldr	r3, [r3, #0]
   1015c:	9301      	str	r3, [sp, #4]
    for (size_t j = 0; j < length; j++)
   1015e:	2300      	movs	r3, #0
   10160:	9304      	str	r3, [sp, #16]
   10162:	9a04      	ldr	r2, [sp, #16]
   10164:	9b01      	ldr	r3, [sp, #4]
   10166:	429a      	cmp	r2, r3
   10168:	d20d      	bcs.n	10186 <InitDataSection()+0x7a>
    {
      ram_location[j] = rom_location[j];
   1016a:	9b04      	ldr	r3, [sp, #16]
   1016c:	009b      	lsls	r3, r3, #2
   1016e:	9a03      	ldr	r2, [sp, #12]
   10170:	441a      	add	r2, r3
   10172:	9b04      	ldr	r3, [sp, #16]
   10174:	009b      	lsls	r3, r3, #2
   10176:	9902      	ldr	r1, [sp, #8]
   10178:	440b      	add	r3, r1
   1017a:	6812      	ldr	r2, [r2, #0]
   1017c:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   1017e:	9b04      	ldr	r3, [sp, #16]
   10180:	3301      	adds	r3, #1
   10182:	9304      	str	r3, [sp, #16]
   10184:	e7ed      	b.n	10162 <InitDataSection()+0x56>
  for (int i = 0; &data_section_table[i] < &data_section_table_end; i++)
   10186:	9b05      	ldr	r3, [sp, #20]
   10188:	3301      	adds	r3, #1
   1018a:	9305      	str	r3, [sp, #20]
   1018c:	e7c1      	b.n	10112 <InitDataSection()+0x6>
    }
  }
}
   1018e:	bf00      	nop
   10190:	b006      	add	sp, #24
   10192:	4770      	bx	lr
   10194:	000100e4 	.word	0x000100e4
   10198:	000100fc 	.word	0x000100fc

0001019c <InitBssSection()>:

// Functions to initialization BSS data sections. This is important because
// the std c libs assume that BSS is set to zero.
SJ2_SECTION(".after_vectors")
void InitBssSection()
{
   1019c:	b084      	sub	sp, #16
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   1019e:	2300      	movs	r3, #0
   101a0:	9303      	str	r3, [sp, #12]
   101a2:	9b03      	ldr	r3, [sp, #12]
   101a4:	00db      	lsls	r3, r3, #3
   101a6:	4a13      	ldr	r2, [pc, #76]	; (101f4 <InitBssSection()+0x58>)
   101a8:	4413      	add	r3, r2
   101aa:	4a13      	ldr	r2, [pc, #76]	; (101f8 <InitBssSection()+0x5c>)
   101ac:	4293      	cmp	r3, r2
   101ae:	d21e      	bcs.n	101ee <InitBssSection()+0x52>
  {
    uint32_t * ram_location = bss_section_table[i].ram_location;
   101b0:	4a10      	ldr	r2, [pc, #64]	; (101f4 <InitBssSection()+0x58>)
   101b2:	9b03      	ldr	r3, [sp, #12]
   101b4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   101b8:	9301      	str	r3, [sp, #4]
    uint32_t length         = bss_section_table[i].length;
   101ba:	4a0e      	ldr	r2, [pc, #56]	; (101f4 <InitBssSection()+0x58>)
   101bc:	9b03      	ldr	r3, [sp, #12]
   101be:	00db      	lsls	r3, r3, #3
   101c0:	4413      	add	r3, r2
   101c2:	685b      	ldr	r3, [r3, #4]
   101c4:	9300      	str	r3, [sp, #0]
    for (size_t j = 0; j < length; j++)
   101c6:	2300      	movs	r3, #0
   101c8:	9302      	str	r3, [sp, #8]
   101ca:	9a02      	ldr	r2, [sp, #8]
   101cc:	9b00      	ldr	r3, [sp, #0]
   101ce:	429a      	cmp	r2, r3
   101d0:	d209      	bcs.n	101e6 <InitBssSection()+0x4a>
    {
      ram_location[j] = 0;
   101d2:	9b02      	ldr	r3, [sp, #8]
   101d4:	009b      	lsls	r3, r3, #2
   101d6:	9a01      	ldr	r2, [sp, #4]
   101d8:	4413      	add	r3, r2
   101da:	2200      	movs	r2, #0
   101dc:	601a      	str	r2, [r3, #0]
    for (size_t j = 0; j < length; j++)
   101de:	9b02      	ldr	r3, [sp, #8]
   101e0:	3301      	adds	r3, #1
   101e2:	9302      	str	r3, [sp, #8]
   101e4:	e7f1      	b.n	101ca <InitBssSection()+0x2e>
  for (int i = 0; &bss_section_table[i] < &bss_section_table_end; i++)
   101e6:	9b03      	ldr	r3, [sp, #12]
   101e8:	3301      	adds	r3, #1
   101ea:	9303      	str	r3, [sp, #12]
   101ec:	e7d9      	b.n	101a2 <InitBssSection()+0x6>
    }
  }
}
   101ee:	bf00      	nop
   101f0:	b004      	add	sp, #16
   101f2:	4770      	bx	lr
   101f4:	000100fc 	.word	0x000100fc
   101f8:	0001010c 	.word	0x0001010c

000101fc <InitFpu()>:
      // Write back the modified value to the CPACR
      "STR     R1, [R0]\n"
      // Wait for store to complete
      "DSB\n"
      // reset pipeline now the FPU is enabled
      "ISB\n");
   101fc:	f8df 0014 	ldr.w	r0, [pc, #20]	; 10214 <InitFpu()+0x18>
   10200:	6801      	ldr	r1, [r0, #0]
   10202:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   10206:	6001      	str	r1, [r0, #0]
   10208:	f3bf 8f4f 	dsb	sy
   1020c:	f3bf 8f6f 	isb	sy
}
   10210:	bf00      	nop
   10212:	4770      	bx	lr
   10214:	e000ed88 	.word	0xe000ed88

00010218 <HardFaultHandler>:
      " mrseq r0, msp                                       \n"
      " mrsne r0, psp                                       \n"
      " ldr r1, [r0, #24]                                   \n"
      " ldr r2, handler2_address_const                      \n"
      " bx r2                                               \n"
      " handler2_address_const: .word GetRegistersFromStack \n");
   10218:	f01e 0f04 	tst.w	lr, #4
   1021c:	bf0c      	ite	eq
   1021e:	f3ef 8008 	mrseq	r0, MSP
   10222:	f3ef 8009 	mrsne	r0, PSP
   10226:	6981      	ldr	r1, [r0, #24]
   10228:	4a00      	ldr	r2, [pc, #0]	; (1022c <handler2_address_const>)
   1022a:	4710      	bx	r2

0001022c <handler2_address_const>:
   1022c:	000130d9 	.word	0x000130d9
#endif
}
   10230:	bf00      	nop
   10232:	4770      	bx	lr
   10234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1023c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1024c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1025c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1026c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1027c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1028c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   10298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   1029c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
   102f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000102fc <__CRP_WORD_START__>:
   102fc:	ffffffff 	.word	0xffffffff

00010300 <_init>:
   10300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10302:	bf00      	nop
   10304:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10306:	bc08      	pop	{r3}
   10308:	469e      	mov	lr, r3
   1030a:	4770      	bx	lr

0001030c <__init_array_start>:
   1030c:	0001034d 	.word	0x0001034d
   10310:	00010dcd 	.word	0x00010dcd
   10314:	00012f81 	.word	0x00012f81
   10318:	000186a9 	.word	0x000186a9

0001031c <_fini>:
   1031c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1031e:	bf00      	nop
   10320:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10322:	bc08      	pop	{r3}
   10324:	469e      	mov	lr, r3
   10326:	4770      	bx	lr

00010328 <__do_global_dtors_aux>:
   10328:	b510      	push	{r4, lr}
   1032a:	4c05      	ldr	r4, [pc, #20]	; (10340 <__do_global_dtors_aux+0x18>)
   1032c:	7823      	ldrb	r3, [r4, #0]
   1032e:	b933      	cbnz	r3, 1033e <__do_global_dtors_aux+0x16>
   10330:	4b04      	ldr	r3, [pc, #16]	; (10344 <__do_global_dtors_aux+0x1c>)
   10332:	b113      	cbz	r3, 1033a <__do_global_dtors_aux+0x12>
   10334:	4804      	ldr	r0, [pc, #16]	; (10348 <__do_global_dtors_aux+0x20>)
   10336:	f3af 8000 	nop.w
   1033a:	2301      	movs	r3, #1
   1033c:	7023      	strb	r3, [r4, #0]
   1033e:	bd10      	pop	{r4, pc}
   10340:	10000288 	.word	0x10000288
   10344:	00000000 	.word	0x00000000
   10348:	0001afa8 	.word	0x0001afa8

0001034c <frame_dummy>:
   1034c:	b508      	push	{r3, lr}
   1034e:	4b03      	ldr	r3, [pc, #12]	; (1035c <frame_dummy+0x10>)
   10350:	b11b      	cbz	r3, 1035a <frame_dummy+0xe>
   10352:	4903      	ldr	r1, [pc, #12]	; (10360 <frame_dummy+0x14>)
   10354:	4803      	ldr	r0, [pc, #12]	; (10364 <frame_dummy+0x18>)
   10356:	f3af 8000 	nop.w
   1035a:	bd08      	pop	{r3, pc}
   1035c:	00000000 	.word	0x00000000
   10360:	1000028c 	.word	0x1000028c
   10364:	0001afa8 	.word	0x0001afa8

00010368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>:
     }};
    //inline static volatile uint32_t *stat= &(LPC_GPIOINT->IntStatus);
    
    IsrPointer LabGPIO::pin_isr_map[kPorts][kPins]={ nullptr};
    
 LabGPIO::LabGPIO(uint8_t port, uint8_t pin){
   10368:	b530      	push	{r4, r5, lr}
   1036a:	b083      	sub	sp, #12
   1036c:	4675      	mov	r5, lr
   1036e:	9001      	str	r0, [sp, #4]
   10370:	460b      	mov	r3, r1
   10372:	f88d 3003 	strb.w	r3, [sp, #3]
   10376:	4613      	mov	r3, r2
   10378:	f88d 3002 	strb.w	r3, [sp, #2]
   1037c:	462b      	mov	r3, r5
   1037e:	4619      	mov	r1, r3
   10380:	480e      	ldr	r0, [pc, #56]	; (103bc <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x54>)
   10382:	f002 ffcf 	bl	13324 <__cyg_profile_func_enter>
    SelPort = port;
   10386:	9b01      	ldr	r3, [sp, #4]
   10388:	f89d 2003 	ldrb.w	r2, [sp, #3]
   1038c:	701a      	strb	r2, [r3, #0]
    SelPin = pin;
   1038e:	9b01      	ldr	r3, [sp, #4]
   10390:	f89d 2002 	ldrb.w	r2, [sp, #2]
   10394:	705a      	strb	r2, [r3, #1]
    
    interrupt_port = (port == 2) ? 1:0;
   10396:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1039a:	2b02      	cmp	r3, #2
   1039c:	d101      	bne.n	103a2 <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x3a>
   1039e:	2201      	movs	r2, #1
   103a0:	e000      	b.n	103a4 <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x3c>
   103a2:	2200      	movs	r2, #0
   103a4:	9b01      	ldr	r3, [sp, #4]
   103a6:	709a      	strb	r2, [r3, #2]
 }
   103a8:	9c01      	ldr	r4, [sp, #4]
   103aa:	462b      	mov	r3, r5
   103ac:	4619      	mov	r1, r3
   103ae:	4803      	ldr	r0, [pc, #12]	; (103bc <LabGPIO::LabGPIO(unsigned char, unsigned char)+0x54>)
   103b0:	f002 ffcc 	bl	1334c <__cyg_profile_func_exit>
   103b4:	4623      	mov	r3, r4
   103b6:	4618      	mov	r0, r3
   103b8:	b003      	add	sp, #12
   103ba:	bd30      	pop	{r4, r5, pc}
   103bc:	00010369 	.word	0x00010369

000103c0 <LabGPIO::SetHigh()>:
    if(direction == Direction::kOutput) SetAsOutput();
    else SetAsInput();
   }
  

  void LabGPIO::SetHigh(){
   103c0:	b510      	push	{r4, lr}
   103c2:	b082      	sub	sp, #8
   103c4:	4674      	mov	r4, lr
   103c6:	9001      	str	r0, [sp, #4]
   103c8:	4623      	mov	r3, r4
   103ca:	4619      	mov	r1, r3
   103cc:	480b      	ldr	r0, [pc, #44]	; (103fc <LabGPIO::SetHigh()+0x3c>)
   103ce:	f002 ffa9 	bl	13324 <__cyg_profile_func_enter>
       /// Set voltage of pin to HIGH
        GPIO[SelPort]-> SET = (1<<SelPin);
   103d2:	9b01      	ldr	r3, [sp, #4]
   103d4:	785b      	ldrb	r3, [r3, #1]
   103d6:	461a      	mov	r2, r3
   103d8:	2301      	movs	r3, #1
   103da:	fa03 f202 	lsl.w	r2, r3, r2
   103de:	9b01      	ldr	r3, [sp, #4]
   103e0:	781b      	ldrb	r3, [r3, #0]
   103e2:	4619      	mov	r1, r3
   103e4:	4b06      	ldr	r3, [pc, #24]	; (10400 <LabGPIO::SetHigh()+0x40>)
   103e6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   103ea:	619a      	str	r2, [r3, #24]
   103ec:	4623      	mov	r3, r4
   103ee:	4619      	mov	r1, r3
   103f0:	4802      	ldr	r0, [pc, #8]	; (103fc <LabGPIO::SetHigh()+0x3c>)
   103f2:	f002 ffab 	bl	1334c <__cyg_profile_func_exit>
    
  }
   103f6:	bf00      	nop
   103f8:	b002      	add	sp, #8
   103fa:	bd10      	pop	{r4, pc}
   103fc:	000103c1 	.word	0x000103c1
   10400:	10000000 	.word	0x10000000

00010404 <LabGPIO::SetLow()>:
  void LabGPIO::SetLow(){
   10404:	b510      	push	{r4, lr}
   10406:	b082      	sub	sp, #8
   10408:	4674      	mov	r4, lr
   1040a:	9001      	str	r0, [sp, #4]
   1040c:	4623      	mov	r3, r4
   1040e:	4619      	mov	r1, r3
   10410:	480b      	ldr	r0, [pc, #44]	; (10440 <LabGPIO::SetLow()+0x3c>)
   10412:	f002 ff87 	bl	13324 <__cyg_profile_func_enter>
        /// Set voltage of pin to LOW
            GPIO[SelPort]-> CLR = (1<<SelPin);
   10416:	9b01      	ldr	r3, [sp, #4]
   10418:	785b      	ldrb	r3, [r3, #1]
   1041a:	461a      	mov	r2, r3
   1041c:	2301      	movs	r3, #1
   1041e:	fa03 f202 	lsl.w	r2, r3, r2
   10422:	9b01      	ldr	r3, [sp, #4]
   10424:	781b      	ldrb	r3, [r3, #0]
   10426:	4619      	mov	r1, r3
   10428:	4b06      	ldr	r3, [pc, #24]	; (10444 <LabGPIO::SetLow()+0x40>)
   1042a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1042e:	61da      	str	r2, [r3, #28]
   10430:	4623      	mov	r3, r4
   10432:	4619      	mov	r1, r3
   10434:	4802      	ldr	r0, [pc, #8]	; (10440 <LabGPIO::SetLow()+0x3c>)
   10436:	f002 ff89 	bl	1334c <__cyg_profile_func_exit>
   
  }
   1043a:	bf00      	nop
   1043c:	b002      	add	sp, #8
   1043e:	bd10      	pop	{r4, pc}
   10440:	00010405 	.word	0x00010405
   10444:	10000000 	.word	0x10000000

00010448 <LabGPIO::ReadBool()>:
      /// @return level of pin high => true, low => false
     
     return (GPIO[SelPort]->PIN & (1<<SelPin)) ? State::kHigh : State::kLow;
    
  }
 bool LabGPIO::ReadBool(){
   10448:	b530      	push	{r4, r5, lr}
   1044a:	b083      	sub	sp, #12
   1044c:	4675      	mov	r5, lr
   1044e:	9001      	str	r0, [sp, #4]
   10450:	462b      	mov	r3, r5
   10452:	4619      	mov	r1, r3
   10454:	480e      	ldr	r0, [pc, #56]	; (10490 <LabGPIO::ReadBool()+0x48>)
   10456:	f002 ff65 	bl	13324 <__cyg_profile_func_enter>
  /// Should return the state of the pin (input or output, doesn't matter)
  ///
  /// @return level of pin high => true, low => false
  return(GPIO[SelPort]->PIN & (1<<SelPin));
   1045a:	9b01      	ldr	r3, [sp, #4]
   1045c:	781b      	ldrb	r3, [r3, #0]
   1045e:	461a      	mov	r2, r3
   10460:	4b0c      	ldr	r3, [pc, #48]	; (10494 <LabGPIO::ReadBool()+0x4c>)
   10462:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10466:	695b      	ldr	r3, [r3, #20]
   10468:	9a01      	ldr	r2, [sp, #4]
   1046a:	7852      	ldrb	r2, [r2, #1]
   1046c:	4611      	mov	r1, r2
   1046e:	2201      	movs	r2, #1
   10470:	408a      	lsls	r2, r1
   10472:	4013      	ands	r3, r2
   10474:	2b00      	cmp	r3, #0
   10476:	bf14      	ite	ne
   10478:	2301      	movne	r3, #1
   1047a:	2300      	moveq	r3, #0
   1047c:	b2dc      	uxtb	r4, r3
   1047e:	462b      	mov	r3, r5
   10480:	4619      	mov	r1, r3
   10482:	4803      	ldr	r0, [pc, #12]	; (10490 <LabGPIO::ReadBool()+0x48>)
   10484:	f002 ff62 	bl	1334c <__cyg_profile_func_exit>
   10488:	4623      	mov	r3, r4
 
  
  }
   1048a:	4618      	mov	r0, r3
   1048c:	b003      	add	sp, #12
   1048e:	bd30      	pop	{r4, r5, pc}
   10490:	00010449 	.word	0x00010449
   10494:	10000000 	.word	0x10000000

00010498 <LabGPIO::toggle()>:
 void LabGPIO::toggle(){
   10498:	b510      	push	{r4, lr}
   1049a:	b082      	sub	sp, #8
   1049c:	4674      	mov	r4, lr
   1049e:	9001      	str	r0, [sp, #4]
   104a0:	4623      	mov	r3, r4
   104a2:	4619      	mov	r1, r3
   104a4:	480d      	ldr	r0, [pc, #52]	; (104dc <LabGPIO::toggle()+0x44>)
   104a6:	f002 ff3d 	bl	13324 <__cyg_profile_func_enter>
      if(!ReadBool())
   104aa:	9801      	ldr	r0, [sp, #4]
   104ac:	f7ff ffcc 	bl	10448 <LabGPIO::ReadBool()>
   104b0:	4603      	mov	r3, r0
   104b2:	f083 0301 	eor.w	r3, r3, #1
   104b6:	b2db      	uxtb	r3, r3
   104b8:	2b00      	cmp	r3, #0
   104ba:	d003      	beq.n	104c4 <LabGPIO::toggle()+0x2c>
           SetHigh();
   104bc:	9801      	ldr	r0, [sp, #4]
   104be:	f7ff ff7f 	bl	103c0 <LabGPIO::SetHigh()>
   104c2:	e002      	b.n	104ca <LabGPIO::toggle()+0x32>
       else SetLow();
   104c4:	9801      	ldr	r0, [sp, #4]
   104c6:	f7ff ff9d 	bl	10404 <LabGPIO::SetLow()>
   104ca:	4623      	mov	r3, r4
   104cc:	4619      	mov	r1, r3
   104ce:	4803      	ldr	r0, [pc, #12]	; (104dc <LabGPIO::toggle()+0x44>)
   104d0:	f002 ff3c 	bl	1334c <__cyg_profile_func_exit>
   
  }
   104d4:	bf00      	nop
   104d6:	b002      	add	sp, #8
   104d8:	bd10      	pop	{r4, pc}
   104da:	bf00      	nop
   104dc:	00010499 	.word	0x00010499

000104e0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>:
    pc->pc_inactive(SelPort, SelPin);
  }
void LabGPIO::setRepeater(){
   pc->pc_repeater(SelPort, SelPin);
  }
 void LabGPIO::AttachInterruptHandler(IsrPointer isr, Edge edge){
   104e0:	b510      	push	{r4, lr}
   104e2:	b084      	sub	sp, #16
   104e4:	4674      	mov	r4, lr
   104e6:	9003      	str	r0, [sp, #12]
   104e8:	9102      	str	r1, [sp, #8]
   104ea:	9201      	str	r2, [sp, #4]
   104ec:	4623      	mov	r3, r4
   104ee:	4619      	mov	r1, r3
   104f0:	480d      	ldr	r0, [pc, #52]	; (10528 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x48>)
   104f2:	f002 ff17 	bl	13324 <__cyg_profile_func_enter>
    pin_isr_map[interrupt_port][SelPin]=isr;
   104f6:	9b03      	ldr	r3, [sp, #12]
   104f8:	789b      	ldrb	r3, [r3, #2]
   104fa:	4618      	mov	r0, r3
   104fc:	9b03      	ldr	r3, [sp, #12]
   104fe:	785b      	ldrb	r3, [r3, #1]
   10500:	461a      	mov	r2, r3
   10502:	490a      	ldr	r1, [pc, #40]	; (1052c <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x4c>)
   10504:	0143      	lsls	r3, r0, #5
   10506:	4413      	add	r3, r2
   10508:	9a02      	ldr	r2, [sp, #8]
   1050a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    //printf("%i %i\n",interrupt_port,SelPin);
    IntEdge(edge);
   1050e:	9901      	ldr	r1, [sp, #4]
   10510:	9803      	ldr	r0, [sp, #12]
   10512:	f000 f88b 	bl	1062c <LabGPIO::IntEdge(LabGPIO::Edge)>
   10516:	4623      	mov	r3, r4
   10518:	4619      	mov	r1, r3
   1051a:	4803      	ldr	r0, [pc, #12]	; (10528 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)+0x48>)
   1051c:	f002 ff16 	bl	1334c <__cyg_profile_func_exit>
  
 }
   10520:	bf00      	nop
   10522:	b004      	add	sp, #16
   10524:	bd10      	pop	{r4, pc}
   10526:	bf00      	nop
   10528:	000104e1 	.word	0x000104e1
   1052c:	100002a4 	.word	0x100002a4

00010530 <LabGPIO::GpioInterruptHandler()>:
 void LabGPIO::GpioInterruptHandler(){
   10530:	b510      	push	{r4, lr}
   10532:	b082      	sub	sp, #8
   10534:	4674      	mov	r4, lr
   10536:	4623      	mov	r3, r4
   10538:	4619      	mov	r1, r3
   1053a:	482c      	ldr	r0, [pc, #176]	; (105ec <LabGPIO::GpioInterruptHandler()+0xbc>)
   1053c:	f002 fef2 	bl	13324 <__cyg_profile_func_enter>
    uint32_t selPin_local;

  
    if((LPC_GPIOINT->IO0IntStatR) | (LPC_GPIOINT->IO0IntStatF)){
   10540:	4b2b      	ldr	r3, [pc, #172]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10542:	685a      	ldr	r2, [r3, #4]
   10544:	4b2a      	ldr	r3, [pc, #168]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10546:	689b      	ldr	r3, [r3, #8]
   10548:	4313      	orrs	r3, r2
   1054a:	2b00      	cmp	r3, #0
   1054c:	bf14      	ite	ne
   1054e:	2301      	movne	r3, #1
   10550:	2300      	moveq	r3, #0
   10552:	b2db      	uxtb	r3, r3
   10554:	2b00      	cmp	r3, #0
   10556:	d019      	beq.n	1058c <LabGPIO::GpioInterruptHandler()+0x5c>
    selPin_local = __builtin_ctz(LPC_GPIOINT->IO0IntStatR | LPC_GPIOINT->IO0IntStatF);
   10558:	4b25      	ldr	r3, [pc, #148]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   1055a:	685a      	ldr	r2, [r3, #4]
   1055c:	4b24      	ldr	r3, [pc, #144]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   1055e:	689b      	ldr	r3, [r3, #8]
   10560:	4313      	orrs	r3, r2
   10562:	fa93 f3a3 	rbit	r3, r3
   10566:	fab3 f383 	clz	r3, r3
   1056a:	9301      	str	r3, [sp, #4]
    //printf("%i\n",selPin_local);
    pin_isr_map[0][selPin_local]();
   1056c:	4a21      	ldr	r2, [pc, #132]	; (105f4 <LabGPIO::GpioInterruptHandler()+0xc4>)
   1056e:	9b01      	ldr	r3, [sp, #4]
   10570:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10574:	4798      	blx	r3
    LPC_GPIOINT -> IO0IntClr &= ~(1<< selPin_local);
   10576:	4b1e      	ldr	r3, [pc, #120]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10578:	68db      	ldr	r3, [r3, #12]
   1057a:	2101      	movs	r1, #1
   1057c:	9a01      	ldr	r2, [sp, #4]
   1057e:	fa01 f202 	lsl.w	r2, r1, r2
   10582:	43d2      	mvns	r2, r2
   10584:	4611      	mov	r1, r2
   10586:	4a1a      	ldr	r2, [pc, #104]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10588:	400b      	ands	r3, r1
   1058a:	60d3      	str	r3, [r2, #12]
    }
    
   
  
    if((LPC_GPIOINT->IO2IntStatR) | (LPC_GPIOINT->IO2IntStatF)) {
   1058c:	4b18      	ldr	r3, [pc, #96]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   1058e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   10590:	4b17      	ldr	r3, [pc, #92]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   10592:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   10594:	4313      	orrs	r3, r2
   10596:	2b00      	cmp	r3, #0
   10598:	bf14      	ite	ne
   1059a:	2301      	movne	r3, #1
   1059c:	2300      	moveq	r3, #0
   1059e:	b2db      	uxtb	r3, r3
   105a0:	2b00      	cmp	r3, #0
   105a2:	d01a      	beq.n	105da <LabGPIO::GpioInterruptHandler()+0xaa>
    selPin_local = __builtin_ctz((LPC_GPIOINT->IO2IntStatR)|(LPC_GPIOINT->IO2IntStatF));
   105a4:	4b12      	ldr	r3, [pc, #72]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105a6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   105a8:	4b11      	ldr	r3, [pc, #68]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   105ac:	4313      	orrs	r3, r2
   105ae:	fa93 f3a3 	rbit	r3, r3
   105b2:	fab3 f383 	clz	r3, r3
   105b6:	9301      	str	r3, [sp, #4]
    pin_isr_map[1][selPin_local]();
   105b8:	4a0e      	ldr	r2, [pc, #56]	; (105f4 <LabGPIO::GpioInterruptHandler()+0xc4>)
   105ba:	9b01      	ldr	r3, [sp, #4]
   105bc:	3320      	adds	r3, #32
   105be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   105c2:	4798      	blx	r3
    LPC_GPIOINT -> IO2IntClr &= ~(1<< selPin_local);
   105c4:	4b0a      	ldr	r3, [pc, #40]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   105c8:	2101      	movs	r1, #1
   105ca:	9a01      	ldr	r2, [sp, #4]
   105cc:	fa01 f202 	lsl.w	r2, r1, r2
   105d0:	43d2      	mvns	r2, r2
   105d2:	4611      	mov	r1, r2
   105d4:	4a06      	ldr	r2, [pc, #24]	; (105f0 <LabGPIO::GpioInterruptHandler()+0xc0>)
   105d6:	400b      	ands	r3, r1
   105d8:	62d3      	str	r3, [r2, #44]	; 0x2c
   105da:	4623      	mov	r3, r4
   105dc:	4619      	mov	r1, r3
   105de:	4803      	ldr	r0, [pc, #12]	; (105ec <LabGPIO::GpioInterruptHandler()+0xbc>)
   105e0:	f002 feb4 	bl	1334c <__cyg_profile_func_exit>
    }
 }
   105e4:	bf00      	nop
   105e6:	b002      	add	sp, #8
   105e8:	bd10      	pop	{r4, pc}
   105ea:	bf00      	nop
   105ec:	00010531 	.word	0x00010531
   105f0:	40028080 	.word	0x40028080
   105f4:	100002a4 	.word	0x100002a4

000105f8 <LabGPIO::EnableInterrupts()>:
 
void LabGPIO::EnableInterrupts(){
   105f8:	b510      	push	{r4, lr}
   105fa:	4674      	mov	r4, lr
   105fc:	4623      	mov	r3, r4
   105fe:	4619      	mov	r1, r3
   10600:	4808      	ldr	r0, [pc, #32]	; (10624 <LabGPIO::EnableInterrupts()+0x2c>)
   10602:	f002 fe8f 	bl	13324 <__cyg_profile_func_enter>
  // Register GPIO_IRQn here
        RegisterIsr(GPIO_IRQn, GpioInterruptHandler );
   10606:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1060a:	2201      	movs	r2, #1
   1060c:	4906      	ldr	r1, [pc, #24]	; (10628 <LabGPIO::EnableInterrupts()+0x30>)
   1060e:	2026      	movs	r0, #38	; 0x26
   10610:	f002 fd34 	bl	1307c <RegisterIsr(IRQn, void (*)(), bool, long)>
   10614:	4623      	mov	r3, r4
   10616:	4619      	mov	r1, r3
   10618:	4802      	ldr	r0, [pc, #8]	; (10624 <LabGPIO::EnableInterrupts()+0x2c>)
   1061a:	f002 fe97 	bl	1334c <__cyg_profile_func_exit>
 }
   1061e:	bf00      	nop
   10620:	bd10      	pop	{r4, pc}
   10622:	bf00      	nop
   10624:	000105f9 	.word	0x000105f9
   10628:	00010531 	.word	0x00010531

0001062c <LabGPIO::IntEdge(LabGPIO::Edge)>:
 
 void LabGPIO::IntEdge(Edge edge){
   1062c:	b510      	push	{r4, lr}
   1062e:	b082      	sub	sp, #8
   10630:	4674      	mov	r4, lr
   10632:	9001      	str	r0, [sp, #4]
   10634:	9100      	str	r1, [sp, #0]
   10636:	4623      	mov	r3, r4
   10638:	4619      	mov	r1, r3
   1063a:	4817      	ldr	r0, [pc, #92]	; (10698 <LabGPIO::IntEdge(LabGPIO::Edge)+0x6c>)
   1063c:	f002 fe72 	bl	13324 <__cyg_profile_func_enter>
    switch(edge)
   10640:	9b00      	ldr	r3, [sp, #0]
   10642:	2b03      	cmp	r3, #3
   10644:	d820      	bhi.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
   10646:	a201      	add	r2, pc, #4	; (adr r2, 1064c <LabGPIO::IntEdge(LabGPIO::Edge)+0x20>)
   10648:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1064c:	0001065d 	.word	0x0001065d
   10650:	0001066b 	.word	0x0001066b
   10654:	00010673 	.word	0x00010673
   10658:	0001067b 	.word	0x0001067b
    {   case Edge::kNone:
                LOG_INFO("No edge selected");
   1065c:	2389      	movs	r3, #137	; 0x89
   1065e:	4a0f      	ldr	r2, [pc, #60]	; (1069c <LabGPIO::IntEdge(LabGPIO::Edge)+0x70>)
   10660:	490f      	ldr	r1, [pc, #60]	; (106a0 <LabGPIO::IntEdge(LabGPIO::Edge)+0x74>)
   10662:	4810      	ldr	r0, [pc, #64]	; (106a4 <LabGPIO::IntEdge(LabGPIO::Edge)+0x78>)
   10664:	f005 fbfa 	bl	15e5c <printf>
                break;
   10668:	e00e      	b.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
        case Edge::kRising:
            setRisingEdge();
   1066a:	9801      	ldr	r0, [sp, #4]
   1066c:	f000 f844 	bl	106f8 <LabGPIO::setRisingEdge()>
            break;
   10670:	e00a      	b.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
        case Edge::kFalling:
            setFallingEdge();
   10672:	9801      	ldr	r0, [sp, #4]
   10674:	f000 f818 	bl	106a8 <LabGPIO::setFallingEdge()>
            break;
   10678:	e006      	b.n	10688 <LabGPIO::IntEdge(LabGPIO::Edge)+0x5c>
        case Edge::kBoth:
            setRisingEdge();
   1067a:	9801      	ldr	r0, [sp, #4]
   1067c:	f000 f83c 	bl	106f8 <LabGPIO::setRisingEdge()>
            setFallingEdge();
   10680:	9801      	ldr	r0, [sp, #4]
   10682:	f000 f811 	bl	106a8 <LabGPIO::setFallingEdge()>
            break;   
   10686:	bf00      	nop
   10688:	4623      	mov	r3, r4
   1068a:	4619      	mov	r1, r3
   1068c:	4802      	ldr	r0, [pc, #8]	; (10698 <LabGPIO::IntEdge(LabGPIO::Edge)+0x6c>)
   1068e:	f002 fe5d 	bl	1334c <__cyg_profile_func_exit>
    }
 }
   10692:	bf00      	nop
   10694:	b002      	add	sp, #8
   10696:	bd10      	pop	{r4, pc}
   10698:	0001062d 	.word	0x0001062d
   1069c:	00018df0 	.word	0x00018df0
   106a0:	00018d98 	.word	0x00018d98
   106a4:	00018da4 	.word	0x00018da4

000106a8 <LabGPIO::setFallingEdge()>:
 void LabGPIO::setFallingEdge(){
   106a8:	b510      	push	{r4, lr}
   106aa:	b082      	sub	sp, #8
   106ac:	4674      	mov	r4, lr
   106ae:	9001      	str	r0, [sp, #4]
   106b0:	4623      	mov	r3, r4
   106b2:	4619      	mov	r1, r3
   106b4:	480e      	ldr	r0, [pc, #56]	; (106f0 <LabGPIO::setFallingEdge()+0x48>)
   106b6:	f002 fe35 	bl	13324 <__cyg_profile_func_enter>
    *interrupts[interrupt_port][4] = (1<<SelPin);
   106ba:	9b01      	ldr	r3, [sp, #4]
   106bc:	785b      	ldrb	r3, [r3, #1]
   106be:	461a      	mov	r2, r3
   106c0:	2301      	movs	r3, #1
   106c2:	fa03 f002 	lsl.w	r0, r3, r2
   106c6:	9b01      	ldr	r3, [sp, #4]
   106c8:	789b      	ldrb	r3, [r3, #2]
   106ca:	4619      	mov	r1, r3
   106cc:	4a09      	ldr	r2, [pc, #36]	; (106f4 <LabGPIO::setFallingEdge()+0x4c>)
   106ce:	460b      	mov	r3, r1
   106d0:	009b      	lsls	r3, r3, #2
   106d2:	440b      	add	r3, r1
   106d4:	009b      	lsls	r3, r3, #2
   106d6:	4413      	add	r3, r2
   106d8:	3310      	adds	r3, #16
   106da:	681b      	ldr	r3, [r3, #0]
   106dc:	4602      	mov	r2, r0
   106de:	601a      	str	r2, [r3, #0]
   106e0:	4623      	mov	r3, r4
   106e2:	4619      	mov	r1, r3
   106e4:	4802      	ldr	r0, [pc, #8]	; (106f0 <LabGPIO::setFallingEdge()+0x48>)
   106e6:	f002 fe31 	bl	1334c <__cyg_profile_func_exit>
 }
   106ea:	bf00      	nop
   106ec:	b002      	add	sp, #8
   106ee:	bd10      	pop	{r4, pc}
   106f0:	000106a9 	.word	0x000106a9
   106f4:	10000018 	.word	0x10000018

000106f8 <LabGPIO::setRisingEdge()>:
 void LabGPIO::setRisingEdge(){
   106f8:	b510      	push	{r4, lr}
   106fa:	b082      	sub	sp, #8
   106fc:	4674      	mov	r4, lr
   106fe:	9001      	str	r0, [sp, #4]
   10700:	4623      	mov	r3, r4
   10702:	4619      	mov	r1, r3
   10704:	480e      	ldr	r0, [pc, #56]	; (10740 <LabGPIO::setRisingEdge()+0x48>)
   10706:	f002 fe0d 	bl	13324 <__cyg_profile_func_enter>
    *interrupts[interrupt_port][3] = (1<<SelPin);
   1070a:	9b01      	ldr	r3, [sp, #4]
   1070c:	785b      	ldrb	r3, [r3, #1]
   1070e:	461a      	mov	r2, r3
   10710:	2301      	movs	r3, #1
   10712:	fa03 f002 	lsl.w	r0, r3, r2
   10716:	9b01      	ldr	r3, [sp, #4]
   10718:	789b      	ldrb	r3, [r3, #2]
   1071a:	4619      	mov	r1, r3
   1071c:	4a09      	ldr	r2, [pc, #36]	; (10744 <LabGPIO::setRisingEdge()+0x4c>)
   1071e:	460b      	mov	r3, r1
   10720:	009b      	lsls	r3, r3, #2
   10722:	440b      	add	r3, r1
   10724:	009b      	lsls	r3, r3, #2
   10726:	4413      	add	r3, r2
   10728:	330c      	adds	r3, #12
   1072a:	681b      	ldr	r3, [r3, #0]
   1072c:	4602      	mov	r2, r0
   1072e:	601a      	str	r2, [r3, #0]
   10730:	4623      	mov	r3, r4
   10732:	4619      	mov	r1, r3
   10734:	4802      	ldr	r0, [pc, #8]	; (10740 <LabGPIO::setRisingEdge()+0x48>)
   10736:	f002 fe09 	bl	1334c <__cyg_profile_func_exit>
 }
   1073a:	bf00      	nop
   1073c:	b002      	add	sp, #8
   1073e:	bd10      	pop	{r4, pc}
   10740:	000106f9 	.word	0x000106f9
   10744:	10000018 	.word	0x10000018

00010748 <(anonymous namespace)::DefaultUptime()>:
{
// uptime in nanoseconds
inline uint64_t uptime = 0;
// Returns the system uptime in nanoseconds, do not use this function directly
[[gnu::always_inline]] inline uint64_t DefaultUptime()
{
   10748:	b570      	push	{r4, r5, r6, lr}
   1074a:	4676      	mov	r6, lr
   1074c:	4633      	mov	r3, r6
   1074e:	4619      	mov	r1, r3
   10750:	4807      	ldr	r0, [pc, #28]	; (10770 <(anonymous namespace)::DefaultUptime()+0x28>)
   10752:	f002 fde7 	bl	13324 <__cyg_profile_func_enter>
  return uptime;
   10756:	4b07      	ldr	r3, [pc, #28]	; (10774 <(anonymous namespace)::DefaultUptime()+0x2c>)
   10758:	e9d3 4500 	ldrd	r4, r5, [r3]
   1075c:	4633      	mov	r3, r6
   1075e:	4619      	mov	r1, r3
   10760:	4803      	ldr	r0, [pc, #12]	; (10770 <(anonymous namespace)::DefaultUptime()+0x28>)
   10762:	f002 fdf3 	bl	1334c <__cyg_profile_func_exit>
   10766:	4623      	mov	r3, r4
   10768:	462c      	mov	r4, r5
}
   1076a:	4618      	mov	r0, r3
   1076c:	4621      	mov	r1, r4
   1076e:	bd70      	pop	{r4, r5, r6, pc}
   10770:	00010749 	.word	0x00010749
   10774:	100003a8 	.word	0x100003a8

00010778 <Milliseconds()>:
{
  Uptime = uptime_function;
}
// Get system uptime in milliseconds as a 64-bit integer
inline uint64_t Milliseconds()
{
   10778:	b570      	push	{r4, r5, r6, lr}
   1077a:	4674      	mov	r4, lr
   1077c:	4623      	mov	r3, r4
   1077e:	4619      	mov	r1, r3
   10780:	480c      	ldr	r0, [pc, #48]	; (107b4 <Milliseconds()+0x3c>)
   10782:	f002 fdcf 	bl	13324 <__cyg_profile_func_enter>
  return Uptime() / 1'000;
   10786:	4b0c      	ldr	r3, [pc, #48]	; (107b8 <Milliseconds()+0x40>)
   10788:	681b      	ldr	r3, [r3, #0]
   1078a:	4798      	blx	r3
   1078c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10790:	f04f 0300 	mov.w	r3, #0
   10794:	f008 f832 	bl	187fc <__aeabi_uldivmod>
   10798:	4602      	mov	r2, r0
   1079a:	460b      	mov	r3, r1
   1079c:	4615      	mov	r5, r2
   1079e:	461e      	mov	r6, r3
   107a0:	4623      	mov	r3, r4
   107a2:	4619      	mov	r1, r3
   107a4:	4803      	ldr	r0, [pc, #12]	; (107b4 <Milliseconds()+0x3c>)
   107a6:	f002 fdd1 	bl	1334c <__cyg_profile_func_exit>
   107aa:	462b      	mov	r3, r5
   107ac:	4634      	mov	r4, r6
}
   107ae:	4618      	mov	r0, r3
   107b0:	4621      	mov	r1, r4
   107b2:	bd70      	pop	{r4, r5, r6, pc}
   107b4:	00010779 	.word	0x00010779
   107b8:	10000040 	.word	0x10000040

000107bc <Wait(unsigned long long)::{lambda()#1}::operator()() const>:
  return status;
}

inline Status Wait(uint64_t timeout)
{
  return Wait(timeout, []() -> bool { return false; });
   107bc:	b530      	push	{r4, r5, lr}
   107be:	b083      	sub	sp, #12
   107c0:	4675      	mov	r5, lr
   107c2:	9001      	str	r0, [sp, #4]
   107c4:	462b      	mov	r3, r5
   107c6:	4619      	mov	r1, r3
   107c8:	4806      	ldr	r0, [pc, #24]	; (107e4 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   107ca:	f002 fdab 	bl	13324 <__cyg_profile_func_enter>
   107ce:	2400      	movs	r4, #0
   107d0:	462b      	mov	r3, r5
   107d2:	4619      	mov	r1, r3
   107d4:	4803      	ldr	r0, [pc, #12]	; (107e4 <Wait(unsigned long long)::{lambda()#1}::operator()() const+0x28>)
   107d6:	f002 fdb9 	bl	1334c <__cyg_profile_func_exit>
   107da:	4623      	mov	r3, r4
   107dc:	4618      	mov	r0, r3
   107de:	b003      	add	sp, #12
   107e0:	bd30      	pop	{r4, r5, pc}
   107e2:	bf00      	nop
   107e4:	000107bd 	.word	0x000107bd

000107e8 <Wait(unsigned long long)::{lambda()#1}::_FUN()>:
   107e8:	b538      	push	{r3, r4, r5, lr}
   107ea:	4674      	mov	r4, lr
   107ec:	4623      	mov	r3, r4
   107ee:	4619      	mov	r1, r3
   107f0:	4807      	ldr	r0, [pc, #28]	; (10810 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   107f2:	f002 fd97 	bl	13324 <__cyg_profile_func_enter>
   107f6:	2000      	movs	r0, #0
   107f8:	f7ff ffe0 	bl	107bc <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   107fc:	4603      	mov	r3, r0
   107fe:	461d      	mov	r5, r3
   10800:	4623      	mov	r3, r4
   10802:	4619      	mov	r1, r3
   10804:	4802      	ldr	r0, [pc, #8]	; (10810 <Wait(unsigned long long)::{lambda()#1}::_FUN()+0x28>)
   10806:	f002 fda1 	bl	1334c <__cyg_profile_func_exit>
   1080a:	462b      	mov	r3, r5
   1080c:	4618      	mov	r0, r3
   1080e:	bd38      	pop	{r3, r4, r5, pc}
   10810:	000107e9 	.word	0x000107e9

00010814 <Wait(unsigned long long)>:
{
   10814:	b5f0      	push	{r4, r5, r6, r7, lr}
   10816:	b089      	sub	sp, #36	; 0x24
   10818:	4675      	mov	r5, lr
   1081a:	e9cd 0100 	strd	r0, r1, [sp]
   1081e:	462b      	mov	r3, r5
   10820:	4619      	mov	r1, r3
   10822:	482b      	ldr	r0, [pc, #172]	; (108d0 <Wait(unsigned long long)+0xbc>)
   10824:	f002 fd7e 	bl	13324 <__cyg_profile_func_enter>
   10828:	e9dd 3400 	ldrd	r3, r4, [sp]
   1082c:	e9cd 3406 	strd	r3, r4, [sp, #24]
   10830:	f88d 6008 	strb.w	r6, [sp, #8]
   10834:	462b      	mov	r3, r5
   10836:	4619      	mov	r1, r3
   10838:	4826      	ldr	r0, [pc, #152]	; (108d4 <Wait(unsigned long long)+0xc0>)
   1083a:	f002 fd73 	bl	13324 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   1083e:	f04f 0300 	mov.w	r3, #0
   10842:	f04f 0400 	mov.w	r4, #0
   10846:	e9cd 3404 	strd	r3, r4, [sp, #16]
  if (timeout == kMaxWait)
   1084a:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   1084e:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   10852:	bf08      	it	eq
   10854:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   10858:	d106      	bne.n	10868 <Wait(unsigned long long)+0x54>
    timeout_time = kMaxWait;
   1085a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1085e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   10862:	e9cd 3404 	strd	r3, r4, [sp, #16]
   10866:	e00a      	b.n	1087e <Wait(unsigned long long)+0x6a>
    timeout_time = Milliseconds() + timeout;
   10868:	f7ff ff86 	bl	10778 <Milliseconds()>
   1086c:	460a      	mov	r2, r1
   1086e:	4601      	mov	r1, r0
   10870:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   10874:	185e      	adds	r6, r3, r1
   10876:	eb44 0702 	adc.w	r7, r4, r2
   1087a:	e9cd 6704 	strd	r6, r7, [sp, #16]
  Status status = Status::kTimedOut;
   1087e:	2301      	movs	r3, #1
   10880:	9303      	str	r3, [sp, #12]
  while (Milliseconds() < timeout_time)
   10882:	f7ff ff79 	bl	10778 <Milliseconds()>
   10886:	460a      	mov	r2, r1
   10888:	4601      	mov	r1, r0
   1088a:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   1088e:	42a2      	cmp	r2, r4
   10890:	bf08      	it	eq
   10892:	4299      	cmpeq	r1, r3
   10894:	bf34      	ite	cc
   10896:	2301      	movcc	r3, #1
   10898:	2300      	movcs	r3, #0
   1089a:	b2db      	uxtb	r3, r3
   1089c:	2b00      	cmp	r3, #0
   1089e:	d008      	beq.n	108b2 <Wait(unsigned long long)+0x9e>
    if (is_done())
   108a0:	ab02      	add	r3, sp, #8
   108a2:	4618      	mov	r0, r3
   108a4:	f7ff ff8a 	bl	107bc <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   108a8:	4603      	mov	r3, r0
   108aa:	2b00      	cmp	r3, #0
   108ac:	d0e9      	beq.n	10882 <Wait(unsigned long long)+0x6e>
      status = Status::kSuccess;
   108ae:	2300      	movs	r3, #0
   108b0:	9303      	str	r3, [sp, #12]
  return status;
   108b2:	9c03      	ldr	r4, [sp, #12]
   108b4:	462b      	mov	r3, r5
   108b6:	4619      	mov	r1, r3
   108b8:	4806      	ldr	r0, [pc, #24]	; (108d4 <Wait(unsigned long long)+0xc0>)
   108ba:	f002 fd47 	bl	1334c <__cyg_profile_func_exit>
   108be:	462b      	mov	r3, r5
   108c0:	4619      	mov	r1, r3
   108c2:	4803      	ldr	r0, [pc, #12]	; (108d0 <Wait(unsigned long long)+0xbc>)
   108c4:	f002 fd42 	bl	1334c <__cyg_profile_func_exit>
  return Wait(timeout, []() -> bool { return false; });
   108c8:	4623      	mov	r3, r4
}
   108ca:	4618      	mov	r0, r3
   108cc:	b009      	add	sp, #36	; 0x24
   108ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   108d0:	00010815 	.word	0x00010815
   108d4:	00010c89 	.word	0x00010c89

000108d8 <Delay(unsigned long long)>:

// Delay the system for a duration of time
inline void Delay([[maybe_unused]] uint64_t delay_time_ms)
{
   108d8:	b510      	push	{r4, lr}
   108da:	b082      	sub	sp, #8
   108dc:	4674      	mov	r4, lr
   108de:	e9cd 0100 	strd	r0, r1, [sp]
   108e2:	4623      	mov	r3, r4
   108e4:	4619      	mov	r1, r3
   108e6:	4807      	ldr	r0, [pc, #28]	; (10904 <Delay(unsigned long long)+0x2c>)
   108e8:	f002 fd1c 	bl	13324 <__cyg_profile_func_enter>
#if defined(HOST_TEST)
  return;
#else
  Wait(delay_time_ms);
   108ec:	e9dd 0100 	ldrd	r0, r1, [sp]
   108f0:	f7ff ff90 	bl	10814 <Wait(unsigned long long)>
   108f4:	4623      	mov	r3, r4
   108f6:	4619      	mov	r1, r3
   108f8:	4802      	ldr	r0, [pc, #8]	; (10904 <Delay(unsigned long long)+0x2c>)
   108fa:	f002 fd27 	bl	1334c <__cyg_profile_func_exit>
#endif  // HOST_TEST
}
   108fe:	bf00      	nop
   10900:	b002      	add	sp, #8
   10902:	bd10      	pop	{r4, pc}
   10904:	000108d9 	.word	0x000108d9

00010908 <Gpio::SetHigh()>:
  inline void SetDirection(Direction direction) override
  {
    (direction) ? SetAsOutput() : SetAsInput();
  }
  // Sets the GPIO output pin to high
  void SetHigh(void) override
   10908:	b530      	push	{r4, r5, lr}
   1090a:	b083      	sub	sp, #12
   1090c:	4675      	mov	r5, lr
   1090e:	9001      	str	r0, [sp, #4]
   10910:	462b      	mov	r3, r5
   10912:	4619      	mov	r1, r3
   10914:	4813      	ldr	r0, [pc, #76]	; (10964 <Gpio::SetHigh()+0x5c>)
   10916:	f002 fd05 	bl	13324 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->SET = (1 << pin_->GetPin());
   1091a:	9b01      	ldr	r3, [sp, #4]
   1091c:	689a      	ldr	r2, [r3, #8]
   1091e:	9b01      	ldr	r3, [sp, #4]
   10920:	689b      	ldr	r3, [r3, #8]
   10922:	681b      	ldr	r3, [r3, #0]
   10924:	3330      	adds	r3, #48	; 0x30
   10926:	681b      	ldr	r3, [r3, #0]
   10928:	4610      	mov	r0, r2
   1092a:	4798      	blx	r3
   1092c:	4603      	mov	r3, r0
   1092e:	461a      	mov	r2, r3
   10930:	2301      	movs	r3, #1
   10932:	4093      	lsls	r3, r2
   10934:	461c      	mov	r4, r3
   10936:	9b01      	ldr	r3, [sp, #4]
   10938:	689a      	ldr	r2, [r3, #8]
   1093a:	9b01      	ldr	r3, [sp, #4]
   1093c:	689b      	ldr	r3, [r3, #8]
   1093e:	681b      	ldr	r3, [r3, #0]
   10940:	332c      	adds	r3, #44	; 0x2c
   10942:	681b      	ldr	r3, [r3, #0]
   10944:	4610      	mov	r0, r2
   10946:	4798      	blx	r3
   10948:	4603      	mov	r3, r0
   1094a:	461a      	mov	r2, r3
   1094c:	4b06      	ldr	r3, [pc, #24]	; (10968 <Gpio::SetHigh()+0x60>)
   1094e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10952:	619c      	str	r4, [r3, #24]
   10954:	462b      	mov	r3, r5
   10956:	4619      	mov	r1, r3
   10958:	4802      	ldr	r0, [pc, #8]	; (10964 <Gpio::SetHigh()+0x5c>)
   1095a:	f002 fcf7 	bl	1334c <__cyg_profile_func_exit>
  }
   1095e:	bf00      	nop
   10960:	b003      	add	sp, #12
   10962:	bd30      	pop	{r4, r5, pc}
   10964:	00010909 	.word	0x00010909
   10968:	10000044 	.word	0x10000044

0001096c <Gpio::SetLow()>:
  // Sets the GPIO output pin to low
  void SetLow(void) override
   1096c:	b530      	push	{r4, r5, lr}
   1096e:	b083      	sub	sp, #12
   10970:	4675      	mov	r5, lr
   10972:	9001      	str	r0, [sp, #4]
   10974:	462b      	mov	r3, r5
   10976:	4619      	mov	r1, r3
   10978:	4813      	ldr	r0, [pc, #76]	; (109c8 <Gpio::SetLow()+0x5c>)
   1097a:	f002 fcd3 	bl	13324 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->CLR = (1 << pin_->GetPin());
   1097e:	9b01      	ldr	r3, [sp, #4]
   10980:	689a      	ldr	r2, [r3, #8]
   10982:	9b01      	ldr	r3, [sp, #4]
   10984:	689b      	ldr	r3, [r3, #8]
   10986:	681b      	ldr	r3, [r3, #0]
   10988:	3330      	adds	r3, #48	; 0x30
   1098a:	681b      	ldr	r3, [r3, #0]
   1098c:	4610      	mov	r0, r2
   1098e:	4798      	blx	r3
   10990:	4603      	mov	r3, r0
   10992:	461a      	mov	r2, r3
   10994:	2301      	movs	r3, #1
   10996:	4093      	lsls	r3, r2
   10998:	461c      	mov	r4, r3
   1099a:	9b01      	ldr	r3, [sp, #4]
   1099c:	689a      	ldr	r2, [r3, #8]
   1099e:	9b01      	ldr	r3, [sp, #4]
   109a0:	689b      	ldr	r3, [r3, #8]
   109a2:	681b      	ldr	r3, [r3, #0]
   109a4:	332c      	adds	r3, #44	; 0x2c
   109a6:	681b      	ldr	r3, [r3, #0]
   109a8:	4610      	mov	r0, r2
   109aa:	4798      	blx	r3
   109ac:	4603      	mov	r3, r0
   109ae:	461a      	mov	r2, r3
   109b0:	4b06      	ldr	r3, [pc, #24]	; (109cc <Gpio::SetLow()+0x60>)
   109b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   109b6:	61dc      	str	r4, [r3, #28]
   109b8:	462b      	mov	r3, r5
   109ba:	4619      	mov	r1, r3
   109bc:	4802      	ldr	r0, [pc, #8]	; (109c8 <Gpio::SetLow()+0x5c>)
   109be:	f002 fcc5 	bl	1334c <__cyg_profile_func_exit>
  }
   109c2:	bf00      	nop
   109c4:	b003      	add	sp, #12
   109c6:	bd30      	pop	{r4, r5, pc}
   109c8:	0001096d 	.word	0x0001096d
   109cc:	10000044 	.word	0x10000044

000109d0 <Gpio::Set(GpioInterface::State)>:
  // Sets the GPIO output pin to high or low depending on the State enum
  // parameter
  void Set(State output = kHigh) override
   109d0:	b510      	push	{r4, lr}
   109d2:	b082      	sub	sp, #8
   109d4:	4674      	mov	r4, lr
   109d6:	9001      	str	r0, [sp, #4]
   109d8:	460b      	mov	r3, r1
   109da:	f88d 3003 	strb.w	r3, [sp, #3]
   109de:	4623      	mov	r3, r4
   109e0:	4619      	mov	r1, r3
   109e2:	480b      	ldr	r0, [pc, #44]	; (10a10 <Gpio::Set(GpioInterface::State)+0x40>)
   109e4:	f002 fc9e 	bl	13324 <__cyg_profile_func_enter>
  {
    (output) ? SetHigh() : SetLow();
   109e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
   109ec:	2b00      	cmp	r3, #0
   109ee:	d003      	beq.n	109f8 <Gpio::Set(GpioInterface::State)+0x28>
   109f0:	9801      	ldr	r0, [sp, #4]
   109f2:	f7ff ff89 	bl	10908 <Gpio::SetHigh()>
   109f6:	e002      	b.n	109fe <Gpio::Set(GpioInterface::State)+0x2e>
   109f8:	9801      	ldr	r0, [sp, #4]
   109fa:	f7ff ffb7 	bl	1096c <Gpio::SetLow()>
   109fe:	4623      	mov	r3, r4
   10a00:	4619      	mov	r1, r3
   10a02:	4803      	ldr	r0, [pc, #12]	; (10a10 <Gpio::Set(GpioInterface::State)+0x40>)
   10a04:	f002 fca2 	bl	1334c <__cyg_profile_func_exit>
  }
   10a08:	bf00      	nop
   10a0a:	b002      	add	sp, #8
   10a0c:	bd10      	pop	{r4, pc}
   10a0e:	bf00      	nop
   10a10:	000109d1 	.word	0x000109d1

00010a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>:
//
// @param enum_type_value variable you would like to get the value of.
// @return the value of the enum class type variable of with the underlying
//         type of the enum class.
template <typename Enum, typename Type = typename std::underlying_type_t<Enum>>
constexpr Type Value(Enum enum_type_value)
   10a14:	b530      	push	{r4, r5, lr}
   10a16:	b083      	sub	sp, #12
   10a18:	4675      	mov	r5, lr
   10a1a:	9001      	str	r0, [sp, #4]
   10a1c:	462b      	mov	r3, r5
   10a1e:	4619      	mov	r1, r3
   10a20:	4806      	ldr	r0, [pc, #24]	; (10a3c <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   10a22:	f002 fc7f 	bl	13324 <__cyg_profile_func_enter>
{
  return static_cast<Type>(enum_type_value);
   10a26:	9c01      	ldr	r4, [sp, #4]
   10a28:	462b      	mov	r3, r5
   10a2a:	4619      	mov	r1, r3
   10a2c:	4803      	ldr	r0, [pc, #12]	; (10a3c <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)+0x28>)
   10a2e:	f002 fc8d 	bl	1334c <__cyg_profile_func_exit>
   10a32:	4623      	mov	r3, r4
}
   10a34:	4618      	mov	r0, r3
   10a36:	b003      	add	sp, #12
   10a38:	bd30      	pop	{r4, r5, pc}
   10a3a:	bf00      	nop
   10a3c:	00010a15 	.word	0x00010a15

00010a40 <Ssp::IsTransferRegBusy()>:
  }

  /// Checks if the SSP controller is idle.
  /// @returns true if the controller is sending or receiving a data frame and
  /// false if it is idle.
  bool IsTransferRegBusy() override
   10a40:	b530      	push	{r4, r5, lr}
   10a42:	b085      	sub	sp, #20
   10a44:	4675      	mov	r5, lr
   10a46:	9001      	str	r0, [sp, #4]
   10a48:	462b      	mov	r3, r5
   10a4a:	4619      	mov	r1, r3
   10a4c:	4817      	ldr	r0, [pc, #92]	; (10aac <Ssp::IsTransferRegBusy()+0x6c>)
   10a4e:	f002 fc69 	bl	13324 <__cyg_profile_func_enter>
  {
    return (bit::Read(ssp_registers[util::Value(pssp_)]->SR, kDataLineIdleBit));
   10a52:	9b01      	ldr	r3, [sp, #4]
   10a54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10a56:	4618      	mov	r0, r3
   10a58:	f7ff ffdc 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   10a5c:	4602      	mov	r2, r0
   10a5e:	4b14      	ldr	r3, [pc, #80]	; (10ab0 <Ssp::IsTransferRegBusy()+0x70>)
   10a60:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   10a64:	68db      	ldr	r3, [r3, #12]
   10a66:	9303      	str	r3, [sp, #12]
   10a68:	2304      	movs	r3, #4
   10a6a:	9302      	str	r3, [sp, #8]
   10a6c:	462b      	mov	r3, r5
   10a6e:	4619      	mov	r1, r3
   10a70:	4810      	ldr	r0, [pc, #64]	; (10ab4 <Ssp::IsTransferRegBusy()+0x74>)
   10a72:	f002 fc57 	bl	13324 <__cyg_profile_func_enter>
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
                                                        uint32_t position)
{
  static_assert(std::numeric_limits<T>::is_integer,
                "Read only accepts intergers.");
  return static_cast<bool>(target & (1 << position));
   10a76:	2201      	movs	r2, #1
   10a78:	9b02      	ldr	r3, [sp, #8]
   10a7a:	fa02 f303 	lsl.w	r3, r2, r3
   10a7e:	461a      	mov	r2, r3
   10a80:	9b03      	ldr	r3, [sp, #12]
   10a82:	4013      	ands	r3, r2
   10a84:	2b00      	cmp	r3, #0
   10a86:	bf14      	ite	ne
   10a88:	2301      	movne	r3, #1
   10a8a:	2300      	moveq	r3, #0
   10a8c:	b2dc      	uxtb	r4, r3
   10a8e:	462b      	mov	r3, r5
   10a90:	4619      	mov	r1, r3
   10a92:	4808      	ldr	r0, [pc, #32]	; (10ab4 <Ssp::IsTransferRegBusy()+0x74>)
   10a94:	f002 fc5a 	bl	1334c <__cyg_profile_func_exit>
   10a98:	462b      	mov	r3, r5
   10a9a:	4619      	mov	r1, r3
   10a9c:	4803      	ldr	r0, [pc, #12]	; (10aac <Ssp::IsTransferRegBusy()+0x6c>)
   10a9e:	f002 fc55 	bl	1334c <__cyg_profile_func_exit>
   10aa2:	4623      	mov	r3, r4
  }
   10aa4:	4618      	mov	r0, r3
   10aa6:	b005      	add	sp, #20
   10aa8:	bd30      	pop	{r4, r5, pc}
   10aaa:	bf00      	nop
   10aac:	00010a41 	.word	0x00010a41
   10ab0:	1000005c 	.word	0x1000005c
   10ab4:	00010d35 	.word	0x00010d35

00010ab8 <Ssp::Transfer(unsigned short)>:
  /// data register. This functions for both transmitting and
  /// receiving data. It is recommended this region be protected
  /// by a mutex.
  /// @param data - information to be placed in data register
  /// @return - received data from external device
  uint16_t Transfer(uint16_t data) override
   10ab8:	b530      	push	{r4, r5, lr}
   10aba:	b085      	sub	sp, #20
   10abc:	4675      	mov	r5, lr
   10abe:	9001      	str	r0, [sp, #4]
   10ac0:	460b      	mov	r3, r1
   10ac2:	f8ad 3002 	strh.w	r3, [sp, #2]
   10ac6:	462b      	mov	r3, r5
   10ac8:	4619      	mov	r1, r3
   10aca:	4814      	ldr	r0, [pc, #80]	; (10b1c <Ssp::Transfer(unsigned short)+0x64>)
   10acc:	f002 fc2a 	bl	13324 <__cyg_profile_func_enter>
  {
    uint32_t pssp = util::Value(pssp_);
   10ad0:	9b01      	ldr	r3, [sp, #4]
   10ad2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10ad4:	4618      	mov	r0, r3
   10ad6:	f7ff ff9d 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   10ada:	4603      	mov	r3, r0
   10adc:	9303      	str	r3, [sp, #12]

    ssp_registers[pssp]->DR = data;
   10ade:	4a10      	ldr	r2, [pc, #64]	; (10b20 <Ssp::Transfer(unsigned short)+0x68>)
   10ae0:	9b03      	ldr	r3, [sp, #12]
   10ae2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ae6:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   10aea:	609a      	str	r2, [r3, #8]
    while (IsTransferRegBusy())
   10aec:	9801      	ldr	r0, [sp, #4]
   10aee:	f7ff ffa7 	bl	10a40 <Ssp::IsTransferRegBusy()>
   10af2:	4603      	mov	r3, r0
   10af4:	2b00      	cmp	r3, #0
   10af6:	d001      	beq.n	10afc <Ssp::Transfer(unsigned short)+0x44>
    {
      continue;
   10af8:	bf00      	nop
    while (IsTransferRegBusy())
   10afa:	e7f7      	b.n	10aec <Ssp::Transfer(unsigned short)+0x34>
    }
    return static_cast<uint16_t>(ssp_registers[pssp]->DR);
   10afc:	4a08      	ldr	r2, [pc, #32]	; (10b20 <Ssp::Transfer(unsigned short)+0x68>)
   10afe:	9b03      	ldr	r3, [sp, #12]
   10b00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b04:	689b      	ldr	r3, [r3, #8]
   10b06:	b29c      	uxth	r4, r3
   10b08:	462b      	mov	r3, r5
   10b0a:	4619      	mov	r1, r3
   10b0c:	4803      	ldr	r0, [pc, #12]	; (10b1c <Ssp::Transfer(unsigned short)+0x64>)
   10b0e:	f002 fc1d 	bl	1334c <__cyg_profile_func_exit>
   10b12:	4623      	mov	r3, r4
  }
   10b14:	4618      	mov	r0, r3
   10b16:	b005      	add	sp, #20
   10b18:	bd30      	pop	{r4, r5, pc}
   10b1a:	bf00      	nop
   10b1c:	00010ab9 	.word	0x00010ab9
   10b20:	1000005c 	.word	0x1000005c

00010b24 <main>:
void isr_toggle();
void sem_task(void *p);
LabGPIO Button3(0,29);
LabGPIO led3(1, 18);
int main() 
{ 
   10b24:	b500      	push	{lr}
   10b26:	b083      	sub	sp, #12
   10b28:	4673      	mov	r3, lr
   10b2a:	4619      	mov	r1, r3
   10b2c:	4818      	ldr	r0, [pc, #96]	; (10b90 <main+0x6c>)
   10b2e:	f002 fbf9 	bl	13324 <__cyg_profile_func_enter>
  LOG_INFO("Start");
   10b32:	2316      	movs	r3, #22
   10b34:	4a17      	ldr	r2, [pc, #92]	; (10b94 <main+0x70>)
   10b36:	4918      	ldr	r1, [pc, #96]	; (10b98 <main+0x74>)
   10b38:	4818      	ldr	r0, [pc, #96]	; (10b9c <main+0x78>)
   10b3a:	f005 f98f 	bl	15e5c <printf>
  /*LabGPIO Int(0,29);
  Int.SetAsInput();
  LPC_GPIOINT -> IO0IntEnR = (1<<29);
  RegisterIsr(GPIO_IRQn, GpioInterruptCallback);
  */
  vSemaphoreCreateBinary(binary_sem);
   10b3e:	2203      	movs	r2, #3
   10b40:	2100      	movs	r1, #0
   10b42:	2001      	movs	r0, #1
   10b44:	f003 fbd0 	bl	142e8 <xQueueGenericCreate>
   10b48:	4602      	mov	r2, r0
   10b4a:	4b15      	ldr	r3, [pc, #84]	; (10ba0 <main+0x7c>)
   10b4c:	601a      	str	r2, [r3, #0]
   10b4e:	4b14      	ldr	r3, [pc, #80]	; (10ba0 <main+0x7c>)
   10b50:	681b      	ldr	r3, [r3, #0]
   10b52:	2b00      	cmp	r3, #0
   10b54:	d006      	beq.n	10b64 <main+0x40>
   10b56:	4b12      	ldr	r3, [pc, #72]	; (10ba0 <main+0x7c>)
   10b58:	6818      	ldr	r0, [r3, #0]
   10b5a:	2300      	movs	r3, #0
   10b5c:	2200      	movs	r2, #0
   10b5e:	2100      	movs	r1, #0
   10b60:	f003 fc18 	bl	14394 <xQueueGenericSend>
  
  //gpio.SetAsInput();
  Button3.AttachInterruptHandler(&isr_toggle,LabGPIO::Edge::kFalling);
   10b64:	2202      	movs	r2, #2
   10b66:	490f      	ldr	r1, [pc, #60]	; (10ba4 <main+0x80>)
   10b68:	480f      	ldr	r0, [pc, #60]	; (10ba8 <main+0x84>)
   10b6a:	f7ff fcb9 	bl	104e0 <LabGPIO::AttachInterruptHandler(void (*)(), LabGPIO::Edge)>
  Button3.EnableInterrupts();
   10b6e:	f7ff fd43 	bl	105f8 <LabGPIO::EnableInterrupts()>
  xTaskCreate(sem_task, (const char*)"t",1024, NULL, 1, NULL);
   10b72:	2300      	movs	r3, #0
   10b74:	9301      	str	r3, [sp, #4]
   10b76:	2301      	movs	r3, #1
   10b78:	9300      	str	r3, [sp, #0]
   10b7a:	2300      	movs	r3, #0
   10b7c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   10b80:	490a      	ldr	r1, [pc, #40]	; (10bac <main+0x88>)
   10b82:	480b      	ldr	r0, [pc, #44]	; (10bb0 <main+0x8c>)
   10b84:	f002 fce3 	bl	1354e <xTaskCreate>
  vTaskStartScheduler();
   10b88:	f002 fe10 	bl	137ac <vTaskStartScheduler>
  while(true)
   10b8c:	e7fe      	b.n	10b8c <main+0x68>
   10b8e:	bf00      	nop
   10b90:	00010b25 	.word	0x00010b25
   10b94:	00018f6c 	.word	0x00018f6c
   10b98:	00018e18 	.word	0x00018e18
   10b9c:	00018e24 	.word	0x00018e24
   10ba0:	100003b0 	.word	0x100003b0
   10ba4:	00010bb5 	.word	0x00010bb5
   10ba8:	100003b4 	.word	0x100003b4
   10bac:	00018e64 	.word	0x00018e64
   10bb0:	00010c15 	.word	0x00010c15

00010bb4 <isr_toggle()>:
    Delay(500);
  // 4) For the callback, do anything such as printf or blink and LED here to test your ISR
  // 5) MUST! Clear the source of the GPIO interrupt
    LPC_GPIOINT->IO0IntClr = (1<<29);
}
void isr_toggle(){
   10bb4:	b510      	push	{r4, lr}
   10bb6:	4674      	mov	r4, lr
   10bb8:	4623      	mov	r3, r4
   10bba:	4619      	mov	r1, r3
   10bbc:	480f      	ldr	r0, [pc, #60]	; (10bfc <isr_toggle()+0x48>)
   10bbe:	f002 fbb1 	bl	13324 <__cyg_profile_func_enter>
    LOG_INFO("In the interrupt");
   10bc2:	2338      	movs	r3, #56	; 0x38
   10bc4:	4a0e      	ldr	r2, [pc, #56]	; (10c00 <isr_toggle()+0x4c>)
   10bc6:	490f      	ldr	r1, [pc, #60]	; (10c04 <isr_toggle()+0x50>)
   10bc8:	480f      	ldr	r0, [pc, #60]	; (10c08 <isr_toggle()+0x54>)
   10bca:	f005 f947 	bl	15e5c <printf>
    Delay(50);
   10bce:	f04f 0032 	mov.w	r0, #50	; 0x32
   10bd2:	f04f 0100 	mov.w	r1, #0
   10bd6:	f7ff fe7f 	bl	108d8 <Delay(unsigned long long)>
    xSemaphoreGiveFromISR(binary_sem,NULL);
   10bda:	4b0c      	ldr	r3, [pc, #48]	; (10c0c <isr_toggle()+0x58>)
   10bdc:	681b      	ldr	r3, [r3, #0]
   10bde:	2100      	movs	r1, #0
   10be0:	4618      	mov	r0, r3
   10be2:	f003 fc7f 	bl	144e4 <xQueueGiveFromISR>
     LPC_GPIOINT->IO0IntClr = (1<<29);
   10be6:	4b0a      	ldr	r3, [pc, #40]	; (10c10 <isr_toggle()+0x5c>)
   10be8:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   10bec:	60da      	str	r2, [r3, #12]
   10bee:	4623      	mov	r3, r4
   10bf0:	4619      	mov	r1, r3
   10bf2:	4802      	ldr	r0, [pc, #8]	; (10bfc <isr_toggle()+0x48>)
   10bf4:	f002 fbaa 	bl	1334c <__cyg_profile_func_exit>
    
}
   10bf8:	bf00      	nop
   10bfa:	bd10      	pop	{r4, pc}
   10bfc:	00010bb5 	.word	0x00010bb5
   10c00:	00018f78 	.word	0x00018f78
   10c04:	00018f48 	.word	0x00018f48
   10c08:	00018e68 	.word	0x00018e68
   10c0c:	100003b0 	.word	0x100003b0
   10c10:	40028080 	.word	0x40028080

00010c14 <sem_task(void*)>:
void sem_task(void *p){
   10c14:	b500      	push	{lr}
   10c16:	b083      	sub	sp, #12
   10c18:	4673      	mov	r3, lr
   10c1a:	9001      	str	r0, [sp, #4]
   10c1c:	4619      	mov	r1, r3
   10c1e:	4811      	ldr	r0, [pc, #68]	; (10c64 <sem_task(void*)+0x50>)
   10c20:	f002 fb80 	bl	13324 <__cyg_profile_func_enter>
      while(1){
      if(xSemaphoreTake(binary_sem,99999999))
   10c24:	4b10      	ldr	r3, [pc, #64]	; (10c68 <sem_task(void*)+0x54>)
   10c26:	681b      	ldr	r3, [r3, #0]
   10c28:	4910      	ldr	r1, [pc, #64]	; (10c6c <sem_task(void*)+0x58>)
   10c2a:	4618      	mov	r0, r3
   10c2c:	f003 fcae 	bl	1458c <xQueueSemaphoreTake>
   10c30:	4603      	mov	r3, r0
   10c32:	2b00      	cmp	r3, #0
   10c34:	bf14      	ite	ne
   10c36:	2301      	movne	r3, #1
   10c38:	2300      	moveq	r3, #0
   10c3a:	b2db      	uxtb	r3, r3
   10c3c:	2b00      	cmp	r3, #0
   10c3e:	d009      	beq.n	10c54 <sem_task(void*)+0x40>
        {   
            LOG_INFO("Semaphore Recieved\n");
   10c40:	2342      	movs	r3, #66	; 0x42
   10c42:	4a0b      	ldr	r2, [pc, #44]	; (10c70 <sem_task(void*)+0x5c>)
   10c44:	490b      	ldr	r1, [pc, #44]	; (10c74 <sem_task(void*)+0x60>)
   10c46:	480c      	ldr	r0, [pc, #48]	; (10c78 <sem_task(void*)+0x64>)
   10c48:	f005 f908 	bl	15e5c <printf>
            led3.toggle();
   10c4c:	480b      	ldr	r0, [pc, #44]	; (10c7c <sem_task(void*)+0x68>)
   10c4e:	f7ff fc23 	bl	10498 <LabGPIO::toggle()>
   10c52:	e7e7      	b.n	10c24 <sem_task(void*)+0x10>
        }
        else LOG_INFO("NOT TICK\n");
   10c54:	2345      	movs	r3, #69	; 0x45
   10c56:	4a06      	ldr	r2, [pc, #24]	; (10c70 <sem_task(void*)+0x5c>)
   10c58:	4909      	ldr	r1, [pc, #36]	; (10c80 <sem_task(void*)+0x6c>)
   10c5a:	480a      	ldr	r0, [pc, #40]	; (10c84 <sem_task(void*)+0x70>)
   10c5c:	f005 f8fe 	bl	15e5c <printf>
        }
   10c60:	e7e0      	b.n	10c24 <sem_task(void*)+0x10>
   10c62:	bf00      	nop
   10c64:	00010c15 	.word	0x00010c15
   10c68:	100003b0 	.word	0x100003b0
   10c6c:	05f5e0ff 	.word	0x05f5e0ff
   10c70:	00018f8c 	.word	0x00018f8c
   10c74:	00018f54 	.word	0x00018f54
   10c78:	00018eb4 	.word	0x00018eb4
   10c7c:	100003bc 	.word	0x100003bc
   10c80:	00018f60 	.word	0x00018f60
   10c84:	00018f04 	.word	0x00018f04

00010c88 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   10c88:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   10c8c:	b088      	sub	sp, #32
   10c8e:	4675      	mov	r5, lr
   10c90:	e9cd 0102 	strd	r0, r1, [sp, #8]
   10c94:	f88d 2004 	strb.w	r2, [sp, #4]
   10c98:	462b      	mov	r3, r5
   10c9a:	4619      	mov	r1, r3
   10c9c:	4824      	ldr	r0, [pc, #144]	; (10d30 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   10c9e:	f002 fb41 	bl	13324 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   10ca2:	f04f 0300 	mov.w	r3, #0
   10ca6:	f04f 0400 	mov.w	r4, #0
   10caa:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   10cae:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   10cb2:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   10cb6:	bf08      	it	eq
   10cb8:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   10cbc:	d106      	bne.n	10ccc <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x44>
    timeout_time = kMaxWait;
   10cbe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   10cc2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   10cc6:	e9cd 3406 	strd	r3, r4, [sp, #24]
   10cca:	e00b      	b.n	10ce4 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x5c>
    timeout_time = Milliseconds() + timeout;
   10ccc:	f7ff fd54 	bl	10778 <Milliseconds()>
   10cd0:	460a      	mov	r2, r1
   10cd2:	4601      	mov	r1, r0
   10cd4:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   10cd8:	eb13 0b01 	adds.w	fp, r3, r1
   10cdc:	eb44 0c02 	adc.w	ip, r4, r2
   10ce0:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   10ce4:	2301      	movs	r3, #1
   10ce6:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   10ce8:	f7ff fd46 	bl	10778 <Milliseconds()>
   10cec:	460a      	mov	r2, r1
   10cee:	4601      	mov	r1, r0
   10cf0:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   10cf4:	42a2      	cmp	r2, r4
   10cf6:	bf08      	it	eq
   10cf8:	4299      	cmpeq	r1, r3
   10cfa:	bf34      	ite	cc
   10cfc:	2301      	movcc	r3, #1
   10cfe:	2300      	movcs	r3, #0
   10d00:	b2db      	uxtb	r3, r3
   10d02:	2b00      	cmp	r3, #0
   10d04:	d008      	beq.n	10d18 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x90>
    if (is_done())
   10d06:	ab01      	add	r3, sp, #4
   10d08:	4618      	mov	r0, r3
   10d0a:	f7ff fd57 	bl	107bc <Wait(unsigned long long)::{lambda()#1}::operator()() const>
   10d0e:	4603      	mov	r3, r0
   10d10:	2b00      	cmp	r3, #0
   10d12:	d0e9      	beq.n	10ce8 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0x60>
      status = Status::kSuccess;
   10d14:	2300      	movs	r3, #0
   10d16:	9305      	str	r3, [sp, #20]
  return status;
   10d18:	9c05      	ldr	r4, [sp, #20]
   10d1a:	462b      	mov	r3, r5
   10d1c:	4619      	mov	r1, r3
   10d1e:	4804      	ldr	r0, [pc, #16]	; (10d30 <Status Wait<Wait(unsigned long long)::{lambda()#1}>(unsigned long long, Wait(unsigned long long)::{lambda()#1})+0xa8>)
   10d20:	f002 fb14 	bl	1334c <__cyg_profile_func_exit>
   10d24:	4623      	mov	r3, r4
}
   10d26:	4618      	mov	r0, r3
   10d28:	b008      	add	sp, #32
   10d2a:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   10d2e:	bf00      	nop
   10d30:	00010c89 	.word	0x00010c89

00010d34 <bool bit::Read<unsigned long>(unsigned long, unsigned long)>:
[[gnu::always_inline]][[nodiscard]] constexpr bool Read(T target,
   10d34:	b530      	push	{r4, r5, lr}
   10d36:	b083      	sub	sp, #12
   10d38:	4675      	mov	r5, lr
   10d3a:	9001      	str	r0, [sp, #4]
   10d3c:	9100      	str	r1, [sp, #0]
   10d3e:	462b      	mov	r3, r5
   10d40:	4619      	mov	r1, r3
   10d42:	480c      	ldr	r0, [pc, #48]	; (10d74 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   10d44:	f002 faee 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   10d48:	2201      	movs	r2, #1
   10d4a:	9b00      	ldr	r3, [sp, #0]
   10d4c:	fa02 f303 	lsl.w	r3, r2, r3
   10d50:	461a      	mov	r2, r3
   10d52:	9b01      	ldr	r3, [sp, #4]
   10d54:	4013      	ands	r3, r2
   10d56:	2b00      	cmp	r3, #0
   10d58:	bf14      	ite	ne
   10d5a:	2301      	movne	r3, #1
   10d5c:	2300      	moveq	r3, #0
   10d5e:	b2dc      	uxtb	r4, r3
   10d60:	462b      	mov	r3, r5
   10d62:	4619      	mov	r1, r3
   10d64:	4803      	ldr	r0, [pc, #12]	; (10d74 <bool bit::Read<unsigned long>(unsigned long, unsigned long)+0x40>)
   10d66:	f002 faf1 	bl	1334c <__cyg_profile_func_exit>
   10d6a:	4623      	mov	r3, r4
}
   10d6c:	4618      	mov	r0, r3
   10d6e:	b003      	add	sp, #12
   10d70:	bd30      	pop	{r4, r5, pc}
   10d72:	bf00      	nop
   10d74:	00010d35 	.word	0x00010d35

00010d78 <__static_initialization_and_destruction_0(int, int)>:
   10d78:	b510      	push	{r4, lr}
   10d7a:	b082      	sub	sp, #8
   10d7c:	4674      	mov	r4, lr
   10d7e:	9001      	str	r0, [sp, #4]
   10d80:	9100      	str	r1, [sp, #0]
   10d82:	4623      	mov	r3, r4
   10d84:	4619      	mov	r1, r3
   10d86:	480e      	ldr	r0, [pc, #56]	; (10dc0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   10d88:	f002 facc 	bl	13324 <__cyg_profile_func_enter>
   10d8c:	9b01      	ldr	r3, [sp, #4]
   10d8e:	2b01      	cmp	r3, #1
   10d90:	d10e      	bne.n	10db0 <__static_initialization_and_destruction_0(int, int)+0x38>
   10d92:	9b00      	ldr	r3, [sp, #0]
   10d94:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10d98:	4293      	cmp	r3, r2
   10d9a:	d109      	bne.n	10db0 <__static_initialization_and_destruction_0(int, int)+0x38>
LabGPIO Button3(0,29);
   10d9c:	221d      	movs	r2, #29
   10d9e:	2100      	movs	r1, #0
   10da0:	4808      	ldr	r0, [pc, #32]	; (10dc4 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   10da2:	f7ff fae1 	bl	10368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>
LabGPIO led3(1, 18);
   10da6:	2212      	movs	r2, #18
   10da8:	2101      	movs	r1, #1
   10daa:	4807      	ldr	r0, [pc, #28]	; (10dc8 <__static_initialization_and_destruction_0(int, int)+0x50>)
   10dac:	f7ff fadc 	bl	10368 <LabGPIO::LabGPIO(unsigned char, unsigned char)>
   10db0:	4623      	mov	r3, r4
   10db2:	4619      	mov	r1, r3
   10db4:	4802      	ldr	r0, [pc, #8]	; (10dc0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   10db6:	f002 fac9 	bl	1334c <__cyg_profile_func_exit>
   10dba:	bf00      	nop
   10dbc:	b002      	add	sp, #8
   10dbe:	bd10      	pop	{r4, pc}
   10dc0:	00010d79 	.word	0x00010d79
   10dc4:	100003b4 	.word	0x100003b4
   10dc8:	100003bc 	.word	0x100003bc

00010dcc <_GLOBAL__sub_I_binary_sem>:
   10dcc:	b510      	push	{r4, lr}
   10dce:	4674      	mov	r4, lr
   10dd0:	4623      	mov	r3, r4
   10dd2:	4619      	mov	r1, r3
   10dd4:	4806      	ldr	r0, [pc, #24]	; (10df0 <_GLOBAL__sub_I_binary_sem+0x24>)
   10dd6:	f002 faa5 	bl	13324 <__cyg_profile_func_enter>
   10dda:	f64f 71ff 	movw	r1, #65535	; 0xffff
   10dde:	2001      	movs	r0, #1
   10de0:	f7ff ffca 	bl	10d78 <__static_initialization_and_destruction_0(int, int)>
   10de4:	4623      	mov	r3, r4
   10de6:	4619      	mov	r1, r3
   10de8:	4801      	ldr	r0, [pc, #4]	; (10df0 <_GLOBAL__sub_I_binary_sem+0x24>)
   10dea:	f002 faaf 	bl	1334c <__cyg_profile_func_exit>
   10dee:	bd10      	pop	{r4, pc}
   10df0:	00010dcd 	.word	0x00010dcd

00010df4 <debug::PrintBacktrace(bool, void*)>:
}

[[gnu::no_instrument_function]]
inline void PrintBacktrace(bool show_make_command = false,
                           void * final_address   = nullptr)
{
   10df4:	b500      	push	{lr}
   10df6:	b08b      	sub	sp, #44	; 0x2c
   10df8:	4603      	mov	r3, r0
   10dfa:	9100      	str	r1, [sp, #0]
   10dfc:	f88d 3007 	strb.w	r3, [sp, #7]
  printf("Stack Depth = %zd\n", GetStackDepth());
   10e00:	f002 fac6 	bl	13390 <GetStackDepth()>
   10e04:	4603      	mov	r3, r0
   10e06:	4619      	mov	r1, r3
   10e08:	4831      	ldr	r0, [pc, #196]	; (10ed0 <debug::PrintBacktrace(bool, void*)+0xdc>)
   10e0a:	f005 f827 	bl	15e5c <printf>
  // stack_depth-1 to ignore PrintBacktrace()
  // PrintBacktrace shouldn't be ignored in profiling because it causes
  // the exit to still fire, which can result in a negative stack_depth
  void ** list_of_called_functions = GetStackTrace();
   10e0e:	f002 faab 	bl	13368 <GetStackTrace()>
   10e12:	9007      	str	r0, [sp, #28]
  size_t stack_depth               = GetStackDepth();
   10e14:	f002 fabc 	bl	13390 <GetStackDepth()>
   10e18:	9006      	str	r0, [sp, #24]
  // Ignore the last function as it is the Backtrace function
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10e1a:	2300      	movs	r3, #0
   10e1c:	9309      	str	r3, [sp, #36]	; 0x24
   10e1e:	9b06      	ldr	r3, [sp, #24]
   10e20:	3b01      	subs	r3, #1
   10e22:	9a09      	ldr	r2, [sp, #36]	; 0x24
   10e24:	429a      	cmp	r2, r3
   10e26:	d20d      	bcs.n	10e44 <debug::PrintBacktrace(bool, void*)+0x50>
  {
    printf("  #%zu: 0x%p\n", pos, list_of_called_functions[pos]);
   10e28:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10e2a:	009b      	lsls	r3, r3, #2
   10e2c:	9a07      	ldr	r2, [sp, #28]
   10e2e:	4413      	add	r3, r2
   10e30:	681b      	ldr	r3, [r3, #0]
   10e32:	461a      	mov	r2, r3
   10e34:	9909      	ldr	r1, [sp, #36]	; 0x24
   10e36:	4827      	ldr	r0, [pc, #156]	; (10ed4 <debug::PrintBacktrace(bool, void*)+0xe0>)
   10e38:	f005 f810 	bl	15e5c <printf>
  for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10e3c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10e3e:	3301      	adds	r3, #1
   10e40:	9309      	str	r3, [sp, #36]	; 0x24
   10e42:	e7ec      	b.n	10e1e <debug::PrintBacktrace(bool, void*)+0x2a>
  }
  if (final_address != nullptr)
   10e44:	9b00      	ldr	r3, [sp, #0]
   10e46:	2b00      	cmp	r3, #0
   10e48:	d006      	beq.n	10e58 <debug::PrintBacktrace(bool, void*)+0x64>
  {
    printf("  #%zu: 0x%p\n", stack_depth - 1, final_address);
   10e4a:	9b06      	ldr	r3, [sp, #24]
   10e4c:	3b01      	subs	r3, #1
   10e4e:	9a00      	ldr	r2, [sp, #0]
   10e50:	4619      	mov	r1, r3
   10e52:	4820      	ldr	r0, [pc, #128]	; (10ed4 <debug::PrintBacktrace(bool, void*)+0xe0>)
   10e54:	f005 f802 	bl	15e5c <printf>
  }
  if (show_make_command)
   10e58:	f89d 3007 	ldrb.w	r3, [sp, #7]
   10e5c:	2b00      	cmp	r3, #0
   10e5e:	d033      	beq.n	10ec8 <debug::PrintBacktrace(bool, void*)+0xd4>
  {
    constexpr const char kBuildType[] =
   10e60:	4a1d      	ldr	r2, [pc, #116]	; (10ed8 <debug::PrintBacktrace(bool, void*)+0xe4>)
   10e62:	ab03      	add	r3, sp, #12
   10e64:	ca07      	ldmia	r2, {r0, r1, r2}
   10e66:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#if defined(APPLICATION)
        "application";
#else
        "bootloader";
#endif
    puts("\nRun: the following command in your project directory");
   10e6a:	481c      	ldr	r0, [pc, #112]	; (10edc <debug::PrintBacktrace(bool, void*)+0xe8>)
   10e6c:	f002 fa2a 	bl	132c4 <puts>
    printf("\n  " SJ2_BOLD_WHITE "make stacktrace-%s TRACES=\"", kBuildType);
   10e70:	ab03      	add	r3, sp, #12
   10e72:	4619      	mov	r1, r3
   10e74:	481a      	ldr	r0, [pc, #104]	; (10ee0 <debug::PrintBacktrace(bool, void*)+0xec>)
   10e76:	f004 fff1 	bl	15e5c <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10e7a:	2300      	movs	r3, #0
   10e7c:	9308      	str	r3, [sp, #32]
   10e7e:	9b06      	ldr	r3, [sp, #24]
   10e80:	3b01      	subs	r3, #1
   10e82:	9a08      	ldr	r2, [sp, #32]
   10e84:	429a      	cmp	r2, r3
   10e86:	d212      	bcs.n	10eae <debug::PrintBacktrace(bool, void*)+0xba>
    {
      if (pos != 0)
   10e88:	9b08      	ldr	r3, [sp, #32]
   10e8a:	2b00      	cmp	r3, #0
   10e8c:	d002      	beq.n	10e94 <debug::PrintBacktrace(bool, void*)+0xa0>
      {
        putchar(' ');
   10e8e:	2020      	movs	r0, #32
   10e90:	f002 f9fc 	bl	1328c <putchar>
      }
      printf("0x%p", list_of_called_functions[pos]);
   10e94:	9b08      	ldr	r3, [sp, #32]
   10e96:	009b      	lsls	r3, r3, #2
   10e98:	9a07      	ldr	r2, [sp, #28]
   10e9a:	4413      	add	r3, r2
   10e9c:	681b      	ldr	r3, [r3, #0]
   10e9e:	4619      	mov	r1, r3
   10ea0:	4810      	ldr	r0, [pc, #64]	; (10ee4 <debug::PrintBacktrace(bool, void*)+0xf0>)
   10ea2:	f004 ffdb 	bl	15e5c <printf>
    for (size_t pos = 0; pos < stack_depth - 1; pos++)
   10ea6:	9b08      	ldr	r3, [sp, #32]
   10ea8:	3301      	adds	r3, #1
   10eaa:	9308      	str	r3, [sp, #32]
   10eac:	e7e7      	b.n	10e7e <debug::PrintBacktrace(bool, void*)+0x8a>
    }
    if (final_address != nullptr)
   10eae:	9b00      	ldr	r3, [sp, #0]
   10eb0:	2b00      	cmp	r3, #0
   10eb2:	d003      	beq.n	10ebc <debug::PrintBacktrace(bool, void*)+0xc8>
    {
      printf(" 0x%p", final_address);
   10eb4:	9900      	ldr	r1, [sp, #0]
   10eb6:	480c      	ldr	r0, [pc, #48]	; (10ee8 <debug::PrintBacktrace(bool, void*)+0xf4>)
   10eb8:	f004 ffd0 	bl	15e5c <printf>
    }
    puts("\"\n" SJ2_COLOR_RESET);
   10ebc:	480b      	ldr	r0, [pc, #44]	; (10eec <debug::PrintBacktrace(bool, void*)+0xf8>)
   10ebe:	f002 fa01 	bl	132c4 <puts>
    puts(
   10ec2:	480b      	ldr	r0, [pc, #44]	; (10ef0 <debug::PrintBacktrace(bool, void*)+0xfc>)
   10ec4:	f002 f9fe 	bl	132c4 <puts>
        "This will report the file and line number that led to this function "
        "being called.");
  }
}
   10ec8:	bf00      	nop
   10eca:	b00b      	add	sp, #44	; 0x2c
   10ecc:	f85d fb04 	ldr.w	pc, [sp], #4
   10ed0:	00018fa4 	.word	0x00018fa4
   10ed4:	00018fb8 	.word	0x00018fb8
   10ed8:	00019094 	.word	0x00019094
   10edc:	00018fc8 	.word	0x00018fc8
   10ee0:	00019000 	.word	0x00019000
   10ee4:	00019028 	.word	0x00019028
   10ee8:	00019030 	.word	0x00019030
   10eec:	00019038 	.word	0x00019038
   10ef0:	00019040 	.word	0x00019040

00010ef4 <SetUptimeFunction(unsigned long long (*)())>:
{
   10ef4:	b510      	push	{r4, lr}
   10ef6:	b082      	sub	sp, #8
   10ef8:	4674      	mov	r4, lr
   10efa:	9001      	str	r0, [sp, #4]
   10efc:	4623      	mov	r3, r4
   10efe:	4619      	mov	r1, r3
   10f00:	4806      	ldr	r0, [pc, #24]	; (10f1c <SetUptimeFunction(unsigned long long (*)())+0x28>)
   10f02:	f002 fa0f 	bl	13324 <__cyg_profile_func_enter>
  Uptime = uptime_function;
   10f06:	4a06      	ldr	r2, [pc, #24]	; (10f20 <SetUptimeFunction(unsigned long long (*)())+0x2c>)
   10f08:	9b01      	ldr	r3, [sp, #4]
   10f0a:	6013      	str	r3, [r2, #0]
   10f0c:	4623      	mov	r3, r4
   10f0e:	4619      	mov	r1, r3
   10f10:	4802      	ldr	r0, [pc, #8]	; (10f1c <SetUptimeFunction(unsigned long long (*)())+0x28>)
   10f12:	f002 fa1b 	bl	1334c <__cyg_profile_func_exit>
}
   10f16:	bf00      	nop
   10f18:	b002      	add	sp, #8
   10f1a:	bd10      	pop	{r4, pc}
   10f1c:	00010ef5 	.word	0x00010ef5
   10f20:	10000040 	.word	0x10000040

00010f24 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>:

  inline static LPC_SC_TypeDef * system_controller = LPC_SC;

  constexpr Lpc40xxSystemController() {}

  uint32_t SetClockFrequency(uint8_t frequency_in_mhz) override
   10f24:	b500      	push	{lr}
   10f26:	b085      	sub	sp, #20
   10f28:	9001      	str	r0, [sp, #4]
   10f2a:	460b      	mov	r3, r1
   10f2c:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    uint32_t offset = 0;
   10f30:	2300      	movs	r3, #0
   10f32:	9303      	str	r3, [sp, #12]
    SelectOscillatorSource(OscillatorSource::kIrc);
   10f34:	2100      	movs	r1, #0
   10f36:	9801      	ldr	r0, [sp, #4]
   10f38:	f000 f8ce 	bl	110d8 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    if (frequency_in_mhz > 12)
   10f3c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10f40:	2b0c      	cmp	r3, #12
   10f42:	d916      	bls.n	10f72 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x4e>
    {
      offset = SetMainPll(PllInput::kIrc, frequency_in_mhz);
   10f44:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10f48:	b29b      	uxth	r3, r3
   10f4a:	461a      	mov	r2, r3
   10f4c:	210c      	movs	r1, #12
   10f4e:	9801      	ldr	r0, [sp, #4]
   10f50:	f000 f9ac 	bl	112ac <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>
   10f54:	9003      	str	r0, [sp, #12]
      SelectMainClockSource(MainClockSource::kPllClock);
   10f56:	f44f 7180 	mov.w	r1, #256	; 0x100
   10f5a:	9801      	ldr	r0, [sp, #4]
   10f5c:	f000 f8d6 	bl	1110c <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = frequency_in_mhz * 1'000'000;
   10f60:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10f64:	4a10      	ldr	r2, [pc, #64]	; (10fa8 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x84>)
   10f66:	fb02 f303 	mul.w	r3, r2, r3
   10f6a:	461a      	mov	r2, r3
   10f6c:	4b0f      	ldr	r3, [pc, #60]	; (10fac <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   10f6e:	601a      	str	r2, [r3, #0]
   10f70:	e006      	b.n	10f80 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x5c>
    }
    else
    {
      SelectMainClockSource(MainClockSource::kBaseClock);
   10f72:	2100      	movs	r1, #0
   10f74:	9801      	ldr	r0, [sp, #4]
   10f76:	f000 f8c9 	bl	1110c <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
      speed_in_hertz = kDefaultIRCFrequency;
   10f7a:	4b0c      	ldr	r3, [pc, #48]	; (10fac <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x88>)
   10f7c:	4a0c      	ldr	r2, [pc, #48]	; (10fb0 <Lpc40xxSystemController::SetClockFrequency(unsigned char)+0x8c>)
   10f7e:	601a      	str	r2, [r3, #0]
    }
    SetCpuClockDivider(kDivideInputBy1);
   10f80:	2101      	movs	r1, #1
   10f82:	9801      	ldr	r0, [sp, #4]
   10f84:	f000 fa4a 	bl	1141c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>
    SetPeripheralClockDivider(kDivideInputBy1);
   10f88:	9b01      	ldr	r3, [sp, #4]
   10f8a:	681b      	ldr	r3, [r3, #0]
   10f8c:	3304      	adds	r3, #4
   10f8e:	681b      	ldr	r3, [r3, #0]
   10f90:	2101      	movs	r1, #1
   10f92:	9801      	ldr	r0, [sp, #4]
   10f94:	4798      	blx	r3
    SetEmcClockDivider(EmcDivider::kSameSpeedAsCpu);
   10f96:	2100      	movs	r1, #0
   10f98:	9801      	ldr	r0, [sp, #4]
   10f9a:	f000 fa73 	bl	11484 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>
    return offset;
   10f9e:	9b03      	ldr	r3, [sp, #12]
  }
   10fa0:	4618      	mov	r0, r3
   10fa2:	b005      	add	sp, #20
   10fa4:	f85d fb04 	ldr.w	pc, [sp], #4
   10fa8:	000f4240 	.word	0x000f4240
   10fac:	1000006c 	.word	0x1000006c
   10fb0:	00b71b00 	.word	0x00b71b00

00010fb4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>:

  void SetPeripheralClockDivider(uint8_t peripheral_divider) override
   10fb4:	b500      	push	{lr}
   10fb6:	b083      	sub	sp, #12
   10fb8:	9001      	str	r0, [sp, #4]
   10fba:	460b      	mov	r3, r1
   10fbc:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(peripheral_divider <= 4, "Divider mustn't exceed 32");
   10fc0:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10fc4:	2b04      	cmp	r3, #4
   10fc6:	d90d      	bls.n	10fe4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x30>
   10fc8:	23ae      	movs	r3, #174	; 0xae
   10fca:	4a0b      	ldr	r2, [pc, #44]	; (10ff8 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x44>)
   10fcc:	490b      	ldr	r1, [pc, #44]	; (10ffc <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x48>)
   10fce:	480c      	ldr	r0, [pc, #48]	; (11000 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x4c>)
   10fd0:	f004 ff44 	bl	15e5c <printf>
   10fd4:	480b      	ldr	r0, [pc, #44]	; (11004 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x50>)
   10fd6:	f002 f975 	bl	132c4 <puts>
   10fda:	2100      	movs	r1, #0
   10fdc:	2001      	movs	r0, #1
   10fde:	f7ff ff09 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   10fe2:	e7fe      	b.n	10fe2 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x2e>
    system_controller->PCLKSEL = peripheral_divider;
   10fe4:	4b08      	ldr	r3, [pc, #32]	; (11008 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)+0x54>)
   10fe6:	681b      	ldr	r3, [r3, #0]
   10fe8:	f89d 2003 	ldrb.w	r2, [sp, #3]
   10fec:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  }
   10ff0:	bf00      	nop
   10ff2:	b003      	add	sp, #12
   10ff4:	f85d fb04 	ldr.w	pc, [sp], #4
   10ff8:	0001972c 	.word	0x0001972c
   10ffc:	00019554 	.word	0x00019554
   11000:	000190a0 	.word	0x000190a0
   11004:	00019140 	.word	0x00019140
   11008:	10000068 	.word	0x10000068

0001100c <Lpc40xxSystemController::GetPeripheralClockDivider() const>:

  uint32_t GetPeripheralClockDivider() const override
   1100c:	b082      	sub	sp, #8
   1100e:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return 1;
#else
    return system_controller->PCLKSEL;
   11010:	4b03      	ldr	r3, [pc, #12]	; (11020 <Lpc40xxSystemController::GetPeripheralClockDivider() const+0x14>)
   11012:	681b      	ldr	r3, [r3, #0]
   11014:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
#endif
  }
   11018:	4618      	mov	r0, r3
   1101a:	b002      	add	sp, #8
   1101c:	4770      	bx	lr
   1101e:	bf00      	nop
   11020:	10000068 	.word	0x10000068

00011024 <Lpc40xxSystemController::GetSystemFrequency() const>:

  uint32_t GetSystemFrequency() const override
   11024:	b082      	sub	sp, #8
   11026:	9001      	str	r0, [sp, #4]
  {
#if defined(HOST_TEST)
    return config::kSystemClockRate;
#else
    return speed_in_hertz;
   11028:	4b02      	ldr	r3, [pc, #8]	; (11034 <Lpc40xxSystemController::GetSystemFrequency() const+0x10>)
   1102a:	681b      	ldr	r3, [r3, #0]
#endif
  }
   1102c:	4618      	mov	r0, r3
   1102e:	b002      	add	sp, #8
   11030:	4770      	bx	lr
   11032:	bf00      	nop
   11034:	1000006c 	.word	0x1000006c

00011038 <Lpc40xxSystemController::GetPeripheralFrequency() const>:

  uint32_t GetPeripheralFrequency() const override
   11038:	b500      	push	{lr}
   1103a:	b085      	sub	sp, #20
   1103c:	9001      	str	r0, [sp, #4]
  {
    uint32_t peripheral_clock_divider = GetPeripheralClockDivider();
   1103e:	9b01      	ldr	r3, [sp, #4]
   11040:	681b      	ldr	r3, [r3, #0]
   11042:	3308      	adds	r3, #8
   11044:	681b      	ldr	r3, [r3, #0]
   11046:	9801      	ldr	r0, [sp, #4]
   11048:	4798      	blx	r3
   1104a:	9002      	str	r0, [sp, #8]
    uint32_t result = 0;  // return 0 if peripheral_clock_divider == 0
   1104c:	2300      	movs	r3, #0
   1104e:	9303      	str	r3, [sp, #12]
    if (peripheral_clock_divider != 0)
   11050:	9b02      	ldr	r3, [sp, #8]
   11052:	2b00      	cmp	r3, #0
   11054:	d00a      	beq.n	1106c <Lpc40xxSystemController::GetPeripheralFrequency() const+0x34>
    {
      result = GetSystemFrequency() / peripheral_clock_divider;
   11056:	9b01      	ldr	r3, [sp, #4]
   11058:	681b      	ldr	r3, [r3, #0]
   1105a:	330c      	adds	r3, #12
   1105c:	681b      	ldr	r3, [r3, #0]
   1105e:	9801      	ldr	r0, [sp, #4]
   11060:	4798      	blx	r3
   11062:	4602      	mov	r2, r0
   11064:	9b02      	ldr	r3, [sp, #8]
   11066:	fbb2 f3f3 	udiv	r3, r2, r3
   1106a:	9303      	str	r3, [sp, #12]
    }
    return result;
   1106c:	9b03      	ldr	r3, [sp, #12]
  }
   1106e:	4618      	mov	r0, r3
   11070:	b005      	add	sp, #20
   11072:	f85d fb04 	ldr.w	pc, [sp], #4
   11076:	Address 0x0000000000011076 is out of bounds.


00011078 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>:

  void PowerUpPeripheral(const PeripheralID & peripheral_select) override
   11078:	b084      	sub	sp, #16
   1107a:	9001      	str	r0, [sp, #4]
   1107c:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_with_enabled_peripheral =
        system_controller->PCONP | (1 << peripheral_select.device_id);
   1107e:	4b09      	ldr	r3, [pc, #36]	; (110a4 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11080:	681b      	ldr	r3, [r3, #0]
   11082:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   11086:	9a00      	ldr	r2, [sp, #0]
   11088:	6812      	ldr	r2, [r2, #0]
   1108a:	2101      	movs	r1, #1
   1108c:	fa01 f202 	lsl.w	r2, r1, r2
   11090:	4313      	orrs	r3, r2
   11092:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_with_enabled_peripheral;
   11094:	4b03      	ldr	r3, [pc, #12]	; (110a4 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   11096:	681b      	ldr	r3, [r3, #0]
   11098:	9a03      	ldr	r2, [sp, #12]
   1109a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   1109e:	bf00      	nop
   110a0:	b004      	add	sp, #16
   110a2:	4770      	bx	lr
   110a4:	10000068 	.word	0x10000068

000110a8 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)>:
  void PowerDownPeripheral(const PeripheralID & peripheral_select) override
   110a8:	b084      	sub	sp, #16
   110aa:	9001      	str	r0, [sp, #4]
   110ac:	9100      	str	r1, [sp, #0]
  {
    auto power_connection_without_enabled_peripheral =
        system_controller->PCONP & (1 << peripheral_select.device_id);
   110ae:	4b09      	ldr	r3, [pc, #36]	; (110d4 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   110b0:	681b      	ldr	r3, [r3, #0]
   110b2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   110b6:	9a00      	ldr	r2, [sp, #0]
   110b8:	6812      	ldr	r2, [r2, #0]
   110ba:	2101      	movs	r1, #1
   110bc:	fa01 f202 	lsl.w	r2, r1, r2
   110c0:	4013      	ands	r3, r2
   110c2:	9303      	str	r3, [sp, #12]

    system_controller->PCONP = power_connection_without_enabled_peripheral;
   110c4:	4b03      	ldr	r3, [pc, #12]	; (110d4 <Lpc40xxSystemController::PowerDownPeripheral(SystemControllerInterface::PeripheralID const&)+0x2c>)
   110c6:	681b      	ldr	r3, [r3, #0]
   110c8:	9a03      	ldr	r2, [sp, #12]
   110ca:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
  }
   110ce:	bf00      	nop
   110d0:	b004      	add	sp, #16
   110d2:	4770      	bx	lr
   110d4:	10000068 	.word	0x10000068

000110d8 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>:

 private:
  void SelectOscillatorSource(OscillatorSource source)
   110d8:	b084      	sub	sp, #16
   110da:	9001      	str	r0, [sp, #4]
   110dc:	460b      	mov	r3, r1
   110de:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    uint32_t source_bit = static_cast<uint32_t>(source);
   110e2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   110e6:	9303      	str	r3, [sp, #12]
    system_controller->CLKSRCSEL =
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   110e8:	4b07      	ldr	r3, [pc, #28]	; (11108 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   110ea:	681b      	ldr	r3, [r3, #0]
   110ec:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
   110f0:	f023 0101 	bic.w	r1, r3, #1
    system_controller->CLKSRCSEL =
   110f4:	4b04      	ldr	r3, [pc, #16]	; (11108 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)+0x30>)
   110f6:	681b      	ldr	r3, [r3, #0]
        (system_controller->CLKSRCSEL & ~(kOscillatorSelect)) | source_bit;
   110f8:	9a03      	ldr	r2, [sp, #12]
   110fa:	430a      	orrs	r2, r1
    system_controller->CLKSRCSEL =
   110fc:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  }
   11100:	bf00      	nop
   11102:	b004      	add	sp, #16
   11104:	4770      	bx	lr
   11106:	bf00      	nop
   11108:	10000068 	.word	0x10000068

0001110c <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>:

  void SelectMainClockSource(MainClockSource source)
   1110c:	b082      	sub	sp, #8
   1110e:	9001      	str	r0, [sp, #4]
   11110:	460b      	mov	r3, r1
   11112:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   11116:	4b08      	ldr	r3, [pc, #32]	; (11138 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   11118:	681b      	ldr	r3, [r3, #0]
   1111a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   1111e:	f423 7180 	bic.w	r1, r3, #256	; 0x100
        static_cast<uint32_t>(source);
   11122:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->CCLKSEL =
   11126:	4b04      	ldr	r3, [pc, #16]	; (11138 <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)+0x2c>)
   11128:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~(kBaseClockSelect)) |
   1112a:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   1112c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   11130:	bf00      	nop
   11132:	b002      	add	sp, #8
   11134:	4770      	bx	lr
   11136:	bf00      	nop
   11138:	10000068 	.word	0x10000068

0001113c <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>:

  void SelectUsbClockSource(UsbSource usb_clock)
   1113c:	b082      	sub	sp, #8
   1113e:	9001      	str	r0, [sp, #4]
   11140:	460b      	mov	r3, r1
   11142:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->USBCLKSEL =
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   11146:	4b08      	ldr	r3, [pc, #32]	; (11168 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11148:	681b      	ldr	r3, [r3, #0]
   1114a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   1114e:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(usb_clock);
   11152:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->USBCLKSEL =
   11156:	4b04      	ldr	r3, [pc, #16]	; (11168 <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)+0x2c>)
   11158:	681b      	ldr	r3, [r3, #0]
        (system_controller->USBCLKSEL & ~(kUsbClockSource)) |
   1115a:	430a      	orrs	r2, r1
    system_controller->USBCLKSEL =
   1115c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  }
   11160:	bf00      	nop
   11162:	b002      	add	sp, #8
   11164:	4770      	bx	lr
   11166:	bf00      	nop
   11168:	10000068 	.word	0x10000068

0001116c <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>:

  void SelectSpifiClockSource(SpifiSource spifi_clock)
   1116c:	b082      	sub	sp, #8
   1116e:	9001      	str	r0, [sp, #4]
   11170:	460b      	mov	r3, r1
   11172:	f8ad 3002 	strh.w	r3, [sp, #2]
  {
    system_controller->SPIFISEL =
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   11176:	4b08      	ldr	r3, [pc, #32]	; (11198 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11178:	681b      	ldr	r3, [r3, #0]
   1117a:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
   1117e:	f423 7140 	bic.w	r1, r3, #768	; 0x300
        static_cast<uint32_t>(spifi_clock);
   11182:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    system_controller->SPIFISEL =
   11186:	4b04      	ldr	r3, [pc, #16]	; (11198 <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)+0x2c>)
   11188:	681b      	ldr	r3, [r3, #0]
        (system_controller->SPIFISEL & ~(kSpifiClockSource)) |
   1118a:	430a      	orrs	r2, r1
    system_controller->SPIFISEL =
   1118c:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
  }
   11190:	bf00      	nop
   11192:	b002      	add	sp, #8
   11194:	4770      	bx	lr
   11196:	bf00      	nop
   11198:	10000068 	.word	0x10000068

0001119c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t CalculatePll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   1119c:	b500      	push	{lr}
   1119e:	b087      	sub	sp, #28
   111a0:	9001      	str	r0, [sp, #4]
   111a2:	460b      	mov	r3, r1
   111a4:	f8ad 3002 	strh.w	r3, [sp, #2]
   111a8:	4613      	mov	r3, r2
   111aa:	f8ad 3000 	strh.w	r3, [sp]
  {
    SJ2_ASSERT_FATAL(desired_speed_in_mhz < 384 && desired_speed_in_mhz > 12,
   111ae:	f8bd 3000 	ldrh.w	r3, [sp]
   111b2:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
   111b6:	d203      	bcs.n	111c0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x24>
   111b8:	f8bd 3000 	ldrh.w	r3, [sp]
   111bc:	2b0c      	cmp	r3, #12
   111be:	d80d      	bhi.n	111dc <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x40>
   111c0:	23ff      	movs	r3, #255	; 0xff
   111c2:	4a34      	ldr	r2, [pc, #208]	; (11294 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   111c4:	4934      	ldr	r1, [pc, #208]	; (11298 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xfc>)
   111c6:	4835      	ldr	r0, [pc, #212]	; (1129c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x100>)
   111c8:	f004 fe48 	bl	15e5c <printf>
   111cc:	4834      	ldr	r0, [pc, #208]	; (112a0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   111ce:	f002 f879 	bl	132c4 <puts>
   111d2:	2100      	movs	r1, #0
   111d4:	2001      	movs	r0, #1
   111d6:	f7ff fe0d 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   111da:	e7fe      	b.n	111da <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x3e>
                     "Frequency must be lower than 384 MHz"
                     "and greater than or equal to 12 MHz");
    bool calculating = true;
   111dc:	2301      	movs	r3, #1
   111de:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32_t multiplier_value;
    if ((desired_speed_in_mhz % static_cast<uint16_t>(input_frequency)) >= 1)
   111e2:	f8bd 3000 	ldrh.w	r3, [sp]
   111e6:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   111ea:	fbb3 f1f2 	udiv	r1, r3, r2
   111ee:	fb02 f201 	mul.w	r2, r2, r1
   111f2:	1a9b      	subs	r3, r3, r2
   111f4:	b29b      	uxth	r3, r3
   111f6:	2b00      	cmp	r3, #0
   111f8:	d009      	beq.n	1120e <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x72>
    {
      multiplier_value = static_cast<uint32_t>(
          (desired_speed_in_mhz / static_cast<uint16_t>(input_frequency)) + 1);
   111fa:	f8bd 2000 	ldrh.w	r2, [sp]
   111fe:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   11202:	fbb2 f3f3 	udiv	r3, r2, r3
   11206:	b29b      	uxth	r3, r3
   11208:	3301      	adds	r3, #1
      multiplier_value = static_cast<uint32_t>(
   1120a:	9304      	str	r3, [sp, #16]
   1120c:	e007      	b.n	1121e <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x82>
    }
    else
    {
      multiplier_value = static_cast<uint32_t>(
          desired_speed_in_mhz / static_cast<uint16_t>(input_frequency));
   1120e:	f8bd 2000 	ldrh.w	r2, [sp]
   11212:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   11216:	fbb2 f3f3 	udiv	r3, r2, r3
   1121a:	b29b      	uxth	r3, r3
      multiplier_value = static_cast<uint32_t>(
   1121c:	9304      	str	r3, [sp, #16]
    }
    uint16_t divider_value = 1;
   1121e:	2301      	movs	r3, #1
   11220:	f8ad 300e 	strh.w	r3, [sp, #14]
    while (calculating)
   11224:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11228:	2b00      	cmp	r3, #0
   1122a:	d02e      	beq.n	1128a <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xee>
    {
      uint16_t current_controlled_oscillator_frequency;
      current_controlled_oscillator_frequency = static_cast<uint16_t>(
   1122c:	9b04      	ldr	r3, [sp, #16]
   1122e:	b29b      	uxth	r3, r3
   11230:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11234:	fb12 f303 	smulbb	r3, r2, r3
   11238:	b29b      	uxth	r3, r3
   1123a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   1123e:	fb12 f303 	smulbb	r3, r2, r3
   11242:	b29b      	uxth	r3, r3
   11244:	005b      	lsls	r3, r3, #1
   11246:	f8ad 300c 	strh.w	r3, [sp, #12]
          (static_cast<uint16_t>(input_frequency) * multiplier_value * 2) *
          divider_value);
      if (current_controlled_oscillator_frequency >= 156)
   1124a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1124e:	2b9b      	cmp	r3, #155	; 0x9b
   11250:	d903      	bls.n	1125a <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xbe>
      {
        calculating = false;
   11252:	2300      	movs	r3, #0
   11254:	f88d 3017 	strb.w	r3, [sp, #23]
   11258:	e7e4      	b.n	11224 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
      }
      else
      {
        divider_value = static_cast<uint16_t>(divider_value * 2);
   1125a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1125e:	005b      	lsls	r3, r3, #1
   11260:	f8ad 300e 	strh.w	r3, [sp, #14]
        SJ2_ASSERT_FATAL(divider_value < 8,
   11264:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   11268:	2b07      	cmp	r3, #7
   1126a:	d9db      	bls.n	11224 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x88>
   1126c:	f240 131b 	movw	r3, #283	; 0x11b
   11270:	4a08      	ldr	r2, [pc, #32]	; (11294 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>)
   11272:	490c      	ldr	r1, [pc, #48]	; (112a4 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x108>)
   11274:	480c      	ldr	r0, [pc, #48]	; (112a8 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x10c>)
   11276:	f004 fdf1 	bl	15e5c <printf>
   1127a:	4809      	ldr	r0, [pc, #36]	; (112a0 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0x104>)
   1127c:	f002 f822 	bl	132c4 <puts>
   11280:	2100      	movs	r1, #0
   11282:	2001      	movs	r0, #1
   11284:	f7ff fdb6 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   11288:	e7fe      	b.n	11288 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)+0xec>
                         "PLL divider value went out of bounds");
      }
    }

    return multiplier_value;
   1128a:	9b04      	ldr	r3, [sp, #16]
  }
   1128c:	4618      	mov	r0, r3
   1128e:	b007      	add	sp, #28
   11290:	f85d fb04 	ldr.w	pc, [sp], #4
   11294:	000197d4 	.word	0x000197d4
   11298:	0001956c 	.word	0x0001956c
   1129c:	00019158 	.word	0x00019158
   112a0:	00019140 	.word	0x00019140
   112a4:	00019584 	.word	0x00019584
   112a8:	00019248 	.word	0x00019248

000112ac <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)>:

  uint32_t SetMainPll(PllInput input_frequency, uint16_t desired_speed_in_mhz)
   112ac:	b510      	push	{r4, lr}
   112ae:	b08a      	sub	sp, #40	; 0x28
   112b0:	9001      	str	r0, [sp, #4]
   112b2:	460b      	mov	r3, r1
   112b4:	f8ad 3002 	strh.w	r3, [sp, #2]
   112b8:	4613      	mov	r3, r2
   112ba:	f8ad 3000 	strh.w	r3, [sp]
  {
    uint16_t divider_value = 1;
   112be:	2301      	movs	r3, #1
   112c0:	f8ad 301a 	strh.w	r3, [sp, #26]
    uint64_t timeout_time  = Milliseconds() + kDefaultTimeout;
   112c4:	f7ff fa58 	bl	10778 <Milliseconds()>
   112c8:	460a      	mov	r2, r1
   112ca:	4601      	mov	r1, r0
   112cc:	f511 737a 	adds.w	r3, r1, #1000	; 0x3e8
   112d0:	f142 0400 	adc.w	r4, r2, #0
   112d4:	e9cd 3404 	strd	r3, r4, [sp, #16]
    uint64_t current_time  = Milliseconds();
   112d8:	f7ff fa4e 	bl	10778 <Milliseconds()>
   112dc:	e9cd 0108 	strd	r0, r1, [sp, #32]
    uint32_t multiplier_value =
        CalculatePll(input_frequency, desired_speed_in_mhz);
   112e0:	f8bd 2000 	ldrh.w	r2, [sp]
   112e4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   112e8:	4619      	mov	r1, r3
   112ea:	9801      	ldr	r0, [sp, #4]
   112ec:	f7ff ff56 	bl	1119c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)>
   112f0:	9003      	str	r0, [sp, #12]
    uint32_t actual_speed =
        static_cast<uint32_t>(input_frequency) * multiplier_value;
   112f2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    uint32_t actual_speed =
   112f6:	9b03      	ldr	r3, [sp, #12]
   112f8:	fb02 f303 	mul.w	r3, r2, r3
   112fc:	9307      	str	r3, [sp, #28]
    // TO DO: use registers to retreive values
    SelectOscillatorSource(OscillatorSource::kIrc);
   112fe:	2100      	movs	r1, #0
   11300:	9801      	ldr	r0, [sp, #4]
   11302:	f7ff fee9 	bl	110d8 <Lpc40xxSystemController::SelectOscillatorSource(Lpc40xxSystemController::OscillatorSource)>
    SelectMainClockSource(MainClockSource::kBaseClock);
   11306:	2100      	movs	r1, #0
   11308:	9801      	ldr	r0, [sp, #4]
   1130a:	f7ff feff 	bl	1110c <Lpc40xxSystemController::SelectMainClockSource(Lpc40xxSystemController::MainClockSource)>
    SelectUsbClockSource(UsbSource::kBaseClock);
   1130e:	2100      	movs	r1, #0
   11310:	9801      	ldr	r0, [sp, #4]
   11312:	f7ff ff13 	bl	1113c <Lpc40xxSystemController::SelectUsbClockSource(Lpc40xxSystemController::UsbSource)>
    SelectSpifiClockSource(SpifiSource::kBaseClock);
   11316:	2100      	movs	r1, #0
   11318:	9801      	ldr	r0, [sp, #4]
   1131a:	f7ff ff27 	bl	1116c <Lpc40xxSystemController::SelectSpifiClockSource(Lpc40xxSystemController::SpifiSource)>
    // must subtract 1 from multiplier value as specified in datasheet
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   1131e:	4b3a      	ldr	r3, [pc, #232]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11320:	681b      	ldr	r3, [r3, #0]
   11322:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   11326:	f023 011f 	bic.w	r1, r3, #31
        (multiplier_value - 1);
   1132a:	9b03      	ldr	r3, [sp, #12]
   1132c:	1e5a      	subs	r2, r3, #1
    system_controller->PLL0CFG =
   1132e:	4b36      	ldr	r3, [pc, #216]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11330:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllMultiplier) |
   11332:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   11334:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CFG =
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   11338:	4b33      	ldr	r3, [pc, #204]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1133a:	681b      	ldr	r3, [r3, #0]
   1133c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   11340:	f023 0260 	bic.w	r2, r3, #96	; 0x60
   11344:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   11348:	015b      	lsls	r3, r3, #5
   1134a:	4619      	mov	r1, r3
    system_controller->PLL0CFG =
   1134c:	4b2e      	ldr	r3, [pc, #184]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1134e:	681b      	ldr	r3, [r3, #0]
        (system_controller->PLL0CFG & ~kClearPllDivider) | (divider_value << 5);
   11350:	430a      	orrs	r2, r1
    system_controller->PLL0CFG =
   11352:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    system_controller->PLL0CON |= kEnablePll;
   11356:	4b2c      	ldr	r3, [pc, #176]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11358:	681b      	ldr	r3, [r3, #0]
   1135a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   1135e:	4b2a      	ldr	r3, [pc, #168]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11360:	681b      	ldr	r3, [r3, #0]
   11362:	f042 0201 	orr.w	r2, r2, #1
   11366:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // nessecary feed sequence to ensure the changes are intentional
    system_controller->PLL0FEED = 0xAA;
   1136a:	4b27      	ldr	r3, [pc, #156]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   1136c:	681b      	ldr	r3, [r3, #0]
   1136e:	22aa      	movs	r2, #170	; 0xaa
   11370:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    system_controller->PLL0FEED = 0x55;
   11374:	4b24      	ldr	r3, [pc, #144]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11376:	681b      	ldr	r3, [r3, #0]
   11378:	2255      	movs	r2, #85	; 0x55
   1137a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   1137e:	4b22      	ldr	r3, [pc, #136]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   11380:	681b      	ldr	r3, [r3, #0]
   11382:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   11386:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1138a:	2b00      	cmp	r3, #0
   1138c:	d109      	bne.n	113a2 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   1138e:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   11392:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   11396:	42a2      	cmp	r2, r4
   11398:	bf08      	it	eq
   1139a:	4299      	cmpeq	r1, r3
   1139c:	d201      	bcs.n	113a2 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf6>
   1139e:	2301      	movs	r3, #1
   113a0:	e000      	b.n	113a4 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xf8>
   113a2:	2300      	movs	r3, #0
   113a4:	2b00      	cmp	r3, #0
   113a6:	d004      	beq.n	113b2 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x106>
           (current_time < timeout_time))
    {
      current_time = Milliseconds();
   113a8:	f7ff f9e6 	bl	10778 <Milliseconds()>
   113ac:	e9cd 0108 	strd	r0, r1, [sp, #32]
    while (!(system_controller->PLL0STAT >> kPlock & 1) &&
   113b0:	e7e5      	b.n	1137e <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0xd2>
    }
    if (!(system_controller->PLL0STAT >> kPlock & 1) &&
   113b2:	4b15      	ldr	r3, [pc, #84]	; (11408 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x15c>)
   113b4:	681b      	ldr	r3, [r3, #0]
   113b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   113ba:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   113be:	2b00      	cmp	r3, #0
   113c0:	d109      	bne.n	113d6 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   113c2:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   113c6:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   113ca:	42a2      	cmp	r2, r4
   113cc:	bf08      	it	eq
   113ce:	4299      	cmpeq	r1, r3
   113d0:	d301      	bcc.n	113d6 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12a>
   113d2:	2301      	movs	r3, #1
   113d4:	e000      	b.n	113d8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x12c>
   113d6:	2300      	movs	r3, #0
   113d8:	2b00      	cmp	r3, #0
   113da:	d00e      	beq.n	113fa <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14e>
        (current_time >= timeout_time))
    {
      SJ2_ASSERT_FATAL(false,
   113dc:	f240 1343 	movw	r3, #323	; 0x143
   113e0:	4a0a      	ldr	r2, [pc, #40]	; (1140c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x160>)
   113e2:	490b      	ldr	r1, [pc, #44]	; (11410 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x164>)
   113e4:	480b      	ldr	r0, [pc, #44]	; (11414 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x168>)
   113e6:	f004 fd39 	bl	15e5c <printf>
   113ea:	480b      	ldr	r0, [pc, #44]	; (11418 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x16c>)
   113ec:	f001 ff6a 	bl	132c4 <puts>
   113f0:	2100      	movs	r1, #0
   113f2:	2001      	movs	r0, #1
   113f4:	f7ff fcfe 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   113f8:	e7fe      	b.n	113f8 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)+0x14c>
                       "PLL lock could not be established before timeout");
      actual_speed = kDefaultIRCFrequency;
    }
    return (actual_speed - desired_speed_in_mhz);
   113fa:	f8bd 3000 	ldrh.w	r3, [sp]
   113fe:	9a07      	ldr	r2, [sp, #28]
   11400:	1ad3      	subs	r3, r2, r3
  }
   11402:	4618      	mov	r0, r3
   11404:	b00a      	add	sp, #40	; 0x28
   11406:	bd10      	pop	{r4, pc}
   11408:	10000068 	.word	0x10000068
   1140c:	00019778 	.word	0x00019778
   11410:	0001959c 	.word	0x0001959c
   11414:	000192f0 	.word	0x000192f0
   11418:	00019140 	.word	0x00019140

0001141c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)>:
                       "PLL lock could not be established before timeout");
    }
    return (actual_speed - desired_speed_in_mhz);
  }

  void SetCpuClockDivider(uint8_t cpu_divider)
   1141c:	b500      	push	{lr}
   1141e:	b083      	sub	sp, #12
   11420:	9001      	str	r0, [sp, #4]
   11422:	460b      	mov	r3, r1
   11424:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    SJ2_ASSERT_FATAL(cpu_divider < 32, "Divider mustn't exceed 32");
   11428:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1142c:	2b1f      	cmp	r3, #31
   1142e:	d90e      	bls.n	1144e <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x32>
   11430:	f240 136f 	movw	r3, #367	; 0x16f
   11434:	4a0e      	ldr	r2, [pc, #56]	; (11470 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x54>)
   11436:	490f      	ldr	r1, [pc, #60]	; (11474 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x58>)
   11438:	480f      	ldr	r0, [pc, #60]	; (11478 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x5c>)
   1143a:	f004 fd0f 	bl	15e5c <printf>
   1143e:	480f      	ldr	r0, [pc, #60]	; (1147c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x60>)
   11440:	f001 ff40 	bl	132c4 <puts>
   11444:	2100      	movs	r1, #0
   11446:	2001      	movs	r0, #1
   11448:	f7ff fcd4 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   1144c:	e7fe      	b.n	1144c <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x30>
    system_controller->CCLKSEL =
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   1144e:	4b0c      	ldr	r3, [pc, #48]	; (11480 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11450:	681b      	ldr	r3, [r3, #0]
   11452:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   11456:	f023 011f 	bic.w	r1, r3, #31
   1145a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->CCLKSEL =
   1145e:	4b08      	ldr	r3, [pc, #32]	; (11480 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)+0x64>)
   11460:	681b      	ldr	r3, [r3, #0]
        (system_controller->CCLKSEL & ~kClearCpuDivider) | cpu_divider;
   11462:	430a      	orrs	r2, r1
    system_controller->CCLKSEL =
   11464:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
   11468:	bf00      	nop
   1146a:	b003      	add	sp, #12
   1146c:	f85d fb04 	ldr.w	pc, [sp], #4
   11470:	00019830 	.word	0x00019830
   11474:	000195b4 	.word	0x000195b4
   11478:	00019398 	.word	0x00019398
   1147c:	00019140 	.word	0x00019140
   11480:	10000068 	.word	0x10000068

00011484 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)>:

  void SetEmcClockDivider(EmcDivider emc_divider)
   11484:	b082      	sub	sp, #8
   11486:	9001      	str	r0, [sp, #4]
   11488:	460b      	mov	r3, r1
   1148a:	f88d 3003 	strb.w	r3, [sp, #3]
  {
    system_controller->EMCCLKSEL =
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   1148e:	4b08      	ldr	r3, [pc, #32]	; (114b0 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   11490:	681b      	ldr	r3, [r3, #0]
   11492:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   11496:	f023 0101 	bic.w	r1, r3, #1
        static_cast<uint8_t>(emc_divider);
   1149a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    system_controller->EMCCLKSEL =
   1149e:	4b04      	ldr	r3, [pc, #16]	; (114b0 <Lpc40xxSystemController::SetEmcClockDivider(Lpc40xxSystemController::EmcDivider)+0x2c>)
   114a0:	681b      	ldr	r3, [r3, #0]
        (system_controller->EMCCLKSEL & ~kClearEmcDivider) |
   114a2:	430a      	orrs	r2, r1
    system_controller->EMCCLKSEL =
   114a4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
   114a8:	bf00      	nop
   114aa:	b002      	add	sp, #8
   114ac:	4770      	bx	lr
   114ae:	bf00      	nop
   114b0:	10000068 	.word	0x10000068

000114b4 <SystemTimer::DisableTimer()>:
  /// system_timer_isr defaults to nullptr. The actual SystemTickHandler should
  /// check if the isr is set to nullptr, and if it is, turn off the timer, if
  /// set a proper function then execute it.
  inline static IsrPointer system_timer_isr = nullptr;
  /// WARNING: Doing so will most likely disable FreeRTOS
  static void DisableTimer()
   114b4:	b510      	push	{r4, lr}
   114b6:	4674      	mov	r4, lr
   114b8:	4623      	mov	r3, r4
   114ba:	4619      	mov	r1, r3
   114bc:	480a      	ldr	r0, [pc, #40]	; (114e8 <SystemTimer::DisableTimer()+0x34>)
   114be:	f001 ff31 	bl	13324 <__cyg_profile_func_enter>
  {
    sys_tick->LOAD = 0;
   114c2:	4b0a      	ldr	r3, [pc, #40]	; (114ec <SystemTimer::DisableTimer()+0x38>)
   114c4:	681b      	ldr	r3, [r3, #0]
   114c6:	2200      	movs	r2, #0
   114c8:	605a      	str	r2, [r3, #4]
    sys_tick->VAL  = 0;
   114ca:	4b08      	ldr	r3, [pc, #32]	; (114ec <SystemTimer::DisableTimer()+0x38>)
   114cc:	681b      	ldr	r3, [r3, #0]
   114ce:	2200      	movs	r2, #0
   114d0:	609a      	str	r2, [r3, #8]
    sys_tick->CTRL = 0;
   114d2:	4b06      	ldr	r3, [pc, #24]	; (114ec <SystemTimer::DisableTimer()+0x38>)
   114d4:	681b      	ldr	r3, [r3, #0]
   114d6:	2200      	movs	r2, #0
   114d8:	601a      	str	r2, [r3, #0]
   114da:	4623      	mov	r3, r4
   114dc:	4619      	mov	r1, r3
   114de:	4802      	ldr	r0, [pc, #8]	; (114e8 <SystemTimer::DisableTimer()+0x34>)
   114e0:	f001 ff34 	bl	1334c <__cyg_profile_func_exit>
  }
   114e4:	bf00      	nop
   114e6:	bd10      	pop	{r4, pc}
   114e8:	000114b5 	.word	0x000114b5
   114ec:	10000070 	.word	0x10000070

000114f0 <SystemTimer::SystemTimerHandler()>:
  static void SystemTimerHandler()
   114f0:	b510      	push	{r4, lr}
   114f2:	4674      	mov	r4, lr
   114f4:	4623      	mov	r3, r4
   114f6:	4619      	mov	r1, r3
   114f8:	4808      	ldr	r0, [pc, #32]	; (1151c <SystemTimer::SystemTimerHandler()+0x2c>)
   114fa:	f001 ff13 	bl	13324 <__cyg_profile_func_enter>
  {
    // This assumes that SysTickHandler is called every millisecond.
    // Changing that frequency will distort the milliseconds time.
    if (system_timer_isr != nullptr)
   114fe:	4b08      	ldr	r3, [pc, #32]	; (11520 <SystemTimer::SystemTimerHandler()+0x30>)
   11500:	681b      	ldr	r3, [r3, #0]
   11502:	2b00      	cmp	r3, #0
   11504:	d002      	beq.n	1150c <SystemTimer::SystemTimerHandler()+0x1c>
    {
      system_timer_isr();
   11506:	4b06      	ldr	r3, [pc, #24]	; (11520 <SystemTimer::SystemTimerHandler()+0x30>)
   11508:	681b      	ldr	r3, [r3, #0]
   1150a:	4798      	blx	r3
   1150c:	4623      	mov	r3, r4
   1150e:	4619      	mov	r1, r3
   11510:	4802      	ldr	r0, [pc, #8]	; (1151c <SystemTimer::SystemTimerHandler()+0x2c>)
   11512:	f001 ff1b 	bl	1334c <__cyg_profile_func_exit>
    }
  }
   11516:	bf00      	nop
   11518:	bd10      	pop	{r4, pc}
   1151a:	bf00      	nop
   1151c:	000114f1 	.word	0x000114f1
   11520:	100003c4 	.word	0x100003c4

00011524 <SystemTimer::SetIsrFunction(void (*)())>:
  constexpr SystemTimer() {}
  void SetIsrFunction(IsrPointer isr) override
   11524:	b510      	push	{r4, lr}
   11526:	b082      	sub	sp, #8
   11528:	4674      	mov	r4, lr
   1152a:	9001      	str	r0, [sp, #4]
   1152c:	9100      	str	r1, [sp, #0]
   1152e:	4623      	mov	r3, r4
   11530:	4619      	mov	r1, r3
   11532:	4807      	ldr	r0, [pc, #28]	; (11550 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   11534:	f001 fef6 	bl	13324 <__cyg_profile_func_enter>
  {
    system_timer_isr = isr;
   11538:	4a06      	ldr	r2, [pc, #24]	; (11554 <SystemTimer::SetIsrFunction(void (*)())+0x30>)
   1153a:	9b00      	ldr	r3, [sp, #0]
   1153c:	6013      	str	r3, [r2, #0]
   1153e:	4623      	mov	r3, r4
   11540:	4619      	mov	r1, r3
   11542:	4803      	ldr	r0, [pc, #12]	; (11550 <SystemTimer::SetIsrFunction(void (*)())+0x2c>)
   11544:	f001 ff02 	bl	1334c <__cyg_profile_func_exit>
  }
   11548:	bf00      	nop
   1154a:	b002      	add	sp, #8
   1154c:	bd10      	pop	{r4, pc}
   1154e:	bf00      	nop
   11550:	00011525 	.word	0x00011525
   11554:	100003c4 	.word	0x100003c4

00011558 <SystemTimer::StartTimer()>:
  bool StartTimer() override
   11558:	b530      	push	{r4, r5, lr}
   1155a:	b085      	sub	sp, #20
   1155c:	4675      	mov	r5, lr
   1155e:	9001      	str	r0, [sp, #4]
   11560:	462b      	mov	r3, r5
   11562:	4619      	mov	r1, r3
   11564:	4820      	ldr	r0, [pc, #128]	; (115e8 <SystemTimer::StartTimer()+0x90>)
   11566:	f001 fedd 	bl	13324 <__cyg_profile_func_enter>
  {
    bool successful = false;
   1156a:	2300      	movs	r3, #0
   1156c:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sys_tick->LOAD != 0)
   11570:	4b1e      	ldr	r3, [pc, #120]	; (115ec <SystemTimer::StartTimer()+0x94>)
   11572:	681b      	ldr	r3, [r3, #0]
   11574:	685b      	ldr	r3, [r3, #4]
   11576:	2b00      	cmp	r3, #0
   11578:	bf14      	ite	ne
   1157a:	2301      	movne	r3, #1
   1157c:	2300      	moveq	r3, #0
   1157e:	b2db      	uxtb	r3, r3
   11580:	2b00      	cmp	r3, #0
   11582:	d01e      	beq.n	115c2 <SystemTimer::StartTimer()+0x6a>
    {
      sys_tick->VAL = 0;
   11584:	4b19      	ldr	r3, [pc, #100]	; (115ec <SystemTimer::StartTimer()+0x94>)
   11586:	681b      	ldr	r3, [r3, #0]
   11588:	2200      	movs	r2, #0
   1158a:	609a      	str	r2, [r3, #8]
      sys_tick->CTRL |= (1 << ControlBitMap::kTickInterupt);
   1158c:	4b17      	ldr	r3, [pc, #92]	; (115ec <SystemTimer::StartTimer()+0x94>)
   1158e:	681b      	ldr	r3, [r3, #0]
   11590:	681a      	ldr	r2, [r3, #0]
   11592:	4b16      	ldr	r3, [pc, #88]	; (115ec <SystemTimer::StartTimer()+0x94>)
   11594:	681b      	ldr	r3, [r3, #0]
   11596:	f042 0202 	orr.w	r2, r2, #2
   1159a:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kEnableCounter);
   1159c:	4b13      	ldr	r3, [pc, #76]	; (115ec <SystemTimer::StartTimer()+0x94>)
   1159e:	681b      	ldr	r3, [r3, #0]
   115a0:	681a      	ldr	r2, [r3, #0]
   115a2:	4b12      	ldr	r3, [pc, #72]	; (115ec <SystemTimer::StartTimer()+0x94>)
   115a4:	681b      	ldr	r3, [r3, #0]
   115a6:	f042 0201 	orr.w	r2, r2, #1
   115aa:	601a      	str	r2, [r3, #0]
      sys_tick->CTRL |= (1 << ControlBitMap::kClkSource);
   115ac:	4b0f      	ldr	r3, [pc, #60]	; (115ec <SystemTimer::StartTimer()+0x94>)
   115ae:	681b      	ldr	r3, [r3, #0]
   115b0:	681a      	ldr	r2, [r3, #0]
   115b2:	4b0e      	ldr	r3, [pc, #56]	; (115ec <SystemTimer::StartTimer()+0x94>)
   115b4:	681b      	ldr	r3, [r3, #0]
   115b6:	f042 0204 	orr.w	r2, r2, #4
   115ba:	601a      	str	r2, [r3, #0]
      successful = true;
   115bc:	2301      	movs	r3, #1
   115be:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    RegisterIsr(SysTick_IRQn, SystemTimerHandler);
   115c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   115c6:	2201      	movs	r2, #1
   115c8:	4909      	ldr	r1, [pc, #36]	; (115f0 <SystemTimer::StartTimer()+0x98>)
   115ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   115ce:	f001 fd55 	bl	1307c <RegisterIsr(IRQn, void (*)(), bool, long)>
    return successful;
   115d2:	f89d 400f 	ldrb.w	r4, [sp, #15]
   115d6:	462b      	mov	r3, r5
   115d8:	4619      	mov	r1, r3
   115da:	4803      	ldr	r0, [pc, #12]	; (115e8 <SystemTimer::StartTimer()+0x90>)
   115dc:	f001 feb6 	bl	1334c <__cyg_profile_func_exit>
   115e0:	4623      	mov	r3, r4
  }
   115e2:	4618      	mov	r0, r3
   115e4:	b005      	add	sp, #20
   115e6:	bd30      	pop	{r4, r5, pc}
   115e8:	00011559 	.word	0x00011559
   115ec:	10000070 	.word	0x10000070
   115f0:	000114f1 	.word	0x000114f1

000115f4 <SystemTimer::SetTickFrequency(unsigned long)>:
  ///          remainder will be returned.
  ///          If the freqency supplied is less then 2Hz, the function will
  ///          return without changing any hardware.
  ///          If the reload value exceeds the SysTick_LOAD_RELOAD_Msk, the
  ///          returned value is the SysTick_LOAD_RELOAD_Msk.
  uint32_t SetTickFrequency(uint32_t frequency) override
   115f4:	b530      	push	{r4, r5, lr}
   115f6:	b085      	sub	sp, #20
   115f8:	4675      	mov	r5, lr
   115fa:	9001      	str	r0, [sp, #4]
   115fc:	9100      	str	r1, [sp, #0]
   115fe:	462b      	mov	r3, r5
   11600:	4619      	mov	r1, r3
   11602:	481f      	ldr	r0, [pc, #124]	; (11680 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   11604:	f001 fe8e 	bl	13324 <__cyg_profile_func_enter>
  {
    if (frequency <= 1)
   11608:	9b00      	ldr	r3, [sp, #0]
   1160a:	2b01      	cmp	r3, #1
   1160c:	d801      	bhi.n	11612 <SystemTimer::SetTickFrequency(unsigned long)+0x1e>
    {
      return 0;
   1160e:	2400      	movs	r4, #0
   11610:	e02d      	b.n	1166e <SystemTimer::SetTickFrequency(unsigned long)+0x7a>
    }
    uint32_t reload_value = (GetSystemFrequency() / frequency) - 1;
   11612:	9b01      	ldr	r3, [sp, #4]
   11614:	1d1a      	adds	r2, r3, #4
   11616:	9b01      	ldr	r3, [sp, #4]
   11618:	685b      	ldr	r3, [r3, #4]
   1161a:	330c      	adds	r3, #12
   1161c:	681b      	ldr	r3, [r3, #0]
   1161e:	4610      	mov	r0, r2
   11620:	4798      	blx	r3
   11622:	4602      	mov	r2, r0
   11624:	9b00      	ldr	r3, [sp, #0]
   11626:	fbb2 f3f3 	udiv	r3, r2, r3
   1162a:	3b01      	subs	r3, #1
   1162c:	9303      	str	r3, [sp, #12]
    int remainder         = (GetSystemFrequency() % frequency);
   1162e:	9b01      	ldr	r3, [sp, #4]
   11630:	1d1a      	adds	r2, r3, #4
   11632:	9b01      	ldr	r3, [sp, #4]
   11634:	685b      	ldr	r3, [r3, #4]
   11636:	330c      	adds	r3, #12
   11638:	681b      	ldr	r3, [r3, #0]
   1163a:	4610      	mov	r0, r2
   1163c:	4798      	blx	r3
   1163e:	4603      	mov	r3, r0
   11640:	9a00      	ldr	r2, [sp, #0]
   11642:	fbb3 f2f2 	udiv	r2, r3, r2
   11646:	9900      	ldr	r1, [sp, #0]
   11648:	fb01 f202 	mul.w	r2, r1, r2
   1164c:	1a9b      	subs	r3, r3, r2
   1164e:	9302      	str	r3, [sp, #8]
    if (reload_value > SysTick_LOAD_RELOAD_Msk)
   11650:	9b03      	ldr	r3, [sp, #12]
   11652:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   11656:	d305      	bcc.n	11664 <SystemTimer::SetTickFrequency(unsigned long)+0x70>
    {
      reload_value = SysTick_LOAD_RELOAD_Msk;
   11658:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   1165c:	9303      	str	r3, [sp, #12]
      remainder    = SysTick_LOAD_RELOAD_Msk;
   1165e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   11662:	9302      	str	r3, [sp, #8]
    }
    sys_tick->LOAD = reload_value;
   11664:	4b07      	ldr	r3, [pc, #28]	; (11684 <SystemTimer::SetTickFrequency(unsigned long)+0x90>)
   11666:	681b      	ldr	r3, [r3, #0]
   11668:	9a03      	ldr	r2, [sp, #12]
   1166a:	605a      	str	r2, [r3, #4]
    return remainder;
   1166c:	9c02      	ldr	r4, [sp, #8]
   1166e:	462b      	mov	r3, r5
   11670:	4619      	mov	r1, r3
   11672:	4803      	ldr	r0, [pc, #12]	; (11680 <SystemTimer::SetTickFrequency(unsigned long)+0x8c>)
   11674:	f001 fe6a 	bl	1334c <__cyg_profile_func_exit>
   11678:	4623      	mov	r3, r4
  }
   1167a:	4618      	mov	r0, r3
   1167c:	b005      	add	sp, #20
   1167e:	bd30      	pop	{r4, r5, pc}
   11680:	000115f5 	.word	0x000115f5
   11684:	10000070 	.word	0x10000070

00011688 <Pin::SetPinFunction(unsigned char)>:
  }
  constexpr Pin(uint8_t port_number, uint8_t pin_number)
      : port_(port_number), pin_(pin_number)
  {
  }
  void SetPinFunction(uint8_t function) override
   11688:	b5f0      	push	{r4, r5, r6, r7, lr}
   1168a:	b085      	sub	sp, #20
   1168c:	4677      	mov	r7, lr
   1168e:	9003      	str	r0, [sp, #12]
   11690:	460b      	mov	r3, r1
   11692:	f88d 300b 	strb.w	r3, [sp, #11]
   11696:	463b      	mov	r3, r7
   11698:	4619      	mov	r1, r3
   1169a:	4817      	ldr	r0, [pc, #92]	; (116f8 <Pin::SetPinFunction(unsigned char)+0x70>)
   1169c:	f001 fe42 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   116a0:	4b16      	ldr	r3, [pc, #88]	; (116fc <Pin::SetPinFunction(unsigned char)+0x74>)
   116a2:	681b      	ldr	r3, [r3, #0]
   116a4:	9a03      	ldr	r2, [sp, #12]
   116a6:	7912      	ldrb	r2, [r2, #4]
   116a8:	4610      	mov	r0, r2
   116aa:	9a03      	ldr	r2, [sp, #12]
   116ac:	7952      	ldrb	r2, [r2, #5]
   116ae:	4611      	mov	r1, r2
   116b0:	0142      	lsls	r2, r0, #5
   116b2:	440a      	add	r2, r1
   116b4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 function & 0b111, 3);
   116b8:	f89d 300b 	ldrb.w	r3, [sp, #11]
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   116bc:	f003 0207 	and.w	r2, r3, #7
    pin_map->_register[port_][pin_] =
   116c0:	4b0e      	ldr	r3, [pc, #56]	; (116fc <Pin::SetPinFunction(unsigned char)+0x74>)
   116c2:	681c      	ldr	r4, [r3, #0]
   116c4:	9b03      	ldr	r3, [sp, #12]
   116c6:	791b      	ldrb	r3, [r3, #4]
   116c8:	461e      	mov	r6, r3
   116ca:	9b03      	ldr	r3, [sp, #12]
   116cc:	795b      	ldrb	r3, [r3, #5]
   116ce:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kFunction,
   116d0:	2303      	movs	r3, #3
   116d2:	9300      	str	r3, [sp, #0]
   116d4:	4613      	mov	r3, r2
   116d6:	2200      	movs	r2, #0
   116d8:	9803      	ldr	r0, [sp, #12]
   116da:	f000 fa67 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   116de:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   116e0:	0173      	lsls	r3, r6, #5
   116e2:	442b      	add	r3, r5
   116e4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   116e8:	463b      	mov	r3, r7
   116ea:	4619      	mov	r1, r3
   116ec:	4802      	ldr	r0, [pc, #8]	; (116f8 <Pin::SetPinFunction(unsigned char)+0x70>)
   116ee:	f001 fe2d 	bl	1334c <__cyg_profile_func_exit>
  }
   116f2:	bf00      	nop
   116f4:	b005      	add	sp, #20
   116f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   116f8:	00011689 	.word	0x00011689
   116fc:	10000074 	.word	0x10000074

00011700 <Pin::SetMode(PinInterface::Mode)>:
  void SetMode(PinInterface::Mode mode) override
   11700:	b5f0      	push	{r4, r5, r6, r7, lr}
   11702:	b087      	sub	sp, #28
   11704:	4677      	mov	r7, lr
   11706:	9003      	str	r0, [sp, #12]
   11708:	460b      	mov	r3, r1
   1170a:	f88d 300b 	strb.w	r3, [sp, #11]
   1170e:	463b      	mov	r3, r7
   11710:	4619      	mov	r1, r3
   11712:	4819      	ldr	r0, [pc, #100]	; (11778 <Pin::SetMode(PinInterface::Mode)+0x78>)
   11714:	f001 fe06 	bl	13324 <__cyg_profile_func_enter>
  {
    uint8_t ui_mode                 = static_cast<uint8_t>(mode);
   11718:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1171c:	f88d 3017 	strb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   11720:	4b16      	ldr	r3, [pc, #88]	; (1177c <Pin::SetMode(PinInterface::Mode)+0x7c>)
   11722:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   11724:	9a03      	ldr	r2, [sp, #12]
   11726:	7912      	ldrb	r2, [r2, #4]
   11728:	4610      	mov	r0, r2
   1172a:	9a03      	ldr	r2, [sp, #12]
   1172c:	7952      	ldrb	r2, [r2, #5]
   1172e:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   11730:	0142      	lsls	r2, r0, #5
   11732:	440a      	add	r2, r1
   11734:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
        pin_map->_register[port_][pin_], PinBitMap::kMode, ui_mode & 0b11, 2);
   11738:	f89d 3017 	ldrb.w	r3, [sp, #23]
    pin_map->_register[port_][pin_] = BitPlace(
   1173c:	f003 0203 	and.w	r2, r3, #3
   11740:	4b0e      	ldr	r3, [pc, #56]	; (1177c <Pin::SetMode(PinInterface::Mode)+0x7c>)
   11742:	681c      	ldr	r4, [r3, #0]
   11744:	9b03      	ldr	r3, [sp, #12]
   11746:	791b      	ldrb	r3, [r3, #4]
   11748:	461e      	mov	r6, r3
   1174a:	9b03      	ldr	r3, [sp, #12]
   1174c:	795b      	ldrb	r3, [r3, #5]
   1174e:	461d      	mov	r5, r3
   11750:	2302      	movs	r3, #2
   11752:	9300      	str	r3, [sp, #0]
   11754:	4613      	mov	r3, r2
   11756:	2203      	movs	r2, #3
   11758:	9803      	ldr	r0, [sp, #12]
   1175a:	f000 fa27 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1175e:	4602      	mov	r2, r0
   11760:	0173      	lsls	r3, r6, #5
   11762:	442b      	add	r3, r5
   11764:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11768:	463b      	mov	r3, r7
   1176a:	4619      	mov	r1, r3
   1176c:	4802      	ldr	r0, [pc, #8]	; (11778 <Pin::SetMode(PinInterface::Mode)+0x78>)
   1176e:	f001 fded 	bl	1334c <__cyg_profile_func_exit>
  }
   11772:	bf00      	nop
   11774:	b007      	add	sp, #28
   11776:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11778:	00011701 	.word	0x00011701
   1177c:	10000074 	.word	0x10000074

00011780 <Pin::EnableHysteresis(bool)>:
  void EnableHysteresis(bool enable_hysteresis = true) override
   11780:	b5f0      	push	{r4, r5, r6, r7, lr}
   11782:	b085      	sub	sp, #20
   11784:	4677      	mov	r7, lr
   11786:	9003      	str	r0, [sp, #12]
   11788:	460b      	mov	r3, r1
   1178a:	f88d 300b 	strb.w	r3, [sp, #11]
   1178e:	463b      	mov	r3, r7
   11790:	4619      	mov	r1, r3
   11792:	4816      	ldr	r0, [pc, #88]	; (117ec <Pin::EnableHysteresis(bool)+0x6c>)
   11794:	f001 fdc6 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   11798:	4b15      	ldr	r3, [pc, #84]	; (117f0 <Pin::EnableHysteresis(bool)+0x70>)
   1179a:	681b      	ldr	r3, [r3, #0]
   1179c:	9a03      	ldr	r2, [sp, #12]
   1179e:	7912      	ldrb	r2, [r2, #4]
   117a0:	4610      	mov	r0, r2
   117a2:	9a03      	ldr	r2, [sp, #12]
   117a4:	7952      	ldrb	r2, [r2, #5]
   117a6:	4611      	mov	r1, r2
   117a8:	0142      	lsls	r2, r0, #5
   117aa:	440a      	add	r2, r1
   117ac:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   117b0:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   117b4:	4b0e      	ldr	r3, [pc, #56]	; (117f0 <Pin::EnableHysteresis(bool)+0x70>)
   117b6:	681c      	ldr	r4, [r3, #0]
   117b8:	9b03      	ldr	r3, [sp, #12]
   117ba:	791b      	ldrb	r3, [r3, #4]
   117bc:	461e      	mov	r6, r3
   117be:	9b03      	ldr	r3, [sp, #12]
   117c0:	795b      	ldrb	r3, [r3, #5]
   117c2:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kHysteresis,
   117c4:	2301      	movs	r3, #1
   117c6:	9300      	str	r3, [sp, #0]
   117c8:	4613      	mov	r3, r2
   117ca:	2205      	movs	r2, #5
   117cc:	9803      	ldr	r0, [sp, #12]
   117ce:	f000 f9ed 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   117d2:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   117d4:	0173      	lsls	r3, r6, #5
   117d6:	442b      	add	r3, r5
   117d8:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   117dc:	463b      	mov	r3, r7
   117de:	4619      	mov	r1, r3
   117e0:	4802      	ldr	r0, [pc, #8]	; (117ec <Pin::EnableHysteresis(bool)+0x6c>)
   117e2:	f001 fdb3 	bl	1334c <__cyg_profile_func_exit>
                 enable_hysteresis, 1);
  }
   117e6:	bf00      	nop
   117e8:	b005      	add	sp, #20
   117ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   117ec:	00011781 	.word	0x00011781
   117f0:	10000074 	.word	0x10000074

000117f4 <Pin::SetAsActiveLow(bool)>:
  void SetAsActiveLow(bool set_as_active_low = true) override
   117f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   117f6:	b085      	sub	sp, #20
   117f8:	4677      	mov	r7, lr
   117fa:	9003      	str	r0, [sp, #12]
   117fc:	460b      	mov	r3, r1
   117fe:	f88d 300b 	strb.w	r3, [sp, #11]
   11802:	463b      	mov	r3, r7
   11804:	4619      	mov	r1, r3
   11806:	4816      	ldr	r0, [pc, #88]	; (11860 <Pin::SetAsActiveLow(bool)+0x6c>)
   11808:	f001 fd8c 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   1180c:	4b15      	ldr	r3, [pc, #84]	; (11864 <Pin::SetAsActiveLow(bool)+0x70>)
   1180e:	681b      	ldr	r3, [r3, #0]
   11810:	9a03      	ldr	r2, [sp, #12]
   11812:	7912      	ldrb	r2, [r2, #4]
   11814:	4610      	mov	r0, r2
   11816:	9a03      	ldr	r2, [sp, #12]
   11818:	7952      	ldrb	r2, [r2, #5]
   1181a:	4611      	mov	r1, r2
   1181c:	0142      	lsls	r2, r0, #5
   1181e:	440a      	add	r2, r1
   11820:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11824:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11828:	4b0e      	ldr	r3, [pc, #56]	; (11864 <Pin::SetAsActiveLow(bool)+0x70>)
   1182a:	681c      	ldr	r4, [r3, #0]
   1182c:	9b03      	ldr	r3, [sp, #12]
   1182e:	791b      	ldrb	r3, [r3, #4]
   11830:	461e      	mov	r6, r3
   11832:	9b03      	ldr	r3, [sp, #12]
   11834:	795b      	ldrb	r3, [r3, #5]
   11836:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kInputInvert,
   11838:	2301      	movs	r3, #1
   1183a:	9300      	str	r3, [sp, #0]
   1183c:	4613      	mov	r3, r2
   1183e:	2206      	movs	r2, #6
   11840:	9803      	ldr	r0, [sp, #12]
   11842:	f000 f9b3 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11846:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11848:	0173      	lsls	r3, r6, #5
   1184a:	442b      	add	r3, r5
   1184c:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11850:	463b      	mov	r3, r7
   11852:	4619      	mov	r1, r3
   11854:	4802      	ldr	r0, [pc, #8]	; (11860 <Pin::SetAsActiveLow(bool)+0x6c>)
   11856:	f001 fd79 	bl	1334c <__cyg_profile_func_exit>
                 set_as_active_low, 1);
  }
   1185a:	bf00      	nop
   1185c:	b005      	add	sp, #20
   1185e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11860:	000117f5 	.word	0x000117f5
   11864:	10000074 	.word	0x10000074

00011868 <Pin::SetAsAnalogMode(bool)>:
  // Set bit to 0 to enable analog mode
  void SetAsAnalogMode(bool set_as_analog = true) override
   11868:	b5f0      	push	{r4, r5, r6, r7, lr}
   1186a:	b085      	sub	sp, #20
   1186c:	4677      	mov	r7, lr
   1186e:	9003      	str	r0, [sp, #12]
   11870:	460b      	mov	r3, r1
   11872:	f88d 300b 	strb.w	r3, [sp, #11]
   11876:	463b      	mov	r3, r7
   11878:	4619      	mov	r1, r3
   1187a:	4818      	ldr	r0, [pc, #96]	; (118dc <Pin::SetAsAnalogMode(bool)+0x74>)
   1187c:	f001 fd52 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   11880:	4b17      	ldr	r3, [pc, #92]	; (118e0 <Pin::SetAsAnalogMode(bool)+0x78>)
   11882:	681b      	ldr	r3, [r3, #0]
   11884:	9a03      	ldr	r2, [sp, #12]
   11886:	7912      	ldrb	r2, [r2, #4]
   11888:	4610      	mov	r0, r2
   1188a:	9a03      	ldr	r2, [sp, #12]
   1188c:	7952      	ldrb	r2, [r2, #5]
   1188e:	4611      	mov	r1, r2
   11890:	0142      	lsls	r2, r0, #5
   11892:	440a      	add	r2, r1
   11894:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !set_as_analog, 1);
   11898:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1189c:	f083 0301 	eor.w	r3, r3, #1
   118a0:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   118a2:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   118a4:	4b0e      	ldr	r3, [pc, #56]	; (118e0 <Pin::SetAsAnalogMode(bool)+0x78>)
   118a6:	681c      	ldr	r4, [r3, #0]
   118a8:	9b03      	ldr	r3, [sp, #12]
   118aa:	791b      	ldrb	r3, [r3, #4]
   118ac:	461e      	mov	r6, r3
   118ae:	9b03      	ldr	r3, [sp, #12]
   118b0:	795b      	ldrb	r3, [r3, #5]
   118b2:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kAnalogDigitalMode,
   118b4:	2301      	movs	r3, #1
   118b6:	9300      	str	r3, [sp, #0]
   118b8:	4613      	mov	r3, r2
   118ba:	2207      	movs	r2, #7
   118bc:	9803      	ldr	r0, [sp, #12]
   118be:	f000 f975 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   118c2:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   118c4:	0173      	lsls	r3, r6, #5
   118c6:	442b      	add	r3, r5
   118c8:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   118cc:	463b      	mov	r3, r7
   118ce:	4619      	mov	r1, r3
   118d0:	4802      	ldr	r0, [pc, #8]	; (118dc <Pin::SetAsAnalogMode(bool)+0x74>)
   118d2:	f001 fd3b 	bl	1334c <__cyg_profile_func_exit>
  }
   118d6:	bf00      	nop
   118d8:	b005      	add	sp, #20
   118da:	bdf0      	pop	{r4, r5, r6, r7, pc}
   118dc:	00011869 	.word	0x00011869
   118e0:	10000074 	.word	0x10000074

000118e4 <Pin::EnableDigitalFilter(bool)>:
  // Enable by setting bit to 0 to enable digital filter.
  void EnableDigitalFilter(bool enable_digital_filter = true) override
   118e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   118e6:	b085      	sub	sp, #20
   118e8:	4677      	mov	r7, lr
   118ea:	9003      	str	r0, [sp, #12]
   118ec:	460b      	mov	r3, r1
   118ee:	f88d 300b 	strb.w	r3, [sp, #11]
   118f2:	463b      	mov	r3, r7
   118f4:	4619      	mov	r1, r3
   118f6:	4818      	ldr	r0, [pc, #96]	; (11958 <Pin::EnableDigitalFilter(bool)+0x74>)
   118f8:	f001 fd14 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   118fc:	4b17      	ldr	r3, [pc, #92]	; (1195c <Pin::EnableDigitalFilter(bool)+0x78>)
   118fe:	681b      	ldr	r3, [r3, #0]
   11900:	9a03      	ldr	r2, [sp, #12]
   11902:	7912      	ldrb	r2, [r2, #4]
   11904:	4610      	mov	r0, r2
   11906:	9a03      	ldr	r2, [sp, #12]
   11908:	7952      	ldrb	r2, [r2, #5]
   1190a:	4611      	mov	r1, r2
   1190c:	0142      	lsls	r2, r0, #5
   1190e:	440a      	add	r2, r1
   11910:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_digital_filter, 1);
   11914:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11918:	f083 0301 	eor.w	r3, r3, #1
   1191c:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   1191e:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11920:	4b0e      	ldr	r3, [pc, #56]	; (1195c <Pin::EnableDigitalFilter(bool)+0x78>)
   11922:	681c      	ldr	r4, [r3, #0]
   11924:	9b03      	ldr	r3, [sp, #12]
   11926:	791b      	ldrb	r3, [r3, #4]
   11928:	461e      	mov	r6, r3
   1192a:	9b03      	ldr	r3, [sp, #12]
   1192c:	795b      	ldrb	r3, [r3, #5]
   1192e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kDigitalFilter,
   11930:	2301      	movs	r3, #1
   11932:	9300      	str	r3, [sp, #0]
   11934:	4613      	mov	r3, r2
   11936:	2208      	movs	r2, #8
   11938:	9803      	ldr	r0, [sp, #12]
   1193a:	f000 f937 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   1193e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11940:	0173      	lsls	r3, r6, #5
   11942:	442b      	add	r3, r5
   11944:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11948:	463b      	mov	r3, r7
   1194a:	4619      	mov	r1, r3
   1194c:	4802      	ldr	r0, [pc, #8]	; (11958 <Pin::EnableDigitalFilter(bool)+0x74>)
   1194e:	f001 fcfd 	bl	1334c <__cyg_profile_func_exit>
  }
   11952:	bf00      	nop
   11954:	b005      	add	sp, #20
   11956:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11958:	000118e5 	.word	0x000118e5
   1195c:	10000074 	.word	0x10000074

00011960 <Pin::EnableFastMode(bool)>:
  void EnableFastMode(bool enable_fast_mode = true) override
   11960:	b5f0      	push	{r4, r5, r6, r7, lr}
   11962:	b085      	sub	sp, #20
   11964:	4677      	mov	r7, lr
   11966:	9003      	str	r0, [sp, #12]
   11968:	460b      	mov	r3, r1
   1196a:	f88d 300b 	strb.w	r3, [sp, #11]
   1196e:	463b      	mov	r3, r7
   11970:	4619      	mov	r1, r3
   11972:	4816      	ldr	r0, [pc, #88]	; (119cc <Pin::EnableFastMode(bool)+0x6c>)
   11974:	f001 fcd6 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   11978:	4b15      	ldr	r3, [pc, #84]	; (119d0 <Pin::EnableFastMode(bool)+0x70>)
   1197a:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kSlew, enable_fast_mode, 1);
   1197c:	9a03      	ldr	r2, [sp, #12]
   1197e:	7912      	ldrb	r2, [r2, #4]
   11980:	4610      	mov	r0, r2
   11982:	9a03      	ldr	r2, [sp, #12]
   11984:	7952      	ldrb	r2, [r2, #5]
   11986:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   11988:	0142      	lsls	r2, r0, #5
   1198a:	440a      	add	r2, r1
   1198c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11990:	f89d 200b 	ldrb.w	r2, [sp, #11]
   11994:	4b0e      	ldr	r3, [pc, #56]	; (119d0 <Pin::EnableFastMode(bool)+0x70>)
   11996:	681c      	ldr	r4, [r3, #0]
   11998:	9b03      	ldr	r3, [sp, #12]
   1199a:	791b      	ldrb	r3, [r3, #4]
   1199c:	461e      	mov	r6, r3
   1199e:	9b03      	ldr	r3, [sp, #12]
   119a0:	795b      	ldrb	r3, [r3, #5]
   119a2:	461d      	mov	r5, r3
   119a4:	2301      	movs	r3, #1
   119a6:	9300      	str	r3, [sp, #0]
   119a8:	4613      	mov	r3, r2
   119aa:	2209      	movs	r2, #9
   119ac:	9803      	ldr	r0, [sp, #12]
   119ae:	f000 f8fd 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   119b2:	4602      	mov	r2, r0
   119b4:	0173      	lsls	r3, r6, #5
   119b6:	442b      	add	r3, r5
   119b8:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   119bc:	463b      	mov	r3, r7
   119be:	4619      	mov	r1, r3
   119c0:	4802      	ldr	r0, [pc, #8]	; (119cc <Pin::EnableFastMode(bool)+0x6c>)
   119c2:	f001 fcc3 	bl	1334c <__cyg_profile_func_exit>
  }
   119c6:	bf00      	nop
   119c8:	b005      	add	sp, #20
   119ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
   119cc:	00011961 	.word	0x00011961
   119d0:	10000074 	.word	0x10000074

000119d4 <Pin::EnableI2cHighSpeedMode(bool)>:
  // Enable by setting bit to 0 for i2c high speed mode
  void EnableI2cHighSpeedMode(bool enable_high_speed = true) override
   119d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   119d6:	b085      	sub	sp, #20
   119d8:	4677      	mov	r7, lr
   119da:	9003      	str	r0, [sp, #12]
   119dc:	460b      	mov	r3, r1
   119de:	f88d 300b 	strb.w	r3, [sp, #11]
   119e2:	463b      	mov	r3, r7
   119e4:	4619      	mov	r1, r3
   119e6:	4818      	ldr	r0, [pc, #96]	; (11a48 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   119e8:	f001 fc9c 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   119ec:	4b17      	ldr	r3, [pc, #92]	; (11a4c <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   119ee:	681b      	ldr	r3, [r3, #0]
   119f0:	9a03      	ldr	r2, [sp, #12]
   119f2:	7912      	ldrb	r2, [r2, #4]
   119f4:	4610      	mov	r0, r2
   119f6:	9a03      	ldr	r2, [sp, #12]
   119f8:	7952      	ldrb	r2, [r2, #5]
   119fa:	4611      	mov	r1, r2
   119fc:	0142      	lsls	r2, r0, #5
   119fe:	440a      	add	r2, r1
   11a00:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
                 !enable_high_speed, 1);
   11a04:	f89d 300b 	ldrb.w	r3, [sp, #11]
   11a08:	f083 0301 	eor.w	r3, r3, #1
   11a0c:	b2db      	uxtb	r3, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11a0e:	461a      	mov	r2, r3
    pin_map->_register[port_][pin_] =
   11a10:	4b0e      	ldr	r3, [pc, #56]	; (11a4c <Pin::EnableI2cHighSpeedMode(bool)+0x78>)
   11a12:	681c      	ldr	r4, [r3, #0]
   11a14:	9b03      	ldr	r3, [sp, #12]
   11a16:	791b      	ldrb	r3, [r3, #4]
   11a18:	461e      	mov	r6, r3
   11a1a:	9b03      	ldr	r3, [sp, #12]
   11a1c:	795b      	ldrb	r3, [r3, #5]
   11a1e:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kI2cHighSpeed,
   11a20:	2301      	movs	r3, #1
   11a22:	9300      	str	r3, [sp, #0]
   11a24:	4613      	mov	r3, r2
   11a26:	2208      	movs	r2, #8
   11a28:	9803      	ldr	r0, [sp, #12]
   11a2a:	f000 f8bf 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11a2e:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11a30:	0173      	lsls	r3, r6, #5
   11a32:	442b      	add	r3, r5
   11a34:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11a38:	463b      	mov	r3, r7
   11a3a:	4619      	mov	r1, r3
   11a3c:	4802      	ldr	r0, [pc, #8]	; (11a48 <Pin::EnableI2cHighSpeedMode(bool)+0x74>)
   11a3e:	f001 fc85 	bl	1334c <__cyg_profile_func_exit>
  }
   11a42:	bf00      	nop
   11a44:	b005      	add	sp, #20
   11a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11a48:	000119d5 	.word	0x000119d5
   11a4c:	10000074 	.word	0x10000074

00011a50 <Pin::EnableI2cHighCurrentDrive(bool)>:
  void EnableI2cHighCurrentDrive(bool enable_high_current = true) override
   11a50:	b5f0      	push	{r4, r5, r6, r7, lr}
   11a52:	b085      	sub	sp, #20
   11a54:	4677      	mov	r7, lr
   11a56:	9003      	str	r0, [sp, #12]
   11a58:	460b      	mov	r3, r1
   11a5a:	f88d 300b 	strb.w	r3, [sp, #11]
   11a5e:	463b      	mov	r3, r7
   11a60:	4619      	mov	r1, r3
   11a62:	4816      	ldr	r0, [pc, #88]	; (11abc <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   11a64:	f001 fc5e 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_],
   11a68:	4b15      	ldr	r3, [pc, #84]	; (11ac0 <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   11a6a:	681b      	ldr	r3, [r3, #0]
   11a6c:	9a03      	ldr	r2, [sp, #12]
   11a6e:	7912      	ldrb	r2, [r2, #4]
   11a70:	4610      	mov	r0, r2
   11a72:	9a03      	ldr	r2, [sp, #12]
   11a74:	7952      	ldrb	r2, [r2, #5]
   11a76:	4611      	mov	r1, r2
   11a78:	0142      	lsls	r2, r0, #5
   11a7a:	440a      	add	r2, r1
   11a7c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11a80:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11a84:	4b0e      	ldr	r3, [pc, #56]	; (11ac0 <Pin::EnableI2cHighCurrentDrive(bool)+0x70>)
   11a86:	681c      	ldr	r4, [r3, #0]
   11a88:	9b03      	ldr	r3, [sp, #12]
   11a8a:	791b      	ldrb	r3, [r3, #4]
   11a8c:	461e      	mov	r6, r3
   11a8e:	9b03      	ldr	r3, [sp, #12]
   11a90:	795b      	ldrb	r3, [r3, #5]
   11a92:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_],
   11a94:	2301      	movs	r3, #1
   11a96:	9300      	str	r3, [sp, #0]
   11a98:	4613      	mov	r3, r2
   11a9a:	2209      	movs	r2, #9
   11a9c:	9803      	ldr	r0, [sp, #12]
   11a9e:	f000 f885 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11aa2:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11aa4:	0173      	lsls	r3, r6, #5
   11aa6:	442b      	add	r3, r5
   11aa8:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11aac:	463b      	mov	r3, r7
   11aae:	4619      	mov	r1, r3
   11ab0:	4802      	ldr	r0, [pc, #8]	; (11abc <Pin::EnableI2cHighCurrentDrive(bool)+0x6c>)
   11ab2:	f001 fc4b 	bl	1334c <__cyg_profile_func_exit>
                 PinBitMap::kI2cHighCurrentDrive, enable_high_current, 1);
  }
   11ab6:	bf00      	nop
   11ab8:	b005      	add	sp, #20
   11aba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11abc:	00011a51 	.word	0x00011a51
   11ac0:	10000074 	.word	0x10000074

00011ac4 <Pin::SetAsOpenDrain(bool)>:
  void SetAsOpenDrain(bool set_as_open_drain = true) override
   11ac4:	b5f0      	push	{r4, r5, r6, r7, lr}
   11ac6:	b085      	sub	sp, #20
   11ac8:	4677      	mov	r7, lr
   11aca:	9003      	str	r0, [sp, #12]
   11acc:	460b      	mov	r3, r1
   11ace:	f88d 300b 	strb.w	r3, [sp, #11]
   11ad2:	463b      	mov	r3, r7
   11ad4:	4619      	mov	r1, r3
   11ad6:	4816      	ldr	r0, [pc, #88]	; (11b30 <Pin::SetAsOpenDrain(bool)+0x6c>)
   11ad8:	f001 fc24 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] =
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   11adc:	4b15      	ldr	r3, [pc, #84]	; (11b34 <Pin::SetAsOpenDrain(bool)+0x70>)
   11ade:	681b      	ldr	r3, [r3, #0]
   11ae0:	9a03      	ldr	r2, [sp, #12]
   11ae2:	7912      	ldrb	r2, [r2, #4]
   11ae4:	4610      	mov	r0, r2
   11ae6:	9a03      	ldr	r2, [sp, #12]
   11ae8:	7952      	ldrb	r2, [r2, #5]
   11aea:	4611      	mov	r1, r2
   11aec:	0142      	lsls	r2, r0, #5
   11aee:	440a      	add	r2, r1
   11af0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11af4:	f89d 200b 	ldrb.w	r2, [sp, #11]
    pin_map->_register[port_][pin_] =
   11af8:	4b0e      	ldr	r3, [pc, #56]	; (11b34 <Pin::SetAsOpenDrain(bool)+0x70>)
   11afa:	681c      	ldr	r4, [r3, #0]
   11afc:	9b03      	ldr	r3, [sp, #12]
   11afe:	791b      	ldrb	r3, [r3, #4]
   11b00:	461e      	mov	r6, r3
   11b02:	9b03      	ldr	r3, [sp, #12]
   11b04:	795b      	ldrb	r3, [r3, #5]
   11b06:	461d      	mov	r5, r3
        BitPlace(pin_map->_register[port_][pin_], PinBitMap::kOpenDrain,
   11b08:	2301      	movs	r3, #1
   11b0a:	9300      	str	r3, [sp, #0]
   11b0c:	4613      	mov	r3, r2
   11b0e:	220a      	movs	r2, #10
   11b10:	9803      	ldr	r0, [sp, #12]
   11b12:	f000 f84b 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11b16:	4602      	mov	r2, r0
    pin_map->_register[port_][pin_] =
   11b18:	0173      	lsls	r3, r6, #5
   11b1a:	442b      	add	r3, r5
   11b1c:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11b20:	463b      	mov	r3, r7
   11b22:	4619      	mov	r1, r3
   11b24:	4802      	ldr	r0, [pc, #8]	; (11b30 <Pin::SetAsOpenDrain(bool)+0x6c>)
   11b26:	f001 fc11 	bl	1334c <__cyg_profile_func_exit>
                 set_as_open_drain, 1);
  }
   11b2a:	bf00      	nop
   11b2c:	b005      	add	sp, #20
   11b2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11b30:	00011ac5 	.word	0x00011ac5
   11b34:	10000074 	.word	0x10000074

00011b38 <Pin::EnableDac(bool)>:
  void EnableDac(bool enable_dac = true) override
   11b38:	b5f0      	push	{r4, r5, r6, r7, lr}
   11b3a:	b085      	sub	sp, #20
   11b3c:	4677      	mov	r7, lr
   11b3e:	9003      	str	r0, [sp, #12]
   11b40:	460b      	mov	r3, r1
   11b42:	f88d 300b 	strb.w	r3, [sp, #11]
   11b46:	463b      	mov	r3, r7
   11b48:	4619      	mov	r1, r3
   11b4a:	4816      	ldr	r0, [pc, #88]	; (11ba4 <Pin::EnableDac(bool)+0x6c>)
   11b4c:	f001 fbea 	bl	13324 <__cyg_profile_func_enter>
  {
    pin_map->_register[port_][pin_] = BitPlace(
   11b50:	4b15      	ldr	r3, [pc, #84]	; (11ba8 <Pin::EnableDac(bool)+0x70>)
   11b52:	681b      	ldr	r3, [r3, #0]
        pin_map->_register[port_][pin_], PinBitMap::kDacEnable, enable_dac, 1);
   11b54:	9a03      	ldr	r2, [sp, #12]
   11b56:	7912      	ldrb	r2, [r2, #4]
   11b58:	4610      	mov	r0, r2
   11b5a:	9a03      	ldr	r2, [sp, #12]
   11b5c:	7952      	ldrb	r2, [r2, #5]
   11b5e:	4611      	mov	r1, r2
    pin_map->_register[port_][pin_] = BitPlace(
   11b60:	0142      	lsls	r2, r0, #5
   11b62:	440a      	add	r2, r1
   11b64:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11b68:	f89d 200b 	ldrb.w	r2, [sp, #11]
   11b6c:	4b0e      	ldr	r3, [pc, #56]	; (11ba8 <Pin::EnableDac(bool)+0x70>)
   11b6e:	681c      	ldr	r4, [r3, #0]
   11b70:	9b03      	ldr	r3, [sp, #12]
   11b72:	791b      	ldrb	r3, [r3, #4]
   11b74:	461e      	mov	r6, r3
   11b76:	9b03      	ldr	r3, [sp, #12]
   11b78:	795b      	ldrb	r3, [r3, #5]
   11b7a:	461d      	mov	r5, r3
   11b7c:	2301      	movs	r3, #1
   11b7e:	9300      	str	r3, [sp, #0]
   11b80:	4613      	mov	r3, r2
   11b82:	2210      	movs	r2, #16
   11b84:	9803      	ldr	r0, [sp, #12]
   11b86:	f000 f811 	bl	11bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>
   11b8a:	4602      	mov	r2, r0
   11b8c:	0173      	lsls	r3, r6, #5
   11b8e:	442b      	add	r3, r5
   11b90:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
   11b94:	463b      	mov	r3, r7
   11b96:	4619      	mov	r1, r3
   11b98:	4802      	ldr	r0, [pc, #8]	; (11ba4 <Pin::EnableDac(bool)+0x6c>)
   11b9a:	f001 fbd7 	bl	1334c <__cyg_profile_func_exit>
  }
   11b9e:	bf00      	nop
   11ba0:	b005      	add	sp, #20
   11ba2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11ba4:	00011b39 	.word	0x00011b39
   11ba8:	10000074 	.word	0x10000074

00011bac <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)>:
  inline uint32_t BitPlace(uint32_t target, uint32_t position, uint32_t value,
   11bac:	b530      	push	{r4, r5, lr}
   11bae:	b087      	sub	sp, #28
   11bb0:	4675      	mov	r5, lr
   11bb2:	9003      	str	r0, [sp, #12]
   11bb4:	9102      	str	r1, [sp, #8]
   11bb6:	9201      	str	r2, [sp, #4]
   11bb8:	9300      	str	r3, [sp, #0]
   11bba:	462b      	mov	r3, r5
   11bbc:	4619      	mov	r1, r3
   11bbe:	4813      	ldr	r0, [pc, #76]	; (11c0c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   11bc0:	f001 fbb0 	bl	13324 <__cyg_profile_func_enter>
                           uint32_t value_width)
  {
    // Generate mask with all 1s
    uint32_t mask = 0xFFFFFFFF >> (32 - value_width);
   11bc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   11bc6:	f1c3 0320 	rsb	r3, r3, #32
   11bca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11bce:	fa22 f303 	lsr.w	r3, r2, r3
   11bd2:	9305      	str	r3, [sp, #20]
    target &= ~(mask << position);
   11bd4:	9a05      	ldr	r2, [sp, #20]
   11bd6:	9b01      	ldr	r3, [sp, #4]
   11bd8:	fa02 f303 	lsl.w	r3, r2, r3
   11bdc:	43db      	mvns	r3, r3
   11bde:	9a02      	ldr	r2, [sp, #8]
   11be0:	4013      	ands	r3, r2
   11be2:	9302      	str	r3, [sp, #8]
    target |= (value & mask) << position;
   11be4:	9a00      	ldr	r2, [sp, #0]
   11be6:	9b05      	ldr	r3, [sp, #20]
   11be8:	401a      	ands	r2, r3
   11bea:	9b01      	ldr	r3, [sp, #4]
   11bec:	fa02 f303 	lsl.w	r3, r2, r3
   11bf0:	9a02      	ldr	r2, [sp, #8]
   11bf2:	4313      	orrs	r3, r2
   11bf4:	9302      	str	r3, [sp, #8]
    return target;
   11bf6:	9c02      	ldr	r4, [sp, #8]
   11bf8:	462b      	mov	r3, r5
   11bfa:	4619      	mov	r1, r3
   11bfc:	4803      	ldr	r0, [pc, #12]	; (11c0c <Pin::BitPlace(unsigned long, unsigned long, unsigned long, unsigned long)+0x60>)
   11bfe:	f001 fba5 	bl	1334c <__cyg_profile_func_exit>
   11c02:	4623      	mov	r3, r4
  }
   11c04:	4618      	mov	r0, r3
   11c06:	b007      	add	sp, #28
   11c08:	bd30      	pop	{r4, r5, pc}
   11c0a:	bf00      	nop
   11c0c:	00011bad 	.word	0x00011bad

00011c10 <Pin::GetPort() const>:
  uint8_t GetPort() const override
   11c10:	b530      	push	{r4, r5, lr}
   11c12:	b083      	sub	sp, #12
   11c14:	4675      	mov	r5, lr
   11c16:	9001      	str	r0, [sp, #4]
   11c18:	462b      	mov	r3, r5
   11c1a:	4619      	mov	r1, r3
   11c1c:	4806      	ldr	r0, [pc, #24]	; (11c38 <Pin::GetPort() const+0x28>)
   11c1e:	f001 fb81 	bl	13324 <__cyg_profile_func_enter>
  {
    return port_;
   11c22:	9b01      	ldr	r3, [sp, #4]
   11c24:	791c      	ldrb	r4, [r3, #4]
   11c26:	462b      	mov	r3, r5
   11c28:	4619      	mov	r1, r3
   11c2a:	4803      	ldr	r0, [pc, #12]	; (11c38 <Pin::GetPort() const+0x28>)
   11c2c:	f001 fb8e 	bl	1334c <__cyg_profile_func_exit>
   11c30:	4623      	mov	r3, r4
  }
   11c32:	4618      	mov	r0, r3
   11c34:	b003      	add	sp, #12
   11c36:	bd30      	pop	{r4, r5, pc}
   11c38:	00011c11 	.word	0x00011c11

00011c3c <Pin::GetPin() const>:
  uint8_t GetPin() const override
   11c3c:	b530      	push	{r4, r5, lr}
   11c3e:	b083      	sub	sp, #12
   11c40:	4675      	mov	r5, lr
   11c42:	9001      	str	r0, [sp, #4]
   11c44:	462b      	mov	r3, r5
   11c46:	4619      	mov	r1, r3
   11c48:	4806      	ldr	r0, [pc, #24]	; (11c64 <Pin::GetPin() const+0x28>)
   11c4a:	f001 fb6b 	bl	13324 <__cyg_profile_func_enter>
  {
    return pin_;
   11c4e:	9b01      	ldr	r3, [sp, #4]
   11c50:	795c      	ldrb	r4, [r3, #5]
   11c52:	462b      	mov	r3, r5
   11c54:	4619      	mov	r1, r3
   11c56:	4803      	ldr	r0, [pc, #12]	; (11c64 <Pin::GetPin() const+0x28>)
   11c58:	f001 fb78 	bl	1334c <__cyg_profile_func_exit>
   11c5c:	4623      	mov	r3, r4
  }
   11c5e:	4618      	mov	r0, r3
   11c60:	b003      	add	sp, #12
   11c62:	bd30      	pop	{r4, r5, pc}
   11c64:	00011c3d 	.word	0x00011c3d

00011c68 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>:
constexpr Type Value(Enum enum_type_value)
   11c68:	b530      	push	{r4, r5, lr}
   11c6a:	b083      	sub	sp, #12
   11c6c:	4675      	mov	r5, lr
   11c6e:	4603      	mov	r3, r0
   11c70:	f88d 3007 	strb.w	r3, [sp, #7]
   11c74:	462b      	mov	r3, r5
   11c76:	4619      	mov	r1, r3
   11c78:	4806      	ldr	r0, [pc, #24]	; (11c94 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   11c7a:	f001 fb53 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11c7e:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11c82:	462b      	mov	r3, r5
   11c84:	4619      	mov	r1, r3
   11c86:	4803      	ldr	r0, [pc, #12]	; (11c94 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)+0x2c>)
   11c88:	f001 fb60 	bl	1334c <__cyg_profile_func_exit>
   11c8c:	4623      	mov	r3, r4
}
   11c8e:	4618      	mov	r0, r3
   11c90:	b003      	add	sp, #12
   11c92:	bd30      	pop	{r4, r5, pc}
   11c94:	00011c69 	.word	0x00011c69

00011c98 <Timer::DoNothingIsr()>:
    Lpc40xxSystemController::Peripherals::kTimer3
  };

  static constexpr IRQn kTimerIrq[] = { IRQn::TIMER0_IRQn, IRQn::TIMER1_IRQn,
                                        IRQn::TIMER2_IRQn, IRQn::TIMER3_IRQn };
  static void DoNothingIsr() {}
   11c98:	b510      	push	{r4, lr}
   11c9a:	4674      	mov	r4, lr
   11c9c:	4623      	mov	r3, r4
   11c9e:	4619      	mov	r1, r3
   11ca0:	4804      	ldr	r0, [pc, #16]	; (11cb4 <Timer::DoNothingIsr()+0x1c>)
   11ca2:	f001 fb3f 	bl	13324 <__cyg_profile_func_enter>
   11ca6:	4623      	mov	r3, r4
   11ca8:	4619      	mov	r1, r3
   11caa:	4802      	ldr	r0, [pc, #8]	; (11cb4 <Timer::DoNothingIsr()+0x1c>)
   11cac:	f001 fb4e 	bl	1334c <__cyg_profile_func_exit>
   11cb0:	bf00      	nop
   11cb2:	bd10      	pop	{r4, pc}
   11cb4:	00011c99 	.word	0x00011c99

00011cb8 <Timer::Initialize(unsigned long, void (*)(), long)>:
  ///                  register will be 10 ms.
  /// @param isr an ISR that will fire when the condition set by SetTimer
  ///            method is achieved.
  /// @param priority sets the Timer interrupt's priority level, defaults to -1
  ///                 which uses the platforms default priority.
  void Initialize(uint32_t frequency, IsrPointer isr = DoNothingIsr,
   11cb8:	b510      	push	{r4, lr}
   11cba:	b086      	sub	sp, #24
   11cbc:	4674      	mov	r4, lr
   11cbe:	9003      	str	r0, [sp, #12]
   11cc0:	9102      	str	r1, [sp, #8]
   11cc2:	9201      	str	r2, [sp, #4]
   11cc4:	9300      	str	r3, [sp, #0]
   11cc6:	4623      	mov	r3, r4
   11cc8:	4619      	mov	r1, r3
   11cca:	483e      	ldr	r0, [pc, #248]	; (11dc4 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   11ccc:	f001 fb2a 	bl	13324 <__cyg_profile_func_enter>
                  int32_t priority = -1) override final
  {
    PowerUpPeripheral(kPowerbit[channel_]);
   11cd0:	9b03      	ldr	r3, [sp, #12]
   11cd2:	1d18      	adds	r0, r3, #4
   11cd4:	9b03      	ldr	r3, [sp, #12]
   11cd6:	685b      	ldr	r3, [r3, #4]
   11cd8:	3314      	adds	r3, #20
   11cda:	681b      	ldr	r3, [r3, #0]
   11cdc:	9a03      	ldr	r2, [sp, #12]
   11cde:	7a12      	ldrb	r2, [r2, #8]
   11ce0:	0092      	lsls	r2, r2, #2
   11ce2:	4939      	ldr	r1, [pc, #228]	; (11dc8 <Timer::Initialize(unsigned long, void (*)(), long)+0x110>)
   11ce4:	440a      	add	r2, r1
   11ce6:	4611      	mov	r1, r2
   11ce8:	4798      	blx	r3
    SJ2_ASSERT_FATAL(
   11cea:	9b02      	ldr	r3, [sp, #8]
   11cec:	2b00      	cmp	r3, #0
   11cee:	d10d      	bne.n	11d0c <Timer::Initialize(unsigned long, void (*)(), long)+0x54>
   11cf0:	2384      	movs	r3, #132	; 0x84
   11cf2:	4a36      	ldr	r2, [pc, #216]	; (11dcc <Timer::Initialize(unsigned long, void (*)(), long)+0x114>)
   11cf4:	4936      	ldr	r1, [pc, #216]	; (11dd0 <Timer::Initialize(unsigned long, void (*)(), long)+0x118>)
   11cf6:	4837      	ldr	r0, [pc, #220]	; (11dd4 <Timer::Initialize(unsigned long, void (*)(), long)+0x11c>)
   11cf8:	f004 f8b0 	bl	15e5c <printf>
   11cfc:	4836      	ldr	r0, [pc, #216]	; (11dd8 <Timer::Initialize(unsigned long, void (*)(), long)+0x120>)
   11cfe:	f001 fae1 	bl	132c4 <puts>
   11d02:	2100      	movs	r1, #0
   11d04:	2001      	movs	r0, #1
   11d06:	f7ff f875 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   11d0a:	e7fe      	b.n	11d0a <Timer::Initialize(unsigned long, void (*)(), long)+0x52>
        frequency != 0,
        "Cannot have zero ticks per microsecond, please choose 1 or more.");
    // Set Prescale register for Prescale Counter to milliseconds
    uint32_t prescaler = GetPeripheralFrequency() / frequency;
   11d0c:	9b03      	ldr	r3, [sp, #12]
   11d0e:	1d1a      	adds	r2, r3, #4
   11d10:	9b03      	ldr	r3, [sp, #12]
   11d12:	685b      	ldr	r3, [r3, #4]
   11d14:	3310      	adds	r3, #16
   11d16:	681b      	ldr	r3, [r3, #0]
   11d18:	4610      	mov	r0, r2
   11d1a:	4798      	blx	r3
   11d1c:	4602      	mov	r2, r0
   11d1e:	9b02      	ldr	r3, [sp, #8]
   11d20:	fbb2 f3f3 	udiv	r3, r2, r3
   11d24:	9305      	str	r3, [sp, #20]
    tim_register[channel_]->PR &= ~(kClear << 1);
   11d26:	9b03      	ldr	r3, [sp, #12]
   11d28:	7a1b      	ldrb	r3, [r3, #8]
   11d2a:	461a      	mov	r2, r3
   11d2c:	4b2b      	ldr	r3, [pc, #172]	; (11ddc <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11d2e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11d32:	68da      	ldr	r2, [r3, #12]
   11d34:	9b03      	ldr	r3, [sp, #12]
   11d36:	7a1b      	ldrb	r3, [r3, #8]
   11d38:	4619      	mov	r1, r3
   11d3a:	4b28      	ldr	r3, [pc, #160]	; (11ddc <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11d3c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   11d40:	f002 0201 	and.w	r2, r2, #1
   11d44:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->PR |= (prescaler << 1);
   11d46:	9b03      	ldr	r3, [sp, #12]
   11d48:	7a1b      	ldrb	r3, [r3, #8]
   11d4a:	461a      	mov	r2, r3
   11d4c:	4b23      	ldr	r3, [pc, #140]	; (11ddc <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11d4e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11d52:	68d9      	ldr	r1, [r3, #12]
   11d54:	9b05      	ldr	r3, [sp, #20]
   11d56:	005a      	lsls	r2, r3, #1
   11d58:	9b03      	ldr	r3, [sp, #12]
   11d5a:	7a1b      	ldrb	r3, [r3, #8]
   11d5c:	4618      	mov	r0, r3
   11d5e:	4b1f      	ldr	r3, [pc, #124]	; (11ddc <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11d60:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   11d64:	430a      	orrs	r2, r1
   11d66:	60da      	str	r2, [r3, #12]
    tim_register[channel_]->TCR |= (1 << 0);
   11d68:	9b03      	ldr	r3, [sp, #12]
   11d6a:	7a1b      	ldrb	r3, [r3, #8]
   11d6c:	461a      	mov	r2, r3
   11d6e:	4b1b      	ldr	r3, [pc, #108]	; (11ddc <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11d70:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11d74:	685a      	ldr	r2, [r3, #4]
   11d76:	9b03      	ldr	r3, [sp, #12]
   11d78:	7a1b      	ldrb	r3, [r3, #8]
   11d7a:	4619      	mov	r1, r3
   11d7c:	4b17      	ldr	r3, [pc, #92]	; (11ddc <Timer::Initialize(unsigned long, void (*)(), long)+0x124>)
   11d7e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   11d82:	f042 0201 	orr.w	r2, r2, #1
   11d86:	605a      	str	r2, [r3, #4]
    user_timer_isr[channel_] = isr;
   11d88:	9b03      	ldr	r3, [sp, #12]
   11d8a:	7a1b      	ldrb	r3, [r3, #8]
   11d8c:	4619      	mov	r1, r3
   11d8e:	4a14      	ldr	r2, [pc, #80]	; (11de0 <Timer::Initialize(unsigned long, void (*)(), long)+0x128>)
   11d90:	9b01      	ldr	r3, [sp, #4]
   11d92:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    RegisterIsr(kTimerIrq[channel_], kTimerIsr[channel_], true, priority);
   11d96:	9b03      	ldr	r3, [sp, #12]
   11d98:	7a1b      	ldrb	r3, [r3, #8]
   11d9a:	461a      	mov	r2, r3
   11d9c:	4b11      	ldr	r3, [pc, #68]	; (11de4 <Timer::Initialize(unsigned long, void (*)(), long)+0x12c>)
   11d9e:	5698      	ldrsb	r0, [r3, r2]
   11da0:	9b03      	ldr	r3, [sp, #12]
   11da2:	7a1b      	ldrb	r3, [r3, #8]
   11da4:	461a      	mov	r2, r3
   11da6:	4b10      	ldr	r3, [pc, #64]	; (11de8 <Timer::Initialize(unsigned long, void (*)(), long)+0x130>)
   11da8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11dac:	9b00      	ldr	r3, [sp, #0]
   11dae:	2201      	movs	r2, #1
   11db0:	f001 f964 	bl	1307c <RegisterIsr(IRQn, void (*)(), bool, long)>
   11db4:	4623      	mov	r3, r4
   11db6:	4619      	mov	r1, r3
   11db8:	4802      	ldr	r0, [pc, #8]	; (11dc4 <Timer::Initialize(unsigned long, void (*)(), long)+0x10c>)
   11dba:	f001 fac7 	bl	1334c <__cyg_profile_func_exit>
  }
   11dbe:	bf00      	nop
   11dc0:	b006      	add	sp, #24
   11dc2:	bd10      	pop	{r4, pc}
   11dc4:	00011cb9 	.word	0x00011cb9
   11dc8:	000195cc 	.word	0x000195cc
   11dcc:	0001986c 	.word	0x0001986c
   11dd0:	000195f0 	.word	0x000195f0
   11dd4:	00019434 	.word	0x00019434
   11dd8:	00019140 	.word	0x00019140
   11ddc:	10000078 	.word	0x10000078
   11de0:	10000408 	.word	0x10000408
   11de4:	000195dc 	.word	0x000195dc
   11de8:	000195e0 	.word	0x000195e0

00011dec <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>:
constexpr Type Value(Enum enum_type_value)
   11dec:	b530      	push	{r4, r5, lr}
   11dee:	b083      	sub	sp, #12
   11df0:	4675      	mov	r5, lr
   11df2:	4603      	mov	r3, r0
   11df4:	f88d 3007 	strb.w	r3, [sp, #7]
   11df8:	462b      	mov	r3, r5
   11dfa:	4619      	mov	r1, r3
   11dfc:	4806      	ldr	r0, [pc, #24]	; (11e18 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   11dfe:	f001 fa91 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   11e02:	f89d 4007 	ldrb.w	r4, [sp, #7]
   11e06:	462b      	mov	r3, r5
   11e08:	4619      	mov	r1, r3
   11e0a:	4803      	ldr	r0, [pc, #12]	; (11e18 <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)+0x2c>)
   11e0c:	f001 fa9e 	bl	1334c <__cyg_profile_func_exit>
   11e10:	4623      	mov	r3, r4
}
   11e12:	4618      	mov	r0, r3
   11e14:	b003      	add	sp, #12
   11e16:	bd30      	pop	{r4, r5, pc}
   11e18:	00011ded 	.word	0x00011ded

00011e1c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)>:
  ///
  /// @param ticks the count of the timer register (TC) to have an ISR fire
  /// @param condition the condition for which a timer interrupt will occur
  /// @param match_register which match register (from 0 to 3) should be used
  ///                       for holding the ticks for the condition.
  void SetTimer(uint32_t ticks, TimerIsrCondition condition,
   11e1c:	b570      	push	{r4, r5, r6, lr}
   11e1e:	b086      	sub	sp, #24
   11e20:	4676      	mov	r6, lr
   11e22:	9003      	str	r0, [sp, #12]
   11e24:	9102      	str	r1, [sp, #8]
   11e26:	4611      	mov	r1, r2
   11e28:	461a      	mov	r2, r3
   11e2a:	460b      	mov	r3, r1
   11e2c:	f88d 3007 	strb.w	r3, [sp, #7]
   11e30:	4613      	mov	r3, r2
   11e32:	f88d 3006 	strb.w	r3, [sp, #6]
   11e36:	4633      	mov	r3, r6
   11e38:	4619      	mov	r1, r3
   11e3a:	4832      	ldr	r0, [pc, #200]	; (11f04 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   11e3c:	f001 fa72 	bl	13324 <__cyg_profile_func_enter>
                MatchControlRegister match_register = kMat0) override final
  {
    static constexpr uint8_t kClearMode = 0b0111;

    uint8_t match_value = util::Value(match_register);
   11e40:	f89d 3006 	ldrb.w	r3, [sp, #6]
   11e44:	4618      	mov	r0, r3
   11e46:	f7ff ffd1 	bl	11dec <unsigned char util::Value<TimerInterface::MatchControlRegister, unsigned char>(TimerInterface::MatchControlRegister)>
   11e4a:	4603      	mov	r3, r0
   11e4c:	f88d 3017 	strb.w	r3, [sp, #23]
    tim_register[channel_]->MCR &= ~(kClearMode << match_value);
   11e50:	9b03      	ldr	r3, [sp, #12]
   11e52:	7a1b      	ldrb	r3, [r3, #8]
   11e54:	461a      	mov	r2, r3
   11e56:	4b2c      	ldr	r3, [pc, #176]	; (11f08 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   11e58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11e5c:	695a      	ldr	r2, [r3, #20]
   11e5e:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11e62:	2107      	movs	r1, #7
   11e64:	fa01 f303 	lsl.w	r3, r1, r3
   11e68:	43db      	mvns	r3, r3
   11e6a:	4619      	mov	r1, r3
   11e6c:	9b03      	ldr	r3, [sp, #12]
   11e6e:	7a1b      	ldrb	r3, [r3, #8]
   11e70:	4618      	mov	r0, r3
   11e72:	4b25      	ldr	r3, [pc, #148]	; (11f08 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   11e74:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   11e78:	400a      	ands	r2, r1
   11e7a:	615a      	str	r2, [r3, #20]
    tim_register[channel_]->MCR |= condition << match_value;
   11e7c:	9b03      	ldr	r3, [sp, #12]
   11e7e:	7a1b      	ldrb	r3, [r3, #8]
   11e80:	461a      	mov	r2, r3
   11e82:	4b21      	ldr	r3, [pc, #132]	; (11f08 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   11e84:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11e88:	695a      	ldr	r2, [r3, #20]
   11e8a:	f89d 1007 	ldrb.w	r1, [sp, #7]
   11e8e:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11e92:	fa01 f303 	lsl.w	r3, r1, r3
   11e96:	4619      	mov	r1, r3
   11e98:	9b03      	ldr	r3, [sp, #12]
   11e9a:	7a1b      	ldrb	r3, [r3, #8]
   11e9c:	4618      	mov	r0, r3
   11e9e:	4b1a      	ldr	r3, [pc, #104]	; (11f08 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xec>)
   11ea0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   11ea4:	430a      	orrs	r2, r1
   11ea6:	615a      	str	r2, [r3, #20]
    *match[channel_][match_value / 3] |= (((ticks / 2)) << 0);
   11ea8:	9b03      	ldr	r3, [sp, #12]
   11eaa:	7a1b      	ldrb	r3, [r3, #8]
   11eac:	4618      	mov	r0, r3
   11eae:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11eb2:	4a16      	ldr	r2, [pc, #88]	; (11f0c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   11eb4:	fba2 2303 	umull	r2, r3, r2, r3
   11eb8:	085b      	lsrs	r3, r3, #1
   11eba:	b2db      	uxtb	r3, r3
   11ebc:	4619      	mov	r1, r3
   11ebe:	4a14      	ldr	r2, [pc, #80]	; (11f10 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   11ec0:	0083      	lsls	r3, r0, #2
   11ec2:	440b      	add	r3, r1
   11ec4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ec8:	6819      	ldr	r1, [r3, #0]
   11eca:	9b02      	ldr	r3, [sp, #8]
   11ecc:	085a      	lsrs	r2, r3, #1
   11ece:	9b03      	ldr	r3, [sp, #12]
   11ed0:	7a1b      	ldrb	r3, [r3, #8]
   11ed2:	461d      	mov	r5, r3
   11ed4:	f89d 3017 	ldrb.w	r3, [sp, #23]
   11ed8:	480c      	ldr	r0, [pc, #48]	; (11f0c <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf0>)
   11eda:	fba0 0303 	umull	r0, r3, r0, r3
   11ede:	085b      	lsrs	r3, r3, #1
   11ee0:	b2db      	uxtb	r3, r3
   11ee2:	461c      	mov	r4, r3
   11ee4:	480a      	ldr	r0, [pc, #40]	; (11f10 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xf4>)
   11ee6:	00ab      	lsls	r3, r5, #2
   11ee8:	4423      	add	r3, r4
   11eea:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   11eee:	430a      	orrs	r2, r1
   11ef0:	601a      	str	r2, [r3, #0]
   11ef2:	4633      	mov	r3, r6
   11ef4:	4619      	mov	r1, r3
   11ef6:	4803      	ldr	r0, [pc, #12]	; (11f04 <Timer::SetTimer(unsigned long, TimerInterface::TimerIsrCondition, TimerInterface::MatchControlRegister)+0xe8>)
   11ef8:	f001 fa28 	bl	1334c <__cyg_profile_func_exit>
  }
   11efc:	bf00      	nop
   11efe:	b006      	add	sp, #24
   11f00:	bd70      	pop	{r4, r5, r6, pc}
   11f02:	bf00      	nop
   11f04:	00011e1d 	.word	0x00011e1d
   11f08:	10000078 	.word	0x10000078
   11f0c:	aaaaaaab 	.word	0xaaaaaaab
   11f10:	100003c8 	.word	0x100003c8

00011f14 <Timer::GetTimer()>:

  [[gnu::always_inline]] uint32_t GetTimer() override final {
   11f14:	b530      	push	{r4, r5, lr}
   11f16:	b083      	sub	sp, #12
   11f18:	4675      	mov	r5, lr
   11f1a:	9001      	str	r0, [sp, #4]
   11f1c:	462b      	mov	r3, r5
   11f1e:	4619      	mov	r1, r3
   11f20:	4809      	ldr	r0, [pc, #36]	; (11f48 <Timer::GetTimer()+0x34>)
   11f22:	f001 f9ff 	bl	13324 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   11f26:	9b01      	ldr	r3, [sp, #4]
   11f28:	7a1b      	ldrb	r3, [r3, #8]
   11f2a:	461a      	mov	r2, r3
   11f2c:	4b07      	ldr	r3, [pc, #28]	; (11f4c <Timer::GetTimer()+0x38>)
   11f2e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11f32:	689c      	ldr	r4, [r3, #8]
   11f34:	462b      	mov	r3, r5
   11f36:	4619      	mov	r1, r3
   11f38:	4803      	ldr	r0, [pc, #12]	; (11f48 <Timer::GetTimer()+0x34>)
   11f3a:	f001 fa07 	bl	1334c <__cyg_profile_func_exit>
   11f3e:	4623      	mov	r3, r4
  }
   11f40:	4618      	mov	r0, r3
   11f42:	b003      	add	sp, #12
   11f44:	bd30      	pop	{r4, r5, pc}
   11f46:	bf00      	nop
   11f48:	00011f15 	.word	0x00011f15
   11f4c:	10000078 	.word	0x10000078

00011f50 <Uart::SetBaudRate(unsigned long)>:
  constexpr Uart(Channels mode, PinInterface * tx_pin, PinInterface * rx_pin)
      : channel_(static_cast<uint8_t>(mode)), tx_(tx_pin), rx_(rx_pin)
  {
  }

  void SetBaudRate(uint32_t baud_rate) override
   11f50:	b510      	push	{r4, lr}
   11f52:	b088      	sub	sp, #32
   11f54:	4674      	mov	r4, lr
   11f56:	9001      	str	r0, [sp, #4]
   11f58:	9100      	str	r1, [sp, #0]
   11f5a:	4623      	mov	r3, r4
   11f5c:	4619      	mov	r1, r3
   11f5e:	482d      	ldr	r0, [pc, #180]	; (12014 <Uart::SetBaudRate(unsigned long)+0xc4>)
   11f60:	f001 f9e0 	bl	13324 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kDlabBit = (1 << 7);
   11f64:	2380      	movs	r3, #128	; 0x80
   11f66:	f88d 301f 	strb.w	r3, [sp, #31]
    float baudrate             = static_cast<float>(baud_rate);
   11f6a:	9b00      	ldr	r3, [sp, #0]
   11f6c:	ee07 3a90 	vmov	s15, r3
   11f70:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11f74:	edcd 7a06 	vstr	s15, [sp, #24]
    UartCalibration_t dividers = GenerateUartCalibration(baudrate);
   11f78:	ab02      	add	r3, sp, #8
   11f7a:	ed9d 0a06 	vldr	s0, [sp, #24]
   11f7e:	9901      	ldr	r1, [sp, #4]
   11f80:	4618      	mov	r0, r3
   11f82:	f000 fb2d 	bl	125e0 <Uart::GenerateUartCalibration(float)>

    uint8_t dlm = static_cast<uint8_t>((dividers.divide_latch >> 8) & 0xFF);
   11f86:	9b02      	ldr	r3, [sp, #8]
   11f88:	0a1b      	lsrs	r3, r3, #8
   11f8a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8_t dll = static_cast<uint8_t>(dividers.divide_latch & 0xFF);
   11f8e:	9b02      	ldr	r3, [sp, #8]
   11f90:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   11f94:	9b04      	ldr	r3, [sp, #16]
   11f96:	b2db      	uxtb	r3, r3
   11f98:	011b      	lsls	r3, r3, #4
   11f9a:	b2da      	uxtb	r2, r3
                                       (dividers.divide_add & 0xF));
   11f9c:	9b03      	ldr	r3, [sp, #12]
   11f9e:	b2db      	uxtb	r3, r3
   11fa0:	f003 030f 	and.w	r3, r3, #15
   11fa4:	b2db      	uxtb	r3, r3
    uint8_t fdr = static_cast<uint8_t>((dividers.multiply & 0xF) << 4 |
   11fa6:	4313      	orrs	r3, r2
   11fa8:	f88d 3015 	strb.w	r3, [sp, #21]

    // Set baud rate
    uart[channel_]->LCR = kDlabBit;
   11fac:	9b01      	ldr	r3, [sp, #4]
   11fae:	7a1b      	ldrb	r3, [r3, #8]
   11fb0:	461a      	mov	r2, r3
   11fb2:	4b19      	ldr	r3, [pc, #100]	; (12018 <Uart::SetBaudRate(unsigned long)+0xc8>)
   11fb4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11fb8:	2280      	movs	r2, #128	; 0x80
   11fba:	731a      	strb	r2, [r3, #12]
    uart[channel_]->DLM = dlm;
   11fbc:	9b01      	ldr	r3, [sp, #4]
   11fbe:	7a1b      	ldrb	r3, [r3, #8]
   11fc0:	461a      	mov	r2, r3
   11fc2:	4b15      	ldr	r3, [pc, #84]	; (12018 <Uart::SetBaudRate(unsigned long)+0xc8>)
   11fc4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11fc8:	f89d 2017 	ldrb.w	r2, [sp, #23]
   11fcc:	711a      	strb	r2, [r3, #4]
    uart[channel_]->DLL = dll;
   11fce:	9b01      	ldr	r3, [sp, #4]
   11fd0:	7a1b      	ldrb	r3, [r3, #8]
   11fd2:	461a      	mov	r2, r3
   11fd4:	4b10      	ldr	r3, [pc, #64]	; (12018 <Uart::SetBaudRate(unsigned long)+0xc8>)
   11fd6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11fda:	f89d 2016 	ldrb.w	r2, [sp, #22]
   11fde:	701a      	strb	r2, [r3, #0]
    uart[channel_]->FDR = fdr;
   11fe0:	9b01      	ldr	r3, [sp, #4]
   11fe2:	7a1b      	ldrb	r3, [r3, #8]
   11fe4:	461a      	mov	r2, r3
   11fe6:	4b0c      	ldr	r3, [pc, #48]	; (12018 <Uart::SetBaudRate(unsigned long)+0xc8>)
   11fe8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   11fec:	f89d 2015 	ldrb.w	r2, [sp, #21]
   11ff0:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    uart[channel_]->LCR = kStandardUart;
   11ff4:	9b01      	ldr	r3, [sp, #4]
   11ff6:	7a1b      	ldrb	r3, [r3, #8]
   11ff8:	461a      	mov	r2, r3
   11ffa:	4b07      	ldr	r3, [pc, #28]	; (12018 <Uart::SetBaudRate(unsigned long)+0xc8>)
   11ffc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12000:	2203      	movs	r2, #3
   12002:	731a      	strb	r2, [r3, #12]
   12004:	4623      	mov	r3, r4
   12006:	4619      	mov	r1, r3
   12008:	4802      	ldr	r0, [pc, #8]	; (12014 <Uart::SetBaudRate(unsigned long)+0xc4>)
   1200a:	f001 f99f 	bl	1334c <__cyg_profile_func_exit>
  }
   1200e:	bf00      	nop
   12010:	b008      	add	sp, #32
   12012:	bd10      	pop	{r4, pc}
   12014:	00011f51 	.word	0x00011f51
   12018:	10000088 	.word	0x10000088

0001201c <Uart::Initialize(unsigned long)>:

  bool Initialize(uint32_t baud_rate) override
   1201c:	b530      	push	{r4, r5, lr}
   1201e:	b085      	sub	sp, #20
   12020:	4675      	mov	r5, lr
   12022:	9001      	str	r0, [sp, #4]
   12024:	9100      	str	r1, [sp, #0]
   12026:	462b      	mov	r3, r5
   12028:	4619      	mov	r1, r3
   1202a:	4830      	ldr	r0, [pc, #192]	; (120ec <Uart::Initialize(unsigned long)+0xd0>)
   1202c:	f001 f97a 	bl	13324 <__cyg_profile_func_enter>
  {
    constexpr uint8_t kFIFOEnableAndReset = 0b111;
   12030:	2307      	movs	r3, #7
   12032:	f88d 300f 	strb.w	r3, [sp, #15]
    // Powering the port
    PowerUpPeripheral(kPowerbit[channel_]);
   12036:	9b01      	ldr	r3, [sp, #4]
   12038:	1d18      	adds	r0, r3, #4
   1203a:	9b01      	ldr	r3, [sp, #4]
   1203c:	685b      	ldr	r3, [r3, #4]
   1203e:	3314      	adds	r3, #20
   12040:	681b      	ldr	r3, [r3, #0]
   12042:	9a01      	ldr	r2, [sp, #4]
   12044:	7a12      	ldrb	r2, [r2, #8]
   12046:	0092      	lsls	r2, r2, #2
   12048:	4929      	ldr	r1, [pc, #164]	; (120f0 <Uart::Initialize(unsigned long)+0xd4>)
   1204a:	440a      	add	r2, r1
   1204c:	4611      	mov	r1, r2
   1204e:	4798      	blx	r3
    // Setting the pin functions and modes
    rx_->SetPinFunction(kRxUartPortFunction[channel_]);
   12050:	9b01      	ldr	r3, [sp, #4]
   12052:	6918      	ldr	r0, [r3, #16]
   12054:	9b01      	ldr	r3, [sp, #4]
   12056:	691b      	ldr	r3, [r3, #16]
   12058:	681b      	ldr	r3, [r3, #0]
   1205a:	681b      	ldr	r3, [r3, #0]
   1205c:	9a01      	ldr	r2, [sp, #4]
   1205e:	7a12      	ldrb	r2, [r2, #8]
   12060:	4611      	mov	r1, r2
   12062:	4a24      	ldr	r2, [pc, #144]	; (120f4 <Uart::Initialize(unsigned long)+0xd8>)
   12064:	5c52      	ldrb	r2, [r2, r1]
   12066:	4611      	mov	r1, r2
   12068:	4798      	blx	r3
    tx_->SetPinFunction(kTxUartPortFunction[channel_]);
   1206a:	9b01      	ldr	r3, [sp, #4]
   1206c:	68d8      	ldr	r0, [r3, #12]
   1206e:	9b01      	ldr	r3, [sp, #4]
   12070:	68db      	ldr	r3, [r3, #12]
   12072:	681b      	ldr	r3, [r3, #0]
   12074:	681b      	ldr	r3, [r3, #0]
   12076:	9a01      	ldr	r2, [sp, #4]
   12078:	7a12      	ldrb	r2, [r2, #8]
   1207a:	4611      	mov	r1, r2
   1207c:	4a1e      	ldr	r2, [pc, #120]	; (120f8 <Uart::Initialize(unsigned long)+0xdc>)
   1207e:	5c52      	ldrb	r2, [r2, r1]
   12080:	4611      	mov	r1, r2
   12082:	4798      	blx	r3
    rx_->SetMode(PinInterface::Mode::kPullUp);
   12084:	9b01      	ldr	r3, [sp, #4]
   12086:	691a      	ldr	r2, [r3, #16]
   12088:	9b01      	ldr	r3, [sp, #4]
   1208a:	691b      	ldr	r3, [r3, #16]
   1208c:	681b      	ldr	r3, [r3, #0]
   1208e:	3304      	adds	r3, #4
   12090:	681b      	ldr	r3, [r3, #0]
   12092:	2102      	movs	r1, #2
   12094:	4610      	mov	r0, r2
   12096:	4798      	blx	r3
    tx_->SetMode(PinInterface::Mode::kPullUp);
   12098:	9b01      	ldr	r3, [sp, #4]
   1209a:	68da      	ldr	r2, [r3, #12]
   1209c:	9b01      	ldr	r3, [sp, #4]
   1209e:	68db      	ldr	r3, [r3, #12]
   120a0:	681b      	ldr	r3, [r3, #0]
   120a2:	3304      	adds	r3, #4
   120a4:	681b      	ldr	r3, [r3, #0]
   120a6:	2102      	movs	r1, #2
   120a8:	4610      	mov	r0, r2
   120aa:	4798      	blx	r3
    // Baud rate setting
    SetBaudRate(baud_rate);
   120ac:	9900      	ldr	r1, [sp, #0]
   120ae:	9801      	ldr	r0, [sp, #4]
   120b0:	f7ff ff4e 	bl	11f50 <Uart::SetBaudRate(unsigned long)>
    uart[channel_]->FCR |= kFIFOEnableAndReset;
   120b4:	9b01      	ldr	r3, [sp, #4]
   120b6:	7a1b      	ldrb	r3, [r3, #8]
   120b8:	461a      	mov	r2, r3
   120ba:	4b10      	ldr	r3, [pc, #64]	; (120fc <Uart::Initialize(unsigned long)+0xe0>)
   120bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   120c0:	7a1b      	ldrb	r3, [r3, #8]
   120c2:	b2da      	uxtb	r2, r3
   120c4:	9b01      	ldr	r3, [sp, #4]
   120c6:	7a1b      	ldrb	r3, [r3, #8]
   120c8:	4619      	mov	r1, r3
   120ca:	4b0c      	ldr	r3, [pc, #48]	; (120fc <Uart::Initialize(unsigned long)+0xe0>)
   120cc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   120d0:	f042 0207 	orr.w	r2, r2, #7
   120d4:	b2d2      	uxtb	r2, r2
   120d6:	721a      	strb	r2, [r3, #8]
    return true;
   120d8:	2401      	movs	r4, #1
   120da:	462b      	mov	r3, r5
   120dc:	4619      	mov	r1, r3
   120de:	4803      	ldr	r0, [pc, #12]	; (120ec <Uart::Initialize(unsigned long)+0xd0>)
   120e0:	f001 f934 	bl	1334c <__cyg_profile_func_exit>
   120e4:	4623      	mov	r3, r4
  }
   120e6:	4618      	mov	r0, r3
   120e8:	b005      	add	sp, #20
   120ea:	bd30      	pop	{r4, r5, pc}
   120ec:	0001201d 	.word	0x0001201d
   120f0:	00019604 	.word	0x00019604
   120f4:	00019600 	.word	0x00019600
   120f8:	000195fc 	.word	0x000195fc
   120fc:	10000088 	.word	0x10000088

00012100 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>:

  void Send(uint8_t data) override
  {
    uart[channel_]->THR              = data;
    auto wait_for_transfer_to_finish = [this]() -> bool {
   12100:	b530      	push	{r4, r5, lr}
   12102:	b083      	sub	sp, #12
   12104:	4675      	mov	r5, lr
   12106:	9001      	str	r0, [sp, #4]
   12108:	462b      	mov	r3, r5
   1210a:	4619      	mov	r1, r3
   1210c:	480d      	ldr	r0, [pc, #52]	; (12144 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   1210e:	f001 f909 	bl	13324 <__cyg_profile_func_enter>
   12112:	9b01      	ldr	r3, [sp, #4]
   12114:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 5));
   12116:	7a1b      	ldrb	r3, [r3, #8]
   12118:	461a      	mov	r2, r3
   1211a:	4b0b      	ldr	r3, [pc, #44]	; (12148 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x48>)
   1211c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12120:	7d1b      	ldrb	r3, [r3, #20]
   12122:	b2db      	uxtb	r3, r3
   12124:	f003 0320 	and.w	r3, r3, #32
   12128:	2b00      	cmp	r3, #0
   1212a:	bf14      	ite	ne
   1212c:	2301      	movne	r3, #1
   1212e:	2300      	moveq	r3, #0
   12130:	b2dc      	uxtb	r4, r3
   12132:	462b      	mov	r3, r5
   12134:	4619      	mov	r1, r3
   12136:	4803      	ldr	r0, [pc, #12]	; (12144 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const+0x44>)
   12138:	f001 f908 	bl	1334c <__cyg_profile_func_exit>
   1213c:	4623      	mov	r3, r4
    };
   1213e:	4618      	mov	r0, r3
   12140:	b003      	add	sp, #12
   12142:	bd30      	pop	{r4, r5, pc}
   12144:	00012101 	.word	0x00012101
   12148:	10000088 	.word	0x10000088

0001214c <Uart::Send(unsigned char)>:
  void Send(uint8_t data) override
   1214c:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   12150:	b08a      	sub	sp, #40	; 0x28
   12152:	4675      	mov	r5, lr
   12154:	9001      	str	r0, [sp, #4]
   12156:	460b      	mov	r3, r1
   12158:	f88d 3003 	strb.w	r3, [sp, #3]
   1215c:	462b      	mov	r3, r5
   1215e:	4619      	mov	r1, r3
   12160:	4831      	ldr	r0, [pc, #196]	; (12228 <Uart::Send(unsigned char)+0xdc>)
   12162:	f001 f8df 	bl	13324 <__cyg_profile_func_enter>
    uart[channel_]->THR              = data;
   12166:	9b01      	ldr	r3, [sp, #4]
   12168:	7a1b      	ldrb	r3, [r3, #8]
   1216a:	461a      	mov	r2, r3
   1216c:	4b2f      	ldr	r3, [pc, #188]	; (1222c <Uart::Send(unsigned char)+0xe0>)
   1216e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12172:	f89d 2003 	ldrb.w	r2, [sp, #3]
   12176:	701a      	strb	r2, [r3, #0]
    };
   12178:	9b01      	ldr	r3, [sp, #4]
   1217a:	9304      	str	r3, [sp, #16]
   1217c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12180:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   12184:	e9cd 3408 	strd	r3, r4, [sp, #32]
   12188:	9b04      	ldr	r3, [sp, #16]
   1218a:	9303      	str	r3, [sp, #12]
   1218c:	462b      	mov	r3, r5
   1218e:	4619      	mov	r1, r3
   12190:	4827      	ldr	r0, [pc, #156]	; (12230 <Uart::Send(unsigned char)+0xe4>)
   12192:	f001 f8c7 	bl	13324 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   12196:	f04f 0300 	mov.w	r3, #0
   1219a:	f04f 0400 	mov.w	r4, #0
   1219e:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   121a2:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   121a6:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   121aa:	bf08      	it	eq
   121ac:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   121b0:	d106      	bne.n	121c0 <Uart::Send(unsigned char)+0x74>
    timeout_time = kMaxWait;
   121b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   121b6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   121ba:	e9cd 3406 	strd	r3, r4, [sp, #24]
   121be:	e00b      	b.n	121d8 <Uart::Send(unsigned char)+0x8c>
    timeout_time = Milliseconds() + timeout;
   121c0:	f7fe fada 	bl	10778 <Milliseconds()>
   121c4:	460a      	mov	r2, r1
   121c6:	4601      	mov	r1, r0
   121c8:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   121cc:	eb13 0b01 	adds.w	fp, r3, r1
   121d0:	eb44 0c02 	adc.w	ip, r4, r2
   121d4:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   121d8:	2301      	movs	r3, #1
   121da:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   121dc:	f7fe facc 	bl	10778 <Milliseconds()>
   121e0:	460a      	mov	r2, r1
   121e2:	4601      	mov	r1, r0
   121e4:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   121e8:	42a2      	cmp	r2, r4
   121ea:	bf08      	it	eq
   121ec:	4299      	cmpeq	r1, r3
   121ee:	bf34      	ite	cc
   121f0:	2301      	movcc	r3, #1
   121f2:	2300      	movcs	r3, #0
   121f4:	b2db      	uxtb	r3, r3
   121f6:	2b00      	cmp	r3, #0
   121f8:	d008      	beq.n	1220c <Uart::Send(unsigned char)+0xc0>
    if (is_done())
   121fa:	ab03      	add	r3, sp, #12
   121fc:	4618      	mov	r0, r3
   121fe:	f7ff ff7f 	bl	12100 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   12202:	4603      	mov	r3, r0
   12204:	2b00      	cmp	r3, #0
   12206:	d0e9      	beq.n	121dc <Uart::Send(unsigned char)+0x90>
      status = Status::kSuccess;
   12208:	2300      	movs	r3, #0
   1220a:	9305      	str	r3, [sp, #20]
   1220c:	462b      	mov	r3, r5
   1220e:	4619      	mov	r1, r3
   12210:	4807      	ldr	r0, [pc, #28]	; (12230 <Uart::Send(unsigned char)+0xe4>)
   12212:	f001 f89b 	bl	1334c <__cyg_profile_func_exit>
   12216:	462b      	mov	r3, r5
   12218:	4619      	mov	r1, r3
   1221a:	4803      	ldr	r0, [pc, #12]	; (12228 <Uart::Send(unsigned char)+0xdc>)
   1221c:	f001 f896 	bl	1334c <__cyg_profile_func_exit>
    Wait(kMaxWait, wait_for_transfer_to_finish);
  }
   12220:	bf00      	nop
   12222:	b00a      	add	sp, #40	; 0x28
   12224:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   12228:	0001214d 	.word	0x0001214d
   1222c:	10000088 	.word	0x10000088
   12230:	00012ad5 	.word	0x00012ad5

00012234 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>:

  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
  {
    uint8_t receiver   = '\xFF';
    auto byte_recieved = [this]() -> bool {
   12234:	b530      	push	{r4, r5, lr}
   12236:	b083      	sub	sp, #12
   12238:	4675      	mov	r5, lr
   1223a:	9001      	str	r0, [sp, #4]
   1223c:	462b      	mov	r3, r5
   1223e:	4619      	mov	r1, r3
   12240:	480d      	ldr	r0, [pc, #52]	; (12278 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   12242:	f001 f86f 	bl	13324 <__cyg_profile_func_enter>
   12246:	9b01      	ldr	r3, [sp, #4]
   12248:	681b      	ldr	r3, [r3, #0]
      return (uart[channel_]->LSR & (1 << 0));
   1224a:	7a1b      	ldrb	r3, [r3, #8]
   1224c:	461a      	mov	r2, r3
   1224e:	4b0b      	ldr	r3, [pc, #44]	; (1227c <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x48>)
   12250:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12254:	7d1b      	ldrb	r3, [r3, #20]
   12256:	b2db      	uxtb	r3, r3
   12258:	f003 0301 	and.w	r3, r3, #1
   1225c:	2b00      	cmp	r3, #0
   1225e:	bf14      	ite	ne
   12260:	2301      	movne	r3, #1
   12262:	2300      	moveq	r3, #0
   12264:	b2dc      	uxtb	r4, r3
   12266:	462b      	mov	r3, r5
   12268:	4619      	mov	r1, r3
   1226a:	4803      	ldr	r0, [pc, #12]	; (12278 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const+0x44>)
   1226c:	f001 f86e 	bl	1334c <__cyg_profile_func_exit>
   12270:	4623      	mov	r3, r4
    };
   12272:	4618      	mov	r0, r3
   12274:	b003      	add	sp, #12
   12276:	bd30      	pop	{r4, r5, pc}
   12278:	00012235 	.word	0x00012235
   1227c:	10000088 	.word	0x10000088

00012280 <Uart::Receive(unsigned long)>:
  uint8_t Receive([[maybe_unused]] uint32_t timeout = 0x7FFFFFFF) override
   12280:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   12284:	b08c      	sub	sp, #48	; 0x30
   12286:	4675      	mov	r5, lr
   12288:	9001      	str	r0, [sp, #4]
   1228a:	9100      	str	r1, [sp, #0]
   1228c:	462b      	mov	r3, r5
   1228e:	4619      	mov	r1, r3
   12290:	4836      	ldr	r0, [pc, #216]	; (1236c <Uart::Receive(unsigned long)+0xec>)
   12292:	f001 f847 	bl	13324 <__cyg_profile_func_enter>
    uint8_t receiver   = '\xFF';
   12296:	23ff      	movs	r3, #255	; 0xff
   12298:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    };
   1229c:	9b01      	ldr	r3, [sp, #4]
   1229e:	9304      	str	r3, [sp, #16]

    Status status = Wait(timeout, byte_recieved);
   122a0:	9b00      	ldr	r3, [sp, #0]
   122a2:	f04f 0400 	mov.w	r4, #0
   122a6:	e9cd 3408 	strd	r3, r4, [sp, #32]
   122aa:	9b04      	ldr	r3, [sp, #16]
   122ac:	9303      	str	r3, [sp, #12]
   122ae:	462b      	mov	r3, r5
   122b0:	4619      	mov	r1, r3
   122b2:	482f      	ldr	r0, [pc, #188]	; (12370 <Uart::Receive(unsigned long)+0xf0>)
   122b4:	f001 f836 	bl	13324 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   122b8:	f04f 0300 	mov.w	r3, #0
   122bc:	f04f 0400 	mov.w	r4, #0
   122c0:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   122c4:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   122c8:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   122cc:	bf08      	it	eq
   122ce:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   122d2:	d106      	bne.n	122e2 <Uart::Receive(unsigned long)+0x62>
    timeout_time = kMaxWait;
   122d4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   122d8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   122dc:	e9cd 3406 	strd	r3, r4, [sp, #24]
   122e0:	e00b      	b.n	122fa <Uart::Receive(unsigned long)+0x7a>
    timeout_time = Milliseconds() + timeout;
   122e2:	f7fe fa49 	bl	10778 <Milliseconds()>
   122e6:	460a      	mov	r2, r1
   122e8:	4601      	mov	r1, r0
   122ea:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   122ee:	eb13 0b01 	adds.w	fp, r3, r1
   122f2:	eb44 0c02 	adc.w	ip, r4, r2
   122f6:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   122fa:	2301      	movs	r3, #1
   122fc:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   122fe:	f7fe fa3b 	bl	10778 <Milliseconds()>
   12302:	460a      	mov	r2, r1
   12304:	4601      	mov	r1, r0
   12306:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   1230a:	42a2      	cmp	r2, r4
   1230c:	bf08      	it	eq
   1230e:	4299      	cmpeq	r1, r3
   12310:	bf34      	ite	cc
   12312:	2301      	movcc	r3, #1
   12314:	2300      	movcs	r3, #0
   12316:	b2db      	uxtb	r3, r3
   12318:	2b00      	cmp	r3, #0
   1231a:	d008      	beq.n	1232e <Uart::Receive(unsigned long)+0xae>
    if (is_done())
   1231c:	ab03      	add	r3, sp, #12
   1231e:	4618      	mov	r0, r3
   12320:	f7ff ff88 	bl	12234 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   12324:	4603      	mov	r3, r0
   12326:	2b00      	cmp	r3, #0
   12328:	d0e9      	beq.n	122fe <Uart::Receive(unsigned long)+0x7e>
      status = Status::kSuccess;
   1232a:	2300      	movs	r3, #0
   1232c:	9305      	str	r3, [sp, #20]
  return status;
   1232e:	9c05      	ldr	r4, [sp, #20]
   12330:	462b      	mov	r3, r5
   12332:	4619      	mov	r1, r3
   12334:	480e      	ldr	r0, [pc, #56]	; (12370 <Uart::Receive(unsigned long)+0xf0>)
   12336:	f001 f809 	bl	1334c <__cyg_profile_func_exit>
   1233a:	940a      	str	r4, [sp, #40]	; 0x28

    if (status == Status::kSuccess)
   1233c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1233e:	2b00      	cmp	r3, #0
   12340:	d108      	bne.n	12354 <Uart::Receive(unsigned long)+0xd4>
    {
      receiver = static_cast<uint8_t>(uart[channel_]->RBR);
   12342:	9b01      	ldr	r3, [sp, #4]
   12344:	7a1b      	ldrb	r3, [r3, #8]
   12346:	461a      	mov	r2, r3
   12348:	4b0a      	ldr	r3, [pc, #40]	; (12374 <Uart::Receive(unsigned long)+0xf4>)
   1234a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1234e:	781b      	ldrb	r3, [r3, #0]
   12350:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    }
    return receiver;
   12354:	f89d 402f 	ldrb.w	r4, [sp, #47]	; 0x2f
   12358:	462b      	mov	r3, r5
   1235a:	4619      	mov	r1, r3
   1235c:	4803      	ldr	r0, [pc, #12]	; (1236c <Uart::Receive(unsigned long)+0xec>)
   1235e:	f000 fff5 	bl	1334c <__cyg_profile_func_exit>
   12362:	4623      	mov	r3, r4
  }
   12364:	4618      	mov	r0, r3
   12366:	b00c      	add	sp, #48	; 0x30
   12368:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   1236c:	00012281 	.word	0x00012281
   12370:	00012b7d 	.word	0x00012b7d
   12374:	10000088 	.word	0x10000088

00012378 <Uart::FindClosestFractional(float)>:

 private:
  UartCalibration_t FindClosestFractional(float decimal)
   12378:	b510      	push	{r4, lr}
   1237a:	b08a      	sub	sp, #40	; 0x28
   1237c:	4674      	mov	r4, lr
   1237e:	9003      	str	r0, [sp, #12]
   12380:	9102      	str	r1, [sp, #8]
   12382:	ed8d 0a01 	vstr	s0, [sp, #4]
   12386:	4623      	mov	r3, r4
   12388:	4619      	mov	r1, r3
   1238a:	4838      	ldr	r0, [pc, #224]	; (1246c <Uart::FindClosestFractional(float)+0xf4>)
   1238c:	f000 ffca 	bl	13324 <__cyg_profile_func_enter>
  {
    UartCalibration_t result;
   12390:	9b03      	ldr	r3, [sp, #12]
   12392:	2200      	movs	r2, #0
   12394:	601a      	str	r2, [r3, #0]
   12396:	9b03      	ldr	r3, [sp, #12]
   12398:	2200      	movs	r2, #0
   1239a:	605a      	str	r2, [r3, #4]
   1239c:	9b03      	ldr	r3, [sp, #12]
   1239e:	2201      	movs	r2, #1
   123a0:	609a      	str	r2, [r3, #8]
    bool finished = false;
   123a2:	2300      	movs	r3, #0
   123a4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (int div = 0; div < 15 && !finished; div++)
   123a8:	2300      	movs	r3, #0
   123aa:	9308      	str	r3, [sp, #32]
   123ac:	9b08      	ldr	r3, [sp, #32]
   123ae:	2b0e      	cmp	r3, #14
   123b0:	dc52      	bgt.n	12458 <Uart::FindClosestFractional(float)+0xe0>
   123b2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   123b6:	2b00      	cmp	r3, #0
   123b8:	d14e      	bne.n	12458 <Uart::FindClosestFractional(float)+0xe0>
    {
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   123ba:	9b08      	ldr	r3, [sp, #32]
   123bc:	3301      	adds	r3, #1
   123be:	9307      	str	r3, [sp, #28]
   123c0:	9b07      	ldr	r3, [sp, #28]
   123c2:	2b0e      	cmp	r3, #14
   123c4:	dc44      	bgt.n	12450 <Uart::FindClosestFractional(float)+0xd8>
   123c6:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   123ca:	2b00      	cmp	r3, #0
   123cc:	d140      	bne.n	12450 <Uart::FindClosestFractional(float)+0xd8>
      {
        float divf         = static_cast<float>(div);
   123ce:	9b08      	ldr	r3, [sp, #32]
   123d0:	ee07 3a90 	vmov	s15, r3
   123d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   123d8:	edcd 7a06 	vstr	s15, [sp, #24]
        float mulf         = static_cast<float>(mul);
   123dc:	9b07      	ldr	r3, [sp, #28]
   123de:	ee07 3a90 	vmov	s15, r3
   123e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   123e6:	edcd 7a05 	vstr	s15, [sp, #20]
        float test_decimal = 1.0f + divf / mulf;
   123ea:	eddd 6a06 	vldr	s13, [sp, #24]
   123ee:	ed9d 7a05 	vldr	s14, [sp, #20]
   123f2:	eec6 7a87 	vdiv.f32	s15, s13, s14
   123f6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   123fa:	ee77 7a87 	vadd.f32	s15, s15, s14
   123fe:	edcd 7a04 	vstr	s15, [sp, #16]
        if (decimal <= test_decimal + kThreshold &&
   12402:	eddd 7a04 	vldr	s15, [sp, #16]
   12406:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 12470 <Uart::FindClosestFractional(float)+0xf8>
   1240a:	ee77 7a87 	vadd.f32	s15, s15, s14
   1240e:	ed9d 7a01 	vldr	s14, [sp, #4]
   12412:	eeb4 7ae7 	vcmpe.f32	s14, s15
   12416:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1241a:	d815      	bhi.n	12448 <Uart::FindClosestFractional(float)+0xd0>
            decimal >= test_decimal - kThreshold)
   1241c:	eddd 7a04 	vldr	s15, [sp, #16]
   12420:	ed9f 7a13 	vldr	s14, [pc, #76]	; 12470 <Uart::FindClosestFractional(float)+0xf8>
   12424:	ee77 7ac7 	vsub.f32	s15, s15, s14
        if (decimal <= test_decimal + kThreshold &&
   12428:	ed9d 7a01 	vldr	s14, [sp, #4]
   1242c:	eeb4 7ae7 	vcmpe.f32	s14, s15
   12430:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12434:	db08      	blt.n	12448 <Uart::FindClosestFractional(float)+0xd0>
        {
          result.divide_add = div;
   12436:	9a08      	ldr	r2, [sp, #32]
   12438:	9b03      	ldr	r3, [sp, #12]
   1243a:	605a      	str	r2, [r3, #4]
          result.multiply   = mul;
   1243c:	9a07      	ldr	r2, [sp, #28]
   1243e:	9b03      	ldr	r3, [sp, #12]
   12440:	609a      	str	r2, [r3, #8]
          finished          = true;
   12442:	2301      	movs	r3, #1
   12444:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      for (int mul = div + 1; mul < 15 && !finished; mul++)
   12448:	9b07      	ldr	r3, [sp, #28]
   1244a:	3301      	adds	r3, #1
   1244c:	9307      	str	r3, [sp, #28]
   1244e:	e7b7      	b.n	123c0 <Uart::FindClosestFractional(float)+0x48>
    for (int div = 0; div < 15 && !finished; div++)
   12450:	9b08      	ldr	r3, [sp, #32]
   12452:	3301      	adds	r3, #1
   12454:	9308      	str	r3, [sp, #32]
   12456:	e7a9      	b.n	123ac <Uart::FindClosestFractional(float)+0x34>
        }
      }
    }
    return result;
   12458:	bf00      	nop
   1245a:	4623      	mov	r3, r4
   1245c:	4619      	mov	r1, r3
   1245e:	4803      	ldr	r0, [pc, #12]	; (1246c <Uart::FindClosestFractional(float)+0xf4>)
   12460:	f000 ff74 	bl	1334c <__cyg_profile_func_exit>
   12464:	bf00      	nop
  }
   12466:	9803      	ldr	r0, [sp, #12]
   12468:	b00a      	add	sp, #40	; 0x28
   1246a:	bd10      	pop	{r4, pc}
   1246c:	00012379 	.word	0x00012379
   12470:	3d4ccccd 	.word	0x3d4ccccd

00012474 <Uart::DividerEstimate(float, float)>:

  float DividerEstimate(float baud_rate, float fraction_estimate = 1)
   12474:	b510      	push	{r4, lr}
   12476:	ed2d 8b02 	vpush	{d8}
   1247a:	b086      	sub	sp, #24
   1247c:	4674      	mov	r4, lr
   1247e:	9003      	str	r0, [sp, #12]
   12480:	ed8d 0a02 	vstr	s0, [sp, #8]
   12484:	edcd 0a01 	vstr	s1, [sp, #4]
   12488:	4623      	mov	r3, r4
   1248a:	4619      	mov	r1, r3
   1248c:	4815      	ldr	r0, [pc, #84]	; (124e4 <Uart::DividerEstimate(float, float)+0x70>)
   1248e:	f000 ff49 	bl	13324 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   12492:	9b03      	ldr	r3, [sp, #12]
   12494:	1d1a      	adds	r2, r3, #4
   12496:	9b03      	ldr	r3, [sp, #12]
   12498:	685b      	ldr	r3, [r3, #4]
   1249a:	3310      	adds	r3, #16
   1249c:	681b      	ldr	r3, [r3, #0]
   1249e:	4610      	mov	r0, r2
   124a0:	4798      	blx	r3
   124a2:	ee07 0a90 	vmov	s15, r0
   124a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   124aa:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * fraction_estimate);
   124ae:	eddd 7a02 	vldr	s15, [sp, #8]
   124b2:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   124b6:	ee27 7a87 	vmul.f32	s14, s15, s14
   124ba:	eddd 7a01 	vldr	s15, [sp, #4]
   124be:	ee67 7a27 	vmul.f32	s15, s14, s15
   124c2:	ed9d 7a05 	vldr	s14, [sp, #20]
   124c6:	ee87 8a27 	vdiv.f32	s16, s14, s15
   124ca:	4623      	mov	r3, r4
   124cc:	4619      	mov	r1, r3
   124ce:	4805      	ldr	r0, [pc, #20]	; (124e4 <Uart::DividerEstimate(float, float)+0x70>)
   124d0:	f000 ff3c 	bl	1334c <__cyg_profile_func_exit>
   124d4:	eef0 7a48 	vmov.f32	s15, s16
  }
   124d8:	eeb0 0a67 	vmov.f32	s0, s15
   124dc:	b006      	add	sp, #24
   124de:	ecbd 8b02 	vpop	{d8}
   124e2:	bd10      	pop	{r4, pc}
   124e4:	00012475 	.word	0x00012475

000124e8 <Uart::FractionalEstimate(float, float)>:

  float FractionalEstimate(float baud_rate, float divider)
   124e8:	b510      	push	{r4, lr}
   124ea:	ed2d 8b02 	vpush	{d8}
   124ee:	b086      	sub	sp, #24
   124f0:	4674      	mov	r4, lr
   124f2:	9003      	str	r0, [sp, #12]
   124f4:	ed8d 0a02 	vstr	s0, [sp, #8]
   124f8:	edcd 0a01 	vstr	s1, [sp, #4]
   124fc:	4623      	mov	r3, r4
   124fe:	4619      	mov	r1, r3
   12500:	4815      	ldr	r0, [pc, #84]	; (12558 <Uart::FractionalEstimate(float, float)+0x70>)
   12502:	f000 ff0f 	bl	13324 <__cyg_profile_func_enter>
  {
    float clock_frequency = static_cast<float>(GetPeripheralFrequency());
   12506:	9b03      	ldr	r3, [sp, #12]
   12508:	1d1a      	adds	r2, r3, #4
   1250a:	9b03      	ldr	r3, [sp, #12]
   1250c:	685b      	ldr	r3, [r3, #4]
   1250e:	3310      	adds	r3, #16
   12510:	681b      	ldr	r3, [r3, #0]
   12512:	4610      	mov	r0, r2
   12514:	4798      	blx	r3
   12516:	ee07 0a90 	vmov	s15, r0
   1251a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1251e:	edcd 7a05 	vstr	s15, [sp, #20]
    return clock_frequency / (16.0f * baud_rate * divider);
   12522:	eddd 7a02 	vldr	s15, [sp, #8]
   12526:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   1252a:	ee27 7a87 	vmul.f32	s14, s15, s14
   1252e:	eddd 7a01 	vldr	s15, [sp, #4]
   12532:	ee67 7a27 	vmul.f32	s15, s14, s15
   12536:	ed9d 7a05 	vldr	s14, [sp, #20]
   1253a:	ee87 8a27 	vdiv.f32	s16, s14, s15
   1253e:	4623      	mov	r3, r4
   12540:	4619      	mov	r1, r3
   12542:	4805      	ldr	r0, [pc, #20]	; (12558 <Uart::FractionalEstimate(float, float)+0x70>)
   12544:	f000 ff02 	bl	1334c <__cyg_profile_func_exit>
   12548:	eef0 7a48 	vmov.f32	s15, s16
  }
   1254c:	eeb0 0a67 	vmov.f32	s0, s15
   12550:	b006      	add	sp, #24
   12552:	ecbd 8b02 	vpop	{d8}
   12556:	bd10      	pop	{r4, pc}
   12558:	000124e9 	.word	0x000124e9

0001255c <Uart::IsDecmial(float)>:

  bool IsDecmial(float value)
   1255c:	b530      	push	{r4, r5, lr}
   1255e:	b087      	sub	sp, #28
   12560:	4675      	mov	r5, lr
   12562:	9001      	str	r0, [sp, #4]
   12564:	ed8d 0a00 	vstr	s0, [sp]
   12568:	462b      	mov	r3, r5
   1256a:	4619      	mov	r1, r3
   1256c:	4819      	ldr	r0, [pc, #100]	; (125d4 <Uart::IsDecmial(float)+0x78>)
   1256e:	f000 fed9 	bl	13324 <__cyg_profile_func_enter>
  {
    bool result         = false;
   12572:	2300      	movs	r3, #0
   12574:	f88d 3017 	strb.w	r3, [sp, #23]
    float rounded_value = roundf(value);
   12578:	ed9d 0a00 	vldr	s0, [sp]
   1257c:	f006 f8be 	bl	186fc <roundf>
   12580:	ed8d 0a04 	vstr	s0, [sp, #16]
    float error         = value - rounded_value;
   12584:	ed9d 7a00 	vldr	s14, [sp]
   12588:	eddd 7a04 	vldr	s15, [sp, #16]
   1258c:	ee77 7a67 	vsub.f32	s15, s14, s15
   12590:	edcd 7a03 	vstr	s15, [sp, #12]
    if (-kThreshold <= error && error <= kThreshold)
   12594:	eddd 7a03 	vldr	s15, [sp, #12]
   12598:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 125d8 <Uart::IsDecmial(float)+0x7c>
   1259c:	eef4 7ac7 	vcmpe.f32	s15, s14
   125a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   125a4:	db0b      	blt.n	125be <Uart::IsDecmial(float)+0x62>
   125a6:	eddd 7a03 	vldr	s15, [sp, #12]
   125aa:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 125dc <Uart::IsDecmial(float)+0x80>
   125ae:	eef4 7ac7 	vcmpe.f32	s15, s14
   125b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   125b6:	d802      	bhi.n	125be <Uart::IsDecmial(float)+0x62>
    {
      result = true;
   125b8:	2301      	movs	r3, #1
   125ba:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return result;
   125be:	f89d 4017 	ldrb.w	r4, [sp, #23]
   125c2:	462b      	mov	r3, r5
   125c4:	4619      	mov	r1, r3
   125c6:	4803      	ldr	r0, [pc, #12]	; (125d4 <Uart::IsDecmial(float)+0x78>)
   125c8:	f000 fec0 	bl	1334c <__cyg_profile_func_exit>
   125cc:	4623      	mov	r3, r4
  }
   125ce:	4618      	mov	r0, r3
   125d0:	b007      	add	sp, #28
   125d2:	bd30      	pop	{r4, r5, pc}
   125d4:	0001255d 	.word	0x0001255d
   125d8:	bd4ccccd 	.word	0xbd4ccccd
   125dc:	3d4ccccd 	.word	0x3d4ccccd

000125e0 <Uart::GenerateUartCalibration(float)>:

  UartCalibration_t GenerateUartCalibration(float baud_rate)
   125e0:	b530      	push	{r4, r5, lr}
   125e2:	b08f      	sub	sp, #60	; 0x3c
   125e4:	4675      	mov	r5, lr
   125e6:	9007      	str	r0, [sp, #28]
   125e8:	9106      	str	r1, [sp, #24]
   125ea:	ed8d 0a05 	vstr	s0, [sp, #20]
   125ee:	462b      	mov	r3, r5
   125f0:	4619      	mov	r1, r3
   125f2:	4874      	ldr	r0, [pc, #464]	; (127c4 <Uart::GenerateUartCalibration(float)+0x1e4>)
   125f4:	f000 fe96 	bl	13324 <__cyg_profile_func_enter>
  {
    States state = States::kCalculateIntegerDivideLatch;
   125f8:	2300      	movs	r3, #0
   125fa:	930d      	str	r3, [sp, #52]	; 0x34
    UartCalibration_t uart_calibration;
   125fc:	9b07      	ldr	r3, [sp, #28]
   125fe:	2200      	movs	r2, #0
   12600:	601a      	str	r2, [r3, #0]
   12602:	9b07      	ldr	r3, [sp, #28]
   12604:	2200      	movs	r2, #0
   12606:	605a      	str	r2, [r3, #4]
   12608:	9b07      	ldr	r3, [sp, #28]
   1260a:	2201      	movs	r2, #1
   1260c:	609a      	str	r2, [r3, #8]
    float divide_estimate = 0;
   1260e:	f04f 0300 	mov.w	r3, #0
   12612:	930c      	str	r3, [sp, #48]	; 0x30
    float decimal         = 1.5;
   12614:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
   12618:	930b      	str	r3, [sp, #44]	; 0x2c
    float div             = 1;
   1261a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   1261e:	930a      	str	r3, [sp, #40]	; 0x28
    float mul             = 2;
   12620:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   12624:	9309      	str	r3, [sp, #36]	; 0x24
    while (state != States::kDone)
   12626:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12628:	2b04      	cmp	r3, #4
   1262a:	f000 80c1 	beq.w	127b0 <Uart::GenerateUartCalibration(float)+0x1d0>
    {
      switch (state)
   1262e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12630:	2b04      	cmp	r3, #4
   12632:	f200 80bb 	bhi.w	127ac <Uart::GenerateUartCalibration(float)+0x1cc>
   12636:	a201      	add	r2, pc, #4	; (adr r2, 1263c <Uart::GenerateUartCalibration(float)+0x5c>)
   12638:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1263c:	00012651 	.word	0x00012651
   12640:	000126ad 	.word	0x000126ad
   12644:	0001270d 	.word	0x0001270d
   12648:	0001277d 	.word	0x0001277d
   1264c:	000127ad 	.word	0x000127ad
      {
        case States::kCalculateIntegerDivideLatch:
        {
          divide_estimate = DividerEstimate(baud_rate);
   12650:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   12654:	ed9d 0a05 	vldr	s0, [sp, #20]
   12658:	9806      	ldr	r0, [sp, #24]
   1265a:	f7ff ff0b 	bl	12474 <Uart::DividerEstimate(float, float)>
   1265e:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          if (divide_estimate < 1.0f)
   12662:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   12666:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1266a:	eef4 7ac7 	vcmpe.f32	s15, s14
   1266e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12672:	d505      	bpl.n	12680 <Uart::GenerateUartCalibration(float)+0xa0>
          {
            uart_calibration.divide_latch = 0;
   12674:	9b07      	ldr	r3, [sp, #28]
   12676:	2200      	movs	r2, #0
   12678:	601a      	str	r2, [r3, #0]
            state                         = States::kDone;
   1267a:	2304      	movs	r3, #4
   1267c:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kCalculateDivideLatchWithDecimal;
          }
          break;
   1267e:	e096      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
          else if (IsDecmial(divide_estimate))
   12680:	ed9d 0a0c 	vldr	s0, [sp, #48]	; 0x30
   12684:	9806      	ldr	r0, [sp, #24]
   12686:	f7ff ff69 	bl	1255c <Uart::IsDecmial(float)>
   1268a:	4603      	mov	r3, r0
   1268c:	2b00      	cmp	r3, #0
   1268e:	d00a      	beq.n	126a6 <Uart::GenerateUartCalibration(float)+0xc6>
                static_cast<uint32_t>(divide_estimate);
   12690:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   12694:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   12698:	ee17 2a90 	vmov	r2, s15
            uart_calibration.divide_latch =
   1269c:	9b07      	ldr	r3, [sp, #28]
   1269e:	601a      	str	r2, [r3, #0]
            state = States::kDone;
   126a0:	2304      	movs	r3, #4
   126a2:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   126a4:	e083      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kCalculateDivideLatchWithDecimal;
   126a6:	2301      	movs	r3, #1
   126a8:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   126aa:	e080      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kCalculateDivideLatchWithDecimal:
        {
          divide_estimate = roundf(DividerEstimate(baud_rate, decimal));
   126ac:	eddd 0a0b 	vldr	s1, [sp, #44]	; 0x2c
   126b0:	ed9d 0a05 	vldr	s0, [sp, #20]
   126b4:	9806      	ldr	r0, [sp, #24]
   126b6:	f7ff fedd 	bl	12474 <Uart::DividerEstimate(float, float)>
   126ba:	eef0 7a40 	vmov.f32	s15, s0
   126be:	eeb0 0a67 	vmov.f32	s0, s15
   126c2:	f006 f81b 	bl	186fc <roundf>
   126c6:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
          decimal         = FractionalEstimate(baud_rate, divide_estimate);
   126ca:	eddd 0a0c 	vldr	s1, [sp, #48]	; 0x30
   126ce:	ed9d 0a05 	vldr	s0, [sp, #20]
   126d2:	9806      	ldr	r0, [sp, #24]
   126d4:	f7ff ff08 	bl	124e8 <Uart::FractionalEstimate(float, float)>
   126d8:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
          if (1.1f <= decimal && decimal <= 1.9f)
   126dc:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   126e0:	ed9f 7a39 	vldr	s14, [pc, #228]	; 127c8 <Uart::GenerateUartCalibration(float)+0x1e8>
   126e4:	eef4 7ac7 	vcmpe.f32	s15, s14
   126e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   126ec:	db0b      	blt.n	12706 <Uart::GenerateUartCalibration(float)+0x126>
   126ee:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
   126f2:	ed9f 7a36 	vldr	s14, [pc, #216]	; 127cc <Uart::GenerateUartCalibration(float)+0x1ec>
   126f6:	eef4 7ac7 	vcmpe.f32	s15, s14
   126fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   126fe:	d802      	bhi.n	12706 <Uart::GenerateUartCalibration(float)+0x126>
          {
            state = States::kGenerateFractionFromDecimal;
   12700:	2303      	movs	r3, #3
   12702:	930d      	str	r3, [sp, #52]	; 0x34
          }
          else
          {
            state = States::kDecimalFailedGenerateNewDecimal;
          }
          break;
   12704:	e053      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
            state = States::kDecimalFailedGenerateNewDecimal;
   12706:	2302      	movs	r3, #2
   12708:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   1270a:	e050      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDecimalFailedGenerateNewDecimal:
        {
          mul += 1;
   1270c:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   12710:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   12714:	ee77 7a87 	vadd.f32	s15, s15, s14
   12718:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24

          if (div > 15)
   1271c:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   12720:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   12724:	eef4 7ac7 	vcmpe.f32	s15, s14
   12728:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1272c:	dd02      	ble.n	12734 <Uart::GenerateUartCalibration(float)+0x154>
          {
            state = States::kDone;
   1272e:	2304      	movs	r3, #4
   12730:	930d      	str	r3, [sp, #52]	; 0x34
            break;
   12732:	e03c      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
          }
          else if (mul > 15)
   12734:	eddd 7a09 	vldr	s15, [sp, #36]	; 0x24
   12738:	eeb2 7a0e 	vmov.f32	s14, #46	; 0x41700000  15.0
   1273c:	eef4 7ac7 	vcmpe.f32	s15, s14
   12740:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12744:	dd0f      	ble.n	12766 <Uart::GenerateUartCalibration(float)+0x186>
          {
            div += 1;
   12746:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   1274a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1274e:	ee77 7a87 	vadd.f32	s15, s15, s14
   12752:	edcd 7a0a 	vstr	s15, [sp, #40]	; 0x28
            mul = div + 1;
   12756:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
   1275a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1275e:	ee77 7a87 	vadd.f32	s15, s15, s14
   12762:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
          }
          decimal = div / mul;
   12766:	eddd 6a0a 	vldr	s13, [sp, #40]	; 0x28
   1276a:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
   1276e:	eec6 7a87 	vdiv.f32	s15, s13, s14
   12772:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
          state   = States::kCalculateDivideLatchWithDecimal;
   12776:	2301      	movs	r3, #1
   12778:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   1277a:	e018      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kGenerateFractionFromDecimal:
        {
          uart_calibration = FindClosestFractional(decimal);
   1277c:	9c07      	ldr	r4, [sp, #28]
   1277e:	466b      	mov	r3, sp
   12780:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
   12784:	9906      	ldr	r1, [sp, #24]
   12786:	4618      	mov	r0, r3
   12788:	f7ff fdf6 	bl	12378 <Uart::FindClosestFractional(float)>
   1278c:	466b      	mov	r3, sp
   1278e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   12792:	e884 0007 	stmia.w	r4, {r0, r1, r2}
          uart_calibration.divide_latch =
              static_cast<uint32_t>(divide_estimate);
   12796:	eddd 7a0c 	vldr	s15, [sp, #48]	; 0x30
   1279a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1279e:	ee17 2a90 	vmov	r2, s15
          uart_calibration.divide_latch =
   127a2:	9b07      	ldr	r3, [sp, #28]
   127a4:	601a      	str	r2, [r3, #0]
          state = States::kDone;
   127a6:	2304      	movs	r3, #4
   127a8:	930d      	str	r3, [sp, #52]	; 0x34
          break;
   127aa:	e000      	b.n	127ae <Uart::GenerateUartCalibration(float)+0x1ce>
        }
        case States::kDone: { break;
        }
        default: { break;
   127ac:	bf00      	nop
    while (state != States::kDone)
   127ae:	e73a      	b.n	12626 <Uart::GenerateUartCalibration(float)+0x46>
        }
      }
    }
    return uart_calibration;
   127b0:	bf00      	nop
   127b2:	462b      	mov	r3, r5
   127b4:	4619      	mov	r1, r3
   127b6:	4803      	ldr	r0, [pc, #12]	; (127c4 <Uart::GenerateUartCalibration(float)+0x1e4>)
   127b8:	f000 fdc8 	bl	1334c <__cyg_profile_func_exit>
   127bc:	bf00      	nop
  }
   127be:	9807      	ldr	r0, [sp, #28]
   127c0:	b00f      	add	sp, #60	; 0x3c
   127c2:	bd30      	pop	{r4, r5, pc}
   127c4:	000125e1 	.word	0x000125e1
   127c8:	3f8ccccd 	.word	0x3f8ccccd
   127cc:	3ff33333 	.word	0x3ff33333

000127d0 <(anonymous namespace)::Lpc40xxUptime()>:
{
   127d0:	b538      	push	{r3, r4, r5, lr}
   127d2:	4675      	mov	r5, lr
   127d4:	462b      	mov	r3, r5
   127d6:	4619      	mov	r1, r3
   127d8:	480a      	ldr	r0, [pc, #40]	; (12804 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   127da:	f000 fda3 	bl	13324 <__cyg_profile_func_enter>
    return tim_register[channel_]->TC;
   127de:	4b0a      	ldr	r3, [pc, #40]	; (12808 <(anonymous namespace)::Lpc40xxUptime()+0x38>)
   127e0:	7a1b      	ldrb	r3, [r3, #8]
   127e2:	461a      	mov	r2, r3
   127e4:	4b09      	ldr	r3, [pc, #36]	; (1280c <(anonymous namespace)::Lpc40xxUptime()+0x3c>)
   127e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   127ea:	689c      	ldr	r4, [r3, #8]
   127ec:	462b      	mov	r3, r5
   127ee:	4619      	mov	r1, r3
   127f0:	4804      	ldr	r0, [pc, #16]	; (12804 <(anonymous namespace)::Lpc40xxUptime()+0x34>)
   127f2:	f000 fdab 	bl	1334c <__cyg_profile_func_exit>
  return timer0.GetTimer();
   127f6:	4623      	mov	r3, r4
   127f8:	f04f 0400 	mov.w	r4, #0
}
   127fc:	4618      	mov	r0, r3
   127fe:	4621      	mov	r1, r4
   12800:	bd38      	pop	{r3, r4, r5, pc}
   12802:	bf00      	nop
   12804:	00011f15 	.word	0x00011f15
   12808:	100000f8 	.word	0x100000f8
   1280c:	10000078 	.word	0x10000078

00012810 <UptimeRTOS>:
{
   12810:	b538      	push	{r3, r4, r5, lr}
   12812:	4675      	mov	r5, lr
   12814:	462b      	mov	r3, r5
   12816:	4619      	mov	r1, r3
   12818:	480a      	ldr	r0, [pc, #40]	; (12844 <UptimeRTOS+0x34>)
   1281a:	f000 fd83 	bl	13324 <__cyg_profile_func_enter>
   1281e:	4b0a      	ldr	r3, [pc, #40]	; (12848 <UptimeRTOS+0x38>)
   12820:	7a1b      	ldrb	r3, [r3, #8]
   12822:	461a      	mov	r2, r3
   12824:	4b09      	ldr	r3, [pc, #36]	; (1284c <UptimeRTOS+0x3c>)
   12826:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1282a:	689c      	ldr	r4, [r3, #8]
   1282c:	462b      	mov	r3, r5
   1282e:	4619      	mov	r1, r3
   12830:	4804      	ldr	r0, [pc, #16]	; (12844 <UptimeRTOS+0x34>)
   12832:	f000 fd8b 	bl	1334c <__cyg_profile_func_exit>
  return timer0.GetTimer();
   12836:	4623      	mov	r3, r4
   12838:	f04f 0400 	mov.w	r4, #0
}
   1283c:	4618      	mov	r0, r3
   1283e:	4621      	mov	r1, r4
   12840:	bd38      	pop	{r3, r4, r5, pc}
   12842:	bf00      	nop
   12844:	00011f15 	.word	0x00011f15
   12848:	100000f8 	.word	0x100000f8
   1284c:	10000078 	.word	0x10000078

00012850 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>:
   *  @brief  Return the size of an array.
   *  @param  __array  Array.
   */
  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (&/*__array*/)[_Nm]) noexcept
   12850:	b530      	push	{r4, r5, lr}
   12852:	b083      	sub	sp, #12
   12854:	4675      	mov	r5, lr
   12856:	9001      	str	r0, [sp, #4]
   12858:	462b      	mov	r3, r5
   1285a:	4619      	mov	r1, r3
   1285c:	4806      	ldr	r0, [pc, #24]	; (12878 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   1285e:	f000 fd61 	bl	13324 <__cyg_profile_func_enter>
    { return _Nm; }
   12862:	2450      	movs	r4, #80	; 0x50
   12864:	462b      	mov	r3, r5
   12866:	4619      	mov	r1, r3
   12868:	4803      	ldr	r0, [pc, #12]	; (12878 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])+0x28>)
   1286a:	f000 fd6f 	bl	1334c <__cyg_profile_func_exit>
   1286e:	4623      	mov	r3, r4
   12870:	4618      	mov	r0, r3
   12872:	b003      	add	sp, #12
   12874:	bd30      	pop	{r4, r5, pc}
   12876:	bf00      	nop
   12878:	00012851 	.word	0x00012851

0001287c <vApplicationGetIdleTaskMemory>:
  {
   1287c:	b500      	push	{lr}
   1287e:	b085      	sub	sp, #20
   12880:	9003      	str	r0, [sp, #12]
   12882:	9102      	str	r1, [sp, #8]
   12884:	9201      	str	r2, [sp, #4]
    *ppx_idle_task_tcb_buffer   = &idle_task_tcb;
   12886:	9b03      	ldr	r3, [sp, #12]
   12888:	4a07      	ldr	r2, [pc, #28]	; (128a8 <vApplicationGetIdleTaskMemory+0x2c>)
   1288a:	601a      	str	r2, [r3, #0]
    *ppx_idle_task_stack_buffer = idle_task_stack;
   1288c:	9b02      	ldr	r3, [sp, #8]
   1288e:	4a07      	ldr	r2, [pc, #28]	; (128ac <vApplicationGetIdleTaskMemory+0x30>)
   12890:	601a      	str	r2, [r3, #0]
    *pul_idle_task_stack_size   = std::size(idle_task_stack);
   12892:	4806      	ldr	r0, [pc, #24]	; (128ac <vApplicationGetIdleTaskMemory+0x30>)
   12894:	f7ff ffdc 	bl	12850 <unsigned int std::size<unsigned long, 80u>(unsigned long const (&) [80u])>
   12898:	4602      	mov	r2, r0
   1289a:	9b01      	ldr	r3, [sp, #4]
   1289c:	601a      	str	r2, [r3, #0]
  }
   1289e:	bf00      	nop
   128a0:	b005      	add	sp, #20
   128a2:	f85d fb04 	ldr.w	pc, [sp], #4
   128a6:	bf00      	nop
   128a8:	10000418 	.word	0x10000418
   128ac:	10000478 	.word	0x10000478

000128b0 <vPortSetupTimerInterrupt>:
  {
   128b0:	b508      	push	{r3, lr}
    system_timer.DisableTimer();
   128b2:	f7fe fdff 	bl	114b4 <SystemTimer::DisableTimer()>
    system_timer.SetTickFrequency(config::kRtosFrequency);
   128b6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   128ba:	4806      	ldr	r0, [pc, #24]	; (128d4 <vPortSetupTimerInterrupt+0x24>)
   128bc:	f7fe fe9a 	bl	115f4 <SystemTimer::SetTickFrequency(unsigned long)>
    system_timer.SetIsrFunction(xPortSysTickHandler);
   128c0:	4905      	ldr	r1, [pc, #20]	; (128d8 <vPortSetupTimerInterrupt+0x28>)
   128c2:	4804      	ldr	r0, [pc, #16]	; (128d4 <vPortSetupTimerInterrupt+0x24>)
   128c4:	f7fe fe2e 	bl	11524 <SystemTimer::SetIsrFunction(void (*)())>
    system_timer.StartTimer();
   128c8:	4802      	ldr	r0, [pc, #8]	; (128d4 <vPortSetupTimerInterrupt+0x24>)
   128ca:	f7fe fe45 	bl	11558 <SystemTimer::StartTimer()>
  }
   128ce:	bf00      	nop
   128d0:	bd08      	pop	{r3, pc}
   128d2:	bf00      	nop
   128d4:	100000ec 	.word	0x100000ec
   128d8:	00014b09 	.word	0x00014b09

000128dc <LowLevelInit()>:

void LowLevelInit()
{
   128dc:	b500      	push	{lr}
   128de:	b083      	sub	sp, #12
  // Set the SystemTick frequency to the RTOS tick frequency
  // It is critical that this happens before you set the system_clock, since
  // The system_timer keeps the time that the system_clock uses to delay itself.
  system_timer.SetTickFrequency(config::kRtosFrequency);
   128e0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   128e4:	4822      	ldr	r0, [pc, #136]	; (12970 <LowLevelInit()+0x94>)
   128e6:	f7fe fe85 	bl	115f4 <SystemTimer::SetTickFrequency(unsigned long)>
  bool timer_started_successfully = system_timer.StartTimer();
   128ea:	4821      	ldr	r0, [pc, #132]	; (12970 <LowLevelInit()+0x94>)
   128ec:	f7fe fe34 	bl	11558 <SystemTimer::StartTimer()>
   128f0:	4603      	mov	r3, r0
   128f2:	f88d 3007 	strb.w	r3, [sp, #7]
  SJ2_ASSERT_WARNING(timer_started_successfully,
   128f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   128fa:	f083 0301 	eor.w	r3, r3, #1
   128fe:	b2db      	uxtb	r3, r3
   12900:	2b00      	cmp	r3, #0
   12902:	d005      	beq.n	12910 <LowLevelInit()+0x34>
   12904:	23ad      	movs	r3, #173	; 0xad
   12906:	4a1b      	ldr	r2, [pc, #108]	; (12974 <LowLevelInit()+0x98>)
   12908:	491b      	ldr	r1, [pc, #108]	; (12978 <LowLevelInit()+0x9c>)
   1290a:	481c      	ldr	r0, [pc, #112]	; (1297c <LowLevelInit()+0xa0>)
   1290c:	f003 faa6 	bl	15e5c <printf>
                     "System Timer has FAILED to start!");
  // Set Clock Speed
  // SetClockFrequency will timeout return the offset between desire clockspeed
  // and actual clockspeed if the PLL doesn't get a frequency fix within a
  // defined timeout (see L1/system_clock.hpp:kDefaultTimeout)
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   12910:	2130      	movs	r1, #48	; 0x30
   12912:	481b      	ldr	r0, [pc, #108]	; (12980 <LowLevelInit()+0xa4>)
   12914:	f7fe fb06 	bl	10f24 <Lpc40xxSystemController::SetClockFrequency(unsigned char)>
   12918:	4603      	mov	r3, r0
   1291a:	2b00      	cmp	r3, #0
   1291c:	bf14      	ite	ne
   1291e:	2301      	movne	r3, #1
   12920:	2300      	moveq	r3, #0
   12922:	b2db      	uxtb	r3, r3
   12924:	2b00      	cmp	r3, #0
   12926:	d001      	beq.n	1292c <LowLevelInit()+0x50>
  {
    // Continually attempt to set the clock frequency to the desired until the
    // delta between desired and actual are 0.
    continue;
   12928:	bf00      	nop
  while (system_controller.SetClockFrequency(config::kSystemClockRateMhz) != 0)
   1292a:	e7f1      	b.n	12910 <LowLevelInit()+0x34>
  }
  // Enable Peripheral Clock and set its divider to 1 meaning the clock speed
  // fed to all peripherals will be 48Mhz.
  system_controller.SetPeripheralClockDivider(1);
   1292c:	2101      	movs	r1, #1
   1292e:	4814      	ldr	r0, [pc, #80]	; (12980 <LowLevelInit()+0xa4>)
   12930:	f7fe fb40 	bl	10fb4 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)>
  // Set System Timer frequency again, since the clock speed has changed since
  // the last time we ran this.
  system_timer.DisableTimer();
   12934:	f7fe fdbe 	bl	114b4 <SystemTimer::DisableTimer()>
  system_timer.SetTickFrequency(config::kRtosFrequency);
   12938:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1293c:	480c      	ldr	r0, [pc, #48]	; (12970 <LowLevelInit()+0x94>)
   1293e:	f7fe fe59 	bl	115f4 <SystemTimer::SetTickFrequency(unsigned long)>
  system_timer.StartTimer();
   12942:	480b      	ldr	r0, [pc, #44]	; (12970 <LowLevelInit()+0x94>)
   12944:	f7fe fe08 	bl	11558 <SystemTimer::StartTimer()>
  // Set timer0 to 1 MHz (1,000,000 Hz) so that the timer increments every 1
  // micro second.
  timer0.Initialize(1'000'000);
   12948:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1294c:	4a0d      	ldr	r2, [pc, #52]	; (12984 <LowLevelInit()+0xa8>)
   1294e:	490e      	ldr	r1, [pc, #56]	; (12988 <LowLevelInit()+0xac>)
   12950:	480e      	ldr	r0, [pc, #56]	; (1298c <LowLevelInit()+0xb0>)
   12952:	f7ff f9b1 	bl	11cb8 <Timer::Initialize(unsigned long, void (*)(), long)>
  SetUptimeFunction(Lpc40xxUptime);
   12956:	480e      	ldr	r0, [pc, #56]	; (12990 <LowLevelInit()+0xb4>)
   12958:	f7fe facc 	bl	10ef4 <SetUptimeFunction(unsigned long long (*)())>
  // Set UART0 baudrate, which is required for printf and scanf to work properly
  uart0.Initialize(config::kBaudRate);
   1295c:	f44f 4116 	mov.w	r1, #38400	; 0x9600
   12960:	480c      	ldr	r0, [pc, #48]	; (12994 <LowLevelInit()+0xb8>)
   12962:	f7ff fb5b 	bl	1201c <Uart::Initialize(unsigned long)>
}
   12966:	bf00      	nop
   12968:	b003      	add	sp, #12
   1296a:	f85d fb04 	ldr.w	pc, [sp], #4
   1296e:	bf00      	nop
   12970:	100000ec 	.word	0x100000ec
   12974:	000198ac 	.word	0x000198ac
   12978:	00019614 	.word	0x00019614
   1297c:	000194f4 	.word	0x000194f4
   12980:	100000f4 	.word	0x100000f4
   12984:	00011c99 	.word	0x00011c99
   12988:	000f4240 	.word	0x000f4240
   1298c:	100000f8 	.word	0x100000f8
   12990:	000127d1 	.word	0x000127d1
   12994:	100000d8 	.word	0x100000d8

00012998 <SystemInit>:

void SystemInit()
{
   12998:	b508      	push	{r3, lr}
  // Transfer data section values from flash to RAM
  InitDataSection();
   1299a:	f7fd fbb7 	bl	1010c <InitDataSection()>
  // Clear BSS section of RAM
  // This is required because the nano implementation of the standard C/C++
  // libraries assumes that the BSS section is initialized to 0.
  InitBssSection();
   1299e:	f7fd fbfd 	bl	1019c <InitBssSection()>
  // Enable FPU (F.loating P.oint U.nit)
  // System will crash if floating point operations occur without
  // Initializing the FPU.
  InitFpu();
   129a2:	f7fd fc2b 	bl	101fc <InitFpu()>
  // Initialisation C++ libraries
  __libc_init_array();
   129a6:	f006 f8b1 	bl	18b0c <__libc_init_array>
  // Run LowLevel System Initialization
  LowLevelInit();
   129aa:	f7ff ff97 	bl	128dc <LowLevelInit()>
}
   129ae:	bf00      	nop
   129b0:	bd08      	pop	{r3, pc}
   129b2:	Address 0x00000000000129b2 is out of bounds.


000129b4 <ResetIsr>:
// Sets up a simple runtime environment and initializes the C/C++ library.

extern "C"
{
  void ResetIsr(void)
  {
   129b4:	b580      	push	{r7, lr}
   129b6:	b084      	sub	sp, #16
   129b8:	af00      	add	r7, sp, #0
    // The Hyperload bootloader takes up stack space to execute. The Hyperload
    // bootloader function launches this ISR manually, but it never returns thus
    // it never cleans up the memory it uses. To get that memory back, we have
    // to manually move the stack pointers back to the top of stack.
    const uint32_t kTopOfStack = reinterpret_cast<intptr_t>(&StackTop);
   129ba:	4b09      	ldr	r3, [pc, #36]	; (129e0 <ResetIsr+0x2c>)
   129bc:	60fb      	str	r3, [r7, #12]
   129be:	68fb      	ldr	r3, [r7, #12]
   129c0:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
   129c2:	683b      	ldr	r3, [r7, #0]
   129c4:	f383 8809 	msr	PSP, r3
   129c8:	68fb      	ldr	r3, [r7, #12]
   129ca:	607b      	str	r3, [r7, #4]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
   129cc:	687b      	ldr	r3, [r7, #4]
   129ce:	f383 8808 	msr	MSP, r3
    __set_PSP(kTopOfStack);
    __set_MSP(kTopOfStack);

    SystemInit();
   129d2:	f7ff ffe1 	bl	12998 <SystemInit>
// #pragma ignored "-Wpedantic" to suppress main function call warning
#pragma GCC diagnostic push ignored "-Wpedantic"
    [[maybe_unused]] int32_t result = main();
   129d6:	f7fe f8a5 	bl	10b24 <main>
   129da:	60b8      	str	r0, [r7, #8]
   129dc:	e7fe      	b.n	129dc <ResetIsr+0x28>
   129de:	bf00      	nop
   129e0:	10010000 	.word	0x10010000

000129e4 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()>:
  static void TimerHandler()
   129e4:	b510      	push	{r4, lr}
   129e6:	4674      	mov	r4, lr
   129e8:	4623      	mov	r3, r4
   129ea:	4619      	mov	r1, r3
   129ec:	480a      	ldr	r0, [pc, #40]	; (12a18 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   129ee:	f000 fc99 	bl	13324 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   129f2:	2000      	movs	r0, #0
   129f4:	f7ff f938 	bl	11c68 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   129f8:	4603      	mov	r3, r0
   129fa:	461a      	mov	r2, r3
   129fc:	4b07      	ldr	r3, [pc, #28]	; (12a1c <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x38>)
   129fe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12a02:	4798      	blx	r3
    ClearInterrupts<port>();
   12a04:	f000 f90e 	bl	12c24 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>
   12a08:	4623      	mov	r3, r4
   12a0a:	4619      	mov	r1, r3
   12a0c:	4802      	ldr	r0, [pc, #8]	; (12a18 <void Timer::TimerHandler<(TimerInterface::TimerPort)0>()+0x34>)
   12a0e:	f000 fc9d 	bl	1334c <__cyg_profile_func_exit>
  }
   12a12:	bf00      	nop
   12a14:	bd10      	pop	{r4, pc}
   12a16:	bf00      	nop
   12a18:	000129e5 	.word	0x000129e5
   12a1c:	10000408 	.word	0x10000408

00012a20 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()>:
  static void TimerHandler()
   12a20:	b510      	push	{r4, lr}
   12a22:	4674      	mov	r4, lr
   12a24:	4623      	mov	r3, r4
   12a26:	4619      	mov	r1, r3
   12a28:	480a      	ldr	r0, [pc, #40]	; (12a54 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   12a2a:	f000 fc7b 	bl	13324 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   12a2e:	2001      	movs	r0, #1
   12a30:	f7ff f91a 	bl	11c68 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   12a34:	4603      	mov	r3, r0
   12a36:	461a      	mov	r2, r3
   12a38:	4b07      	ldr	r3, [pc, #28]	; (12a58 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x38>)
   12a3a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12a3e:	4798      	blx	r3
    ClearInterrupts<port>();
   12a40:	f000 f940 	bl	12cc4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>
   12a44:	4623      	mov	r3, r4
   12a46:	4619      	mov	r1, r3
   12a48:	4802      	ldr	r0, [pc, #8]	; (12a54 <void Timer::TimerHandler<(TimerInterface::TimerPort)1>()+0x34>)
   12a4a:	f000 fc7f 	bl	1334c <__cyg_profile_func_exit>
  }
   12a4e:	bf00      	nop
   12a50:	bd10      	pop	{r4, pc}
   12a52:	bf00      	nop
   12a54:	00012a21 	.word	0x00012a21
   12a58:	10000408 	.word	0x10000408

00012a5c <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()>:
  static void TimerHandler()
   12a5c:	b510      	push	{r4, lr}
   12a5e:	4674      	mov	r4, lr
   12a60:	4623      	mov	r3, r4
   12a62:	4619      	mov	r1, r3
   12a64:	480a      	ldr	r0, [pc, #40]	; (12a90 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   12a66:	f000 fc5d 	bl	13324 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   12a6a:	2002      	movs	r0, #2
   12a6c:	f7ff f8fc 	bl	11c68 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   12a70:	4603      	mov	r3, r0
   12a72:	461a      	mov	r2, r3
   12a74:	4b07      	ldr	r3, [pc, #28]	; (12a94 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x38>)
   12a76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12a7a:	4798      	blx	r3
    ClearInterrupts<port>();
   12a7c:	f000 f972 	bl	12d64 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>
   12a80:	4623      	mov	r3, r4
   12a82:	4619      	mov	r1, r3
   12a84:	4802      	ldr	r0, [pc, #8]	; (12a90 <void Timer::TimerHandler<(TimerInterface::TimerPort)2>()+0x34>)
   12a86:	f000 fc61 	bl	1334c <__cyg_profile_func_exit>
  }
   12a8a:	bf00      	nop
   12a8c:	bd10      	pop	{r4, pc}
   12a8e:	bf00      	nop
   12a90:	00012a5d 	.word	0x00012a5d
   12a94:	10000408 	.word	0x10000408

00012a98 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()>:
  static void TimerHandler()
   12a98:	b510      	push	{r4, lr}
   12a9a:	4674      	mov	r4, lr
   12a9c:	4623      	mov	r3, r4
   12a9e:	4619      	mov	r1, r3
   12aa0:	480a      	ldr	r0, [pc, #40]	; (12acc <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   12aa2:	f000 fc3f 	bl	13324 <__cyg_profile_func_enter>
      user_timer_isr[util::Value(port)]();
   12aa6:	2003      	movs	r0, #3
   12aa8:	f7ff f8de 	bl	11c68 <unsigned char util::Value<TimerInterface::TimerPort, unsigned char>(TimerInterface::TimerPort)>
   12aac:	4603      	mov	r3, r0
   12aae:	461a      	mov	r2, r3
   12ab0:	4b07      	ldr	r3, [pc, #28]	; (12ad0 <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x38>)
   12ab2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   12ab6:	4798      	blx	r3
    ClearInterrupts<port>();
   12ab8:	f000 f9a4 	bl	12e04 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>
   12abc:	4623      	mov	r3, r4
   12abe:	4619      	mov	r1, r3
   12ac0:	4802      	ldr	r0, [pc, #8]	; (12acc <void Timer::TimerHandler<(TimerInterface::TimerPort)3>()+0x34>)
   12ac2:	f000 fc43 	bl	1334c <__cyg_profile_func_exit>
  }
   12ac6:	bf00      	nop
   12ac8:	bd10      	pop	{r4, pc}
   12aca:	bf00      	nop
   12acc:	00012a99 	.word	0x00012a99
   12ad0:	10000408 	.word	0x10000408

00012ad4 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   12ad4:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   12ad8:	b088      	sub	sp, #32
   12ada:	4675      	mov	r5, lr
   12adc:	e9cd 0102 	strd	r0, r1, [sp, #8]
   12ae0:	9201      	str	r2, [sp, #4]
   12ae2:	462b      	mov	r3, r5
   12ae4:	4619      	mov	r1, r3
   12ae6:	4824      	ldr	r0, [pc, #144]	; (12b78 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   12ae8:	f000 fc1c 	bl	13324 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   12aec:	f04f 0300 	mov.w	r3, #0
   12af0:	f04f 0400 	mov.w	r4, #0
   12af4:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   12af8:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12afc:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   12b00:	bf08      	it	eq
   12b02:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   12b06:	d106      	bne.n	12b16 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   12b08:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12b0c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   12b10:	e9cd 3406 	strd	r3, r4, [sp, #24]
   12b14:	e00b      	b.n	12b2e <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   12b16:	f7fd fe2f 	bl	10778 <Milliseconds()>
   12b1a:	460a      	mov	r2, r1
   12b1c:	4601      	mov	r1, r0
   12b1e:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12b22:	eb13 0b01 	adds.w	fp, r3, r1
   12b26:	eb44 0c02 	adc.w	ip, r4, r2
   12b2a:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   12b2e:	2301      	movs	r3, #1
   12b30:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   12b32:	f7fd fe21 	bl	10778 <Milliseconds()>
   12b36:	460a      	mov	r2, r1
   12b38:	4601      	mov	r1, r0
   12b3a:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   12b3e:	42a2      	cmp	r2, r4
   12b40:	bf08      	it	eq
   12b42:	4299      	cmpeq	r1, r3
   12b44:	bf34      	ite	cc
   12b46:	2301      	movcc	r3, #1
   12b48:	2300      	movcs	r3, #0
   12b4a:	b2db      	uxtb	r3, r3
   12b4c:	2b00      	cmp	r3, #0
   12b4e:	d008      	beq.n	12b62 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x8e>
    if (is_done())
   12b50:	ab01      	add	r3, sp, #4
   12b52:	4618      	mov	r0, r3
   12b54:	f7ff fad4 	bl	12100 <Uart::Send(unsigned char)::{lambda()#1}::operator()() const>
   12b58:	4603      	mov	r3, r0
   12b5a:	2b00      	cmp	r3, #0
   12b5c:	d0e9      	beq.n	12b32 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   12b5e:	2300      	movs	r3, #0
   12b60:	9305      	str	r3, [sp, #20]
  return status;
   12b62:	9c05      	ldr	r4, [sp, #20]
   12b64:	462b      	mov	r3, r5
   12b66:	4619      	mov	r1, r3
   12b68:	4803      	ldr	r0, [pc, #12]	; (12b78 <Status Wait<Uart::Send(unsigned char)::{lambda()#1}>(unsigned long long, Uart::Send(unsigned char)::{lambda()#1})+0xa4>)
   12b6a:	f000 fbef 	bl	1334c <__cyg_profile_func_exit>
   12b6e:	4623      	mov	r3, r4
}
   12b70:	4618      	mov	r0, r3
   12b72:	b008      	add	sp, #32
   12b74:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   12b78:	00012ad5 	.word	0x00012ad5

00012b7c <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})>:
inline Status Wait(uint64_t timeout, F is_done)
   12b7c:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
   12b80:	b088      	sub	sp, #32
   12b82:	4675      	mov	r5, lr
   12b84:	e9cd 0102 	strd	r0, r1, [sp, #8]
   12b88:	9201      	str	r2, [sp, #4]
   12b8a:	462b      	mov	r3, r5
   12b8c:	4619      	mov	r1, r3
   12b8e:	4824      	ldr	r0, [pc, #144]	; (12c20 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   12b90:	f000 fbc8 	bl	13324 <__cyg_profile_func_enter>
  uint64_t timeout_time = 0;
   12b94:	f04f 0300 	mov.w	r3, #0
   12b98:	f04f 0400 	mov.w	r4, #0
   12b9c:	e9cd 3406 	strd	r3, r4, [sp, #24]
  if (timeout == kMaxWait)
   12ba0:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12ba4:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   12ba8:	bf08      	it	eq
   12baa:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
   12bae:	d106      	bne.n	12bbe <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x42>
    timeout_time = kMaxWait;
   12bb0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12bb4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   12bb8:	e9cd 3406 	strd	r3, r4, [sp, #24]
   12bbc:	e00b      	b.n	12bd6 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5a>
    timeout_time = Milliseconds() + timeout;
   12bbe:	f7fd fddb 	bl	10778 <Milliseconds()>
   12bc2:	460a      	mov	r2, r1
   12bc4:	4601      	mov	r1, r0
   12bc6:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   12bca:	eb13 0b01 	adds.w	fp, r3, r1
   12bce:	eb44 0c02 	adc.w	ip, r4, r2
   12bd2:	e9cd bc06 	strd	fp, ip, [sp, #24]
  Status status = Status::kTimedOut;
   12bd6:	2301      	movs	r3, #1
   12bd8:	9305      	str	r3, [sp, #20]
  while (Milliseconds() < timeout_time)
   12bda:	f7fd fdcd 	bl	10778 <Milliseconds()>
   12bde:	460a      	mov	r2, r1
   12be0:	4601      	mov	r1, r0
   12be2:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   12be6:	42a2      	cmp	r2, r4
   12be8:	bf08      	it	eq
   12bea:	4299      	cmpeq	r1, r3
   12bec:	bf34      	ite	cc
   12bee:	2301      	movcc	r3, #1
   12bf0:	2300      	movcs	r3, #0
   12bf2:	b2db      	uxtb	r3, r3
   12bf4:	2b00      	cmp	r3, #0
   12bf6:	d008      	beq.n	12c0a <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x8e>
    if (is_done())
   12bf8:	ab01      	add	r3, sp, #4
   12bfa:	4618      	mov	r0, r3
   12bfc:	f7ff fb1a 	bl	12234 <Uart::Receive(unsigned long)::{lambda()#1}::operator()() const>
   12c00:	4603      	mov	r3, r0
   12c02:	2b00      	cmp	r3, #0
   12c04:	d0e9      	beq.n	12bda <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0x5e>
      status = Status::kSuccess;
   12c06:	2300      	movs	r3, #0
   12c08:	9305      	str	r3, [sp, #20]
  return status;
   12c0a:	9c05      	ldr	r4, [sp, #20]
   12c0c:	462b      	mov	r3, r5
   12c0e:	4619      	mov	r1, r3
   12c10:	4803      	ldr	r0, [pc, #12]	; (12c20 <Status Wait<Uart::Receive(unsigned long)::{lambda()#1}>(unsigned long long, Uart::Receive(unsigned long)::{lambda()#1})+0xa4>)
   12c12:	f000 fb9b 	bl	1334c <__cyg_profile_func_exit>
   12c16:	4623      	mov	r3, r4
}
   12c18:	4618      	mov	r0, r3
   12c1a:	b008      	add	sp, #32
   12c1c:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
   12c20:	00012b7d 	.word	0x00012b7d

00012c24 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()>:
  static void ClearInterrupts()
   12c24:	b510      	push	{r4, lr}
   12c26:	b082      	sub	sp, #8
   12c28:	4674      	mov	r4, lr
   12c2a:	4623      	mov	r3, r4
   12c2c:	4619      	mov	r1, r3
   12c2e:	4823      	ldr	r0, [pc, #140]	; (12cbc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   12c30:	f000 fb78 	bl	13324 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   12c34:	2300      	movs	r3, #0
   12c36:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   12c3a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c3e:	4a20      	ldr	r2, [pc, #128]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12c40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c44:	681a      	ldr	r2, [r3, #0]
   12c46:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c4a:	491d      	ldr	r1, [pc, #116]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12c4c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12c50:	f042 0201 	orr.w	r2, r2, #1
   12c54:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   12c56:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c5a:	4a19      	ldr	r2, [pc, #100]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12c5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c60:	681a      	ldr	r2, [r3, #0]
   12c62:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c66:	4916      	ldr	r1, [pc, #88]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12c68:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12c6c:	f042 0202 	orr.w	r2, r2, #2
   12c70:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   12c72:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c76:	4a12      	ldr	r2, [pc, #72]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12c78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c7c:	681a      	ldr	r2, [r3, #0]
   12c7e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c82:	490f      	ldr	r1, [pc, #60]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12c84:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12c88:	f042 0204 	orr.w	r2, r2, #4
   12c8c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   12c8e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c92:	4a0b      	ldr	r2, [pc, #44]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12c94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c98:	681a      	ldr	r2, [r3, #0]
   12c9a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12c9e:	4908      	ldr	r1, [pc, #32]	; (12cc0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x9c>)
   12ca0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12ca4:	f042 0208 	orr.w	r2, r2, #8
   12ca8:	601a      	str	r2, [r3, #0]
   12caa:	4623      	mov	r3, r4
   12cac:	4619      	mov	r1, r3
   12cae:	4803      	ldr	r0, [pc, #12]	; (12cbc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)0>()+0x98>)
   12cb0:	f000 fb4c 	bl	1334c <__cyg_profile_func_exit>
  }
   12cb4:	bf00      	nop
   12cb6:	b002      	add	sp, #8
   12cb8:	bd10      	pop	{r4, pc}
   12cba:	bf00      	nop
   12cbc:	00012c25 	.word	0x00012c25
   12cc0:	10000078 	.word	0x10000078

00012cc4 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()>:
  static void ClearInterrupts()
   12cc4:	b510      	push	{r4, lr}
   12cc6:	b082      	sub	sp, #8
   12cc8:	4674      	mov	r4, lr
   12cca:	4623      	mov	r3, r4
   12ccc:	4619      	mov	r1, r3
   12cce:	4823      	ldr	r0, [pc, #140]	; (12d5c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   12cd0:	f000 fb28 	bl	13324 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   12cd4:	2301      	movs	r3, #1
   12cd6:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   12cda:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12cde:	4a20      	ldr	r2, [pc, #128]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12ce0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ce4:	681a      	ldr	r2, [r3, #0]
   12ce6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12cea:	491d      	ldr	r1, [pc, #116]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12cec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12cf0:	f042 0201 	orr.w	r2, r2, #1
   12cf4:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   12cf6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12cfa:	4a19      	ldr	r2, [pc, #100]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12cfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d00:	681a      	ldr	r2, [r3, #0]
   12d02:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d06:	4916      	ldr	r1, [pc, #88]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12d08:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12d0c:	f042 0202 	orr.w	r2, r2, #2
   12d10:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   12d12:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d16:	4a12      	ldr	r2, [pc, #72]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12d18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d1c:	681a      	ldr	r2, [r3, #0]
   12d1e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d22:	490f      	ldr	r1, [pc, #60]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12d24:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12d28:	f042 0204 	orr.w	r2, r2, #4
   12d2c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   12d2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d32:	4a0b      	ldr	r2, [pc, #44]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12d34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d38:	681a      	ldr	r2, [r3, #0]
   12d3a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d3e:	4908      	ldr	r1, [pc, #32]	; (12d60 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x9c>)
   12d40:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12d44:	f042 0208 	orr.w	r2, r2, #8
   12d48:	601a      	str	r2, [r3, #0]
   12d4a:	4623      	mov	r3, r4
   12d4c:	4619      	mov	r1, r3
   12d4e:	4803      	ldr	r0, [pc, #12]	; (12d5c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)1>()+0x98>)
   12d50:	f000 fafc 	bl	1334c <__cyg_profile_func_exit>
  }
   12d54:	bf00      	nop
   12d56:	b002      	add	sp, #8
   12d58:	bd10      	pop	{r4, pc}
   12d5a:	bf00      	nop
   12d5c:	00012cc5 	.word	0x00012cc5
   12d60:	10000078 	.word	0x10000078

00012d64 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()>:
  static void ClearInterrupts()
   12d64:	b510      	push	{r4, lr}
   12d66:	b082      	sub	sp, #8
   12d68:	4674      	mov	r4, lr
   12d6a:	4623      	mov	r3, r4
   12d6c:	4619      	mov	r1, r3
   12d6e:	4823      	ldr	r0, [pc, #140]	; (12dfc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   12d70:	f000 fad8 	bl	13324 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   12d74:	2302      	movs	r3, #2
   12d76:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   12d7a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d7e:	4a20      	ldr	r2, [pc, #128]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12d80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d84:	681a      	ldr	r2, [r3, #0]
   12d86:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d8a:	491d      	ldr	r1, [pc, #116]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12d8c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12d90:	f042 0201 	orr.w	r2, r2, #1
   12d94:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   12d96:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12d9a:	4a19      	ldr	r2, [pc, #100]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12d9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12da0:	681a      	ldr	r2, [r3, #0]
   12da2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12da6:	4916      	ldr	r1, [pc, #88]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12da8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12dac:	f042 0202 	orr.w	r2, r2, #2
   12db0:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   12db2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12db6:	4a12      	ldr	r2, [pc, #72]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12db8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12dbc:	681a      	ldr	r2, [r3, #0]
   12dbe:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12dc2:	490f      	ldr	r1, [pc, #60]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12dc4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12dc8:	f042 0204 	orr.w	r2, r2, #4
   12dcc:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   12dce:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12dd2:	4a0b      	ldr	r2, [pc, #44]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12dd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12dd8:	681a      	ldr	r2, [r3, #0]
   12dda:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12dde:	4908      	ldr	r1, [pc, #32]	; (12e00 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x9c>)
   12de0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12de4:	f042 0208 	orr.w	r2, r2, #8
   12de8:	601a      	str	r2, [r3, #0]
   12dea:	4623      	mov	r3, r4
   12dec:	4619      	mov	r1, r3
   12dee:	4803      	ldr	r0, [pc, #12]	; (12dfc <void Timer::ClearInterrupts<(TimerInterface::TimerPort)2>()+0x98>)
   12df0:	f000 faac 	bl	1334c <__cyg_profile_func_exit>
  }
   12df4:	bf00      	nop
   12df6:	b002      	add	sp, #8
   12df8:	bd10      	pop	{r4, pc}
   12dfa:	bf00      	nop
   12dfc:	00012d65 	.word	0x00012d65
   12e00:	10000078 	.word	0x10000078

00012e04 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()>:
  static void ClearInterrupts()
   12e04:	b510      	push	{r4, lr}
   12e06:	b082      	sub	sp, #8
   12e08:	4674      	mov	r4, lr
   12e0a:	4623      	mov	r3, r4
   12e0c:	4619      	mov	r1, r3
   12e0e:	4823      	ldr	r0, [pc, #140]	; (12e9c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   12e10:	f000 fa88 	bl	13324 <__cyg_profile_func_enter>
    uint8_t channel = util::Value(port);
   12e14:	2303      	movs	r3, #3
   12e16:	f88d 3007 	strb.w	r3, [sp, #7]
    tim_register[channel]->IR |= (1 << kRegMR0);
   12e1a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e1e:	4a20      	ldr	r2, [pc, #128]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e24:	681a      	ldr	r2, [r3, #0]
   12e26:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e2a:	491d      	ldr	r1, [pc, #116]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e2c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12e30:	f042 0201 	orr.w	r2, r2, #1
   12e34:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR1);
   12e36:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e3a:	4a19      	ldr	r2, [pc, #100]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e40:	681a      	ldr	r2, [r3, #0]
   12e42:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e46:	4916      	ldr	r1, [pc, #88]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e48:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12e4c:	f042 0202 	orr.w	r2, r2, #2
   12e50:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR2);
   12e52:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e56:	4a12      	ldr	r2, [pc, #72]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e5c:	681a      	ldr	r2, [r3, #0]
   12e5e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e62:	490f      	ldr	r1, [pc, #60]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e64:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12e68:	f042 0204 	orr.w	r2, r2, #4
   12e6c:	601a      	str	r2, [r3, #0]
    tim_register[channel]->IR |= (1 << kRegMR3);
   12e6e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e72:	4a0b      	ldr	r2, [pc, #44]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e78:	681a      	ldr	r2, [r3, #0]
   12e7a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12e7e:	4908      	ldr	r1, [pc, #32]	; (12ea0 <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x9c>)
   12e80:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   12e84:	f042 0208 	orr.w	r2, r2, #8
   12e88:	601a      	str	r2, [r3, #0]
   12e8a:	4623      	mov	r3, r4
   12e8c:	4619      	mov	r1, r3
   12e8e:	4803      	ldr	r0, [pc, #12]	; (12e9c <void Timer::ClearInterrupts<(TimerInterface::TimerPort)3>()+0x98>)
   12e90:	f000 fa5c 	bl	1334c <__cyg_profile_func_exit>
  }
   12e94:	bf00      	nop
   12e96:	b002      	add	sp, #8
   12e98:	bd10      	pop	{r4, pc}
   12e9a:	bf00      	nop
   12e9c:	00012e05 	.word	0x00012e05
   12ea0:	10000078 	.word	0x10000078

00012ea4 <__static_initialization_and_destruction_0(int, int)>:
#pragma GCC diagnostic pop
    // main() shouldn't return, but if it does, we'll just enter an infinite
    // loop
    Halt();
  }
}
   12ea4:	b082      	sub	sp, #8
   12ea6:	9001      	str	r0, [sp, #4]
   12ea8:	9100      	str	r1, [sp, #0]
   12eaa:	9b01      	ldr	r3, [sp, #4]
   12eac:	2b01      	cmp	r3, #1
   12eae:	d15d      	bne.n	12f6c <__static_initialization_and_destruction_0(int, int)+0xc8>
   12eb0:	9b00      	ldr	r3, [sp, #0]
   12eb2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   12eb6:	4293      	cmp	r3, r2
   12eb8:	d158      	bne.n	12f6c <__static_initialization_and_destruction_0(int, int)+0xc8>
  inline static volatile uint32_t * match[4][4] = {
   12eba:	4b2e      	ldr	r3, [pc, #184]	; (12f74 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   12ebc:	681b      	ldr	r3, [r3, #0]
   12ebe:	f003 0301 	and.w	r3, r3, #1
   12ec2:	2b00      	cmp	r3, #0
   12ec4:	d152      	bne.n	12f6c <__static_initialization_and_destruction_0(int, int)+0xc8>
   12ec6:	4b2b      	ldr	r3, [pc, #172]	; (12f74 <__static_initialization_and_destruction_0(int, int)+0xd0>)
   12ec8:	2201      	movs	r2, #1
   12eca:	601a      	str	r2, [r3, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   12ecc:	4b2a      	ldr	r3, [pc, #168]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12ece:	681b      	ldr	r3, [r3, #0]
   12ed0:	3318      	adds	r3, #24
  };
   12ed2:	4a2a      	ldr	r2, [pc, #168]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12ed4:	6013      	str	r3, [r2, #0]
    [kTimer0] = { &tim_register[0]->MR0, &tim_register[0]->MR1,
   12ed6:	4b28      	ldr	r3, [pc, #160]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12ed8:	681b      	ldr	r3, [r3, #0]
   12eda:	331c      	adds	r3, #28
  };
   12edc:	4a27      	ldr	r2, [pc, #156]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12ede:	6053      	str	r3, [r2, #4]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   12ee0:	4b25      	ldr	r3, [pc, #148]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12ee2:	681b      	ldr	r3, [r3, #0]
   12ee4:	3320      	adds	r3, #32
  };
   12ee6:	4a25      	ldr	r2, [pc, #148]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12ee8:	6093      	str	r3, [r2, #8]
                  &tim_register[0]->MR2, &tim_register[0]->MR3 },
   12eea:	4b23      	ldr	r3, [pc, #140]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12eec:	681b      	ldr	r3, [r3, #0]
   12eee:	3324      	adds	r3, #36	; 0x24
  };
   12ef0:	4a22      	ldr	r2, [pc, #136]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12ef2:	60d3      	str	r3, [r2, #12]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   12ef4:	4b20      	ldr	r3, [pc, #128]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12ef6:	685b      	ldr	r3, [r3, #4]
   12ef8:	3318      	adds	r3, #24
  };
   12efa:	4a20      	ldr	r2, [pc, #128]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12efc:	6113      	str	r3, [r2, #16]
    [kTimer1] = { &tim_register[1]->MR0, &tim_register[1]->MR1,
   12efe:	4b1e      	ldr	r3, [pc, #120]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f00:	685b      	ldr	r3, [r3, #4]
   12f02:	331c      	adds	r3, #28
  };
   12f04:	4a1d      	ldr	r2, [pc, #116]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f06:	6153      	str	r3, [r2, #20]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   12f08:	4b1b      	ldr	r3, [pc, #108]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f0a:	685b      	ldr	r3, [r3, #4]
   12f0c:	3320      	adds	r3, #32
  };
   12f0e:	4a1b      	ldr	r2, [pc, #108]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f10:	6193      	str	r3, [r2, #24]
                  &tim_register[1]->MR2, &tim_register[1]->MR3 },
   12f12:	4b19      	ldr	r3, [pc, #100]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f14:	685b      	ldr	r3, [r3, #4]
   12f16:	3324      	adds	r3, #36	; 0x24
  };
   12f18:	4a18      	ldr	r2, [pc, #96]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f1a:	61d3      	str	r3, [r2, #28]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   12f1c:	4b16      	ldr	r3, [pc, #88]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f1e:	689b      	ldr	r3, [r3, #8]
   12f20:	3318      	adds	r3, #24
  };
   12f22:	4a16      	ldr	r2, [pc, #88]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f24:	6213      	str	r3, [r2, #32]
    [kTimer2] = { &tim_register[2]->MR0, &tim_register[2]->MR1,
   12f26:	4b14      	ldr	r3, [pc, #80]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f28:	689b      	ldr	r3, [r3, #8]
   12f2a:	331c      	adds	r3, #28
  };
   12f2c:	4a13      	ldr	r2, [pc, #76]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f2e:	6253      	str	r3, [r2, #36]	; 0x24
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   12f30:	4b11      	ldr	r3, [pc, #68]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f32:	689b      	ldr	r3, [r3, #8]
   12f34:	3320      	adds	r3, #32
  };
   12f36:	4a11      	ldr	r2, [pc, #68]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f38:	6293      	str	r3, [r2, #40]	; 0x28
                  &tim_register[2]->MR2, &tim_register[2]->MR3 },
   12f3a:	4b0f      	ldr	r3, [pc, #60]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f3c:	689b      	ldr	r3, [r3, #8]
   12f3e:	3324      	adds	r3, #36	; 0x24
  };
   12f40:	4a0e      	ldr	r2, [pc, #56]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f42:	62d3      	str	r3, [r2, #44]	; 0x2c
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   12f44:	4b0c      	ldr	r3, [pc, #48]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f46:	68db      	ldr	r3, [r3, #12]
   12f48:	3318      	adds	r3, #24
  };
   12f4a:	4a0c      	ldr	r2, [pc, #48]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f4c:	6313      	str	r3, [r2, #48]	; 0x30
    [kTimer3] = { &tim_register[3]->MR0, &tim_register[3]->MR1,
   12f4e:	4b0a      	ldr	r3, [pc, #40]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f50:	68db      	ldr	r3, [r3, #12]
   12f52:	331c      	adds	r3, #28
  };
   12f54:	4a09      	ldr	r2, [pc, #36]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f56:	6353      	str	r3, [r2, #52]	; 0x34
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   12f58:	4b07      	ldr	r3, [pc, #28]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f5a:	68db      	ldr	r3, [r3, #12]
   12f5c:	3320      	adds	r3, #32
  };
   12f5e:	4a07      	ldr	r2, [pc, #28]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f60:	6393      	str	r3, [r2, #56]	; 0x38
                  &tim_register[3]->MR2, &tim_register[3]->MR3 }
   12f62:	4b05      	ldr	r3, [pc, #20]	; (12f78 <__static_initialization_and_destruction_0(int, int)+0xd4>)
   12f64:	68db      	ldr	r3, [r3, #12]
   12f66:	3324      	adds	r3, #36	; 0x24
  };
   12f68:	4a04      	ldr	r2, [pc, #16]	; (12f7c <__static_initialization_and_destruction_0(int, int)+0xd8>)
   12f6a:	63d3      	str	r3, [r2, #60]	; 0x3c
   12f6c:	bf00      	nop
   12f6e:	b002      	add	sp, #8
   12f70:	4770      	bx	lr
   12f72:	bf00      	nop
   12f74:	100005b8 	.word	0x100005b8
   12f78:	10000078 	.word	0x10000078
   12f7c:	100003c8 	.word	0x100003c8

00012f80 <_GLOBAL__sub_I_UptimeRTOS>:
   12f80:	b508      	push	{r3, lr}
   12f82:	f64f 71ff 	movw	r1, #65535	; 0xffff
   12f86:	2001      	movs	r0, #1
   12f88:	f7ff ff8c 	bl	12ea4 <__static_initialization_and_destruction_0(int, int)>
   12f8c:	bd08      	pop	{r3, pc}
   12f8e:	Address 0x0000000000012f8e is out of bounds.


00012f90 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   12f90:	b082      	sub	sp, #8
   12f92:	4603      	mov	r3, r0
   12f94:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   12f98:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   12f9c:	f003 021f 	and.w	r2, r3, #31
   12fa0:	4905      	ldr	r1, [pc, #20]	; (12fb8 <NVIC_EnableIRQ+0x28>)
   12fa2:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   12fa6:	095b      	lsrs	r3, r3, #5
   12fa8:	2001      	movs	r0, #1
   12faa:	fa00 f202 	lsl.w	r2, r0, r2
   12fae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12fb2:	bf00      	nop
   12fb4:	b002      	add	sp, #8
   12fb6:	4770      	bx	lr
   12fb8:	e000e100 	.word	0xe000e100

00012fbc <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   12fbc:	b082      	sub	sp, #8
   12fbe:	4603      	mov	r3, r0
   12fc0:	9100      	str	r1, [sp, #0]
   12fc2:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) < 0)
   12fc6:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   12fca:	2b00      	cmp	r3, #0
   12fcc:	da0c      	bge.n	12fe8 <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   12fce:	9b00      	ldr	r3, [sp, #0]
   12fd0:	b2da      	uxtb	r2, r3
   12fd2:	490d      	ldr	r1, [pc, #52]	; (13008 <NVIC_SetPriority+0x4c>)
   12fd4:	f99d 3007 	ldrsb.w	r3, [sp, #7]
   12fd8:	f003 030f 	and.w	r3, r3, #15
   12fdc:	3b04      	subs	r3, #4
   12fde:	0152      	lsls	r2, r2, #5
   12fe0:	b2d2      	uxtb	r2, r2
   12fe2:	440b      	add	r3, r1
   12fe4:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   12fe6:	e00b      	b.n	13000 <NVIC_SetPriority+0x44>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   12fe8:	9b00      	ldr	r3, [sp, #0]
   12fea:	b2db      	uxtb	r3, r3
   12fec:	4a07      	ldr	r2, [pc, #28]	; (1300c <NVIC_SetPriority+0x50>)
   12fee:	f99d 1007 	ldrsb.w	r1, [sp, #7]
   12ff2:	4608      	mov	r0, r1
   12ff4:	015b      	lsls	r3, r3, #5
   12ff6:	b2d9      	uxtb	r1, r3
   12ff8:	1813      	adds	r3, r2, r0
   12ffa:	460a      	mov	r2, r1
   12ffc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   13000:	bf00      	nop
   13002:	b002      	add	sp, #8
   13004:	4770      	bx	lr
   13006:	bf00      	nop
   13008:	e000ed00 	.word	0xe000ed00
   1300c:	e000e100 	.word	0xe000e100

00013010 <InterruptLookupHandler>:
{
   13010:	b500      	push	{lr}
   13012:	b085      	sub	sp, #20
  uint8_t active_isr = (SCB->ICSR & 0xFF);
   13014:	4b12      	ldr	r3, [pc, #72]	; (13060 <InterruptLookupHandler+0x50>)
   13016:	685b      	ldr	r3, [r3, #4]
   13018:	f88d 300f 	strb.w	r3, [sp, #15]
  IsrPointer isr     = dynamic_isr_vector_table[active_isr];
   1301c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   13020:	4a10      	ldr	r2, [pc, #64]	; (13064 <InterruptLookupHandler+0x54>)
   13022:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13026:	9302      	str	r3, [sp, #8]
  SJ2_ASSERT_FATAL(isr != InterruptLookupHandler,
   13028:	9b02      	ldr	r3, [sp, #8]
   1302a:	4a0f      	ldr	r2, [pc, #60]	; (13068 <InterruptLookupHandler+0x58>)
   1302c:	4293      	cmp	r3, r2
   1302e:	d110      	bne.n	13052 <InterruptLookupHandler+0x42>
   13030:	f89d 300f 	ldrb.w	r3, [sp, #15]
   13034:	9300      	str	r3, [sp, #0]
   13036:	23dd      	movs	r3, #221	; 0xdd
   13038:	4a0c      	ldr	r2, [pc, #48]	; (1306c <InterruptLookupHandler+0x5c>)
   1303a:	490d      	ldr	r1, [pc, #52]	; (13070 <InterruptLookupHandler+0x60>)
   1303c:	480d      	ldr	r0, [pc, #52]	; (13074 <InterruptLookupHandler+0x64>)
   1303e:	f002 ff0d 	bl	15e5c <printf>
   13042:	480d      	ldr	r0, [pc, #52]	; (13078 <InterruptLookupHandler+0x68>)
   13044:	f000 f93e 	bl	132c4 <puts>
   13048:	2100      	movs	r1, #0
   1304a:	2001      	movs	r0, #1
   1304c:	f7fd fed2 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   13050:	e7fe      	b.n	13050 <InterruptLookupHandler+0x40>
  isr();
   13052:	9b02      	ldr	r3, [sp, #8]
   13054:	4798      	blx	r3
}
   13056:	bf00      	nop
   13058:	b005      	add	sp, #20
   1305a:	f85d fb04 	ldr.w	pc, [sp], #4
   1305e:	bf00      	nop
   13060:	e000ed00 	.word	0xe000ed00
   13064:	10000104 	.word	0x10000104
   13068:	00013011 	.word	0x00013011
   1306c:	00019b28 	.word	0x00019b28
   13070:	00019b18 	.word	0x00019b18
   13074:	000199bc 	.word	0x000199bc
   13078:	00019a68 	.word	0x00019a68

0001307c <RegisterIsr(IRQn, void (*)(), bool, long)>:
{
   1307c:	b500      	push	{lr}
   1307e:	b085      	sub	sp, #20
   13080:	9102      	str	r1, [sp, #8]
   13082:	9301      	str	r3, [sp, #4]
   13084:	4603      	mov	r3, r0
   13086:	f88d 300f 	strb.w	r3, [sp, #15]
   1308a:	4613      	mov	r3, r2
   1308c:	f88d 300e 	strb.w	r3, [sp, #14]
  dynamic_isr_vector_table[irq + kIrqOffset] = isr;
   13090:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   13094:	3310      	adds	r3, #16
   13096:	490f      	ldr	r1, [pc, #60]	; (130d4 <RegisterIsr(IRQn, void (*)(), bool, long)+0x58>)
   13098:	9a02      	ldr	r2, [sp, #8]
   1309a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  if (enable_interrupt && irq >= 0)
   1309e:	f89d 300e 	ldrb.w	r3, [sp, #14]
   130a2:	2b00      	cmp	r3, #0
   130a4:	d008      	beq.n	130b8 <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
   130a6:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   130aa:	2b00      	cmp	r3, #0
   130ac:	db04      	blt.n	130b8 <RegisterIsr(IRQn, void (*)(), bool, long)+0x3c>
    NVIC_EnableIRQ(irq);
   130ae:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   130b2:	4618      	mov	r0, r3
   130b4:	f7ff ff6c 	bl	12f90 <NVIC_EnableIRQ>
  if (priority > -1)
   130b8:	9b01      	ldr	r3, [sp, #4]
   130ba:	2b00      	cmp	r3, #0
   130bc:	db06      	blt.n	130cc <RegisterIsr(IRQn, void (*)(), bool, long)+0x50>
    NVIC_SetPriority(irq, priority);
   130be:	9a01      	ldr	r2, [sp, #4]
   130c0:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   130c4:	4611      	mov	r1, r2
   130c6:	4618      	mov	r0, r3
   130c8:	f7ff ff78 	bl	12fbc <NVIC_SetPriority>
}
   130cc:	bf00      	nop
   130ce:	b005      	add	sp, #20
   130d0:	f85d fb04 	ldr.w	pc, [sp], #4
   130d4:	10000104 	.word	0x10000104

000130d8 <GetRegistersFromStack>:
{
   130d8:	b500      	push	{lr}
   130da:	b08d      	sub	sp, #52	; 0x34
   130dc:	9003      	str	r0, [sp, #12]
  volatile uint32_t r0  = fault_stack_address[0];
   130de:	9b03      	ldr	r3, [sp, #12]
   130e0:	681b      	ldr	r3, [r3, #0]
   130e2:	930b      	str	r3, [sp, #44]	; 0x2c
  volatile uint32_t r1  = fault_stack_address[1];
   130e4:	9b03      	ldr	r3, [sp, #12]
   130e6:	685b      	ldr	r3, [r3, #4]
   130e8:	930a      	str	r3, [sp, #40]	; 0x28
  volatile uint32_t r2  = fault_stack_address[2];
   130ea:	9b03      	ldr	r3, [sp, #12]
   130ec:	689b      	ldr	r3, [r3, #8]
   130ee:	9309      	str	r3, [sp, #36]	; 0x24
  volatile uint32_t r3  = fault_stack_address[3];
   130f0:	9b03      	ldr	r3, [sp, #12]
   130f2:	68db      	ldr	r3, [r3, #12]
   130f4:	9308      	str	r3, [sp, #32]
  volatile uint32_t r12 = fault_stack_address[4];
   130f6:	9b03      	ldr	r3, [sp, #12]
   130f8:	691b      	ldr	r3, [r3, #16]
   130fa:	9307      	str	r3, [sp, #28]
  volatile uint32_t lr = fault_stack_address[5];
   130fc:	9b03      	ldr	r3, [sp, #12]
   130fe:	695b      	ldr	r3, [r3, #20]
   13100:	9306      	str	r3, [sp, #24]
  volatile uint32_t pc = fault_stack_address[6];
   13102:	9b03      	ldr	r3, [sp, #12]
   13104:	699b      	ldr	r3, [r3, #24]
   13106:	9305      	str	r3, [sp, #20]
  volatile uint32_t psr = fault_stack_address[7];
   13108:	9b03      	ldr	r3, [sp, #12]
   1310a:	69db      	ldr	r3, [r3, #28]
   1310c:	9304      	str	r3, [sp, #16]
  printf(SJ2_BACKGROUND_RED "Hard Fault Exception Occurred!\n" SJ2_COLOR_RESET);
   1310e:	480d      	ldr	r0, [pc, #52]	; (13144 <GetRegistersFromStack+0x6c>)
   13110:	f002 fea4 	bl	15e5c <printf>
  printf("r0: 0x%08" PRIX32 ", r1: 0x%08" PRIX32
   13114:	990b      	ldr	r1, [sp, #44]	; 0x2c
   13116:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   13118:	9809      	ldr	r0, [sp, #36]	; 0x24
   1311a:	9b08      	ldr	r3, [sp, #32]
   1311c:	9300      	str	r3, [sp, #0]
   1311e:	4603      	mov	r3, r0
   13120:	4809      	ldr	r0, [pc, #36]	; (13148 <GetRegistersFromStack+0x70>)
   13122:	f002 fe9b 	bl	15e5c <printf>
  printf("r12: 0x%08" PRIX32 ", lr: 0x%08" PRIX32
   13126:	9907      	ldr	r1, [sp, #28]
   13128:	9a06      	ldr	r2, [sp, #24]
   1312a:	9805      	ldr	r0, [sp, #20]
   1312c:	9b04      	ldr	r3, [sp, #16]
   1312e:	9300      	str	r3, [sp, #0]
   13130:	4603      	mov	r3, r0
   13132:	4806      	ldr	r0, [pc, #24]	; (1314c <GetRegistersFromStack+0x74>)
   13134:	f002 fe92 	bl	15e5c <printf>
  debug::PrintBacktrace(true, reinterpret_cast<void *>(pc));
   13138:	9b05      	ldr	r3, [sp, #20]
   1313a:	4619      	mov	r1, r3
   1313c:	2001      	movs	r0, #1
   1313e:	f7fd fe59 	bl	10df4 <debug::PrintBacktrace(bool, void*)>
   13142:	e7fe      	b.n	13142 <GetRegistersFromStack+0x6a>
   13144:	00019a80 	.word	0x00019a80
   13148:	00019aac 	.word	0x00019aac
   1314c:	00019ae0 	.word	0x00019ae0

00013150 <FirmwareStdOut(int)>:
}
Stdout out = HostWrite;
Stdin in   = HostRead;
#else
int FirmwareStdOut(int data)
{
   13150:	b530      	push	{r4, r5, lr}
   13152:	b083      	sub	sp, #12
   13154:	4675      	mov	r5, lr
   13156:	9001      	str	r0, [sp, #4]
   13158:	462b      	mov	r3, r5
   1315a:	4619      	mov	r1, r3
   1315c:	4809      	ldr	r0, [pc, #36]	; (13184 <FirmwareStdOut(int)+0x34>)
   1315e:	f000 f8e1 	bl	13324 <__cyg_profile_func_enter>
  uart0.Send(static_cast<uint8_t>(data));
   13162:	9b01      	ldr	r3, [sp, #4]
   13164:	b2db      	uxtb	r3, r3
   13166:	4619      	mov	r1, r3
   13168:	4807      	ldr	r0, [pc, #28]	; (13188 <FirmwareStdOut(int)+0x38>)
   1316a:	f7fe ffef 	bl	1214c <Uart::Send(unsigned char)>
  return 1;
   1316e:	2401      	movs	r4, #1
   13170:	462b      	mov	r3, r5
   13172:	4619      	mov	r1, r3
   13174:	4803      	ldr	r0, [pc, #12]	; (13184 <FirmwareStdOut(int)+0x34>)
   13176:	f000 f8e9 	bl	1334c <__cyg_profile_func_exit>
   1317a:	4623      	mov	r3, r4
}
   1317c:	4618      	mov	r0, r3
   1317e:	b003      	add	sp, #12
   13180:	bd30      	pop	{r4, r5, pc}
   13182:	bf00      	nop
   13184:	00013151 	.word	0x00013151
   13188:	100000d8 	.word	0x100000d8

0001318c <_exit>:
  }
  // Dummy implementation of exit with return code placed into
  // Arm register r3
  // NOLINTNEXTLINE(readability-identifier-naming)
  void _exit([[maybe_unused]] int rc)
  {
   1318c:	b500      	push	{lr}
   1318e:	b083      	sub	sp, #12
   13190:	4673      	mov	r3, lr
   13192:	9001      	str	r0, [sp, #4]
   13194:	4619      	mov	r1, r3
   13196:	4802      	ldr	r0, [pc, #8]	; (131a0 <_exit+0x14>)
   13198:	f000 f8c4 	bl	13324 <__cyg_profile_func_enter>
    while (1)
    {
      continue;
   1319c:	bf00      	nop
    while (1)
   1319e:	e7fd      	b.n	1319c <_exit+0x10>
   131a0:	0001318d 	.word	0x0001318d

000131a4 <_getpid>:
    }
  }
  // Dummy implementation of getpid
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _getpid()
  {
   131a4:	b538      	push	{r3, r4, r5, lr}
   131a6:	4675      	mov	r5, lr
   131a8:	462b      	mov	r3, r5
   131aa:	4619      	mov	r1, r3
   131ac:	4805      	ldr	r0, [pc, #20]	; (131c4 <_getpid+0x20>)
   131ae:	f000 f8b9 	bl	13324 <__cyg_profile_func_enter>
    return 1;
   131b2:	2401      	movs	r4, #1
   131b4:	462b      	mov	r3, r5
   131b6:	4619      	mov	r1, r3
   131b8:	4802      	ldr	r0, [pc, #8]	; (131c4 <_getpid+0x20>)
   131ba:	f000 f8c7 	bl	1334c <__cyg_profile_func_exit>
   131be:	4623      	mov	r3, r4
  }
   131c0:	4618      	mov	r0, r3
   131c2:	bd38      	pop	{r3, r4, r5, pc}
   131c4:	000131a5 	.word	0x000131a5

000131c8 <_kill>:
  // Dummy implementation of kill
  // NOLINTNEXTLINE(readability-identifier-naming)
  int _kill(int, int)
  {
   131c8:	b530      	push	{r4, r5, lr}
   131ca:	b083      	sub	sp, #12
   131cc:	4675      	mov	r5, lr
   131ce:	9001      	str	r0, [sp, #4]
   131d0:	9100      	str	r1, [sp, #0]
   131d2:	462b      	mov	r3, r5
   131d4:	4619      	mov	r1, r3
   131d6:	4807      	ldr	r0, [pc, #28]	; (131f4 <_kill+0x2c>)
   131d8:	f000 f8a4 	bl	13324 <__cyg_profile_func_enter>
    return -1;
   131dc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   131e0:	462b      	mov	r3, r5
   131e2:	4619      	mov	r1, r3
   131e4:	4803      	ldr	r0, [pc, #12]	; (131f4 <_kill+0x2c>)
   131e6:	f000 f8b1 	bl	1334c <__cyg_profile_func_exit>
   131ea:	4623      	mov	r3, r4
  }
   131ec:	4618      	mov	r0, r3
   131ee:	b003      	add	sp, #12
   131f0:	bd30      	pop	{r4, r5, pc}
   131f2:	bf00      	nop
   131f4:	000131c9 	.word	0x000131c9

000131f8 <_sbrk>:
    return 0;
  }
  // Implementation of sbrk for allocating and deallocating space for malloc.
  // NOLINTNEXTLINE(readability-identifier-naming)
  void * _sbrk(int increment)
  {
   131f8:	b530      	push	{r4, r5, lr}
   131fa:	b085      	sub	sp, #20
   131fc:	4675      	mov	r5, lr
   131fe:	9001      	str	r0, [sp, #4]
   13200:	462b      	mov	r3, r5
   13202:	4619      	mov	r1, r3
   13204:	480f      	ldr	r0, [pc, #60]	; (13244 <_sbrk+0x4c>)
   13206:	f000 f88d 	bl	13324 <__cyg_profile_func_enter>
    void * previous_heap_position  = static_cast<void *>(heap_position);
   1320a:	4b0f      	ldr	r3, [pc, #60]	; (13248 <_sbrk+0x50>)
   1320c:	681b      	ldr	r3, [r3, #0]
   1320e:	9303      	str	r3, [sp, #12]
    // Check that by allocating this space, we do not exceed the heap area.
    if ((heap_position + increment) > &heap_end)
   13210:	4b0d      	ldr	r3, [pc, #52]	; (13248 <_sbrk+0x50>)
   13212:	681a      	ldr	r2, [r3, #0]
   13214:	9b01      	ldr	r3, [sp, #4]
   13216:	4413      	add	r3, r2
   13218:	4a0c      	ldr	r2, [pc, #48]	; (1324c <_sbrk+0x54>)
   1321a:	4293      	cmp	r3, r2
   1321c:	d901      	bls.n	13222 <_sbrk+0x2a>
    {
      previous_heap_position = nullptr;
   1321e:	2300      	movs	r3, #0
   13220:	9303      	str	r3, [sp, #12]
    }
    heap_position += increment;
   13222:	4b09      	ldr	r3, [pc, #36]	; (13248 <_sbrk+0x50>)
   13224:	681a      	ldr	r2, [r3, #0]
   13226:	9b01      	ldr	r3, [sp, #4]
   13228:	4413      	add	r3, r2
   1322a:	4a07      	ldr	r2, [pc, #28]	; (13248 <_sbrk+0x50>)
   1322c:	6013      	str	r3, [r2, #0]
    return previous_heap_position;
   1322e:	9c03      	ldr	r4, [sp, #12]
   13230:	462b      	mov	r3, r5
   13232:	4619      	mov	r1, r3
   13234:	4803      	ldr	r0, [pc, #12]	; (13244 <_sbrk+0x4c>)
   13236:	f000 f889 	bl	1334c <__cyg_profile_func_exit>
   1323a:	4623      	mov	r3, r4
  }
   1323c:	4618      	mov	r0, r3
   1323e:	b005      	add	sp, #20
   13240:	bd30      	pop	{r4, r5, pc}
   13242:	bf00      	nop
   13244:	000131f9 	.word	0x000131f9
   13248:	100001e8 	.word	0x100001e8
   1324c:	20008000 	.word	0x20008000

00013250 <_putchar>:
    }
    return length;
  }
  // Needed by third party printf library
  void _putchar(char character)  // NOLINT
  {
   13250:	b510      	push	{r4, lr}
   13252:	b082      	sub	sp, #8
   13254:	4674      	mov	r4, lr
   13256:	4603      	mov	r3, r0
   13258:	f88d 3007 	strb.w	r3, [sp, #7]
   1325c:	4623      	mov	r3, r4
   1325e:	4619      	mov	r1, r3
   13260:	4808      	ldr	r0, [pc, #32]	; (13284 <_putchar+0x34>)
   13262:	f000 f85f 	bl	13324 <__cyg_profile_func_enter>
    out(character);
   13266:	4b08      	ldr	r3, [pc, #32]	; (13288 <_putchar+0x38>)
   13268:	681b      	ldr	r3, [r3, #0]
   1326a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1326e:	4610      	mov	r0, r2
   13270:	4798      	blx	r3
   13272:	4623      	mov	r3, r4
   13274:	4619      	mov	r1, r3
   13276:	4803      	ldr	r0, [pc, #12]	; (13284 <_putchar+0x34>)
   13278:	f000 f868 	bl	1334c <__cyg_profile_func_exit>
  }
   1327c:	bf00      	nop
   1327e:	b002      	add	sp, #8
   13280:	bd10      	pop	{r4, pc}
   13282:	bf00      	nop
   13284:	00013251 	.word	0x00013251
   13288:	100001ec 	.word	0x100001ec

0001328c <putchar>:

  // Overload default libnano putchar() with a more optimal version that does
  // not use dynamic memory
  int putchar(int character)  // NOLINT
  {
   1328c:	b530      	push	{r4, r5, lr}
   1328e:	b083      	sub	sp, #12
   13290:	4674      	mov	r4, lr
   13292:	9001      	str	r0, [sp, #4]
   13294:	4623      	mov	r3, r4
   13296:	4619      	mov	r1, r3
   13298:	4808      	ldr	r0, [pc, #32]	; (132bc <putchar+0x30>)
   1329a:	f000 f843 	bl	13324 <__cyg_profile_func_enter>
    return out(character);
   1329e:	4b08      	ldr	r3, [pc, #32]	; (132c0 <putchar+0x34>)
   132a0:	681b      	ldr	r3, [r3, #0]
   132a2:	9801      	ldr	r0, [sp, #4]
   132a4:	4798      	blx	r3
   132a6:	4605      	mov	r5, r0
   132a8:	4623      	mov	r3, r4
   132aa:	4619      	mov	r1, r3
   132ac:	4803      	ldr	r0, [pc, #12]	; (132bc <putchar+0x30>)
   132ae:	f000 f84d 	bl	1334c <__cyg_profile_func_exit>
   132b2:	462b      	mov	r3, r5
  }
   132b4:	4618      	mov	r0, r3
   132b6:	b003      	add	sp, #12
   132b8:	bd30      	pop	{r4, r5, pc}
   132ba:	bf00      	nop
   132bc:	0001328d 	.word	0x0001328d
   132c0:	100001ec 	.word	0x100001ec

000132c4 <puts>:

  // Overload default libnano puts() with a more optimal version that does
  // not use dynamic memory
  int puts(const char * str)  // NOLINT
  {
   132c4:	b530      	push	{r4, r5, lr}
   132c6:	b085      	sub	sp, #20
   132c8:	4675      	mov	r5, lr
   132ca:	9001      	str	r0, [sp, #4]
   132cc:	462b      	mov	r3, r5
   132ce:	4619      	mov	r1, r3
   132d0:	4812      	ldr	r0, [pc, #72]	; (1331c <puts+0x58>)
   132d2:	f000 f827 	bl	13324 <__cyg_profile_func_enter>
    int i;
    for (i = 0; str[i] != '\0'; i++)
   132d6:	2300      	movs	r3, #0
   132d8:	9303      	str	r3, [sp, #12]
   132da:	9b03      	ldr	r3, [sp, #12]
   132dc:	9a01      	ldr	r2, [sp, #4]
   132de:	4413      	add	r3, r2
   132e0:	781b      	ldrb	r3, [r3, #0]
   132e2:	2b00      	cmp	r3, #0
   132e4:	d00b      	beq.n	132fe <puts+0x3a>
    {
      out(str[i]);
   132e6:	4b0e      	ldr	r3, [pc, #56]	; (13320 <puts+0x5c>)
   132e8:	681b      	ldr	r3, [r3, #0]
   132ea:	9a03      	ldr	r2, [sp, #12]
   132ec:	9901      	ldr	r1, [sp, #4]
   132ee:	440a      	add	r2, r1
   132f0:	7812      	ldrb	r2, [r2, #0]
   132f2:	4610      	mov	r0, r2
   132f4:	4798      	blx	r3
    for (i = 0; str[i] != '\0'; i++)
   132f6:	9b03      	ldr	r3, [sp, #12]
   132f8:	3301      	adds	r3, #1
   132fa:	9303      	str	r3, [sp, #12]
   132fc:	e7ed      	b.n	132da <puts+0x16>
    }
    out('\n');
   132fe:	4b08      	ldr	r3, [pc, #32]	; (13320 <puts+0x5c>)
   13300:	681b      	ldr	r3, [r3, #0]
   13302:	200a      	movs	r0, #10
   13304:	4798      	blx	r3
    return i;
   13306:	9c03      	ldr	r4, [sp, #12]
   13308:	462b      	mov	r3, r5
   1330a:	4619      	mov	r1, r3
   1330c:	4803      	ldr	r0, [pc, #12]	; (1331c <puts+0x58>)
   1330e:	f000 f81d 	bl	1334c <__cyg_profile_func_exit>
   13312:	4623      	mov	r3, r4
  }
   13314:	4618      	mov	r0, r3
   13316:	b005      	add	sp, #20
   13318:	bd30      	pop	{r4, r5, pc}
   1331a:	bf00      	nop
   1331c:	000132c5 	.word	0x000132c5
   13320:	100001ec 	.word	0x100001ec

00013324 <__cyg_profile_func_enter>:
  // =============================
  void * stack_trace[config::kBacktraceDepth] = { nullptr };
  size_t stack_depth = 0;

  void __cyg_profile_func_enter(void *, void * call_site)  // NOLINT
  {
   13324:	b082      	sub	sp, #8
   13326:	9001      	str	r0, [sp, #4]
   13328:	9100      	str	r1, [sp, #0]
    stack_trace[stack_depth++] = call_site;
   1332a:	9a00      	ldr	r2, [sp, #0]
   1332c:	4b05      	ldr	r3, [pc, #20]	; (13344 <__cyg_profile_func_enter+0x20>)
   1332e:	681b      	ldr	r3, [r3, #0]
   13330:	1c59      	adds	r1, r3, #1
   13332:	4804      	ldr	r0, [pc, #16]	; (13344 <__cyg_profile_func_enter+0x20>)
   13334:	6001      	str	r1, [r0, #0]
   13336:	4904      	ldr	r1, [pc, #16]	; (13348 <__cyg_profile_func_enter+0x24>)
   13338:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
   1333c:	bf00      	nop
   1333e:	b002      	add	sp, #8
   13340:	4770      	bx	lr
   13342:	bf00      	nop
   13344:	100006bc 	.word	0x100006bc
   13348:	100005bc 	.word	0x100005bc

0001334c <__cyg_profile_func_exit>:

  void __cyg_profile_func_exit(void *, void *)  // NOLINT
  {
   1334c:	b082      	sub	sp, #8
   1334e:	9001      	str	r0, [sp, #4]
   13350:	9100      	str	r1, [sp, #0]
    stack_depth--;
   13352:	4b04      	ldr	r3, [pc, #16]	; (13364 <__cyg_profile_func_exit+0x18>)
   13354:	681b      	ldr	r3, [r3, #0]
   13356:	3b01      	subs	r3, #1
   13358:	4a02      	ldr	r2, [pc, #8]	; (13364 <__cyg_profile_func_exit+0x18>)
   1335a:	6013      	str	r3, [r2, #0]
  }
   1335c:	bf00      	nop
   1335e:	b002      	add	sp, #8
   13360:	4770      	bx	lr
   13362:	bf00      	nop
   13364:	100006bc 	.word	0x100006bc

00013368 <GetStackTrace()>:
}

void ** GetStackTrace()
{
   13368:	b538      	push	{r3, r4, r5, lr}
   1336a:	4675      	mov	r5, lr
   1336c:	462b      	mov	r3, r5
   1336e:	4619      	mov	r1, r3
   13370:	4805      	ldr	r0, [pc, #20]	; (13388 <GetStackTrace()+0x20>)
   13372:	f7ff ffd7 	bl	13324 <__cyg_profile_func_enter>
  return stack_trace;
   13376:	4c05      	ldr	r4, [pc, #20]	; (1338c <GetStackTrace()+0x24>)
   13378:	462b      	mov	r3, r5
   1337a:	4619      	mov	r1, r3
   1337c:	4802      	ldr	r0, [pc, #8]	; (13388 <GetStackTrace()+0x20>)
   1337e:	f7ff ffe5 	bl	1334c <__cyg_profile_func_exit>
   13382:	4623      	mov	r3, r4
}
   13384:	4618      	mov	r0, r3
   13386:	bd38      	pop	{r3, r4, r5, pc}
   13388:	00013369 	.word	0x00013369
   1338c:	100005bc 	.word	0x100005bc

00013390 <GetStackDepth()>:

size_t GetStackDepth()
{
   13390:	b538      	push	{r3, r4, r5, lr}
   13392:	4675      	mov	r5, lr
   13394:	462b      	mov	r3, r5
   13396:	4619      	mov	r1, r3
   13398:	4806      	ldr	r0, [pc, #24]	; (133b4 <GetStackDepth()+0x24>)
   1339a:	f7ff ffc3 	bl	13324 <__cyg_profile_func_enter>
  return stack_depth;
   1339e:	4b06      	ldr	r3, [pc, #24]	; (133b8 <GetStackDepth()+0x28>)
   133a0:	681c      	ldr	r4, [r3, #0]
   133a2:	462b      	mov	r3, r5
   133a4:	4619      	mov	r1, r3
   133a6:	4803      	ldr	r0, [pc, #12]	; (133b4 <GetStackDepth()+0x24>)
   133a8:	f7ff ffd0 	bl	1334c <__cyg_profile_func_exit>
   133ac:	4623      	mov	r3, r4
}
   133ae:	4618      	mov	r0, r3
   133b0:	bd38      	pop	{r3, r4, r5, pc}
   133b2:	bf00      	nop
   133b4:	00013391 	.word	0x00013391
   133b8:	100006bc 	.word	0x100006bc

000133bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   133bc:	b082      	sub	sp, #8
   133be:	9001      	str	r0, [sp, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   133c0:	9b01      	ldr	r3, [sp, #4]
   133c2:	f103 0208 	add.w	r2, r3, #8
   133c6:	9b01      	ldr	r3, [sp, #4]
   133c8:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   133ca:	9b01      	ldr	r3, [sp, #4]
   133cc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   133d0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   133d2:	9b01      	ldr	r3, [sp, #4]
   133d4:	f103 0208 	add.w	r2, r3, #8
   133d8:	9b01      	ldr	r3, [sp, #4]
   133da:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   133dc:	9b01      	ldr	r3, [sp, #4]
   133de:	f103 0208 	add.w	r2, r3, #8
   133e2:	9b01      	ldr	r3, [sp, #4]
   133e4:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   133e6:	9b01      	ldr	r3, [sp, #4]
   133e8:	2200      	movs	r2, #0
   133ea:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   133ec:	bf00      	nop
   133ee:	b002      	add	sp, #8
   133f0:	4770      	bx	lr

000133f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   133f2:	b082      	sub	sp, #8
   133f4:	9001      	str	r0, [sp, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   133f6:	9b01      	ldr	r3, [sp, #4]
   133f8:	2200      	movs	r2, #0
   133fa:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   133fc:	bf00      	nop
   133fe:	b002      	add	sp, #8
   13400:	4770      	bx	lr

00013402 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   13402:	b084      	sub	sp, #16
   13404:	9001      	str	r0, [sp, #4]
   13406:	9100      	str	r1, [sp, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   13408:	9b01      	ldr	r3, [sp, #4]
   1340a:	685b      	ldr	r3, [r3, #4]
   1340c:	9303      	str	r3, [sp, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   1340e:	9b00      	ldr	r3, [sp, #0]
   13410:	9a03      	ldr	r2, [sp, #12]
   13412:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   13414:	9b03      	ldr	r3, [sp, #12]
   13416:	689a      	ldr	r2, [r3, #8]
   13418:	9b00      	ldr	r3, [sp, #0]
   1341a:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   1341c:	9b03      	ldr	r3, [sp, #12]
   1341e:	689b      	ldr	r3, [r3, #8]
   13420:	9a00      	ldr	r2, [sp, #0]
   13422:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   13424:	9b03      	ldr	r3, [sp, #12]
   13426:	9a00      	ldr	r2, [sp, #0]
   13428:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   1342a:	9b00      	ldr	r3, [sp, #0]
   1342c:	9a01      	ldr	r2, [sp, #4]
   1342e:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   13430:	9b01      	ldr	r3, [sp, #4]
   13432:	681b      	ldr	r3, [r3, #0]
   13434:	1c5a      	adds	r2, r3, #1
   13436:	9b01      	ldr	r3, [sp, #4]
   13438:	601a      	str	r2, [r3, #0]
}
   1343a:	bf00      	nop
   1343c:	b004      	add	sp, #16
   1343e:	4770      	bx	lr

00013440 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   13440:	b084      	sub	sp, #16
   13442:	9001      	str	r0, [sp, #4]
   13444:	9100      	str	r1, [sp, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   13446:	9b00      	ldr	r3, [sp, #0]
   13448:	681b      	ldr	r3, [r3, #0]
   1344a:	9302      	str	r3, [sp, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   1344c:	9b02      	ldr	r3, [sp, #8]
   1344e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   13452:	d103      	bne.n	1345c <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   13454:	9b01      	ldr	r3, [sp, #4]
   13456:	691b      	ldr	r3, [r3, #16]
   13458:	9303      	str	r3, [sp, #12]
   1345a:	e00c      	b.n	13476 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   1345c:	9b01      	ldr	r3, [sp, #4]
   1345e:	3308      	adds	r3, #8
   13460:	9303      	str	r3, [sp, #12]
   13462:	e002      	b.n	1346a <vListInsert+0x2a>
   13464:	9b03      	ldr	r3, [sp, #12]
   13466:	685b      	ldr	r3, [r3, #4]
   13468:	9303      	str	r3, [sp, #12]
   1346a:	9b03      	ldr	r3, [sp, #12]
   1346c:	685b      	ldr	r3, [r3, #4]
   1346e:	681b      	ldr	r3, [r3, #0]
   13470:	9a02      	ldr	r2, [sp, #8]
   13472:	429a      	cmp	r2, r3
   13474:	d2f6      	bcs.n	13464 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   13476:	9b03      	ldr	r3, [sp, #12]
   13478:	685a      	ldr	r2, [r3, #4]
   1347a:	9b00      	ldr	r3, [sp, #0]
   1347c:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   1347e:	9b00      	ldr	r3, [sp, #0]
   13480:	685b      	ldr	r3, [r3, #4]
   13482:	9a00      	ldr	r2, [sp, #0]
   13484:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   13486:	9b00      	ldr	r3, [sp, #0]
   13488:	9a03      	ldr	r2, [sp, #12]
   1348a:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   1348c:	9b03      	ldr	r3, [sp, #12]
   1348e:	9a00      	ldr	r2, [sp, #0]
   13490:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   13492:	9b00      	ldr	r3, [sp, #0]
   13494:	9a01      	ldr	r2, [sp, #4]
   13496:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   13498:	9b01      	ldr	r3, [sp, #4]
   1349a:	681b      	ldr	r3, [r3, #0]
   1349c:	1c5a      	adds	r2, r3, #1
   1349e:	9b01      	ldr	r3, [sp, #4]
   134a0:	601a      	str	r2, [r3, #0]
}
   134a2:	bf00      	nop
   134a4:	b004      	add	sp, #16
   134a6:	4770      	bx	lr

000134a8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   134a8:	b084      	sub	sp, #16
   134aa:	9001      	str	r0, [sp, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   134ac:	9b01      	ldr	r3, [sp, #4]
   134ae:	691b      	ldr	r3, [r3, #16]
   134b0:	9303      	str	r3, [sp, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   134b2:	9b01      	ldr	r3, [sp, #4]
   134b4:	685b      	ldr	r3, [r3, #4]
   134b6:	9a01      	ldr	r2, [sp, #4]
   134b8:	6892      	ldr	r2, [r2, #8]
   134ba:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   134bc:	9b01      	ldr	r3, [sp, #4]
   134be:	689b      	ldr	r3, [r3, #8]
   134c0:	9a01      	ldr	r2, [sp, #4]
   134c2:	6852      	ldr	r2, [r2, #4]
   134c4:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   134c6:	9b03      	ldr	r3, [sp, #12]
   134c8:	685b      	ldr	r3, [r3, #4]
   134ca:	9a01      	ldr	r2, [sp, #4]
   134cc:	429a      	cmp	r2, r3
   134ce:	d103      	bne.n	134d8 <uxListRemove+0x30>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   134d0:	9b01      	ldr	r3, [sp, #4]
   134d2:	689a      	ldr	r2, [r3, #8]
   134d4:	9b03      	ldr	r3, [sp, #12]
   134d6:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   134d8:	9b01      	ldr	r3, [sp, #4]
   134da:	2200      	movs	r2, #0
   134dc:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   134de:	9b03      	ldr	r3, [sp, #12]
   134e0:	681b      	ldr	r3, [r3, #0]
   134e2:	1e5a      	subs	r2, r3, #1
   134e4:	9b03      	ldr	r3, [sp, #12]
   134e6:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   134e8:	9b03      	ldr	r3, [sp, #12]
   134ea:	681b      	ldr	r3, [r3, #0]
}
   134ec:	4618      	mov	r0, r3
   134ee:	b004      	add	sp, #16
   134f0:	4770      	bx	lr

000134f2 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
   134f2:	b500      	push	{lr}
   134f4:	b08b      	sub	sp, #44	; 0x2c
   134f6:	9007      	str	r0, [sp, #28]
   134f8:	9106      	str	r1, [sp, #24]
   134fa:	9205      	str	r2, [sp, #20]
   134fc:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
   134fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   13500:	2b00      	cmp	r3, #0
   13502:	d01d      	beq.n	13540 <xTaskCreateStatic+0x4e>
   13504:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   13506:	2b00      	cmp	r3, #0
   13508:	d01a      	beq.n	13540 <xTaskCreateStatic+0x4e>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
   1350a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1350c:	9309      	str	r3, [sp, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
   1350e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13510:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   13512:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
   13514:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13516:	2202      	movs	r2, #2
   13518:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
   1351c:	2300      	movs	r3, #0
   1351e:	9303      	str	r3, [sp, #12]
   13520:	9b09      	ldr	r3, [sp, #36]	; 0x24
   13522:	9302      	str	r3, [sp, #8]
   13524:	ab08      	add	r3, sp, #32
   13526:	9301      	str	r3, [sp, #4]
   13528:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1352a:	9300      	str	r3, [sp, #0]
   1352c:	9b04      	ldr	r3, [sp, #16]
   1352e:	9a05      	ldr	r2, [sp, #20]
   13530:	9906      	ldr	r1, [sp, #24]
   13532:	9807      	ldr	r0, [sp, #28]
   13534:	f000 f852 	bl	135dc <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   13538:	9809      	ldr	r0, [sp, #36]	; 0x24
   1353a:	f000 f8c9 	bl	136d0 <prvAddNewTaskToReadyList>
   1353e:	e001      	b.n	13544 <xTaskCreateStatic+0x52>
		}
		else
		{
			xReturn = NULL;
   13540:	2300      	movs	r3, #0
   13542:	9308      	str	r3, [sp, #32]
		}

		return xReturn;
   13544:	9b08      	ldr	r3, [sp, #32]
	}
   13546:	4618      	mov	r0, r3
   13548:	b00b      	add	sp, #44	; 0x2c
   1354a:	f85d fb04 	ldr.w	pc, [sp], #4

0001354e <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   1354e:	b500      	push	{lr}
   13550:	b08d      	sub	sp, #52	; 0x34
   13552:	9007      	str	r0, [sp, #28]
   13554:	9106      	str	r1, [sp, #24]
   13556:	9304      	str	r3, [sp, #16]
   13558:	4613      	mov	r3, r2
   1355a:	f8ad 3016 	strh.w	r3, [sp, #22]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1355e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   13562:	009b      	lsls	r3, r3, #2
   13564:	4618      	mov	r0, r3
   13566:	f001 faf9 	bl	14b5c <pvPortMalloc>
   1356a:	9009      	str	r0, [sp, #36]	; 0x24

			if( pxStack != NULL )
   1356c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1356e:	2b00      	cmp	r3, #0
   13570:	d00e      	beq.n	13590 <xTaskCreate+0x42>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   13572:	2060      	movs	r0, #96	; 0x60
   13574:	f001 faf2 	bl	14b5c <pvPortMalloc>
   13578:	900b      	str	r0, [sp, #44]	; 0x2c

				if( pxNewTCB != NULL )
   1357a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1357c:	2b00      	cmp	r3, #0
   1357e:	d003      	beq.n	13588 <xTaskCreate+0x3a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   13580:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   13582:	9a09      	ldr	r2, [sp, #36]	; 0x24
   13584:	631a      	str	r2, [r3, #48]	; 0x30
   13586:	e005      	b.n	13594 <xTaskCreate+0x46>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   13588:	9809      	ldr	r0, [sp, #36]	; 0x24
   1358a:	f001 faf8 	bl	14b7e <vPortFree>
   1358e:	e001      	b.n	13594 <xTaskCreate+0x46>
				}
			}
			else
			{
				pxNewTCB = NULL;
   13590:	2300      	movs	r3, #0
   13592:	930b      	str	r3, [sp, #44]	; 0x2c
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   13594:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   13596:	2b00      	cmp	r3, #0
   13598:	d018      	beq.n	135cc <xTaskCreate+0x7e>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
   1359a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1359c:	2200      	movs	r2, #0
   1359e:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   135a2:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   135a6:	2300      	movs	r3, #0
   135a8:	9303      	str	r3, [sp, #12]
   135aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   135ac:	9302      	str	r3, [sp, #8]
   135ae:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   135b0:	9301      	str	r3, [sp, #4]
   135b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   135b4:	9300      	str	r3, [sp, #0]
   135b6:	9b04      	ldr	r3, [sp, #16]
   135b8:	9906      	ldr	r1, [sp, #24]
   135ba:	9807      	ldr	r0, [sp, #28]
   135bc:	f000 f80e 	bl	135dc <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   135c0:	980b      	ldr	r0, [sp, #44]	; 0x2c
   135c2:	f000 f885 	bl	136d0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   135c6:	2301      	movs	r3, #1
   135c8:	930a      	str	r3, [sp, #40]	; 0x28
   135ca:	e002      	b.n	135d2 <xTaskCreate+0x84>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   135cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   135d0:	930a      	str	r3, [sp, #40]	; 0x28
		}

		return xReturn;
   135d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	}
   135d4:	4618      	mov	r0, r3
   135d6:	b00d      	add	sp, #52	; 0x34
   135d8:	f85d fb04 	ldr.w	pc, [sp], #4

000135dc <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   135dc:	b500      	push	{lr}
   135de:	b087      	sub	sp, #28
   135e0:	9003      	str	r0, [sp, #12]
   135e2:	9102      	str	r1, [sp, #8]
   135e4:	9201      	str	r2, [sp, #4]
   135e6:	9300      	str	r3, [sp, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   135e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   135ea:	6b18      	ldr	r0, [r3, #48]	; 0x30
   135ec:	9b01      	ldr	r3, [sp, #4]
   135ee:	009b      	lsls	r3, r3, #2
   135f0:	461a      	mov	r2, r3
   135f2:	21a5      	movs	r1, #165	; 0xa5
   135f4:	f005 fac9 	bl	18b8a <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   135f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   135fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   135fc:	9b01      	ldr	r3, [sp, #4]
   135fe:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   13602:	3b01      	subs	r3, #1
   13604:	009b      	lsls	r3, r3, #2
   13606:	4413      	add	r3, r2
   13608:	9304      	str	r3, [sp, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   1360a:	9b04      	ldr	r3, [sp, #16]
   1360c:	f023 0307 	bic.w	r3, r3, #7
   13610:	9304      	str	r3, [sp, #16]
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   13612:	2300      	movs	r3, #0
   13614:	9305      	str	r3, [sp, #20]
   13616:	e012      	b.n	1363e <prvInitialiseNewTask+0x62>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   13618:	9a02      	ldr	r2, [sp, #8]
   1361a:	9b05      	ldr	r3, [sp, #20]
   1361c:	4413      	add	r3, r2
   1361e:	7819      	ldrb	r1, [r3, #0]
   13620:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   13622:	9b05      	ldr	r3, [sp, #20]
   13624:	4413      	add	r3, r2
   13626:	3334      	adds	r3, #52	; 0x34
   13628:	460a      	mov	r2, r1
   1362a:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   1362c:	9a02      	ldr	r2, [sp, #8]
   1362e:	9b05      	ldr	r3, [sp, #20]
   13630:	4413      	add	r3, r2
   13632:	781b      	ldrb	r3, [r3, #0]
   13634:	2b00      	cmp	r3, #0
   13636:	d006      	beq.n	13646 <prvInitialiseNewTask+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   13638:	9b05      	ldr	r3, [sp, #20]
   1363a:	3301      	adds	r3, #1
   1363c:	9305      	str	r3, [sp, #20]
   1363e:	9b05      	ldr	r3, [sp, #20]
   13640:	2b0f      	cmp	r3, #15
   13642:	d9e9      	bls.n	13618 <prvInitialiseNewTask+0x3c>
   13644:	e000      	b.n	13648 <prvInitialiseNewTask+0x6c>
		{
			break;
   13646:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   13648:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1364a:	2200      	movs	r2, #0
   1364c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   13650:	9b08      	ldr	r3, [sp, #32]
   13652:	2b04      	cmp	r3, #4
   13654:	d901      	bls.n	1365a <prvInitialiseNewTask+0x7e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   13656:	2304      	movs	r3, #4
   13658:	9308      	str	r3, [sp, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   1365a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1365c:	9a08      	ldr	r2, [sp, #32]
   1365e:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
   13660:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13662:	9a08      	ldr	r2, [sp, #32]
   13664:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
   13666:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13668:	2200      	movs	r2, #0
   1366a:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   1366c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1366e:	3304      	adds	r3, #4
   13670:	4618      	mov	r0, r3
   13672:	f7ff febe 	bl	133f2 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   13676:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13678:	3318      	adds	r3, #24
   1367a:	4618      	mov	r0, r3
   1367c:	f7ff feb9 	bl	133f2 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   13680:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13682:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   13684:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   13686:	9b08      	ldr	r3, [sp, #32]
   13688:	f1c3 0205 	rsb	r2, r3, #5
   1368c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1368e:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   13690:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13692:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   13694:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
   13696:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13698:	2200      	movs	r2, #0
   1369a:	655a      	str	r2, [r3, #84]	; 0x54
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   1369c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1369e:	2200      	movs	r2, #0
   136a0:	659a      	str	r2, [r3, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   136a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   136a4:	2200      	movs	r2, #0
   136a6:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   136aa:	9a00      	ldr	r2, [sp, #0]
   136ac:	9903      	ldr	r1, [sp, #12]
   136ae:	9804      	ldr	r0, [sp, #16]
   136b0:	f001 f932 	bl	14918 <pxPortInitialiseStack>
   136b4:	4602      	mov	r2, r0
   136b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   136b8:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
   136ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
   136bc:	2b00      	cmp	r3, #0
   136be:	d002      	beq.n	136c6 <prvInitialiseNewTask+0xea>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   136c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   136c2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   136c4:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   136c6:	bf00      	nop
   136c8:	b007      	add	sp, #28
   136ca:	f85d fb04 	ldr.w	pc, [sp], #4
   136ce:	Address 0x00000000000136ce is out of bounds.


000136d0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   136d0:	b500      	push	{lr}
   136d2:	b083      	sub	sp, #12
   136d4:	9001      	str	r0, [sp, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   136d6:	f001 f9b5 	bl	14a44 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   136da:	4b2d      	ldr	r3, [pc, #180]	; (13790 <prvAddNewTaskToReadyList+0xc0>)
   136dc:	681b      	ldr	r3, [r3, #0]
   136de:	3301      	adds	r3, #1
   136e0:	4a2b      	ldr	r2, [pc, #172]	; (13790 <prvAddNewTaskToReadyList+0xc0>)
   136e2:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   136e4:	4b2b      	ldr	r3, [pc, #172]	; (13794 <prvAddNewTaskToReadyList+0xc4>)
   136e6:	681b      	ldr	r3, [r3, #0]
   136e8:	2b00      	cmp	r3, #0
   136ea:	d109      	bne.n	13700 <prvAddNewTaskToReadyList+0x30>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   136ec:	4a29      	ldr	r2, [pc, #164]	; (13794 <prvAddNewTaskToReadyList+0xc4>)
   136ee:	9b01      	ldr	r3, [sp, #4]
   136f0:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   136f2:	4b27      	ldr	r3, [pc, #156]	; (13790 <prvAddNewTaskToReadyList+0xc0>)
   136f4:	681b      	ldr	r3, [r3, #0]
   136f6:	2b01      	cmp	r3, #1
   136f8:	d110      	bne.n	1371c <prvAddNewTaskToReadyList+0x4c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   136fa:	f000 fb1b 	bl	13d34 <prvInitialiseTaskLists>
   136fe:	e00d      	b.n	1371c <prvAddNewTaskToReadyList+0x4c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   13700:	4b25      	ldr	r3, [pc, #148]	; (13798 <prvAddNewTaskToReadyList+0xc8>)
   13702:	681b      	ldr	r3, [r3, #0]
   13704:	2b00      	cmp	r3, #0
   13706:	d109      	bne.n	1371c <prvAddNewTaskToReadyList+0x4c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   13708:	4b22      	ldr	r3, [pc, #136]	; (13794 <prvAddNewTaskToReadyList+0xc4>)
   1370a:	681b      	ldr	r3, [r3, #0]
   1370c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1370e:	9b01      	ldr	r3, [sp, #4]
   13710:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13712:	429a      	cmp	r2, r3
   13714:	d802      	bhi.n	1371c <prvAddNewTaskToReadyList+0x4c>
				{
					pxCurrentTCB = pxNewTCB;
   13716:	4a1f      	ldr	r2, [pc, #124]	; (13794 <prvAddNewTaskToReadyList+0xc4>)
   13718:	9b01      	ldr	r3, [sp, #4]
   1371a:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   1371c:	4b1f      	ldr	r3, [pc, #124]	; (1379c <prvAddNewTaskToReadyList+0xcc>)
   1371e:	681b      	ldr	r3, [r3, #0]
   13720:	3301      	adds	r3, #1
   13722:	4a1e      	ldr	r2, [pc, #120]	; (1379c <prvAddNewTaskToReadyList+0xcc>)
   13724:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   13726:	4b1d      	ldr	r3, [pc, #116]	; (1379c <prvAddNewTaskToReadyList+0xcc>)
   13728:	681a      	ldr	r2, [r3, #0]
   1372a:	9b01      	ldr	r3, [sp, #4]
   1372c:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   1372e:	9b01      	ldr	r3, [sp, #4]
   13730:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13732:	2201      	movs	r2, #1
   13734:	409a      	lsls	r2, r3
   13736:	4b1a      	ldr	r3, [pc, #104]	; (137a0 <prvAddNewTaskToReadyList+0xd0>)
   13738:	681b      	ldr	r3, [r3, #0]
   1373a:	4313      	orrs	r3, r2
   1373c:	4a18      	ldr	r2, [pc, #96]	; (137a0 <prvAddNewTaskToReadyList+0xd0>)
   1373e:	6013      	str	r3, [r2, #0]
   13740:	9b01      	ldr	r3, [sp, #4]
   13742:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13744:	4613      	mov	r3, r2
   13746:	009b      	lsls	r3, r3, #2
   13748:	4413      	add	r3, r2
   1374a:	009b      	lsls	r3, r3, #2
   1374c:	4a15      	ldr	r2, [pc, #84]	; (137a4 <prvAddNewTaskToReadyList+0xd4>)
   1374e:	441a      	add	r2, r3
   13750:	9b01      	ldr	r3, [sp, #4]
   13752:	3304      	adds	r3, #4
   13754:	4619      	mov	r1, r3
   13756:	4610      	mov	r0, r2
   13758:	f7ff fe53 	bl	13402 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   1375c:	f001 f986 	bl	14a6c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   13760:	4b0d      	ldr	r3, [pc, #52]	; (13798 <prvAddNewTaskToReadyList+0xc8>)
   13762:	681b      	ldr	r3, [r3, #0]
   13764:	2b00      	cmp	r3, #0
   13766:	d00e      	beq.n	13786 <prvAddNewTaskToReadyList+0xb6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   13768:	4b0a      	ldr	r3, [pc, #40]	; (13794 <prvAddNewTaskToReadyList+0xc4>)
   1376a:	681b      	ldr	r3, [r3, #0]
   1376c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1376e:	9b01      	ldr	r3, [sp, #4]
   13770:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13772:	429a      	cmp	r2, r3
   13774:	d207      	bcs.n	13786 <prvAddNewTaskToReadyList+0xb6>
		{
			taskYIELD_IF_USING_PREEMPTION();
   13776:	4b0c      	ldr	r3, [pc, #48]	; (137a8 <prvAddNewTaskToReadyList+0xd8>)
   13778:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1377c:	601a      	str	r2, [r3, #0]
   1377e:	f3bf 8f4f 	dsb	sy
   13782:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   13786:	bf00      	nop
   13788:	b003      	add	sp, #12
   1378a:	f85d fb04 	ldr.w	pc, [sp], #4
   1378e:	bf00      	nop
   13790:	10000798 	.word	0x10000798
   13794:	100006c0 	.word	0x100006c0
   13798:	100007a4 	.word	0x100007a4
   1379c:	100007b4 	.word	0x100007b4
   137a0:	100007a0 	.word	0x100007a0
   137a4:	100006c4 	.word	0x100006c4
   137a8:	e000ed04 	.word	0xe000ed04

000137ac <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   137ac:	b500      	push	{lr}
   137ae:	b08b      	sub	sp, #44	; 0x2c
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   137b0:	2300      	movs	r3, #0
   137b2:	9307      	str	r3, [sp, #28]
		StackType_t *pxIdleTaskStackBuffer = NULL;
   137b4:	2300      	movs	r3, #0
   137b6:	9306      	str	r3, [sp, #24]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   137b8:	aa05      	add	r2, sp, #20
   137ba:	a906      	add	r1, sp, #24
   137bc:	ab07      	add	r3, sp, #28
   137be:	4618      	mov	r0, r3
   137c0:	f7ff f85c 	bl	1287c <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   137c4:	9905      	ldr	r1, [sp, #20]
   137c6:	9b06      	ldr	r3, [sp, #24]
   137c8:	9a07      	ldr	r2, [sp, #28]
   137ca:	9202      	str	r2, [sp, #8]
   137cc:	9301      	str	r3, [sp, #4]
   137ce:	2300      	movs	r3, #0
   137d0:	9300      	str	r3, [sp, #0]
   137d2:	2300      	movs	r3, #0
   137d4:	460a      	mov	r2, r1
   137d6:	4916      	ldr	r1, [pc, #88]	; (13830 <vTaskStartScheduler+0x84>)
   137d8:	4816      	ldr	r0, [pc, #88]	; (13834 <vTaskStartScheduler+0x88>)
   137da:	f7ff fe8a 	bl	134f2 <xTaskCreateStatic>
   137de:	4602      	mov	r2, r0
   137e0:	4b15      	ldr	r3, [pc, #84]	; (13838 <vTaskStartScheduler+0x8c>)
   137e2:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
   137e4:	4b14      	ldr	r3, [pc, #80]	; (13838 <vTaskStartScheduler+0x8c>)
   137e6:	681b      	ldr	r3, [r3, #0]
   137e8:	2b00      	cmp	r3, #0
   137ea:	d002      	beq.n	137f2 <vTaskStartScheduler+0x46>
		{
			xReturn = pdPASS;
   137ec:	2301      	movs	r3, #1
   137ee:	9309      	str	r3, [sp, #36]	; 0x24
   137f0:	e001      	b.n	137f6 <vTaskStartScheduler+0x4a>
		}
		else
		{
			xReturn = pdFAIL;
   137f2:	2300      	movs	r3, #0
   137f4:	9309      	str	r3, [sp, #36]	; 0x24
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   137f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   137f8:	2b01      	cmp	r3, #1
   137fa:	d114      	bne.n	13826 <vTaskStartScheduler+0x7a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   137fc:	f04f 0328 	mov.w	r3, #40	; 0x28
   13800:	f383 8811 	msr	BASEPRI, r3
   13804:	f3bf 8f6f 	isb	sy
   13808:	f3bf 8f4f 	dsb	sy
   1380c:	9308      	str	r3, [sp, #32]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   1380e:	4b0b      	ldr	r3, [pc, #44]	; (1383c <vTaskStartScheduler+0x90>)
   13810:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13814:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   13816:	4b0a      	ldr	r3, [pc, #40]	; (13840 <vTaskStartScheduler+0x94>)
   13818:	2201      	movs	r2, #1
   1381a:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   1381c:	4b09      	ldr	r3, [pc, #36]	; (13844 <vTaskStartScheduler+0x98>)
   1381e:	2200      	movs	r2, #0
   13820:	601a      	str	r2, [r3, #0]
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   13822:	f001 f8e5 	bl	149f0 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   13826:	bf00      	nop
   13828:	b00b      	add	sp, #44	; 0x2c
   1382a:	f85d fb04 	ldr.w	pc, [sp], #4
   1382e:	bf00      	nop
   13830:	00019b48 	.word	0x00019b48
   13834:	00013d29 	.word	0x00013d29
   13838:	100007bc 	.word	0x100007bc
   1383c:	100007b8 	.word	0x100007b8
   13840:	100007a4 	.word	0x100007a4
   13844:	1000079c 	.word	0x1000079c

00013848 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   13848:	4b03      	ldr	r3, [pc, #12]	; (13858 <vTaskSuspendAll+0x10>)
   1384a:	681b      	ldr	r3, [r3, #0]
   1384c:	3301      	adds	r3, #1
   1384e:	4a02      	ldr	r2, [pc, #8]	; (13858 <vTaskSuspendAll+0x10>)
   13850:	6013      	str	r3, [r2, #0]
}
   13852:	bf00      	nop
   13854:	4770      	bx	lr
   13856:	bf00      	nop
   13858:	100007c0 	.word	0x100007c0

0001385c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   1385c:	b500      	push	{lr}
   1385e:	b085      	sub	sp, #20
TCB_t *pxTCB = NULL;
   13860:	2300      	movs	r3, #0
   13862:	9303      	str	r3, [sp, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   13864:	2300      	movs	r3, #0
   13866:	9302      	str	r3, [sp, #8]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   13868:	f001 f8ec 	bl	14a44 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   1386c:	4b38      	ldr	r3, [pc, #224]	; (13950 <xTaskResumeAll+0xf4>)
   1386e:	681b      	ldr	r3, [r3, #0]
   13870:	3b01      	subs	r3, #1
   13872:	4a37      	ldr	r2, [pc, #220]	; (13950 <xTaskResumeAll+0xf4>)
   13874:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13876:	4b36      	ldr	r3, [pc, #216]	; (13950 <xTaskResumeAll+0xf4>)
   13878:	681b      	ldr	r3, [r3, #0]
   1387a:	2b00      	cmp	r3, #0
   1387c:	d161      	bne.n	13942 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   1387e:	4b35      	ldr	r3, [pc, #212]	; (13954 <xTaskResumeAll+0xf8>)
   13880:	681b      	ldr	r3, [r3, #0]
   13882:	2b00      	cmp	r3, #0
   13884:	d05d      	beq.n	13942 <xTaskResumeAll+0xe6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   13886:	e02e      	b.n	138e6 <xTaskResumeAll+0x8a>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   13888:	4b33      	ldr	r3, [pc, #204]	; (13958 <xTaskResumeAll+0xfc>)
   1388a:	68db      	ldr	r3, [r3, #12]
   1388c:	68db      	ldr	r3, [r3, #12]
   1388e:	9303      	str	r3, [sp, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   13890:	9b03      	ldr	r3, [sp, #12]
   13892:	3318      	adds	r3, #24
   13894:	4618      	mov	r0, r3
   13896:	f7ff fe07 	bl	134a8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1389a:	9b03      	ldr	r3, [sp, #12]
   1389c:	3304      	adds	r3, #4
   1389e:	4618      	mov	r0, r3
   138a0:	f7ff fe02 	bl	134a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   138a4:	9b03      	ldr	r3, [sp, #12]
   138a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   138a8:	2201      	movs	r2, #1
   138aa:	409a      	lsls	r2, r3
   138ac:	4b2b      	ldr	r3, [pc, #172]	; (1395c <xTaskResumeAll+0x100>)
   138ae:	681b      	ldr	r3, [r3, #0]
   138b0:	4313      	orrs	r3, r2
   138b2:	4a2a      	ldr	r2, [pc, #168]	; (1395c <xTaskResumeAll+0x100>)
   138b4:	6013      	str	r3, [r2, #0]
   138b6:	9b03      	ldr	r3, [sp, #12]
   138b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   138ba:	4613      	mov	r3, r2
   138bc:	009b      	lsls	r3, r3, #2
   138be:	4413      	add	r3, r2
   138c0:	009b      	lsls	r3, r3, #2
   138c2:	4a27      	ldr	r2, [pc, #156]	; (13960 <xTaskResumeAll+0x104>)
   138c4:	441a      	add	r2, r3
   138c6:	9b03      	ldr	r3, [sp, #12]
   138c8:	3304      	adds	r3, #4
   138ca:	4619      	mov	r1, r3
   138cc:	4610      	mov	r0, r2
   138ce:	f7ff fd98 	bl	13402 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   138d2:	9b03      	ldr	r3, [sp, #12]
   138d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   138d6:	4b23      	ldr	r3, [pc, #140]	; (13964 <xTaskResumeAll+0x108>)
   138d8:	681b      	ldr	r3, [r3, #0]
   138da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   138dc:	429a      	cmp	r2, r3
   138de:	d302      	bcc.n	138e6 <xTaskResumeAll+0x8a>
					{
						xYieldPending = pdTRUE;
   138e0:	4b21      	ldr	r3, [pc, #132]	; (13968 <xTaskResumeAll+0x10c>)
   138e2:	2201      	movs	r2, #1
   138e4:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   138e6:	4b1c      	ldr	r3, [pc, #112]	; (13958 <xTaskResumeAll+0xfc>)
   138e8:	681b      	ldr	r3, [r3, #0]
   138ea:	2b00      	cmp	r3, #0
   138ec:	d1cc      	bne.n	13888 <xTaskResumeAll+0x2c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   138ee:	9b03      	ldr	r3, [sp, #12]
   138f0:	2b00      	cmp	r3, #0
   138f2:	d001      	beq.n	138f8 <xTaskResumeAll+0x9c>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   138f4:	f000 faa6 	bl	13e44 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   138f8:	4b1c      	ldr	r3, [pc, #112]	; (1396c <xTaskResumeAll+0x110>)
   138fa:	681b      	ldr	r3, [r3, #0]
   138fc:	9301      	str	r3, [sp, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   138fe:	9b01      	ldr	r3, [sp, #4]
   13900:	2b00      	cmp	r3, #0
   13902:	d010      	beq.n	13926 <xTaskResumeAll+0xca>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   13904:	f000 f836 	bl	13974 <xTaskIncrementTick>
   13908:	4603      	mov	r3, r0
   1390a:	2b00      	cmp	r3, #0
   1390c:	d002      	beq.n	13914 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
   1390e:	4b16      	ldr	r3, [pc, #88]	; (13968 <xTaskResumeAll+0x10c>)
   13910:	2201      	movs	r2, #1
   13912:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   13914:	9b01      	ldr	r3, [sp, #4]
   13916:	3b01      	subs	r3, #1
   13918:	9301      	str	r3, [sp, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   1391a:	9b01      	ldr	r3, [sp, #4]
   1391c:	2b00      	cmp	r3, #0
   1391e:	d1f1      	bne.n	13904 <xTaskResumeAll+0xa8>

						uxPendedTicks = 0;
   13920:	4b12      	ldr	r3, [pc, #72]	; (1396c <xTaskResumeAll+0x110>)
   13922:	2200      	movs	r2, #0
   13924:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   13926:	4b10      	ldr	r3, [pc, #64]	; (13968 <xTaskResumeAll+0x10c>)
   13928:	681b      	ldr	r3, [r3, #0]
   1392a:	2b00      	cmp	r3, #0
   1392c:	d009      	beq.n	13942 <xTaskResumeAll+0xe6>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   1392e:	2301      	movs	r3, #1
   13930:	9302      	str	r3, [sp, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   13932:	4b0f      	ldr	r3, [pc, #60]	; (13970 <xTaskResumeAll+0x114>)
   13934:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   13938:	601a      	str	r2, [r3, #0]
   1393a:	f3bf 8f4f 	dsb	sy
   1393e:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   13942:	f001 f893 	bl	14a6c <vPortExitCritical>

	return xAlreadyYielded;
   13946:	9b02      	ldr	r3, [sp, #8]
}
   13948:	4618      	mov	r0, r3
   1394a:	b005      	add	sp, #20
   1394c:	f85d fb04 	ldr.w	pc, [sp], #4
   13950:	100007c0 	.word	0x100007c0
   13954:	10000798 	.word	0x10000798
   13958:	10000758 	.word	0x10000758
   1395c:	100007a0 	.word	0x100007a0
   13960:	100006c4 	.word	0x100006c4
   13964:	100006c0 	.word	0x100006c0
   13968:	100007ac 	.word	0x100007ac
   1396c:	100007a8 	.word	0x100007a8
   13970:	e000ed04 	.word	0xe000ed04

00013974 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   13974:	b500      	push	{lr}
   13976:	b087      	sub	sp, #28
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   13978:	2300      	movs	r3, #0
   1397a:	9305      	str	r3, [sp, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1397c:	4b48      	ldr	r3, [pc, #288]	; (13aa0 <xTaskIncrementTick+0x12c>)
   1397e:	681b      	ldr	r3, [r3, #0]
   13980:	2b00      	cmp	r3, #0
   13982:	d17c      	bne.n	13a7e <xTaskIncrementTick+0x10a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   13984:	4b47      	ldr	r3, [pc, #284]	; (13aa4 <xTaskIncrementTick+0x130>)
   13986:	681b      	ldr	r3, [r3, #0]
   13988:	3301      	adds	r3, #1
   1398a:	9304      	str	r3, [sp, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   1398c:	4a45      	ldr	r2, [pc, #276]	; (13aa4 <xTaskIncrementTick+0x130>)
   1398e:	9b04      	ldr	r3, [sp, #16]
   13990:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   13992:	9b04      	ldr	r3, [sp, #16]
   13994:	2b00      	cmp	r3, #0
   13996:	d110      	bne.n	139ba <xTaskIncrementTick+0x46>
		{
			taskSWITCH_DELAYED_LISTS();
   13998:	4b43      	ldr	r3, [pc, #268]	; (13aa8 <xTaskIncrementTick+0x134>)
   1399a:	681b      	ldr	r3, [r3, #0]
   1399c:	9303      	str	r3, [sp, #12]
   1399e:	4b43      	ldr	r3, [pc, #268]	; (13aac <xTaskIncrementTick+0x138>)
   139a0:	681b      	ldr	r3, [r3, #0]
   139a2:	4a41      	ldr	r2, [pc, #260]	; (13aa8 <xTaskIncrementTick+0x134>)
   139a4:	6013      	str	r3, [r2, #0]
   139a6:	4a41      	ldr	r2, [pc, #260]	; (13aac <xTaskIncrementTick+0x138>)
   139a8:	9b03      	ldr	r3, [sp, #12]
   139aa:	6013      	str	r3, [r2, #0]
   139ac:	4b40      	ldr	r3, [pc, #256]	; (13ab0 <xTaskIncrementTick+0x13c>)
   139ae:	681b      	ldr	r3, [r3, #0]
   139b0:	3301      	adds	r3, #1
   139b2:	4a3f      	ldr	r2, [pc, #252]	; (13ab0 <xTaskIncrementTick+0x13c>)
   139b4:	6013      	str	r3, [r2, #0]
   139b6:	f000 fa45 	bl	13e44 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   139ba:	4b3e      	ldr	r3, [pc, #248]	; (13ab4 <xTaskIncrementTick+0x140>)
   139bc:	681b      	ldr	r3, [r3, #0]
   139be:	9a04      	ldr	r2, [sp, #16]
   139c0:	429a      	cmp	r2, r3
   139c2:	d34d      	bcc.n	13a60 <xTaskIncrementTick+0xec>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   139c4:	4b38      	ldr	r3, [pc, #224]	; (13aa8 <xTaskIncrementTick+0x134>)
   139c6:	681b      	ldr	r3, [r3, #0]
   139c8:	681b      	ldr	r3, [r3, #0]
   139ca:	2b00      	cmp	r3, #0
   139cc:	d101      	bne.n	139d2 <xTaskIncrementTick+0x5e>
   139ce:	2301      	movs	r3, #1
   139d0:	e000      	b.n	139d4 <xTaskIncrementTick+0x60>
   139d2:	2300      	movs	r3, #0
   139d4:	2b00      	cmp	r3, #0
   139d6:	d004      	beq.n	139e2 <xTaskIncrementTick+0x6e>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   139d8:	4b36      	ldr	r3, [pc, #216]	; (13ab4 <xTaskIncrementTick+0x140>)
   139da:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   139de:	601a      	str	r2, [r3, #0]
					break;
   139e0:	e03e      	b.n	13a60 <xTaskIncrementTick+0xec>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   139e2:	4b31      	ldr	r3, [pc, #196]	; (13aa8 <xTaskIncrementTick+0x134>)
   139e4:	681b      	ldr	r3, [r3, #0]
   139e6:	68db      	ldr	r3, [r3, #12]
   139e8:	68db      	ldr	r3, [r3, #12]
   139ea:	9302      	str	r3, [sp, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   139ec:	9b02      	ldr	r3, [sp, #8]
   139ee:	685b      	ldr	r3, [r3, #4]
   139f0:	9301      	str	r3, [sp, #4]

					if( xConstTickCount < xItemValue )
   139f2:	9a04      	ldr	r2, [sp, #16]
   139f4:	9b01      	ldr	r3, [sp, #4]
   139f6:	429a      	cmp	r2, r3
   139f8:	d203      	bcs.n	13a02 <xTaskIncrementTick+0x8e>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   139fa:	4a2e      	ldr	r2, [pc, #184]	; (13ab4 <xTaskIncrementTick+0x140>)
   139fc:	9b01      	ldr	r3, [sp, #4]
   139fe:	6013      	str	r3, [r2, #0]
						break;
   13a00:	e02e      	b.n	13a60 <xTaskIncrementTick+0xec>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13a02:	9b02      	ldr	r3, [sp, #8]
   13a04:	3304      	adds	r3, #4
   13a06:	4618      	mov	r0, r3
   13a08:	f7ff fd4e 	bl	134a8 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   13a0c:	9b02      	ldr	r3, [sp, #8]
   13a0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13a10:	2b00      	cmp	r3, #0
   13a12:	d004      	beq.n	13a1e <xTaskIncrementTick+0xaa>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   13a14:	9b02      	ldr	r3, [sp, #8]
   13a16:	3318      	adds	r3, #24
   13a18:	4618      	mov	r0, r3
   13a1a:	f7ff fd45 	bl	134a8 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   13a1e:	9b02      	ldr	r3, [sp, #8]
   13a20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13a22:	2201      	movs	r2, #1
   13a24:	409a      	lsls	r2, r3
   13a26:	4b24      	ldr	r3, [pc, #144]	; (13ab8 <xTaskIncrementTick+0x144>)
   13a28:	681b      	ldr	r3, [r3, #0]
   13a2a:	4313      	orrs	r3, r2
   13a2c:	4a22      	ldr	r2, [pc, #136]	; (13ab8 <xTaskIncrementTick+0x144>)
   13a2e:	6013      	str	r3, [r2, #0]
   13a30:	9b02      	ldr	r3, [sp, #8]
   13a32:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13a34:	4613      	mov	r3, r2
   13a36:	009b      	lsls	r3, r3, #2
   13a38:	4413      	add	r3, r2
   13a3a:	009b      	lsls	r3, r3, #2
   13a3c:	4a1f      	ldr	r2, [pc, #124]	; (13abc <xTaskIncrementTick+0x148>)
   13a3e:	441a      	add	r2, r3
   13a40:	9b02      	ldr	r3, [sp, #8]
   13a42:	3304      	adds	r3, #4
   13a44:	4619      	mov	r1, r3
   13a46:	4610      	mov	r0, r2
   13a48:	f7ff fcdb 	bl	13402 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   13a4c:	9b02      	ldr	r3, [sp, #8]
   13a4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13a50:	4b1b      	ldr	r3, [pc, #108]	; (13ac0 <xTaskIncrementTick+0x14c>)
   13a52:	681b      	ldr	r3, [r3, #0]
   13a54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13a56:	429a      	cmp	r2, r3
   13a58:	d3b4      	bcc.n	139c4 <xTaskIncrementTick+0x50>
						{
							xSwitchRequired = pdTRUE;
   13a5a:	2301      	movs	r3, #1
   13a5c:	9305      	str	r3, [sp, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   13a5e:	e7b1      	b.n	139c4 <xTaskIncrementTick+0x50>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   13a60:	4b17      	ldr	r3, [pc, #92]	; (13ac0 <xTaskIncrementTick+0x14c>)
   13a62:	681b      	ldr	r3, [r3, #0]
   13a64:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13a66:	4915      	ldr	r1, [pc, #84]	; (13abc <xTaskIncrementTick+0x148>)
   13a68:	4613      	mov	r3, r2
   13a6a:	009b      	lsls	r3, r3, #2
   13a6c:	4413      	add	r3, r2
   13a6e:	009b      	lsls	r3, r3, #2
   13a70:	440b      	add	r3, r1
   13a72:	681b      	ldr	r3, [r3, #0]
   13a74:	2b01      	cmp	r3, #1
   13a76:	d907      	bls.n	13a88 <xTaskIncrementTick+0x114>
			{
				xSwitchRequired = pdTRUE;
   13a78:	2301      	movs	r3, #1
   13a7a:	9305      	str	r3, [sp, #20]
   13a7c:	e004      	b.n	13a88 <xTaskIncrementTick+0x114>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   13a7e:	4b11      	ldr	r3, [pc, #68]	; (13ac4 <xTaskIncrementTick+0x150>)
   13a80:	681b      	ldr	r3, [r3, #0]
   13a82:	3301      	adds	r3, #1
   13a84:	4a0f      	ldr	r2, [pc, #60]	; (13ac4 <xTaskIncrementTick+0x150>)
   13a86:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   13a88:	4b0f      	ldr	r3, [pc, #60]	; (13ac8 <xTaskIncrementTick+0x154>)
   13a8a:	681b      	ldr	r3, [r3, #0]
   13a8c:	2b00      	cmp	r3, #0
   13a8e:	d001      	beq.n	13a94 <xTaskIncrementTick+0x120>
		{
			xSwitchRequired = pdTRUE;
   13a90:	2301      	movs	r3, #1
   13a92:	9305      	str	r3, [sp, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   13a94:	9b05      	ldr	r3, [sp, #20]
}
   13a96:	4618      	mov	r0, r3
   13a98:	b007      	add	sp, #28
   13a9a:	f85d fb04 	ldr.w	pc, [sp], #4
   13a9e:	bf00      	nop
   13aa0:	100007c0 	.word	0x100007c0
   13aa4:	1000079c 	.word	0x1000079c
   13aa8:	10000750 	.word	0x10000750
   13aac:	10000754 	.word	0x10000754
   13ab0:	100007b0 	.word	0x100007b0
   13ab4:	100007b8 	.word	0x100007b8
   13ab8:	100007a0 	.word	0x100007a0
   13abc:	100006c4 	.word	0x100006c4
   13ac0:	100006c0 	.word	0x100006c0
   13ac4:	100007a8 	.word	0x100007a8
   13ac8:	100007ac 	.word	0x100007ac

00013acc <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   13acc:	b510      	push	{r4, lr}
   13ace:	b084      	sub	sp, #16
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   13ad0:	4b29      	ldr	r3, [pc, #164]	; (13b78 <vTaskSwitchContext+0xac>)
   13ad2:	681b      	ldr	r3, [r3, #0]
   13ad4:	2b00      	cmp	r3, #0
   13ad6:	d003      	beq.n	13ae0 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   13ad8:	4b28      	ldr	r3, [pc, #160]	; (13b7c <vTaskSwitchContext+0xb0>)
   13ada:	2201      	movs	r2, #1
   13adc:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   13ade:	e047      	b.n	13b70 <vTaskSwitchContext+0xa4>
		xYieldPending = pdFALSE;
   13ae0:	4b26      	ldr	r3, [pc, #152]	; (13b7c <vTaskSwitchContext+0xb0>)
   13ae2:	2200      	movs	r2, #0
   13ae4:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   13ae6:	f7fe fe93 	bl	12810 <UptimeRTOS>
   13aea:	4603      	mov	r3, r0
   13aec:	460c      	mov	r4, r1
   13aee:	461a      	mov	r2, r3
   13af0:	4b23      	ldr	r3, [pc, #140]	; (13b80 <vTaskSwitchContext+0xb4>)
   13af2:	601a      	str	r2, [r3, #0]
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   13af4:	4b22      	ldr	r3, [pc, #136]	; (13b80 <vTaskSwitchContext+0xb4>)
   13af6:	681a      	ldr	r2, [r3, #0]
   13af8:	4b22      	ldr	r3, [pc, #136]	; (13b84 <vTaskSwitchContext+0xb8>)
   13afa:	681b      	ldr	r3, [r3, #0]
   13afc:	429a      	cmp	r2, r3
   13afe:	d909      	bls.n	13b14 <vTaskSwitchContext+0x48>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   13b00:	4b21      	ldr	r3, [pc, #132]	; (13b88 <vTaskSwitchContext+0xbc>)
   13b02:	681b      	ldr	r3, [r3, #0]
   13b04:	6d59      	ldr	r1, [r3, #84]	; 0x54
   13b06:	4a1e      	ldr	r2, [pc, #120]	; (13b80 <vTaskSwitchContext+0xb4>)
   13b08:	6810      	ldr	r0, [r2, #0]
   13b0a:	4a1e      	ldr	r2, [pc, #120]	; (13b84 <vTaskSwitchContext+0xb8>)
   13b0c:	6812      	ldr	r2, [r2, #0]
   13b0e:	1a82      	subs	r2, r0, r2
   13b10:	440a      	add	r2, r1
   13b12:	655a      	str	r2, [r3, #84]	; 0x54
				ulTaskSwitchedInTime = ulTotalRunTime;
   13b14:	4b1a      	ldr	r3, [pc, #104]	; (13b80 <vTaskSwitchContext+0xb4>)
   13b16:	681b      	ldr	r3, [r3, #0]
   13b18:	4a1a      	ldr	r2, [pc, #104]	; (13b84 <vTaskSwitchContext+0xb8>)
   13b1a:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
   13b1c:	4b1b      	ldr	r3, [pc, #108]	; (13b8c <vTaskSwitchContext+0xc0>)
   13b1e:	681b      	ldr	r3, [r3, #0]
   13b20:	9301      	str	r3, [sp, #4]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   13b22:	9b01      	ldr	r3, [sp, #4]
   13b24:	fab3 f383 	clz	r3, r3
   13b28:	f88d 3003 	strb.w	r3, [sp, #3]
		return ucReturn;
   13b2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
   13b30:	f1c3 031f 	rsb	r3, r3, #31
   13b34:	9303      	str	r3, [sp, #12]
   13b36:	9a03      	ldr	r2, [sp, #12]
   13b38:	4613      	mov	r3, r2
   13b3a:	009b      	lsls	r3, r3, #2
   13b3c:	4413      	add	r3, r2
   13b3e:	009b      	lsls	r3, r3, #2
   13b40:	4a13      	ldr	r2, [pc, #76]	; (13b90 <vTaskSwitchContext+0xc4>)
   13b42:	4413      	add	r3, r2
   13b44:	9302      	str	r3, [sp, #8]
   13b46:	9b02      	ldr	r3, [sp, #8]
   13b48:	685b      	ldr	r3, [r3, #4]
   13b4a:	685a      	ldr	r2, [r3, #4]
   13b4c:	9b02      	ldr	r3, [sp, #8]
   13b4e:	605a      	str	r2, [r3, #4]
   13b50:	9b02      	ldr	r3, [sp, #8]
   13b52:	685a      	ldr	r2, [r3, #4]
   13b54:	9b02      	ldr	r3, [sp, #8]
   13b56:	3308      	adds	r3, #8
   13b58:	429a      	cmp	r2, r3
   13b5a:	d104      	bne.n	13b66 <vTaskSwitchContext+0x9a>
   13b5c:	9b02      	ldr	r3, [sp, #8]
   13b5e:	685b      	ldr	r3, [r3, #4]
   13b60:	685a      	ldr	r2, [r3, #4]
   13b62:	9b02      	ldr	r3, [sp, #8]
   13b64:	605a      	str	r2, [r3, #4]
   13b66:	9b02      	ldr	r3, [sp, #8]
   13b68:	685b      	ldr	r3, [r3, #4]
   13b6a:	68db      	ldr	r3, [r3, #12]
   13b6c:	4a06      	ldr	r2, [pc, #24]	; (13b88 <vTaskSwitchContext+0xbc>)
   13b6e:	6013      	str	r3, [r2, #0]
}
   13b70:	bf00      	nop
   13b72:	b004      	add	sp, #16
   13b74:	bd10      	pop	{r4, pc}
   13b76:	bf00      	nop
   13b78:	100007c0 	.word	0x100007c0
   13b7c:	100007ac 	.word	0x100007ac
   13b80:	100007c8 	.word	0x100007c8
   13b84:	100007c4 	.word	0x100007c4
   13b88:	100006c0 	.word	0x100006c0
   13b8c:	100007a0 	.word	0x100007a0
   13b90:	100006c4 	.word	0x100006c4

00013b94 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   13b94:	b500      	push	{lr}
   13b96:	b083      	sub	sp, #12
   13b98:	9001      	str	r0, [sp, #4]
   13b9a:	9100      	str	r1, [sp, #0]

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   13b9c:	4b07      	ldr	r3, [pc, #28]	; (13bbc <vTaskPlaceOnEventList+0x28>)
   13b9e:	681b      	ldr	r3, [r3, #0]
   13ba0:	3318      	adds	r3, #24
   13ba2:	4619      	mov	r1, r3
   13ba4:	9801      	ldr	r0, [sp, #4]
   13ba6:	f7ff fc4b 	bl	13440 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   13baa:	2101      	movs	r1, #1
   13bac:	9800      	ldr	r0, [sp, #0]
   13bae:	f000 fadd 	bl	1416c <prvAddCurrentTaskToDelayedList>
}
   13bb2:	bf00      	nop
   13bb4:	b003      	add	sp, #12
   13bb6:	f85d fb04 	ldr.w	pc, [sp], #4
   13bba:	bf00      	nop
   13bbc:	100006c0 	.word	0x100006c0

00013bc0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   13bc0:	b500      	push	{lr}
   13bc2:	b085      	sub	sp, #20
   13bc4:	9001      	str	r0, [sp, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   13bc6:	9b01      	ldr	r3, [sp, #4]
   13bc8:	68db      	ldr	r3, [r3, #12]
   13bca:	68db      	ldr	r3, [r3, #12]
   13bcc:	9302      	str	r3, [sp, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   13bce:	9b02      	ldr	r3, [sp, #8]
   13bd0:	3318      	adds	r3, #24
   13bd2:	4618      	mov	r0, r3
   13bd4:	f7ff fc68 	bl	134a8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   13bd8:	4b1d      	ldr	r3, [pc, #116]	; (13c50 <xTaskRemoveFromEventList+0x90>)
   13bda:	681b      	ldr	r3, [r3, #0]
   13bdc:	2b00      	cmp	r3, #0
   13bde:	d11c      	bne.n	13c1a <xTaskRemoveFromEventList+0x5a>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   13be0:	9b02      	ldr	r3, [sp, #8]
   13be2:	3304      	adds	r3, #4
   13be4:	4618      	mov	r0, r3
   13be6:	f7ff fc5f 	bl	134a8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   13bea:	9b02      	ldr	r3, [sp, #8]
   13bec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13bee:	2201      	movs	r2, #1
   13bf0:	409a      	lsls	r2, r3
   13bf2:	4b18      	ldr	r3, [pc, #96]	; (13c54 <xTaskRemoveFromEventList+0x94>)
   13bf4:	681b      	ldr	r3, [r3, #0]
   13bf6:	4313      	orrs	r3, r2
   13bf8:	4a16      	ldr	r2, [pc, #88]	; (13c54 <xTaskRemoveFromEventList+0x94>)
   13bfa:	6013      	str	r3, [r2, #0]
   13bfc:	9b02      	ldr	r3, [sp, #8]
   13bfe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13c00:	4613      	mov	r3, r2
   13c02:	009b      	lsls	r3, r3, #2
   13c04:	4413      	add	r3, r2
   13c06:	009b      	lsls	r3, r3, #2
   13c08:	4a13      	ldr	r2, [pc, #76]	; (13c58 <xTaskRemoveFromEventList+0x98>)
   13c0a:	441a      	add	r2, r3
   13c0c:	9b02      	ldr	r3, [sp, #8]
   13c0e:	3304      	adds	r3, #4
   13c10:	4619      	mov	r1, r3
   13c12:	4610      	mov	r0, r2
   13c14:	f7ff fbf5 	bl	13402 <vListInsertEnd>
   13c18:	e005      	b.n	13c26 <xTaskRemoveFromEventList+0x66>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   13c1a:	9b02      	ldr	r3, [sp, #8]
   13c1c:	3318      	adds	r3, #24
   13c1e:	4619      	mov	r1, r3
   13c20:	480e      	ldr	r0, [pc, #56]	; (13c5c <xTaskRemoveFromEventList+0x9c>)
   13c22:	f7ff fbee 	bl	13402 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   13c26:	9b02      	ldr	r3, [sp, #8]
   13c28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13c2a:	4b0d      	ldr	r3, [pc, #52]	; (13c60 <xTaskRemoveFromEventList+0xa0>)
   13c2c:	681b      	ldr	r3, [r3, #0]
   13c2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13c30:	429a      	cmp	r2, r3
   13c32:	d905      	bls.n	13c40 <xTaskRemoveFromEventList+0x80>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   13c34:	2301      	movs	r3, #1
   13c36:	9303      	str	r3, [sp, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   13c38:	4b0a      	ldr	r3, [pc, #40]	; (13c64 <xTaskRemoveFromEventList+0xa4>)
   13c3a:	2201      	movs	r2, #1
   13c3c:	601a      	str	r2, [r3, #0]
   13c3e:	e001      	b.n	13c44 <xTaskRemoveFromEventList+0x84>
	}
	else
	{
		xReturn = pdFALSE;
   13c40:	2300      	movs	r3, #0
   13c42:	9303      	str	r3, [sp, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   13c44:	9b03      	ldr	r3, [sp, #12]
}
   13c46:	4618      	mov	r0, r3
   13c48:	b005      	add	sp, #20
   13c4a:	f85d fb04 	ldr.w	pc, [sp], #4
   13c4e:	bf00      	nop
   13c50:	100007c0 	.word	0x100007c0
   13c54:	100007a0 	.word	0x100007a0
   13c58:	100006c4 	.word	0x100006c4
   13c5c:	10000758 	.word	0x10000758
   13c60:	100006c0 	.word	0x100006c0
   13c64:	100007ac 	.word	0x100007ac

00013c68 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   13c68:	b082      	sub	sp, #8
   13c6a:	9001      	str	r0, [sp, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   13c6c:	4b05      	ldr	r3, [pc, #20]	; (13c84 <vTaskInternalSetTimeOutState+0x1c>)
   13c6e:	681a      	ldr	r2, [r3, #0]
   13c70:	9b01      	ldr	r3, [sp, #4]
   13c72:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   13c74:	4b04      	ldr	r3, [pc, #16]	; (13c88 <vTaskInternalSetTimeOutState+0x20>)
   13c76:	681a      	ldr	r2, [r3, #0]
   13c78:	9b01      	ldr	r3, [sp, #4]
   13c7a:	605a      	str	r2, [r3, #4]
}
   13c7c:	bf00      	nop
   13c7e:	b002      	add	sp, #8
   13c80:	4770      	bx	lr
   13c82:	bf00      	nop
   13c84:	100007b0 	.word	0x100007b0
   13c88:	1000079c 	.word	0x1000079c

00013c8c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   13c8c:	b500      	push	{lr}
   13c8e:	b087      	sub	sp, #28
   13c90:	9001      	str	r0, [sp, #4]
   13c92:	9100      	str	r1, [sp, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   13c94:	f000 fed6 	bl	14a44 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   13c98:	4b1d      	ldr	r3, [pc, #116]	; (13d10 <xTaskCheckForTimeOut+0x84>)
   13c9a:	681b      	ldr	r3, [r3, #0]
   13c9c:	9304      	str	r3, [sp, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   13c9e:	9b01      	ldr	r3, [sp, #4]
   13ca0:	685b      	ldr	r3, [r3, #4]
   13ca2:	9a04      	ldr	r2, [sp, #16]
   13ca4:	1ad3      	subs	r3, r2, r3
   13ca6:	9303      	str	r3, [sp, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   13ca8:	9b00      	ldr	r3, [sp, #0]
   13caa:	681b      	ldr	r3, [r3, #0]
   13cac:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   13cb0:	d102      	bne.n	13cb8 <xTaskCheckForTimeOut+0x2c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   13cb2:	2300      	movs	r3, #0
   13cb4:	9305      	str	r3, [sp, #20]
   13cb6:	e023      	b.n	13d00 <xTaskCheckForTimeOut+0x74>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   13cb8:	9b01      	ldr	r3, [sp, #4]
   13cba:	681a      	ldr	r2, [r3, #0]
   13cbc:	4b15      	ldr	r3, [pc, #84]	; (13d14 <xTaskCheckForTimeOut+0x88>)
   13cbe:	681b      	ldr	r3, [r3, #0]
   13cc0:	429a      	cmp	r2, r3
   13cc2:	d007      	beq.n	13cd4 <xTaskCheckForTimeOut+0x48>
   13cc4:	9b01      	ldr	r3, [sp, #4]
   13cc6:	685b      	ldr	r3, [r3, #4]
   13cc8:	9a04      	ldr	r2, [sp, #16]
   13cca:	429a      	cmp	r2, r3
   13ccc:	d302      	bcc.n	13cd4 <xTaskCheckForTimeOut+0x48>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   13cce:	2301      	movs	r3, #1
   13cd0:	9305      	str	r3, [sp, #20]
   13cd2:	e015      	b.n	13d00 <xTaskCheckForTimeOut+0x74>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   13cd4:	9b00      	ldr	r3, [sp, #0]
   13cd6:	681b      	ldr	r3, [r3, #0]
   13cd8:	9a03      	ldr	r2, [sp, #12]
   13cda:	429a      	cmp	r2, r3
   13cdc:	d20b      	bcs.n	13cf6 <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   13cde:	9b00      	ldr	r3, [sp, #0]
   13ce0:	681a      	ldr	r2, [r3, #0]
   13ce2:	9b03      	ldr	r3, [sp, #12]
   13ce4:	1ad2      	subs	r2, r2, r3
   13ce6:	9b00      	ldr	r3, [sp, #0]
   13ce8:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   13cea:	9801      	ldr	r0, [sp, #4]
   13cec:	f7ff ffbc 	bl	13c68 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   13cf0:	2300      	movs	r3, #0
   13cf2:	9305      	str	r3, [sp, #20]
   13cf4:	e004      	b.n	13d00 <xTaskCheckForTimeOut+0x74>
		}
		else
		{
			*pxTicksToWait = 0;
   13cf6:	9b00      	ldr	r3, [sp, #0]
   13cf8:	2200      	movs	r2, #0
   13cfa:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   13cfc:	2301      	movs	r3, #1
   13cfe:	9305      	str	r3, [sp, #20]
		}
	}
	taskEXIT_CRITICAL();
   13d00:	f000 feb4 	bl	14a6c <vPortExitCritical>

	return xReturn;
   13d04:	9b05      	ldr	r3, [sp, #20]
}
   13d06:	4618      	mov	r0, r3
   13d08:	b007      	add	sp, #28
   13d0a:	f85d fb04 	ldr.w	pc, [sp], #4
   13d0e:	bf00      	nop
   13d10:	1000079c 	.word	0x1000079c
   13d14:	100007b0 	.word	0x100007b0

00013d18 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
   13d18:	4b02      	ldr	r3, [pc, #8]	; (13d24 <vTaskMissedYield+0xc>)
   13d1a:	2201      	movs	r2, #1
   13d1c:	601a      	str	r2, [r3, #0]
}
   13d1e:	bf00      	nop
   13d20:	4770      	bx	lr
   13d22:	bf00      	nop
   13d24:	100007ac 	.word	0x100007ac

00013d28 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   13d28:	b500      	push	{lr}
   13d2a:	b083      	sub	sp, #12
   13d2c:	9001      	str	r0, [sp, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   13d2e:	f000 f83f 	bl	13db0 <prvCheckTasksWaitingTermination>
   13d32:	e7fc      	b.n	13d2e <prvIdleTask+0x6>

00013d34 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   13d34:	b500      	push	{lr}
   13d36:	b083      	sub	sp, #12
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   13d38:	2300      	movs	r3, #0
   13d3a:	9301      	str	r3, [sp, #4]
   13d3c:	e00c      	b.n	13d58 <prvInitialiseTaskLists+0x24>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   13d3e:	9a01      	ldr	r2, [sp, #4]
   13d40:	4613      	mov	r3, r2
   13d42:	009b      	lsls	r3, r3, #2
   13d44:	4413      	add	r3, r2
   13d46:	009b      	lsls	r3, r3, #2
   13d48:	4a11      	ldr	r2, [pc, #68]	; (13d90 <prvInitialiseTaskLists+0x5c>)
   13d4a:	4413      	add	r3, r2
   13d4c:	4618      	mov	r0, r3
   13d4e:	f7ff fb35 	bl	133bc <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   13d52:	9b01      	ldr	r3, [sp, #4]
   13d54:	3301      	adds	r3, #1
   13d56:	9301      	str	r3, [sp, #4]
   13d58:	9b01      	ldr	r3, [sp, #4]
   13d5a:	2b04      	cmp	r3, #4
   13d5c:	d9ef      	bls.n	13d3e <prvInitialiseTaskLists+0xa>
	}

	vListInitialise( &xDelayedTaskList1 );
   13d5e:	480d      	ldr	r0, [pc, #52]	; (13d94 <prvInitialiseTaskLists+0x60>)
   13d60:	f7ff fb2c 	bl	133bc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   13d64:	480c      	ldr	r0, [pc, #48]	; (13d98 <prvInitialiseTaskLists+0x64>)
   13d66:	f7ff fb29 	bl	133bc <vListInitialise>
	vListInitialise( &xPendingReadyList );
   13d6a:	480c      	ldr	r0, [pc, #48]	; (13d9c <prvInitialiseTaskLists+0x68>)
   13d6c:	f7ff fb26 	bl	133bc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   13d70:	480b      	ldr	r0, [pc, #44]	; (13da0 <prvInitialiseTaskLists+0x6c>)
   13d72:	f7ff fb23 	bl	133bc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   13d76:	480b      	ldr	r0, [pc, #44]	; (13da4 <prvInitialiseTaskLists+0x70>)
   13d78:	f7ff fb20 	bl	133bc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   13d7c:	4b0a      	ldr	r3, [pc, #40]	; (13da8 <prvInitialiseTaskLists+0x74>)
   13d7e:	4a05      	ldr	r2, [pc, #20]	; (13d94 <prvInitialiseTaskLists+0x60>)
   13d80:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   13d82:	4b0a      	ldr	r3, [pc, #40]	; (13dac <prvInitialiseTaskLists+0x78>)
   13d84:	4a04      	ldr	r2, [pc, #16]	; (13d98 <prvInitialiseTaskLists+0x64>)
   13d86:	601a      	str	r2, [r3, #0]
}
   13d88:	bf00      	nop
   13d8a:	b003      	add	sp, #12
   13d8c:	f85d fb04 	ldr.w	pc, [sp], #4
   13d90:	100006c4 	.word	0x100006c4
   13d94:	10000728 	.word	0x10000728
   13d98:	1000073c 	.word	0x1000073c
   13d9c:	10000758 	.word	0x10000758
   13da0:	1000076c 	.word	0x1000076c
   13da4:	10000784 	.word	0x10000784
   13da8:	10000750 	.word	0x10000750
   13dac:	10000754 	.word	0x10000754

00013db0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   13db0:	b500      	push	{lr}
   13db2:	b083      	sub	sp, #12
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   13db4:	e019      	b.n	13dea <prvCheckTasksWaitingTermination+0x3a>
		{
			taskENTER_CRITICAL();
   13db6:	f000 fe45 	bl	14a44 <vPortEnterCritical>
			{
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   13dba:	4b10      	ldr	r3, [pc, #64]	; (13dfc <prvCheckTasksWaitingTermination+0x4c>)
   13dbc:	68db      	ldr	r3, [r3, #12]
   13dbe:	68db      	ldr	r3, [r3, #12]
   13dc0:	9301      	str	r3, [sp, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   13dc2:	9b01      	ldr	r3, [sp, #4]
   13dc4:	3304      	adds	r3, #4
   13dc6:	4618      	mov	r0, r3
   13dc8:	f7ff fb6e 	bl	134a8 <uxListRemove>
				--uxCurrentNumberOfTasks;
   13dcc:	4b0c      	ldr	r3, [pc, #48]	; (13e00 <prvCheckTasksWaitingTermination+0x50>)
   13dce:	681b      	ldr	r3, [r3, #0]
   13dd0:	3b01      	subs	r3, #1
   13dd2:	4a0b      	ldr	r2, [pc, #44]	; (13e00 <prvCheckTasksWaitingTermination+0x50>)
   13dd4:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
   13dd6:	4b0b      	ldr	r3, [pc, #44]	; (13e04 <prvCheckTasksWaitingTermination+0x54>)
   13dd8:	681b      	ldr	r3, [r3, #0]
   13dda:	3b01      	subs	r3, #1
   13ddc:	4a09      	ldr	r2, [pc, #36]	; (13e04 <prvCheckTasksWaitingTermination+0x54>)
   13dde:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
   13de0:	f000 fe44 	bl	14a6c <vPortExitCritical>

			prvDeleteTCB( pxTCB );
   13de4:	9801      	ldr	r0, [sp, #4]
   13de6:	f000 f80f 	bl	13e08 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   13dea:	4b06      	ldr	r3, [pc, #24]	; (13e04 <prvCheckTasksWaitingTermination+0x54>)
   13dec:	681b      	ldr	r3, [r3, #0]
   13dee:	2b00      	cmp	r3, #0
   13df0:	d1e1      	bne.n	13db6 <prvCheckTasksWaitingTermination+0x6>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   13df2:	bf00      	nop
   13df4:	b003      	add	sp, #12
   13df6:	f85d fb04 	ldr.w	pc, [sp], #4
   13dfa:	bf00      	nop
   13dfc:	1000076c 	.word	0x1000076c
   13e00:	10000798 	.word	0x10000798
   13e04:	10000780 	.word	0x10000780

00013e08 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   13e08:	b500      	push	{lr}
   13e0a:	b083      	sub	sp, #12
   13e0c:	9001      	str	r0, [sp, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   13e0e:	9b01      	ldr	r3, [sp, #4]
   13e10:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   13e14:	2b00      	cmp	r3, #0
   13e16:	d108      	bne.n	13e2a <prvDeleteTCB+0x22>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
   13e18:	9b01      	ldr	r3, [sp, #4]
   13e1a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   13e1c:	4618      	mov	r0, r3
   13e1e:	f000 feae 	bl	14b7e <vPortFree>
				vPortFree( pxTCB );
   13e22:	9801      	ldr	r0, [sp, #4]
   13e24:	f000 feab 	bl	14b7e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
   13e28:	e007      	b.n	13e3a <prvDeleteTCB+0x32>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   13e2a:	9b01      	ldr	r3, [sp, #4]
   13e2c:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
   13e30:	2b01      	cmp	r3, #1
   13e32:	d102      	bne.n	13e3a <prvDeleteTCB+0x32>
				vPortFree( pxTCB );
   13e34:	9801      	ldr	r0, [sp, #4]
   13e36:	f000 fea2 	bl	14b7e <vPortFree>
	}
   13e3a:	bf00      	nop
   13e3c:	b003      	add	sp, #12
   13e3e:	f85d fb04 	ldr.w	pc, [sp], #4
   13e42:	Address 0x0000000000013e42 is out of bounds.


00013e44 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   13e44:	b082      	sub	sp, #8
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   13e46:	4b0d      	ldr	r3, [pc, #52]	; (13e7c <prvResetNextTaskUnblockTime+0x38>)
   13e48:	681b      	ldr	r3, [r3, #0]
   13e4a:	681b      	ldr	r3, [r3, #0]
   13e4c:	2b00      	cmp	r3, #0
   13e4e:	d101      	bne.n	13e54 <prvResetNextTaskUnblockTime+0x10>
   13e50:	2301      	movs	r3, #1
   13e52:	e000      	b.n	13e56 <prvResetNextTaskUnblockTime+0x12>
   13e54:	2300      	movs	r3, #0
   13e56:	2b00      	cmp	r3, #0
   13e58:	d004      	beq.n	13e64 <prvResetNextTaskUnblockTime+0x20>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   13e5a:	4b09      	ldr	r3, [pc, #36]	; (13e80 <prvResetNextTaskUnblockTime+0x3c>)
   13e5c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13e60:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   13e62:	e008      	b.n	13e76 <prvResetNextTaskUnblockTime+0x32>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   13e64:	4b05      	ldr	r3, [pc, #20]	; (13e7c <prvResetNextTaskUnblockTime+0x38>)
   13e66:	681b      	ldr	r3, [r3, #0]
   13e68:	68db      	ldr	r3, [r3, #12]
   13e6a:	68db      	ldr	r3, [r3, #12]
   13e6c:	9301      	str	r3, [sp, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   13e6e:	9b01      	ldr	r3, [sp, #4]
   13e70:	685b      	ldr	r3, [r3, #4]
   13e72:	4a03      	ldr	r2, [pc, #12]	; (13e80 <prvResetNextTaskUnblockTime+0x3c>)
   13e74:	6013      	str	r3, [r2, #0]
}
   13e76:	bf00      	nop
   13e78:	b002      	add	sp, #8
   13e7a:	4770      	bx	lr
   13e7c:	10000750 	.word	0x10000750
   13e80:	100007b8 	.word	0x100007b8

00013e84 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
   13e84:	b500      	push	{lr}
   13e86:	b085      	sub	sp, #20
   13e88:	9001      	str	r0, [sp, #4]
	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
   13e8a:	9b01      	ldr	r3, [sp, #4]
   13e8c:	9302      	str	r3, [sp, #8]
	BaseType_t xReturn = pdFALSE;
   13e8e:	2300      	movs	r3, #0
   13e90:	9303      	str	r3, [sp, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
   13e92:	9b01      	ldr	r3, [sp, #4]
   13e94:	2b00      	cmp	r3, #0
   13e96:	d06e      	beq.n	13f76 <xTaskPriorityInherit+0xf2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   13e98:	9b02      	ldr	r3, [sp, #8]
   13e9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13e9c:	4b38      	ldr	r3, [pc, #224]	; (13f80 <xTaskPriorityInherit+0xfc>)
   13e9e:	681b      	ldr	r3, [r3, #0]
   13ea0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13ea2:	429a      	cmp	r2, r3
   13ea4:	d25e      	bcs.n	13f64 <xTaskPriorityInherit+0xe0>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   13ea6:	9b02      	ldr	r3, [sp, #8]
   13ea8:	699b      	ldr	r3, [r3, #24]
   13eaa:	2b00      	cmp	r3, #0
   13eac:	db06      	blt.n	13ebc <xTaskPriorityInherit+0x38>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   13eae:	4b34      	ldr	r3, [pc, #208]	; (13f80 <xTaskPriorityInherit+0xfc>)
   13eb0:	681b      	ldr	r3, [r3, #0]
   13eb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13eb4:	f1c3 0205 	rsb	r2, r3, #5
   13eb8:	9b02      	ldr	r3, [sp, #8]
   13eba:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   13ebc:	9b02      	ldr	r3, [sp, #8]
   13ebe:	6959      	ldr	r1, [r3, #20]
   13ec0:	9b02      	ldr	r3, [sp, #8]
   13ec2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13ec4:	4613      	mov	r3, r2
   13ec6:	009b      	lsls	r3, r3, #2
   13ec8:	4413      	add	r3, r2
   13eca:	009b      	lsls	r3, r3, #2
   13ecc:	4a2d      	ldr	r2, [pc, #180]	; (13f84 <xTaskPriorityInherit+0x100>)
   13ece:	4413      	add	r3, r2
   13ed0:	4299      	cmp	r1, r3
   13ed2:	d101      	bne.n	13ed8 <xTaskPriorityInherit+0x54>
   13ed4:	2301      	movs	r3, #1
   13ed6:	e000      	b.n	13eda <xTaskPriorityInherit+0x56>
   13ed8:	2300      	movs	r3, #0
   13eda:	2b00      	cmp	r3, #0
   13edc:	d03a      	beq.n	13f54 <xTaskPriorityInherit+0xd0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   13ede:	9b02      	ldr	r3, [sp, #8]
   13ee0:	3304      	adds	r3, #4
   13ee2:	4618      	mov	r0, r3
   13ee4:	f7ff fae0 	bl	134a8 <uxListRemove>
   13ee8:	4603      	mov	r3, r0
   13eea:	2b00      	cmp	r3, #0
   13eec:	d115      	bne.n	13f1a <xTaskPriorityInherit+0x96>
					{
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
   13eee:	9b02      	ldr	r3, [sp, #8]
   13ef0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13ef2:	4924      	ldr	r1, [pc, #144]	; (13f84 <xTaskPriorityInherit+0x100>)
   13ef4:	4613      	mov	r3, r2
   13ef6:	009b      	lsls	r3, r3, #2
   13ef8:	4413      	add	r3, r2
   13efa:	009b      	lsls	r3, r3, #2
   13efc:	440b      	add	r3, r1
   13efe:	681b      	ldr	r3, [r3, #0]
   13f00:	2b00      	cmp	r3, #0
   13f02:	d10a      	bne.n	13f1a <xTaskPriorityInherit+0x96>
   13f04:	9b02      	ldr	r3, [sp, #8]
   13f06:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13f08:	2201      	movs	r2, #1
   13f0a:	fa02 f303 	lsl.w	r3, r2, r3
   13f0e:	43da      	mvns	r2, r3
   13f10:	4b1d      	ldr	r3, [pc, #116]	; (13f88 <xTaskPriorityInherit+0x104>)
   13f12:	681b      	ldr	r3, [r3, #0]
   13f14:	4013      	ands	r3, r2
   13f16:	4a1c      	ldr	r2, [pc, #112]	; (13f88 <xTaskPriorityInherit+0x104>)
   13f18:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   13f1a:	4b19      	ldr	r3, [pc, #100]	; (13f80 <xTaskPriorityInherit+0xfc>)
   13f1c:	681b      	ldr	r3, [r3, #0]
   13f1e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13f20:	9b02      	ldr	r3, [sp, #8]
   13f22:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   13f24:	9b02      	ldr	r3, [sp, #8]
   13f26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13f28:	2201      	movs	r2, #1
   13f2a:	409a      	lsls	r2, r3
   13f2c:	4b16      	ldr	r3, [pc, #88]	; (13f88 <xTaskPriorityInherit+0x104>)
   13f2e:	681b      	ldr	r3, [r3, #0]
   13f30:	4313      	orrs	r3, r2
   13f32:	4a15      	ldr	r2, [pc, #84]	; (13f88 <xTaskPriorityInherit+0x104>)
   13f34:	6013      	str	r3, [r2, #0]
   13f36:	9b02      	ldr	r3, [sp, #8]
   13f38:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13f3a:	4613      	mov	r3, r2
   13f3c:	009b      	lsls	r3, r3, #2
   13f3e:	4413      	add	r3, r2
   13f40:	009b      	lsls	r3, r3, #2
   13f42:	4a10      	ldr	r2, [pc, #64]	; (13f84 <xTaskPriorityInherit+0x100>)
   13f44:	441a      	add	r2, r3
   13f46:	9b02      	ldr	r3, [sp, #8]
   13f48:	3304      	adds	r3, #4
   13f4a:	4619      	mov	r1, r3
   13f4c:	4610      	mov	r0, r2
   13f4e:	f7ff fa58 	bl	13402 <vListInsertEnd>
   13f52:	e004      	b.n	13f5e <xTaskPriorityInherit+0xda>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   13f54:	4b0a      	ldr	r3, [pc, #40]	; (13f80 <xTaskPriorityInherit+0xfc>)
   13f56:	681b      	ldr	r3, [r3, #0]
   13f58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13f5a:	9b02      	ldr	r3, [sp, #8]
   13f5c:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
   13f5e:	2301      	movs	r3, #1
   13f60:	9303      	str	r3, [sp, #12]
   13f62:	e008      	b.n	13f76 <xTaskPriorityInherit+0xf2>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   13f64:	9b02      	ldr	r3, [sp, #8]
   13f66:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   13f68:	4b05      	ldr	r3, [pc, #20]	; (13f80 <xTaskPriorityInherit+0xfc>)
   13f6a:	681b      	ldr	r3, [r3, #0]
   13f6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13f6e:	429a      	cmp	r2, r3
   13f70:	d201      	bcs.n	13f76 <xTaskPriorityInherit+0xf2>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
   13f72:	2301      	movs	r3, #1
   13f74:	9303      	str	r3, [sp, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   13f76:	9b03      	ldr	r3, [sp, #12]
	}
   13f78:	4618      	mov	r0, r3
   13f7a:	b005      	add	sp, #20
   13f7c:	f85d fb04 	ldr.w	pc, [sp], #4
   13f80:	100006c0 	.word	0x100006c0
   13f84:	100006c4 	.word	0x100006c4
   13f88:	100007a0 	.word	0x100007a0

00013f8c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   13f8c:	b500      	push	{lr}
   13f8e:	b085      	sub	sp, #20
   13f90:	9001      	str	r0, [sp, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   13f92:	9b01      	ldr	r3, [sp, #4]
   13f94:	9302      	str	r3, [sp, #8]
	BaseType_t xReturn = pdFALSE;
   13f96:	2300      	movs	r3, #0
   13f98:	9303      	str	r3, [sp, #12]

		if( pxMutexHolder != NULL )
   13f9a:	9b01      	ldr	r3, [sp, #4]
   13f9c:	2b00      	cmp	r3, #0
   13f9e:	d04f      	beq.n	14040 <xTaskPriorityDisinherit+0xb4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
   13fa0:	9b02      	ldr	r3, [sp, #8]
   13fa2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   13fa4:	1e5a      	subs	r2, r3, #1
   13fa6:	9b02      	ldr	r3, [sp, #8]
   13fa8:	651a      	str	r2, [r3, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   13faa:	9b02      	ldr	r3, [sp, #8]
   13fac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13fae:	9b02      	ldr	r3, [sp, #8]
   13fb0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   13fb2:	429a      	cmp	r2, r3
   13fb4:	d044      	beq.n	14040 <xTaskPriorityDisinherit+0xb4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   13fb6:	9b02      	ldr	r3, [sp, #8]
   13fb8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   13fba:	2b00      	cmp	r3, #0
   13fbc:	d140      	bne.n	14040 <xTaskPriorityDisinherit+0xb4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   13fbe:	9b02      	ldr	r3, [sp, #8]
   13fc0:	3304      	adds	r3, #4
   13fc2:	4618      	mov	r0, r3
   13fc4:	f7ff fa70 	bl	134a8 <uxListRemove>
   13fc8:	4603      	mov	r3, r0
   13fca:	2b00      	cmp	r3, #0
   13fcc:	d115      	bne.n	13ffa <xTaskPriorityDisinherit+0x6e>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   13fce:	9b02      	ldr	r3, [sp, #8]
   13fd0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13fd2:	491e      	ldr	r1, [pc, #120]	; (1404c <xTaskPriorityDisinherit+0xc0>)
   13fd4:	4613      	mov	r3, r2
   13fd6:	009b      	lsls	r3, r3, #2
   13fd8:	4413      	add	r3, r2
   13fda:	009b      	lsls	r3, r3, #2
   13fdc:	440b      	add	r3, r1
   13fde:	681b      	ldr	r3, [r3, #0]
   13fe0:	2b00      	cmp	r3, #0
   13fe2:	d10a      	bne.n	13ffa <xTaskPriorityDisinherit+0x6e>
   13fe4:	9b02      	ldr	r3, [sp, #8]
   13fe6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13fe8:	2201      	movs	r2, #1
   13fea:	fa02 f303 	lsl.w	r3, r2, r3
   13fee:	43da      	mvns	r2, r3
   13ff0:	4b17      	ldr	r3, [pc, #92]	; (14050 <xTaskPriorityDisinherit+0xc4>)
   13ff2:	681b      	ldr	r3, [r3, #0]
   13ff4:	4013      	ands	r3, r2
   13ff6:	4a16      	ldr	r2, [pc, #88]	; (14050 <xTaskPriorityDisinherit+0xc4>)
   13ff8:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   13ffa:	9b02      	ldr	r3, [sp, #8]
   13ffc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   13ffe:	9b02      	ldr	r3, [sp, #8]
   14000:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   14002:	9b02      	ldr	r3, [sp, #8]
   14004:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14006:	f1c3 0205 	rsb	r2, r3, #5
   1400a:	9b02      	ldr	r3, [sp, #8]
   1400c:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   1400e:	9b02      	ldr	r3, [sp, #8]
   14010:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14012:	2201      	movs	r2, #1
   14014:	409a      	lsls	r2, r3
   14016:	4b0e      	ldr	r3, [pc, #56]	; (14050 <xTaskPriorityDisinherit+0xc4>)
   14018:	681b      	ldr	r3, [r3, #0]
   1401a:	4313      	orrs	r3, r2
   1401c:	4a0c      	ldr	r2, [pc, #48]	; (14050 <xTaskPriorityDisinherit+0xc4>)
   1401e:	6013      	str	r3, [r2, #0]
   14020:	9b02      	ldr	r3, [sp, #8]
   14022:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   14024:	4613      	mov	r3, r2
   14026:	009b      	lsls	r3, r3, #2
   14028:	4413      	add	r3, r2
   1402a:	009b      	lsls	r3, r3, #2
   1402c:	4a07      	ldr	r2, [pc, #28]	; (1404c <xTaskPriorityDisinherit+0xc0>)
   1402e:	441a      	add	r2, r3
   14030:	9b02      	ldr	r3, [sp, #8]
   14032:	3304      	adds	r3, #4
   14034:	4619      	mov	r1, r3
   14036:	4610      	mov	r0, r2
   14038:	f7ff f9e3 	bl	13402 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
   1403c:	2301      	movs	r3, #1
   1403e:	9303      	str	r3, [sp, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   14040:	9b03      	ldr	r3, [sp, #12]
	}
   14042:	4618      	mov	r0, r3
   14044:	b005      	add	sp, #20
   14046:	f85d fb04 	ldr.w	pc, [sp], #4
   1404a:	bf00      	nop
   1404c:	100006c4 	.word	0x100006c4
   14050:	100007a0 	.word	0x100007a0

00014054 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
   14054:	b500      	push	{lr}
   14056:	b087      	sub	sp, #28
   14058:	9001      	str	r0, [sp, #4]
   1405a:	9100      	str	r1, [sp, #0]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   1405c:	9b01      	ldr	r3, [sp, #4]
   1405e:	9304      	str	r3, [sp, #16]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
   14060:	2301      	movs	r3, #1
   14062:	9303      	str	r3, [sp, #12]

		if( pxMutexHolder != NULL )
   14064:	9b01      	ldr	r3, [sp, #4]
   14066:	2b00      	cmp	r3, #0
   14068:	d068      	beq.n	1413c <vTaskPriorityDisinheritAfterTimeout+0xe8>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   1406a:	9b04      	ldr	r3, [sp, #16]
   1406c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   1406e:	9a00      	ldr	r2, [sp, #0]
   14070:	429a      	cmp	r2, r3
   14072:	d902      	bls.n	1407a <vTaskPriorityDisinheritAfterTimeout+0x26>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
   14074:	9b00      	ldr	r3, [sp, #0]
   14076:	9305      	str	r3, [sp, #20]
   14078:	e002      	b.n	14080 <vTaskPriorityDisinheritAfterTimeout+0x2c>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
   1407a:	9b04      	ldr	r3, [sp, #16]
   1407c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   1407e:	9305      	str	r3, [sp, #20]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
   14080:	9b04      	ldr	r3, [sp, #16]
   14082:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14084:	9a05      	ldr	r2, [sp, #20]
   14086:	429a      	cmp	r2, r3
   14088:	d058      	beq.n	1413c <vTaskPriorityDisinheritAfterTimeout+0xe8>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   1408a:	9b04      	ldr	r3, [sp, #16]
   1408c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   1408e:	9a03      	ldr	r2, [sp, #12]
   14090:	429a      	cmp	r2, r3
   14092:	d153      	bne.n	1413c <vTaskPriorityDisinheritAfterTimeout+0xe8>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   14094:	9b04      	ldr	r3, [sp, #16]
   14096:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14098:	9302      	str	r3, [sp, #8]
					pxTCB->uxPriority = uxPriorityToUse;
   1409a:	9b04      	ldr	r3, [sp, #16]
   1409c:	9a05      	ldr	r2, [sp, #20]
   1409e:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   140a0:	9b04      	ldr	r3, [sp, #16]
   140a2:	699b      	ldr	r3, [r3, #24]
   140a4:	2b00      	cmp	r3, #0
   140a6:	db04      	blt.n	140b2 <vTaskPriorityDisinheritAfterTimeout+0x5e>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   140a8:	9b05      	ldr	r3, [sp, #20]
   140aa:	f1c3 0205 	rsb	r2, r3, #5
   140ae:	9b04      	ldr	r3, [sp, #16]
   140b0:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   140b2:	9b04      	ldr	r3, [sp, #16]
   140b4:	6959      	ldr	r1, [r3, #20]
   140b6:	9a02      	ldr	r2, [sp, #8]
   140b8:	4613      	mov	r3, r2
   140ba:	009b      	lsls	r3, r3, #2
   140bc:	4413      	add	r3, r2
   140be:	009b      	lsls	r3, r3, #2
   140c0:	4a20      	ldr	r2, [pc, #128]	; (14144 <vTaskPriorityDisinheritAfterTimeout+0xf0>)
   140c2:	4413      	add	r3, r2
   140c4:	4299      	cmp	r1, r3
   140c6:	d101      	bne.n	140cc <vTaskPriorityDisinheritAfterTimeout+0x78>
   140c8:	2301      	movs	r3, #1
   140ca:	e000      	b.n	140ce <vTaskPriorityDisinheritAfterTimeout+0x7a>
   140cc:	2300      	movs	r3, #0
   140ce:	2b00      	cmp	r3, #0
   140d0:	d034      	beq.n	1413c <vTaskPriorityDisinheritAfterTimeout+0xe8>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   140d2:	9b04      	ldr	r3, [sp, #16]
   140d4:	3304      	adds	r3, #4
   140d6:	4618      	mov	r0, r3
   140d8:	f7ff f9e6 	bl	134a8 <uxListRemove>
   140dc:	4603      	mov	r3, r0
   140de:	2b00      	cmp	r3, #0
   140e0:	d115      	bne.n	1410e <vTaskPriorityDisinheritAfterTimeout+0xba>
						{
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   140e2:	9b04      	ldr	r3, [sp, #16]
   140e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   140e6:	4917      	ldr	r1, [pc, #92]	; (14144 <vTaskPriorityDisinheritAfterTimeout+0xf0>)
   140e8:	4613      	mov	r3, r2
   140ea:	009b      	lsls	r3, r3, #2
   140ec:	4413      	add	r3, r2
   140ee:	009b      	lsls	r3, r3, #2
   140f0:	440b      	add	r3, r1
   140f2:	681b      	ldr	r3, [r3, #0]
   140f4:	2b00      	cmp	r3, #0
   140f6:	d10a      	bne.n	1410e <vTaskPriorityDisinheritAfterTimeout+0xba>
   140f8:	9b04      	ldr	r3, [sp, #16]
   140fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   140fc:	2201      	movs	r2, #1
   140fe:	fa02 f303 	lsl.w	r3, r2, r3
   14102:	43da      	mvns	r2, r3
   14104:	4b10      	ldr	r3, [pc, #64]	; (14148 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   14106:	681b      	ldr	r3, [r3, #0]
   14108:	4013      	ands	r3, r2
   1410a:	4a0f      	ldr	r2, [pc, #60]	; (14148 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   1410c:	6013      	str	r3, [r2, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
   1410e:	9b04      	ldr	r3, [sp, #16]
   14110:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14112:	2201      	movs	r2, #1
   14114:	409a      	lsls	r2, r3
   14116:	4b0c      	ldr	r3, [pc, #48]	; (14148 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   14118:	681b      	ldr	r3, [r3, #0]
   1411a:	4313      	orrs	r3, r2
   1411c:	4a0a      	ldr	r2, [pc, #40]	; (14148 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   1411e:	6013      	str	r3, [r2, #0]
   14120:	9b04      	ldr	r3, [sp, #16]
   14122:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   14124:	4613      	mov	r3, r2
   14126:	009b      	lsls	r3, r3, #2
   14128:	4413      	add	r3, r2
   1412a:	009b      	lsls	r3, r3, #2
   1412c:	4a05      	ldr	r2, [pc, #20]	; (14144 <vTaskPriorityDisinheritAfterTimeout+0xf0>)
   1412e:	441a      	add	r2, r3
   14130:	9b04      	ldr	r3, [sp, #16]
   14132:	3304      	adds	r3, #4
   14134:	4619      	mov	r1, r3
   14136:	4610      	mov	r0, r2
   14138:	f7ff f963 	bl	13402 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   1413c:	bf00      	nop
   1413e:	b007      	add	sp, #28
   14140:	f85d fb04 	ldr.w	pc, [sp], #4
   14144:	100006c4 	.word	0x100006c4
   14148:	100007a0 	.word	0x100007a0

0001414c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
   1414c:	4b06      	ldr	r3, [pc, #24]	; (14168 <pvTaskIncrementMutexHeldCount+0x1c>)
   1414e:	681b      	ldr	r3, [r3, #0]
   14150:	2b00      	cmp	r3, #0
   14152:	d004      	beq.n	1415e <pvTaskIncrementMutexHeldCount+0x12>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
   14154:	4b04      	ldr	r3, [pc, #16]	; (14168 <pvTaskIncrementMutexHeldCount+0x1c>)
   14156:	681b      	ldr	r3, [r3, #0]
   14158:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   1415a:	3201      	adds	r2, #1
   1415c:	651a      	str	r2, [r3, #80]	; 0x50
		}

		return pxCurrentTCB;
   1415e:	4b02      	ldr	r3, [pc, #8]	; (14168 <pvTaskIncrementMutexHeldCount+0x1c>)
   14160:	681b      	ldr	r3, [r3, #0]
	}
   14162:	4618      	mov	r0, r3
   14164:	4770      	bx	lr
   14166:	bf00      	nop
   14168:	100006c0 	.word	0x100006c0

0001416c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   1416c:	b500      	push	{lr}
   1416e:	b085      	sub	sp, #20
   14170:	9001      	str	r0, [sp, #4]
   14172:	9100      	str	r1, [sp, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   14174:	4b28      	ldr	r3, [pc, #160]	; (14218 <prvAddCurrentTaskToDelayedList+0xac>)
   14176:	681b      	ldr	r3, [r3, #0]
   14178:	9303      	str	r3, [sp, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1417a:	4b28      	ldr	r3, [pc, #160]	; (1421c <prvAddCurrentTaskToDelayedList+0xb0>)
   1417c:	681b      	ldr	r3, [r3, #0]
   1417e:	3304      	adds	r3, #4
   14180:	4618      	mov	r0, r3
   14182:	f7ff f991 	bl	134a8 <uxListRemove>
   14186:	4603      	mov	r3, r0
   14188:	2b00      	cmp	r3, #0
   1418a:	d10b      	bne.n	141a4 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   1418c:	4b23      	ldr	r3, [pc, #140]	; (1421c <prvAddCurrentTaskToDelayedList+0xb0>)
   1418e:	681b      	ldr	r3, [r3, #0]
   14190:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14192:	2201      	movs	r2, #1
   14194:	fa02 f303 	lsl.w	r3, r2, r3
   14198:	43da      	mvns	r2, r3
   1419a:	4b21      	ldr	r3, [pc, #132]	; (14220 <prvAddCurrentTaskToDelayedList+0xb4>)
   1419c:	681b      	ldr	r3, [r3, #0]
   1419e:	4013      	ands	r3, r2
   141a0:	4a1f      	ldr	r2, [pc, #124]	; (14220 <prvAddCurrentTaskToDelayedList+0xb4>)
   141a2:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   141a4:	9b01      	ldr	r3, [sp, #4]
   141a6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   141aa:	d10a      	bne.n	141c2 <prvAddCurrentTaskToDelayedList+0x56>
   141ac:	9b00      	ldr	r3, [sp, #0]
   141ae:	2b00      	cmp	r3, #0
   141b0:	d007      	beq.n	141c2 <prvAddCurrentTaskToDelayedList+0x56>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   141b2:	4b1a      	ldr	r3, [pc, #104]	; (1421c <prvAddCurrentTaskToDelayedList+0xb0>)
   141b4:	681b      	ldr	r3, [r3, #0]
   141b6:	3304      	adds	r3, #4
   141b8:	4619      	mov	r1, r3
   141ba:	481a      	ldr	r0, [pc, #104]	; (14224 <prvAddCurrentTaskToDelayedList+0xb8>)
   141bc:	f7ff f921 	bl	13402 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   141c0:	e026      	b.n	14210 <prvAddCurrentTaskToDelayedList+0xa4>
			xTimeToWake = xConstTickCount + xTicksToWait;
   141c2:	9a03      	ldr	r2, [sp, #12]
   141c4:	9b01      	ldr	r3, [sp, #4]
   141c6:	4413      	add	r3, r2
   141c8:	9302      	str	r3, [sp, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   141ca:	4b14      	ldr	r3, [pc, #80]	; (1421c <prvAddCurrentTaskToDelayedList+0xb0>)
   141cc:	681b      	ldr	r3, [r3, #0]
   141ce:	9a02      	ldr	r2, [sp, #8]
   141d0:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
   141d2:	9a02      	ldr	r2, [sp, #8]
   141d4:	9b03      	ldr	r3, [sp, #12]
   141d6:	429a      	cmp	r2, r3
   141d8:	d209      	bcs.n	141ee <prvAddCurrentTaskToDelayedList+0x82>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   141da:	4b13      	ldr	r3, [pc, #76]	; (14228 <prvAddCurrentTaskToDelayedList+0xbc>)
   141dc:	681a      	ldr	r2, [r3, #0]
   141de:	4b0f      	ldr	r3, [pc, #60]	; (1421c <prvAddCurrentTaskToDelayedList+0xb0>)
   141e0:	681b      	ldr	r3, [r3, #0]
   141e2:	3304      	adds	r3, #4
   141e4:	4619      	mov	r1, r3
   141e6:	4610      	mov	r0, r2
   141e8:	f7ff f92a 	bl	13440 <vListInsert>
}
   141ec:	e010      	b.n	14210 <prvAddCurrentTaskToDelayedList+0xa4>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   141ee:	4b0f      	ldr	r3, [pc, #60]	; (1422c <prvAddCurrentTaskToDelayedList+0xc0>)
   141f0:	681a      	ldr	r2, [r3, #0]
   141f2:	4b0a      	ldr	r3, [pc, #40]	; (1421c <prvAddCurrentTaskToDelayedList+0xb0>)
   141f4:	681b      	ldr	r3, [r3, #0]
   141f6:	3304      	adds	r3, #4
   141f8:	4619      	mov	r1, r3
   141fa:	4610      	mov	r0, r2
   141fc:	f7ff f920 	bl	13440 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   14200:	4b0b      	ldr	r3, [pc, #44]	; (14230 <prvAddCurrentTaskToDelayedList+0xc4>)
   14202:	681b      	ldr	r3, [r3, #0]
   14204:	9a02      	ldr	r2, [sp, #8]
   14206:	429a      	cmp	r2, r3
   14208:	d202      	bcs.n	14210 <prvAddCurrentTaskToDelayedList+0xa4>
					xNextTaskUnblockTime = xTimeToWake;
   1420a:	4a09      	ldr	r2, [pc, #36]	; (14230 <prvAddCurrentTaskToDelayedList+0xc4>)
   1420c:	9b02      	ldr	r3, [sp, #8]
   1420e:	6013      	str	r3, [r2, #0]
}
   14210:	bf00      	nop
   14212:	b005      	add	sp, #20
   14214:	f85d fb04 	ldr.w	pc, [sp], #4
   14218:	1000079c 	.word	0x1000079c
   1421c:	100006c0 	.word	0x100006c0
   14220:	100007a0 	.word	0x100007a0
   14224:	10000784 	.word	0x10000784
   14228:	10000754 	.word	0x10000754
   1422c:	10000750 	.word	0x10000750
   14230:	100007b8 	.word	0x100007b8

00014234 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   14234:	b500      	push	{lr}
   14236:	b085      	sub	sp, #20
   14238:	9001      	str	r0, [sp, #4]
   1423a:	9100      	str	r1, [sp, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   1423c:	9b01      	ldr	r3, [sp, #4]
   1423e:	9303      	str	r3, [sp, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   14240:	f000 fc00 	bl	14a44 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   14244:	9b03      	ldr	r3, [sp, #12]
   14246:	681a      	ldr	r2, [r3, #0]
   14248:	9b03      	ldr	r3, [sp, #12]
   1424a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1424c:	9903      	ldr	r1, [sp, #12]
   1424e:	6c09      	ldr	r1, [r1, #64]	; 0x40
   14250:	fb01 f303 	mul.w	r3, r1, r3
   14254:	441a      	add	r2, r3
   14256:	9b03      	ldr	r3, [sp, #12]
   14258:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   1425a:	9b03      	ldr	r3, [sp, #12]
   1425c:	2200      	movs	r2, #0
   1425e:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   14260:	9b03      	ldr	r3, [sp, #12]
   14262:	681a      	ldr	r2, [r3, #0]
   14264:	9b03      	ldr	r3, [sp, #12]
   14266:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   14268:	9b03      	ldr	r3, [sp, #12]
   1426a:	681a      	ldr	r2, [r3, #0]
   1426c:	9b03      	ldr	r3, [sp, #12]
   1426e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   14270:	3b01      	subs	r3, #1
   14272:	9903      	ldr	r1, [sp, #12]
   14274:	6c09      	ldr	r1, [r1, #64]	; 0x40
   14276:	fb01 f303 	mul.w	r3, r1, r3
   1427a:	441a      	add	r2, r3
   1427c:	9b03      	ldr	r3, [sp, #12]
   1427e:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   14280:	9b03      	ldr	r3, [sp, #12]
   14282:	22ff      	movs	r2, #255	; 0xff
   14284:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   14288:	9b03      	ldr	r3, [sp, #12]
   1428a:	22ff      	movs	r2, #255	; 0xff
   1428c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
   14290:	9b00      	ldr	r3, [sp, #0]
   14292:	2b00      	cmp	r3, #0
   14294:	d114      	bne.n	142c0 <xQueueGenericReset+0x8c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   14296:	9b03      	ldr	r3, [sp, #12]
   14298:	691b      	ldr	r3, [r3, #16]
   1429a:	2b00      	cmp	r3, #0
   1429c:	d01a      	beq.n	142d4 <xQueueGenericReset+0xa0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1429e:	9b03      	ldr	r3, [sp, #12]
   142a0:	3310      	adds	r3, #16
   142a2:	4618      	mov	r0, r3
   142a4:	f7ff fc8c 	bl	13bc0 <xTaskRemoveFromEventList>
   142a8:	4603      	mov	r3, r0
   142aa:	2b00      	cmp	r3, #0
   142ac:	d012      	beq.n	142d4 <xQueueGenericReset+0xa0>
				{
					queueYIELD_IF_USING_PREEMPTION();
   142ae:	4b0d      	ldr	r3, [pc, #52]	; (142e4 <xQueueGenericReset+0xb0>)
   142b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   142b4:	601a      	str	r2, [r3, #0]
   142b6:	f3bf 8f4f 	dsb	sy
   142ba:	f3bf 8f6f 	isb	sy
   142be:	e009      	b.n	142d4 <xQueueGenericReset+0xa0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   142c0:	9b03      	ldr	r3, [sp, #12]
   142c2:	3310      	adds	r3, #16
   142c4:	4618      	mov	r0, r3
   142c6:	f7ff f879 	bl	133bc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   142ca:	9b03      	ldr	r3, [sp, #12]
   142cc:	3324      	adds	r3, #36	; 0x24
   142ce:	4618      	mov	r0, r3
   142d0:	f7ff f874 	bl	133bc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   142d4:	f000 fbca 	bl	14a6c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   142d8:	2301      	movs	r3, #1
}
   142da:	4618      	mov	r0, r3
   142dc:	b005      	add	sp, #20
   142de:	f85d fb04 	ldr.w	pc, [sp], #4
   142e2:	bf00      	nop
   142e4:	e000ed04 	.word	0xe000ed04

000142e8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
   142e8:	b500      	push	{lr}
   142ea:	b08b      	sub	sp, #44	; 0x2c
   142ec:	9005      	str	r0, [sp, #20]
   142ee:	9104      	str	r1, [sp, #16]
   142f0:	4613      	mov	r3, r2
   142f2:	f88d 300f 	strb.w	r3, [sp, #15]
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
   142f6:	9b04      	ldr	r3, [sp, #16]
   142f8:	2b00      	cmp	r3, #0
   142fa:	d102      	bne.n	14302 <xQueueGenericCreate+0x1a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
   142fc:	2300      	movs	r3, #0
   142fe:	9309      	str	r3, [sp, #36]	; 0x24
   14300:	e004      	b.n	1430c <xQueueGenericCreate+0x24>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   14302:	9b05      	ldr	r3, [sp, #20]
   14304:	9a04      	ldr	r2, [sp, #16]
   14306:	fb02 f303 	mul.w	r3, r2, r3
   1430a:	9309      	str	r3, [sp, #36]	; 0x24
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   1430c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1430e:	3350      	adds	r3, #80	; 0x50
   14310:	4618      	mov	r0, r3
   14312:	f000 fc23 	bl	14b5c <pvPortMalloc>
   14316:	9008      	str	r0, [sp, #32]

		if( pxNewQueue != NULL )
   14318:	9b08      	ldr	r3, [sp, #32]
   1431a:	2b00      	cmp	r3, #0
   1431c:	d010      	beq.n	14340 <xQueueGenericCreate+0x58>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   1431e:	9b08      	ldr	r3, [sp, #32]
   14320:	3350      	adds	r3, #80	; 0x50
   14322:	9307      	str	r3, [sp, #28]
			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
   14324:	9b08      	ldr	r3, [sp, #32]
   14326:	2200      	movs	r2, #0
   14328:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   1432c:	f89d 200f 	ldrb.w	r2, [sp, #15]
   14330:	9b08      	ldr	r3, [sp, #32]
   14332:	9300      	str	r3, [sp, #0]
   14334:	4613      	mov	r3, r2
   14336:	9a07      	ldr	r2, [sp, #28]
   14338:	9904      	ldr	r1, [sp, #16]
   1433a:	9805      	ldr	r0, [sp, #20]
   1433c:	f000 f805 	bl	1434a <prvInitialiseNewQueue>
		else
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
   14340:	9b08      	ldr	r3, [sp, #32]
	}
   14342:	4618      	mov	r0, r3
   14344:	b00b      	add	sp, #44	; 0x2c
   14346:	f85d fb04 	ldr.w	pc, [sp], #4

0001434a <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
   1434a:	b500      	push	{lr}
   1434c:	b085      	sub	sp, #20
   1434e:	9003      	str	r0, [sp, #12]
   14350:	9102      	str	r1, [sp, #8]
   14352:	9201      	str	r2, [sp, #4]
   14354:	f88d 3003 	strb.w	r3, [sp, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
   14358:	9b02      	ldr	r3, [sp, #8]
   1435a:	2b00      	cmp	r3, #0
   1435c:	d103      	bne.n	14366 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   1435e:	9b06      	ldr	r3, [sp, #24]
   14360:	9a06      	ldr	r2, [sp, #24]
   14362:	601a      	str	r2, [r3, #0]
   14364:	e002      	b.n	1436c <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   14366:	9b06      	ldr	r3, [sp, #24]
   14368:	9a01      	ldr	r2, [sp, #4]
   1436a:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
   1436c:	9b06      	ldr	r3, [sp, #24]
   1436e:	9a03      	ldr	r2, [sp, #12]
   14370:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   14372:	9b06      	ldr	r3, [sp, #24]
   14374:	9a02      	ldr	r2, [sp, #8]
   14376:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   14378:	2101      	movs	r1, #1
   1437a:	9806      	ldr	r0, [sp, #24]
   1437c:	f7ff ff5a 	bl	14234 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
   14380:	9b06      	ldr	r3, [sp, #24]
   14382:	f89d 2003 	ldrb.w	r2, [sp, #3]
   14386:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
   1438a:	bf00      	nop
   1438c:	b005      	add	sp, #20
   1438e:	f85d fb04 	ldr.w	pc, [sp], #4
   14392:	Address 0x0000000000014392 is out of bounds.


00014394 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
   14394:	b500      	push	{lr}
   14396:	b08b      	sub	sp, #44	; 0x2c
   14398:	9003      	str	r0, [sp, #12]
   1439a:	9102      	str	r1, [sp, #8]
   1439c:	9201      	str	r2, [sp, #4]
   1439e:	9300      	str	r3, [sp, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   143a0:	2300      	movs	r3, #0
   143a2:	9309      	str	r3, [sp, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   143a4:	9b03      	ldr	r3, [sp, #12]
   143a6:	9308      	str	r3, [sp, #32]
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   143a8:	f000 fb4c 	bl	14a44 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   143ac:	9b08      	ldr	r3, [sp, #32]
   143ae:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   143b0:	9b08      	ldr	r3, [sp, #32]
   143b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   143b4:	429a      	cmp	r2, r3
   143b6:	d302      	bcc.n	143be <xQueueGenericSend+0x2a>
   143b8:	9b00      	ldr	r3, [sp, #0]
   143ba:	2b02      	cmp	r3, #2
   143bc:	d129      	bne.n	14412 <xQueueGenericSend+0x7e>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   143be:	9a00      	ldr	r2, [sp, #0]
   143c0:	9902      	ldr	r1, [sp, #8]
   143c2:	9808      	ldr	r0, [sp, #32]
   143c4:	f000 f9bb 	bl	1473e <prvCopyDataToQueue>
   143c8:	9007      	str	r0, [sp, #28]
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   143ca:	9b08      	ldr	r3, [sp, #32]
   143cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   143ce:	2b00      	cmp	r3, #0
   143d0:	d010      	beq.n	143f4 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   143d2:	9b08      	ldr	r3, [sp, #32]
   143d4:	3324      	adds	r3, #36	; 0x24
   143d6:	4618      	mov	r0, r3
   143d8:	f7ff fbf2 	bl	13bc0 <xTaskRemoveFromEventList>
   143dc:	4603      	mov	r3, r0
   143de:	2b00      	cmp	r3, #0
   143e0:	d013      	beq.n	1440a <xQueueGenericSend+0x76>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
   143e2:	4b3f      	ldr	r3, [pc, #252]	; (144e0 <xQueueGenericSend+0x14c>)
   143e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   143e8:	601a      	str	r2, [r3, #0]
   143ea:	f3bf 8f4f 	dsb	sy
   143ee:	f3bf 8f6f 	isb	sy
   143f2:	e00a      	b.n	1440a <xQueueGenericSend+0x76>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
   143f4:	9b07      	ldr	r3, [sp, #28]
   143f6:	2b00      	cmp	r3, #0
   143f8:	d007      	beq.n	1440a <xQueueGenericSend+0x76>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
   143fa:	4b39      	ldr	r3, [pc, #228]	; (144e0 <xQueueGenericSend+0x14c>)
   143fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   14400:	601a      	str	r2, [r3, #0]
   14402:	f3bf 8f4f 	dsb	sy
   14406:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
   1440a:	f000 fb2f 	bl	14a6c <vPortExitCritical>
				return pdPASS;
   1440e:	2301      	movs	r3, #1
   14410:	e061      	b.n	144d6 <xQueueGenericSend+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   14412:	9b01      	ldr	r3, [sp, #4]
   14414:	2b00      	cmp	r3, #0
   14416:	d103      	bne.n	14420 <xQueueGenericSend+0x8c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   14418:	f000 fb28 	bl	14a6c <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   1441c:	2300      	movs	r3, #0
   1441e:	e05a      	b.n	144d6 <xQueueGenericSend+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
   14420:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14422:	2b00      	cmp	r3, #0
   14424:	d105      	bne.n	14432 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   14426:	ab05      	add	r3, sp, #20
   14428:	4618      	mov	r0, r3
   1442a:	f7ff fc1d 	bl	13c68 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   1442e:	2301      	movs	r3, #1
   14430:	9309      	str	r3, [sp, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   14432:	f000 fb1b 	bl	14a6c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   14436:	f7ff fa07 	bl	13848 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   1443a:	f000 fb03 	bl	14a44 <vPortEnterCritical>
   1443e:	9b08      	ldr	r3, [sp, #32]
   14440:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   14444:	b25b      	sxtb	r3, r3
   14446:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1444a:	d103      	bne.n	14454 <xQueueGenericSend+0xc0>
   1444c:	9b08      	ldr	r3, [sp, #32]
   1444e:	2200      	movs	r2, #0
   14450:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   14454:	9b08      	ldr	r3, [sp, #32]
   14456:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   1445a:	b25b      	sxtb	r3, r3
   1445c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   14460:	d103      	bne.n	1446a <xQueueGenericSend+0xd6>
   14462:	9b08      	ldr	r3, [sp, #32]
   14464:	2200      	movs	r2, #0
   14466:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   1446a:	f000 faff 	bl	14a6c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1446e:	aa01      	add	r2, sp, #4
   14470:	ab05      	add	r3, sp, #20
   14472:	4611      	mov	r1, r2
   14474:	4618      	mov	r0, r3
   14476:	f7ff fc09 	bl	13c8c <xTaskCheckForTimeOut>
   1447a:	4603      	mov	r3, r0
   1447c:	2b00      	cmp	r3, #0
   1447e:	d124      	bne.n	144ca <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   14480:	9808      	ldr	r0, [sp, #32]
   14482:	f000 fa31 	bl	148e8 <prvIsQueueFull>
   14486:	4603      	mov	r3, r0
   14488:	2b00      	cmp	r3, #0
   1448a:	d018      	beq.n	144be <xQueueGenericSend+0x12a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   1448c:	9b08      	ldr	r3, [sp, #32]
   1448e:	3310      	adds	r3, #16
   14490:	9a01      	ldr	r2, [sp, #4]
   14492:	4611      	mov	r1, r2
   14494:	4618      	mov	r0, r3
   14496:	f7ff fb7d 	bl	13b94 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   1449a:	9808      	ldr	r0, [sp, #32]
   1449c:	f000 f9b8 	bl	14810 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   144a0:	f7ff f9dc 	bl	1385c <xTaskResumeAll>
   144a4:	4603      	mov	r3, r0
   144a6:	2b00      	cmp	r3, #0
   144a8:	f47f af7e 	bne.w	143a8 <xQueueGenericSend+0x14>
				{
					portYIELD_WITHIN_API();
   144ac:	4b0c      	ldr	r3, [pc, #48]	; (144e0 <xQueueGenericSend+0x14c>)
   144ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   144b2:	601a      	str	r2, [r3, #0]
   144b4:	f3bf 8f4f 	dsb	sy
   144b8:	f3bf 8f6f 	isb	sy
   144bc:	e774      	b.n	143a8 <xQueueGenericSend+0x14>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   144be:	9808      	ldr	r0, [sp, #32]
   144c0:	f000 f9a6 	bl	14810 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   144c4:	f7ff f9ca 	bl	1385c <xTaskResumeAll>
   144c8:	e76e      	b.n	143a8 <xQueueGenericSend+0x14>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   144ca:	9808      	ldr	r0, [sp, #32]
   144cc:	f000 f9a0 	bl	14810 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   144d0:	f7ff f9c4 	bl	1385c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   144d4:	2300      	movs	r3, #0
		}
	}
}
   144d6:	4618      	mov	r0, r3
   144d8:	b00b      	add	sp, #44	; 0x2c
   144da:	f85d fb04 	ldr.w	pc, [sp], #4
   144de:	bf00      	nop
   144e0:	e000ed04 	.word	0xe000ed04

000144e4 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
   144e4:	b500      	push	{lr}
   144e6:	b08b      	sub	sp, #44	; 0x2c
   144e8:	9001      	str	r0, [sp, #4]
   144ea:	9100      	str	r1, [sp, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   144ec:	9b01      	ldr	r3, [sp, #4]
   144ee:	9308      	str	r3, [sp, #32]

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
   144f0:	f3ef 8211 	mrs	r2, BASEPRI
   144f4:	f04f 0328 	mov.w	r3, #40	; 0x28
   144f8:	f383 8811 	msr	BASEPRI, r3
   144fc:	f3bf 8f6f 	isb	sy
   14500:	f3bf 8f4f 	dsb	sy
   14504:	9204      	str	r2, [sp, #16]
   14506:	9303      	str	r3, [sp, #12]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
   14508:	9b04      	ldr	r3, [sp, #16]
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1450a:	9307      	str	r3, [sp, #28]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1450c:	9b08      	ldr	r3, [sp, #32]
   1450e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   14510:	9306      	str	r3, [sp, #24]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
   14512:	9b08      	ldr	r3, [sp, #32]
   14514:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   14516:	9a06      	ldr	r2, [sp, #24]
   14518:	429a      	cmp	r2, r3
   1451a:	d22b      	bcs.n	14574 <xQueueGiveFromISR+0x90>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   1451c:	9b08      	ldr	r3, [sp, #32]
   1451e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   14522:	f88d 3017 	strb.w	r3, [sp, #23]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   14526:	9b06      	ldr	r3, [sp, #24]
   14528:	1c5a      	adds	r2, r3, #1
   1452a:	9b08      	ldr	r3, [sp, #32]
   1452c:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   1452e:	f99d 3017 	ldrsb.w	r3, [sp, #23]
   14532:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   14536:	d112      	bne.n	1455e <xQueueGiveFromISR+0x7a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   14538:	9b08      	ldr	r3, [sp, #32]
   1453a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1453c:	2b00      	cmp	r3, #0
   1453e:	d016      	beq.n	1456e <xQueueGiveFromISR+0x8a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   14540:	9b08      	ldr	r3, [sp, #32]
   14542:	3324      	adds	r3, #36	; 0x24
   14544:	4618      	mov	r0, r3
   14546:	f7ff fb3b 	bl	13bc0 <xTaskRemoveFromEventList>
   1454a:	4603      	mov	r3, r0
   1454c:	2b00      	cmp	r3, #0
   1454e:	d00e      	beq.n	1456e <xQueueGiveFromISR+0x8a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   14550:	9b00      	ldr	r3, [sp, #0]
   14552:	2b00      	cmp	r3, #0
   14554:	d00b      	beq.n	1456e <xQueueGiveFromISR+0x8a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   14556:	9b00      	ldr	r3, [sp, #0]
   14558:	2201      	movs	r2, #1
   1455a:	601a      	str	r2, [r3, #0]
   1455c:	e007      	b.n	1456e <xQueueGiveFromISR+0x8a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   1455e:	f89d 3017 	ldrb.w	r3, [sp, #23]
   14562:	3301      	adds	r3, #1
   14564:	b2db      	uxtb	r3, r3
   14566:	b25a      	sxtb	r2, r3
   14568:	9b08      	ldr	r3, [sp, #32]
   1456a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
   1456e:	2301      	movs	r3, #1
   14570:	9309      	str	r3, [sp, #36]	; 0x24
   14572:	e001      	b.n	14578 <xQueueGiveFromISR+0x94>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   14574:	2300      	movs	r3, #0
   14576:	9309      	str	r3, [sp, #36]	; 0x24
   14578:	9b07      	ldr	r3, [sp, #28]
   1457a:	9302      	str	r3, [sp, #8]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   1457c:	9b02      	ldr	r3, [sp, #8]
   1457e:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   14582:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
   14584:	4618      	mov	r0, r3
   14586:	b00b      	add	sp, #44	; 0x2c
   14588:	f85d fb04 	ldr.w	pc, [sp], #4

0001458c <xQueueSemaphoreTake>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
   1458c:	b500      	push	{lr}
   1458e:	b08b      	sub	sp, #44	; 0x2c
   14590:	9001      	str	r0, [sp, #4]
   14592:	9100      	str	r1, [sp, #0]
BaseType_t xEntryTimeSet = pdFALSE;
   14594:	2300      	movs	r3, #0
   14596:	9309      	str	r3, [sp, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   14598:	9b01      	ldr	r3, [sp, #4]
   1459a:	9307      	str	r3, [sp, #28]

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
   1459c:	2300      	movs	r3, #0
   1459e:	9308      	str	r3, [sp, #32]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   145a0:	f000 fa50 	bl	14a44 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   145a4:	9b07      	ldr	r3, [sp, #28]
   145a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   145a8:	9306      	str	r3, [sp, #24]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   145aa:	9b06      	ldr	r3, [sp, #24]
   145ac:	2b00      	cmp	r3, #0
   145ae:	d024      	beq.n	145fa <xQueueSemaphoreTake+0x6e>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   145b0:	9b06      	ldr	r3, [sp, #24]
   145b2:	1e5a      	subs	r2, r3, #1
   145b4:	9b07      	ldr	r3, [sp, #28]
   145b6:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   145b8:	9b07      	ldr	r3, [sp, #28]
   145ba:	681b      	ldr	r3, [r3, #0]
   145bc:	2b00      	cmp	r3, #0
   145be:	d104      	bne.n	145ca <xQueueSemaphoreTake+0x3e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
   145c0:	f7ff fdc4 	bl	1414c <pvTaskIncrementMutexHeldCount>
   145c4:	4602      	mov	r2, r0
   145c6:	9b07      	ldr	r3, [sp, #28]
   145c8:	605a      	str	r2, [r3, #4]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   145ca:	9b07      	ldr	r3, [sp, #28]
   145cc:	691b      	ldr	r3, [r3, #16]
   145ce:	2b00      	cmp	r3, #0
   145d0:	d00f      	beq.n	145f2 <xQueueSemaphoreTake+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   145d2:	9b07      	ldr	r3, [sp, #28]
   145d4:	3310      	adds	r3, #16
   145d6:	4618      	mov	r0, r3
   145d8:	f7ff faf2 	bl	13bc0 <xTaskRemoveFromEventList>
   145dc:	4603      	mov	r3, r0
   145de:	2b00      	cmp	r3, #0
   145e0:	d007      	beq.n	145f2 <xQueueSemaphoreTake+0x66>
					{
						queueYIELD_IF_USING_PREEMPTION();
   145e2:	4b4c      	ldr	r3, [pc, #304]	; (14714 <xQueueSemaphoreTake+0x188>)
   145e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   145e8:	601a      	str	r2, [r3, #0]
   145ea:	f3bf 8f4f 	dsb	sy
   145ee:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   145f2:	f000 fa3b 	bl	14a6c <vPortExitCritical>
				return pdPASS;
   145f6:	2301      	movs	r3, #1
   145f8:	e087      	b.n	1470a <xQueueSemaphoreTake+0x17e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   145fa:	9b00      	ldr	r3, [sp, #0]
   145fc:	2b00      	cmp	r3, #0
   145fe:	d103      	bne.n	14608 <xQueueSemaphoreTake+0x7c>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
   14600:	f000 fa34 	bl	14a6c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   14604:	2300      	movs	r3, #0
   14606:	e080      	b.n	1470a <xQueueSemaphoreTake+0x17e>
				}
				else if( xEntryTimeSet == pdFALSE )
   14608:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1460a:	2b00      	cmp	r3, #0
   1460c:	d105      	bne.n	1461a <xQueueSemaphoreTake+0x8e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   1460e:	ab03      	add	r3, sp, #12
   14610:	4618      	mov	r0, r3
   14612:	f7ff fb29 	bl	13c68 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   14616:	2301      	movs	r3, #1
   14618:	9309      	str	r3, [sp, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   1461a:	f000 fa27 	bl	14a6c <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
   1461e:	f7ff f913 	bl	13848 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   14622:	f000 fa0f 	bl	14a44 <vPortEnterCritical>
   14626:	9b07      	ldr	r3, [sp, #28]
   14628:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   1462c:	b25b      	sxtb	r3, r3
   1462e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   14632:	d103      	bne.n	1463c <xQueueSemaphoreTake+0xb0>
   14634:	9b07      	ldr	r3, [sp, #28]
   14636:	2200      	movs	r2, #0
   14638:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   1463c:	9b07      	ldr	r3, [sp, #28]
   1463e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   14642:	b25b      	sxtb	r3, r3
   14644:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   14648:	d103      	bne.n	14652 <xQueueSemaphoreTake+0xc6>
   1464a:	9b07      	ldr	r3, [sp, #28]
   1464c:	2200      	movs	r2, #0
   1464e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   14652:	f000 fa0b 	bl	14a6c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   14656:	466a      	mov	r2, sp
   14658:	ab03      	add	r3, sp, #12
   1465a:	4611      	mov	r1, r2
   1465c:	4618      	mov	r0, r3
   1465e:	f7ff fb15 	bl	13c8c <xTaskCheckForTimeOut>
   14662:	4603      	mov	r3, r0
   14664:	2b00      	cmp	r3, #0
   14666:	d132      	bne.n	146ce <xQueueSemaphoreTake+0x142>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   14668:	9807      	ldr	r0, [sp, #28]
   1466a:	f000 f928 	bl	148be <prvIsQueueEmpty>
   1466e:	4603      	mov	r3, r0
   14670:	2b00      	cmp	r3, #0
   14672:	d026      	beq.n	146c2 <xQueueSemaphoreTake+0x136>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   14674:	9b07      	ldr	r3, [sp, #28]
   14676:	681b      	ldr	r3, [r3, #0]
   14678:	2b00      	cmp	r3, #0
   1467a:	d109      	bne.n	14690 <xQueueSemaphoreTake+0x104>
					{
						taskENTER_CRITICAL();
   1467c:	f000 f9e2 	bl	14a44 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   14680:	9b07      	ldr	r3, [sp, #28]
   14682:	685b      	ldr	r3, [r3, #4]
   14684:	4618      	mov	r0, r3
   14686:	f7ff fbfd 	bl	13e84 <xTaskPriorityInherit>
   1468a:	9008      	str	r0, [sp, #32]
						}
						taskEXIT_CRITICAL();
   1468c:	f000 f9ee 	bl	14a6c <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   14690:	9b07      	ldr	r3, [sp, #28]
   14692:	3324      	adds	r3, #36	; 0x24
   14694:	9a00      	ldr	r2, [sp, #0]
   14696:	4611      	mov	r1, r2
   14698:	4618      	mov	r0, r3
   1469a:	f7ff fa7b 	bl	13b94 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   1469e:	9807      	ldr	r0, [sp, #28]
   146a0:	f000 f8b6 	bl	14810 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   146a4:	f7ff f8da 	bl	1385c <xTaskResumeAll>
   146a8:	4603      	mov	r3, r0
   146aa:	2b00      	cmp	r3, #0
   146ac:	f47f af78 	bne.w	145a0 <xQueueSemaphoreTake+0x14>
				{
					portYIELD_WITHIN_API();
   146b0:	4b18      	ldr	r3, [pc, #96]	; (14714 <xQueueSemaphoreTake+0x188>)
   146b2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   146b6:	601a      	str	r2, [r3, #0]
   146b8:	f3bf 8f4f 	dsb	sy
   146bc:	f3bf 8f6f 	isb	sy
   146c0:	e76e      	b.n	145a0 <xQueueSemaphoreTake+0x14>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
   146c2:	9807      	ldr	r0, [sp, #28]
   146c4:	f000 f8a4 	bl	14810 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   146c8:	f7ff f8c8 	bl	1385c <xTaskResumeAll>
   146cc:	e768      	b.n	145a0 <xQueueSemaphoreTake+0x14>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
   146ce:	9807      	ldr	r0, [sp, #28]
   146d0:	f000 f89e 	bl	14810 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   146d4:	f7ff f8c2 	bl	1385c <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   146d8:	9807      	ldr	r0, [sp, #28]
   146da:	f000 f8f0 	bl	148be <prvIsQueueEmpty>
   146de:	4603      	mov	r3, r0
   146e0:	2b00      	cmp	r3, #0
   146e2:	f43f af5d 	beq.w	145a0 <xQueueSemaphoreTake+0x14>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
   146e6:	9b08      	ldr	r3, [sp, #32]
   146e8:	2b00      	cmp	r3, #0
   146ea:	d00d      	beq.n	14708 <xQueueSemaphoreTake+0x17c>
					{
						taskENTER_CRITICAL();
   146ec:	f000 f9aa 	bl	14a44 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
   146f0:	9807      	ldr	r0, [sp, #28]
   146f2:	f000 f811 	bl	14718 <prvGetDisinheritPriorityAfterTimeout>
   146f6:	9005      	str	r0, [sp, #20]
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
   146f8:	9b07      	ldr	r3, [sp, #28]
   146fa:	685b      	ldr	r3, [r3, #4]
   146fc:	9905      	ldr	r1, [sp, #20]
   146fe:	4618      	mov	r0, r3
   14700:	f7ff fca8 	bl	14054 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
   14704:	f000 f9b2 	bl	14a6c <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   14708:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
   1470a:	4618      	mov	r0, r3
   1470c:	b00b      	add	sp, #44	; 0x2c
   1470e:	f85d fb04 	ldr.w	pc, [sp], #4
   14712:	bf00      	nop
   14714:	e000ed04 	.word	0xe000ed04

00014718 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
   14718:	b084      	sub	sp, #16
   1471a:	9001      	str	r0, [sp, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
   1471c:	9b01      	ldr	r3, [sp, #4]
   1471e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   14720:	2b00      	cmp	r3, #0
   14722:	d006      	beq.n	14732 <prvGetDisinheritPriorityAfterTimeout+0x1a>
		{
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   14724:	9b01      	ldr	r3, [sp, #4]
   14726:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   14728:	681b      	ldr	r3, [r3, #0]
   1472a:	f1c3 0305 	rsb	r3, r3, #5
   1472e:	9303      	str	r3, [sp, #12]
   14730:	e001      	b.n	14736 <prvGetDisinheritPriorityAfterTimeout+0x1e>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   14732:	2300      	movs	r3, #0
   14734:	9303      	str	r3, [sp, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
   14736:	9b03      	ldr	r3, [sp, #12]
	}
   14738:	4618      	mov	r0, r3
   1473a:	b004      	add	sp, #16
   1473c:	4770      	bx	lr

0001473e <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   1473e:	b500      	push	{lr}
   14740:	b087      	sub	sp, #28
   14742:	9003      	str	r0, [sp, #12]
   14744:	9102      	str	r1, [sp, #8]
   14746:	9201      	str	r2, [sp, #4]
BaseType_t xReturn = pdFALSE;
   14748:	2300      	movs	r3, #0
   1474a:	9305      	str	r3, [sp, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1474c:	9b03      	ldr	r3, [sp, #12]
   1474e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   14750:	9304      	str	r3, [sp, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   14752:	9b03      	ldr	r3, [sp, #12]
   14754:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   14756:	2b00      	cmp	r3, #0
   14758:	d10d      	bne.n	14776 <prvCopyDataToQueue+0x38>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1475a:	9b03      	ldr	r3, [sp, #12]
   1475c:	681b      	ldr	r3, [r3, #0]
   1475e:	2b00      	cmp	r3, #0
   14760:	d14d      	bne.n	147fe <prvCopyDataToQueue+0xc0>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   14762:	9b03      	ldr	r3, [sp, #12]
   14764:	685b      	ldr	r3, [r3, #4]
   14766:	4618      	mov	r0, r3
   14768:	f7ff fc10 	bl	13f8c <xTaskPriorityDisinherit>
   1476c:	9005      	str	r0, [sp, #20]
				pxQueue->pxMutexHolder = NULL;
   1476e:	9b03      	ldr	r3, [sp, #12]
   14770:	2200      	movs	r2, #0
   14772:	605a      	str	r2, [r3, #4]
   14774:	e043      	b.n	147fe <prvCopyDataToQueue+0xc0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   14776:	9b01      	ldr	r3, [sp, #4]
   14778:	2b00      	cmp	r3, #0
   1477a:	d119      	bne.n	147b0 <prvCopyDataToQueue+0x72>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   1477c:	9b03      	ldr	r3, [sp, #12]
   1477e:	6898      	ldr	r0, [r3, #8]
   14780:	9b03      	ldr	r3, [sp, #12]
   14782:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   14784:	461a      	mov	r2, r3
   14786:	9902      	ldr	r1, [sp, #8]
   14788:	f004 f9f4 	bl	18b74 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   1478c:	9b03      	ldr	r3, [sp, #12]
   1478e:	689a      	ldr	r2, [r3, #8]
   14790:	9b03      	ldr	r3, [sp, #12]
   14792:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   14794:	441a      	add	r2, r3
   14796:	9b03      	ldr	r3, [sp, #12]
   14798:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1479a:	9b03      	ldr	r3, [sp, #12]
   1479c:	689a      	ldr	r2, [r3, #8]
   1479e:	9b03      	ldr	r3, [sp, #12]
   147a0:	685b      	ldr	r3, [r3, #4]
   147a2:	429a      	cmp	r2, r3
   147a4:	d32b      	bcc.n	147fe <prvCopyDataToQueue+0xc0>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   147a6:	9b03      	ldr	r3, [sp, #12]
   147a8:	681a      	ldr	r2, [r3, #0]
   147aa:	9b03      	ldr	r3, [sp, #12]
   147ac:	609a      	str	r2, [r3, #8]
   147ae:	e026      	b.n	147fe <prvCopyDataToQueue+0xc0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   147b0:	9b03      	ldr	r3, [sp, #12]
   147b2:	68d8      	ldr	r0, [r3, #12]
   147b4:	9b03      	ldr	r3, [sp, #12]
   147b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   147b8:	461a      	mov	r2, r3
   147ba:	9902      	ldr	r1, [sp, #8]
   147bc:	f004 f9da 	bl	18b74 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   147c0:	9b03      	ldr	r3, [sp, #12]
   147c2:	68da      	ldr	r2, [r3, #12]
   147c4:	9b03      	ldr	r3, [sp, #12]
   147c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   147c8:	425b      	negs	r3, r3
   147ca:	441a      	add	r2, r3
   147cc:	9b03      	ldr	r3, [sp, #12]
   147ce:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   147d0:	9b03      	ldr	r3, [sp, #12]
   147d2:	68da      	ldr	r2, [r3, #12]
   147d4:	9b03      	ldr	r3, [sp, #12]
   147d6:	681b      	ldr	r3, [r3, #0]
   147d8:	429a      	cmp	r2, r3
   147da:	d207      	bcs.n	147ec <prvCopyDataToQueue+0xae>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   147dc:	9b03      	ldr	r3, [sp, #12]
   147de:	685a      	ldr	r2, [r3, #4]
   147e0:	9b03      	ldr	r3, [sp, #12]
   147e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   147e4:	425b      	negs	r3, r3
   147e6:	441a      	add	r2, r3
   147e8:	9b03      	ldr	r3, [sp, #12]
   147ea:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   147ec:	9b01      	ldr	r3, [sp, #4]
   147ee:	2b02      	cmp	r3, #2
   147f0:	d105      	bne.n	147fe <prvCopyDataToQueue+0xc0>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   147f2:	9b04      	ldr	r3, [sp, #16]
   147f4:	2b00      	cmp	r3, #0
   147f6:	d002      	beq.n	147fe <prvCopyDataToQueue+0xc0>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   147f8:	9b04      	ldr	r3, [sp, #16]
   147fa:	3b01      	subs	r3, #1
   147fc:	9304      	str	r3, [sp, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   147fe:	9b04      	ldr	r3, [sp, #16]
   14800:	1c5a      	adds	r2, r3, #1
   14802:	9b03      	ldr	r3, [sp, #12]
   14804:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   14806:	9b05      	ldr	r3, [sp, #20]
}
   14808:	4618      	mov	r0, r3
   1480a:	b007      	add	sp, #28
   1480c:	f85d fb04 	ldr.w	pc, [sp], #4

00014810 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   14810:	b500      	push	{lr}
   14812:	b085      	sub	sp, #20
   14814:	9001      	str	r0, [sp, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   14816:	f000 f915 	bl	14a44 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   1481a:	9b01      	ldr	r3, [sp, #4]
   1481c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   14820:	f88d 300f 	strb.w	r3, [sp, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   14824:	e013      	b.n	1484e <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   14826:	9b01      	ldr	r3, [sp, #4]
   14828:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1482a:	2b00      	cmp	r3, #0
   1482c:	d014      	beq.n	14858 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1482e:	9b01      	ldr	r3, [sp, #4]
   14830:	3324      	adds	r3, #36	; 0x24
   14832:	4618      	mov	r0, r3
   14834:	f7ff f9c4 	bl	13bc0 <xTaskRemoveFromEventList>
   14838:	4603      	mov	r3, r0
   1483a:	2b00      	cmp	r3, #0
   1483c:	d001      	beq.n	14842 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   1483e:	f7ff fa6b 	bl	13d18 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   14842:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14846:	3b01      	subs	r3, #1
   14848:	b2db      	uxtb	r3, r3
   1484a:	f88d 300f 	strb.w	r3, [sp, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
   1484e:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   14852:	2b00      	cmp	r3, #0
   14854:	dce7      	bgt.n	14826 <prvUnlockQueue+0x16>
   14856:	e000      	b.n	1485a <prvUnlockQueue+0x4a>
					break;
   14858:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
   1485a:	9b01      	ldr	r3, [sp, #4]
   1485c:	22ff      	movs	r2, #255	; 0xff
   1485e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
   14862:	f000 f903 	bl	14a6c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   14866:	f000 f8ed 	bl	14a44 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   1486a:	9b01      	ldr	r3, [sp, #4]
   1486c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   14870:	f88d 300e 	strb.w	r3, [sp, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   14874:	e013      	b.n	1489e <prvUnlockQueue+0x8e>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   14876:	9b01      	ldr	r3, [sp, #4]
   14878:	691b      	ldr	r3, [r3, #16]
   1487a:	2b00      	cmp	r3, #0
   1487c:	d014      	beq.n	148a8 <prvUnlockQueue+0x98>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1487e:	9b01      	ldr	r3, [sp, #4]
   14880:	3310      	adds	r3, #16
   14882:	4618      	mov	r0, r3
   14884:	f7ff f99c 	bl	13bc0 <xTaskRemoveFromEventList>
   14888:	4603      	mov	r3, r0
   1488a:	2b00      	cmp	r3, #0
   1488c:	d001      	beq.n	14892 <prvUnlockQueue+0x82>
				{
					vTaskMissedYield();
   1488e:	f7ff fa43 	bl	13d18 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   14892:	f89d 300e 	ldrb.w	r3, [sp, #14]
   14896:	3b01      	subs	r3, #1
   14898:	b2db      	uxtb	r3, r3
   1489a:	f88d 300e 	strb.w	r3, [sp, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
   1489e:	f99d 300e 	ldrsb.w	r3, [sp, #14]
   148a2:	2b00      	cmp	r3, #0
   148a4:	dce7      	bgt.n	14876 <prvUnlockQueue+0x66>
   148a6:	e000      	b.n	148aa <prvUnlockQueue+0x9a>
			}
			else
			{
				break;
   148a8:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   148aa:	9b01      	ldr	r3, [sp, #4]
   148ac:	22ff      	movs	r2, #255	; 0xff
   148ae:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   148b2:	f000 f8db 	bl	14a6c <vPortExitCritical>
}
   148b6:	bf00      	nop
   148b8:	b005      	add	sp, #20
   148ba:	f85d fb04 	ldr.w	pc, [sp], #4

000148be <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   148be:	b500      	push	{lr}
   148c0:	b085      	sub	sp, #20
   148c2:	9001      	str	r0, [sp, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   148c4:	f000 f8be 	bl	14a44 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   148c8:	9b01      	ldr	r3, [sp, #4]
   148ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   148cc:	2b00      	cmp	r3, #0
   148ce:	d102      	bne.n	148d6 <prvIsQueueEmpty+0x18>
		{
			xReturn = pdTRUE;
   148d0:	2301      	movs	r3, #1
   148d2:	9303      	str	r3, [sp, #12]
   148d4:	e001      	b.n	148da <prvIsQueueEmpty+0x1c>
		}
		else
		{
			xReturn = pdFALSE;
   148d6:	2300      	movs	r3, #0
   148d8:	9303      	str	r3, [sp, #12]
		}
	}
	taskEXIT_CRITICAL();
   148da:	f000 f8c7 	bl	14a6c <vPortExitCritical>

	return xReturn;
   148de:	9b03      	ldr	r3, [sp, #12]
}
   148e0:	4618      	mov	r0, r3
   148e2:	b005      	add	sp, #20
   148e4:	f85d fb04 	ldr.w	pc, [sp], #4

000148e8 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   148e8:	b500      	push	{lr}
   148ea:	b085      	sub	sp, #20
   148ec:	9001      	str	r0, [sp, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   148ee:	f000 f8a9 	bl	14a44 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   148f2:	9b01      	ldr	r3, [sp, #4]
   148f4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   148f6:	9b01      	ldr	r3, [sp, #4]
   148f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   148fa:	429a      	cmp	r2, r3
   148fc:	d102      	bne.n	14904 <prvIsQueueFull+0x1c>
		{
			xReturn = pdTRUE;
   148fe:	2301      	movs	r3, #1
   14900:	9303      	str	r3, [sp, #12]
   14902:	e001      	b.n	14908 <prvIsQueueFull+0x20>
		}
		else
		{
			xReturn = pdFALSE;
   14904:	2300      	movs	r3, #0
   14906:	9303      	str	r3, [sp, #12]
		}
	}
	taskEXIT_CRITICAL();
   14908:	f000 f8b0 	bl	14a6c <vPortExitCritical>

	return xReturn;
   1490c:	9b03      	ldr	r3, [sp, #12]
}
   1490e:	4618      	mov	r0, r3
   14910:	b005      	add	sp, #20
   14912:	f85d fb04 	ldr.w	pc, [sp], #4
   14916:	Address 0x0000000000014916 is out of bounds.


00014918 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   14918:	b084      	sub	sp, #16
   1491a:	9003      	str	r0, [sp, #12]
   1491c:	9102      	str	r1, [sp, #8]
   1491e:	9201      	str	r2, [sp, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
   14920:	9b03      	ldr	r3, [sp, #12]
   14922:	3b04      	subs	r3, #4
   14924:	9303      	str	r3, [sp, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   14926:	9b03      	ldr	r3, [sp, #12]
   14928:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   1492c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   1492e:	9b03      	ldr	r3, [sp, #12]
   14930:	3b04      	subs	r3, #4
   14932:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   14934:	9b02      	ldr	r3, [sp, #8]
   14936:	f023 0201 	bic.w	r2, r3, #1
   1493a:	9b03      	ldr	r3, [sp, #12]
   1493c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   1493e:	9b03      	ldr	r3, [sp, #12]
   14940:	3b04      	subs	r3, #4
   14942:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   14944:	4a0b      	ldr	r2, [pc, #44]	; (14974 <pxPortInitialiseStack+0x5c>)
   14946:	9b03      	ldr	r3, [sp, #12]
   14948:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   1494a:	9b03      	ldr	r3, [sp, #12]
   1494c:	3b14      	subs	r3, #20
   1494e:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   14950:	9a01      	ldr	r2, [sp, #4]
   14952:	9b03      	ldr	r3, [sp, #12]
   14954:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
   14956:	9b03      	ldr	r3, [sp, #12]
   14958:	3b04      	subs	r3, #4
   1495a:	9303      	str	r3, [sp, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   1495c:	9b03      	ldr	r3, [sp, #12]
   1495e:	f06f 0202 	mvn.w	r2, #2
   14962:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   14964:	9b03      	ldr	r3, [sp, #12]
   14966:	3b20      	subs	r3, #32
   14968:	9303      	str	r3, [sp, #12]

	return pxTopOfStack;
   1496a:	9b03      	ldr	r3, [sp, #12]
}
   1496c:	4618      	mov	r0, r3
   1496e:	b004      	add	sp, #16
   14970:	4770      	bx	lr
   14972:	bf00      	nop
   14974:	00014979 	.word	0x00014979

00014978 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   14978:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
   1497a:	2300      	movs	r3, #0
   1497c:	9300      	str	r3, [sp, #0]
	__asm volatile
   1497e:	f04f 0328 	mov.w	r3, #40	; 0x28
   14982:	f383 8811 	msr	BASEPRI, r3
   14986:	f3bf 8f6f 	isb	sy
   1498a:	f3bf 8f4f 	dsb	sy
   1498e:	9301      	str	r3, [sp, #4]

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   14990:	bf00      	nop
   14992:	9b00      	ldr	r3, [sp, #0]
   14994:	2b00      	cmp	r3, #0
   14996:	d0fc      	beq.n	14992 <prvTaskExitError+0x1a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   14998:	bf00      	nop
   1499a:	b002      	add	sp, #8
   1499c:	4770      	bx	lr
   1499e:	Address 0x000000000001499e is out of bounds.


000149a0 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   149a0:	4b07      	ldr	r3, [pc, #28]	; (149c0 <pxCurrentTCBConst2>)
   149a2:	6819      	ldr	r1, [r3, #0]
   149a4:	6808      	ldr	r0, [r1, #0]
   149a6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   149aa:	f380 8809 	msr	PSP, r0
   149ae:	f3bf 8f6f 	isb	sy
   149b2:	f04f 0000 	mov.w	r0, #0
   149b6:	f380 8811 	msr	BASEPRI, r0
   149ba:	4770      	bx	lr
   149bc:	f3af 8000 	nop.w

000149c0 <pxCurrentTCBConst2>:
   149c0:	100006c0 	.word	0x100006c0
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   149c4:	bf00      	nop
   149c6:	bf00      	nop

000149c8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
   149c8:	4808      	ldr	r0, [pc, #32]	; (149ec <prvPortStartFirstTask+0x24>)
   149ca:	6800      	ldr	r0, [r0, #0]
   149cc:	6800      	ldr	r0, [r0, #0]
   149ce:	f380 8808 	msr	MSP, r0
   149d2:	f04f 0000 	mov.w	r0, #0
   149d6:	f380 8814 	msr	CONTROL, r0
   149da:	b662      	cpsie	i
   149dc:	b661      	cpsie	f
   149de:	f3bf 8f4f 	dsb	sy
   149e2:	f3bf 8f6f 	isb	sy
   149e6:	df00      	svc	0
   149e8:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
   149ea:	bf00      	nop
   149ec:	e000ed08 	.word	0xe000ed08

000149f0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   149f0:	b508      	push	{r3, lr}
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   149f2:	4b11      	ldr	r3, [pc, #68]	; (14a38 <xPortStartScheduler+0x48>)
   149f4:	681b      	ldr	r3, [r3, #0]
   149f6:	4a10      	ldr	r2, [pc, #64]	; (14a38 <xPortStartScheduler+0x48>)
   149f8:	f443 0378 	orr.w	r3, r3, #16252928	; 0xf80000
   149fc:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   149fe:	4b0e      	ldr	r3, [pc, #56]	; (14a38 <xPortStartScheduler+0x48>)
   14a00:	681b      	ldr	r3, [r3, #0]
   14a02:	4a0d      	ldr	r2, [pc, #52]	; (14a38 <xPortStartScheduler+0x48>)
   14a04:	f043 4378 	orr.w	r3, r3, #4160749568	; 0xf8000000
   14a08:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   14a0a:	f7fd ff51 	bl	128b0 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   14a0e:	4b0b      	ldr	r3, [pc, #44]	; (14a3c <xPortStartScheduler+0x4c>)
   14a10:	2200      	movs	r2, #0
   14a12:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
   14a14:	f000 f898 	bl	14b48 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   14a18:	4b09      	ldr	r3, [pc, #36]	; (14a40 <xPortStartScheduler+0x50>)
   14a1a:	681b      	ldr	r3, [r3, #0]
   14a1c:	4a08      	ldr	r2, [pc, #32]	; (14a40 <xPortStartScheduler+0x50>)
   14a1e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   14a22:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   14a24:	f7ff ffd0 	bl	149c8 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   14a28:	f7ff f850 	bl	13acc <vTaskSwitchContext>
	prvTaskExitError();
   14a2c:	f7ff ffa4 	bl	14978 <prvTaskExitError>

	/* Should not get here! */
	return 0;
   14a30:	2300      	movs	r3, #0
}
   14a32:	4618      	mov	r0, r3
   14a34:	bd08      	pop	{r3, pc}
   14a36:	bf00      	nop
   14a38:	e000ed20 	.word	0xe000ed20
   14a3c:	100001f0 	.word	0x100001f0
   14a40:	e000ef34 	.word	0xe000ef34

00014a44 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   14a44:	b082      	sub	sp, #8
   14a46:	f04f 0328 	mov.w	r3, #40	; 0x28
   14a4a:	f383 8811 	msr	BASEPRI, r3
   14a4e:	f3bf 8f6f 	isb	sy
   14a52:	f3bf 8f4f 	dsb	sy
   14a56:	9301      	str	r3, [sp, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   14a58:	4b03      	ldr	r3, [pc, #12]	; (14a68 <vPortEnterCritical+0x24>)
   14a5a:	681b      	ldr	r3, [r3, #0]
   14a5c:	3301      	adds	r3, #1
   14a5e:	4a02      	ldr	r2, [pc, #8]	; (14a68 <vPortEnterCritical+0x24>)
   14a60:	6013      	str	r3, [r2, #0]
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
   14a62:	bf00      	nop
   14a64:	b002      	add	sp, #8
   14a66:	4770      	bx	lr
   14a68:	100001f0 	.word	0x100001f0

00014a6c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   14a6c:	b082      	sub	sp, #8
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
   14a6e:	4b08      	ldr	r3, [pc, #32]	; (14a90 <vPortExitCritical+0x24>)
   14a70:	681b      	ldr	r3, [r3, #0]
   14a72:	3b01      	subs	r3, #1
   14a74:	4a06      	ldr	r2, [pc, #24]	; (14a90 <vPortExitCritical+0x24>)
   14a76:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   14a78:	4b05      	ldr	r3, [pc, #20]	; (14a90 <vPortExitCritical+0x24>)
   14a7a:	681b      	ldr	r3, [r3, #0]
   14a7c:	2b00      	cmp	r3, #0
   14a7e:	d104      	bne.n	14a8a <vPortExitCritical+0x1e>
   14a80:	2300      	movs	r3, #0
   14a82:	9301      	str	r3, [sp, #4]
	__asm volatile
   14a84:	9b01      	ldr	r3, [sp, #4]
   14a86:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
   14a8a:	bf00      	nop
   14a8c:	b002      	add	sp, #8
   14a8e:	4770      	bx	lr
   14a90:	100001f0 	.word	0x100001f0
   14a94:	ffffffff 	.word	0xffffffff
   14a98:	ffffffff 	.word	0xffffffff
   14a9c:	ffffffff 	.word	0xffffffff

00014aa0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   14aa0:	f3ef 8009 	mrs	r0, PSP
   14aa4:	f3bf 8f6f 	isb	sy
   14aa8:	4b15      	ldr	r3, [pc, #84]	; (14b00 <pxCurrentTCBConst>)
   14aaa:	681a      	ldr	r2, [r3, #0]
   14aac:	f01e 0f10 	tst.w	lr, #16
   14ab0:	bf08      	it	eq
   14ab2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   14ab6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14aba:	6010      	str	r0, [r2, #0]
   14abc:	e92d 0009 	stmdb	sp!, {r0, r3}
   14ac0:	f04f 0028 	mov.w	r0, #40	; 0x28
   14ac4:	f380 8811 	msr	BASEPRI, r0
   14ac8:	f3bf 8f4f 	dsb	sy
   14acc:	f3bf 8f6f 	isb	sy
   14ad0:	f7fe fffc 	bl	13acc <vTaskSwitchContext>
   14ad4:	f04f 0000 	mov.w	r0, #0
   14ad8:	f380 8811 	msr	BASEPRI, r0
   14adc:	bc09      	pop	{r0, r3}
   14ade:	6819      	ldr	r1, [r3, #0]
   14ae0:	6808      	ldr	r0, [r1, #0]
   14ae2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14ae6:	f01e 0f10 	tst.w	lr, #16
   14aea:	bf08      	it	eq
   14aec:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   14af0:	f380 8809 	msr	PSP, r0
   14af4:	f3bf 8f6f 	isb	sy
   14af8:	4770      	bx	lr
   14afa:	bf00      	nop
   14afc:	f3af 8000 	nop.w

00014b00 <pxCurrentTCBConst>:
   14b00:	100006c0 	.word	0x100006c0
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   14b04:	bf00      	nop
   14b06:	bf00      	nop

00014b08 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   14b08:	b500      	push	{lr}
   14b0a:	b083      	sub	sp, #12
	__asm volatile
   14b0c:	f04f 0328 	mov.w	r3, #40	; 0x28
   14b10:	f383 8811 	msr	BASEPRI, r3
   14b14:	f3bf 8f6f 	isb	sy
   14b18:	f3bf 8f4f 	dsb	sy
   14b1c:	9301      	str	r3, [sp, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   14b1e:	f7fe ff29 	bl	13974 <xTaskIncrementTick>
   14b22:	4603      	mov	r3, r0
   14b24:	2b00      	cmp	r3, #0
   14b26:	d003      	beq.n	14b30 <xPortSysTickHandler+0x28>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   14b28:	4b06      	ldr	r3, [pc, #24]	; (14b44 <xPortSysTickHandler+0x3c>)
   14b2a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   14b2e:	601a      	str	r2, [r3, #0]
   14b30:	2300      	movs	r3, #0
   14b32:	9300      	str	r3, [sp, #0]
	__asm volatile
   14b34:	9b00      	ldr	r3, [sp, #0]
   14b36:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
   14b3a:	bf00      	nop
   14b3c:	b003      	add	sp, #12
   14b3e:	f85d fb04 	ldr.w	pc, [sp], #4
   14b42:	bf00      	nop
   14b44:	e000ed04 	.word	0xe000ed04

00014b48 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   14b48:	f8df 000c 	ldr.w	r0, [pc, #12]	; 14b58 <vPortEnableVFP+0x10>
   14b4c:	6801      	ldr	r1, [r0, #0]
   14b4e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14b52:	6001      	str	r1, [r0, #0]
   14b54:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   14b56:	bf00      	nop
   14b58:	e000ed88 	.word	0xe000ed88

00014b5c <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   14b5c:	b500      	push	{lr}
   14b5e:	b085      	sub	sp, #20
   14b60:	9001      	str	r0, [sp, #4]
void *pvReturn;

	vTaskSuspendAll();
   14b62:	f7fe fe71 	bl	13848 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
   14b66:	9801      	ldr	r0, [sp, #4]
   14b68:	f003 fff4 	bl	18b54 <malloc>
   14b6c:	4603      	mov	r3, r0
   14b6e:	9303      	str	r3, [sp, #12]
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   14b70:	f7fe fe74 	bl	1385c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
   14b74:	9b03      	ldr	r3, [sp, #12]
}
   14b76:	4618      	mov	r0, r3
   14b78:	b005      	add	sp, #20
   14b7a:	f85d fb04 	ldr.w	pc, [sp], #4

00014b7e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   14b7e:	b500      	push	{lr}
   14b80:	b083      	sub	sp, #12
   14b82:	9001      	str	r0, [sp, #4]
	if( pv )
   14b84:	9b01      	ldr	r3, [sp, #4]
   14b86:	2b00      	cmp	r3, #0
   14b88:	d006      	beq.n	14b98 <vPortFree+0x1a>
	{
		vTaskSuspendAll();
   14b8a:	f7fe fe5d 	bl	13848 <vTaskSuspendAll>
		{
			free( pv );
   14b8e:	9801      	ldr	r0, [sp, #4]
   14b90:	f003 ffe8 	bl	18b64 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
   14b94:	f7fe fe62 	bl	1385c <xTaskResumeAll>
	}
}
   14b98:	bf00      	nop
   14b9a:	b003      	add	sp, #12
   14b9c:	f85d fb04 	ldr.w	pc, [sp], #4

00014ba0 <_out_null(char, void*, unsigned int, unsigned int)>:
}


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
   14ba0:	b510      	push	{r4, lr}
   14ba2:	b084      	sub	sp, #16
   14ba4:	4674      	mov	r4, lr
   14ba6:	9102      	str	r1, [sp, #8]
   14ba8:	9201      	str	r2, [sp, #4]
   14baa:	9300      	str	r3, [sp, #0]
   14bac:	4603      	mov	r3, r0
   14bae:	f88d 300f 	strb.w	r3, [sp, #15]
   14bb2:	4623      	mov	r3, r4
   14bb4:	4619      	mov	r1, r3
   14bb6:	4805      	ldr	r0, [pc, #20]	; (14bcc <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   14bb8:	f7fe fbb4 	bl	13324 <__cyg_profile_func_enter>
   14bbc:	4623      	mov	r3, r4
   14bbe:	4619      	mov	r1, r3
   14bc0:	4802      	ldr	r0, [pc, #8]	; (14bcc <_out_null(char, void*, unsigned int, unsigned int)+0x2c>)
   14bc2:	f7fe fbc3 	bl	1334c <__cyg_profile_func_exit>
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
   14bc6:	bf00      	nop
   14bc8:	b004      	add	sp, #16
   14bca:	bd10      	pop	{r4, pc}
   14bcc:	00014ba1 	.word	0x00014ba1

00014bd0 <_out_char(char, void*, unsigned int, unsigned int)>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
   14bd0:	b510      	push	{r4, lr}
   14bd2:	b084      	sub	sp, #16
   14bd4:	4674      	mov	r4, lr
   14bd6:	9102      	str	r1, [sp, #8]
   14bd8:	9201      	str	r2, [sp, #4]
   14bda:	9300      	str	r3, [sp, #0]
   14bdc:	4603      	mov	r3, r0
   14bde:	f88d 300f 	strb.w	r3, [sp, #15]
   14be2:	4623      	mov	r3, r4
   14be4:	4619      	mov	r1, r3
   14be6:	480a      	ldr	r0, [pc, #40]	; (14c10 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   14be8:	f7fe fb9c 	bl	13324 <__cyg_profile_func_enter>
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
   14bec:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14bf0:	2b00      	cmp	r3, #0
   14bf2:	d004      	beq.n	14bfe <_out_char(char, void*, unsigned int, unsigned int)+0x2e>
    _putchar(character);
   14bf4:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14bf8:	4618      	mov	r0, r3
   14bfa:	f7fe fb29 	bl	13250 <_putchar>
   14bfe:	4623      	mov	r3, r4
   14c00:	4619      	mov	r1, r3
   14c02:	4803      	ldr	r0, [pc, #12]	; (14c10 <_out_char(char, void*, unsigned int, unsigned int)+0x40>)
   14c04:	f7fe fba2 	bl	1334c <__cyg_profile_func_exit>
  }
}
   14c08:	bf00      	nop
   14c0a:	b004      	add	sp, #16
   14c0c:	bd10      	pop	{r4, pc}
   14c0e:	bf00      	nop
   14c10:	00014bd1 	.word	0x00014bd1

00014c14 <_strlen(char const*)>:


// internal strlen
// \return The length of the string (excluding the terminating 0)
static inline unsigned int _strlen(const char* str)
{
   14c14:	b530      	push	{r4, r5, lr}
   14c16:	b085      	sub	sp, #20
   14c18:	4674      	mov	r4, lr
   14c1a:	9001      	str	r0, [sp, #4]
   14c1c:	4623      	mov	r3, r4
   14c1e:	4619      	mov	r1, r3
   14c20:	480c      	ldr	r0, [pc, #48]	; (14c54 <_strlen(char const*)+0x40>)
   14c22:	f7fe fb7f 	bl	13324 <__cyg_profile_func_enter>
  const char* s;
  for (s = str; *s; ++s);
   14c26:	9b01      	ldr	r3, [sp, #4]
   14c28:	9303      	str	r3, [sp, #12]
   14c2a:	9b03      	ldr	r3, [sp, #12]
   14c2c:	781b      	ldrb	r3, [r3, #0]
   14c2e:	2b00      	cmp	r3, #0
   14c30:	d003      	beq.n	14c3a <_strlen(char const*)+0x26>
   14c32:	9b03      	ldr	r3, [sp, #12]
   14c34:	3301      	adds	r3, #1
   14c36:	9303      	str	r3, [sp, #12]
   14c38:	e7f7      	b.n	14c2a <_strlen(char const*)+0x16>
  return (unsigned int)(s - str);
   14c3a:	9a03      	ldr	r2, [sp, #12]
   14c3c:	9b01      	ldr	r3, [sp, #4]
   14c3e:	1ad3      	subs	r3, r2, r3
   14c40:	461d      	mov	r5, r3
   14c42:	4623      	mov	r3, r4
   14c44:	4619      	mov	r1, r3
   14c46:	4803      	ldr	r0, [pc, #12]	; (14c54 <_strlen(char const*)+0x40>)
   14c48:	f7fe fb80 	bl	1334c <__cyg_profile_func_exit>
   14c4c:	462b      	mov	r3, r5
}
   14c4e:	4618      	mov	r0, r3
   14c50:	b005      	add	sp, #20
   14c52:	bd30      	pop	{r4, r5, pc}
   14c54:	00014c15 	.word	0x00014c15

00014c58 <_is_digit(char)>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
   14c58:	b530      	push	{r4, r5, lr}
   14c5a:	b083      	sub	sp, #12
   14c5c:	4675      	mov	r5, lr
   14c5e:	4603      	mov	r3, r0
   14c60:	f88d 3007 	strb.w	r3, [sp, #7]
   14c64:	462b      	mov	r3, r5
   14c66:	4619      	mov	r1, r3
   14c68:	480b      	ldr	r0, [pc, #44]	; (14c98 <_is_digit(char)+0x40>)
   14c6a:	f7fe fb5b 	bl	13324 <__cyg_profile_func_enter>
  return (ch >= '0') && (ch <= '9');
   14c6e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c72:	2b2f      	cmp	r3, #47	; 0x2f
   14c74:	d905      	bls.n	14c82 <_is_digit(char)+0x2a>
   14c76:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14c7a:	2b39      	cmp	r3, #57	; 0x39
   14c7c:	d801      	bhi.n	14c82 <_is_digit(char)+0x2a>
   14c7e:	2401      	movs	r4, #1
   14c80:	e000      	b.n	14c84 <_is_digit(char)+0x2c>
   14c82:	2400      	movs	r4, #0
   14c84:	462b      	mov	r3, r5
   14c86:	4619      	mov	r1, r3
   14c88:	4803      	ldr	r0, [pc, #12]	; (14c98 <_is_digit(char)+0x40>)
   14c8a:	f7fe fb5f 	bl	1334c <__cyg_profile_func_exit>
   14c8e:	4623      	mov	r3, r4
}
   14c90:	4618      	mov	r0, r3
   14c92:	b003      	add	sp, #12
   14c94:	bd30      	pop	{r4, r5, pc}
   14c96:	bf00      	nop
   14c98:	00014c59 	.word	0x00014c59

00014c9c <_atoi(char const**)>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
   14c9c:	b530      	push	{r4, r5, lr}
   14c9e:	b085      	sub	sp, #20
   14ca0:	4675      	mov	r5, lr
   14ca2:	9001      	str	r0, [sp, #4]
   14ca4:	462b      	mov	r3, r5
   14ca6:	4619      	mov	r1, r3
   14ca8:	4813      	ldr	r0, [pc, #76]	; (14cf8 <_atoi(char const**)+0x5c>)
   14caa:	f7fe fb3b 	bl	13324 <__cyg_profile_func_enter>
  unsigned int i = 0U;
   14cae:	2300      	movs	r3, #0
   14cb0:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   14cb2:	9b01      	ldr	r3, [sp, #4]
   14cb4:	681b      	ldr	r3, [r3, #0]
   14cb6:	781b      	ldrb	r3, [r3, #0]
   14cb8:	4618      	mov	r0, r3
   14cba:	f7ff ffcd 	bl	14c58 <_is_digit(char)>
   14cbe:	4603      	mov	r3, r0
   14cc0:	2b00      	cmp	r3, #0
   14cc2:	d00f      	beq.n	14ce4 <_atoi(char const**)+0x48>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
   14cc4:	9a03      	ldr	r2, [sp, #12]
   14cc6:	4613      	mov	r3, r2
   14cc8:	009b      	lsls	r3, r3, #2
   14cca:	4413      	add	r3, r2
   14ccc:	005b      	lsls	r3, r3, #1
   14cce:	4618      	mov	r0, r3
   14cd0:	9b01      	ldr	r3, [sp, #4]
   14cd2:	681b      	ldr	r3, [r3, #0]
   14cd4:	1c59      	adds	r1, r3, #1
   14cd6:	9a01      	ldr	r2, [sp, #4]
   14cd8:	6011      	str	r1, [r2, #0]
   14cda:	781b      	ldrb	r3, [r3, #0]
   14cdc:	4403      	add	r3, r0
   14cde:	3b30      	subs	r3, #48	; 0x30
   14ce0:	9303      	str	r3, [sp, #12]
  while (_is_digit(**str)) {
   14ce2:	e7e6      	b.n	14cb2 <_atoi(char const**)+0x16>
  }
  return i;
   14ce4:	9c03      	ldr	r4, [sp, #12]
   14ce6:	462b      	mov	r3, r5
   14ce8:	4619      	mov	r1, r3
   14cea:	4803      	ldr	r0, [pc, #12]	; (14cf8 <_atoi(char const**)+0x5c>)
   14cec:	f7fe fb2e 	bl	1334c <__cyg_profile_func_exit>
   14cf0:	4623      	mov	r3, r4
}
   14cf2:	4618      	mov	r0, r3
   14cf4:	b005      	add	sp, #20
   14cf6:	bd30      	pop	{r4, r5, pc}
   14cf8:	00014c9d 	.word	0x00014c9d

00014cfc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
   14cfc:	b530      	push	{r4, r5, lr}
   14cfe:	b089      	sub	sp, #36	; 0x24
   14d00:	4675      	mov	r5, lr
   14d02:	9003      	str	r0, [sp, #12]
   14d04:	9102      	str	r1, [sp, #8]
   14d06:	9201      	str	r2, [sp, #4]
   14d08:	9300      	str	r3, [sp, #0]
   14d0a:	462b      	mov	r3, r5
   14d0c:	4619      	mov	r1, r3
   14d0e:	4891      	ldr	r0, [pc, #580]	; (14f54 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   14d10:	f7fe fb08 	bl	13324 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   14d14:	9b01      	ldr	r3, [sp, #4]
   14d16:	9305      	str	r3, [sp, #20]

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14d18:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14d1a:	f003 0302 	and.w	r3, r3, #2
   14d1e:	2b00      	cmp	r3, #0
   14d20:	d10e      	bne.n	14d40 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   14d22:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14d24:	9b10      	ldr	r3, [sp, #64]	; 0x40
   14d26:	429a      	cmp	r2, r3
   14d28:	d20a      	bcs.n	14d40 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
   14d2a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14d2c:	2b1f      	cmp	r3, #31
   14d2e:	d807      	bhi.n	14d40 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
    buf[len++] = '0';
   14d30:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14d32:	1c5a      	adds	r2, r3, #1
   14d34:	920d      	str	r2, [sp, #52]	; 0x34
   14d36:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14d38:	4413      	add	r3, r2
   14d3a:	2230      	movs	r2, #48	; 0x30
   14d3c:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14d3e:	e7eb      	b.n	14d18 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1c>
  }
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14d40:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14d42:	f003 0302 	and.w	r3, r3, #2
   14d46:	2b00      	cmp	r3, #0
   14d48:	d113      	bne.n	14d72 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   14d4a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14d4c:	f003 0301 	and.w	r3, r3, #1
   14d50:	2b00      	cmp	r3, #0
   14d52:	d00e      	beq.n	14d72 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   14d54:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14d56:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14d58:	429a      	cmp	r2, r3
   14d5a:	d20a      	bcs.n	14d72 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
   14d5c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14d5e:	2b1f      	cmp	r3, #31
   14d60:	d807      	bhi.n	14d72 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x76>
    buf[len++] = '0';
   14d62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14d64:	1c5a      	adds	r2, r3, #1
   14d66:	920d      	str	r2, [sp, #52]	; 0x34
   14d68:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14d6a:	4413      	add	r3, r2
   14d6c:	2230      	movs	r2, #48	; 0x30
   14d6e:	701a      	strb	r2, [r3, #0]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14d70:	e7e6      	b.n	14d40 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x44>
  }

  // handle hash
  if (flags & FLAGS_HASH) {
   14d72:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14d74:	f003 0310 	and.w	r3, r3, #16
   14d78:	2b00      	cmp	r3, #0
   14d7a:	d058      	beq.n	14e2e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
   14d7c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14d7e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   14d82:	2b00      	cmp	r3, #0
   14d84:	d116      	bne.n	14db4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   14d86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14d88:	2b00      	cmp	r3, #0
   14d8a:	d013      	beq.n	14db4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   14d8c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14d8e:	9b10      	ldr	r3, [sp, #64]	; 0x40
   14d90:	429a      	cmp	r2, r3
   14d92:	d003      	beq.n	14d9c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xa0>
   14d94:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14d96:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14d98:	429a      	cmp	r2, r3
   14d9a:	d10b      	bne.n	14db4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
      len--;
   14d9c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14d9e:	3b01      	subs	r3, #1
   14da0:	930d      	str	r3, [sp, #52]	; 0x34
      if (len && (base == 16U)) {
   14da2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14da4:	2b00      	cmp	r3, #0
   14da6:	d005      	beq.n	14db4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
   14da8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14daa:	2b10      	cmp	r3, #16
   14dac:	d102      	bne.n	14db4 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xb8>
        len--;
   14dae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14db0:	3b01      	subs	r3, #1
   14db2:	930d      	str	r3, [sp, #52]	; 0x34
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14db4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14db6:	2b10      	cmp	r3, #16
   14db8:	d10f      	bne.n	14dda <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   14dba:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14dbc:	f003 0320 	and.w	r3, r3, #32
   14dc0:	2b00      	cmp	r3, #0
   14dc2:	d10a      	bne.n	14dda <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
   14dc4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14dc6:	2b1f      	cmp	r3, #31
   14dc8:	d807      	bhi.n	14dda <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0xde>
      buf[len++] = 'x';
   14dca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14dcc:	1c5a      	adds	r2, r3, #1
   14dce:	920d      	str	r2, [sp, #52]	; 0x34
   14dd0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14dd2:	4413      	add	r3, r2
   14dd4:	2278      	movs	r2, #120	; 0x78
   14dd6:	701a      	strb	r2, [r3, #0]
   14dd8:	e01f      	b.n	14e1a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14dda:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14ddc:	2b10      	cmp	r3, #16
   14dde:	d10f      	bne.n	14e00 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   14de0:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14de2:	f003 0320 	and.w	r3, r3, #32
   14de6:	2b00      	cmp	r3, #0
   14de8:	d00a      	beq.n	14e00 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
   14dea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14dec:	2b1f      	cmp	r3, #31
   14dee:	d807      	bhi.n	14e00 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x104>
      buf[len++] = 'X';
   14df0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14df2:	1c5a      	adds	r2, r3, #1
   14df4:	920d      	str	r2, [sp, #52]	; 0x34
   14df6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14df8:	4413      	add	r3, r2
   14dfa:	2258      	movs	r2, #88	; 0x58
   14dfc:	701a      	strb	r2, [r3, #0]
   14dfe:	e00c      	b.n	14e1a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
   14e00:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   14e02:	2b02      	cmp	r3, #2
   14e04:	d109      	bne.n	14e1a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
   14e06:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e08:	2b1f      	cmp	r3, #31
   14e0a:	d806      	bhi.n	14e1a <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x11e>
      buf[len++] = 'b';
   14e0c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e0e:	1c5a      	adds	r2, r3, #1
   14e10:	920d      	str	r2, [sp, #52]	; 0x34
   14e12:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14e14:	4413      	add	r3, r2
   14e16:	2262      	movs	r2, #98	; 0x62
   14e18:	701a      	strb	r2, [r3, #0]
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
   14e1a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e1c:	2b1f      	cmp	r3, #31
   14e1e:	d806      	bhi.n	14e2e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x132>
      buf[len++] = '0';
   14e20:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e22:	1c5a      	adds	r2, r3, #1
   14e24:	920d      	str	r2, [sp, #52]	; 0x34
   14e26:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14e28:	4413      	add	r3, r2
   14e2a:	2230      	movs	r2, #48	; 0x30
   14e2c:	701a      	strb	r2, [r3, #0]
    }
  }

  // handle sign
  if (len && (len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   14e2e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e30:	2b00      	cmp	r3, #0
   14e32:	d014      	beq.n	14e5e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   14e34:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14e36:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14e38:	429a      	cmp	r2, r3
   14e3a:	d110      	bne.n	14e5e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
   14e3c:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   14e40:	2b00      	cmp	r3, #0
   14e42:	d109      	bne.n	14e58 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   14e44:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14e46:	f003 0304 	and.w	r3, r3, #4
   14e4a:	2b00      	cmp	r3, #0
   14e4c:	d104      	bne.n	14e58 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x15c>
   14e4e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14e50:	f003 0308 	and.w	r3, r3, #8
   14e54:	2b00      	cmp	r3, #0
   14e56:	d002      	beq.n	14e5e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x162>
    len--;
   14e58:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e5a:	3b01      	subs	r3, #1
   14e5c:	930d      	str	r3, [sp, #52]	; 0x34
  }
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
   14e5e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e60:	2b1f      	cmp	r3, #31
   14e62:	d824      	bhi.n	14eae <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    if (negative) {
   14e64:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   14e68:	2b00      	cmp	r3, #0
   14e6a:	d007      	beq.n	14e7c <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x180>
      buf[len++] = '-';
   14e6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e6e:	1c5a      	adds	r2, r3, #1
   14e70:	920d      	str	r2, [sp, #52]	; 0x34
   14e72:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14e74:	4413      	add	r3, r2
   14e76:	222d      	movs	r2, #45	; 0x2d
   14e78:	701a      	strb	r2, [r3, #0]
   14e7a:	e018      	b.n	14eae <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_PLUS) {
   14e7c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14e7e:	f003 0304 	and.w	r3, r3, #4
   14e82:	2b00      	cmp	r3, #0
   14e84:	d007      	beq.n	14e96 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x19a>
      buf[len++] = '+';  // ignore the space if the '+' exists
   14e86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14e88:	1c5a      	adds	r2, r3, #1
   14e8a:	920d      	str	r2, [sp, #52]	; 0x34
   14e8c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14e8e:	4413      	add	r3, r2
   14e90:	222b      	movs	r2, #43	; 0x2b
   14e92:	701a      	strb	r2, [r3, #0]
   14e94:	e00b      	b.n	14eae <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
    }
    else if (flags & FLAGS_SPACE) {
   14e96:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14e98:	f003 0308 	and.w	r3, r3, #8
   14e9c:	2b00      	cmp	r3, #0
   14e9e:	d006      	beq.n	14eae <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1b2>
      buf[len++] = ' ';
   14ea0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14ea2:	1c5a      	adds	r2, r3, #1
   14ea4:	920d      	str	r2, [sp, #52]	; 0x34
   14ea6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14ea8:	4413      	add	r3, r2
   14eaa:	2220      	movs	r2, #32
   14eac:	701a      	strb	r2, [r3, #0]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   14eae:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14eb0:	f003 0302 	and.w	r3, r3, #2
   14eb4:	2b00      	cmp	r3, #0
   14eb6:	d116      	bne.n	14ee6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
   14eb8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14eba:	f003 0301 	and.w	r3, r3, #1
   14ebe:	2b00      	cmp	r3, #0
   14ec0:	d111      	bne.n	14ee6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
    for (size_t i = len; i < width; i++) {
   14ec2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14ec4:	9307      	str	r3, [sp, #28]
   14ec6:	9a07      	ldr	r2, [sp, #28]
   14ec8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14eca:	429a      	cmp	r2, r3
   14ecc:	d20b      	bcs.n	14ee6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ea>
      out(' ', buffer, idx++, maxlen);
   14ece:	9a01      	ldr	r2, [sp, #4]
   14ed0:	1c53      	adds	r3, r2, #1
   14ed2:	9301      	str	r3, [sp, #4]
   14ed4:	9c03      	ldr	r4, [sp, #12]
   14ed6:	9b00      	ldr	r3, [sp, #0]
   14ed8:	9902      	ldr	r1, [sp, #8]
   14eda:	2020      	movs	r0, #32
   14edc:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   14ede:	9b07      	ldr	r3, [sp, #28]
   14ee0:	3301      	adds	r3, #1
   14ee2:	9307      	str	r3, [sp, #28]
   14ee4:	e7ef      	b.n	14ec6 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ca>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   14ee6:	2300      	movs	r3, #0
   14ee8:	9306      	str	r3, [sp, #24]
   14eea:	9a06      	ldr	r2, [sp, #24]
   14eec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14eee:	429a      	cmp	r2, r3
   14ef0:	d211      	bcs.n	14f16 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x21a>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   14ef2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   14ef4:	9b06      	ldr	r3, [sp, #24]
   14ef6:	1ad3      	subs	r3, r2, r3
   14ef8:	3b01      	subs	r3, #1
   14efa:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14efc:	4413      	add	r3, r2
   14efe:	7818      	ldrb	r0, [r3, #0]
   14f00:	9a01      	ldr	r2, [sp, #4]
   14f02:	1c53      	adds	r3, r2, #1
   14f04:	9301      	str	r3, [sp, #4]
   14f06:	9c03      	ldr	r4, [sp, #12]
   14f08:	9b00      	ldr	r3, [sp, #0]
   14f0a:	9902      	ldr	r1, [sp, #8]
   14f0c:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   14f0e:	9b06      	ldr	r3, [sp, #24]
   14f10:	3301      	adds	r3, #1
   14f12:	9306      	str	r3, [sp, #24]
   14f14:	e7e9      	b.n	14eea <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x1ee>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   14f16:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14f18:	f003 0302 	and.w	r3, r3, #2
   14f1c:	2b00      	cmp	r3, #0
   14f1e:	d00e      	beq.n	14f3e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
    while (idx - start_idx < width) {
   14f20:	9a01      	ldr	r2, [sp, #4]
   14f22:	9b05      	ldr	r3, [sp, #20]
   14f24:	1ad3      	subs	r3, r2, r3
   14f26:	9a11      	ldr	r2, [sp, #68]	; 0x44
   14f28:	429a      	cmp	r2, r3
   14f2a:	d908      	bls.n	14f3e <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x242>
      out(' ', buffer, idx++, maxlen);
   14f2c:	9a01      	ldr	r2, [sp, #4]
   14f2e:	1c53      	adds	r3, r2, #1
   14f30:	9301      	str	r3, [sp, #4]
   14f32:	9c03      	ldr	r4, [sp, #12]
   14f34:	9b00      	ldr	r3, [sp, #0]
   14f36:	9902      	ldr	r1, [sp, #8]
   14f38:	2020      	movs	r0, #32
   14f3a:	47a0      	blx	r4
    while (idx - start_idx < width) {
   14f3c:	e7f0      	b.n	14f20 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x224>
    }
  }

  return idx;
   14f3e:	9c01      	ldr	r4, [sp, #4]
   14f40:	462b      	mov	r3, r5
   14f42:	4619      	mov	r1, r3
   14f44:	4803      	ldr	r0, [pc, #12]	; (14f54 <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)+0x258>)
   14f46:	f7fe fa01 	bl	1334c <__cyg_profile_func_exit>
   14f4a:	4623      	mov	r3, r4
}
   14f4c:	4618      	mov	r0, r3
   14f4e:	b009      	add	sp, #36	; 0x24
   14f50:	bd30      	pop	{r4, r5, pc}
   14f52:	bf00      	nop
   14f54:	00014cfd 	.word	0x00014cfd

00014f58 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   14f58:	b530      	push	{r4, r5, lr}
   14f5a:	b097      	sub	sp, #92	; 0x5c
   14f5c:	4674      	mov	r4, lr
   14f5e:	900b      	str	r0, [sp, #44]	; 0x2c
   14f60:	910a      	str	r1, [sp, #40]	; 0x28
   14f62:	9209      	str	r2, [sp, #36]	; 0x24
   14f64:	9308      	str	r3, [sp, #32]
   14f66:	4623      	mov	r3, r4
   14f68:	4619      	mov	r1, r3
   14f6a:	4833      	ldr	r0, [pc, #204]	; (15038 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   14f6c:	f7fe f9da 	bl	13324 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   14f70:	2300      	movs	r3, #0
   14f72:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   14f74:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   14f76:	2b00      	cmp	r3, #0
   14f78:	d103      	bne.n	14f82 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x2a>
    flags &= ~FLAGS_HASH;
   14f7a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   14f7c:	f023 0310 	bic.w	r3, r3, #16
   14f80:	931f      	str	r3, [sp, #124]	; 0x7c
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   14f82:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   14f84:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   14f88:	2b00      	cmp	r3, #0
   14f8a:	d002      	beq.n	14f92 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
   14f8c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   14f8e:	2b00      	cmp	r3, #0
   14f90:	d033      	beq.n	14ffa <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
      const char digit = (char)(value % base);
   14f92:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   14f94:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   14f96:	fbb3 f2f2 	udiv	r2, r3, r2
   14f9a:	991c      	ldr	r1, [sp, #112]	; 0x70
   14f9c:	fb01 f202 	mul.w	r2, r1, r2
   14fa0:	1a9b      	subs	r3, r3, r2
   14fa2:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   14fa6:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   14faa:	2b09      	cmp	r3, #9
   14fac:	d804      	bhi.n	14fb8 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x60>
   14fae:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   14fb2:	3330      	adds	r3, #48	; 0x30
   14fb4:	b2da      	uxtb	r2, r3
   14fb6:	e00d      	b.n	14fd4 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x7c>
   14fb8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   14fba:	f003 0320 	and.w	r3, r3, #32
   14fbe:	2b00      	cmp	r3, #0
   14fc0:	d001      	beq.n	14fc6 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x6e>
   14fc2:	2241      	movs	r2, #65	; 0x41
   14fc4:	e000      	b.n	14fc8 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x70>
   14fc6:	2261      	movs	r2, #97	; 0x61
   14fc8:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   14fcc:	4413      	add	r3, r2
   14fce:	b2db      	uxtb	r3, r3
   14fd0:	3b0a      	subs	r3, #10
   14fd2:	b2da      	uxtb	r2, r3
   14fd4:	9b15      	ldr	r3, [sp, #84]	; 0x54
   14fd6:	1c59      	adds	r1, r3, #1
   14fd8:	9115      	str	r1, [sp, #84]	; 0x54
   14fda:	a916      	add	r1, sp, #88	; 0x58
   14fdc:	440b      	add	r3, r1
   14fde:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   14fe2:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   14fe4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   14fe6:	fbb2 f3f3 	udiv	r3, r2, r3
   14fea:	931a      	str	r3, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   14fec:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   14fee:	2b00      	cmp	r3, #0
   14ff0:	d003      	beq.n	14ffa <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
   14ff2:	9b15      	ldr	r3, [sp, #84]	; 0x54
   14ff4:	2b1f      	cmp	r3, #31
   14ff6:	d800      	bhi.n	14ffa <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xa2>
    do {
   14ff8:	e7cb      	b.n	14f92 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0x3a>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   14ffa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   14ffc:	9306      	str	r3, [sp, #24]
   14ffe:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15000:	9305      	str	r3, [sp, #20]
   15002:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15004:	9304      	str	r3, [sp, #16]
   15006:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   15008:	9303      	str	r3, [sp, #12]
   1500a:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
   1500e:	9302      	str	r3, [sp, #8]
   15010:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15012:	9301      	str	r3, [sp, #4]
   15014:	ab0c      	add	r3, sp, #48	; 0x30
   15016:	9300      	str	r3, [sp, #0]
   15018:	9b08      	ldr	r3, [sp, #32]
   1501a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1501c:	990a      	ldr	r1, [sp, #40]	; 0x28
   1501e:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15020:	f7ff fe6c 	bl	14cfc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   15024:	4605      	mov	r5, r0
   15026:	4623      	mov	r3, r4
   15028:	4619      	mov	r1, r3
   1502a:	4803      	ldr	r0, [pc, #12]	; (15038 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)+0xe0>)
   1502c:	f7fe f98e 	bl	1334c <__cyg_profile_func_exit>
   15030:	462b      	mov	r3, r5
}
   15032:	4618      	mov	r0, r3
   15034:	b017      	add	sp, #92	; 0x5c
   15036:	bd30      	pop	{r4, r5, pc}
   15038:	00014f59 	.word	0x00014f59

0001503c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
   1503c:	b530      	push	{r4, r5, lr}
   1503e:	b097      	sub	sp, #92	; 0x5c
   15040:	4675      	mov	r5, lr
   15042:	900b      	str	r0, [sp, #44]	; 0x2c
   15044:	910a      	str	r1, [sp, #40]	; 0x28
   15046:	9209      	str	r2, [sp, #36]	; 0x24
   15048:	9308      	str	r3, [sp, #32]
   1504a:	462b      	mov	r3, r5
   1504c:	4619      	mov	r1, r3
   1504e:	4837      	ldr	r0, [pc, #220]	; (1512c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   15050:	f7fe f968 	bl	13324 <__cyg_profile_func_enter>
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
   15054:	2300      	movs	r3, #0
   15056:	9315      	str	r3, [sp, #84]	; 0x54

  // no hash for 0 values
  if (!value) {
   15058:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   1505c:	4323      	orrs	r3, r4
   1505e:	d103      	bne.n	15068 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x2c>
    flags &= ~FLAGS_HASH;
   15060:	9b22      	ldr	r3, [sp, #136]	; 0x88
   15062:	f023 0310 	bic.w	r3, r3, #16
   15066:	9322      	str	r3, [sp, #136]	; 0x88
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
   15068:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1506a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1506e:	2b00      	cmp	r3, #0
   15070:	d003      	beq.n	1507a <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
   15072:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   15076:	4323      	orrs	r3, r4
   15078:	d039      	beq.n	150ee <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
      const char digit = (char)(value % base);
   1507a:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   1507e:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   15082:	f003 fbbb 	bl	187fc <__aeabi_uldivmod>
   15086:	461c      	mov	r4, r3
   15088:	4613      	mov	r3, r2
   1508a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
   1508e:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   15092:	2b09      	cmp	r3, #9
   15094:	d804      	bhi.n	150a0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x64>
   15096:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   1509a:	3330      	adds	r3, #48	; 0x30
   1509c:	b2da      	uxtb	r2, r3
   1509e:	e00d      	b.n	150bc <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x80>
   150a0:	9b22      	ldr	r3, [sp, #136]	; 0x88
   150a2:	f003 0320 	and.w	r3, r3, #32
   150a6:	2b00      	cmp	r3, #0
   150a8:	d001      	beq.n	150ae <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x72>
   150aa:	2241      	movs	r2, #65	; 0x41
   150ac:	e000      	b.n	150b0 <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x74>
   150ae:	2261      	movs	r2, #97	; 0x61
   150b0:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
   150b4:	4413      	add	r3, r2
   150b6:	b2db      	uxtb	r3, r3
   150b8:	3b0a      	subs	r3, #10
   150ba:	b2da      	uxtb	r2, r3
   150bc:	9b15      	ldr	r3, [sp, #84]	; 0x54
   150be:	1c59      	adds	r1, r3, #1
   150c0:	9115      	str	r1, [sp, #84]	; 0x54
   150c2:	a916      	add	r1, sp, #88	; 0x58
   150c4:	440b      	add	r3, r1
   150c6:	f803 2c28 	strb.w	r2, [r3, #-40]
      value /= base;
   150ca:	e9dd 231e 	ldrd	r2, r3, [sp, #120]	; 0x78
   150ce:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   150d2:	f003 fb93 	bl	187fc <__aeabi_uldivmod>
   150d6:	4603      	mov	r3, r0
   150d8:	460c      	mov	r4, r1
   150da:	e9cd 341a 	strd	r3, r4, [sp, #104]	; 0x68
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
   150de:	e9dd 341a 	ldrd	r3, r4, [sp, #104]	; 0x68
   150e2:	4323      	orrs	r3, r4
   150e4:	d003      	beq.n	150ee <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
   150e6:	9b15      	ldr	r3, [sp, #84]	; 0x54
   150e8:	2b1f      	cmp	r3, #31
   150ea:	d800      	bhi.n	150ee <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xb2>
    do {
   150ec:	e7c5      	b.n	1507a <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0x3e>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
   150ee:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   150f0:	9a22      	ldr	r2, [sp, #136]	; 0x88
   150f2:	9206      	str	r2, [sp, #24]
   150f4:	9a21      	ldr	r2, [sp, #132]	; 0x84
   150f6:	9205      	str	r2, [sp, #20]
   150f8:	9a20      	ldr	r2, [sp, #128]	; 0x80
   150fa:	9204      	str	r2, [sp, #16]
   150fc:	9303      	str	r3, [sp, #12]
   150fe:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
   15102:	9302      	str	r3, [sp, #8]
   15104:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15106:	9301      	str	r3, [sp, #4]
   15108:	ab0c      	add	r3, sp, #48	; 0x30
   1510a:	9300      	str	r3, [sp, #0]
   1510c:	9b08      	ldr	r3, [sp, #32]
   1510e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   15110:	990a      	ldr	r1, [sp, #40]	; 0x28
   15112:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15114:	f7ff fdf2 	bl	14cfc <_ntoa_format(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, char*, unsigned int, bool, unsigned int, unsigned int, unsigned int, unsigned int)>
   15118:	4604      	mov	r4, r0
   1511a:	462b      	mov	r3, r5
   1511c:	4619      	mov	r1, r3
   1511e:	4803      	ldr	r0, [pc, #12]	; (1512c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)+0xf0>)
   15120:	f7fe f914 	bl	1334c <__cyg_profile_func_exit>
   15124:	4623      	mov	r3, r4
}
   15126:	4618      	mov	r0, r3
   15128:	b017      	add	sp, #92	; 0x5c
   1512a:	bd30      	pop	{r4, r5, pc}
   1512c:	0001503d 	.word	0x0001503d

00015130 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>:
#endif  // PRINTF_SUPPORT_LONG_LONG


#if defined(PRINTF_SUPPORT_FLOAT)
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value_param, unsigned int prec, unsigned int width, unsigned int flags)
{
   15130:	b530      	push	{r4, r5, lr}
   15132:	b09b      	sub	sp, #108	; 0x6c
   15134:	4675      	mov	r5, lr
   15136:	9005      	str	r0, [sp, #20]
   15138:	9104      	str	r1, [sp, #16]
   1513a:	9203      	str	r2, [sp, #12]
   1513c:	9302      	str	r3, [sp, #8]
   1513e:	ed8d 0b00 	vstr	d0, [sp]
   15142:	462b      	mov	r3, r5
   15144:	4619      	mov	r1, r3
   15146:	48b7      	ldr	r0, [pc, #732]	; (15424 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f4>)
   15148:	f7fe f8ec 	bl	13324 <__cyg_profile_func_enter>
  const size_t start_idx = idx;
   1514c:	9b03      	ldr	r3, [sp, #12]
   1514e:	9311      	str	r3, [sp, #68]	; 0x44

  float value = static_cast<float>(value_param);
   15150:	e9dd 0100 	ldrd	r0, r1, [sp]
   15154:	f003 fb02 	bl	1875c <__aeabi_d2f>
   15158:	4603      	mov	r3, r0
   1515a:	9319      	str	r3, [sp, #100]	; 0x64

  char buf[PRINTF_FTOA_BUFFER_SIZE];
  size_t len  = 0U;
   1515c:	2300      	movs	r3, #0
   1515e:	9318      	str	r3, [sp, #96]	; 0x60
  float diff = 0.0;
   15160:	f04f 0300 	mov.w	r3, #0
   15164:	9310      	str	r3, [sp, #64]	; 0x40

  // if input is larger than thres_max, revert to exponential
  const float thres_max = (float)0x7FFFFFFF;
   15166:	f04f 439e 	mov.w	r3, #1325400064	; 0x4f000000
   1516a:	930f      	str	r3, [sp, #60]	; 0x3c

  // powers of 10
  static const float pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for negative
  bool negative = false;
   1516c:	2300      	movs	r3, #0
   1516e:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
  if (value < 0) {
   15172:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   15176:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1517a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1517e:	d50a      	bpl.n	15196 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x66>
    negative = true;
   15180:	2301      	movs	r3, #1
   15182:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    value = 0 - value;
   15186:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 15428 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2f8>
   1518a:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   1518e:	ee77 7a67 	vsub.f32	s15, s14, s15
   15192:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
  }

  // set default precision to 6, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
   15196:	9b20      	ldr	r3, [sp, #128]	; 0x80
   15198:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   1519c:	2b00      	cmp	r3, #0
   1519e:	d101      	bne.n	151a4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
    prec = 6U;
   151a0:	2306      	movs	r3, #6
   151a2:	931e      	str	r3, [sp, #120]	; 0x78
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   151a4:	9b18      	ldr	r3, [sp, #96]	; 0x60
   151a6:	2b1f      	cmp	r3, #31
   151a8:	d80e      	bhi.n	151c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
   151aa:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   151ac:	2b09      	cmp	r3, #9
   151ae:	d90b      	bls.n	151c8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x98>
    buf[len++] = '0';
   151b0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   151b2:	1c5a      	adds	r2, r3, #1
   151b4:	9218      	str	r2, [sp, #96]	; 0x60
   151b6:	aa1a      	add	r2, sp, #104	; 0x68
   151b8:	4413      	add	r3, r2
   151ba:	2230      	movs	r2, #48	; 0x30
   151bc:	f803 2c50 	strb.w	r2, [r3, #-80]
    prec--;
   151c0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   151c2:	3b01      	subs	r3, #1
   151c4:	931e      	str	r3, [sp, #120]	; 0x78
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
   151c6:	e7ed      	b.n	151a4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x74>
  }

  int whole = (int)value;
   151c8:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   151cc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   151d0:	ee17 3a90 	vmov	r3, s15
   151d4:	9316      	str	r3, [sp, #88]	; 0x58
  float tmp = (value - whole) * pow10[prec];
   151d6:	9b16      	ldr	r3, [sp, #88]	; 0x58
   151d8:	ee07 3a90 	vmov	s15, r3
   151dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   151e0:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   151e4:	ee37 7a67 	vsub.f32	s14, s14, s15
   151e8:	4a90      	ldr	r2, [pc, #576]	; (1542c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   151ea:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   151ec:	009b      	lsls	r3, r3, #2
   151ee:	4413      	add	r3, r2
   151f0:	edd3 7a00 	vldr	s15, [r3]
   151f4:	ee67 7a27 	vmul.f32	s15, s14, s15
   151f8:	edcd 7a0e 	vstr	s15, [sp, #56]	; 0x38
  unsigned long frac = (unsigned long)tmp;
   151fc:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   15200:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   15204:	ee17 3a90 	vmov	r3, s15
   15208:	9315      	str	r3, [sp, #84]	; 0x54
  diff = tmp - frac;
   1520a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1520c:	ee07 3a90 	vmov	s15, r3
   15210:	eef8 7a67 	vcvt.f32.u32	s15, s15
   15214:	ed9d 7a0e 	vldr	s14, [sp, #56]	; 0x38
   15218:	ee77 7a67 	vsub.f32	s15, s14, s15
   1521c:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40

  if (diff > 0.5) {
   15220:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   15224:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   15228:	eef4 7ac7 	vcmpe.f32	s15, s14
   1522c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15230:	dd18      	ble.n	15264 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x134>
    ++frac;
   15232:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15234:	3301      	adds	r3, #1
   15236:	9315      	str	r3, [sp, #84]	; 0x54
    // handle rollover, e.g. case 0.99 with prec 1 is 1.0
    if (frac >= pow10[prec]) {
   15238:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1523a:	ee07 3a90 	vmov	s15, r3
   1523e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   15242:	4a7a      	ldr	r2, [pc, #488]	; (1542c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2fc>)
   15244:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15246:	009b      	lsls	r3, r3, #2
   15248:	4413      	add	r3, r2
   1524a:	edd3 7a00 	vldr	s15, [r3]
   1524e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   15252:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15256:	db19      	blt.n	1528c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
      frac = 0;
   15258:	2300      	movs	r3, #0
   1525a:	9315      	str	r3, [sp, #84]	; 0x54
      ++whole;
   1525c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1525e:	3301      	adds	r3, #1
   15260:	9316      	str	r3, [sp, #88]	; 0x58
   15262:	e013      	b.n	1528c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    }
  }
  else if ((diff == 0.5) && ((frac == 0U) || (frac & 1U))) {
   15264:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   15268:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   1526c:	eef4 7a47 	vcmp.f32	s15, s14
   15270:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   15274:	d10a      	bne.n	1528c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
   15276:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15278:	2b00      	cmp	r3, #0
   1527a:	d004      	beq.n	15286 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x156>
   1527c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1527e:	f003 0301 	and.w	r3, r3, #1
   15282:	2b00      	cmp	r3, #0
   15284:	d002      	beq.n	1528c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x15c>
    // if halfway, round up if odd, OR if last digit is 0
    ++frac;
   15286:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15288:	3301      	adds	r3, #1
   1528a:	9315      	str	r3, [sp, #84]	; 0x54
  }

  // TBD: for very large numbers switch back to native sprintf for exponentials. Anyone want to write code to replace this?
  // Normal printf behavior is to print EVERY whole number digit which can be 100s of characters overflowing your buffers == bad
  if (value > thres_max) {
   1528c:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   15290:	ed9f 7a67 	vldr	s14, [pc, #412]	; 15430 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x300>
   15294:	eef4 7ac7 	vcmpe.f32	s15, s14
   15298:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1529c:	dd01      	ble.n	152a2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x172>
    return 0U;
   1529e:	2400      	movs	r4, #0
   152a0:	e156      	b.n	15550 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x420>
  }

  if (prec == 0U) {
   152a2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   152a4:	2b00      	cmp	r3, #0
   152a6:	d129      	bne.n	152fc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1cc>
    diff = value - (float)whole;
   152a8:	9b16      	ldr	r3, [sp, #88]	; 0x58
   152aa:	ee07 3a90 	vmov	s15, r3
   152ae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   152b2:	ed9d 7a19 	vldr	s14, [sp, #100]	; 0x64
   152b6:	ee77 7a67 	vsub.f32	s15, s14, s15
   152ba:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
    if (diff > 0.5) {
   152be:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   152c2:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   152c6:	eef4 7ac7 	vcmpe.f32	s15, s14
   152ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   152ce:	dd03      	ble.n	152d8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1a8>
      // greater than 0.5, round up, e.g. 1.6 -> 2
      ++whole;
   152d0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   152d2:	3301      	adds	r3, #1
   152d4:	9316      	str	r3, [sp, #88]	; 0x58
   152d6:	e05f      	b.n	15398 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
    else if ((diff == 0.5) && (whole & 1)) {
   152d8:	eddd 7a10 	vldr	s15, [sp, #64]	; 0x40
   152dc:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   152e0:	eef4 7a47 	vcmp.f32	s15, s14
   152e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   152e8:	d156      	bne.n	15398 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
   152ea:	9b16      	ldr	r3, [sp, #88]	; 0x58
   152ec:	f003 0301 	and.w	r3, r3, #1
   152f0:	2b00      	cmp	r3, #0
   152f2:	d051      	beq.n	15398 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
   152f4:	9b16      	ldr	r3, [sp, #88]	; 0x58
   152f6:	3301      	adds	r3, #1
   152f8:	9316      	str	r3, [sp, #88]	; 0x58
   152fa:	e04d      	b.n	15398 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
    }
  }
  else {
    unsigned int count = prec;
   152fc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   152fe:	9314      	str	r3, [sp, #80]	; 0x50
    // now do fractional part, as an unsigned number
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   15300:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15302:	2b1f      	cmp	r3, #31
   15304:	d827      	bhi.n	15356 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
      --count;
   15306:	9b14      	ldr	r3, [sp, #80]	; 0x50
   15308:	3b01      	subs	r3, #1
   1530a:	9314      	str	r3, [sp, #80]	; 0x50
      buf[len++] = (char)(48U + (frac % 10U));
   1530c:	9915      	ldr	r1, [sp, #84]	; 0x54
   1530e:	4b49      	ldr	r3, [pc, #292]	; (15434 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   15310:	fba3 2301 	umull	r2, r3, r3, r1
   15314:	08da      	lsrs	r2, r3, #3
   15316:	4613      	mov	r3, r2
   15318:	009b      	lsls	r3, r3, #2
   1531a:	4413      	add	r3, r2
   1531c:	005b      	lsls	r3, r3, #1
   1531e:	1aca      	subs	r2, r1, r3
   15320:	b2d3      	uxtb	r3, r2
   15322:	3330      	adds	r3, #48	; 0x30
   15324:	b2d9      	uxtb	r1, r3
   15326:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15328:	1c5a      	adds	r2, r3, #1
   1532a:	9218      	str	r2, [sp, #96]	; 0x60
   1532c:	aa1a      	add	r2, sp, #104	; 0x68
   1532e:	4413      	add	r3, r2
   15330:	460a      	mov	r2, r1
   15332:	f803 2c50 	strb.w	r2, [r3, #-80]
      if (!(frac /= 10U)) {
   15336:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15338:	4a3e      	ldr	r2, [pc, #248]	; (15434 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x304>)
   1533a:	fba2 2303 	umull	r2, r3, r2, r3
   1533e:	08db      	lsrs	r3, r3, #3
   15340:	9315      	str	r3, [sp, #84]	; 0x54
   15342:	9b15      	ldr	r3, [sp, #84]	; 0x54
   15344:	2b00      	cmp	r3, #0
   15346:	bf0c      	ite	eq
   15348:	2301      	moveq	r3, #1
   1534a:	2300      	movne	r3, #0
   1534c:	b2db      	uxtb	r3, r3
   1534e:	2b00      	cmp	r3, #0
   15350:	d100      	bne.n	15354 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x224>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
   15352:	e7d5      	b.n	15300 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x1d0>
        break;
   15354:	bf00      	nop
      }
    }
    // add extra 0s
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   15356:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15358:	2b1f      	cmp	r3, #31
   1535a:	d806      	bhi.n	1536a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   1535c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1535e:	1e5a      	subs	r2, r3, #1
   15360:	9214      	str	r2, [sp, #80]	; 0x50
   15362:	2b00      	cmp	r3, #0
   15364:	d001      	beq.n	1536a <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23a>
   15366:	2301      	movs	r3, #1
   15368:	e000      	b.n	1536c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x23c>
   1536a:	2300      	movs	r3, #0
   1536c:	2b00      	cmp	r3, #0
   1536e:	d008      	beq.n	15382 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x252>
      buf[len++] = '0';
   15370:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15372:	1c5a      	adds	r2, r3, #1
   15374:	9218      	str	r2, [sp, #96]	; 0x60
   15376:	aa1a      	add	r2, sp, #104	; 0x68
   15378:	4413      	add	r3, r2
   1537a:	2230      	movs	r2, #48	; 0x30
   1537c:	f803 2c50 	strb.w	r2, [r3, #-80]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
   15380:	e7e9      	b.n	15356 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x226>
    }
    if (len < PRINTF_FTOA_BUFFER_SIZE) {
   15382:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15384:	2b1f      	cmp	r3, #31
   15386:	d807      	bhi.n	15398 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      // add decimal
      buf[len++] = '.';
   15388:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1538a:	1c5a      	adds	r2, r3, #1
   1538c:	9218      	str	r2, [sp, #96]	; 0x60
   1538e:	aa1a      	add	r2, sp, #104	; 0x68
   15390:	4413      	add	r3, r2
   15392:	222e      	movs	r2, #46	; 0x2e
   15394:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   15398:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1539a:	2b1f      	cmp	r3, #31
   1539c:	d828      	bhi.n	153f0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
    buf[len++] = (char)(48 + (whole % 10));
   1539e:	9a16      	ldr	r2, [sp, #88]	; 0x58
   153a0:	4b25      	ldr	r3, [pc, #148]	; (15438 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   153a2:	fb83 1302 	smull	r1, r3, r3, r2
   153a6:	1099      	asrs	r1, r3, #2
   153a8:	17d3      	asrs	r3, r2, #31
   153aa:	1ac9      	subs	r1, r1, r3
   153ac:	460b      	mov	r3, r1
   153ae:	009b      	lsls	r3, r3, #2
   153b0:	440b      	add	r3, r1
   153b2:	005b      	lsls	r3, r3, #1
   153b4:	1ad1      	subs	r1, r2, r3
   153b6:	b2cb      	uxtb	r3, r1
   153b8:	3330      	adds	r3, #48	; 0x30
   153ba:	b2d9      	uxtb	r1, r3
   153bc:	9b18      	ldr	r3, [sp, #96]	; 0x60
   153be:	1c5a      	adds	r2, r3, #1
   153c0:	9218      	str	r2, [sp, #96]	; 0x60
   153c2:	aa1a      	add	r2, sp, #104	; 0x68
   153c4:	4413      	add	r3, r2
   153c6:	460a      	mov	r2, r1
   153c8:	f803 2c50 	strb.w	r2, [r3, #-80]
    if (!(whole /= 10)) {
   153cc:	9b16      	ldr	r3, [sp, #88]	; 0x58
   153ce:	4a1a      	ldr	r2, [pc, #104]	; (15438 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x308>)
   153d0:	fb82 1203 	smull	r1, r2, r2, r3
   153d4:	1092      	asrs	r2, r2, #2
   153d6:	17db      	asrs	r3, r3, #31
   153d8:	1ad3      	subs	r3, r2, r3
   153da:	9316      	str	r3, [sp, #88]	; 0x58
   153dc:	9b16      	ldr	r3, [sp, #88]	; 0x58
   153de:	2b00      	cmp	r3, #0
   153e0:	bf0c      	ite	eq
   153e2:	2301      	moveq	r3, #1
   153e4:	2300      	movne	r3, #0
   153e6:	b2db      	uxtb	r3, r3
   153e8:	2b00      	cmp	r3, #0
   153ea:	d100      	bne.n	153ee <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2be>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
   153ec:	e7d4      	b.n	15398 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x268>
      break;
   153ee:	bf00      	nop
    }
  }

  // pad leading zeros
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   153f0:	9b20      	ldr	r3, [sp, #128]	; 0x80
   153f2:	f003 0302 	and.w	r3, r3, #2
   153f6:	2b00      	cmp	r3, #0
   153f8:	d120      	bne.n	1543c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   153fa:	9b20      	ldr	r3, [sp, #128]	; 0x80
   153fc:	f003 0301 	and.w	r3, r3, #1
   15400:	2b00      	cmp	r3, #0
   15402:	d01b      	beq.n	1543c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   15404:	9a18      	ldr	r2, [sp, #96]	; 0x60
   15406:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15408:	429a      	cmp	r2, r3
   1540a:	d217      	bcs.n	1543c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
   1540c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1540e:	2b1f      	cmp	r3, #31
   15410:	d814      	bhi.n	1543c <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x30c>
    buf[len++] = '0';
   15412:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15414:	1c5a      	adds	r2, r3, #1
   15416:	9218      	str	r2, [sp, #96]	; 0x60
   15418:	aa1a      	add	r2, sp, #104	; 0x68
   1541a:	4413      	add	r3, r2
   1541c:	2230      	movs	r2, #48	; 0x30
   1541e:	f803 2c50 	strb.w	r2, [r3, #-80]
  while (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
   15422:	e7e5      	b.n	153f0 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x2c0>
   15424:	00015131 	.word	0x00015131
   15428:	00000000 	.word	0x00000000
   1542c:	00019b78 	.word	0x00019b78
   15430:	4f000000 	.word	0x4f000000
   15434:	cccccccd 	.word	0xcccccccd
   15438:	66666667 	.word	0x66666667
  }

  // handle sign
  if ((len == width) && (negative || (flags & FLAGS_PLUS) || (flags & FLAGS_SPACE))) {
   1543c:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1543e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15440:	429a      	cmp	r2, r3
   15442:	d110      	bne.n	15466 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
   15444:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   15448:	2b00      	cmp	r3, #0
   1544a:	d109      	bne.n	15460 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   1544c:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1544e:	f003 0304 	and.w	r3, r3, #4
   15452:	2b00      	cmp	r3, #0
   15454:	d104      	bne.n	15460 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x330>
   15456:	9b20      	ldr	r3, [sp, #128]	; 0x80
   15458:	f003 0308 	and.w	r3, r3, #8
   1545c:	2b00      	cmp	r3, #0
   1545e:	d002      	beq.n	15466 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x336>
    len--;
   15460:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15462:	3b01      	subs	r3, #1
   15464:	9318      	str	r3, [sp, #96]	; 0x60
  }
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
   15466:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15468:	2b1f      	cmp	r3, #31
   1546a:	d827      	bhi.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    if (negative) {
   1546c:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
   15470:	2b00      	cmp	r3, #0
   15472:	d008      	beq.n	15486 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x356>
      buf[len++] = '-';
   15474:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15476:	1c5a      	adds	r2, r3, #1
   15478:	9218      	str	r2, [sp, #96]	; 0x60
   1547a:	aa1a      	add	r2, sp, #104	; 0x68
   1547c:	4413      	add	r3, r2
   1547e:	222d      	movs	r2, #45	; 0x2d
   15480:	f803 2c50 	strb.w	r2, [r3, #-80]
   15484:	e01a      	b.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_PLUS) {
   15486:	9b20      	ldr	r3, [sp, #128]	; 0x80
   15488:	f003 0304 	and.w	r3, r3, #4
   1548c:	2b00      	cmp	r3, #0
   1548e:	d008      	beq.n	154a2 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x372>
      buf[len++] = '+';  // ignore the space if the '+' exists
   15490:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15492:	1c5a      	adds	r2, r3, #1
   15494:	9218      	str	r2, [sp, #96]	; 0x60
   15496:	aa1a      	add	r2, sp, #104	; 0x68
   15498:	4413      	add	r3, r2
   1549a:	222b      	movs	r2, #43	; 0x2b
   1549c:	f803 2c50 	strb.w	r2, [r3, #-80]
   154a0:	e00c      	b.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
    }
    else if (flags & FLAGS_SPACE) {
   154a2:	9b20      	ldr	r3, [sp, #128]	; 0x80
   154a4:	f003 0308 	and.w	r3, r3, #8
   154a8:	2b00      	cmp	r3, #0
   154aa:	d007      	beq.n	154bc <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x38c>
      buf[len++] = ' ';
   154ac:	9b18      	ldr	r3, [sp, #96]	; 0x60
   154ae:	1c5a      	adds	r2, r3, #1
   154b0:	9218      	str	r2, [sp, #96]	; 0x60
   154b2:	aa1a      	add	r2, sp, #104	; 0x68
   154b4:	4413      	add	r3, r2
   154b6:	2220      	movs	r2, #32
   154b8:	f803 2c50 	strb.w	r2, [r3, #-80]
    }
  }

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
   154bc:	9b20      	ldr	r3, [sp, #128]	; 0x80
   154be:	f003 0302 	and.w	r3, r3, #2
   154c2:	2b00      	cmp	r3, #0
   154c4:	d116      	bne.n	154f4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
   154c6:	9b20      	ldr	r3, [sp, #128]	; 0x80
   154c8:	f003 0301 	and.w	r3, r3, #1
   154cc:	2b00      	cmp	r3, #0
   154ce:	d111      	bne.n	154f4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
    for (size_t i = len; i < width; i++) {
   154d0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   154d2:	9313      	str	r3, [sp, #76]	; 0x4c
   154d4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   154d6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   154d8:	429a      	cmp	r2, r3
   154da:	d20b      	bcs.n	154f4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c4>
      out(' ', buffer, idx++, maxlen);
   154dc:	9a03      	ldr	r2, [sp, #12]
   154de:	1c53      	adds	r3, r2, #1
   154e0:	9303      	str	r3, [sp, #12]
   154e2:	9c05      	ldr	r4, [sp, #20]
   154e4:	9b02      	ldr	r3, [sp, #8]
   154e6:	9904      	ldr	r1, [sp, #16]
   154e8:	2020      	movs	r0, #32
   154ea:	47a0      	blx	r4
    for (size_t i = len; i < width; i++) {
   154ec:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   154ee:	3301      	adds	r3, #1
   154f0:	9313      	str	r3, [sp, #76]	; 0x4c
   154f2:	e7ef      	b.n	154d4 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3a4>
    }
  }

  // reverse string
  for (size_t i = 0U; i < len; i++) {
   154f4:	2300      	movs	r3, #0
   154f6:	9312      	str	r3, [sp, #72]	; 0x48
   154f8:	9a12      	ldr	r2, [sp, #72]	; 0x48
   154fa:	9b18      	ldr	r3, [sp, #96]	; 0x60
   154fc:	429a      	cmp	r2, r3
   154fe:	d212      	bcs.n	15526 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3f6>
    out(buf[len - i - 1U], buffer, idx++, maxlen);
   15500:	9a18      	ldr	r2, [sp, #96]	; 0x60
   15502:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15504:	1ad3      	subs	r3, r2, r3
   15506:	3b01      	subs	r3, #1
   15508:	aa1a      	add	r2, sp, #104	; 0x68
   1550a:	4413      	add	r3, r2
   1550c:	f813 0c50 	ldrb.w	r0, [r3, #-80]
   15510:	9a03      	ldr	r2, [sp, #12]
   15512:	1c53      	adds	r3, r2, #1
   15514:	9303      	str	r3, [sp, #12]
   15516:	9c05      	ldr	r4, [sp, #20]
   15518:	9b02      	ldr	r3, [sp, #8]
   1551a:	9904      	ldr	r1, [sp, #16]
   1551c:	47a0      	blx	r4
  for (size_t i = 0U; i < len; i++) {
   1551e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15520:	3301      	adds	r3, #1
   15522:	9312      	str	r3, [sp, #72]	; 0x48
   15524:	e7e8      	b.n	154f8 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x3c8>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
   15526:	9b20      	ldr	r3, [sp, #128]	; 0x80
   15528:	f003 0302 	and.w	r3, r3, #2
   1552c:	2b00      	cmp	r3, #0
   1552e:	d00e      	beq.n	1554e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
    while (idx - start_idx < width) {
   15530:	9a03      	ldr	r2, [sp, #12]
   15532:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15534:	1ad3      	subs	r3, r2, r3
   15536:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15538:	429a      	cmp	r2, r3
   1553a:	d908      	bls.n	1554e <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x41e>
      out(' ', buffer, idx++, maxlen);
   1553c:	9a03      	ldr	r2, [sp, #12]
   1553e:	1c53      	adds	r3, r2, #1
   15540:	9303      	str	r3, [sp, #12]
   15542:	9c05      	ldr	r4, [sp, #20]
   15544:	9b02      	ldr	r3, [sp, #8]
   15546:	9904      	ldr	r1, [sp, #16]
   15548:	2020      	movs	r0, #32
   1554a:	47a0      	blx	r4
    while (idx - start_idx < width) {
   1554c:	e7f0      	b.n	15530 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x400>
    }
  }

  return idx;
   1554e:	9c03      	ldr	r4, [sp, #12]
   15550:	462b      	mov	r3, r5
   15552:	4619      	mov	r1, r3
   15554:	4803      	ldr	r0, [pc, #12]	; (15564 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)+0x434>)
   15556:	f7fd fef9 	bl	1334c <__cyg_profile_func_exit>
   1555a:	4623      	mov	r3, r4
}
   1555c:	4618      	mov	r0, r3
   1555e:	b01b      	add	sp, #108	; 0x6c
   15560:	bd30      	pop	{r4, r5, pc}
   15562:	bf00      	nop
   15564:	00015131 	.word	0x00015131

00015568 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
   15568:	b570      	push	{r4, r5, r6, lr}
   1556a:	b0a0      	sub	sp, #128	; 0x80
   1556c:	4676      	mov	r6, lr
   1556e:	900d      	str	r0, [sp, #52]	; 0x34
   15570:	910c      	str	r1, [sp, #48]	; 0x30
   15572:	920b      	str	r2, [sp, #44]	; 0x2c
   15574:	930a      	str	r3, [sp, #40]	; 0x28
   15576:	4633      	mov	r3, r6
   15578:	4619      	mov	r1, r3
   1557a:	48a7      	ldr	r0, [pc, #668]	; (15818 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b0>)
   1557c:	f7fd fed2 	bl	13324 <__cyg_profile_func_enter>
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
   15580:	2300      	movs	r3, #0
   15582:	931b      	str	r3, [sp, #108]	; 0x6c

  if (!buffer) {
   15584:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   15586:	2b00      	cmp	r3, #0
   15588:	d101      	bne.n	1558e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    // use null output function
    out = _out_null;
   1558a:	4ba4      	ldr	r3, [pc, #656]	; (1581c <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b4>)
   1558c:	930d      	str	r3, [sp, #52]	; 0x34
  }

  while (*format)
   1558e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15590:	781b      	ldrb	r3, [r3, #0]
   15592:	2b00      	cmp	r3, #0
   15594:	f000 8448 	beq.w	15e28 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8c0>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
   15598:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1559a:	781b      	ldrb	r3, [r3, #0]
   1559c:	2b25      	cmp	r3, #37	; 0x25
   1559e:	d00d      	beq.n	155bc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x54>
      // no
      out(*format, buffer, idx++, maxlen);
   155a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   155a2:	7818      	ldrb	r0, [r3, #0]
   155a4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   155a6:	1c53      	adds	r3, r2, #1
   155a8:	931b      	str	r3, [sp, #108]	; 0x6c
   155aa:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   155ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   155ae:	990c      	ldr	r1, [sp, #48]	; 0x30
   155b0:	47a0      	blx	r4
      format++;
   155b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   155b4:	3301      	adds	r3, #1
   155b6:	930a      	str	r3, [sp, #40]	; 0x28
      continue;
   155b8:	f000 bc34 	b.w	15e24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
    }
    else {
      // yes, evaluate it
      format++;
   155bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   155be:	3301      	adds	r3, #1
   155c0:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate flags
    flags = 0U;
   155c2:	2300      	movs	r3, #0
   155c4:	931f      	str	r3, [sp, #124]	; 0x7c
    do {
      switch (*format) {
   155c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   155c8:	781b      	ldrb	r3, [r3, #0]
   155ca:	3b20      	subs	r3, #32
   155cc:	2b10      	cmp	r3, #16
   155ce:	d857      	bhi.n	15680 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x118>
   155d0:	a201      	add	r2, pc, #4	; (adr r2, 155d8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x70>)
   155d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   155d6:	bf00      	nop
   155d8:	00015659 	.word	0x00015659
   155dc:	00015681 	.word	0x00015681
   155e0:	00015681 	.word	0x00015681
   155e4:	0001566d 	.word	0x0001566d
   155e8:	00015681 	.word	0x00015681
   155ec:	00015681 	.word	0x00015681
   155f0:	00015681 	.word	0x00015681
   155f4:	00015681 	.word	0x00015681
   155f8:	00015681 	.word	0x00015681
   155fc:	00015681 	.word	0x00015681
   15600:	00015681 	.word	0x00015681
   15604:	00015645 	.word	0x00015645
   15608:	00015681 	.word	0x00015681
   1560c:	00015631 	.word	0x00015631
   15610:	00015681 	.word	0x00015681
   15614:	00015681 	.word	0x00015681
   15618:	0001561d 	.word	0x0001561d
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
   1561c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1561e:	f043 0301 	orr.w	r3, r3, #1
   15622:	931f      	str	r3, [sp, #124]	; 0x7c
   15624:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15626:	3301      	adds	r3, #1
   15628:	930a      	str	r3, [sp, #40]	; 0x28
   1562a:	2301      	movs	r3, #1
   1562c:	931c      	str	r3, [sp, #112]	; 0x70
   1562e:	e02a      	b.n	15686 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
   15630:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15632:	f043 0302 	orr.w	r3, r3, #2
   15636:	931f      	str	r3, [sp, #124]	; 0x7c
   15638:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1563a:	3301      	adds	r3, #1
   1563c:	930a      	str	r3, [sp, #40]	; 0x28
   1563e:	2301      	movs	r3, #1
   15640:	931c      	str	r3, [sp, #112]	; 0x70
   15642:	e020      	b.n	15686 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
   15644:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15646:	f043 0304 	orr.w	r3, r3, #4
   1564a:	931f      	str	r3, [sp, #124]	; 0x7c
   1564c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1564e:	3301      	adds	r3, #1
   15650:	930a      	str	r3, [sp, #40]	; 0x28
   15652:	2301      	movs	r3, #1
   15654:	931c      	str	r3, [sp, #112]	; 0x70
   15656:	e016      	b.n	15686 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
   15658:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1565a:	f043 0308 	orr.w	r3, r3, #8
   1565e:	931f      	str	r3, [sp, #124]	; 0x7c
   15660:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15662:	3301      	adds	r3, #1
   15664:	930a      	str	r3, [sp, #40]	; 0x28
   15666:	2301      	movs	r3, #1
   15668:	931c      	str	r3, [sp, #112]	; 0x70
   1566a:	e00c      	b.n	15686 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
   1566c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1566e:	f043 0310 	orr.w	r3, r3, #16
   15672:	931f      	str	r3, [sp, #124]	; 0x7c
   15674:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15676:	3301      	adds	r3, #1
   15678:	930a      	str	r3, [sp, #40]	; 0x28
   1567a:	2301      	movs	r3, #1
   1567c:	931c      	str	r3, [sp, #112]	; 0x70
   1567e:	e002      	b.n	15686 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x11e>
        default :                                   n = 0U; break;
   15680:	2300      	movs	r3, #0
   15682:	931c      	str	r3, [sp, #112]	; 0x70
   15684:	bf00      	nop
      }
    } while (n);
   15686:	9b1c      	ldr	r3, [sp, #112]	; 0x70
   15688:	2b00      	cmp	r3, #0
   1568a:	d000      	beq.n	1568e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x126>
    do {
   1568c:	e79b      	b.n	155c6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5e>

    // evaluate width field
    width = 0U;
   1568e:	2300      	movs	r3, #0
   15690:	931e      	str	r3, [sp, #120]	; 0x78
    if (_is_digit(*format)) {
   15692:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15694:	781b      	ldrb	r3, [r3, #0]
   15696:	4618      	mov	r0, r3
   15698:	f7ff fade 	bl	14c58 <_is_digit(char)>
   1569c:	4603      	mov	r3, r0
   1569e:	2b00      	cmp	r3, #0
   156a0:	d005      	beq.n	156ae <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x146>
      width = _atoi(&format);
   156a2:	ab0a      	add	r3, sp, #40	; 0x28
   156a4:	4618      	mov	r0, r3
   156a6:	f7ff faf9 	bl	14c9c <_atoi(char const**)>
   156aa:	901e      	str	r0, [sp, #120]	; 0x78
   156ac:	e018      	b.n	156e0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
    }
    else if (*format == '*') {
   156ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   156b0:	781b      	ldrb	r3, [r3, #0]
   156b2:	2b2a      	cmp	r3, #42	; 0x2a
   156b4:	d114      	bne.n	156e0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x178>
      const int w = va_arg(va, int);
   156b6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   156b8:	1d1a      	adds	r2, r3, #4
   156ba:	9224      	str	r2, [sp, #144]	; 0x90
   156bc:	681b      	ldr	r3, [r3, #0]
   156be:	9316      	str	r3, [sp, #88]	; 0x58
      if (w < 0) {
   156c0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   156c2:	2b00      	cmp	r3, #0
   156c4:	da07      	bge.n	156d6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x16e>
        flags |= FLAGS_LEFT;    // reverse padding
   156c6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   156c8:	f043 0302 	orr.w	r3, r3, #2
   156cc:	931f      	str	r3, [sp, #124]	; 0x7c
        width = (unsigned int)-w;
   156ce:	9b16      	ldr	r3, [sp, #88]	; 0x58
   156d0:	425b      	negs	r3, r3
   156d2:	931e      	str	r3, [sp, #120]	; 0x78
   156d4:	e001      	b.n	156da <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x172>
      }
      else {
        width = (unsigned int)w;
   156d6:	9b16      	ldr	r3, [sp, #88]	; 0x58
   156d8:	931e      	str	r3, [sp, #120]	; 0x78
      }
      format++;
   156da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   156dc:	3301      	adds	r3, #1
   156de:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // evaluate precision field
    precision = 0U;
   156e0:	2300      	movs	r3, #0
   156e2:	931d      	str	r3, [sp, #116]	; 0x74
    if (*format == '.') {
   156e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   156e6:	781b      	ldrb	r3, [r3, #0]
   156e8:	2b2e      	cmp	r3, #46	; 0x2e
   156ea:	d124      	bne.n	15736 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      flags |= FLAGS_PRECISION;
   156ec:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   156ee:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   156f2:	931f      	str	r3, [sp, #124]	; 0x7c
      format++;
   156f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   156f6:	3301      	adds	r3, #1
   156f8:	930a      	str	r3, [sp, #40]	; 0x28
      if (_is_digit(*format)) {
   156fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   156fc:	781b      	ldrb	r3, [r3, #0]
   156fe:	4618      	mov	r0, r3
   15700:	f7ff faaa 	bl	14c58 <_is_digit(char)>
   15704:	4603      	mov	r3, r0
   15706:	2b00      	cmp	r3, #0
   15708:	d005      	beq.n	15716 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ae>
        precision = _atoi(&format);
   1570a:	ab0a      	add	r3, sp, #40	; 0x28
   1570c:	4618      	mov	r0, r3
   1570e:	f7ff fac5 	bl	14c9c <_atoi(char const**)>
   15712:	901d      	str	r0, [sp, #116]	; 0x74
   15714:	e00f      	b.n	15736 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
      }
      else if (*format == '*') {
   15716:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15718:	781b      	ldrb	r3, [r3, #0]
   1571a:	2b2a      	cmp	r3, #42	; 0x2a
   1571c:	d10b      	bne.n	15736 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1ce>
        const int prec = (int)va_arg(va, int);
   1571e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15720:	1d1a      	adds	r2, r3, #4
   15722:	9224      	str	r2, [sp, #144]	; 0x90
   15724:	681b      	ldr	r3, [r3, #0]
   15726:	9315      	str	r3, [sp, #84]	; 0x54
        precision = prec > 0 ? (unsigned int)prec : 0U;
   15728:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1572a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   1572e:	931d      	str	r3, [sp, #116]	; 0x74
        format++;
   15730:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15732:	3301      	adds	r3, #1
   15734:	930a      	str	r3, [sp, #40]	; 0x28
      }
    }

    // evaluate length field
    switch (*format) {
   15736:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15738:	781b      	ldrb	r3, [r3, #0]
   1573a:	3b68      	subs	r3, #104	; 0x68
   1573c:	2b12      	cmp	r3, #18
   1573e:	d867      	bhi.n	15810 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2a8>
   15740:	a201      	add	r2, pc, #4	; (adr r2, 15748 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x1e0>)
   15742:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   15746:	bf00      	nop
   15748:	000157bb 	.word	0x000157bb
   1574c:	00015811 	.word	0x00015811
   15750:	000157f1 	.word	0x000157f1
   15754:	00015811 	.word	0x00015811
   15758:	00015795 	.word	0x00015795
   1575c:	00015811 	.word	0x00015811
   15760:	00015811 	.word	0x00015811
   15764:	00015811 	.word	0x00015811
   15768:	00015811 	.word	0x00015811
   1576c:	00015811 	.word	0x00015811
   15770:	00015811 	.word	0x00015811
   15774:	00015811 	.word	0x00015811
   15778:	000157e1 	.word	0x000157e1
   1577c:	00015811 	.word	0x00015811
   15780:	00015811 	.word	0x00015811
   15784:	00015811 	.word	0x00015811
   15788:	00015811 	.word	0x00015811
   1578c:	00015811 	.word	0x00015811
   15790:	00015801 	.word	0x00015801
      case 'l' :
        flags |= FLAGS_LONG;
   15794:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15796:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1579a:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   1579c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1579e:	3301      	adds	r3, #1
   157a0:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'l') {
   157a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157a4:	781b      	ldrb	r3, [r3, #0]
   157a6:	2b6c      	cmp	r3, #108	; 0x6c
   157a8:	d134      	bne.n	15814 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
          flags |= FLAGS_LONG_LONG;
   157aa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   157ac:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   157b0:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   157b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157b4:	3301      	adds	r3, #1
   157b6:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   157b8:	e02c      	b.n	15814 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ac>
      case 'h' :
        flags |= FLAGS_SHORT;
   157ba:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   157bc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   157c0:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   157c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157c4:	3301      	adds	r3, #1
   157c6:	930a      	str	r3, [sp, #40]	; 0x28
        if (*format == 'h') {
   157c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157ca:	781b      	ldrb	r3, [r3, #0]
   157cc:	2b68      	cmp	r3, #104	; 0x68
   157ce:	d127      	bne.n	15820 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
          flags |= FLAGS_CHAR;
   157d0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   157d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   157d6:	931f      	str	r3, [sp, #124]	; 0x7c
          format++;
   157d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157da:	3301      	adds	r3, #1
   157dc:	930a      	str	r3, [sp, #40]	; 0x28
        }
        break;
   157de:	e01f      	b.n	15820 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2b8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   157e0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   157e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   157e6:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   157e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157ea:	3301      	adds	r3, #1
   157ec:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   157ee:	e018      	b.n	15822 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   157f0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   157f2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   157f6:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   157f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   157fa:	3301      	adds	r3, #1
   157fc:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   157fe:	e010      	b.n	15822 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
   15800:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15802:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   15806:	931f      	str	r3, [sp, #124]	; 0x7c
        format++;
   15808:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1580a:	3301      	adds	r3, #1
   1580c:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   1580e:	e008      	b.n	15822 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
      default :
        break;
   15810:	bf00      	nop
   15812:	e006      	b.n	15822 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
        break;
   15814:	bf00      	nop
   15816:	e004      	b.n	15822 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2ba>
   15818:	00015569 	.word	0x00015569
   1581c:	00014ba1 	.word	0x00014ba1
        break;
   15820:	bf00      	nop
    }

    // evaluate specifier
    switch (*format) {
   15822:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15824:	781b      	ldrb	r3, [r3, #0]
   15826:	3b25      	subs	r3, #37	; 0x25
   15828:	2b53      	cmp	r3, #83	; 0x53
   1582a:	f200 82ee 	bhi.w	15e0a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8a2>
   1582e:	a201      	add	r2, pc, #4	; (adr r2, 15834 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x2cc>)
   15830:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   15834:	00015df3 	.word	0x00015df3
   15838:	00015e0b 	.word	0x00015e0b
   1583c:	00015e0b 	.word	0x00015e0b
   15840:	00015e0b 	.word	0x00015e0b
   15844:	00015e0b 	.word	0x00015e0b
   15848:	00015e0b 	.word	0x00015e0b
   1584c:	00015e0b 	.word	0x00015e0b
   15850:	00015e0b 	.word	0x00015e0b
   15854:	00015e0b 	.word	0x00015e0b
   15858:	00015e0b 	.word	0x00015e0b
   1585c:	00015e0b 	.word	0x00015e0b
   15860:	00015e0b 	.word	0x00015e0b
   15864:	00015e0b 	.word	0x00015e0b
   15868:	00015e0b 	.word	0x00015e0b
   1586c:	00015e0b 	.word	0x00015e0b
   15870:	00015e0b 	.word	0x00015e0b
   15874:	00015e0b 	.word	0x00015e0b
   15878:	00015e0b 	.word	0x00015e0b
   1587c:	00015e0b 	.word	0x00015e0b
   15880:	00015e0b 	.word	0x00015e0b
   15884:	00015e0b 	.word	0x00015e0b
   15888:	00015e0b 	.word	0x00015e0b
   1588c:	00015e0b 	.word	0x00015e0b
   15890:	00015e0b 	.word	0x00015e0b
   15894:	00015e0b 	.word	0x00015e0b
   15898:	00015e0b 	.word	0x00015e0b
   1589c:	00015e0b 	.word	0x00015e0b
   158a0:	00015e0b 	.word	0x00015e0b
   158a4:	00015e0b 	.word	0x00015e0b
   158a8:	00015e0b 	.word	0x00015e0b
   158ac:	00015e0b 	.word	0x00015e0b
   158b0:	00015e0b 	.word	0x00015e0b
   158b4:	00015e0b 	.word	0x00015e0b
   158b8:	00015c11 	.word	0x00015c11
   158bc:	00015e0b 	.word	0x00015e0b
   158c0:	00015e0b 	.word	0x00015e0b
   158c4:	00015e0b 	.word	0x00015e0b
   158c8:	00015e0b 	.word	0x00015e0b
   158cc:	00015e0b 	.word	0x00015e0b
   158d0:	00015e0b 	.word	0x00015e0b
   158d4:	00015e0b 	.word	0x00015e0b
   158d8:	00015e0b 	.word	0x00015e0b
   158dc:	00015e0b 	.word	0x00015e0b
   158e0:	00015e0b 	.word	0x00015e0b
   158e4:	00015e0b 	.word	0x00015e0b
   158e8:	00015e0b 	.word	0x00015e0b
   158ec:	00015e0b 	.word	0x00015e0b
   158f0:	00015e0b 	.word	0x00015e0b
   158f4:	00015e0b 	.word	0x00015e0b
   158f8:	00015e0b 	.word	0x00015e0b
   158fc:	00015e0b 	.word	0x00015e0b
   15900:	00015985 	.word	0x00015985
   15904:	00015e0b 	.word	0x00015e0b
   15908:	00015e0b 	.word	0x00015e0b
   1590c:	00015e0b 	.word	0x00015e0b
   15910:	00015e0b 	.word	0x00015e0b
   15914:	00015e0b 	.word	0x00015e0b
   15918:	00015e0b 	.word	0x00015e0b
   1591c:	00015e0b 	.word	0x00015e0b
   15920:	00015e0b 	.word	0x00015e0b
   15924:	00015e0b 	.word	0x00015e0b
   15928:	00015985 	.word	0x00015985
   1592c:	00015c4d 	.word	0x00015c4d
   15930:	00015985 	.word	0x00015985
   15934:	00015e0b 	.word	0x00015e0b
   15938:	00015c11 	.word	0x00015c11
   1593c:	00015e0b 	.word	0x00015e0b
   15940:	00015e0b 	.word	0x00015e0b
   15944:	00015985 	.word	0x00015985
   15948:	00015e0b 	.word	0x00015e0b
   1594c:	00015e0b 	.word	0x00015e0b
   15950:	00015e0b 	.word	0x00015e0b
   15954:	00015e0b 	.word	0x00015e0b
   15958:	00015e0b 	.word	0x00015e0b
   1595c:	00015985 	.word	0x00015985
   15960:	00015dab 	.word	0x00015dab
   15964:	00015e0b 	.word	0x00015e0b
   15968:	00015e0b 	.word	0x00015e0b
   1596c:	00015cd5 	.word	0x00015cd5
   15970:	00015e0b 	.word	0x00015e0b
   15974:	00015985 	.word	0x00015985
   15978:	00015e0b 	.word	0x00015e0b
   1597c:	00015e0b 	.word	0x00015e0b
   15980:	00015985 	.word	0x00015985
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
   15984:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15986:	781b      	ldrb	r3, [r3, #0]
   15988:	2b78      	cmp	r3, #120	; 0x78
   1598a:	d003      	beq.n	15994 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x42c>
   1598c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1598e:	781b      	ldrb	r3, [r3, #0]
   15990:	2b58      	cmp	r3, #88	; 0x58
   15992:	d102      	bne.n	1599a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x432>
          base = 16U;
   15994:	2310      	movs	r3, #16
   15996:	931a      	str	r3, [sp, #104]	; 0x68
   15998:	e013      	b.n	159c2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'o') {
   1599a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1599c:	781b      	ldrb	r3, [r3, #0]
   1599e:	2b6f      	cmp	r3, #111	; 0x6f
   159a0:	d102      	bne.n	159a8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x440>
          base =  8U;
   159a2:	2308      	movs	r3, #8
   159a4:	931a      	str	r3, [sp, #104]	; 0x68
   159a6:	e00c      	b.n	159c2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else if (*format == 'b') {
   159a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159aa:	781b      	ldrb	r3, [r3, #0]
   159ac:	2b62      	cmp	r3, #98	; 0x62
   159ae:	d102      	bne.n	159b6 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x44e>
          base =  2U;
   159b0:	2302      	movs	r3, #2
   159b2:	931a      	str	r3, [sp, #104]	; 0x68
   159b4:	e005      	b.n	159c2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x45a>
        }
        else {
          base = 10U;
   159b6:	230a      	movs	r3, #10
   159b8:	931a      	str	r3, [sp, #104]	; 0x68
          flags &= ~FLAGS_HASH;   // no hash for dec format
   159ba:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159bc:	f023 0310 	bic.w	r3, r3, #16
   159c0:	931f      	str	r3, [sp, #124]	; 0x7c
        }
        // uppercase
        if (*format == 'X') {
   159c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159c4:	781b      	ldrb	r3, [r3, #0]
   159c6:	2b58      	cmp	r3, #88	; 0x58
   159c8:	d103      	bne.n	159d2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x46a>
          flags |= FLAGS_UPPERCASE;
   159ca:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159cc:	f043 0320 	orr.w	r3, r3, #32
   159d0:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
   159d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159d4:	781b      	ldrb	r3, [r3, #0]
   159d6:	2b69      	cmp	r3, #105	; 0x69
   159d8:	d007      	beq.n	159ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
   159da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159dc:	781b      	ldrb	r3, [r3, #0]
   159de:	2b64      	cmp	r3, #100	; 0x64
   159e0:	d003      	beq.n	159ea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x482>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
   159e2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159e4:	f023 030c 	bic.w	r3, r3, #12
   159e8:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
   159ea:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159ec:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   159f0:	2b00      	cmp	r3, #0
   159f2:	d003      	beq.n	159fc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x494>
          flags &= ~FLAGS_ZEROPAD;
   159f4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   159f6:	f023 0301 	bic.w	r3, r3, #1
   159fa:	931f      	str	r3, [sp, #124]	; 0x7c
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
   159fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   159fe:	781b      	ldrb	r3, [r3, #0]
   15a00:	2b69      	cmp	r3, #105	; 0x69
   15a02:	d004      	beq.n	15a0e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4a6>
   15a04:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15a06:	781b      	ldrb	r3, [r3, #0]
   15a08:	2b64      	cmp	r3, #100	; 0x64
   15a0a:	f040 808d 	bne.w	15b28 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x5c0>
          // signed
          if (flags & FLAGS_LONG_LONG) {
   15a0e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15a10:	f403 7300 	and.w	r3, r3, #512	; 0x200
   15a14:	2b00      	cmp	r3, #0
   15a16:	d02e      	beq.n	15a76 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x50e>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
   15a18:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15a1a:	3307      	adds	r3, #7
   15a1c:	f023 0307 	bic.w	r3, r3, #7
   15a20:	f103 0208 	add.w	r2, r3, #8
   15a24:	9224      	str	r2, [sp, #144]	; 0x90
   15a26:	e9d3 3400 	ldrd	r3, r4, [r3]
   15a2a:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   15a2e:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   15a32:	2b00      	cmp	r3, #0
   15a34:	f174 0200 	sbcs.w	r2, r4, #0
   15a38:	da02      	bge.n	15a40 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x4d8>
   15a3a:	425b      	negs	r3, r3
   15a3c:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
   15a40:	4619      	mov	r1, r3
   15a42:	4622      	mov	r2, r4
   15a44:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   15a46:	0fdb      	lsrs	r3, r3, #31
   15a48:	b2d8      	uxtb	r0, r3
   15a4a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   15a4c:	f04f 0400 	mov.w	r4, #0
   15a50:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
   15a52:	9508      	str	r5, [sp, #32]
   15a54:	9d1e      	ldr	r5, [sp, #120]	; 0x78
   15a56:	9507      	str	r5, [sp, #28]
   15a58:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   15a5a:	9506      	str	r5, [sp, #24]
   15a5c:	e9cd 3404 	strd	r3, r4, [sp, #16]
   15a60:	9002      	str	r0, [sp, #8]
   15a62:	e9cd 1200 	strd	r1, r2, [sp]
   15a66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15a68:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15a6a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15a6c:	980d      	ldr	r0, [sp, #52]	; 0x34
   15a6e:	f7ff fae5 	bl	1503c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   15a72:	901b      	str	r0, [sp, #108]	; 0x6c
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
          }
   15a74:	e0c8      	b.n	15c08 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          else if (flags & FLAGS_LONG) {
   15a76:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15a78:	f403 7380 	and.w	r3, r3, #256	; 0x100
   15a7c:	2b00      	cmp	r3, #0
   15a7e:	d01e      	beq.n	15abe <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x556>
            const long value = va_arg(va, long);
   15a80:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15a82:	1d1a      	adds	r2, r3, #4
   15a84:	9224      	str	r2, [sp, #144]	; 0x90
   15a86:	681b      	ldr	r3, [r3, #0]
   15a88:	9311      	str	r3, [sp, #68]	; 0x44
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   15a8a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15a8c:	2b00      	cmp	r3, #0
   15a8e:	bfb8      	it	lt
   15a90:	425b      	neglt	r3, r3
   15a92:	4619      	mov	r1, r3
   15a94:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15a96:	0fdb      	lsrs	r3, r3, #31
   15a98:	b2db      	uxtb	r3, r3
   15a9a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15a9c:	9205      	str	r2, [sp, #20]
   15a9e:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15aa0:	9204      	str	r2, [sp, #16]
   15aa2:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   15aa4:	9203      	str	r2, [sp, #12]
   15aa6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15aa8:	9202      	str	r2, [sp, #8]
   15aaa:	9301      	str	r3, [sp, #4]
   15aac:	9100      	str	r1, [sp, #0]
   15aae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15ab0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15ab2:	990c      	ldr	r1, [sp, #48]	; 0x30
   15ab4:	980d      	ldr	r0, [sp, #52]	; 0x34
   15ab6:	f7ff fa4f 	bl	14f58 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15aba:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   15abc:	e0a4      	b.n	15c08 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
   15abe:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15ac0:	f003 0340 	and.w	r3, r3, #64	; 0x40
   15ac4:	2b00      	cmp	r3, #0
   15ac6:	d005      	beq.n	15ad4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x56c>
   15ac8:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15aca:	1d1a      	adds	r2, r3, #4
   15acc:	9224      	str	r2, [sp, #144]	; 0x90
   15ace:	681b      	ldr	r3, [r3, #0]
   15ad0:	b2db      	uxtb	r3, r3
   15ad2:	e00e      	b.n	15af2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   15ad4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15ad6:	f003 0380 	and.w	r3, r3, #128	; 0x80
   15ada:	2b00      	cmp	r3, #0
   15adc:	d005      	beq.n	15aea <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x582>
   15ade:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15ae0:	1d1a      	adds	r2, r3, #4
   15ae2:	9224      	str	r2, [sp, #144]	; 0x90
   15ae4:	681b      	ldr	r3, [r3, #0]
   15ae6:	b21b      	sxth	r3, r3
   15ae8:	e003      	b.n	15af2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x58a>
   15aea:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15aec:	1d1a      	adds	r2, r3, #4
   15aee:	9224      	str	r2, [sp, #144]	; 0x90
   15af0:	681b      	ldr	r3, [r3, #0]
   15af2:	9312      	str	r3, [sp, #72]	; 0x48
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
   15af4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15af6:	2b00      	cmp	r3, #0
   15af8:	bfb8      	it	lt
   15afa:	425b      	neglt	r3, r3
   15afc:	4619      	mov	r1, r3
   15afe:	9b12      	ldr	r3, [sp, #72]	; 0x48
   15b00:	0fdb      	lsrs	r3, r3, #31
   15b02:	b2db      	uxtb	r3, r3
   15b04:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15b06:	9205      	str	r2, [sp, #20]
   15b08:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15b0a:	9204      	str	r2, [sp, #16]
   15b0c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   15b0e:	9203      	str	r2, [sp, #12]
   15b10:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15b12:	9202      	str	r2, [sp, #8]
   15b14:	9301      	str	r3, [sp, #4]
   15b16:	9100      	str	r1, [sp, #0]
   15b18:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15b1a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15b1c:	990c      	ldr	r1, [sp, #48]	; 0x30
   15b1e:	980d      	ldr	r0, [sp, #52]	; 0x34
   15b20:	f7ff fa1a 	bl	14f58 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15b24:	901b      	str	r0, [sp, #108]	; 0x6c
          }
   15b26:	e06f      	b.n	15c08 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
   15b28:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15b2a:	f403 7300 	and.w	r3, r3, #512	; 0x200
   15b2e:	2b00      	cmp	r3, #0
   15b30:	d020      	beq.n	15b74 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x60c>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
   15b32:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15b34:	3307      	adds	r3, #7
   15b36:	f023 0307 	bic.w	r3, r3, #7
   15b3a:	f103 0208 	add.w	r2, r3, #8
   15b3e:	9224      	str	r2, [sp, #144]	; 0x90
   15b40:	e9d3 3400 	ldrd	r3, r4, [r3]
   15b44:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15b46:	4611      	mov	r1, r2
   15b48:	f04f 0200 	mov.w	r2, #0
   15b4c:	981f      	ldr	r0, [sp, #124]	; 0x7c
   15b4e:	9008      	str	r0, [sp, #32]
   15b50:	981e      	ldr	r0, [sp, #120]	; 0x78
   15b52:	9007      	str	r0, [sp, #28]
   15b54:	981d      	ldr	r0, [sp, #116]	; 0x74
   15b56:	9006      	str	r0, [sp, #24]
   15b58:	e9cd 1204 	strd	r1, r2, [sp, #16]
   15b5c:	2200      	movs	r2, #0
   15b5e:	9202      	str	r2, [sp, #8]
   15b60:	e9cd 3400 	strd	r3, r4, [sp]
   15b64:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15b66:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15b68:	990c      	ldr	r1, [sp, #48]	; 0x30
   15b6a:	980d      	ldr	r0, [sp, #52]	; 0x34
   15b6c:	f7ff fa66 	bl	1503c <_ntoa_long_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long long, bool, unsigned long long, unsigned int, unsigned int, unsigned int)>
   15b70:	901b      	str	r0, [sp, #108]	; 0x6c
   15b72:	e049      	b.n	15c08 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
#endif
          }
          else if (flags & FLAGS_LONG) {
   15b74:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15b76:	f403 7380 	and.w	r3, r3, #256	; 0x100
   15b7a:	2b00      	cmp	r3, #0
   15b7c:	d016      	beq.n	15bac <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x644>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
   15b7e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15b80:	1d1a      	adds	r2, r3, #4
   15b82:	9224      	str	r2, [sp, #144]	; 0x90
   15b84:	681b      	ldr	r3, [r3, #0]
   15b86:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   15b88:	9205      	str	r2, [sp, #20]
   15b8a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15b8c:	9204      	str	r2, [sp, #16]
   15b8e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
   15b90:	9203      	str	r2, [sp, #12]
   15b92:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   15b94:	9202      	str	r2, [sp, #8]
   15b96:	2200      	movs	r2, #0
   15b98:	9201      	str	r2, [sp, #4]
   15b9a:	9300      	str	r3, [sp, #0]
   15b9c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15b9e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15ba0:	990c      	ldr	r1, [sp, #48]	; 0x30
   15ba2:	980d      	ldr	r0, [sp, #52]	; 0x34
   15ba4:	f7ff f9d8 	bl	14f58 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15ba8:	901b      	str	r0, [sp, #108]	; 0x6c
   15baa:	e02d      	b.n	15c08 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6a0>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
   15bac:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15bae:	f003 0340 	and.w	r3, r3, #64	; 0x40
   15bb2:	2b00      	cmp	r3, #0
   15bb4:	d005      	beq.n	15bc2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x65a>
   15bb6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15bb8:	1d1a      	adds	r2, r3, #4
   15bba:	9224      	str	r2, [sp, #144]	; 0x90
   15bbc:	681b      	ldr	r3, [r3, #0]
   15bbe:	b2db      	uxtb	r3, r3
   15bc0:	e00e      	b.n	15be0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   15bc2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15bc4:	f003 0380 	and.w	r3, r3, #128	; 0x80
   15bc8:	2b00      	cmp	r3, #0
   15bca:	d005      	beq.n	15bd8 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x670>
   15bcc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15bce:	1d1a      	adds	r2, r3, #4
   15bd0:	9224      	str	r2, [sp, #144]	; 0x90
   15bd2:	681b      	ldr	r3, [r3, #0]
   15bd4:	b29b      	uxth	r3, r3
   15bd6:	e003      	b.n	15be0 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x678>
   15bd8:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15bda:	1d1a      	adds	r2, r3, #4
   15bdc:	9224      	str	r2, [sp, #144]	; 0x90
   15bde:	681b      	ldr	r3, [r3, #0]
   15be0:	9313      	str	r3, [sp, #76]	; 0x4c
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
   15be2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15be4:	9305      	str	r3, [sp, #20]
   15be6:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15be8:	9304      	str	r3, [sp, #16]
   15bea:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15bec:	9303      	str	r3, [sp, #12]
   15bee:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   15bf0:	9302      	str	r3, [sp, #8]
   15bf2:	2300      	movs	r3, #0
   15bf4:	9301      	str	r3, [sp, #4]
   15bf6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   15bf8:	9300      	str	r3, [sp, #0]
   15bfa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15bfc:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15bfe:	990c      	ldr	r1, [sp, #48]	; 0x30
   15c00:	980d      	ldr	r0, [sp, #52]	; 0x34
   15c02:	f7ff f9a9 	bl	14f58 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15c06:	901b      	str	r0, [sp, #108]	; 0x6c
          }
        }
        format++;
   15c08:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15c0a:	3301      	adds	r3, #1
   15c0c:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15c0e:	e109      	b.n	15e24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }
#if defined(PRINTF_SUPPORT_FLOAT)
      case 'f' :
      case 'F' :
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
   15c10:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15c12:	3307      	adds	r3, #7
   15c14:	f023 0307 	bic.w	r3, r3, #7
   15c18:	f103 0208 	add.w	r2, r3, #8
   15c1c:	9224      	str	r2, [sp, #144]	; 0x90
   15c1e:	ed93 7b00 	vldr	d7, [r3]
   15c22:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15c24:	9302      	str	r3, [sp, #8]
   15c26:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15c28:	9301      	str	r3, [sp, #4]
   15c2a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15c2c:	9300      	str	r3, [sp, #0]
   15c2e:	eeb0 0a47 	vmov.f32	s0, s14
   15c32:	eef0 0a67 	vmov.f32	s1, s15
   15c36:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15c38:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15c3a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15c3c:	980d      	ldr	r0, [sp, #52]	; 0x34
   15c3e:	f7ff fa77 	bl	15130 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)>
   15c42:	901b      	str	r0, [sp, #108]	; 0x6c
        format++;
   15c44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15c46:	3301      	adds	r3, #1
   15c48:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15c4a:	e0eb      	b.n	15e24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
   15c4c:	2301      	movs	r3, #1
   15c4e:	9319      	str	r3, [sp, #100]	; 0x64
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
   15c50:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15c52:	f003 0302 	and.w	r3, r3, #2
   15c56:	2b00      	cmp	r3, #0
   15c58:	d113      	bne.n	15c82 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
          while (l++ < width) {
   15c5a:	9b19      	ldr	r3, [sp, #100]	; 0x64
   15c5c:	1c5a      	adds	r2, r3, #1
   15c5e:	9219      	str	r2, [sp, #100]	; 0x64
   15c60:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15c62:	429a      	cmp	r2, r3
   15c64:	bf8c      	ite	hi
   15c66:	2301      	movhi	r3, #1
   15c68:	2300      	movls	r3, #0
   15c6a:	b2db      	uxtb	r3, r3
   15c6c:	2b00      	cmp	r3, #0
   15c6e:	d008      	beq.n	15c82 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x71a>
            out(' ', buffer, idx++, maxlen);
   15c70:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15c72:	1c53      	adds	r3, r2, #1
   15c74:	931b      	str	r3, [sp, #108]	; 0x6c
   15c76:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15c78:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15c7a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15c7c:	2020      	movs	r0, #32
   15c7e:	47a0      	blx	r4
          while (l++ < width) {
   15c80:	e7eb      	b.n	15c5a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x6f2>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
   15c82:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15c84:	1d1a      	adds	r2, r3, #4
   15c86:	9224      	str	r2, [sp, #144]	; 0x90
   15c88:	681b      	ldr	r3, [r3, #0]
   15c8a:	b2d8      	uxtb	r0, r3
   15c8c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15c8e:	1c53      	adds	r3, r2, #1
   15c90:	931b      	str	r3, [sp, #108]	; 0x6c
   15c92:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15c94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15c96:	990c      	ldr	r1, [sp, #48]	; 0x30
   15c98:	47a0      	blx	r4
        // post padding
        if (flags & FLAGS_LEFT) {
   15c9a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15c9c:	f003 0302 	and.w	r3, r3, #2
   15ca0:	2b00      	cmp	r3, #0
   15ca2:	d013      	beq.n	15ccc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
          while (l++ < width) {
   15ca4:	9b19      	ldr	r3, [sp, #100]	; 0x64
   15ca6:	1c5a      	adds	r2, r3, #1
   15ca8:	9219      	str	r2, [sp, #100]	; 0x64
   15caa:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15cac:	429a      	cmp	r2, r3
   15cae:	bf8c      	ite	hi
   15cb0:	2301      	movhi	r3, #1
   15cb2:	2300      	movls	r3, #0
   15cb4:	b2db      	uxtb	r3, r3
   15cb6:	2b00      	cmp	r3, #0
   15cb8:	d008      	beq.n	15ccc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x764>
            out(' ', buffer, idx++, maxlen);
   15cba:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15cbc:	1c53      	adds	r3, r2, #1
   15cbe:	931b      	str	r3, [sp, #108]	; 0x6c
   15cc0:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15cc2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15cc4:	990c      	ldr	r1, [sp, #48]	; 0x30
   15cc6:	2020      	movs	r0, #32
   15cc8:	47a0      	blx	r4
          while (l++ < width) {
   15cca:	e7eb      	b.n	15ca4 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x73c>
          }
        }
        format++;
   15ccc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15cce:	3301      	adds	r3, #1
   15cd0:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15cd2:	e0a7      	b.n	15e24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 's' : {
        char* p = va_arg(va, char*);
   15cd4:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15cd6:	1d1a      	adds	r2, r3, #4
   15cd8:	9224      	str	r2, [sp, #144]	; 0x90
   15cda:	681b      	ldr	r3, [r3, #0]
   15cdc:	9318      	str	r3, [sp, #96]	; 0x60
        unsigned int l = _strlen(p);
   15cde:	9818      	ldr	r0, [sp, #96]	; 0x60
   15ce0:	f7fe ff98 	bl	14c14 <_strlen(char const*)>
   15ce4:	9017      	str	r0, [sp, #92]	; 0x5c
        // pre padding
        if (flags & FLAGS_PRECISION) {
   15ce6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15ce8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   15cec:	2b00      	cmp	r3, #0
   15cee:	d007      	beq.n	15d00 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x798>
          l = (l < precision ? l : precision);
   15cf0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   15cf2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15cf4:	429a      	cmp	r2, r3
   15cf6:	d201      	bcs.n	15cfc <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x794>
   15cf8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   15cfa:	e000      	b.n	15cfe <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x796>
   15cfc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15cfe:	9317      	str	r3, [sp, #92]	; 0x5c
        }
        if (!(flags & FLAGS_LEFT)) {
   15d00:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15d02:	f003 0302 	and.w	r3, r3, #2
   15d06:	2b00      	cmp	r3, #0
   15d08:	d113      	bne.n	15d32 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
          while (l++ < width) {
   15d0a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   15d0c:	1c5a      	adds	r2, r3, #1
   15d0e:	9217      	str	r2, [sp, #92]	; 0x5c
   15d10:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15d12:	429a      	cmp	r2, r3
   15d14:	bf8c      	ite	hi
   15d16:	2301      	movhi	r3, #1
   15d18:	2300      	movls	r3, #0
   15d1a:	b2db      	uxtb	r3, r3
   15d1c:	2b00      	cmp	r3, #0
   15d1e:	d008      	beq.n	15d32 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
            out(' ', buffer, idx++, maxlen);
   15d20:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15d22:	1c53      	adds	r3, r2, #1
   15d24:	931b      	str	r3, [sp, #108]	; 0x6c
   15d26:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15d28:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15d2a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15d2c:	2020      	movs	r0, #32
   15d2e:	47a0      	blx	r4
          while (l++ < width) {
   15d30:	e7eb      	b.n	15d0a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7a2>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   15d32:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15d34:	781b      	ldrb	r3, [r3, #0]
   15d36:	2b00      	cmp	r3, #0
   15d38:	d00b      	beq.n	15d52 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   15d3a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15d3c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
   15d40:	2b00      	cmp	r3, #0
   15d42:	d004      	beq.n	15d4e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7e6>
   15d44:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15d46:	1e5a      	subs	r2, r3, #1
   15d48:	921d      	str	r2, [sp, #116]	; 0x74
   15d4a:	2b00      	cmp	r3, #0
   15d4c:	d001      	beq.n	15d52 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ea>
   15d4e:	2301      	movs	r3, #1
   15d50:	e000      	b.n	15d54 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ec>
   15d52:	2300      	movs	r3, #0
   15d54:	2b00      	cmp	r3, #0
   15d56:	d00b      	beq.n	15d70 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x808>
          out(*(p++), buffer, idx++, maxlen);
   15d58:	9b18      	ldr	r3, [sp, #96]	; 0x60
   15d5a:	1c5a      	adds	r2, r3, #1
   15d5c:	9218      	str	r2, [sp, #96]	; 0x60
   15d5e:	7818      	ldrb	r0, [r3, #0]
   15d60:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15d62:	1c53      	adds	r3, r2, #1
   15d64:	931b      	str	r3, [sp, #108]	; 0x6c
   15d66:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15d68:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15d6a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15d6c:	47a0      	blx	r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
   15d6e:	e7e0      	b.n	15d32 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x7ca>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
   15d70:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15d72:	f003 0302 	and.w	r3, r3, #2
   15d76:	2b00      	cmp	r3, #0
   15d78:	d013      	beq.n	15da2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
          while (l++ < width) {
   15d7a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   15d7c:	1c5a      	adds	r2, r3, #1
   15d7e:	9217      	str	r2, [sp, #92]	; 0x5c
   15d80:	9a1e      	ldr	r2, [sp, #120]	; 0x78
   15d82:	429a      	cmp	r2, r3
   15d84:	bf8c      	ite	hi
   15d86:	2301      	movhi	r3, #1
   15d88:	2300      	movls	r3, #0
   15d8a:	b2db      	uxtb	r3, r3
   15d8c:	2b00      	cmp	r3, #0
   15d8e:	d008      	beq.n	15da2 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x83a>
            out(' ', buffer, idx++, maxlen);
   15d90:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15d92:	1c53      	adds	r3, r2, #1
   15d94:	931b      	str	r3, [sp, #108]	; 0x6c
   15d96:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15d98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15d9a:	990c      	ldr	r1, [sp, #48]	; 0x30
   15d9c:	2020      	movs	r0, #32
   15d9e:	47a0      	blx	r4
          while (l++ < width) {
   15da0:	e7eb      	b.n	15d7a <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x812>
          }
        }
        format++;
   15da2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15da4:	3301      	adds	r3, #1
   15da6:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15da8:	e03c      	b.n	15e24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
   15daa:	2308      	movs	r3, #8
   15dac:	931e      	str	r3, [sp, #120]	; 0x78
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
   15dae:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15db0:	f043 0321 	orr.w	r3, r3, #33	; 0x21
   15db4:	931f      	str	r3, [sp, #124]	; 0x7c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
   15db6:	2300      	movs	r3, #0
   15db8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
        if (is_ll) {
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
   15dbc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   15dbe:	1d1a      	adds	r2, r3, #4
   15dc0:	9224      	str	r2, [sp, #144]	; 0x90
   15dc2:	681b      	ldr	r3, [r3, #0]
   15dc4:	461a      	mov	r2, r3
   15dc6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   15dc8:	9305      	str	r3, [sp, #20]
   15dca:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   15dcc:	9304      	str	r3, [sp, #16]
   15dce:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   15dd0:	9303      	str	r3, [sp, #12]
   15dd2:	2310      	movs	r3, #16
   15dd4:	9302      	str	r3, [sp, #8]
   15dd6:	2300      	movs	r3, #0
   15dd8:	9301      	str	r3, [sp, #4]
   15dda:	9200      	str	r2, [sp, #0]
   15ddc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15dde:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15de0:	990c      	ldr	r1, [sp, #48]	; 0x30
   15de2:	980d      	ldr	r0, [sp, #52]	; 0x34
   15de4:	f7ff f8b8 	bl	14f58 <_ntoa_long(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, unsigned long, bool, unsigned long, unsigned int, unsigned int, unsigned int)>
   15de8:	901b      	str	r0, [sp, #108]	; 0x6c
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
   15dea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15dec:	3301      	adds	r3, #1
   15dee:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15df0:	e018      	b.n	15e24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
   15df2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15df4:	1c53      	adds	r3, r2, #1
   15df6:	931b      	str	r3, [sp, #108]	; 0x6c
   15df8:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15dfa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15dfc:	990c      	ldr	r1, [sp, #48]	; 0x30
   15dfe:	2025      	movs	r0, #37	; 0x25
   15e00:	47a0      	blx	r4
        format++;
   15e02:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15e04:	3301      	adds	r3, #1
   15e06:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15e08:	e00c      	b.n	15e24 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8bc>

      default :
        out(*format, buffer, idx++, maxlen);
   15e0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15e0c:	7818      	ldrb	r0, [r3, #0]
   15e0e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15e10:	1c53      	adds	r3, r2, #1
   15e12:	931b      	str	r3, [sp, #108]	; 0x6c
   15e14:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15e16:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15e18:	990c      	ldr	r1, [sp, #48]	; 0x30
   15e1a:	47a0      	blx	r4
        format++;
   15e1c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15e1e:	3301      	adds	r3, #1
   15e20:	930a      	str	r3, [sp, #40]	; 0x28
        break;
   15e22:	bf00      	nop
  while (*format)
   15e24:	f7ff bbb3 	b.w	1558e <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x26>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
   15e28:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15e2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15e2c:	429a      	cmp	r2, r3
   15e2e:	d302      	bcc.n	15e36 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8ce>
   15e30:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15e32:	1e5a      	subs	r2, r3, #1
   15e34:	e000      	b.n	15e38 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8d0>
   15e36:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   15e38:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   15e3a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15e3c:	990c      	ldr	r1, [sp, #48]	; 0x30
   15e3e:	2000      	movs	r0, #0
   15e40:	47a0      	blx	r4

  // return written chars without terminating \0
  return (int)idx;
   15e42:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
   15e44:	4633      	mov	r3, r6
   15e46:	4619      	mov	r1, r3
   15e48:	4803      	ldr	r0, [pc, #12]	; (15e58 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)+0x8f0>)
   15e4a:	f7fd fa7f 	bl	1334c <__cyg_profile_func_exit>
   15e4e:	4623      	mov	r3, r4
}
   15e50:	4618      	mov	r0, r3
   15e52:	b020      	add	sp, #128	; 0x80
   15e54:	bd70      	pop	{r4, r5, r6, pc}
   15e56:	bf00      	nop
   15e58:	00015569 	.word	0x00015569

00015e5c <printf>:

///////////////////////////////////////////////////////////////////////////////


int printf(const char* format, ...)
{
   15e5c:	b40f      	push	{r0, r1, r2, r3}
   15e5e:	b530      	push	{r4, r5, lr}
   15e60:	b087      	sub	sp, #28
   15e62:	4675      	mov	r5, lr
   15e64:	462b      	mov	r3, r5
   15e66:	4619      	mov	r1, r3
   15e68:	480d      	ldr	r0, [pc, #52]	; (15ea0 <printf+0x44>)
   15e6a:	f7fd fa5b 	bl	13324 <__cyg_profile_func_enter>
  va_list va;
  va_start(va, format);
   15e6e:	ab0b      	add	r3, sp, #44	; 0x2c
   15e70:	9304      	str	r3, [sp, #16]
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
   15e72:	a903      	add	r1, sp, #12
   15e74:	9b04      	ldr	r3, [sp, #16]
   15e76:	9300      	str	r3, [sp, #0]
   15e78:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15e7a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15e7e:	4809      	ldr	r0, [pc, #36]	; (15ea4 <printf+0x48>)
   15e80:	f7ff fb72 	bl	15568 <_vsnprintf(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, char const*, std::__va_list)>
   15e84:	9005      	str	r0, [sp, #20]
  va_end(va);
  return ret;
   15e86:	9c05      	ldr	r4, [sp, #20]
   15e88:	462b      	mov	r3, r5
   15e8a:	4619      	mov	r1, r3
   15e8c:	4804      	ldr	r0, [pc, #16]	; (15ea0 <printf+0x44>)
   15e8e:	f7fd fa5d 	bl	1334c <__cyg_profile_func_exit>
   15e92:	4623      	mov	r3, r4
}
   15e94:	4618      	mov	r0, r3
   15e96:	b007      	add	sp, #28
   15e98:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   15e9c:	b004      	add	sp, #16
   15e9e:	4770      	bx	lr
   15ea0:	00015e5d 	.word	0x00015e5d
   15ea4:	00014bd1 	.word	0x00014bd1

00015ea8 <PinInterface::PinInterface()>:
class PinInterface
   15ea8:	b530      	push	{r4, r5, lr}
   15eaa:	b083      	sub	sp, #12
   15eac:	4675      	mov	r5, lr
   15eae:	9001      	str	r0, [sp, #4]
   15eb0:	462b      	mov	r3, r5
   15eb2:	4619      	mov	r1, r3
   15eb4:	4807      	ldr	r0, [pc, #28]	; (15ed4 <PinInterface::PinInterface()+0x2c>)
   15eb6:	f7fd fa35 	bl	13324 <__cyg_profile_func_enter>
   15eba:	4a07      	ldr	r2, [pc, #28]	; (15ed8 <PinInterface::PinInterface()+0x30>)
   15ebc:	9b01      	ldr	r3, [sp, #4]
   15ebe:	601a      	str	r2, [r3, #0]
   15ec0:	9c01      	ldr	r4, [sp, #4]
   15ec2:	462b      	mov	r3, r5
   15ec4:	4619      	mov	r1, r3
   15ec6:	4803      	ldr	r0, [pc, #12]	; (15ed4 <PinInterface::PinInterface()+0x2c>)
   15ec8:	f7fd fa40 	bl	1334c <__cyg_profile_func_exit>
   15ecc:	4623      	mov	r3, r4
   15ece:	4618      	mov	r0, r3
   15ed0:	b003      	add	sp, #12
   15ed2:	bd30      	pop	{r4, r5, pc}
   15ed4:	00015ea9 	.word	0x00015ea9
   15ed8:	0001ad68 	.word	0x0001ad68

00015edc <Pin::Pin(unsigned char, unsigned char)>:
  constexpr Pin(uint8_t port_number, uint8_t pin_number)
   15edc:	b530      	push	{r4, r5, lr}
   15ede:	b083      	sub	sp, #12
   15ee0:	4675      	mov	r5, lr
   15ee2:	9001      	str	r0, [sp, #4]
   15ee4:	460b      	mov	r3, r1
   15ee6:	f88d 3003 	strb.w	r3, [sp, #3]
   15eea:	4613      	mov	r3, r2
   15eec:	f88d 3002 	strb.w	r3, [sp, #2]
   15ef0:	462b      	mov	r3, r5
   15ef2:	4619      	mov	r1, r3
   15ef4:	480d      	ldr	r0, [pc, #52]	; (15f2c <Pin::Pin(unsigned char, unsigned char)+0x50>)
   15ef6:	f7fd fa15 	bl	13324 <__cyg_profile_func_enter>
      : port_(port_number), pin_(pin_number)
   15efa:	9b01      	ldr	r3, [sp, #4]
   15efc:	4618      	mov	r0, r3
   15efe:	f7ff ffd3 	bl	15ea8 <PinInterface::PinInterface()>
   15f02:	4a0b      	ldr	r2, [pc, #44]	; (15f30 <Pin::Pin(unsigned char, unsigned char)+0x54>)
   15f04:	9b01      	ldr	r3, [sp, #4]
   15f06:	601a      	str	r2, [r3, #0]
   15f08:	9b01      	ldr	r3, [sp, #4]
   15f0a:	f89d 2003 	ldrb.w	r2, [sp, #3]
   15f0e:	711a      	strb	r2, [r3, #4]
   15f10:	9b01      	ldr	r3, [sp, #4]
   15f12:	f89d 2002 	ldrb.w	r2, [sp, #2]
   15f16:	715a      	strb	r2, [r3, #5]
  }
   15f18:	9c01      	ldr	r4, [sp, #4]
   15f1a:	462b      	mov	r3, r5
   15f1c:	4619      	mov	r1, r3
   15f1e:	4803      	ldr	r0, [pc, #12]	; (15f2c <Pin::Pin(unsigned char, unsigned char)+0x50>)
   15f20:	f7fd fa14 	bl	1334c <__cyg_profile_func_exit>
   15f24:	4623      	mov	r3, r4
   15f26:	4618      	mov	r0, r3
   15f28:	b003      	add	sp, #12
   15f2a:	bd30      	pop	{r4, r5, pc}
   15f2c:	00015edd 	.word	0x00015edd
   15f30:	0001969c 	.word	0x0001969c

00015f34 <GpioInterface::GpioInterface()>:
class GpioInterface
   15f34:	b530      	push	{r4, r5, lr}
   15f36:	b083      	sub	sp, #12
   15f38:	4675      	mov	r5, lr
   15f3a:	9001      	str	r0, [sp, #4]
   15f3c:	462b      	mov	r3, r5
   15f3e:	4619      	mov	r1, r3
   15f40:	4807      	ldr	r0, [pc, #28]	; (15f60 <GpioInterface::GpioInterface()+0x2c>)
   15f42:	f7fd f9ef 	bl	13324 <__cyg_profile_func_enter>
   15f46:	4a07      	ldr	r2, [pc, #28]	; (15f64 <GpioInterface::GpioInterface()+0x30>)
   15f48:	9b01      	ldr	r3, [sp, #4]
   15f4a:	601a      	str	r2, [r3, #0]
   15f4c:	9c01      	ldr	r4, [sp, #4]
   15f4e:	462b      	mov	r3, r5
   15f50:	4619      	mov	r1, r3
   15f52:	4803      	ldr	r0, [pc, #12]	; (15f60 <GpioInterface::GpioInterface()+0x2c>)
   15f54:	f7fd f9fa 	bl	1334c <__cyg_profile_func_exit>
   15f58:	4623      	mov	r3, r4
   15f5a:	4618      	mov	r0, r3
   15f5c:	b003      	add	sp, #12
   15f5e:	bd30      	pop	{r4, r5, pc}
   15f60:	00015f35 	.word	0x00015f35
   15f64:	0001ad20 	.word	0x0001ad20

00015f68 <Gpio::Gpio(unsigned char, unsigned char)>:
  constexpr Gpio(uint8_t port_number, uint8_t pin_number)
   15f68:	b530      	push	{r4, r5, lr}
   15f6a:	b083      	sub	sp, #12
   15f6c:	4675      	mov	r5, lr
   15f6e:	9001      	str	r0, [sp, #4]
   15f70:	460b      	mov	r3, r1
   15f72:	f88d 3003 	strb.w	r3, [sp, #3]
   15f76:	4613      	mov	r3, r2
   15f78:	f88d 3002 	strb.w	r3, [sp, #2]
   15f7c:	462b      	mov	r3, r5
   15f7e:	4619      	mov	r1, r3
   15f80:	4816      	ldr	r0, [pc, #88]	; (15fdc <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   15f82:	f7fd f9cf 	bl	13324 <__cyg_profile_func_enter>
        lpc40xx_pin_(port_number, pin_number)
   15f86:	9b01      	ldr	r3, [sp, #4]
   15f88:	4618      	mov	r0, r3
   15f8a:	f7ff ffd3 	bl	15f34 <GpioInterface::GpioInterface()>
   15f8e:	4a14      	ldr	r2, [pc, #80]	; (15fe0 <Gpio::Gpio(unsigned char, unsigned char)+0x78>)
   15f90:	9b01      	ldr	r3, [sp, #4]
   15f92:	601a      	str	r2, [r3, #0]
   15f94:	9b01      	ldr	r3, [sp, #4]
   15f96:	2200      	movs	r2, #0
   15f98:	711a      	strb	r2, [r3, #4]
   15f9a:	9b01      	ldr	r3, [sp, #4]
   15f9c:	f103 020c 	add.w	r2, r3, #12
   15fa0:	9b01      	ldr	r3, [sp, #4]
   15fa2:	609a      	str	r2, [r3, #8]
   15fa4:	9b01      	ldr	r3, [sp, #4]
   15fa6:	330c      	adds	r3, #12
   15fa8:	f89d 2002 	ldrb.w	r2, [sp, #2]
   15fac:	f89d 1003 	ldrb.w	r1, [sp, #3]
   15fb0:	4618      	mov	r0, r3
   15fb2:	f7ff ff93 	bl	15edc <Pin::Pin(unsigned char, unsigned char)>
    interupt_port_ = (port_number == 2) ? 1 : 0;
   15fb6:	f89d 3003 	ldrb.w	r3, [sp, #3]
   15fba:	2b02      	cmp	r3, #2
   15fbc:	d101      	bne.n	15fc2 <Gpio::Gpio(unsigned char, unsigned char)+0x5a>
   15fbe:	2201      	movs	r2, #1
   15fc0:	e000      	b.n	15fc4 <Gpio::Gpio(unsigned char, unsigned char)+0x5c>
   15fc2:	2200      	movs	r2, #0
   15fc4:	9b01      	ldr	r3, [sp, #4]
   15fc6:	711a      	strb	r2, [r3, #4]
  }
   15fc8:	9c01      	ldr	r4, [sp, #4]
   15fca:	462b      	mov	r3, r5
   15fcc:	4619      	mov	r1, r3
   15fce:	4803      	ldr	r0, [pc, #12]	; (15fdc <Gpio::Gpio(unsigned char, unsigned char)+0x74>)
   15fd0:	f7fd f9bc 	bl	1334c <__cyg_profile_func_exit>
   15fd4:	4623      	mov	r3, r4
   15fd6:	4618      	mov	r0, r3
   15fd8:	b003      	add	sp, #12
   15fda:	bd30      	pop	{r4, r5, pc}
   15fdc:	00015f69 	.word	0x00015f69
   15fe0:	0001acd8 	.word	0x0001acd8

00015fe4 <Gpio::SetAsInput()>:
  void SetAsInput(void) override
   15fe4:	b530      	push	{r4, r5, lr}
   15fe6:	b083      	sub	sp, #12
   15fe8:	4675      	mov	r5, lr
   15fea:	9001      	str	r0, [sp, #4]
   15fec:	462b      	mov	r3, r5
   15fee:	4619      	mov	r1, r3
   15ff0:	4819      	ldr	r0, [pc, #100]	; (16058 <Gpio::SetAsInput()+0x74>)
   15ff2:	f7fd f997 	bl	13324 <__cyg_profile_func_enter>
    pin_->SetPinFunction(kGpioFunction);
   15ff6:	9b01      	ldr	r3, [sp, #4]
   15ff8:	689a      	ldr	r2, [r3, #8]
   15ffa:	9b01      	ldr	r3, [sp, #4]
   15ffc:	689b      	ldr	r3, [r3, #8]
   15ffe:	681b      	ldr	r3, [r3, #0]
   16000:	681b      	ldr	r3, [r3, #0]
   16002:	2100      	movs	r1, #0
   16004:	4610      	mov	r0, r2
   16006:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR &= ~(1 << pin_->GetPin());
   16008:	9b01      	ldr	r3, [sp, #4]
   1600a:	689a      	ldr	r2, [r3, #8]
   1600c:	9b01      	ldr	r3, [sp, #4]
   1600e:	689b      	ldr	r3, [r3, #8]
   16010:	681b      	ldr	r3, [r3, #0]
   16012:	3330      	adds	r3, #48	; 0x30
   16014:	681b      	ldr	r3, [r3, #0]
   16016:	4610      	mov	r0, r2
   16018:	4798      	blx	r3
   1601a:	4603      	mov	r3, r0
   1601c:	461a      	mov	r2, r3
   1601e:	2301      	movs	r3, #1
   16020:	4093      	lsls	r3, r2
   16022:	43dc      	mvns	r4, r3
   16024:	9b01      	ldr	r3, [sp, #4]
   16026:	689a      	ldr	r2, [r3, #8]
   16028:	9b01      	ldr	r3, [sp, #4]
   1602a:	689b      	ldr	r3, [r3, #8]
   1602c:	681b      	ldr	r3, [r3, #0]
   1602e:	332c      	adds	r3, #44	; 0x2c
   16030:	681b      	ldr	r3, [r3, #0]
   16032:	4610      	mov	r0, r2
   16034:	4798      	blx	r3
   16036:	4603      	mov	r3, r0
   16038:	461a      	mov	r2, r3
   1603a:	4b08      	ldr	r3, [pc, #32]	; (1605c <Gpio::SetAsInput()+0x78>)
   1603c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16040:	681a      	ldr	r2, [r3, #0]
   16042:	4621      	mov	r1, r4
   16044:	400a      	ands	r2, r1
   16046:	601a      	str	r2, [r3, #0]
   16048:	462b      	mov	r3, r5
   1604a:	4619      	mov	r1, r3
   1604c:	4802      	ldr	r0, [pc, #8]	; (16058 <Gpio::SetAsInput()+0x74>)
   1604e:	f7fd f97d 	bl	1334c <__cyg_profile_func_exit>
  }
   16052:	bf00      	nop
   16054:	b003      	add	sp, #12
   16056:	bd30      	pop	{r4, r5, pc}
   16058:	00015fe5 	.word	0x00015fe5
   1605c:	10000044 	.word	0x10000044

00016060 <Gpio::SetAsOutput()>:
  void SetAsOutput(void) override
   16060:	b530      	push	{r4, r5, lr}
   16062:	b083      	sub	sp, #12
   16064:	4675      	mov	r5, lr
   16066:	9001      	str	r0, [sp, #4]
   16068:	462b      	mov	r3, r5
   1606a:	4619      	mov	r1, r3
   1606c:	4819      	ldr	r0, [pc, #100]	; (160d4 <Gpio::SetAsOutput()+0x74>)
   1606e:	f7fd f959 	bl	13324 <__cyg_profile_func_enter>
    pin_->SetPinFunction(kGpioFunction);
   16072:	9b01      	ldr	r3, [sp, #4]
   16074:	689a      	ldr	r2, [r3, #8]
   16076:	9b01      	ldr	r3, [sp, #4]
   16078:	689b      	ldr	r3, [r3, #8]
   1607a:	681b      	ldr	r3, [r3, #0]
   1607c:	681b      	ldr	r3, [r3, #0]
   1607e:	2100      	movs	r1, #0
   16080:	4610      	mov	r0, r2
   16082:	4798      	blx	r3
    gpio_port[pin_->GetPort()]->DIR |= (1 << pin_->GetPin());
   16084:	9b01      	ldr	r3, [sp, #4]
   16086:	689a      	ldr	r2, [r3, #8]
   16088:	9b01      	ldr	r3, [sp, #4]
   1608a:	689b      	ldr	r3, [r3, #8]
   1608c:	681b      	ldr	r3, [r3, #0]
   1608e:	3330      	adds	r3, #48	; 0x30
   16090:	681b      	ldr	r3, [r3, #0]
   16092:	4610      	mov	r0, r2
   16094:	4798      	blx	r3
   16096:	4603      	mov	r3, r0
   16098:	461a      	mov	r2, r3
   1609a:	2301      	movs	r3, #1
   1609c:	fa03 f402 	lsl.w	r4, r3, r2
   160a0:	9b01      	ldr	r3, [sp, #4]
   160a2:	689a      	ldr	r2, [r3, #8]
   160a4:	9b01      	ldr	r3, [sp, #4]
   160a6:	689b      	ldr	r3, [r3, #8]
   160a8:	681b      	ldr	r3, [r3, #0]
   160aa:	332c      	adds	r3, #44	; 0x2c
   160ac:	681b      	ldr	r3, [r3, #0]
   160ae:	4610      	mov	r0, r2
   160b0:	4798      	blx	r3
   160b2:	4603      	mov	r3, r0
   160b4:	461a      	mov	r2, r3
   160b6:	4b08      	ldr	r3, [pc, #32]	; (160d8 <Gpio::SetAsOutput()+0x78>)
   160b8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   160bc:	681a      	ldr	r2, [r3, #0]
   160be:	4621      	mov	r1, r4
   160c0:	430a      	orrs	r2, r1
   160c2:	601a      	str	r2, [r3, #0]
   160c4:	462b      	mov	r3, r5
   160c6:	4619      	mov	r1, r3
   160c8:	4802      	ldr	r0, [pc, #8]	; (160d4 <Gpio::SetAsOutput()+0x74>)
   160ca:	f7fd f93f 	bl	1334c <__cyg_profile_func_exit>
  }
   160ce:	bf00      	nop
   160d0:	b003      	add	sp, #12
   160d2:	bd30      	pop	{r4, r5, pc}
   160d4:	00016061 	.word	0x00016061
   160d8:	10000044 	.word	0x10000044

000160dc <Gpio::SetDirection(GpioInterface::Direction)>:
  inline void SetDirection(Direction direction) override
   160dc:	b510      	push	{r4, lr}
   160de:	b082      	sub	sp, #8
   160e0:	4674      	mov	r4, lr
   160e2:	9001      	str	r0, [sp, #4]
   160e4:	460b      	mov	r3, r1
   160e6:	f88d 3003 	strb.w	r3, [sp, #3]
   160ea:	4623      	mov	r3, r4
   160ec:	4619      	mov	r1, r3
   160ee:	480b      	ldr	r0, [pc, #44]	; (1611c <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   160f0:	f7fd f918 	bl	13324 <__cyg_profile_func_enter>
    (direction) ? SetAsOutput() : SetAsInput();
   160f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   160f8:	2b00      	cmp	r3, #0
   160fa:	d003      	beq.n	16104 <Gpio::SetDirection(GpioInterface::Direction)+0x28>
   160fc:	9801      	ldr	r0, [sp, #4]
   160fe:	f7ff ffaf 	bl	16060 <Gpio::SetAsOutput()>
   16102:	e002      	b.n	1610a <Gpio::SetDirection(GpioInterface::Direction)+0x2e>
   16104:	9801      	ldr	r0, [sp, #4]
   16106:	f7ff ff6d 	bl	15fe4 <Gpio::SetAsInput()>
   1610a:	4623      	mov	r3, r4
   1610c:	4619      	mov	r1, r3
   1610e:	4803      	ldr	r0, [pc, #12]	; (1611c <Gpio::SetDirection(GpioInterface::Direction)+0x40>)
   16110:	f7fd f91c 	bl	1334c <__cyg_profile_func_exit>
  }
   16114:	bf00      	nop
   16116:	b002      	add	sp, #8
   16118:	bd10      	pop	{r4, pc}
   1611a:	bf00      	nop
   1611c:	000160dd 	.word	0x000160dd

00016120 <Gpio::Toggle()>:
  // Toggle the output of a GPIO output pin
  void Toggle() override
   16120:	b530      	push	{r4, r5, lr}
   16122:	b083      	sub	sp, #12
   16124:	4675      	mov	r5, lr
   16126:	9001      	str	r0, [sp, #4]
   16128:	462b      	mov	r3, r5
   1612a:	4619      	mov	r1, r3
   1612c:	4815      	ldr	r0, [pc, #84]	; (16184 <Gpio::Toggle()+0x64>)
   1612e:	f7fd f8f9 	bl	13324 <__cyg_profile_func_enter>
  {
    gpio_port[pin_->GetPort()]->PIN ^= (1 << pin_->GetPin());
   16132:	9b01      	ldr	r3, [sp, #4]
   16134:	689a      	ldr	r2, [r3, #8]
   16136:	9b01      	ldr	r3, [sp, #4]
   16138:	689b      	ldr	r3, [r3, #8]
   1613a:	681b      	ldr	r3, [r3, #0]
   1613c:	3330      	adds	r3, #48	; 0x30
   1613e:	681b      	ldr	r3, [r3, #0]
   16140:	4610      	mov	r0, r2
   16142:	4798      	blx	r3
   16144:	4603      	mov	r3, r0
   16146:	461a      	mov	r2, r3
   16148:	2301      	movs	r3, #1
   1614a:	fa03 f402 	lsl.w	r4, r3, r2
   1614e:	9b01      	ldr	r3, [sp, #4]
   16150:	689a      	ldr	r2, [r3, #8]
   16152:	9b01      	ldr	r3, [sp, #4]
   16154:	689b      	ldr	r3, [r3, #8]
   16156:	681b      	ldr	r3, [r3, #0]
   16158:	332c      	adds	r3, #44	; 0x2c
   1615a:	681b      	ldr	r3, [r3, #0]
   1615c:	4610      	mov	r0, r2
   1615e:	4798      	blx	r3
   16160:	4603      	mov	r3, r0
   16162:	461a      	mov	r2, r3
   16164:	4b08      	ldr	r3, [pc, #32]	; (16188 <Gpio::Toggle()+0x68>)
   16166:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1616a:	695a      	ldr	r2, [r3, #20]
   1616c:	4621      	mov	r1, r4
   1616e:	404a      	eors	r2, r1
   16170:	615a      	str	r2, [r3, #20]
   16172:	462b      	mov	r3, r5
   16174:	4619      	mov	r1, r3
   16176:	4803      	ldr	r0, [pc, #12]	; (16184 <Gpio::Toggle()+0x64>)
   16178:	f7fd f8e8 	bl	1334c <__cyg_profile_func_exit>
  }
   1617c:	bf00      	nop
   1617e:	b003      	add	sp, #12
   16180:	bd30      	pop	{r4, r5, pc}
   16182:	bf00      	nop
   16184:	00016121 	.word	0x00016121
   16188:	10000044 	.word	0x10000044

0001618c <Gpio::ReadState()>:
  // Returns the current State state of the pin
  State ReadState(void) override
   1618c:	b530      	push	{r4, r5, lr}
   1618e:	b085      	sub	sp, #20
   16190:	4675      	mov	r5, lr
   16192:	9001      	str	r0, [sp, #4]
   16194:	462b      	mov	r3, r5
   16196:	4619      	mov	r1, r3
   16198:	4818      	ldr	r0, [pc, #96]	; (161fc <Gpio::ReadState()+0x70>)
   1619a:	f7fd f8c3 	bl	13324 <__cyg_profile_func_enter>
  {
    bool state = (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   1619e:	9b01      	ldr	r3, [sp, #4]
   161a0:	689a      	ldr	r2, [r3, #8]
   161a2:	9b01      	ldr	r3, [sp, #4]
   161a4:	689b      	ldr	r3, [r3, #8]
   161a6:	681b      	ldr	r3, [r3, #0]
   161a8:	332c      	adds	r3, #44	; 0x2c
   161aa:	681b      	ldr	r3, [r3, #0]
   161ac:	4610      	mov	r0, r2
   161ae:	4798      	blx	r3
   161b0:	4603      	mov	r3, r0
   161b2:	461a      	mov	r2, r3
   161b4:	4b12      	ldr	r3, [pc, #72]	; (16200 <Gpio::ReadState()+0x74>)
   161b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   161ba:	695c      	ldr	r4, [r3, #20]
   161bc:	9b01      	ldr	r3, [sp, #4]
   161be:	689a      	ldr	r2, [r3, #8]
   161c0:	9b01      	ldr	r3, [sp, #4]
   161c2:	689b      	ldr	r3, [r3, #8]
   161c4:	681b      	ldr	r3, [r3, #0]
   161c6:	3330      	adds	r3, #48	; 0x30
   161c8:	681b      	ldr	r3, [r3, #0]
   161ca:	4610      	mov	r0, r2
   161cc:	4798      	blx	r3
   161ce:	4603      	mov	r3, r0
   161d0:	fa24 f303 	lsr.w	r3, r4, r3
   161d4:	f003 0301 	and.w	r3, r3, #1
   161d8:	2b00      	cmp	r3, #0
   161da:	bf14      	ite	ne
   161dc:	2301      	movne	r3, #1
   161de:	2300      	moveq	r3, #0
   161e0:	f88d 300f 	strb.w	r3, [sp, #15]
    return static_cast<State>(state);
   161e4:	f89d 400f 	ldrb.w	r4, [sp, #15]
   161e8:	462b      	mov	r3, r5
   161ea:	4619      	mov	r1, r3
   161ec:	4803      	ldr	r0, [pc, #12]	; (161fc <Gpio::ReadState()+0x70>)
   161ee:	f7fd f8ad 	bl	1334c <__cyg_profile_func_exit>
   161f2:	4623      	mov	r3, r4
  }
   161f4:	4618      	mov	r0, r3
   161f6:	b005      	add	sp, #20
   161f8:	bd30      	pop	{r4, r5, pc}
   161fa:	bf00      	nop
   161fc:	0001618d 	.word	0x0001618d
   16200:	10000044 	.word	0x10000044

00016204 <Gpio::Read()>:
  // Returns true if input or output pin is high
  bool Read(void) override
   16204:	b530      	push	{r4, r5, lr}
   16206:	b083      	sub	sp, #12
   16208:	4675      	mov	r5, lr
   1620a:	9001      	str	r0, [sp, #4]
   1620c:	462b      	mov	r3, r5
   1620e:	4619      	mov	r1, r3
   16210:	4816      	ldr	r0, [pc, #88]	; (1626c <Gpio::Read()+0x68>)
   16212:	f7fd f887 	bl	13324 <__cyg_profile_func_enter>
  {
    return (gpio_port[pin_->GetPort()]->PIN >> pin_->GetPin()) & 1;
   16216:	9b01      	ldr	r3, [sp, #4]
   16218:	689a      	ldr	r2, [r3, #8]
   1621a:	9b01      	ldr	r3, [sp, #4]
   1621c:	689b      	ldr	r3, [r3, #8]
   1621e:	681b      	ldr	r3, [r3, #0]
   16220:	332c      	adds	r3, #44	; 0x2c
   16222:	681b      	ldr	r3, [r3, #0]
   16224:	4610      	mov	r0, r2
   16226:	4798      	blx	r3
   16228:	4603      	mov	r3, r0
   1622a:	461a      	mov	r2, r3
   1622c:	4b10      	ldr	r3, [pc, #64]	; (16270 <Gpio::Read()+0x6c>)
   1622e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16232:	695c      	ldr	r4, [r3, #20]
   16234:	9b01      	ldr	r3, [sp, #4]
   16236:	689a      	ldr	r2, [r3, #8]
   16238:	9b01      	ldr	r3, [sp, #4]
   1623a:	689b      	ldr	r3, [r3, #8]
   1623c:	681b      	ldr	r3, [r3, #0]
   1623e:	3330      	adds	r3, #48	; 0x30
   16240:	681b      	ldr	r3, [r3, #0]
   16242:	4610      	mov	r0, r2
   16244:	4798      	blx	r3
   16246:	4603      	mov	r3, r0
   16248:	fa24 f303 	lsr.w	r3, r4, r3
   1624c:	f003 0301 	and.w	r3, r3, #1
   16250:	2b00      	cmp	r3, #0
   16252:	bf14      	ite	ne
   16254:	2301      	movne	r3, #1
   16256:	2300      	moveq	r3, #0
   16258:	b2dc      	uxtb	r4, r3
   1625a:	462b      	mov	r3, r5
   1625c:	4619      	mov	r1, r3
   1625e:	4803      	ldr	r0, [pc, #12]	; (1626c <Gpio::Read()+0x68>)
   16260:	f7fd f874 	bl	1334c <__cyg_profile_func_exit>
   16264:	4623      	mov	r3, r4
  }
   16266:	4618      	mov	r0, r3
   16268:	b003      	add	sp, #12
   1626a:	bd30      	pop	{r4, r5, pc}
   1626c:	00016205 	.word	0x00016205
   16270:	10000044 	.word	0x10000044

00016274 <Gpio::GetPin()>:
  PinInterface & GetPin() override
   16274:	b530      	push	{r4, r5, lr}
   16276:	b083      	sub	sp, #12
   16278:	4675      	mov	r5, lr
   1627a:	9001      	str	r0, [sp, #4]
   1627c:	462b      	mov	r3, r5
   1627e:	4619      	mov	r1, r3
   16280:	4806      	ldr	r0, [pc, #24]	; (1629c <Gpio::GetPin()+0x28>)
   16282:	f7fd f84f 	bl	13324 <__cyg_profile_func_enter>
  {
    return *pin_;
   16286:	9b01      	ldr	r3, [sp, #4]
   16288:	689c      	ldr	r4, [r3, #8]
   1628a:	462b      	mov	r3, r5
   1628c:	4619      	mov	r1, r3
   1628e:	4803      	ldr	r0, [pc, #12]	; (1629c <Gpio::GetPin()+0x28>)
   16290:	f7fd f85c 	bl	1334c <__cyg_profile_func_exit>
   16294:	4623      	mov	r3, r4
  }
   16296:	4618      	mov	r0, r3
   16298:	b003      	add	sp, #12
   1629a:	bd30      	pop	{r4, r5, pc}
   1629c:	00016275 	.word	0x00016275

000162a0 <Gpio::ValidPortCheck()>:

  // Checks if the selected gpio port is valid for external interrupts.
  bool ValidPortCheck()
   162a0:	b530      	push	{r4, r5, lr}
   162a2:	b087      	sub	sp, #28
   162a4:	4675      	mov	r5, lr
   162a6:	9003      	str	r0, [sp, #12]
   162a8:	462b      	mov	r3, r5
   162aa:	4619      	mov	r1, r3
   162ac:	4817      	ldr	r0, [pc, #92]	; (1630c <Gpio::ValidPortCheck()+0x6c>)
   162ae:	f7fd f839 	bl	13324 <__cyg_profile_func_enter>
  {
    bool is_valid = (interupt_port_ <= 1);
   162b2:	9b03      	ldr	r3, [sp, #12]
   162b4:	791b      	ldrb	r3, [r3, #4]
   162b6:	2b01      	cmp	r3, #1
   162b8:	bf94      	ite	ls
   162ba:	2301      	movls	r3, #1
   162bc:	2300      	movhi	r3, #0
   162be:	b2db      	uxtb	r3, r3
   162c0:	f88d 3017 	strb.w	r3, [sp, #23]
    SJ2_ASSERT_WARNING(is_valid,
   162c4:	f89d 3017 	ldrb.w	r3, [sp, #23]
   162c8:	f083 0301 	eor.w	r3, r3, #1
   162cc:	b2db      	uxtb	r3, r3
   162ce:	2b00      	cmp	r3, #0
   162d0:	d010      	beq.n	162f4 <Gpio::ValidPortCheck()+0x54>
   162d2:	9b03      	ldr	r3, [sp, #12]
   162d4:	689a      	ldr	r2, [r3, #8]
   162d6:	9b03      	ldr	r3, [sp, #12]
   162d8:	689b      	ldr	r3, [r3, #8]
   162da:	681b      	ldr	r3, [r3, #0]
   162dc:	332c      	adds	r3, #44	; 0x2c
   162de:	681b      	ldr	r3, [r3, #0]
   162e0:	4610      	mov	r0, r2
   162e2:	4798      	blx	r3
   162e4:	4603      	mov	r3, r0
   162e6:	9300      	str	r3, [sp, #0]
   162e8:	23a6      	movs	r3, #166	; 0xa6
   162ea:	4a09      	ldr	r2, [pc, #36]	; (16310 <Gpio::ValidPortCheck()+0x70>)
   162ec:	4909      	ldr	r1, [pc, #36]	; (16314 <Gpio::ValidPortCheck()+0x74>)
   162ee:	480a      	ldr	r0, [pc, #40]	; (16318 <Gpio::ValidPortCheck()+0x78>)
   162f0:	f7ff fdb4 	bl	15e5c <printf>
                       "Port %d cannot be used for External Interrupts. Need "
                       "to use GPIO on Port 0 or 2.",
                       pin_->GetPort());
    return is_valid;
   162f4:	f89d 4017 	ldrb.w	r4, [sp, #23]
   162f8:	462b      	mov	r3, r5
   162fa:	4619      	mov	r1, r3
   162fc:	4803      	ldr	r0, [pc, #12]	; (1630c <Gpio::ValidPortCheck()+0x6c>)
   162fe:	f7fd f825 	bl	1334c <__cyg_profile_func_exit>
   16302:	4623      	mov	r3, r4
  }
   16304:	4618      	mov	r0, r3
   16306:	b007      	add	sp, #28
   16308:	bd30      	pop	{r4, r5, pc}
   1630a:	bf00      	nop
   1630c:	000162a1 	.word	0x000162a1
   16310:	0001add8 	.word	0x0001add8
   16314:	0001a7cc 	.word	0x0001a7cc
   16318:	00019c9c 	.word	0x00019c9c

0001631c <Gpio::SetInterruptRoutine(void (*)())>:

  // Assigns the developer's ISR function to the port/pin gpio instance.
  void SetInterruptRoutine(IsrPointer function) override
   1631c:	b570      	push	{r4, r5, r6, lr}
   1631e:	b082      	sub	sp, #8
   16320:	4676      	mov	r6, lr
   16322:	9001      	str	r0, [sp, #4]
   16324:	9100      	str	r1, [sp, #0]
   16326:	4633      	mov	r3, r6
   16328:	4619      	mov	r1, r3
   1632a:	4811      	ldr	r0, [pc, #68]	; (16370 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   1632c:	f7fc fffa 	bl	13324 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16330:	9801      	ldr	r0, [sp, #4]
   16332:	f7ff ffb5 	bl	162a0 <Gpio::ValidPortCheck()>
    interrupthandlers[interupt_port_][pin_->GetPin()] = function;
   16336:	9c00      	ldr	r4, [sp, #0]
   16338:	9b01      	ldr	r3, [sp, #4]
   1633a:	791b      	ldrb	r3, [r3, #4]
   1633c:	461d      	mov	r5, r3
   1633e:	9b01      	ldr	r3, [sp, #4]
   16340:	689a      	ldr	r2, [r3, #8]
   16342:	9b01      	ldr	r3, [sp, #4]
   16344:	689b      	ldr	r3, [r3, #8]
   16346:	681b      	ldr	r3, [r3, #0]
   16348:	3330      	adds	r3, #48	; 0x30
   1634a:	681b      	ldr	r3, [r3, #0]
   1634c:	4610      	mov	r0, r2
   1634e:	4798      	blx	r3
   16350:	4603      	mov	r3, r0
   16352:	4619      	mov	r1, r3
   16354:	4a07      	ldr	r2, [pc, #28]	; (16374 <Gpio::SetInterruptRoutine(void (*)())+0x58>)
   16356:	016b      	lsls	r3, r5, #5
   16358:	440b      	add	r3, r1
   1635a:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
   1635e:	4633      	mov	r3, r6
   16360:	4619      	mov	r1, r3
   16362:	4803      	ldr	r0, [pc, #12]	; (16370 <Gpio::SetInterruptRoutine(void (*)())+0x54>)
   16364:	f7fc fff2 	bl	1334c <__cyg_profile_func_exit>
  }
   16368:	bf00      	nop
   1636a:	b002      	add	sp, #8
   1636c:	bd70      	pop	{r4, r5, r6, pc}
   1636e:	bf00      	nop
   16370:	0001631d 	.word	0x0001631d
   16374:	100007cc 	.word	0x100007cc

00016378 <Gpio::ClearInterruptRoutine()>:

  // Clears the developers ISR function from the port/pin gio instance.
  void ClearInterruptRoutine() override
   16378:	b530      	push	{r4, r5, lr}
   1637a:	b083      	sub	sp, #12
   1637c:	4675      	mov	r5, lr
   1637e:	9001      	str	r0, [sp, #4]
   16380:	462b      	mov	r3, r5
   16382:	4619      	mov	r1, r3
   16384:	480f      	ldr	r0, [pc, #60]	; (163c4 <Gpio::ClearInterruptRoutine()+0x4c>)
   16386:	f7fc ffcd 	bl	13324 <__cyg_profile_func_enter>
  {
    interrupthandlers[interupt_port_][pin_->GetPin()] = nullptr;
   1638a:	9b01      	ldr	r3, [sp, #4]
   1638c:	791b      	ldrb	r3, [r3, #4]
   1638e:	461c      	mov	r4, r3
   16390:	9b01      	ldr	r3, [sp, #4]
   16392:	689a      	ldr	r2, [r3, #8]
   16394:	9b01      	ldr	r3, [sp, #4]
   16396:	689b      	ldr	r3, [r3, #8]
   16398:	681b      	ldr	r3, [r3, #0]
   1639a:	3330      	adds	r3, #48	; 0x30
   1639c:	681b      	ldr	r3, [r3, #0]
   1639e:	4610      	mov	r0, r2
   163a0:	4798      	blx	r3
   163a2:	4603      	mov	r3, r0
   163a4:	4619      	mov	r1, r3
   163a6:	4a08      	ldr	r2, [pc, #32]	; (163c8 <Gpio::ClearInterruptRoutine()+0x50>)
   163a8:	0163      	lsls	r3, r4, #5
   163aa:	440b      	add	r3, r1
   163ac:	2100      	movs	r1, #0
   163ae:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   163b2:	462b      	mov	r3, r5
   163b4:	4619      	mov	r1, r3
   163b6:	4803      	ldr	r0, [pc, #12]	; (163c4 <Gpio::ClearInterruptRoutine()+0x4c>)
   163b8:	f7fc ffc8 	bl	1334c <__cyg_profile_func_exit>
  }
   163bc:	bf00      	nop
   163be:	b003      	add	sp, #12
   163c0:	bd30      	pop	{r4, r5, pc}
   163c2:	bf00      	nop
   163c4:	00016379 	.word	0x00016379
   163c8:	100007cc 	.word	0x100007cc

000163cc <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>:
constexpr Type Value(Enum enum_type_value)
   163cc:	b530      	push	{r4, r5, lr}
   163ce:	b083      	sub	sp, #12
   163d0:	4675      	mov	r5, lr
   163d2:	4603      	mov	r3, r0
   163d4:	f88d 3007 	strb.w	r3, [sp, #7]
   163d8:	462b      	mov	r3, r5
   163da:	4619      	mov	r1, r3
   163dc:	4806      	ldr	r0, [pc, #24]	; (163f8 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   163de:	f7fc ffa1 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   163e2:	f89d 4007 	ldrb.w	r4, [sp, #7]
   163e6:	462b      	mov	r3, r5
   163e8:	4619      	mov	r1, r3
   163ea:	4803      	ldr	r0, [pc, #12]	; (163f8 <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)+0x2c>)
   163ec:	f7fc ffae 	bl	1334c <__cyg_profile_func_exit>
   163f0:	4623      	mov	r3, r4
}
   163f2:	4618      	mov	r0, r3
   163f4:	b003      	add	sp, #12
   163f6:	bd30      	pop	{r4, r5, pc}
   163f8:	000163cd 	.word	0x000163cd

000163fc <Gpio::SetInterruptEdge(GpioInterface::Edge)>:

  // Sets the selected edge that the gpio interrupt will be triggered on.
  void SetInterruptEdge(Edge edge) override
   163fc:	b510      	push	{r4, lr}
   163fe:	b084      	sub	sp, #16
   16400:	4674      	mov	r4, lr
   16402:	9003      	str	r0, [sp, #12]
   16404:	460b      	mov	r3, r1
   16406:	f88d 300b 	strb.w	r3, [sp, #11]
   1640a:	4623      	mov	r3, r4
   1640c:	4619      	mov	r1, r3
   1640e:	4819      	ldr	r0, [pc, #100]	; (16474 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   16410:	f7fc ff88 	bl	13324 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16414:	9803      	ldr	r0, [sp, #12]
   16416:	f7ff ff43 	bl	162a0 <Gpio::ValidPortCheck()>
    switch (edge)
   1641a:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1641e:	2b01      	cmp	r3, #1
   16420:	d008      	beq.n	16434 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x38>
   16422:	2b01      	cmp	r3, #1
   16424:	d302      	bcc.n	1642c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x30>
   16426:	2b02      	cmp	r3, #2
   16428:	d008      	beq.n	1643c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x40>
   1642a:	e00e      	b.n	1644a <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        SetEdgeRising();
   1642c:	9803      	ldr	r0, [sp, #12]
   1642e:	f000 f8b1 	bl	16594 <Gpio::SetEdgeRising()>
        break;
   16432:	e017      	b.n	16464 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        SetEdgeFalling();
   16434:	9803      	ldr	r0, [sp, #12]
   16436:	f000 f8eb 	bl	16610 <Gpio::SetEdgeFalling()>
        break;
   1643a:	e013      	b.n	16464 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        SetEdgeRising();
   1643c:	9803      	ldr	r0, [sp, #12]
   1643e:	f000 f8a9 	bl	16594 <Gpio::SetEdgeRising()>
        SetEdgeFalling();
   16442:	9803      	ldr	r0, [sp, #12]
   16444:	f000 f8e4 	bl	16610 <Gpio::SetEdgeFalling()>
        break;
   16448:	e00c      	b.n	16464 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   1644a:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1644e:	4618      	mov	r0, r3
   16450:	f7ff ffbc 	bl	163cc <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   16454:	4603      	mov	r3, r0
   16456:	9300      	str	r3, [sp, #0]
   16458:	23d2      	movs	r3, #210	; 0xd2
   1645a:	4a07      	ldr	r2, [pc, #28]	; (16478 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x7c>)
   1645c:	4907      	ldr	r1, [pc, #28]	; (1647c <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x80>)
   1645e:	4808      	ldr	r0, [pc, #32]	; (16480 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x84>)
   16460:	f7ff fcfc 	bl	15e5c <printf>
   16464:	4623      	mov	r3, r4
   16466:	4619      	mov	r1, r3
   16468:	4802      	ldr	r0, [pc, #8]	; (16474 <Gpio::SetInterruptEdge(GpioInterface::Edge)+0x78>)
   1646a:	f7fc ff6f 	bl	1334c <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
            util::Value(edge));
      }
    }
  }
   1646e:	bf00      	nop
   16470:	b004      	add	sp, #16
   16472:	bd10      	pop	{r4, pc}
   16474:	000163fd 	.word	0x000163fd
   16478:	0001adf4 	.word	0x0001adf4
   1647c:	0001a7d8 	.word	0x0001a7d8
   16480:	00019d2c 	.word	0x00019d2c

00016484 <Gpio::ClearInterruptEdge(GpioInterface::Edge)>:

  // Clears the seleted edge of the gpio interrupt from being triggered.
  void ClearInterruptEdge(Edge edge) override
   16484:	b510      	push	{r4, lr}
   16486:	b084      	sub	sp, #16
   16488:	4674      	mov	r4, lr
   1648a:	9003      	str	r0, [sp, #12]
   1648c:	460b      	mov	r3, r1
   1648e:	f88d 300b 	strb.w	r3, [sp, #11]
   16492:	4623      	mov	r3, r4
   16494:	4619      	mov	r1, r3
   16496:	4819      	ldr	r0, [pc, #100]	; (164fc <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   16498:	f7fc ff44 	bl	13324 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   1649c:	9803      	ldr	r0, [sp, #12]
   1649e:	f7ff feff 	bl	162a0 <Gpio::ValidPortCheck()>
    switch (edge)
   164a2:	f89d 300b 	ldrb.w	r3, [sp, #11]
   164a6:	2b01      	cmp	r3, #1
   164a8:	d008      	beq.n	164bc <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x38>
   164aa:	2b01      	cmp	r3, #1
   164ac:	d302      	bcc.n	164b4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x30>
   164ae:	2b02      	cmp	r3, #2
   164b0:	d008      	beq.n	164c4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x40>
   164b2:	e00e      	b.n	164d2 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x4e>
    {
      case Edge::kEdgeRising:
      {
        ClearEdgeRising();
   164b4:	9803      	ldr	r0, [sp, #12]
   164b6:	f000 f8e9 	bl	1668c <Gpio::ClearEdgeRising()>
        break;
   164ba:	e017      	b.n	164ec <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeFalling:
      {
        ClearEdgeFalling();
   164bc:	9803      	ldr	r0, [sp, #12]
   164be:	f000 f923 	bl	16708 <Gpio::ClearEdgeFalling()>
        break;
   164c2:	e013      	b.n	164ec <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      case Edge::kEdgeBoth:
      {
        ClearEdgeRising();
   164c4:	9803      	ldr	r0, [sp, #12]
   164c6:	f000 f8e1 	bl	1668c <Gpio::ClearEdgeRising()>
        ClearEdgeFalling();
   164ca:	9803      	ldr	r0, [sp, #12]
   164cc:	f000 f91c 	bl	16708 <Gpio::ClearEdgeFalling()>
        break;
   164d0:	e00c      	b.n	164ec <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x68>
      }
      default:
      {
        LOG_WARNING(
   164d2:	f89d 300b 	ldrb.w	r3, [sp, #11]
   164d6:	4618      	mov	r0, r3
   164d8:	f7ff ff78 	bl	163cc <unsigned char util::Value<GpioInterface::Edge, unsigned char>(GpioInterface::Edge)>
   164dc:	4603      	mov	r3, r0
   164de:	9300      	str	r3, [sp, #0]
   164e0:	23f2      	movs	r3, #242	; 0xf2
   164e2:	4a07      	ldr	r2, [pc, #28]	; (16500 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x7c>)
   164e4:	4907      	ldr	r1, [pc, #28]	; (16504 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x80>)
   164e6:	4808      	ldr	r0, [pc, #32]	; (16508 <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x84>)
   164e8:	f7ff fcb8 	bl	15e5c <printf>
   164ec:	4623      	mov	r3, r4
   164ee:	4619      	mov	r1, r3
   164f0:	4802      	ldr	r0, [pc, #8]	; (164fc <Gpio::ClearInterruptEdge(GpioInterface::Edge)+0x78>)
   164f2:	f7fc ff2b 	bl	1334c <__cyg_profile_func_exit>
            "Edge %d cannot be used for External Interrupts."
            "Need to use a rising, falling, or both configuration.",
           util::Value(edge));
      }
    }
  }
   164f6:	bf00      	nop
   164f8:	b004      	add	sp, #16
   164fa:	bd10      	pop	{r4, pc}
   164fc:	00016485 	.word	0x00016485
   16500:	0001ad9c 	.word	0x0001ad9c
   16504:	0001a7e4 	.word	0x0001a7e4
   16508:	00019d2c 	.word	0x00019d2c

0001650c <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)>:

  // Assign the developer's ISR and sets the selected edge that the gpio
  // interrupt will be triggered on.
  void AttachInterrupt(IsrPointer function, Edge edge) override
   1650c:	b510      	push	{r4, lr}
   1650e:	b084      	sub	sp, #16
   16510:	4674      	mov	r4, lr
   16512:	9003      	str	r0, [sp, #12]
   16514:	9102      	str	r1, [sp, #8]
   16516:	4613      	mov	r3, r2
   16518:	f88d 3007 	strb.w	r3, [sp, #7]
   1651c:	4623      	mov	r3, r4
   1651e:	4619      	mov	r1, r3
   16520:	480b      	ldr	r0, [pc, #44]	; (16550 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   16522:	f7fc feff 	bl	13324 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16526:	9803      	ldr	r0, [sp, #12]
   16528:	f7ff feba 	bl	162a0 <Gpio::ValidPortCheck()>
    SetInterruptRoutine(function);
   1652c:	9902      	ldr	r1, [sp, #8]
   1652e:	9803      	ldr	r0, [sp, #12]
   16530:	f7ff fef4 	bl	1631c <Gpio::SetInterruptRoutine(void (*)())>
    SetInterruptEdge(edge);
   16534:	f89d 3007 	ldrb.w	r3, [sp, #7]
   16538:	4619      	mov	r1, r3
   1653a:	9803      	ldr	r0, [sp, #12]
   1653c:	f7ff ff5e 	bl	163fc <Gpio::SetInterruptEdge(GpioInterface::Edge)>
   16540:	4623      	mov	r3, r4
   16542:	4619      	mov	r1, r3
   16544:	4802      	ldr	r0, [pc, #8]	; (16550 <Gpio::AttachInterrupt(void (*)(), GpioInterface::Edge)+0x44>)
   16546:	f7fc ff01 	bl	1334c <__cyg_profile_func_exit>
  }
   1654a:	bf00      	nop
   1654c:	b004      	add	sp, #16
   1654e:	bd10      	pop	{r4, pc}
   16550:	0001650d 	.word	0x0001650d

00016554 <Gpio::DetachInterrupt()>:

  // Removes the developer's ISR and clears the selected edge of the gpio
  // interrupt from being triggered.
  void DetachInterrupt() override
   16554:	b510      	push	{r4, lr}
   16556:	b082      	sub	sp, #8
   16558:	4674      	mov	r4, lr
   1655a:	9001      	str	r0, [sp, #4]
   1655c:	4623      	mov	r3, r4
   1655e:	4619      	mov	r1, r3
   16560:	480b      	ldr	r0, [pc, #44]	; (16590 <Gpio::DetachInterrupt()+0x3c>)
   16562:	f7fc fedf 	bl	13324 <__cyg_profile_func_enter>
  {
    ValidPortCheck();
   16566:	9801      	ldr	r0, [sp, #4]
   16568:	f7ff fe9a 	bl	162a0 <Gpio::ValidPortCheck()>
    ClearInterruptRoutine();
   1656c:	9801      	ldr	r0, [sp, #4]
   1656e:	f7ff ff03 	bl	16378 <Gpio::ClearInterruptRoutine()>
    ClearEdgeRising();
   16572:	9801      	ldr	r0, [sp, #4]
   16574:	f000 f88a 	bl	1668c <Gpio::ClearEdgeRising()>
    ClearEdgeFalling();
   16578:	9801      	ldr	r0, [sp, #4]
   1657a:	f000 f8c5 	bl	16708 <Gpio::ClearEdgeFalling()>
   1657e:	4623      	mov	r3, r4
   16580:	4619      	mov	r1, r3
   16582:	4803      	ldr	r0, [pc, #12]	; (16590 <Gpio::DetachInterrupt()+0x3c>)
   16584:	f7fc fee2 	bl	1334c <__cyg_profile_func_exit>
  }
   16588:	bf00      	nop
   1658a:	b002      	add	sp, #8
   1658c:	bd10      	pop	{r4, pc}
   1658e:	bf00      	nop
   16590:	00016555 	.word	0x00016555

00016594 <Gpio::SetEdgeRising()>:
    *interrupt[triggered_port].clear |= (1 << triggered_pin);
  }

 private:
  // Sets the gpio interrupt to trigger on a rising edge.
  void SetEdgeRising()
   16594:	b530      	push	{r4, r5, lr}
   16596:	b083      	sub	sp, #12
   16598:	4675      	mov	r5, lr
   1659a:	9001      	str	r0, [sp, #4]
   1659c:	462b      	mov	r3, r5
   1659e:	4619      	mov	r1, r3
   165a0:	4819      	ldr	r0, [pc, #100]	; (16608 <Gpio::SetEdgeRising()+0x74>)
   165a2:	f7fc febf 	bl	13324 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge |= (1 << pin_->GetPin());
   165a6:	9b01      	ldr	r3, [sp, #4]
   165a8:	689a      	ldr	r2, [r3, #8]
   165aa:	9b01      	ldr	r3, [sp, #4]
   165ac:	689b      	ldr	r3, [r3, #8]
   165ae:	681b      	ldr	r3, [r3, #0]
   165b0:	3330      	adds	r3, #48	; 0x30
   165b2:	681b      	ldr	r3, [r3, #0]
   165b4:	4610      	mov	r0, r2
   165b6:	4798      	blx	r3
   165b8:	4603      	mov	r3, r0
   165ba:	461a      	mov	r2, r3
   165bc:	2301      	movs	r3, #1
   165be:	fa03 f002 	lsl.w	r0, r3, r2
   165c2:	9b01      	ldr	r3, [sp, #4]
   165c4:	791b      	ldrb	r3, [r3, #4]
   165c6:	4619      	mov	r1, r3
   165c8:	4a10      	ldr	r2, [pc, #64]	; (1660c <Gpio::SetEdgeRising()+0x78>)
   165ca:	460b      	mov	r3, r1
   165cc:	009b      	lsls	r3, r3, #2
   165ce:	440b      	add	r3, r1
   165d0:	009b      	lsls	r3, r3, #2
   165d2:	4413      	add	r3, r2
   165d4:	330c      	adds	r3, #12
   165d6:	681b      	ldr	r3, [r3, #0]
   165d8:	681a      	ldr	r2, [r3, #0]
   165da:	4604      	mov	r4, r0
   165dc:	9b01      	ldr	r3, [sp, #4]
   165de:	791b      	ldrb	r3, [r3, #4]
   165e0:	4618      	mov	r0, r3
   165e2:	490a      	ldr	r1, [pc, #40]	; (1660c <Gpio::SetEdgeRising()+0x78>)
   165e4:	4603      	mov	r3, r0
   165e6:	009b      	lsls	r3, r3, #2
   165e8:	4403      	add	r3, r0
   165ea:	009b      	lsls	r3, r3, #2
   165ec:	440b      	add	r3, r1
   165ee:	330c      	adds	r3, #12
   165f0:	681b      	ldr	r3, [r3, #0]
   165f2:	4322      	orrs	r2, r4
   165f4:	601a      	str	r2, [r3, #0]
   165f6:	462b      	mov	r3, r5
   165f8:	4619      	mov	r1, r3
   165fa:	4803      	ldr	r0, [pc, #12]	; (16608 <Gpio::SetEdgeRising()+0x74>)
   165fc:	f7fc fea6 	bl	1334c <__cyg_profile_func_exit>
  }
   16600:	bf00      	nop
   16602:	b003      	add	sp, #12
   16604:	bd30      	pop	{r4, r5, pc}
   16606:	bf00      	nop
   16608:	00016595 	.word	0x00016595
   1660c:	100001f4 	.word	0x100001f4

00016610 <Gpio::SetEdgeFalling()>:

  // Sets the gpio interrupt to trigger on a falling edge.
  void SetEdgeFalling()
   16610:	b530      	push	{r4, r5, lr}
   16612:	b083      	sub	sp, #12
   16614:	4675      	mov	r5, lr
   16616:	9001      	str	r0, [sp, #4]
   16618:	462b      	mov	r3, r5
   1661a:	4619      	mov	r1, r3
   1661c:	4819      	ldr	r0, [pc, #100]	; (16684 <Gpio::SetEdgeFalling()+0x74>)
   1661e:	f7fc fe81 	bl	13324 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge |= (1 << pin_->GetPin());
   16622:	9b01      	ldr	r3, [sp, #4]
   16624:	689a      	ldr	r2, [r3, #8]
   16626:	9b01      	ldr	r3, [sp, #4]
   16628:	689b      	ldr	r3, [r3, #8]
   1662a:	681b      	ldr	r3, [r3, #0]
   1662c:	3330      	adds	r3, #48	; 0x30
   1662e:	681b      	ldr	r3, [r3, #0]
   16630:	4610      	mov	r0, r2
   16632:	4798      	blx	r3
   16634:	4603      	mov	r3, r0
   16636:	461a      	mov	r2, r3
   16638:	2301      	movs	r3, #1
   1663a:	fa03 f002 	lsl.w	r0, r3, r2
   1663e:	9b01      	ldr	r3, [sp, #4]
   16640:	791b      	ldrb	r3, [r3, #4]
   16642:	4619      	mov	r1, r3
   16644:	4a10      	ldr	r2, [pc, #64]	; (16688 <Gpio::SetEdgeFalling()+0x78>)
   16646:	460b      	mov	r3, r1
   16648:	009b      	lsls	r3, r3, #2
   1664a:	440b      	add	r3, r1
   1664c:	009b      	lsls	r3, r3, #2
   1664e:	4413      	add	r3, r2
   16650:	3310      	adds	r3, #16
   16652:	681b      	ldr	r3, [r3, #0]
   16654:	681a      	ldr	r2, [r3, #0]
   16656:	4604      	mov	r4, r0
   16658:	9b01      	ldr	r3, [sp, #4]
   1665a:	791b      	ldrb	r3, [r3, #4]
   1665c:	4618      	mov	r0, r3
   1665e:	490a      	ldr	r1, [pc, #40]	; (16688 <Gpio::SetEdgeFalling()+0x78>)
   16660:	4603      	mov	r3, r0
   16662:	009b      	lsls	r3, r3, #2
   16664:	4403      	add	r3, r0
   16666:	009b      	lsls	r3, r3, #2
   16668:	440b      	add	r3, r1
   1666a:	3310      	adds	r3, #16
   1666c:	681b      	ldr	r3, [r3, #0]
   1666e:	4322      	orrs	r2, r4
   16670:	601a      	str	r2, [r3, #0]
   16672:	462b      	mov	r3, r5
   16674:	4619      	mov	r1, r3
   16676:	4803      	ldr	r0, [pc, #12]	; (16684 <Gpio::SetEdgeFalling()+0x74>)
   16678:	f7fc fe68 	bl	1334c <__cyg_profile_func_exit>
  }
   1667c:	bf00      	nop
   1667e:	b003      	add	sp, #12
   16680:	bd30      	pop	{r4, r5, pc}
   16682:	bf00      	nop
   16684:	00016611 	.word	0x00016611
   16688:	100001f4 	.word	0x100001f4

0001668c <Gpio::ClearEdgeRising()>:

  // Clears the gpio interrupt to no longer trigger on a rising edge.
  void ClearEdgeRising()
   1668c:	b530      	push	{r4, r5, lr}
   1668e:	b083      	sub	sp, #12
   16690:	4675      	mov	r5, lr
   16692:	9001      	str	r0, [sp, #4]
   16694:	462b      	mov	r3, r5
   16696:	4619      	mov	r1, r3
   16698:	4819      	ldr	r0, [pc, #100]	; (16700 <Gpio::ClearEdgeRising()+0x74>)
   1669a:	f7fc fe43 	bl	13324 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_rising_edge &= ~(1 << pin_->GetPin());
   1669e:	9b01      	ldr	r3, [sp, #4]
   166a0:	689a      	ldr	r2, [r3, #8]
   166a2:	9b01      	ldr	r3, [sp, #4]
   166a4:	689b      	ldr	r3, [r3, #8]
   166a6:	681b      	ldr	r3, [r3, #0]
   166a8:	3330      	adds	r3, #48	; 0x30
   166aa:	681b      	ldr	r3, [r3, #0]
   166ac:	4610      	mov	r0, r2
   166ae:	4798      	blx	r3
   166b0:	4603      	mov	r3, r0
   166b2:	461a      	mov	r2, r3
   166b4:	2301      	movs	r3, #1
   166b6:	4093      	lsls	r3, r2
   166b8:	43d8      	mvns	r0, r3
   166ba:	9b01      	ldr	r3, [sp, #4]
   166bc:	791b      	ldrb	r3, [r3, #4]
   166be:	4619      	mov	r1, r3
   166c0:	4a10      	ldr	r2, [pc, #64]	; (16704 <Gpio::ClearEdgeRising()+0x78>)
   166c2:	460b      	mov	r3, r1
   166c4:	009b      	lsls	r3, r3, #2
   166c6:	440b      	add	r3, r1
   166c8:	009b      	lsls	r3, r3, #2
   166ca:	4413      	add	r3, r2
   166cc:	330c      	adds	r3, #12
   166ce:	681b      	ldr	r3, [r3, #0]
   166d0:	681a      	ldr	r2, [r3, #0]
   166d2:	4604      	mov	r4, r0
   166d4:	9b01      	ldr	r3, [sp, #4]
   166d6:	791b      	ldrb	r3, [r3, #4]
   166d8:	4618      	mov	r0, r3
   166da:	490a      	ldr	r1, [pc, #40]	; (16704 <Gpio::ClearEdgeRising()+0x78>)
   166dc:	4603      	mov	r3, r0
   166de:	009b      	lsls	r3, r3, #2
   166e0:	4403      	add	r3, r0
   166e2:	009b      	lsls	r3, r3, #2
   166e4:	440b      	add	r3, r1
   166e6:	330c      	adds	r3, #12
   166e8:	681b      	ldr	r3, [r3, #0]
   166ea:	4022      	ands	r2, r4
   166ec:	601a      	str	r2, [r3, #0]
   166ee:	462b      	mov	r3, r5
   166f0:	4619      	mov	r1, r3
   166f2:	4803      	ldr	r0, [pc, #12]	; (16700 <Gpio::ClearEdgeRising()+0x74>)
   166f4:	f7fc fe2a 	bl	1334c <__cyg_profile_func_exit>
  }
   166f8:	bf00      	nop
   166fa:	b003      	add	sp, #12
   166fc:	bd30      	pop	{r4, r5, pc}
   166fe:	bf00      	nop
   16700:	0001668d 	.word	0x0001668d
   16704:	100001f4 	.word	0x100001f4

00016708 <Gpio::ClearEdgeFalling()>:

  // Clears the gpio interrupt to no longer trigger on a falling edge.
  void ClearEdgeFalling()
   16708:	b530      	push	{r4, r5, lr}
   1670a:	b083      	sub	sp, #12
   1670c:	4675      	mov	r5, lr
   1670e:	9001      	str	r0, [sp, #4]
   16710:	462b      	mov	r3, r5
   16712:	4619      	mov	r1, r3
   16714:	4819      	ldr	r0, [pc, #100]	; (1677c <Gpio::ClearEdgeFalling()+0x74>)
   16716:	f7fc fe05 	bl	13324 <__cyg_profile_func_enter>
  {
    *interrupt[interupt_port_].enable_falling_edge &= ~(1 << pin_->GetPin());
   1671a:	9b01      	ldr	r3, [sp, #4]
   1671c:	689a      	ldr	r2, [r3, #8]
   1671e:	9b01      	ldr	r3, [sp, #4]
   16720:	689b      	ldr	r3, [r3, #8]
   16722:	681b      	ldr	r3, [r3, #0]
   16724:	3330      	adds	r3, #48	; 0x30
   16726:	681b      	ldr	r3, [r3, #0]
   16728:	4610      	mov	r0, r2
   1672a:	4798      	blx	r3
   1672c:	4603      	mov	r3, r0
   1672e:	461a      	mov	r2, r3
   16730:	2301      	movs	r3, #1
   16732:	4093      	lsls	r3, r2
   16734:	43d8      	mvns	r0, r3
   16736:	9b01      	ldr	r3, [sp, #4]
   16738:	791b      	ldrb	r3, [r3, #4]
   1673a:	4619      	mov	r1, r3
   1673c:	4a10      	ldr	r2, [pc, #64]	; (16780 <Gpio::ClearEdgeFalling()+0x78>)
   1673e:	460b      	mov	r3, r1
   16740:	009b      	lsls	r3, r3, #2
   16742:	440b      	add	r3, r1
   16744:	009b      	lsls	r3, r3, #2
   16746:	4413      	add	r3, r2
   16748:	3310      	adds	r3, #16
   1674a:	681b      	ldr	r3, [r3, #0]
   1674c:	681a      	ldr	r2, [r3, #0]
   1674e:	4604      	mov	r4, r0
   16750:	9b01      	ldr	r3, [sp, #4]
   16752:	791b      	ldrb	r3, [r3, #4]
   16754:	4618      	mov	r0, r3
   16756:	490a      	ldr	r1, [pc, #40]	; (16780 <Gpio::ClearEdgeFalling()+0x78>)
   16758:	4603      	mov	r3, r0
   1675a:	009b      	lsls	r3, r3, #2
   1675c:	4403      	add	r3, r0
   1675e:	009b      	lsls	r3, r3, #2
   16760:	440b      	add	r3, r1
   16762:	3310      	adds	r3, #16
   16764:	681b      	ldr	r3, [r3, #0]
   16766:	4022      	ands	r2, r4
   16768:	601a      	str	r2, [r3, #0]
   1676a:	462b      	mov	r3, r5
   1676c:	4619      	mov	r1, r3
   1676e:	4803      	ldr	r0, [pc, #12]	; (1677c <Gpio::ClearEdgeFalling()+0x74>)
   16770:	f7fc fdec 	bl	1334c <__cyg_profile_func_exit>
  }
   16774:	bf00      	nop
   16776:	b003      	add	sp, #12
   16778:	bd30      	pop	{r4, r5, pc}
   1677a:	bf00      	nop
   1677c:	00016709 	.word	0x00016709
   16780:	100001f4 	.word	0x100001f4

00016784 <SystemControllerInterface::SystemControllerInterface()>:
class SystemControllerInterface
   16784:	b082      	sub	sp, #8
   16786:	9001      	str	r0, [sp, #4]
   16788:	4a03      	ldr	r2, [pc, #12]	; (16798 <SystemControllerInterface::SystemControllerInterface()+0x14>)
   1678a:	9b01      	ldr	r3, [sp, #4]
   1678c:	601a      	str	r2, [r3, #0]
   1678e:	9b01      	ldr	r3, [sp, #4]
   16790:	4618      	mov	r0, r3
   16792:	b002      	add	sp, #8
   16794:	4770      	bx	lr
   16796:	bf00      	nop
   16798:	0001acb4 	.word	0x0001acb4

0001679c <Lpc40xxSystemController::Lpc40xxSystemController()>:
  constexpr Lpc40xxSystemController() {}
   1679c:	b500      	push	{lr}
   1679e:	b083      	sub	sp, #12
   167a0:	9001      	str	r0, [sp, #4]
   167a2:	9b01      	ldr	r3, [sp, #4]
   167a4:	4618      	mov	r0, r3
   167a6:	f7ff ffed 	bl	16784 <SystemControllerInterface::SystemControllerInterface()>
   167aa:	4a04      	ldr	r2, [pc, #16]	; (167bc <Lpc40xxSystemController::Lpc40xxSystemController()+0x20>)
   167ac:	9b01      	ldr	r3, [sp, #4]
   167ae:	601a      	str	r2, [r3, #0]
   167b0:	9b01      	ldr	r3, [sp, #4]
   167b2:	4618      	mov	r0, r3
   167b4:	b003      	add	sp, #12
   167b6:	f85d fb04 	ldr.w	pc, [sp], #4
   167ba:	bf00      	nop
   167bc:	00019710 	.word	0x00019710

000167c0 <SspInterface::SspInterface()>:
class SspInterface
   167c0:	b530      	push	{r4, r5, lr}
   167c2:	b083      	sub	sp, #12
   167c4:	4675      	mov	r5, lr
   167c6:	9001      	str	r0, [sp, #4]
   167c8:	462b      	mov	r3, r5
   167ca:	4619      	mov	r1, r3
   167cc:	4807      	ldr	r0, [pc, #28]	; (167ec <SspInterface::SspInterface()+0x2c>)
   167ce:	f7fc fda9 	bl	13324 <__cyg_profile_func_enter>
   167d2:	4a07      	ldr	r2, [pc, #28]	; (167f0 <SspInterface::SspInterface()+0x30>)
   167d4:	9b01      	ldr	r3, [sp, #4]
   167d6:	601a      	str	r2, [r3, #0]
   167d8:	9c01      	ldr	r4, [sp, #4]
   167da:	462b      	mov	r3, r5
   167dc:	4619      	mov	r1, r3
   167de:	4803      	ldr	r0, [pc, #12]	; (167ec <SspInterface::SspInterface()+0x2c>)
   167e0:	f7fc fdb4 	bl	1334c <__cyg_profile_func_exit>
   167e4:	4623      	mov	r3, r4
   167e6:	4618      	mov	r0, r3
   167e8:	b003      	add	sp, #12
   167ea:	bd30      	pop	{r4, r5, pc}
   167ec:	000167c1 	.word	0x000167c1
   167f0:	0001ac8c 	.word	0x0001ac8c

000167f4 <PinInterface::PinInterface(PinInterface const&)>:
class PinInterface
   167f4:	b530      	push	{r4, r5, lr}
   167f6:	b083      	sub	sp, #12
   167f8:	4675      	mov	r5, lr
   167fa:	9001      	str	r0, [sp, #4]
   167fc:	9100      	str	r1, [sp, #0]
   167fe:	462b      	mov	r3, r5
   16800:	4619      	mov	r1, r3
   16802:	4808      	ldr	r0, [pc, #32]	; (16824 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   16804:	f7fc fd8e 	bl	13324 <__cyg_profile_func_enter>
   16808:	4a07      	ldr	r2, [pc, #28]	; (16828 <PinInterface::PinInterface(PinInterface const&)+0x34>)
   1680a:	9b01      	ldr	r3, [sp, #4]
   1680c:	601a      	str	r2, [r3, #0]
   1680e:	9c01      	ldr	r4, [sp, #4]
   16810:	462b      	mov	r3, r5
   16812:	4619      	mov	r1, r3
   16814:	4803      	ldr	r0, [pc, #12]	; (16824 <PinInterface::PinInterface(PinInterface const&)+0x30>)
   16816:	f7fc fd99 	bl	1334c <__cyg_profile_func_exit>
   1681a:	4623      	mov	r3, r4
   1681c:	4618      	mov	r0, r3
   1681e:	b003      	add	sp, #12
   16820:	bd30      	pop	{r4, r5, pc}
   16822:	bf00      	nop
   16824:	000167f5 	.word	0x000167f5
   16828:	0001ad68 	.word	0x0001ad68

0001682c <Pin::Pin(Pin const&)>:
class Pin : public PinInterface
   1682c:	b530      	push	{r4, r5, lr}
   1682e:	b083      	sub	sp, #12
   16830:	4675      	mov	r5, lr
   16832:	9001      	str	r0, [sp, #4]
   16834:	9100      	str	r1, [sp, #0]
   16836:	462b      	mov	r3, r5
   16838:	4619      	mov	r1, r3
   1683a:	480f      	ldr	r0, [pc, #60]	; (16878 <Pin::Pin(Pin const&)+0x4c>)
   1683c:	f7fc fd72 	bl	13324 <__cyg_profile_func_enter>
   16840:	9b01      	ldr	r3, [sp, #4]
   16842:	9a00      	ldr	r2, [sp, #0]
   16844:	4611      	mov	r1, r2
   16846:	4618      	mov	r0, r3
   16848:	f7ff ffd4 	bl	167f4 <PinInterface::PinInterface(PinInterface const&)>
   1684c:	4a0b      	ldr	r2, [pc, #44]	; (1687c <Pin::Pin(Pin const&)+0x50>)
   1684e:	9b01      	ldr	r3, [sp, #4]
   16850:	601a      	str	r2, [r3, #0]
   16852:	9b00      	ldr	r3, [sp, #0]
   16854:	791a      	ldrb	r2, [r3, #4]
   16856:	9b01      	ldr	r3, [sp, #4]
   16858:	711a      	strb	r2, [r3, #4]
   1685a:	9b00      	ldr	r3, [sp, #0]
   1685c:	795a      	ldrb	r2, [r3, #5]
   1685e:	9b01      	ldr	r3, [sp, #4]
   16860:	715a      	strb	r2, [r3, #5]
   16862:	9c01      	ldr	r4, [sp, #4]
   16864:	462b      	mov	r3, r5
   16866:	4619      	mov	r1, r3
   16868:	4803      	ldr	r0, [pc, #12]	; (16878 <Pin::Pin(Pin const&)+0x4c>)
   1686a:	f7fc fd6f 	bl	1334c <__cyg_profile_func_exit>
   1686e:	4623      	mov	r3, r4
   16870:	4618      	mov	r0, r3
   16872:	b003      	add	sp, #12
   16874:	bd30      	pop	{r4, r5, pc}
   16876:	bf00      	nop
   16878:	0001682d 	.word	0x0001682d
   1687c:	0001969c 	.word	0x0001969c

00016880 <Ssp::Ssp(Ssp::Peripheral)>:
  explicit constexpr Ssp(Peripheral set_pssp)
   16880:	b530      	push	{r4, r5, lr}
   16882:	b083      	sub	sp, #12
   16884:	4675      	mov	r5, lr
   16886:	9001      	str	r0, [sp, #4]
   16888:	9100      	str	r1, [sp, #0]
   1688a:	462b      	mov	r3, r5
   1688c:	4619      	mov	r1, r3
   1688e:	4831      	ldr	r0, [pc, #196]	; (16954 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   16890:	f7fc fd48 	bl	13324 <__cyg_profile_func_enter>
        pssp_(set_pssp)
   16894:	9b01      	ldr	r3, [sp, #4]
   16896:	4618      	mov	r0, r3
   16898:	f7ff ff92 	bl	167c0 <SspInterface::SspInterface()>
   1689c:	9b01      	ldr	r3, [sp, #4]
   1689e:	3304      	adds	r3, #4
   168a0:	4618      	mov	r0, r3
   168a2:	f7ff ff7b 	bl	1679c <Lpc40xxSystemController::Lpc40xxSystemController()>
   168a6:	4a2c      	ldr	r2, [pc, #176]	; (16958 <Ssp::Ssp(Ssp::Peripheral)+0xd8>)
   168a8:	9b01      	ldr	r3, [sp, #4]
   168aa:	601a      	str	r2, [r3, #0]
   168ac:	4a2b      	ldr	r2, [pc, #172]	; (1695c <Ssp::Ssp(Ssp::Peripheral)+0xdc>)
   168ae:	9b01      	ldr	r3, [sp, #4]
   168b0:	605a      	str	r2, [r3, #4]
   168b2:	9b01      	ldr	r3, [sp, #4]
   168b4:	f103 0214 	add.w	r2, r3, #20
   168b8:	9b01      	ldr	r3, [sp, #4]
   168ba:	609a      	str	r2, [r3, #8]
   168bc:	9b01      	ldr	r3, [sp, #4]
   168be:	f103 021c 	add.w	r2, r3, #28
   168c2:	9b01      	ldr	r3, [sp, #4]
   168c4:	60da      	str	r2, [r3, #12]
   168c6:	9b01      	ldr	r3, [sp, #4]
   168c8:	f103 0224 	add.w	r2, r3, #36	; 0x24
   168cc:	9b01      	ldr	r3, [sp, #4]
   168ce:	611a      	str	r2, [r3, #16]
   168d0:	9b01      	ldr	r3, [sp, #4]
   168d2:	f103 0414 	add.w	r4, r3, #20
        mosi_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMosi]),
   168d6:	9800      	ldr	r0, [sp, #0]
   168d8:	f7fa f89c 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   168dc:	4602      	mov	r2, r0
        pssp_(set_pssp)
   168de:	4613      	mov	r3, r2
   168e0:	005b      	lsls	r3, r3, #1
   168e2:	4413      	add	r3, r2
   168e4:	00db      	lsls	r3, r3, #3
   168e6:	4a1e      	ldr	r2, [pc, #120]	; (16960 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   168e8:	4413      	add	r3, r2
   168ea:	4619      	mov	r1, r3
   168ec:	4620      	mov	r0, r4
   168ee:	f7ff ff9d 	bl	1682c <Pin::Pin(Pin const&)>
   168f2:	9b01      	ldr	r3, [sp, #4]
   168f4:	f103 041c 	add.w	r4, r3, #28
        miso_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kMiso]),
   168f8:	9800      	ldr	r0, [sp, #0]
   168fa:	f7fa f88b 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   168fe:	4602      	mov	r2, r0
        pssp_(set_pssp)
   16900:	4613      	mov	r3, r2
   16902:	005b      	lsls	r3, r3, #1
   16904:	4413      	add	r3, r2
   16906:	00db      	lsls	r3, r3, #3
   16908:	3308      	adds	r3, #8
   1690a:	4a15      	ldr	r2, [pc, #84]	; (16960 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   1690c:	4413      	add	r3, r2
   1690e:	4619      	mov	r1, r3
   16910:	4620      	mov	r0, r4
   16912:	f7ff ff8b 	bl	1682c <Pin::Pin(Pin const&)>
   16916:	9b01      	ldr	r3, [sp, #4]
   16918:	f103 0424 	add.w	r4, r3, #36	; 0x24
        sck_pin_(kSspPinMatrix[util::Value(set_pssp)][MatrixLookup::kSck]),
   1691c:	9800      	ldr	r0, [sp, #0]
   1691e:	f7fa f879 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16922:	4602      	mov	r2, r0
        pssp_(set_pssp)
   16924:	4613      	mov	r3, r2
   16926:	005b      	lsls	r3, r3, #1
   16928:	4413      	add	r3, r2
   1692a:	00db      	lsls	r3, r3, #3
   1692c:	3310      	adds	r3, #16
   1692e:	4a0c      	ldr	r2, [pc, #48]	; (16960 <Ssp::Ssp(Ssp::Peripheral)+0xe0>)
   16930:	4413      	add	r3, r2
   16932:	4619      	mov	r1, r3
   16934:	4620      	mov	r0, r4
   16936:	f7ff ff79 	bl	1682c <Pin::Pin(Pin const&)>
   1693a:	9b01      	ldr	r3, [sp, #4]
   1693c:	9a00      	ldr	r2, [sp, #0]
   1693e:	62da      	str	r2, [r3, #44]	; 0x2c
  }
   16940:	9c01      	ldr	r4, [sp, #4]
   16942:	462b      	mov	r3, r5
   16944:	4619      	mov	r1, r3
   16946:	4803      	ldr	r0, [pc, #12]	; (16954 <Ssp::Ssp(Ssp::Peripheral)+0xd4>)
   16948:	f7fc fd00 	bl	1334c <__cyg_profile_func_exit>
   1694c:	4623      	mov	r3, r4
   1694e:	4618      	mov	r0, r3
   16950:	b003      	add	sp, #12
   16952:	bd30      	pop	{r4, r5, pc}
   16954:	00016881 	.word	0x00016881
   16958:	0001ac40 	.word	0x0001ac40
   1695c:	0001ac68 	.word	0x0001ac68
   16960:	0001a7f4 	.word	0x0001a7f4

00016964 <Ssp::Initialize()>:
  void Initialize() override
   16964:	b570      	push	{r4, r5, r6, lr}
   16966:	b086      	sub	sp, #24
   16968:	4676      	mov	r6, lr
   1696a:	9001      	str	r0, [sp, #4]
   1696c:	4633      	mov	r3, r6
   1696e:	4619      	mov	r1, r3
   16970:	4830      	ldr	r0, [pc, #192]	; (16a34 <Ssp::Initialize()+0xd0>)
   16972:	f7fc fcd7 	bl	13324 <__cyg_profile_func_enter>
    uint32_t pssp = util::Value(pssp_);
   16976:	9b01      	ldr	r3, [sp, #4]
   16978:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1697a:	4618      	mov	r0, r3
   1697c:	f7fa f84a 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16980:	4603      	mov	r3, r0
   16982:	9305      	str	r3, [sp, #20]
    PowerUpPeripheral(kPowerBit[pssp]);
   16984:	9b01      	ldr	r3, [sp, #4]
   16986:	1d18      	adds	r0, r3, #4
   16988:	9b01      	ldr	r3, [sp, #4]
   1698a:	685b      	ldr	r3, [r3, #4]
   1698c:	3314      	adds	r3, #20
   1698e:	681b      	ldr	r3, [r3, #0]
   16990:	9a05      	ldr	r2, [sp, #20]
   16992:	0092      	lsls	r2, r2, #2
   16994:	4928      	ldr	r1, [pc, #160]	; (16a38 <Ssp::Initialize()+0xd4>)
   16996:	440a      	add	r2, r1
   16998:	4611      	mov	r1, r2
   1699a:	4798      	blx	r3
    mosi_->SetPinFunction(kPinSelect[pssp]);
   1699c:	9b01      	ldr	r3, [sp, #4]
   1699e:	6898      	ldr	r0, [r3, #8]
   169a0:	9b01      	ldr	r3, [sp, #4]
   169a2:	689b      	ldr	r3, [r3, #8]
   169a4:	681b      	ldr	r3, [r3, #0]
   169a6:	681b      	ldr	r3, [r3, #0]
   169a8:	4924      	ldr	r1, [pc, #144]	; (16a3c <Ssp::Initialize()+0xd8>)
   169aa:	9a05      	ldr	r2, [sp, #20]
   169ac:	440a      	add	r2, r1
   169ae:	7812      	ldrb	r2, [r2, #0]
   169b0:	4611      	mov	r1, r2
   169b2:	4798      	blx	r3
    miso_->SetPinFunction(kPinSelect[pssp]);
   169b4:	9b01      	ldr	r3, [sp, #4]
   169b6:	68d8      	ldr	r0, [r3, #12]
   169b8:	9b01      	ldr	r3, [sp, #4]
   169ba:	68db      	ldr	r3, [r3, #12]
   169bc:	681b      	ldr	r3, [r3, #0]
   169be:	681b      	ldr	r3, [r3, #0]
   169c0:	491e      	ldr	r1, [pc, #120]	; (16a3c <Ssp::Initialize()+0xd8>)
   169c2:	9a05      	ldr	r2, [sp, #20]
   169c4:	440a      	add	r2, r1
   169c6:	7812      	ldrb	r2, [r2, #0]
   169c8:	4611      	mov	r1, r2
   169ca:	4798      	blx	r3
    sck_->SetPinFunction(kPinSelect[pssp]);
   169cc:	9b01      	ldr	r3, [sp, #4]
   169ce:	6918      	ldr	r0, [r3, #16]
   169d0:	9b01      	ldr	r3, [sp, #4]
   169d2:	691b      	ldr	r3, [r3, #16]
   169d4:	681b      	ldr	r3, [r3, #0]
   169d6:	681b      	ldr	r3, [r3, #0]
   169d8:	4918      	ldr	r1, [pc, #96]	; (16a3c <Ssp::Initialize()+0xd8>)
   169da:	9a05      	ldr	r2, [sp, #20]
   169dc:	440a      	add	r2, r1
   169de:	7812      	ldrb	r2, [r2, #0]
   169e0:	4611      	mov	r1, r2
   169e2:	4798      	blx	r3
    ssp_registers[pssp]->CR1 = bit::Set(ssp_registers[pssp]->CR1, kSspEnable);
   169e4:	4a16      	ldr	r2, [pc, #88]	; (16a40 <Ssp::Initialize()+0xdc>)
   169e6:	9b05      	ldr	r3, [sp, #20]
   169e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   169ec:	685b      	ldr	r3, [r3, #4]
   169ee:	4914      	ldr	r1, [pc, #80]	; (16a40 <Ssp::Initialize()+0xdc>)
   169f0:	9a05      	ldr	r2, [sp, #20]
   169f2:	f851 4022 	ldr.w	r4, [r1, r2, lsl #2]
   169f6:	9304      	str	r3, [sp, #16]
   169f8:	2301      	movs	r3, #1
   169fa:	9303      	str	r3, [sp, #12]
   169fc:	4633      	mov	r3, r6
   169fe:	4619      	mov	r1, r3
   16a00:	4810      	ldr	r0, [pc, #64]	; (16a44 <Ssp::Initialize()+0xe0>)
   16a02:	f7fc fc8f 	bl	13324 <__cyg_profile_func_enter>
  return target | (1 << position);
   16a06:	2201      	movs	r2, #1
   16a08:	9b03      	ldr	r3, [sp, #12]
   16a0a:	fa02 f303 	lsl.w	r3, r2, r3
   16a0e:	461a      	mov	r2, r3
   16a10:	9b04      	ldr	r3, [sp, #16]
   16a12:	ea42 0503 	orr.w	r5, r2, r3
   16a16:	4633      	mov	r3, r6
   16a18:	4619      	mov	r1, r3
   16a1a:	480a      	ldr	r0, [pc, #40]	; (16a44 <Ssp::Initialize()+0xe0>)
   16a1c:	f7fc fc96 	bl	1334c <__cyg_profile_func_exit>
   16a20:	6065      	str	r5, [r4, #4]
   16a22:	4633      	mov	r3, r6
   16a24:	4619      	mov	r1, r3
   16a26:	4803      	ldr	r0, [pc, #12]	; (16a34 <Ssp::Initialize()+0xd0>)
   16a28:	f7fc fc90 	bl	1334c <__cyg_profile_func_exit>
  }
   16a2c:	bf00      	nop
   16a2e:	b006      	add	sp, #24
   16a30:	bd70      	pop	{r4, r5, r6, pc}
   16a32:	bf00      	nop
   16a34:	00016965 	.word	0x00016965
   16a38:	0001a83c 	.word	0x0001a83c
   16a3c:	0001a7f0 	.word	0x0001a7f0
   16a40:	1000005c 	.word	0x1000005c
   16a44:	000184e1 	.word	0x000184e1

00016a48 <Ssp::SetSpiMasterDefault()>:

  /// Sets up SSP peripheral as SPI master
  void SetSpiMasterDefault() override
   16a48:	b510      	push	{r4, lr}
   16a4a:	b086      	sub	sp, #24
   16a4c:	4674      	mov	r4, lr
   16a4e:	9003      	str	r0, [sp, #12]
   16a50:	4623      	mov	r3, r4
   16a52:	4619      	mov	r1, r3
   16a54:	4812      	ldr	r0, [pc, #72]	; (16aa0 <Ssp::SetSpiMasterDefault()+0x58>)
   16a56:	f7fc fc65 	bl	13324 <__cyg_profile_func_enter>
  {
    constexpr bool kHighPolarity  = 1;
   16a5a:	2301      	movs	r3, #1
   16a5c:	f88d 3017 	strb.w	r3, [sp, #23]
    constexpr bool kPhase0        = 0;
   16a60:	2300      	movs	r3, #0
   16a62:	f88d 3016 	strb.w	r3, [sp, #22]
    constexpr uint8_t kScrDivider = 0;
   16a66:	2300      	movs	r3, #0
   16a68:	f88d 3015 	strb.w	r3, [sp, #21]
    constexpr uint8_t kPrescaler  = SJ2_SYSTEM_CLOCK_RATE_MHZ;
   16a6c:	2330      	movs	r3, #48	; 0x30
   16a6e:	f88d 3014 	strb.w	r3, [sp, #20]

    SetPeripheralMode(kMaster, kSpi, kEight);
   16a72:	2307      	movs	r3, #7
   16a74:	2200      	movs	r2, #0
   16a76:	2100      	movs	r1, #0
   16a78:	9803      	ldr	r0, [sp, #12]
   16a7a:	f000 f85b 	bl	16b34 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>
    SetClock(kHighPolarity, kPhase0, kScrDivider, kPrescaler);
   16a7e:	2330      	movs	r3, #48	; 0x30
   16a80:	9300      	str	r3, [sp, #0]
   16a82:	2300      	movs	r3, #0
   16a84:	2200      	movs	r2, #0
   16a86:	2101      	movs	r1, #1
   16a88:	9803      	ldr	r0, [sp, #12]
   16a8a:	f000 fa09 	bl	16ea0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>
   16a8e:	4623      	mov	r3, r4
   16a90:	4619      	mov	r1, r3
   16a92:	4803      	ldr	r0, [pc, #12]	; (16aa0 <Ssp::SetSpiMasterDefault()+0x58>)
   16a94:	f7fc fc5a 	bl	1334c <__cyg_profile_func_exit>
  }
   16a98:	bf00      	nop
   16a9a:	b006      	add	sp, #24
   16a9c:	bd10      	pop	{r4, pc}
   16a9e:	bf00      	nop
   16aa0:	00016a49 	.word	0x00016a49

00016aa4 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>:
constexpr Type Value(Enum enum_type_value)
   16aa4:	b530      	push	{r4, r5, lr}
   16aa6:	b083      	sub	sp, #12
   16aa8:	4675      	mov	r5, lr
   16aaa:	4603      	mov	r3, r0
   16aac:	f88d 3007 	strb.w	r3, [sp, #7]
   16ab0:	462b      	mov	r3, r5
   16ab2:	4619      	mov	r1, r3
   16ab4:	4806      	ldr	r0, [pc, #24]	; (16ad0 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   16ab6:	f7fc fc35 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   16aba:	f89d 4007 	ldrb.w	r4, [sp, #7]
   16abe:	462b      	mov	r3, r5
   16ac0:	4619      	mov	r1, r3
   16ac2:	4803      	ldr	r0, [pc, #12]	; (16ad0 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)+0x2c>)
   16ac4:	f7fc fc42 	bl	1334c <__cyg_profile_func_exit>
   16ac8:	4623      	mov	r3, r4
}
   16aca:	4618      	mov	r0, r3
   16acc:	b003      	add	sp, #12
   16ace:	bd30      	pop	{r4, r5, pc}
   16ad0:	00016aa5 	.word	0x00016aa5

00016ad4 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>:
constexpr Type Value(Enum enum_type_value)
   16ad4:	b530      	push	{r4, r5, lr}
   16ad6:	b083      	sub	sp, #12
   16ad8:	4675      	mov	r5, lr
   16ada:	4603      	mov	r3, r0
   16adc:	f88d 3007 	strb.w	r3, [sp, #7]
   16ae0:	462b      	mov	r3, r5
   16ae2:	4619      	mov	r1, r3
   16ae4:	4806      	ldr	r0, [pc, #24]	; (16b00 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   16ae6:	f7fc fc1d 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   16aea:	f89d 4007 	ldrb.w	r4, [sp, #7]
   16aee:	462b      	mov	r3, r5
   16af0:	4619      	mov	r1, r3
   16af2:	4803      	ldr	r0, [pc, #12]	; (16b00 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)+0x2c>)
   16af4:	f7fc fc2a 	bl	1334c <__cyg_profile_func_exit>
   16af8:	4623      	mov	r3, r4
}
   16afa:	4618      	mov	r0, r3
   16afc:	b003      	add	sp, #12
   16afe:	bd30      	pop	{r4, r5, pc}
   16b00:	00016ad5 	.word	0x00016ad5

00016b04 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>:
constexpr Type Value(Enum enum_type_value)
   16b04:	b530      	push	{r4, r5, lr}
   16b06:	b083      	sub	sp, #12
   16b08:	4675      	mov	r5, lr
   16b0a:	4603      	mov	r3, r0
   16b0c:	f88d 3007 	strb.w	r3, [sp, #7]
   16b10:	462b      	mov	r3, r5
   16b12:	4619      	mov	r1, r3
   16b14:	4806      	ldr	r0, [pc, #24]	; (16b30 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   16b16:	f7fc fc05 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<Type>(enum_type_value);
   16b1a:	f89d 4007 	ldrb.w	r4, [sp, #7]
   16b1e:	462b      	mov	r3, r5
   16b20:	4619      	mov	r1, r3
   16b22:	4803      	ldr	r0, [pc, #12]	; (16b30 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)+0x2c>)
   16b24:	f7fc fc12 	bl	1334c <__cyg_profile_func_exit>
   16b28:	4623      	mov	r3, r4
}
   16b2a:	4618      	mov	r0, r3
   16b2c:	b003      	add	sp, #12
   16b2e:	bd30      	pop	{r4, r5, pc}
   16b30:	00016b05 	.word	0x00016b05

00016b34 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)>:

  /// Sets the various modes for the Peripheral
  /// @param mode - master or slave mode
  /// @param frame - format for Peripheral data to use
  /// @param size - number of bits per frame
  void SetPeripheralMode(MasterSlaveMode mode, FrameMode frame,
   16b34:	b570      	push	{r4, r5, r6, lr}
   16b36:	b098      	sub	sp, #96	; 0x60
   16b38:	4674      	mov	r4, lr
   16b3a:	9001      	str	r0, [sp, #4]
   16b3c:	4608      	mov	r0, r1
   16b3e:	4611      	mov	r1, r2
   16b40:	461a      	mov	r2, r3
   16b42:	4603      	mov	r3, r0
   16b44:	f88d 3003 	strb.w	r3, [sp, #3]
   16b48:	460b      	mov	r3, r1
   16b4a:	f88d 3002 	strb.w	r3, [sp, #2]
   16b4e:	4613      	mov	r3, r2
   16b50:	f88d 3001 	strb.w	r3, [sp, #1]
   16b54:	4623      	mov	r3, r4
   16b56:	4619      	mov	r1, r3
   16b58:	4875      	ldr	r0, [pc, #468]	; (16d30 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   16b5a:	f7fc fbe3 	bl	13324 <__cyg_profile_func_enter>
                         DataSize size) override
  {
    uint32_t pssp = util::Value(pssp_);
   16b5e:	9b01      	ldr	r3, [sp, #4]
   16b60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16b62:	4618      	mov	r0, r3
   16b64:	f7f9 ff56 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16b68:	4603      	mov	r3, r0
   16b6a:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   16b6c:	9b01      	ldr	r3, [sp, #4]
   16b6e:	1d18      	adds	r0, r3, #4
   16b70:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16b72:	009b      	lsls	r3, r3, #2
   16b74:	4a6f      	ldr	r2, [pc, #444]	; (16d34 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x200>)
   16b76:	4413      	add	r3, r2
   16b78:	4619      	mov	r1, r3
   16b7a:	f7fa fa7d 	bl	11078 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    if (frame == kMicro)
   16b7e:	f89d 3002 	ldrb.w	r3, [sp, #2]
   16b82:	2b02      	cmp	r3, #2
   16b84:	d102      	bne.n	16b8c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x58>
    {
      size = kEight;
   16b86:	2307      	movs	r3, #7
   16b88:	f88d 3001 	strb.w	r3, [sp, #1]
    }
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(size), kDataBit, 4);
   16b8c:	4a6a      	ldr	r2, [pc, #424]	; (16d38 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16b8e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16b90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16b94:	681e      	ldr	r6, [r3, #0]
   16b96:	f89d 3001 	ldrb.w	r3, [sp, #1]
   16b9a:	4618      	mov	r0, r3
   16b9c:	f7ff ff82 	bl	16aa4 <unsigned char util::Value<SspInterface::DataSize, unsigned char>(SspInterface::DataSize)>
   16ba0:	4603      	mov	r3, r0
   16ba2:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   16ba4:	4a64      	ldr	r2, [pc, #400]	; (16d38 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16ba6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16ba8:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   16bac:	9608      	str	r6, [sp, #32]
   16bae:	460b      	mov	r3, r1
   16bb0:	f88d 301f 	strb.w	r3, [sp, #31]
   16bb4:	2300      	movs	r3, #0
   16bb6:	9306      	str	r3, [sp, #24]
   16bb8:	2304      	movs	r3, #4
   16bba:	9305      	str	r3, [sp, #20]
   16bbc:	4623      	mov	r3, r4
   16bbe:	4619      	mov	r1, r3
   16bc0:	485e      	ldr	r0, [pc, #376]	; (16d3c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16bc2:	f7fc fbaf 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16bc6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16bca:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16bcc:	2320      	movs	r3, #32
   16bce:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16bd0:	9b05      	ldr	r3, [sp, #20]
   16bd2:	f1c3 0320 	rsb	r3, r3, #32
   16bd6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16bda:	fa22 f303 	lsr.w	r3, r2, r3
   16bde:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   16be0:	9a02      	ldr	r2, [sp, #8]
   16be2:	9b06      	ldr	r3, [sp, #24]
   16be4:	fa02 f303 	lsl.w	r3, r2, r3
   16be8:	43db      	mvns	r3, r3
   16bea:	9a08      	ldr	r2, [sp, #32]
   16bec:	4013      	ands	r3, r2
   16bee:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   16bf0:	f89d 201f 	ldrb.w	r2, [sp, #31]
   16bf4:	9b02      	ldr	r3, [sp, #8]
   16bf6:	401a      	ands	r2, r3
   16bf8:	9b06      	ldr	r3, [sp, #24]
   16bfa:	fa02 f303 	lsl.w	r3, r2, r3
   16bfe:	9a08      	ldr	r2, [sp, #32]
   16c00:	4313      	orrs	r3, r2
   16c02:	9308      	str	r3, [sp, #32]
  return target;
   16c04:	9e08      	ldr	r6, [sp, #32]
   16c06:	4623      	mov	r3, r4
   16c08:	4619      	mov	r1, r3
   16c0a:	484c      	ldr	r0, [pc, #304]	; (16d3c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16c0c:	f7fc fb9e 	bl	1334c <__cyg_profile_func_exit>
   16c10:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, util::Value(frame), kFrameBit, 2);
   16c12:	4a49      	ldr	r2, [pc, #292]	; (16d38 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16c14:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16c16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16c1a:	681e      	ldr	r6, [r3, #0]
   16c1c:	f89d 3002 	ldrb.w	r3, [sp, #2]
   16c20:	4618      	mov	r0, r3
   16c22:	f7ff ff57 	bl	16ad4 <unsigned char util::Value<SspInterface::FrameMode, unsigned char>(SspInterface::FrameMode)>
   16c26:	4603      	mov	r3, r0
   16c28:	4619      	mov	r1, r3
    ssp_registers[pssp]->CR0 =
   16c2a:	4a43      	ldr	r2, [pc, #268]	; (16d38 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16c2c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16c2e:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   16c32:	960f      	str	r6, [sp, #60]	; 0x3c
   16c34:	460b      	mov	r3, r1
   16c36:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   16c3a:	2304      	movs	r3, #4
   16c3c:	930d      	str	r3, [sp, #52]	; 0x34
   16c3e:	2302      	movs	r3, #2
   16c40:	930c      	str	r3, [sp, #48]	; 0x30
   16c42:	4623      	mov	r3, r4
   16c44:	4619      	mov	r1, r3
   16c46:	483d      	ldr	r0, [pc, #244]	; (16d3c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16c48:	f7fc fb6c 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16c4c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16c50:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16c52:	2320      	movs	r3, #32
   16c54:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16c56:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   16c58:	f1c3 0320 	rsb	r3, r3, #32
   16c5c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16c60:	fa22 f303 	lsr.w	r3, r2, r3
   16c64:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   16c66:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16c68:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16c6a:	fa02 f303 	lsl.w	r3, r2, r3
   16c6e:	43db      	mvns	r3, r3
   16c70:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16c72:	4013      	ands	r3, r2
   16c74:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   16c76:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   16c7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16c7c:	401a      	ands	r2, r3
   16c7e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16c80:	fa02 f303 	lsl.w	r3, r2, r3
   16c84:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16c86:	4313      	orrs	r3, r2
   16c88:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   16c8a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   16c8c:	4623      	mov	r3, r4
   16c8e:	4619      	mov	r1, r3
   16c90:	482a      	ldr	r0, [pc, #168]	; (16d3c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16c92:	f7fc fb5b 	bl	1334c <__cyg_profile_func_exit>
   16c96:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR1 = bit::Insert(
        ssp_registers[pssp]->CR1, util::Value(mode), kMasterModeBit, 1);
   16c98:	4a27      	ldr	r2, [pc, #156]	; (16d38 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16c9a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16c9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16ca0:	685e      	ldr	r6, [r3, #4]
    ssp_registers[pssp]->CR1 = bit::Insert(
   16ca2:	f89d 3003 	ldrb.w	r3, [sp, #3]
   16ca6:	4618      	mov	r0, r3
   16ca8:	f7ff ff2c 	bl	16b04 <unsigned char util::Value<SspInterface::MasterSlaveMode, unsigned char>(SspInterface::MasterSlaveMode)>
   16cac:	4603      	mov	r3, r0
   16cae:	4619      	mov	r1, r3
   16cb0:	4a21      	ldr	r2, [pc, #132]	; (16d38 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x204>)
   16cb2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16cb4:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   16cb8:	9616      	str	r6, [sp, #88]	; 0x58
   16cba:	460b      	mov	r3, r1
   16cbc:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   16cc0:	2302      	movs	r3, #2
   16cc2:	9314      	str	r3, [sp, #80]	; 0x50
   16cc4:	2301      	movs	r3, #1
   16cc6:	9313      	str	r3, [sp, #76]	; 0x4c
   16cc8:	4623      	mov	r3, r4
   16cca:	4619      	mov	r1, r3
   16ccc:	481b      	ldr	r0, [pc, #108]	; (16d3c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16cce:	f7fc fb29 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16cd2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16cd6:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16cd8:	2320      	movs	r3, #32
   16cda:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16cdc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   16cde:	f1c3 0320 	rsb	r3, r3, #32
   16ce2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16ce6:	fa22 f303 	lsr.w	r3, r2, r3
   16cea:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   16cec:	9a10      	ldr	r2, [sp, #64]	; 0x40
   16cee:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16cf0:	fa02 f303 	lsl.w	r3, r2, r3
   16cf4:	43db      	mvns	r3, r3
   16cf6:	9a16      	ldr	r2, [sp, #88]	; 0x58
   16cf8:	4013      	ands	r3, r2
   16cfa:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   16cfc:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   16d00:	9b10      	ldr	r3, [sp, #64]	; 0x40
   16d02:	401a      	ands	r2, r3
   16d04:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16d06:	fa02 f303 	lsl.w	r3, r2, r3
   16d0a:	9a16      	ldr	r2, [sp, #88]	; 0x58
   16d0c:	4313      	orrs	r3, r2
   16d0e:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   16d10:	9e16      	ldr	r6, [sp, #88]	; 0x58
   16d12:	4623      	mov	r3, r4
   16d14:	4619      	mov	r1, r3
   16d16:	4809      	ldr	r0, [pc, #36]	; (16d3c <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x208>)
   16d18:	f7fc fb18 	bl	1334c <__cyg_profile_func_exit>
   16d1c:	606e      	str	r6, [r5, #4]
   16d1e:	4623      	mov	r3, r4
   16d20:	4619      	mov	r1, r3
   16d22:	4803      	ldr	r0, [pc, #12]	; (16d30 <Ssp::SetPeripheralMode(SspInterface::MasterSlaveMode, SspInterface::FrameMode, SspInterface::DataSize)+0x1fc>)
   16d24:	f7fc fb12 	bl	1334c <__cyg_profile_func_exit>
  }
   16d28:	bf00      	nop
   16d2a:	b018      	add	sp, #96	; 0x60
   16d2c:	bd70      	pop	{r4, r5, r6, pc}
   16d2e:	bf00      	nop
   16d30:	00016b35 	.word	0x00016b35
   16d34:	0001a83c 	.word	0x0001a83c
   16d38:	1000005c 	.word	0x1000005c
   16d3c:	0001851d 	.word	0x0001851d

00016d40 <Ssp::GetPeripheralMode()>:
  /// Gets the Peripheral modes from registers
  /// @return - returns a 16-bit value as follows: 0000_000x 0xx0_xxxx
  ///       MasterSlaveMode = 1-bit @ bit 8
  ///       FrameMode       = 2-bit @ bit 5
  ///       DataSize        = 4-bit @ bit 0
  uint16_t GetPeripheralMode() override
   16d40:	b570      	push	{r4, r5, r6, lr}
   16d42:	b096      	sub	sp, #88	; 0x58
   16d44:	4674      	mov	r4, lr
   16d46:	9001      	str	r0, [sp, #4]
   16d48:	4623      	mov	r3, r4
   16d4a:	4619      	mov	r1, r3
   16d4c:	4850      	ldr	r0, [pc, #320]	; (16e90 <Ssp::GetPeripheralMode()+0x150>)
   16d4e:	f7fc fae9 	bl	13324 <__cyg_profile_func_enter>
  {
    uint16_t return_val = 0;
   16d52:	2300      	movs	r3, #0
   16d54:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    uint32_t pssp       = util::Value(pssp_);
   16d58:	9b01      	ldr	r3, [sp, #4]
   16d5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16d5c:	4618      	mov	r0, r3
   16d5e:	f7f9 fe59 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16d62:	4603      	mov	r3, r0
   16d64:	9314      	str	r3, [sp, #80]	; 0x50
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   16d66:	9b01      	ldr	r3, [sp, #4]
   16d68:	1d18      	adds	r0, r3, #4
   16d6a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16d6c:	009b      	lsls	r3, r3, #2
   16d6e:	4a49      	ldr	r2, [pc, #292]	; (16e94 <Ssp::GetPeripheralMode()+0x154>)
   16d70:	4413      	add	r3, r2
   16d72:	4619      	mov	r1, r3
   16d74:	f7fa f980 	bl	11078 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val = static_cast<uint16_t>(
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   16d78:	4a47      	ldr	r2, [pc, #284]	; (16e98 <Ssp::GetPeripheralMode()+0x158>)
   16d7a:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16d7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16d80:	681b      	ldr	r3, [r3, #0]
   16d82:	9307      	str	r3, [sp, #28]
   16d84:	2300      	movs	r3, #0
   16d86:	9306      	str	r3, [sp, #24]
   16d88:	2304      	movs	r3, #4
   16d8a:	9305      	str	r3, [sp, #20]
   16d8c:	4623      	mov	r3, r4
   16d8e:	4619      	mov	r1, r3
   16d90:	4842      	ldr	r0, [pc, #264]	; (16e9c <Ssp::GetPeripheralMode()+0x15c>)
   16d92:	f7fc fac7 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16d96:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16d9a:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16d9c:	2320      	movs	r3, #32
   16d9e:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16da0:	9b05      	ldr	r3, [sp, #20]
   16da2:	f1c3 0320 	rsb	r3, r3, #32
   16da6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16daa:	fa22 f303 	lsr.w	r3, r2, r3
   16dae:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   16db0:	9a07      	ldr	r2, [sp, #28]
   16db2:	9b06      	ldr	r3, [sp, #24]
   16db4:	40da      	lsrs	r2, r3
   16db6:	9b02      	ldr	r3, [sp, #8]
   16db8:	ea02 0503 	and.w	r5, r2, r3
   16dbc:	4623      	mov	r3, r4
   16dbe:	4619      	mov	r1, r3
   16dc0:	4836      	ldr	r0, [pc, #216]	; (16e9c <Ssp::GetPeripheralMode()+0x15c>)
   16dc2:	f7fc fac3 	bl	1334c <__cyg_profile_func_exit>
   16dc6:	b2ad      	uxth	r5, r5
        ((bit::Extract(ssp_registers[pssp]->CR0, kFrameBit, 2)) << 5) +
   16dc8:	4a33      	ldr	r2, [pc, #204]	; (16e98 <Ssp::GetPeripheralMode()+0x158>)
   16dca:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16dcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16dd0:	681b      	ldr	r3, [r3, #0]
   16dd2:	930d      	str	r3, [sp, #52]	; 0x34
   16dd4:	2304      	movs	r3, #4
   16dd6:	930c      	str	r3, [sp, #48]	; 0x30
   16dd8:	2302      	movs	r3, #2
   16dda:	930b      	str	r3, [sp, #44]	; 0x2c
   16ddc:	4623      	mov	r3, r4
   16dde:	4619      	mov	r1, r3
   16de0:	482e      	ldr	r0, [pc, #184]	; (16e9c <Ssp::GetPeripheralMode()+0x15c>)
   16de2:	f7fc fa9f 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16de6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16dea:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16dec:	2320      	movs	r3, #32
   16dee:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16df0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16df2:	f1c3 0320 	rsb	r3, r3, #32
   16df6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16dfa:	fa22 f303 	lsr.w	r3, r2, r3
   16dfe:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   16e00:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   16e02:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   16e04:	40da      	lsrs	r2, r3
   16e06:	9b08      	ldr	r3, [sp, #32]
   16e08:	ea02 0603 	and.w	r6, r2, r3
   16e0c:	4623      	mov	r3, r4
   16e0e:	4619      	mov	r1, r3
   16e10:	4822      	ldr	r0, [pc, #136]	; (16e9c <Ssp::GetPeripheralMode()+0x15c>)
   16e12:	f7fc fa9b 	bl	1334c <__cyg_profile_func_exit>
   16e16:	b2b3      	uxth	r3, r6
   16e18:	015b      	lsls	r3, r3, #5
   16e1a:	b29b      	uxth	r3, r3
        (bit::Extract(ssp_registers[pssp]->CR0, kDataBit, 4)) +
   16e1c:	442b      	add	r3, r5
   16e1e:	b29d      	uxth	r5, r3
        ((bit::Extract(ssp_registers[pssp]->CR1, kMasterModeBit)) << 8));
   16e20:	4a1d      	ldr	r2, [pc, #116]	; (16e98 <Ssp::GetPeripheralMode()+0x158>)
   16e22:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16e24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16e28:	685b      	ldr	r3, [r3, #4]
   16e2a:	9313      	str	r3, [sp, #76]	; 0x4c
   16e2c:	2302      	movs	r3, #2
   16e2e:	9312      	str	r3, [sp, #72]	; 0x48
   16e30:	2301      	movs	r3, #1
   16e32:	9311      	str	r3, [sp, #68]	; 0x44
   16e34:	4623      	mov	r3, r4
   16e36:	4619      	mov	r1, r3
   16e38:	4818      	ldr	r0, [pc, #96]	; (16e9c <Ssp::GetPeripheralMode()+0x15c>)
   16e3a:	f7fc fa73 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16e3e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16e42:	9310      	str	r3, [sp, #64]	; 0x40
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16e44:	2320      	movs	r3, #32
   16e46:	930f      	str	r3, [sp, #60]	; 0x3c
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16e48:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16e4a:	f1c3 0320 	rsb	r3, r3, #32
   16e4e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16e52:	fa22 f303 	lsr.w	r3, r2, r3
   16e56:	930e      	str	r3, [sp, #56]	; 0x38
  return (target >> position) & mask;
   16e58:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   16e5a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16e5c:	40da      	lsrs	r2, r3
   16e5e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   16e60:	ea02 0603 	and.w	r6, r2, r3
   16e64:	4623      	mov	r3, r4
   16e66:	4619      	mov	r1, r3
   16e68:	480c      	ldr	r0, [pc, #48]	; (16e9c <Ssp::GetPeripheralMode()+0x15c>)
   16e6a:	f7fc fa6f 	bl	1334c <__cyg_profile_func_exit>
   16e6e:	b2b3      	uxth	r3, r6
   16e70:	021b      	lsls	r3, r3, #8
   16e72:	b29b      	uxth	r3, r3
    return_val = static_cast<uint16_t>(
   16e74:	442b      	add	r3, r5
   16e76:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    return return_val;
   16e7a:	f8bd 5056 	ldrh.w	r5, [sp, #86]	; 0x56
   16e7e:	4623      	mov	r3, r4
   16e80:	4619      	mov	r1, r3
   16e82:	4803      	ldr	r0, [pc, #12]	; (16e90 <Ssp::GetPeripheralMode()+0x150>)
   16e84:	f7fc fa62 	bl	1334c <__cyg_profile_func_exit>
   16e88:	462b      	mov	r3, r5
  }
   16e8a:	4618      	mov	r0, r3
   16e8c:	b016      	add	sp, #88	; 0x58
   16e8e:	bd70      	pop	{r4, r5, r6, pc}
   16e90:	00016d41 	.word	0x00016d41
   16e94:	0001a83c 	.word	0x0001a83c
   16e98:	1000005c 	.word	0x1000005c
   16e9c:	00018591 	.word	0x00018591

00016ea0 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)>:
  /// Sets the clock rate for the Peripheral
  /// @param polarity - maintain bus on clock 0=low or 1=high between frames
  /// @param phase - capture serial data on 0=first or 1=second clock cycle
  /// @param divider - see notes in SSP_Interface above
  /// @param prescaler - divides the PCLK, must be even value between 2-254
  void SetClock(bool polarity, bool phase, uint8_t divider,
   16ea0:	b570      	push	{r4, r5, r6, lr}
   16ea2:	b098      	sub	sp, #96	; 0x60
   16ea4:	4674      	mov	r4, lr
   16ea6:	9001      	str	r0, [sp, #4]
   16ea8:	4608      	mov	r0, r1
   16eaa:	4611      	mov	r1, r2
   16eac:	461a      	mov	r2, r3
   16eae:	4603      	mov	r3, r0
   16eb0:	f88d 3003 	strb.w	r3, [sp, #3]
   16eb4:	460b      	mov	r3, r1
   16eb6:	f88d 3002 	strb.w	r3, [sp, #2]
   16eba:	4613      	mov	r3, r2
   16ebc:	f88d 3001 	strb.w	r3, [sp, #1]
   16ec0:	4623      	mov	r3, r4
   16ec2:	4619      	mov	r1, r3
   16ec4:	486c      	ldr	r0, [pc, #432]	; (17078 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   16ec6:	f7fc fa2d 	bl	13324 <__cyg_profile_func_enter>
                uint8_t prescaler) override
  {
    uint32_t pssp = util::Value(pssp_);
   16eca:	9b01      	ldr	r3, [sp, #4]
   16ecc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   16ece:	4618      	mov	r0, r3
   16ed0:	f7f9 fda0 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   16ed4:	4603      	mov	r3, r0
   16ed6:	9317      	str	r3, [sp, #92]	; 0x5c
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   16ed8:	9b01      	ldr	r3, [sp, #4]
   16eda:	1d18      	adds	r0, r3, #4
   16edc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16ede:	009b      	lsls	r3, r3, #2
   16ee0:	4a66      	ldr	r2, [pc, #408]	; (1707c <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1dc>)
   16ee2:	4413      	add	r3, r2
   16ee4:	4619      	mov	r1, r3
   16ee6:	f7fa f8c7 	bl	11078 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>
    // first clear the appropriate registers
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, polarity, kPolarityBit, 1);
   16eea:	4a65      	ldr	r2, [pc, #404]	; (17080 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   16eec:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16eee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16ef2:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   16ef4:	4962      	ldr	r1, [pc, #392]	; (17080 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   16ef6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   16ef8:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   16efc:	9308      	str	r3, [sp, #32]
   16efe:	f89d 3003 	ldrb.w	r3, [sp, #3]
   16f02:	f88d 301f 	strb.w	r3, [sp, #31]
   16f06:	2306      	movs	r3, #6
   16f08:	9306      	str	r3, [sp, #24]
   16f0a:	2301      	movs	r3, #1
   16f0c:	9305      	str	r3, [sp, #20]
   16f0e:	4623      	mov	r3, r4
   16f10:	4619      	mov	r1, r3
   16f12:	485c      	ldr	r0, [pc, #368]	; (17084 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   16f14:	f7fc fa06 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16f18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16f1c:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16f1e:	2320      	movs	r3, #32
   16f20:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16f22:	9b05      	ldr	r3, [sp, #20]
   16f24:	f1c3 0320 	rsb	r3, r3, #32
   16f28:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16f2c:	fa22 f303 	lsr.w	r3, r2, r3
   16f30:	9302      	str	r3, [sp, #8]
  target &= ~(mask << position);
   16f32:	9a02      	ldr	r2, [sp, #8]
   16f34:	9b06      	ldr	r3, [sp, #24]
   16f36:	fa02 f303 	lsl.w	r3, r2, r3
   16f3a:	43db      	mvns	r3, r3
   16f3c:	9a08      	ldr	r2, [sp, #32]
   16f3e:	4013      	ands	r3, r2
   16f40:	9308      	str	r3, [sp, #32]
  target |= (value & mask) << position;
   16f42:	f89d 201f 	ldrb.w	r2, [sp, #31]
   16f46:	9b02      	ldr	r3, [sp, #8]
   16f48:	401a      	ands	r2, r3
   16f4a:	9b06      	ldr	r3, [sp, #24]
   16f4c:	fa02 f303 	lsl.w	r3, r2, r3
   16f50:	9a08      	ldr	r2, [sp, #32]
   16f52:	4313      	orrs	r3, r2
   16f54:	9308      	str	r3, [sp, #32]
  return target;
   16f56:	9e08      	ldr	r6, [sp, #32]
   16f58:	4623      	mov	r3, r4
   16f5a:	4619      	mov	r1, r3
   16f5c:	4849      	ldr	r0, [pc, #292]	; (17084 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   16f5e:	f7fc f9f5 	bl	1334c <__cyg_profile_func_exit>
   16f62:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, phase, kPhaseBit, 1);
   16f64:	4a46      	ldr	r2, [pc, #280]	; (17080 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   16f66:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16f68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16f6c:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   16f6e:	4944      	ldr	r1, [pc, #272]	; (17080 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   16f70:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   16f72:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   16f76:	930f      	str	r3, [sp, #60]	; 0x3c
   16f78:	f89d 3002 	ldrb.w	r3, [sp, #2]
   16f7c:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
   16f80:	2307      	movs	r3, #7
   16f82:	930d      	str	r3, [sp, #52]	; 0x34
   16f84:	2301      	movs	r3, #1
   16f86:	930c      	str	r3, [sp, #48]	; 0x30
   16f88:	4623      	mov	r3, r4
   16f8a:	4619      	mov	r1, r3
   16f8c:	483d      	ldr	r0, [pc, #244]	; (17084 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   16f8e:	f7fc f9c9 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   16f92:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16f96:	930b      	str	r3, [sp, #44]	; 0x2c
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   16f98:	2320      	movs	r3, #32
   16f9a:	930a      	str	r3, [sp, #40]	; 0x28
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   16f9c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   16f9e:	f1c3 0320 	rsb	r3, r3, #32
   16fa2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16fa6:	fa22 f303 	lsr.w	r3, r2, r3
   16faa:	9309      	str	r3, [sp, #36]	; 0x24
  target &= ~(mask << position);
   16fac:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16fae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16fb0:	fa02 f303 	lsl.w	r3, r2, r3
   16fb4:	43db      	mvns	r3, r3
   16fb6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16fb8:	4013      	ands	r3, r2
   16fba:	930f      	str	r3, [sp, #60]	; 0x3c
  target |= (value & mask) << position;
   16fbc:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   16fc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16fc2:	401a      	ands	r2, r3
   16fc4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16fc6:	fa02 f303 	lsl.w	r3, r2, r3
   16fca:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16fcc:	4313      	orrs	r3, r2
   16fce:	930f      	str	r3, [sp, #60]	; 0x3c
  return target;
   16fd0:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   16fd2:	4623      	mov	r3, r4
   16fd4:	4619      	mov	r1, r3
   16fd6:	482b      	ldr	r0, [pc, #172]	; (17084 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e4>)
   16fd8:	f7fc f9b8 	bl	1334c <__cyg_profile_func_exit>
   16fdc:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CR0 =
        bit::Insert(ssp_registers[pssp]->CR0, divider, kDividerBit, 8);
   16fde:	4a28      	ldr	r2, [pc, #160]	; (17080 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   16fe0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16fe2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16fe6:	681b      	ldr	r3, [r3, #0]
    ssp_registers[pssp]->CR0 =
   16fe8:	4925      	ldr	r1, [pc, #148]	; (17080 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   16fea:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   16fec:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
   16ff0:	9316      	str	r3, [sp, #88]	; 0x58
   16ff2:	f89d 3001 	ldrb.w	r3, [sp, #1]
   16ff6:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
   16ffa:	2308      	movs	r3, #8
   16ffc:	9314      	str	r3, [sp, #80]	; 0x50
   16ffe:	2308      	movs	r3, #8
   17000:	9313      	str	r3, [sp, #76]	; 0x4c
   17002:	4623      	mov	r3, r4
   17004:	4619      	mov	r1, r3
   17006:	4820      	ldr	r0, [pc, #128]	; (17088 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   17008:	f7fc f98c 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1700c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17010:	9312      	str	r3, [sp, #72]	; 0x48
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   17012:	2320      	movs	r3, #32
   17014:	9311      	str	r3, [sp, #68]	; 0x44
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   17016:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17018:	f1c3 0320 	rsb	r3, r3, #32
   1701c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17020:	fa22 f303 	lsr.w	r3, r2, r3
   17024:	9310      	str	r3, [sp, #64]	; 0x40
  target &= ~(mask << position);
   17026:	9a10      	ldr	r2, [sp, #64]	; 0x40
   17028:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1702a:	fa02 f303 	lsl.w	r3, r2, r3
   1702e:	43db      	mvns	r3, r3
   17030:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17032:	4013      	ands	r3, r2
   17034:	9316      	str	r3, [sp, #88]	; 0x58
  target |= (value & mask) << position;
   17036:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   1703a:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1703c:	401a      	ands	r2, r3
   1703e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17040:	fa02 f303 	lsl.w	r3, r2, r3
   17044:	9a16      	ldr	r2, [sp, #88]	; 0x58
   17046:	4313      	orrs	r3, r2
   17048:	9316      	str	r3, [sp, #88]	; 0x58
  return target;
   1704a:	9e16      	ldr	r6, [sp, #88]	; 0x58
   1704c:	4623      	mov	r3, r4
   1704e:	4619      	mov	r1, r3
   17050:	480d      	ldr	r0, [pc, #52]	; (17088 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e8>)
   17052:	f7fc f97b 	bl	1334c <__cyg_profile_func_exit>
   17056:	602e      	str	r6, [r5, #0]
    ssp_registers[pssp]->CPSR = prescaler;
   17058:	4a09      	ldr	r2, [pc, #36]	; (17080 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1e0>)
   1705a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1705c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17060:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   17064:	611a      	str	r2, [r3, #16]
   17066:	4623      	mov	r3, r4
   17068:	4619      	mov	r1, r3
   1706a:	4803      	ldr	r0, [pc, #12]	; (17078 <Ssp::SetClock(bool, bool, unsigned char, unsigned char)+0x1d8>)
   1706c:	f7fc f96e 	bl	1334c <__cyg_profile_func_exit>
  }
   17070:	bf00      	nop
   17072:	b018      	add	sp, #96	; 0x60
   17074:	bd70      	pop	{r4, r5, r6, pc}
   17076:	bf00      	nop
   17078:	00016ea1 	.word	0x00016ea1
   1707c:	0001a83c 	.word	0x0001a83c
   17080:	1000005c 	.word	0x1000005c
   17084:	000185e5 	.word	0x000185e5
   17088:	0001851d 	.word	0x0001851d

0001708c <Ssp::GetClock()>:
  ///   0000_0000 0000_0x0x xxxx_xxxx xxxx_xxxx
  ///       polarity    = 1-bit @ bit 18
  ///       phase       = 1-bit @ bit 16
  ///       divider     = 8-bits @ bit 8
  ///       prescaler   = 8-bits @ bit 0
  uint32_t GetClock() override
   1708c:	b570      	push	{r4, r5, r6, lr}
   1708e:	b094      	sub	sp, #80	; 0x50
   17090:	4674      	mov	r4, lr
   17092:	9001      	str	r0, [sp, #4]
   17094:	4623      	mov	r3, r4
   17096:	4619      	mov	r1, r3
   17098:	4858      	ldr	r0, [pc, #352]	; (171fc <Ssp::GetClock()+0x170>)
   1709a:	f7fc f943 	bl	13324 <__cyg_profile_func_enter>
  {
    uint32_t return_val = 0;
   1709e:	2300      	movs	r3, #0
   170a0:	9313      	str	r3, [sp, #76]	; 0x4c
    uint32_t pssp       = util::Value(pssp_);
   170a2:	9b01      	ldr	r3, [sp, #4]
   170a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   170a6:	4618      	mov	r0, r3
   170a8:	f7f9 fcb4 	bl	10a14 <int util::Value<Ssp::Peripheral, int>(Ssp::Peripheral)>
   170ac:	4603      	mov	r3, r0
   170ae:	9312      	str	r3, [sp, #72]	; 0x48
    // TODO(#371): Find a better alternative to powering up the peripheral for
    // every method.
    Ssp::PowerUpPeripheral(Ssp::kPowerBit[pssp]);
   170b0:	9b01      	ldr	r3, [sp, #4]
   170b2:	1d18      	adds	r0, r3, #4
   170b4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   170b6:	009b      	lsls	r3, r3, #2
   170b8:	4a51      	ldr	r2, [pc, #324]	; (17200 <Ssp::GetClock()+0x174>)
   170ba:	4413      	add	r3, r2
   170bc:	4619      	mov	r1, r3
   170be:	f7f9 ffdb 	bl	11078 <Lpc40xxSystemController::PowerUpPeripheral(SystemControllerInterface::PeripheralID const&)>

    return_val =
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   170c2:	4a50      	ldr	r2, [pc, #320]	; (17204 <Ssp::GetClock()+0x178>)
   170c4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   170c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   170ca:	691b      	ldr	r3, [r3, #16]
   170cc:	9307      	str	r3, [sp, #28]
   170ce:	2300      	movs	r3, #0
   170d0:	9306      	str	r3, [sp, #24]
   170d2:	2308      	movs	r3, #8
   170d4:	9305      	str	r3, [sp, #20]
   170d6:	4623      	mov	r3, r4
   170d8:	4619      	mov	r1, r3
   170da:	484b      	ldr	r0, [pc, #300]	; (17208 <Ssp::GetClock()+0x17c>)
   170dc:	f7fc f922 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   170e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   170e4:	9304      	str	r3, [sp, #16]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   170e6:	2320      	movs	r3, #32
   170e8:	9303      	str	r3, [sp, #12]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   170ea:	9b05      	ldr	r3, [sp, #20]
   170ec:	f1c3 0320 	rsb	r3, r3, #32
   170f0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   170f4:	fa22 f303 	lsr.w	r3, r2, r3
   170f8:	9302      	str	r3, [sp, #8]
  return (target >> position) & mask;
   170fa:	9a07      	ldr	r2, [sp, #28]
   170fc:	9b06      	ldr	r3, [sp, #24]
   170fe:	40da      	lsrs	r2, r3
   17100:	9b02      	ldr	r3, [sp, #8]
   17102:	ea02 0503 	and.w	r5, r2, r3
   17106:	4623      	mov	r3, r4
   17108:	4619      	mov	r1, r3
   1710a:	483f      	ldr	r0, [pc, #252]	; (17208 <Ssp::GetClock()+0x17c>)
   1710c:	f7fc f91e 	bl	1334c <__cyg_profile_func_exit>
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   17110:	4a3c      	ldr	r2, [pc, #240]	; (17204 <Ssp::GetClock()+0x178>)
   17112:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17114:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   17118:	681b      	ldr	r3, [r3, #0]
   1711a:	930d      	str	r3, [sp, #52]	; 0x34
   1711c:	2308      	movs	r3, #8
   1711e:	930c      	str	r3, [sp, #48]	; 0x30
   17120:	2308      	movs	r3, #8
   17122:	930b      	str	r3, [sp, #44]	; 0x2c
   17124:	4623      	mov	r3, r4
   17126:	4619      	mov	r1, r3
   17128:	4837      	ldr	r0, [pc, #220]	; (17208 <Ssp::GetClock()+0x17c>)
   1712a:	f7fc f8fb 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   1712e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   17132:	930a      	str	r3, [sp, #40]	; 0x28
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   17134:	2320      	movs	r3, #32
   17136:	9309      	str	r3, [sp, #36]	; 0x24
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   17138:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1713a:	f1c3 0320 	rsb	r3, r3, #32
   1713e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17142:	fa22 f303 	lsr.w	r3, r2, r3
   17146:	9308      	str	r3, [sp, #32]
  return (target >> position) & mask;
   17148:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1714a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1714c:	40da      	lsrs	r2, r3
   1714e:	9b08      	ldr	r3, [sp, #32]
   17150:	ea02 0603 	and.w	r6, r2, r3
   17154:	4623      	mov	r3, r4
   17156:	4619      	mov	r1, r3
   17158:	482b      	ldr	r0, [pc, #172]	; (17208 <Ssp::GetClock()+0x17c>)
   1715a:	f7fc f8f7 	bl	1334c <__cyg_profile_func_exit>
   1715e:	0233      	lsls	r3, r6, #8
        (bit::Extract(ssp_registers[pssp]->CPSR, kPrescalerBit, 8)) +
   17160:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPhaseBit)) << 16) +
   17162:	4a28      	ldr	r2, [pc, #160]	; (17204 <Ssp::GetClock()+0x178>)
   17164:	9b12      	ldr	r3, [sp, #72]	; 0x48
   17166:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1716a:	681b      	ldr	r3, [r3, #0]
   1716c:	930f      	str	r3, [sp, #60]	; 0x3c
   1716e:	2307      	movs	r3, #7
   17170:	930e      	str	r3, [sp, #56]	; 0x38
   17172:	4623      	mov	r3, r4
   17174:	4619      	mov	r1, r3
   17176:	4825      	ldr	r0, [pc, #148]	; (1720c <Ssp::GetClock()+0x180>)
   17178:	f7fc f8d4 	bl	13324 <__cyg_profile_func_enter>
  return static_cast<bool>(target & (1 << position));
   1717c:	2201      	movs	r2, #1
   1717e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   17180:	fa02 f303 	lsl.w	r3, r2, r3
   17184:	461a      	mov	r2, r3
   17186:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   17188:	4013      	ands	r3, r2
   1718a:	2b00      	cmp	r3, #0
   1718c:	bf14      	ite	ne
   1718e:	2301      	movne	r3, #1
   17190:	2300      	moveq	r3, #0
   17192:	b2de      	uxtb	r6, r3
   17194:	4623      	mov	r3, r4
   17196:	4619      	mov	r1, r3
   17198:	481c      	ldr	r0, [pc, #112]	; (1720c <Ssp::GetClock()+0x180>)
   1719a:	f7fc f8d7 	bl	1334c <__cyg_profile_func_exit>
   1719e:	4633      	mov	r3, r6
   171a0:	041b      	lsls	r3, r3, #16
        ((bit::Extract(ssp_registers[pssp]->CR0, kDividerBit, 8)) << 8) +
   171a2:	441d      	add	r5, r3
        ((bit::Read(ssp_registers[pssp]->CR0, kPolarityBit)) << 18);
   171a4:	4a17      	ldr	r2, [pc, #92]	; (17204 <Ssp::GetClock()+0x178>)
   171a6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   171a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   171ac:	681b      	ldr	r3, [r3, #0]
   171ae:	9311      	str	r3, [sp, #68]	; 0x44
   171b0:	2306      	movs	r3, #6
   171b2:	9310      	str	r3, [sp, #64]	; 0x40
   171b4:	4623      	mov	r3, r4
   171b6:	4619      	mov	r1, r3
   171b8:	4814      	ldr	r0, [pc, #80]	; (1720c <Ssp::GetClock()+0x180>)
   171ba:	f7fc f8b3 	bl	13324 <__cyg_profile_func_enter>
   171be:	2201      	movs	r2, #1
   171c0:	9b10      	ldr	r3, [sp, #64]	; 0x40
   171c2:	fa02 f303 	lsl.w	r3, r2, r3
   171c6:	461a      	mov	r2, r3
   171c8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   171ca:	4013      	ands	r3, r2
   171cc:	2b00      	cmp	r3, #0
   171ce:	bf14      	ite	ne
   171d0:	2301      	movne	r3, #1
   171d2:	2300      	moveq	r3, #0
   171d4:	b2de      	uxtb	r6, r3
   171d6:	4623      	mov	r3, r4
   171d8:	4619      	mov	r1, r3
   171da:	480c      	ldr	r0, [pc, #48]	; (1720c <Ssp::GetClock()+0x180>)
   171dc:	f7fc f8b6 	bl	1334c <__cyg_profile_func_exit>
   171e0:	4633      	mov	r3, r6
   171e2:	049b      	lsls	r3, r3, #18
    return_val =
   171e4:	442b      	add	r3, r5
   171e6:	9313      	str	r3, [sp, #76]	; 0x4c

    return return_val;
   171e8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   171ea:	4623      	mov	r3, r4
   171ec:	4619      	mov	r1, r3
   171ee:	4803      	ldr	r0, [pc, #12]	; (171fc <Ssp::GetClock()+0x170>)
   171f0:	f7fc f8ac 	bl	1334c <__cyg_profile_func_exit>
   171f4:	462b      	mov	r3, r5
  }
   171f6:	4618      	mov	r0, r3
   171f8:	b014      	add	sp, #80	; 0x50
   171fa:	bd70      	pop	{r4, r5, r6, pc}
   171fc:	0001708d 	.word	0x0001708d
   17200:	0001a83c 	.word	0x0001a83c
   17204:	1000005c 	.word	0x1000005c
   17208:	00018591 	.word	0x00018591
   1720c:	00010d35 	.word	0x00010d35

00017210 <SdInterface::SdInterface()>:
// NOLINTNEXTLINE(readability-identifier-naming)
// Relevant Datasheet:
// https://www.sdcard.org/downloads/pls/pdf/index.php?p=Part1_Physical_Layer_Simplified_Specification_Ver6.00.jpg&f=Part1_Physical_Layer_Simplified_Specification_Ver6.00.pdf&e=EN_SS1
// TODO(#348):  Write a class to represent a single Sd Card Block to make use
//              of block-related functions easier.
class SdInterface
   17210:	b530      	push	{r4, r5, lr}
   17212:	b083      	sub	sp, #12
   17214:	4675      	mov	r5, lr
   17216:	9001      	str	r0, [sp, #4]
   17218:	462b      	mov	r3, r5
   1721a:	4619      	mov	r1, r3
   1721c:	4807      	ldr	r0, [pc, #28]	; (1723c <SdInterface::SdInterface()+0x2c>)
   1721e:	f7fc f881 	bl	13324 <__cyg_profile_func_enter>
   17222:	4a07      	ldr	r2, [pc, #28]	; (17240 <SdInterface::SdInterface()+0x30>)
   17224:	9b01      	ldr	r3, [sp, #4]
   17226:	601a      	str	r2, [r3, #0]
   17228:	9c01      	ldr	r4, [sp, #4]
   1722a:	462b      	mov	r3, r5
   1722c:	4619      	mov	r1, r3
   1722e:	4803      	ldr	r0, [pc, #12]	; (1723c <SdInterface::SdInterface()+0x2c>)
   17230:	f7fc f88c 	bl	1334c <__cyg_profile_func_exit>
   17234:	4623      	mov	r3, r4
   17236:	4618      	mov	r0, r3
   17238:	b003      	add	sp, #12
   1723a:	bd30      	pop	{r4, r5, pc}
   1723c:	00017211 	.word	0x00017211
   17240:	0001ac14 	.word	0x0001ac14

00017244 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>:
  /// port that is broken out through the board's GPIO, allowing you to probe
  /// the chip select manually. To use this version instead of the main version,
  /// instantiate an Sd card instance like so:
  ///
  ///   Sd sdcard(Sd::DebugSdCard_t{});
  constexpr Sd(DebugSdCard_t, uint8_t port = 1, uint8_t pin = 8,
   17244:	b530      	push	{r4, r5, lr}
   17246:	b083      	sub	sp, #12
   17248:	4675      	mov	r5, lr
   1724a:	9001      	str	r0, [sp, #4]
   1724c:	f88d 1000 	strb.w	r1, [sp]
   17250:	4611      	mov	r1, r2
   17252:	461a      	mov	r2, r3
   17254:	460b      	mov	r3, r1
   17256:	f88d 3003 	strb.w	r3, [sp, #3]
   1725a:	4613      	mov	r3, r2
   1725c:	f88d 3002 	strb.w	r3, [sp, #2]
   17260:	462b      	mov	r3, r5
   17262:	4619      	mov	r1, r3
   17264:	481d      	ldr	r0, [pc, #116]	; (172dc <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   17266:	f7fc f85d 	bl	13324 <__cyg_profile_func_enter>
      : ssp_interface_(&ssp_),
        ssp_(Ssp::Peripheral::kSsp2),
        chip_select_(&chip_select_pin_),
        chip_select_external_(&chip_select_external_pin_),
        chip_select_pin_(port, pin),
        chip_select_external_pin_(extport, extpin)
   1726a:	9b01      	ldr	r3, [sp, #4]
   1726c:	4618      	mov	r0, r3
   1726e:	f7ff ffcf 	bl	17210 <SdInterface::SdInterface()>
   17272:	4a1b      	ldr	r2, [pc, #108]	; (172e0 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x9c>)
   17274:	9b01      	ldr	r3, [sp, #4]
   17276:	601a      	str	r2, [r3, #0]
   17278:	9b01      	ldr	r3, [sp, #4]
   1727a:	f103 0208 	add.w	r2, r3, #8
   1727e:	9b01      	ldr	r3, [sp, #4]
   17280:	605a      	str	r2, [r3, #4]
   17282:	9b01      	ldr	r3, [sp, #4]
   17284:	3308      	adds	r3, #8
   17286:	2102      	movs	r1, #2
   17288:	4618      	mov	r0, r3
   1728a:	f7ff faf9 	bl	16880 <Ssp::Ssp(Ssp::Peripheral)>
   1728e:	9b01      	ldr	r3, [sp, #4]
   17290:	f103 0240 	add.w	r2, r3, #64	; 0x40
   17294:	9b01      	ldr	r3, [sp, #4]
   17296:	639a      	str	r2, [r3, #56]	; 0x38
   17298:	9b01      	ldr	r3, [sp, #4]
   1729a:	f103 0254 	add.w	r2, r3, #84	; 0x54
   1729e:	9b01      	ldr	r3, [sp, #4]
   172a0:	63da      	str	r2, [r3, #60]	; 0x3c
   172a2:	9b01      	ldr	r3, [sp, #4]
   172a4:	3340      	adds	r3, #64	; 0x40
   172a6:	f89d 2002 	ldrb.w	r2, [sp, #2]
   172aa:	f89d 1003 	ldrb.w	r1, [sp, #3]
   172ae:	4618      	mov	r0, r3
   172b0:	f7fe fe5a 	bl	15f68 <Gpio::Gpio(unsigned char, unsigned char)>
   172b4:	9b01      	ldr	r3, [sp, #4]
   172b6:	3354      	adds	r3, #84	; 0x54
   172b8:	f89d 201c 	ldrb.w	r2, [sp, #28]
   172bc:	f89d 1018 	ldrb.w	r1, [sp, #24]
   172c0:	4618      	mov	r0, r3
   172c2:	f7fe fe51 	bl	15f68 <Gpio::Gpio(unsigned char, unsigned char)>
  {
  }
   172c6:	9c01      	ldr	r4, [sp, #4]
   172c8:	462b      	mov	r3, r5
   172ca:	4619      	mov	r1, r3
   172cc:	4803      	ldr	r0, [pc, #12]	; (172dc <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)+0x98>)
   172ce:	f7fc f83d 	bl	1334c <__cyg_profile_func_exit>
   172d2:	4623      	mov	r3, r4
   172d4:	4618      	mov	r0, r3
   172d6:	b003      	add	sp, #12
   172d8:	bd30      	pop	{r4, r5, pc}
   172da:	bf00      	nop
   172dc:	00017245 	.word	0x00017245
   172e0:	0001abe8 	.word	0x0001abe8

000172e4 <Sd::Initialize()>:

  void Initialize() override
   172e4:	b530      	push	{r4, r5, lr}
   172e6:	b085      	sub	sp, #20
   172e8:	4675      	mov	r5, lr
   172ea:	9003      	str	r0, [sp, #12]
   172ec:	462b      	mov	r3, r5
   172ee:	4619      	mov	r1, r3
   172f0:	4827      	ldr	r0, [pc, #156]	; (17390 <Sd::Initialize()+0xac>)
   172f2:	f7fc f817 	bl	13324 <__cyg_profile_func_enter>
  {
    LOG_DEBUG("Begin initialization:");
    LOG_DEBUG("Setting CS as output...");
    chip_select_->SetAsOutput();
   172f6:	9b03      	ldr	r3, [sp, #12]
   172f8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   172fa:	9b03      	ldr	r3, [sp, #12]
   172fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   172fe:	681b      	ldr	r3, [r3, #0]
   17300:	3304      	adds	r3, #4
   17302:	681b      	ldr	r3, [r3, #0]
   17304:	4610      	mov	r0, r2
   17306:	4798      	blx	r3
    chip_select_->SetHigh();
   17308:	9b03      	ldr	r3, [sp, #12]
   1730a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   1730c:	9b03      	ldr	r3, [sp, #12]
   1730e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   17310:	681b      	ldr	r3, [r3, #0]
   17312:	330c      	adds	r3, #12
   17314:	681b      	ldr	r3, [r3, #0]
   17316:	4610      	mov	r0, r2
   17318:	4798      	blx	r3
    chip_select_external_->SetAsOutput();
   1731a:	9b03      	ldr	r3, [sp, #12]
   1731c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   1731e:	9b03      	ldr	r3, [sp, #12]
   17320:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   17322:	681b      	ldr	r3, [r3, #0]
   17324:	3304      	adds	r3, #4
   17326:	681b      	ldr	r3, [r3, #0]
   17328:	4610      	mov	r0, r2
   1732a:	4798      	blx	r3
    chip_select_external_->SetHigh();
   1732c:	9b03      	ldr	r3, [sp, #12]
   1732e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   17330:	9b03      	ldr	r3, [sp, #12]
   17332:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   17334:	681b      	ldr	r3, [r3, #0]
   17336:	330c      	adds	r3, #12
   17338:	681b      	ldr	r3, [r3, #0]
   1733a:	4610      	mov	r0, r2
   1733c:	4798      	blx	r3

    LOG_DEBUG("Setting SSP Clock Speed...");
    ssp_interface_->SetClock(false, false, 14, 2);  // 400kHz
   1733e:	9b03      	ldr	r3, [sp, #12]
   17340:	6858      	ldr	r0, [r3, #4]
   17342:	9b03      	ldr	r3, [sp, #12]
   17344:	685b      	ldr	r3, [r3, #4]
   17346:	681b      	ldr	r3, [r3, #0]
   17348:	3318      	adds	r3, #24
   1734a:	681c      	ldr	r4, [r3, #0]
   1734c:	2302      	movs	r3, #2
   1734e:	9300      	str	r3, [sp, #0]
   17350:	230e      	movs	r3, #14
   17352:	2200      	movs	r2, #0
   17354:	2100      	movs	r1, #0
   17356:	47a0      	blx	r4

    LOG_DEBUG("Setting Peripheral Mode...");
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   17358:	9b03      	ldr	r3, [sp, #12]
   1735a:	6858      	ldr	r0, [r3, #4]
   1735c:	9b03      	ldr	r3, [sp, #12]
   1735e:	685b      	ldr	r3, [r3, #4]
                                      Ssp::FrameMode::kSpi,
                                      Ssp::DataSize::kEight);
   17360:	681b      	ldr	r3, [r3, #0]
   17362:	3310      	adds	r3, #16
   17364:	681c      	ldr	r4, [r3, #0]
    ssp_interface_->SetPeripheralMode(Ssp::MasterSlaveMode::kMaster,
   17366:	2307      	movs	r3, #7
   17368:	2200      	movs	r2, #0
   1736a:	2100      	movs	r1, #0
   1736c:	47a0      	blx	r4

    LOG_DEBUG("Starting SSP Peripheral...");
    ssp_interface_->Initialize();
   1736e:	9b03      	ldr	r3, [sp, #12]
   17370:	685a      	ldr	r2, [r3, #4]
   17372:	9b03      	ldr	r3, [sp, #12]
   17374:	685b      	ldr	r3, [r3, #4]
   17376:	681b      	ldr	r3, [r3, #0]
   17378:	681b      	ldr	r3, [r3, #0]
   1737a:	4610      	mov	r0, r2
   1737c:	4798      	blx	r3
   1737e:	462b      	mov	r3, r5
   17380:	4619      	mov	r1, r3
   17382:	4803      	ldr	r0, [pc, #12]	; (17390 <Sd::Initialize()+0xac>)
   17384:	f7fb ffe2 	bl	1334c <__cyg_profile_func_exit>
  }
   17388:	bf00      	nop
   1738a:	b005      	add	sp, #20
   1738c:	bd30      	pop	{r4, r5, pc}
   1738e:	bf00      	nop
   17390:	000172e5 	.word	0x000172e5

00017394 <Sd::Mount(SdInterface::CardInfo_t*)>:

  // Initialize SD Card
  // TODO(#349): Split method into smaller piece with single jobs
  bool Mount(CardInfo_t * sd) override
   17394:	b530      	push	{r4, r5, lr}
   17396:	b08b      	sub	sp, #44	; 0x2c
   17398:	4675      	mov	r5, lr
   1739a:	9003      	str	r0, [sp, #12]
   1739c:	9102      	str	r1, [sp, #8]
   1739e:	462b      	mov	r3, r5
   173a0:	4619      	mov	r1, r3
   173a2:	48a7      	ldr	r0, [pc, #668]	; (17640 <Sd::Mount(SdInterface::CardInfo_t*)+0x2ac>)
   173a4:	f7fb ffbe 	bl	13324 <__cyg_profile_func_enter>
  {
    uint8_t tries     = 0;
   173a8:	2300      	movs	r3, #0
   173aa:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    bool card_is_idle = false;
   173ae:	2300      	movs	r3, #0
   173b0:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26

    // Reset the card and force it to go to idle state at <400kHz with a
    // CMD0 + (active-low) CS
    LOG_DEBUG("Sending SD Card to Idle State...");
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   173b4:	9b03      	ldr	r3, [sp, #12]
   173b6:	681b      	ldr	r3, [r3, #0]
   173b8:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kReset, 0x00000000,
   173ba:	9b02      	ldr	r3, [sp, #8]
   173bc:	f103 0208 	add.w	r2, r3, #8
   173c0:	2301      	movs	r3, #1
   173c2:	9301      	str	r3, [sp, #4]
   173c4:	2364      	movs	r3, #100	; 0x64
   173c6:	9300      	str	r3, [sp, #0]
   173c8:	4613      	mov	r3, r2
   173ca:	2200      	movs	r2, #0
   173cc:	2140      	movs	r1, #64	; 0x40
   173ce:	9803      	ldr	r0, [sp, #12]
   173d0:	47a0      	blx	r4
   173d2:	4602      	mov	r2, r0
   173d4:	9b02      	ldr	r3, [sp, #8]
   173d6:	611a      	str	r2, [r3, #16]

    // Reset the card again to trigger SPI mode
    LOG_DEBUG("Initializing SPI mode...");
    do
    {
      tries++;
   173d8:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   173dc:	3301      	adds	r3, #1
   173de:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
      sd->response.length = SendCmd(
          Command::kReset, 0x00, sd->response.data.byte, 100, KeepAlive::kYes);
   173e2:	9b03      	ldr	r3, [sp, #12]
   173e4:	681b      	ldr	r3, [r3, #0]
   173e6:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(
   173e8:	9b02      	ldr	r3, [sp, #8]
   173ea:	f103 0208 	add.w	r2, r3, #8
   173ee:	2301      	movs	r3, #1
   173f0:	9301      	str	r3, [sp, #4]
   173f2:	2364      	movs	r3, #100	; 0x64
   173f4:	9300      	str	r3, [sp, #0]
   173f6:	4613      	mov	r3, r2
   173f8:	2200      	movs	r2, #0
   173fa:	2140      	movs	r1, #64	; 0x40
   173fc:	9803      	ldr	r0, [sp, #12]
   173fe:	47a0      	blx	r4
   17400:	4602      	mov	r2, r0
   17402:	9b02      	ldr	r3, [sp, #8]
   17404:	611a      	str	r2, [r3, #16]

      // Check if R1 response frame's bit 1 is set (to ensure that
      // card is in idle state)
      if (sd->response.data.byte[0] != 0xFF &&
   17406:	9b02      	ldr	r3, [sp, #8]
   17408:	7a1b      	ldrb	r3, [r3, #8]
   1740a:	2bff      	cmp	r3, #255	; 0xff
   1740c:	d008      	beq.n	17420 <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
          (sd->response.data.byte[0] & 0x01) == 0x01)
   1740e:	9b02      	ldr	r3, [sp, #8]
   17410:	7a1b      	ldrb	r3, [r3, #8]
   17412:	f003 0301 	and.w	r3, r3, #1
      if (sd->response.data.byte[0] != 0xFF &&
   17416:	2b00      	cmp	r3, #0
   17418:	d002      	beq.n	17420 <Sd::Mount(SdInterface::CardInfo_t*)+0x8c>
      {
        // If it is, we can move on; otherwise, keep trying for a set
        // amount of tries
        card_is_idle = true;
   1741a:	2301      	movs	r3, #1
   1741c:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
      }
      Delay(10);
   17420:	f04f 000a 	mov.w	r0, #10
   17424:	f04f 0100 	mov.w	r1, #0
   17428:	f7f9 fa56 	bl	108d8 <Delay(unsigned long long)>
    } while (tries < kBusTimeout && !card_is_idle);
   1742c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17430:	2bf9      	cmp	r3, #249	; 0xf9
   17432:	d804      	bhi.n	1743e <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
   17434:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   17438:	2b00      	cmp	r3, #0
   1743a:	d100      	bne.n	1743e <Sd::Mount(SdInterface::CardInfo_t*)+0xaa>
    do
   1743c:	e7cc      	b.n	173d8 <Sd::Mount(SdInterface::CardInfo_t*)+0x44>
    LOG_DEBUG("%d tries", tries);
    if (tries >= kBusTimeout)
   1743e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17442:	2bf9      	cmp	r3, #249	; 0xf9
   17444:	d91b      	bls.n	1747e <Sd::Mount(SdInterface::CardInfo_t*)+0xea>
    {
      LOG_ERROR("Failed to initiate SPI mode within timeout. Aborting!");
   17446:	f240 13ff 	movw	r3, #511	; 0x1ff
   1744a:	4a7e      	ldr	r2, [pc, #504]	; (17644 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   1744c:	497e      	ldr	r1, [pc, #504]	; (17648 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b4>)
   1744e:	487f      	ldr	r0, [pc, #508]	; (1764c <Sd::Mount(SdInterface::CardInfo_t*)+0x2b8>)
   17450:	f7fe fd04 	bl	15e5c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17454:	9b03      	ldr	r3, [sp, #12]
   17456:	681b      	ldr	r3, [r3, #0]
   17458:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   1745a:	9b02      	ldr	r3, [sp, #8]
   1745c:	f103 0208 	add.w	r2, r3, #8
   17460:	2300      	movs	r3, #0
   17462:	9301      	str	r3, [sp, #4]
   17464:	2300      	movs	r3, #0
   17466:	9300      	str	r3, [sp, #0]
   17468:	4613      	mov	r3, r2
   1746a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1746e:	21ff      	movs	r1, #255	; 0xff
   17470:	9803      	ldr	r0, [sp, #12]
   17472:	47a0      	blx	r4
   17474:	4602      	mov	r2, r0
   17476:	9b02      	ldr	r3, [sp, #8]
   17478:	611a      	str	r2, [r3, #16]
      return false;
   1747a:	2400      	movs	r4, #0
   1747c:	e10c      	b.n	17698 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Send the host's supported voltage (3.3V) and ask if the card
    // supports it
    LOG_DEBUG("Checking Current SD Card Voltage Level...");
    constexpr uint8_t kCheckPattern = 0xAB;
   1747e:	23ab      	movs	r3, #171	; 0xab
   17480:	f88d 301f 	strb.w	r3, [sp, #31]
    uint64_t supported_voltage      = 0x00000001;
   17484:	f04f 0301 	mov.w	r3, #1
   17488:	f04f 0400 	mov.w	r4, #0
   1748c:	e9cd 3404 	strd	r3, r4, [sp, #16]
    sd->response.length =
        SendCmd(Command::kGetOp,
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
                sd->response.data.byte, 100, KeepAlive::kYes);
   17490:	9b03      	ldr	r3, [sp, #12]
   17492:	681b      	ldr	r3, [r3, #0]
   17494:	681c      	ldr	r4, [r3, #0]
                static_cast<uint32_t>((supported_voltage << 8) | kCheckPattern),
   17496:	9b04      	ldr	r3, [sp, #16]
   17498:	021b      	lsls	r3, r3, #8
        SendCmd(Command::kGetOp,
   1749a:	f043 02ab 	orr.w	r2, r3, #171	; 0xab
   1749e:	9b02      	ldr	r3, [sp, #8]
   174a0:	f103 0108 	add.w	r1, r3, #8
   174a4:	2301      	movs	r3, #1
   174a6:	9301      	str	r3, [sp, #4]
   174a8:	2364      	movs	r3, #100	; 0x64
   174aa:	9300      	str	r3, [sp, #0]
   174ac:	460b      	mov	r3, r1
   174ae:	2148      	movs	r1, #72	; 0x48
   174b0:	9803      	ldr	r0, [sp, #12]
   174b2:	47a0      	blx	r4
   174b4:	4602      	mov	r2, r0
    sd->response.length =
   174b6:	9b02      	ldr	r3, [sp, #8]
   174b8:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[4] != kCheckPattern)
   174ba:	9b02      	ldr	r3, [sp, #8]
   174bc:	7b1b      	ldrb	r3, [r3, #12]
   174be:	2bab      	cmp	r3, #171	; 0xab
   174c0:	d01b      	beq.n	174fa <Sd::Mount(SdInterface::CardInfo_t*)+0x166>
    {
      // If the last byte is not an exact echo of the LSB of the kGetOp
      // command's argument, this response is invalid
      LOG_ERROR("Response integrity check failed. Aborting!");
   174c2:	f240 2312 	movw	r3, #530	; 0x212
   174c6:	4a5f      	ldr	r2, [pc, #380]	; (17644 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   174c8:	4961      	ldr	r1, [pc, #388]	; (17650 <Sd::Mount(SdInterface::CardInfo_t*)+0x2bc>)
   174ca:	4862      	ldr	r0, [pc, #392]	; (17654 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c0>)
   174cc:	f7fe fcc6 	bl	15e5c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   174d0:	9b03      	ldr	r3, [sp, #12]
   174d2:	681b      	ldr	r3, [r3, #0]
   174d4:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   174d6:	9b02      	ldr	r3, [sp, #8]
   174d8:	f103 0208 	add.w	r2, r3, #8
   174dc:	2300      	movs	r3, #0
   174de:	9301      	str	r3, [sp, #4]
   174e0:	2300      	movs	r3, #0
   174e2:	9300      	str	r3, [sp, #0]
   174e4:	4613      	mov	r3, r2
   174e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   174ea:	21ff      	movs	r1, #255	; 0xff
   174ec:	9803      	ldr	r0, [sp, #12]
   174ee:	47a0      	blx	r4
   174f0:	4602      	mov	r2, r0
   174f2:	9b02      	ldr	r3, [sp, #8]
   174f4:	611a      	str	r2, [r3, #16]
      return false;
   174f6:	2400      	movs	r4, #0
   174f8:	e0ce      	b.n	17698 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }
    else if (sd->response.data.byte[3] &
   174fa:	9b02      	ldr	r3, [sp, #8]
   174fc:	7adb      	ldrb	r3, [r3, #11]
   174fe:	4619      	mov	r1, r3
             (supported_voltage == static_cast<uint64_t>(0x00)))
   17500:	9a04      	ldr	r2, [sp, #16]
   17502:	9b05      	ldr	r3, [sp, #20]
   17504:	4313      	orrs	r3, r2
   17506:	2b00      	cmp	r3, #0
   17508:	bf0c      	ite	eq
   1750a:	2301      	moveq	r3, #1
   1750c:	2300      	movne	r3, #0
   1750e:	b2db      	uxtb	r3, r3
    else if (sd->response.data.byte[3] &
   17510:	400b      	ands	r3, r1
   17512:	2b00      	cmp	r3, #0
   17514:	d01b      	beq.n	1754e <Sd::Mount(SdInterface::CardInfo_t*)+0x1ba>
    {
      // If the 2nd-to-last byte of the reponse AND'ed with our host
      // device's supported voltage range is 0x00, the SD card doesn't
      // support our device's operating voltage
      LOG_ERROR("Unsupported voltage in use. Aborting!");
   17516:	f240 231d 	movw	r3, #541	; 0x21d
   1751a:	4a4a      	ldr	r2, [pc, #296]	; (17644 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   1751c:	494e      	ldr	r1, [pc, #312]	; (17658 <Sd::Mount(SdInterface::CardInfo_t*)+0x2c4>)
   1751e:	484f      	ldr	r0, [pc, #316]	; (1765c <Sd::Mount(SdInterface::CardInfo_t*)+0x2c8>)
   17520:	f7fe fc9c 	bl	15e5c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   17524:	9b03      	ldr	r3, [sp, #12]
   17526:	681b      	ldr	r3, [r3, #0]
   17528:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   1752a:	9b02      	ldr	r3, [sp, #8]
   1752c:	f103 0208 	add.w	r2, r3, #8
   17530:	2300      	movs	r3, #0
   17532:	9301      	str	r3, [sp, #4]
   17534:	2300      	movs	r3, #0
   17536:	9300      	str	r3, [sp, #0]
   17538:	4613      	mov	r3, r2
   1753a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1753e:	21ff      	movs	r1, #255	; 0xff
   17540:	9803      	ldr	r0, [sp, #12]
   17542:	47a0      	blx	r4
   17544:	4602      	mov	r2, r0
   17546:	9b02      	ldr	r3, [sp, #8]
   17548:	611a      	str	r2, [r3, #16]
      return false;
   1754a:	2400      	movs	r4, #0
   1754c:	e0a4      	b.n	17698 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    }

    // Indicate that the host supports SDHC/SDXC and wait for card to
    // shift out of idle state
    LOG_DEBUG("Expressing High-Capacity SD Card Support...");
    tries = 0;
   1754e:	2300      	movs	r3, #0
   17550:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    do
    {
      // Send host's operating conditions
      sd->response.length =
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
                  KeepAlive::kYes);
   17554:	9b03      	ldr	r3, [sp, #12]
   17556:	681b      	ldr	r3, [r3, #0]
   17558:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kInit, 0x40000000, sd->response.data.byte, 100,
   1755a:	9b02      	ldr	r3, [sp, #8]
   1755c:	f103 0208 	add.w	r2, r3, #8
   17560:	2301      	movs	r3, #1
   17562:	9301      	str	r3, [sp, #4]
   17564:	2364      	movs	r3, #100	; 0x64
   17566:	9300      	str	r3, [sp, #0]
   17568:	4613      	mov	r3, r2
   1756a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   1756e:	2141      	movs	r1, #65	; 0x41
   17570:	9803      	ldr	r0, [sp, #12]
   17572:	47a0      	blx	r4
   17574:	4602      	mov	r2, r0
      sd->response.length =
   17576:	9b02      	ldr	r3, [sp, #8]
   17578:	611a      	str	r2, [r3, #16]
      tries++;
   1757a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1757e:	3301      	adds	r3, #1
   17580:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    } while (tries < kBusTimeout && sd->response.data.byte[0] & 0x01);
   17584:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   17588:	2bf9      	cmp	r3, #249	; 0xf9
   1758a:	d806      	bhi.n	1759a <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
   1758c:	9b02      	ldr	r3, [sp, #8]
   1758e:	7a1b      	ldrb	r3, [r3, #8]
   17590:	f003 0301 	and.w	r3, r3, #1
   17594:	2b00      	cmp	r3, #0
   17596:	d000      	beq.n	1759a <Sd::Mount(SdInterface::CardInfo_t*)+0x206>
    do
   17598:	e7dc      	b.n	17554 <Sd::Mount(SdInterface::CardInfo_t*)+0x1c0>
    if (tries == kBusTimeout)
   1759a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   1759e:	2bfa      	cmp	r3, #250	; 0xfa
   175a0:	d11b      	bne.n	175da <Sd::Mount(SdInterface::CardInfo_t*)+0x246>
    {
      LOG_ERROR("SD Card timed out. Aborting!");
   175a2:	f240 2331 	movw	r3, #561	; 0x231
   175a6:	4a27      	ldr	r2, [pc, #156]	; (17644 <Sd::Mount(SdInterface::CardInfo_t*)+0x2b0>)
   175a8:	492d      	ldr	r1, [pc, #180]	; (17660 <Sd::Mount(SdInterface::CardInfo_t*)+0x2cc>)
   175aa:	482e      	ldr	r0, [pc, #184]	; (17664 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d0>)
   175ac:	f7fe fc56 	bl	15e5c <printf>
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
                                    sd->response.data.byte, 0, KeepAlive::kNo);
   175b0:	9b03      	ldr	r3, [sp, #12]
   175b2:	681b      	ldr	r3, [r3, #0]
   175b4:	681c      	ldr	r4, [r3, #0]
      sd->response.length = SendCmd(Command::kGarbage, 0xFFFFFFFF,
   175b6:	9b02      	ldr	r3, [sp, #8]
   175b8:	f103 0208 	add.w	r2, r3, #8
   175bc:	2300      	movs	r3, #0
   175be:	9301      	str	r3, [sp, #4]
   175c0:	2300      	movs	r3, #0
   175c2:	9300      	str	r3, [sp, #0]
   175c4:	4613      	mov	r3, r2
   175c6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   175ca:	21ff      	movs	r1, #255	; 0xff
   175cc:	9803      	ldr	r0, [sp, #12]
   175ce:	47a0      	blx	r4
   175d0:	4602      	mov	r2, r0
   175d2:	9b02      	ldr	r3, [sp, #8]
   175d4:	611a      	str	r2, [r3, #16]
      return false;
   175d6:	2400      	movs	r4, #0
   175d8:	e05e      	b.n	17698 <Sd::Mount(SdInterface::CardInfo_t*)+0x304>
    // After card is ready, acquire card capacity info using kGetOcr a
    // second time
    LOG_DEBUG("Reading Card Capacity Information...");
    // Read CCS
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
                                  sd->response.data.byte, 100, KeepAlive::kYes);
   175da:	9b03      	ldr	r3, [sp, #12]
   175dc:	681b      	ldr	r3, [r3, #0]
   175de:	681c      	ldr	r4, [r3, #0]
    sd->response.length = SendCmd(Command::kGetOcr, 0x00,
   175e0:	9b02      	ldr	r3, [sp, #8]
   175e2:	f103 0208 	add.w	r2, r3, #8
   175e6:	2301      	movs	r3, #1
   175e8:	9301      	str	r3, [sp, #4]
   175ea:	2364      	movs	r3, #100	; 0x64
   175ec:	9300      	str	r3, [sp, #0]
   175ee:	4613      	mov	r3, r2
   175f0:	2200      	movs	r2, #0
   175f2:	217a      	movs	r1, #122	; 0x7a
   175f4:	9803      	ldr	r0, [sp, #12]
   175f6:	47a0      	blx	r4
   175f8:	4602      	mov	r2, r0
   175fa:	9b02      	ldr	r3, [sp, #8]
   175fc:	611a      	str	r2, [r3, #16]
    if (sd->response.data.byte[1] & 0x40)
   175fe:	9b02      	ldr	r3, [sp, #8]
   17600:	7a5b      	ldrb	r3, [r3, #9]
   17602:	f003 0340 	and.w	r3, r3, #64	; 0x40
   17606:	2b00      	cmp	r3, #0
   17608:	d003      	beq.n	17612 <Sd::Mount(SdInterface::CardInfo_t*)+0x27e>
    {
      // The card is either high or extended capacity
      LOG_DEBUG("SD Card is HC/XC");
      sd->type = Type::kSDHC;
   1760a:	9b02      	ldr	r3, [sp, #8]
   1760c:	2201      	movs	r2, #1
   1760e:	605a      	str	r2, [r3, #4]
   17610:	e002      	b.n	17618 <Sd::Mount(SdInterface::CardInfo_t*)+0x284>
    }
    else
    {
      // The card is standard capacity
      LOG_DEBUG("SD Card is SC");
      sd->type = Type::kSDSC;
   17612:	9b02      	ldr	r3, [sp, #8]
   17614:	2200      	movs	r2, #0
   17616:	605a      	str	r2, [r3, #4]
    }

    // Store OCR information
    for (int i = 0; i < 4; i++)
   17618:	2300      	movs	r3, #0
   1761a:	9308      	str	r3, [sp, #32]
   1761c:	9b08      	ldr	r3, [sp, #32]
   1761e:	2b03      	cmp	r3, #3
   17620:	dc22      	bgt.n	17668 <Sd::Mount(SdInterface::CardInfo_t*)+0x2d4>
    {
      // ensure OCR doesn't capture the R1 section of the response
      sd->ocr.byte[i] = sd->response.data.byte[i + 1];
   17622:	9b08      	ldr	r3, [sp, #32]
   17624:	3301      	adds	r3, #1
   17626:	9a02      	ldr	r2, [sp, #8]
   17628:	4413      	add	r3, r2
   1762a:	7a19      	ldrb	r1, [r3, #8]
   1762c:	9a02      	ldr	r2, [sp, #8]
   1762e:	9b08      	ldr	r3, [sp, #32]
   17630:	4413      	add	r3, r2
   17632:	460a      	mov	r2, r1
   17634:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < 4; i++)
   17636:	9b08      	ldr	r3, [sp, #32]
   17638:	3301      	adds	r3, #1
   1763a:	9308      	str	r3, [sp, #32]
   1763c:	e7ee      	b.n	1761c <Sd::Mount(SdInterface::CardInfo_t*)+0x288>
   1763e:	bf00      	nop
   17640:	00017395 	.word	0x00017395
   17644:	0001ae30 	.word	0x0001ae30
   17648:	0001ab48 	.word	0x0001ab48
   1764c:	0001a160 	.word	0x0001a160
   17650:	0001ab50 	.word	0x0001ab50
   17654:	0001a1d0 	.word	0x0001a1d0
   17658:	0001ab58 	.word	0x0001ab58
   1765c:	0001a234 	.word	0x0001a234
   17660:	0001ab60 	.word	0x0001ab60
   17664:	0001a294 	.word	0x0001a294
    }

    // If card is SDSC, manually set its block size
    if (sd->type == Type::kSDSC)
   17668:	9b02      	ldr	r3, [sp, #8]
   1766a:	685b      	ldr	r3, [r3, #4]
   1766c:	2b00      	cmp	r3, #0
   1766e:	d112      	bne.n	17696 <Sd::Mount(SdInterface::CardInfo_t*)+0x302>
    {
      // Send requested byte size
      sd->response.length =
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
                  sd->response.data.byte, 0, KeepAlive::kYes);
   17670:	9b03      	ldr	r3, [sp, #12]
   17672:	681b      	ldr	r3, [r3, #0]
   17674:	681c      	ldr	r4, [r3, #0]
          SendCmd(Command::kChgBlkLen, static_cast<uint32_t>(kBlockSize),
   17676:	9b02      	ldr	r3, [sp, #8]
   17678:	f103 0208 	add.w	r2, r3, #8
   1767c:	2301      	movs	r3, #1
   1767e:	9301      	str	r3, [sp, #4]
   17680:	2300      	movs	r3, #0
   17682:	9300      	str	r3, [sp, #0]
   17684:	4613      	mov	r3, r2
   17686:	f44f 7200 	mov.w	r2, #512	; 0x200
   1768a:	2150      	movs	r1, #80	; 0x50
   1768c:	9803      	ldr	r0, [sp, #12]
   1768e:	47a0      	blx	r4
   17690:	4602      	mov	r2, r0
      sd->response.length =
   17692:	9b02      	ldr	r3, [sp, #8]
   17694:	611a      	str	r2, [r3, #16]
    }

    return true;
   17696:	2401      	movs	r4, #1
   17698:	462b      	mov	r3, r5
   1769a:	4619      	mov	r1, r3
   1769c:	4803      	ldr	r0, [pc, #12]	; (176ac <Sd::Mount(SdInterface::CardInfo_t*)+0x318>)
   1769e:	f7fb fe55 	bl	1334c <__cyg_profile_func_exit>
   176a2:	4623      	mov	r3, r4
  }
   176a4:	4618      	mov	r0, r3
   176a6:	b00b      	add	sp, #44	; 0x2c
   176a8:	bd30      	pop	{r4, r5, pc}
   176aa:	bf00      	nop
   176ac:	00017395 	.word	0x00017395

000176b0 <Sd::ToBool(bool)>:

  // Returns string to represent a boolean value
  const char * ToBool(bool condition)
   176b0:	b530      	push	{r4, r5, lr}
   176b2:	b083      	sub	sp, #12
   176b4:	4675      	mov	r5, lr
   176b6:	9001      	str	r0, [sp, #4]
   176b8:	460b      	mov	r3, r1
   176ba:	f88d 3003 	strb.w	r3, [sp, #3]
   176be:	462b      	mov	r3, r5
   176c0:	4619      	mov	r1, r3
   176c2:	4809      	ldr	r0, [pc, #36]	; (176e8 <Sd::ToBool(bool)+0x38>)
   176c4:	f7fb fe2e 	bl	13324 <__cyg_profile_func_enter>
  {
    return (condition) ? "true" : "false";
   176c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
   176cc:	2b00      	cmp	r3, #0
   176ce:	d001      	beq.n	176d4 <Sd::ToBool(bool)+0x24>
   176d0:	4c06      	ldr	r4, [pc, #24]	; (176ec <Sd::ToBool(bool)+0x3c>)
   176d2:	e000      	b.n	176d6 <Sd::ToBool(bool)+0x26>
   176d4:	4c06      	ldr	r4, [pc, #24]	; (176f0 <Sd::ToBool(bool)+0x40>)
   176d6:	462b      	mov	r3, r5
   176d8:	4619      	mov	r1, r3
   176da:	4803      	ldr	r0, [pc, #12]	; (176e8 <Sd::ToBool(bool)+0x38>)
   176dc:	f7fb fe36 	bl	1334c <__cyg_profile_func_exit>
   176e0:	4623      	mov	r3, r4
  }
   176e2:	4618      	mov	r0, r3
   176e4:	b003      	add	sp, #12
   176e6:	bd30      	pop	{r4, r5, pc}
   176e8:	000176b1 	.word	0x000176b1
   176ec:	0001a2ec 	.word	0x0001a2ec
   176f0:	0001a2f4 	.word	0x0001a2f4

000176f4 <Sd::WaitToReadBlock()>:

  // Waits for the card to respond after a single or multi block read cmd is
  // sent.
  void WaitToReadBlock()
   176f4:	b510      	push	{r4, lr}
   176f6:	b084      	sub	sp, #16
   176f8:	4674      	mov	r4, lr
   176fa:	9001      	str	r0, [sp, #4]
   176fc:	4623      	mov	r3, r4
   176fe:	4619      	mov	r1, r3
   17700:	4814      	ldr	r0, [pc, #80]	; (17754 <Sd::WaitToReadBlock()+0x60>)
   17702:	f7fb fe0f 	bl	13324 <__cyg_profile_func_enter>
    // Bit 4 -->  If set, card is locked
    // Bit 3 -->  If set, address is out or range
    // Bit 2 -->  If set, card ECC failed
    // Bit 1 -->  If set, CC error occurred
    // Bit 0 -->  If set, a generic error occurred
    uint8_t wait_byte = 0x00;
   17706:	2300      	movs	r3, #0
   17708:	f88d 300f 	strb.w	r3, [sp, #15]
    do
    {
      wait_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1770c:	9b01      	ldr	r3, [sp, #4]
   1770e:	685a      	ldr	r2, [r3, #4]
   17710:	9b01      	ldr	r3, [sp, #4]
   17712:	685b      	ldr	r3, [r3, #4]
   17714:	681b      	ldr	r3, [r3, #0]
   17716:	3308      	adds	r3, #8
   17718:	681b      	ldr	r3, [r3, #0]
   1771a:	21ff      	movs	r1, #255	; 0xff
   1771c:	4610      	mov	r0, r2
   1771e:	4798      	blx	r3
   17720:	4603      	mov	r3, r0
   17722:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (wait_byte != 0xFE && (wait_byte & 0xE0) != 0x00);
   17726:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1772a:	2bfe      	cmp	r3, #254	; 0xfe
   1772c:	d006      	beq.n	1773c <Sd::WaitToReadBlock()+0x48>
   1772e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   17732:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   17736:	2b00      	cmp	r3, #0
   17738:	d000      	beq.n	1773c <Sd::WaitToReadBlock()+0x48>
    do
   1773a:	e7e7      	b.n	1770c <Sd::WaitToReadBlock()+0x18>

    // DEBUG: Check the value of the wait byte
    if (wait_byte == 0xFE)
   1773c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   17740:	2bfe      	cmp	r3, #254	; 0xfe
   17742:	4623      	mov	r3, r4
   17744:	4619      	mov	r1, r3
   17746:	4803      	ldr	r0, [pc, #12]	; (17754 <Sd::WaitToReadBlock()+0x60>)
   17748:	f7fb fe00 	bl	1334c <__cyg_profile_func_exit>
      LOG_DEBUG("Addr Out of Range?: %s", ToBool(wait_byte & 0x08));
      LOG_DEBUG("Card ECC Failed?: %s", ToBool(wait_byte & 0x04));
      LOG_DEBUG("CC Error?: %s", ToBool(wait_byte & 0x02));
      LOG_DEBUG("Error?: %s", ToBool(wait_byte & 0x01));
    }
  }
   1774c:	bf00      	nop
   1774e:	b004      	add	sp, #16
   17750:	bd10      	pop	{r4, pc}
   17752:	bf00      	nop
   17754:	000176f5 	.word	0x000176f5

00017758 <Sd::WaitWhileBusy()>:

  // Waits for the card to be ready to receive a new block after one has
  // been written or erased
  void WaitWhileBusy()
   17758:	b510      	push	{r4, lr}
   1775a:	b084      	sub	sp, #16
   1775c:	4674      	mov	r4, lr
   1775e:	9001      	str	r0, [sp, #4]
   17760:	4623      	mov	r3, r4
   17762:	4619      	mov	r1, r3
   17764:	480f      	ldr	r0, [pc, #60]	; (177a4 <Sd::WaitWhileBusy()+0x4c>)
   17766:	f7fb fddd 	bl	13324 <__cyg_profile_func_enter>
  {
    // Wait for the card to finish programming (i.e. when the
    // bytes return to 0xFF)
    uint8_t busy_byte = 0x00;
   1776a:	2300      	movs	r3, #0
   1776c:	f88d 300f 	strb.w	r3, [sp, #15]
    LOG_DEBUG("Card is busy. Waiting for it to finish...");
    do
    {
      busy_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   17770:	9b01      	ldr	r3, [sp, #4]
   17772:	685a      	ldr	r2, [r3, #4]
   17774:	9b01      	ldr	r3, [sp, #4]
   17776:	685b      	ldr	r3, [r3, #4]
   17778:	681b      	ldr	r3, [r3, #0]
   1777a:	3308      	adds	r3, #8
   1777c:	681b      	ldr	r3, [r3, #0]
   1777e:	21ff      	movs	r1, #255	; 0xff
   17780:	4610      	mov	r0, r2
   17782:	4798      	blx	r3
   17784:	4603      	mov	r3, r0
   17786:	f88d 300f 	strb.w	r3, [sp, #15]
    } while (busy_byte != 0xFF);
   1778a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1778e:	2bff      	cmp	r3, #255	; 0xff
   17790:	d000      	beq.n	17794 <Sd::WaitWhileBusy()+0x3c>
    do
   17792:	e7ed      	b.n	17770 <Sd::WaitWhileBusy()+0x18>
   17794:	4623      	mov	r3, r4
   17796:	4619      	mov	r1, r3
   17798:	4802      	ldr	r0, [pc, #8]	; (177a4 <Sd::WaitWhileBusy()+0x4c>)
   1779a:	f7fb fdd7 	bl	1334c <__cyg_profile_func_exit>
    LOG_DEBUG("Card finished!");
  }
   1779e:	bf00      	nop
   177a0:	b004      	add	sp, #16
   177a2:	bd10      	pop	{r4, pc}
   177a4:	00017759 	.word	0x00017759

000177a8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)>:

  // Read any number of blocks from the SD card
  uint8_t ReadBlock(uint32_t address, uint8_t * array,
   177a8:	b530      	push	{r4, r5, lr}
   177aa:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
   177ae:	4675      	mov	r5, lr
   177b0:	ac05      	add	r4, sp, #20
   177b2:	6020      	str	r0, [r4, #0]
   177b4:	a804      	add	r0, sp, #16
   177b6:	6001      	str	r1, [r0, #0]
   177b8:	a903      	add	r1, sp, #12
   177ba:	600a      	str	r2, [r1, #0]
   177bc:	aa02      	add	r2, sp, #8
   177be:	6013      	str	r3, [r2, #0]
   177c0:	462b      	mov	r3, r5
   177c2:	4619      	mov	r1, r3
   177c4:	487d      	ldr	r0, [pc, #500]	; (179bc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x214>)
   177c6:	f7fb fdad 	bl	13324 <__cyg_profile_func_enter>
                    uint32_t blocks = 1) override
  {
    LOG_DEBUG("Block %" PRId32 " :: 0x%" PRIX32 " for %" PRId32 " blocks",
              address, address, blocks);
    // Wait for a previous command to finish
    WaitWhileBusy();
   177ca:	ab05      	add	r3, sp, #20
   177cc:	6818      	ldr	r0, [r3, #0]
   177ce:	f7ff ffc3 	bl	17758 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool payload_had_bad_crc = false;
   177d2:	2300      	movs	r3, #0
   177d4:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247

    // Create a temporary place to store blocks of 512 bytes (this is now
    // possible because the constructor enforces block size cross-
    // compatibility)
    uint8_t block_store[512] = { 0 };
   177d8:	ab06      	add	r3, sp, #24
   177da:	4618      	mov	r0, r3
   177dc:	f44f 7300 	mov.w	r3, #512	; 0x200
   177e0:	461a      	mov	r2, r3
   177e2:	2100      	movs	r1, #0
   177e4:	f001 f9d1 	bl	18b8a <memset>

    // Determine appropriate command to send
    Command read_cmd;
    if (blocks > 1)
   177e8:	ab02      	add	r3, sp, #8
   177ea:	681b      	ldr	r3, [r3, #0]
   177ec:	2b01      	cmp	r3, #1
   177ee:	d902      	bls.n	177f6 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x4e>
    {
      read_cmd = Command::kReadMulti;
   177f0:	2352      	movs	r3, #82	; 0x52
   177f2:	9390      	str	r3, [sp, #576]	; 0x240
   177f4:	e001      	b.n	177fa <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x52>
    }
    else
    {
      read_cmd = Command::kReadSingle;
   177f6:	2351      	movs	r3, #81	; 0x51
   177f8:	9390      	str	r3, [sp, #576]	; 0x240
    }

    // Send initial read command
    sd.response.length =
        SendCmd(read_cmd, address, sd.response.data.byte, 100, KeepAlive::kYes);
   177fa:	ab05      	add	r3, sp, #20
   177fc:	681b      	ldr	r3, [r3, #0]
   177fe:	681b      	ldr	r3, [r3, #0]
   17800:	681c      	ldr	r4, [r3, #0]
   17802:	ab86      	add	r3, sp, #536	; 0x218
   17804:	f103 0108 	add.w	r1, r3, #8
   17808:	aa04      	add	r2, sp, #16
   1780a:	a805      	add	r0, sp, #20
   1780c:	2301      	movs	r3, #1
   1780e:	9301      	str	r3, [sp, #4]
   17810:	2364      	movs	r3, #100	; 0x64
   17812:	9300      	str	r3, [sp, #0]
   17814:	460b      	mov	r3, r1
   17816:	6812      	ldr	r2, [r2, #0]
   17818:	9990      	ldr	r1, [sp, #576]	; 0x240
   1781a:	6800      	ldr	r0, [r0, #0]
   1781c:	47a0      	blx	r4
   1781e:	4603      	mov	r3, r0
    sd.response.length =
   17820:	938a      	str	r3, [sp, #552]	; 0x228
    LOG_DEBUG("Sent Read Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the command was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   17822:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17826:	2b00      	cmp	r3, #0
   17828:	f040 80d8 	bne.w	179dc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x234>
    {
      // For every block requested
      uint16_t block_count;
      for (block_count = 0; block_count < blocks; block_count++)
   1782c:	2300      	movs	r3, #0
   1782e:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   17832:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   17836:	aa02      	add	r2, sp, #8
   17838:	6812      	ldr	r2, [r2, #0]
   1783a:	429a      	cmp	r2, r3
   1783c:	f240 8099 	bls.w	17972 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1ca>
      {
        // Wait for the card to respond with a ready signal
        WaitToReadBlock();
   17840:	ab05      	add	r3, sp, #20
   17842:	6818      	ldr	r0, [r3, #0]
   17844:	f7ff ff56 	bl	176f4 <Sd::WaitToReadBlock()>

        // Calculate the block address offset
        uint16_t block_addr_offset =
   17848:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   1784c:	025b      	lsls	r3, r3, #9
   1784e:	f8ad 323a 	strh.w	r3, [sp, #570]	; 0x23a
            static_cast<uint16_t>(block_count * kBlockSize);

        // Read all the bytes of a single block
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   17852:	2300      	movs	r3, #0
   17854:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   17858:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   1785c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   17860:	d22b      	bcs.n	178ba <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x112>
        {
          // Calculate the current storage index
          uint16_t storage_index =
   17862:	f8bd 223a 	ldrh.w	r2, [sp, #570]	; 0x23a
   17866:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   1786a:	4413      	add	r3, r2
   1786c:	f8ad 3238 	strh.w	r3, [sp, #568]	; 0x238
              static_cast<uint16_t>(block_addr_offset + byte_count);

          // Transfer a byte to read a block from the SD card
          array[storage_index] =
              static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   17870:	ab05      	add	r3, sp, #20
   17872:	681b      	ldr	r3, [r3, #0]
   17874:	685a      	ldr	r2, [r3, #4]
   17876:	ab05      	add	r3, sp, #20
   17878:	681b      	ldr	r3, [r3, #0]
   1787a:	685b      	ldr	r3, [r3, #4]
   1787c:	681b      	ldr	r3, [r3, #0]
   1787e:	3308      	adds	r3, #8
   17880:	681b      	ldr	r3, [r3, #0]
   17882:	21ff      	movs	r1, #255	; 0xff
   17884:	4610      	mov	r0, r2
   17886:	4798      	blx	r3
   17888:	4603      	mov	r3, r0
   1788a:	4619      	mov	r1, r3
          array[storage_index] =
   1788c:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   17890:	aa03      	add	r2, sp, #12
   17892:	6812      	ldr	r2, [r2, #0]
   17894:	4413      	add	r3, r2
   17896:	b2ca      	uxtb	r2, r1
   17898:	701a      	strb	r2, [r3, #0]

          // Copy that byte into our temporary block store
          block_store[byte_count] = array[storage_index];
   1789a:	f8bd 3238 	ldrh.w	r3, [sp, #568]	; 0x238
   1789e:	aa03      	add	r2, sp, #12
   178a0:	6812      	ldr	r2, [r2, #0]
   178a2:	441a      	add	r2, r3
   178a4:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   178a8:	7811      	ldrb	r1, [r2, #0]
   178aa:	aa06      	add	r2, sp, #24
   178ac:	54d1      	strb	r1, [r2, r3]
        for (uint16_t byte_count = 0; byte_count < kBlockSize; byte_count++)
   178ae:	f8bd 323c 	ldrh.w	r3, [sp, #572]	; 0x23c
   178b2:	3301      	adds	r3, #1
   178b4:	f8ad 323c 	strh.w	r3, [sp, #572]	; 0x23c
   178b8:	e7ce      	b.n	17858 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0xb0>
        }

        // Then read the block's 16-bit CRC (i.e. read two bytes)
        uint16_t block_crc =
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   178ba:	ab05      	add	r3, sp, #20
   178bc:	681b      	ldr	r3, [r3, #0]
   178be:	685a      	ldr	r2, [r3, #4]
   178c0:	ab05      	add	r3, sp, #20
   178c2:	681b      	ldr	r3, [r3, #0]
   178c4:	685b      	ldr	r3, [r3, #4]
   178c6:	681b      	ldr	r3, [r3, #0]
   178c8:	3308      	adds	r3, #8
   178ca:	681b      	ldr	r3, [r3, #0]
   178cc:	21ff      	movs	r1, #255	; 0xff
   178ce:	4610      	mov	r0, r2
   178d0:	4798      	blx	r3
   178d2:	4603      	mov	r3, r0
   178d4:	021b      	lsls	r3, r3, #8
   178d6:	b21c      	sxth	r4, r3
                                  ssp_interface_->Transfer(0xFF));
   178d8:	ab05      	add	r3, sp, #20
   178da:	681b      	ldr	r3, [r3, #0]
   178dc:	685a      	ldr	r2, [r3, #4]
   178de:	ab05      	add	r3, sp, #20
   178e0:	681b      	ldr	r3, [r3, #0]
   178e2:	685b      	ldr	r3, [r3, #4]
   178e4:	681b      	ldr	r3, [r3, #0]
   178e6:	3308      	adds	r3, #8
   178e8:	681b      	ldr	r3, [r3, #0]
   178ea:	21ff      	movs	r1, #255	; 0xff
   178ec:	4610      	mov	r0, r2
   178ee:	4798      	blx	r3
   178f0:	4603      	mov	r3, r0
   178f2:	b21b      	sxth	r3, r3
            static_cast<uint16_t>((ssp_interface_->Transfer(0xFF) << 8) |
   178f4:	4323      	orrs	r3, r4
   178f6:	b21b      	sxth	r3, r3
                                  ssp_interface_->Transfer(0xFF));
   178f8:	f8ad 3236 	strh.w	r3, [sp, #566]	; 0x236

        // Run a CRC-16 calculation on the message to determine if the
        // received CRCs match (i.e. checks if the block data is
        // valid).
        uint16_t expected_block_crc = GetCrc16(block_store, 512);
   178fc:	ab05      	add	r3, sp, #20
   178fe:	681b      	ldr	r3, [r3, #0]
   17900:	681b      	ldr	r3, [r3, #0]
   17902:	3320      	adds	r3, #32
   17904:	681b      	ldr	r3, [r3, #0]
   17906:	a906      	add	r1, sp, #24
   17908:	a805      	add	r0, sp, #20
   1790a:	f44f 7200 	mov.w	r2, #512	; 0x200
   1790e:	6800      	ldr	r0, [r0, #0]
   17910:	4798      	blx	r3
   17912:	4603      	mov	r3, r0
   17914:	f8ad 3234 	strh.w	r3, [sp, #564]	; 0x234

        LOG_DEBUG("Block #%d @ 0x%" PRIX32 " acquired", block_count, address);
        LOG_DEBUG("Expecting block crc16 '0x%04X'", expected_block_crc);
        LOG_DEBUG("Got '0x%04X'", block_crc);
        if (expected_block_crc != block_crc)
   17918:	f8bd 2234 	ldrh.w	r2, [sp, #564]	; 0x234
   1791c:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   17920:	429a      	cmp	r2, r3
   17922:	d020      	beq.n	17966 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1be>
        {
          // If they do not match, set the bad crc status
          payload_had_bad_crc = true;
   17924:	2301      	movs	r3, #1
   17926:	f88d 3247 	strb.w	r3, [sp, #583]	; 0x247
          LOG_ERROR("While Reading Block #%d CRC16:", block_count);
   1792a:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   1792e:	9300      	str	r3, [sp, #0]
   17930:	f240 23ed 	movw	r3, #749	; 0x2ed
   17934:	4a22      	ldr	r2, [pc, #136]	; (179c0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   17936:	4923      	ldr	r1, [pc, #140]	; (179c4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x21c>)
   17938:	4823      	ldr	r0, [pc, #140]	; (179c8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x220>)
   1793a:	f7fe fa8f 	bl	15e5c <printf>
          LOG_ERROR("Expected '0x%04X'", expected_block_crc);
   1793e:	f8bd 3234 	ldrh.w	r3, [sp, #564]	; 0x234
   17942:	9300      	str	r3, [sp, #0]
   17944:	f240 23ee 	movw	r3, #750	; 0x2ee
   17948:	4a1d      	ldr	r2, [pc, #116]	; (179c0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   1794a:	4920      	ldr	r1, [pc, #128]	; (179cc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x224>)
   1794c:	4820      	ldr	r0, [pc, #128]	; (179d0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x228>)
   1794e:	f7fe fa85 	bl	15e5c <printf>
          LOG_ERROR("Got '0x%04X'", block_crc);
   17952:	f8bd 3236 	ldrh.w	r3, [sp, #566]	; 0x236
   17956:	9300      	str	r3, [sp, #0]
   17958:	f240 23ef 	movw	r3, #751	; 0x2ef
   1795c:	4a18      	ldr	r2, [pc, #96]	; (179c0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x218>)
   1795e:	491d      	ldr	r1, [pc, #116]	; (179d4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x22c>)
   17960:	481d      	ldr	r0, [pc, #116]	; (179d8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x230>)
   17962:	f7fe fa7b 	bl	15e5c <printf>
      for (block_count = 0; block_count < blocks; block_count++)
   17966:	f8bd 323e 	ldrh.w	r3, [sp, #574]	; 0x23e
   1796a:	3301      	adds	r3, #1
   1796c:	f8ad 323e 	strh.w	r3, [sp, #574]	; 0x23e
   17970:	e75f      	b.n	17832 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x8a>
        }
      }

      // After reading multiple blocks, send the stop command to terminate the
      // transaction (i.e. no keep-alive)
      if (blocks > 1)
   17972:	ab02      	add	r3, sp, #8
   17974:	681b      	ldr	r3, [r3, #0]
   17976:	2b01      	cmp	r3, #1
   17978:	d913      	bls.n	179a2 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x1fa>
      {
        sd.response.length =
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
                    KeepAlive::kNo);
   1797a:	ab05      	add	r3, sp, #20
   1797c:	681b      	ldr	r3, [r3, #0]
   1797e:	681b      	ldr	r3, [r3, #0]
   17980:	681c      	ldr	r4, [r3, #0]
            SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte, 100,
   17982:	ab86      	add	r3, sp, #536	; 0x218
   17984:	f103 0208 	add.w	r2, r3, #8
   17988:	a805      	add	r0, sp, #20
   1798a:	2300      	movs	r3, #0
   1798c:	9301      	str	r3, [sp, #4]
   1798e:	2364      	movs	r3, #100	; 0x64
   17990:	9300      	str	r3, [sp, #0]
   17992:	4613      	mov	r3, r2
   17994:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17998:	214c      	movs	r1, #76	; 0x4c
   1799a:	6800      	ldr	r0, [r0, #0]
   1799c:	47a0      	blx	r4
   1799e:	4603      	mov	r3, r0
        sd.response.length =
   179a0:	938a      	str	r3, [sp, #552]	; 0x228
      LOG_DEBUG("Response Byte");
      LOG_DEBUG("0x%02X", sd.response.data.byte[0]);

      // If there was a bad crc from the payload, manually set the
      // CRC error flag in the command response byte
      if (payload_had_bad_crc)
   179a2:	f89d 3247 	ldrb.w	r3, [sp, #583]	; 0x247
   179a6:	2b00      	cmp	r3, #0
   179a8:	f000 80c0 	beq.w	17b2c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
      {
        sd.response.data.byte[0] |= 0x08;
   179ac:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   179b0:	f043 0308 	orr.w	r3, r3, #8
   179b4:	b2db      	uxtb	r3, r3
   179b6:	f88d 3220 	strb.w	r3, [sp, #544]	; 0x220
   179ba:	e0b7      	b.n	17b2c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
   179bc:	000177a9 	.word	0x000177a9
   179c0:	0001ae64 	.word	0x0001ae64
   179c4:	0001ab68 	.word	0x0001ab68
   179c8:	0001a2fc 	.word	0x0001a2fc
   179cc:	0001ab70 	.word	0x0001ab70
   179d0:	0001a354 	.word	0x0001a354
   179d4:	0001ab78 	.word	0x0001ab78
   179d8:	0001a3a0 	.word	0x0001a3a0
      }
    }
    else
    {
      LOG_ERROR("Read Cmd was not acknowledged properly!");
   179dc:	f240 3309 	movw	r3, #777	; 0x309
   179e0:	4a65      	ldr	r2, [pc, #404]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   179e2:	4966      	ldr	r1, [pc, #408]	; (17b7c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d4>)
   179e4:	4866      	ldr	r0, [pc, #408]	; (17b80 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d8>)
   179e6:	f7fe fa39 	bl	15e5c <printf>
      LOG_ERROR("Parameter Err: %s", ToBool(sd.response.data.byte[0] & 0x40));
   179ea:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   179ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
   179f2:	2b00      	cmp	r3, #0
   179f4:	bf14      	ite	ne
   179f6:	2301      	movne	r3, #1
   179f8:	2300      	moveq	r3, #0
   179fa:	b2da      	uxtb	r2, r3
   179fc:	ab05      	add	r3, sp, #20
   179fe:	4611      	mov	r1, r2
   17a00:	6818      	ldr	r0, [r3, #0]
   17a02:	f7ff fe55 	bl	176b0 <Sd::ToBool(bool)>
   17a06:	4603      	mov	r3, r0
   17a08:	9300      	str	r3, [sp, #0]
   17a0a:	f240 330a 	movw	r3, #778	; 0x30a
   17a0e:	4a5a      	ldr	r2, [pc, #360]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17a10:	495c      	ldr	r1, [pc, #368]	; (17b84 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3dc>)
   17a12:	485d      	ldr	r0, [pc, #372]	; (17b88 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e0>)
   17a14:	f7fe fa22 	bl	15e5c <printf>
      LOG_ERROR("Addr Err: %s", ToBool(sd.response.data.byte[0] & 0x20));
   17a18:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17a1c:	f003 0320 	and.w	r3, r3, #32
   17a20:	2b00      	cmp	r3, #0
   17a22:	bf14      	ite	ne
   17a24:	2301      	movne	r3, #1
   17a26:	2300      	moveq	r3, #0
   17a28:	b2da      	uxtb	r2, r3
   17a2a:	ab05      	add	r3, sp, #20
   17a2c:	4611      	mov	r1, r2
   17a2e:	6818      	ldr	r0, [r3, #0]
   17a30:	f7ff fe3e 	bl	176b0 <Sd::ToBool(bool)>
   17a34:	4603      	mov	r3, r0
   17a36:	9300      	str	r3, [sp, #0]
   17a38:	f240 330b 	movw	r3, #779	; 0x30b
   17a3c:	4a4e      	ldr	r2, [pc, #312]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17a3e:	4953      	ldr	r1, [pc, #332]	; (17b8c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e4>)
   17a40:	4853      	ldr	r0, [pc, #332]	; (17b90 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3e8>)
   17a42:	f7fe fa0b 	bl	15e5c <printf>
      LOG_ERROR("Erase Seq Err: %s", ToBool(sd.response.data.byte[0] & 0x10));
   17a46:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17a4a:	f003 0310 	and.w	r3, r3, #16
   17a4e:	2b00      	cmp	r3, #0
   17a50:	bf14      	ite	ne
   17a52:	2301      	movne	r3, #1
   17a54:	2300      	moveq	r3, #0
   17a56:	b2da      	uxtb	r2, r3
   17a58:	ab05      	add	r3, sp, #20
   17a5a:	4611      	mov	r1, r2
   17a5c:	6818      	ldr	r0, [r3, #0]
   17a5e:	f7ff fe27 	bl	176b0 <Sd::ToBool(bool)>
   17a62:	4603      	mov	r3, r0
   17a64:	9300      	str	r3, [sp, #0]
   17a66:	f44f 7343 	mov.w	r3, #780	; 0x30c
   17a6a:	4a43      	ldr	r2, [pc, #268]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17a6c:	4949      	ldr	r1, [pc, #292]	; (17b94 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3ec>)
   17a6e:	484a      	ldr	r0, [pc, #296]	; (17b98 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f0>)
   17a70:	f7fe f9f4 	bl	15e5c <printf>
      LOG_ERROR("Com CRC Err: %s", ToBool(sd.response.data.byte[0] & 0x08));
   17a74:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17a78:	f003 0308 	and.w	r3, r3, #8
   17a7c:	2b00      	cmp	r3, #0
   17a7e:	bf14      	ite	ne
   17a80:	2301      	movne	r3, #1
   17a82:	2300      	moveq	r3, #0
   17a84:	b2da      	uxtb	r2, r3
   17a86:	ab05      	add	r3, sp, #20
   17a88:	4611      	mov	r1, r2
   17a8a:	6818      	ldr	r0, [r3, #0]
   17a8c:	f7ff fe10 	bl	176b0 <Sd::ToBool(bool)>
   17a90:	4603      	mov	r3, r0
   17a92:	9300      	str	r3, [sp, #0]
   17a94:	f240 330d 	movw	r3, #781	; 0x30d
   17a98:	4a37      	ldr	r2, [pc, #220]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17a9a:	4940      	ldr	r1, [pc, #256]	; (17b9c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f4>)
   17a9c:	4840      	ldr	r0, [pc, #256]	; (17ba0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3f8>)
   17a9e:	f7fe f9dd 	bl	15e5c <printf>
      LOG_ERROR("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
   17aa2:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17aa6:	f003 0304 	and.w	r3, r3, #4
   17aaa:	2b00      	cmp	r3, #0
   17aac:	bf14      	ite	ne
   17aae:	2301      	movne	r3, #1
   17ab0:	2300      	moveq	r3, #0
   17ab2:	b2da      	uxtb	r2, r3
   17ab4:	ab05      	add	r3, sp, #20
   17ab6:	4611      	mov	r1, r2
   17ab8:	6818      	ldr	r0, [r3, #0]
   17aba:	f7ff fdf9 	bl	176b0 <Sd::ToBool(bool)>
   17abe:	4603      	mov	r3, r0
   17ac0:	9300      	str	r3, [sp, #0]
   17ac2:	f240 330e 	movw	r3, #782	; 0x30e
   17ac6:	4a2c      	ldr	r2, [pc, #176]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17ac8:	4936      	ldr	r1, [pc, #216]	; (17ba4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3fc>)
   17aca:	4837      	ldr	r0, [pc, #220]	; (17ba8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x400>)
   17acc:	f7fe f9c6 	bl	15e5c <printf>
      LOG_ERROR("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
   17ad0:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17ad4:	f003 0302 	and.w	r3, r3, #2
   17ad8:	2b00      	cmp	r3, #0
   17ada:	bf14      	ite	ne
   17adc:	2301      	movne	r3, #1
   17ade:	2300      	moveq	r3, #0
   17ae0:	b2da      	uxtb	r2, r3
   17ae2:	ab05      	add	r3, sp, #20
   17ae4:	4611      	mov	r1, r2
   17ae6:	6818      	ldr	r0, [r3, #0]
   17ae8:	f7ff fde2 	bl	176b0 <Sd::ToBool(bool)>
   17aec:	4603      	mov	r3, r0
   17aee:	9300      	str	r3, [sp, #0]
   17af0:	f240 330f 	movw	r3, #783	; 0x30f
   17af4:	4a20      	ldr	r2, [pc, #128]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17af6:	492d      	ldr	r1, [pc, #180]	; (17bac <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x404>)
   17af8:	482d      	ldr	r0, [pc, #180]	; (17bb0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x408>)
   17afa:	f7fe f9af 	bl	15e5c <printf>
      LOG_ERROR("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
   17afe:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17b02:	f003 0301 	and.w	r3, r3, #1
   17b06:	2b00      	cmp	r3, #0
   17b08:	bf14      	ite	ne
   17b0a:	2301      	movne	r3, #1
   17b0c:	2300      	moveq	r3, #0
   17b0e:	b2da      	uxtb	r2, r3
   17b10:	ab05      	add	r3, sp, #20
   17b12:	4611      	mov	r1, r2
   17b14:	6818      	ldr	r0, [r3, #0]
   17b16:	f7ff fdcb 	bl	176b0 <Sd::ToBool(bool)>
   17b1a:	4603      	mov	r3, r0
   17b1c:	9300      	str	r3, [sp, #0]
   17b1e:	f44f 7344 	mov.w	r3, #784	; 0x310
   17b22:	4a15      	ldr	r2, [pc, #84]	; (17b78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3d0>)
   17b24:	4923      	ldr	r1, [pc, #140]	; (17bb4 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x40c>)
   17b26:	4824      	ldr	r0, [pc, #144]	; (17bb8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x410>)
   17b28:	f7fe f998 	bl	15e5c <printf>
    LOG_DEBUG("Now waiting for SD Card to exit Idle Mode...");
    do
    {
      // Query the status register
      sd.response.length = SendCmd(Command::kGetStatus, 32,
                                   sd.response.data.byte, 0, KeepAlive::kNo);
   17b2c:	ab05      	add	r3, sp, #20
   17b2e:	681b      	ldr	r3, [r3, #0]
   17b30:	681b      	ldr	r3, [r3, #0]
   17b32:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kGetStatus, 32,
   17b34:	ab86      	add	r3, sp, #536	; 0x218
   17b36:	f103 0208 	add.w	r2, r3, #8
   17b3a:	a805      	add	r0, sp, #20
   17b3c:	2300      	movs	r3, #0
   17b3e:	9301      	str	r3, [sp, #4]
   17b40:	2300      	movs	r3, #0
   17b42:	9300      	str	r3, [sp, #0]
   17b44:	4613      	mov	r3, r2
   17b46:	2220      	movs	r2, #32
   17b48:	210d      	movs	r1, #13
   17b4a:	6800      	ldr	r0, [r0, #0]
   17b4c:	47a0      	blx	r4
   17b4e:	4603      	mov	r3, r0
   17b50:	938a      	str	r3, [sp, #552]	; 0x228
    } while (sd.response.data.byte[0] & 0x01);
   17b52:	f89d 3220 	ldrb.w	r3, [sp, #544]	; 0x220
   17b56:	f003 0301 	and.w	r3, r3, #1
   17b5a:	2b00      	cmp	r3, #0
   17b5c:	d000      	beq.n	17b60 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x3b8>
    do
   17b5e:	e7e5      	b.n	17b2c <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x384>
    LOG_DEBUG("SD Card is out of Idle Mode!");

    // Return the status
    LOG_DEBUG("Read Complete! [R1 Response: 0x%02X]", sd.response.data.byte[0]);
    return sd.response.data.byte[0];
   17b60:	f89d 4220 	ldrb.w	r4, [sp, #544]	; 0x220
   17b64:	462b      	mov	r3, r5
   17b66:	4619      	mov	r1, r3
   17b68:	4814      	ldr	r0, [pc, #80]	; (17bbc <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)+0x414>)
   17b6a:	f7fb fbef 	bl	1334c <__cyg_profile_func_exit>
   17b6e:	4623      	mov	r3, r4
  }
   17b70:	4618      	mov	r0, r3
   17b72:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
   17b76:	bd30      	pop	{r4, r5, pc}
   17b78:	0001ae64 	.word	0x0001ae64
   17b7c:	0001ab80 	.word	0x0001ab80
   17b80:	0001a3e8 	.word	0x0001a3e8
   17b84:	0001ab88 	.word	0x0001ab88
   17b88:	0001a44c 	.word	0x0001a44c
   17b8c:	0001ab90 	.word	0x0001ab90
   17b90:	0001a498 	.word	0x0001a498
   17b94:	0001ab98 	.word	0x0001ab98
   17b98:	0001a4e0 	.word	0x0001a4e0
   17b9c:	0001aba0 	.word	0x0001aba0
   17ba0:	0001a52c 	.word	0x0001a52c
   17ba4:	0001aba8 	.word	0x0001aba8
   17ba8:	0001a578 	.word	0x0001a578
   17bac:	0001abb0 	.word	0x0001abb0
   17bb0:	0001a5c8 	.word	0x0001a5c8
   17bb4:	0001abb8 	.word	0x0001abb8
   17bb8:	0001a614 	.word	0x0001a614
   17bbc:	000177a9 	.word	0x000177a9

00017bc0 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)>:

  // Writes any number of 512-byte blocks to the SD Card
  uint8_t WriteBlock(uint32_t address, const uint8_t * array,
   17bc0:	b530      	push	{r4, r5, lr}
   17bc2:	b095      	sub	sp, #84	; 0x54
   17bc4:	4675      	mov	r5, lr
   17bc6:	9005      	str	r0, [sp, #20]
   17bc8:	9104      	str	r1, [sp, #16]
   17bca:	9203      	str	r2, [sp, #12]
   17bcc:	9302      	str	r3, [sp, #8]
   17bce:	462b      	mov	r3, r5
   17bd0:	4619      	mov	r1, r3
   17bd2:	4865      	ldr	r0, [pc, #404]	; (17d68 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   17bd4:	f7fb fba6 	bl	13324 <__cyg_profile_func_enter>
                     uint32_t blocks = 1) override
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   17bd8:	9805      	ldr	r0, [sp, #20]
   17bda:	f7ff fdbd 	bl	17758 <Sd::WaitWhileBusy()>
    Sd::CardInfo_t sd;

    // Determine appropriate command and start token to send
    Command write_cmd;
    uint8_t write_start_tkn;
    if (blocks > 1)
   17bde:	9b02      	ldr	r3, [sp, #8]
   17be0:	2b01      	cmp	r3, #1
   17be2:	d905      	bls.n	17bf0 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x30>
    {
      write_cmd       = Command::kWriteMulti;
   17be4:	2359      	movs	r3, #89	; 0x59
   17be6:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFC;
   17be8:	23fc      	movs	r3, #252	; 0xfc
   17bea:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
   17bee:	e004      	b.n	17bfa <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x3a>
    }
    else
    {
      write_cmd       = Command::kWriteSingle;
   17bf0:	2358      	movs	r3, #88	; 0x58
   17bf2:	9313      	str	r3, [sp, #76]	; 0x4c
      write_start_tkn = 0xFE;
   17bf4:	23fe      	movs	r3, #254	; 0xfe
   17bf6:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
    }

    // Send initial write command
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
                                 KeepAlive::kYes);
   17bfa:	9b05      	ldr	r3, [sp, #20]
   17bfc:	681b      	ldr	r3, [r3, #0]
   17bfe:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(write_cmd, address, sd.response.data.byte, 100,
   17c00:	ab06      	add	r3, sp, #24
   17c02:	f103 0208 	add.w	r2, r3, #8
   17c06:	2301      	movs	r3, #1
   17c08:	9301      	str	r3, [sp, #4]
   17c0a:	2364      	movs	r3, #100	; 0x64
   17c0c:	9300      	str	r3, [sp, #0]
   17c0e:	4613      	mov	r3, r2
   17c10:	9a04      	ldr	r2, [sp, #16]
   17c12:	9913      	ldr	r1, [sp, #76]	; 0x4c
   17c14:	9805      	ldr	r0, [sp, #20]
   17c16:	47a0      	blx	r4
   17c18:	4603      	mov	r3, r0
   17c1a:	930a      	str	r3, [sp, #40]	; 0x28
    LOG_DEBUG("Sent Write Cmd");
    LOG_DEBUG("[R1 Response:0x%02X]", sd.response.data.byte[0]);

    // Check if the response was acknowledged properly
    if (sd.response.data.byte[0] == 0x00)
   17c1c:	f89d 3020 	ldrb.w	r3, [sp, #32]
   17c20:	2b00      	cmp	r3, #0
   17c22:	f040 8096 	bne.w	17d52 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
    {
      // If no errors, proceed write given block(s) to SD Card
      // For each given block
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   17c26:	2300      	movs	r3, #0
   17c28:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   17c2c:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   17c30:	9a02      	ldr	r2, [sp, #8]
   17c32:	429a      	cmp	r2, r3
   17c34:	d97a      	bls.n	17d2c <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x16c>
           current_block_num++)
      {
        // Calculate array offset
        uint64_t arr_offset = current_block_num * kBlockSize;
   17c36:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   17c3a:	025b      	lsls	r3, r3, #9
   17c3c:	ea4f 74e3 	mov.w	r4, r3, asr #31
   17c40:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38

        // Send the start token for the current block
        ssp_interface_->Transfer(write_start_tkn);
   17c44:	9b05      	ldr	r3, [sp, #20]
   17c46:	685a      	ldr	r2, [r3, #4]
   17c48:	9b05      	ldr	r3, [sp, #20]
   17c4a:	685b      	ldr	r3, [r3, #4]
   17c4c:	681b      	ldr	r3, [r3, #0]
   17c4e:	3308      	adds	r3, #8
   17c50:	681b      	ldr	r3, [r3, #0]
   17c52:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
   17c56:	b289      	uxth	r1, r1
   17c58:	4610      	mov	r0, r2
   17c5a:	4798      	blx	r3

        // Write all 512-bytes of the given block
        LOG_DEBUG("Writing block #%d", current_block_num);
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   17c5c:	2300      	movs	r3, #0
   17c5e:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   17c62:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   17c66:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   17c6a:	d216      	bcs.n	17c9a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xda>
             current_byte++)
        {
          ssp_interface_->Transfer(array[arr_offset + current_byte]);
   17c6c:	9b05      	ldr	r3, [sp, #20]
   17c6e:	6858      	ldr	r0, [r3, #4]
   17c70:	9b05      	ldr	r3, [sp, #20]
   17c72:	685b      	ldr	r3, [r3, #4]
   17c74:	681b      	ldr	r3, [r3, #0]
   17c76:	3308      	adds	r3, #8
   17c78:	681b      	ldr	r3, [r3, #0]
   17c7a:	990e      	ldr	r1, [sp, #56]	; 0x38
   17c7c:	f8bd 2046 	ldrh.w	r2, [sp, #70]	; 0x46
   17c80:	440a      	add	r2, r1
   17c82:	9903      	ldr	r1, [sp, #12]
   17c84:	440a      	add	r2, r1
   17c86:	7812      	ldrb	r2, [r2, #0]
   17c88:	b292      	uxth	r2, r2
   17c8a:	4611      	mov	r1, r2
   17c8c:	4798      	blx	r3
        for (uint16_t current_byte = 0; current_byte < kBlockSize;
   17c8e:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
   17c92:	3301      	adds	r3, #1
   17c94:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   17c98:	e7e3      	b.n	17c62 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0xa2>
        }

        // Read the data response token after writing the block
        uint8_t data_response_tkn =
            static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   17c9a:	9b05      	ldr	r3, [sp, #20]
   17c9c:	685a      	ldr	r2, [r3, #4]
   17c9e:	9b05      	ldr	r3, [sp, #20]
   17ca0:	685b      	ldr	r3, [r3, #4]
   17ca2:	681b      	ldr	r3, [r3, #0]
   17ca4:	3308      	adds	r3, #8
   17ca6:	681b      	ldr	r3, [r3, #0]
   17ca8:	21ff      	movs	r1, #255	; 0xff
   17caa:	4610      	mov	r0, r2
   17cac:	4798      	blx	r3
   17cae:	4603      	mov	r3, r0
   17cb0:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
                  ToBool(data_response_tkn & 0x0B));
        LOG_DEBUG("Data Rejected (write err)?: %s",
                  ToBool(data_response_tkn & 0x0D));

        // If writing multiple blocks and the previous block was rejected
        if (blocks > 1 && !(data_response_tkn & 0x05))
   17cb4:	9b02      	ldr	r3, [sp, #8]
   17cb6:	2b01      	cmp	r3, #1
   17cb8:	d92f      	bls.n	17d1a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
   17cba:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   17cbe:	f003 0305 	and.w	r3, r3, #5
   17cc2:	2b00      	cmp	r3, #0
   17cc4:	d129      	bne.n	17d1a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
        {
          // Send an immediate stop (CMD12)
          sd.response.length =
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
                      100, KeepAlive::kYes);
   17cc6:	9b05      	ldr	r3, [sp, #20]
   17cc8:	681b      	ldr	r3, [r3, #0]
   17cca:	681c      	ldr	r4, [r3, #0]
              SendCmd(Command::kStopTrans, 0xFFFFFFFF, sd.response.data.byte,
   17ccc:	ab06      	add	r3, sp, #24
   17cce:	f103 0208 	add.w	r2, r3, #8
   17cd2:	2301      	movs	r3, #1
   17cd4:	9301      	str	r3, [sp, #4]
   17cd6:	2364      	movs	r3, #100	; 0x64
   17cd8:	9300      	str	r3, [sp, #0]
   17cda:	4613      	mov	r3, r2
   17cdc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17ce0:	214c      	movs	r1, #76	; 0x4c
   17ce2:	9805      	ldr	r0, [sp, #20]
   17ce4:	47a0      	blx	r4
   17ce6:	4603      	mov	r3, r0
          sd.response.length =
   17ce8:	930a      	str	r3, [sp, #40]	; 0x28
          LOG_DEBUG("Stopped Transmission due to rejection...");
          LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);

          // In the case of a write error, ask for the reason why
          if (data_response_tkn & 0x0D)
   17cea:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   17cee:	f003 030d 	and.w	r3, r3, #13
   17cf2:	2b00      	cmp	r3, #0
   17cf4:	d011      	beq.n	17d1a <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x15a>
          {
            sd.response.length =
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
                        100, KeepAlive::kYes);
   17cf6:	9b05      	ldr	r3, [sp, #20]
   17cf8:	681b      	ldr	r3, [r3, #0]
   17cfa:	681c      	ldr	r4, [r3, #0]
                SendCmd(Command::kGetStatus, 0xFFFFFFFF, sd.response.data.byte,
   17cfc:	ab06      	add	r3, sp, #24
   17cfe:	f103 0208 	add.w	r2, r3, #8
   17d02:	2301      	movs	r3, #1
   17d04:	9301      	str	r3, [sp, #4]
   17d06:	2364      	movs	r3, #100	; 0x64
   17d08:	9300      	str	r3, [sp, #0]
   17d0a:	4613      	mov	r3, r2
   17d0c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17d10:	210d      	movs	r1, #13
   17d12:	9805      	ldr	r0, [sp, #20]
   17d14:	47a0      	blx	r4
   17d16:	4603      	mov	r3, r0
            sd.response.length =
   17d18:	930a      	str	r3, [sp, #40]	; 0x28
                "Checking Status Register to see cause of Write Error...");
            LOG_DEBUG("[R2 Response: 0x%04" PRIX32 "]",
                      sd.response.data.dWord.lo);
          }
        }
        WaitWhileBusy();
   17d1a:	9805      	ldr	r0, [sp, #20]
   17d1c:	f7ff fd1c 	bl	17758 <Sd::WaitWhileBusy()>
      for (uint16_t current_block_num = 0; current_block_num < blocks;
   17d20:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   17d24:	3301      	adds	r3, #1
   17d26:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   17d2a:	e77f      	b.n	17c2c <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x6c>
      }

      if (blocks > 1)
   17d2c:	9b02      	ldr	r3, [sp, #8]
   17d2e:	2b01      	cmp	r3, #1
   17d30:	d90f      	bls.n	17d52 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x192>
      {
        constexpr uint8_t kStopToken = 0xFD;
   17d32:	23fd      	movs	r3, #253	; 0xfd
   17d34:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
        ssp_interface_->Transfer(kStopToken);
   17d38:	9b05      	ldr	r3, [sp, #20]
   17d3a:	685a      	ldr	r2, [r3, #4]
   17d3c:	9b05      	ldr	r3, [sp, #20]
   17d3e:	685b      	ldr	r3, [r3, #4]
   17d40:	681b      	ldr	r3, [r3, #0]
   17d42:	3308      	adds	r3, #8
   17d44:	681b      	ldr	r3, [r3, #0]
   17d46:	21fd      	movs	r1, #253	; 0xfd
   17d48:	4610      	mov	r0, r2
   17d4a:	4798      	blx	r3

        // Wait for the card's programming to complete before
        // reselecting it (i.e. to prevent corruption)
        WaitWhileBusy();
   17d4c:	9805      	ldr	r0, [sp, #20]
   17d4e:	f7ff fd03 	bl	17758 <Sd::WaitWhileBusy()>
      LOG_DEBUG("Illegal Cmd Err: %s", ToBool(sd.response.data.byte[0] & 0x04));
      LOG_DEBUG("Erase Reset: %s", ToBool(sd.response.data.byte[0] & 0x02));
      LOG_DEBUG("In Idle: %s", ToBool(sd.response.data.byte[0] & 0x01));
    }

    return sd.response.data.byte[0];
   17d52:	f89d 4020 	ldrb.w	r4, [sp, #32]
   17d56:	462b      	mov	r3, r5
   17d58:	4619      	mov	r1, r3
   17d5a:	4803      	ldr	r0, [pc, #12]	; (17d68 <Sd::WriteBlock(unsigned long, unsigned char const*, unsigned long)+0x1a8>)
   17d5c:	f7fb faf6 	bl	1334c <__cyg_profile_func_exit>
   17d60:	4623      	mov	r3, r4
  }
   17d62:	4618      	mov	r0, r3
   17d64:	b015      	add	sp, #84	; 0x54
   17d66:	bd30      	pop	{r4, r5, pc}
   17d68:	00017bc1 	.word	0x00017bc1

00017d6c <Sd::DeleteBlock(unsigned long, unsigned long)>:

  // Deletes any number of blocks (inclusively) within a range of address.
  uint8_t DeleteBlock(uint32_t start, uint32_t end) override
   17d6c:	b530      	push	{r4, r5, lr}
   17d6e:	b08f      	sub	sp, #60	; 0x3c
   17d70:	4675      	mov	r5, lr
   17d72:	9005      	str	r0, [sp, #20]
   17d74:	9104      	str	r1, [sp, #16]
   17d76:	9203      	str	r2, [sp, #12]
   17d78:	462b      	mov	r3, r5
   17d7a:	4619      	mov	r1, r3
   17d7c:	483d      	ldr	r0, [pc, #244]	; (17e74 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   17d7e:	f7fb fad1 	bl	13324 <__cyg_profile_func_enter>
  {
    // Wait for a previous command to finish
    WaitWhileBusy();
   17d82:	9805      	ldr	r0, [sp, #20]
   17d84:	f7ff fce8 	bl	17758 <Sd::WaitWhileBusy()>

    // Create a temporary storage location to store sd command responses
    Sd::CardInfo_t sd;
    bool delete_failed = false;
   17d88:	2300      	movs	r3, #0
   17d8a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37

    // Set the delete start address
    LOG_DEBUG("Setting Delete Start Address...");
    sd.response.length = SendCmd(Command::kDelFrom, start,
                                 sd.response.data.byte, 100, KeepAlive::kYes);
   17d8e:	9b05      	ldr	r3, [sp, #20]
   17d90:	681b      	ldr	r3, [r3, #0]
   17d92:	681c      	ldr	r4, [r3, #0]
    sd.response.length = SendCmd(Command::kDelFrom, start,
   17d94:	ab06      	add	r3, sp, #24
   17d96:	f103 0208 	add.w	r2, r3, #8
   17d9a:	2301      	movs	r3, #1
   17d9c:	9301      	str	r3, [sp, #4]
   17d9e:	2364      	movs	r3, #100	; 0x64
   17da0:	9300      	str	r3, [sp, #0]
   17da2:	4613      	mov	r3, r2
   17da4:	9a04      	ldr	r2, [sp, #16]
   17da6:	2160      	movs	r1, #96	; 0x60
   17da8:	9805      	ldr	r0, [sp, #20]
   17daa:	47a0      	blx	r4
   17dac:	4603      	mov	r3, r0
   17dae:	930a      	str	r3, [sp, #40]	; 0x28

    // Wait while the writing the start address
    WaitWhileBusy();
   17db0:	9805      	ldr	r0, [sp, #20]
   17db2:	f7ff fcd1 	bl	17758 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   17db6:	f89d 3020 	ldrb.w	r3, [sp, #32]
   17dba:	2b00      	cmp	r3, #0
   17dbc:	d009      	beq.n	17dd2 <Sd::DeleteBlock(unsigned long, unsigned long)+0x66>
    {
      LOG_ERROR("Failed to set Start Address!");
   17dbe:	f44f 736a 	mov.w	r3, #936	; 0x3a8
   17dc2:	4a2d      	ldr	r2, [pc, #180]	; (17e78 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   17dc4:	492d      	ldr	r1, [pc, #180]	; (17e7c <Sd::DeleteBlock(unsigned long, unsigned long)+0x110>)
   17dc6:	482e      	ldr	r0, [pc, #184]	; (17e80 <Sd::DeleteBlock(unsigned long, unsigned long)+0x114>)
   17dc8:	f7fe f848 	bl	15e5c <printf>
      delete_failed = true;
   17dcc:	2301      	movs	r3, #1
   17dce:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Set the delete end address
    if (!delete_failed)
   17dd2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   17dd6:	f083 0301 	eor.w	r3, r3, #1
   17dda:	b2db      	uxtb	r3, r3
   17ddc:	2b00      	cmp	r3, #0
   17dde:	d010      	beq.n	17e02 <Sd::DeleteBlock(unsigned long, unsigned long)+0x96>
    {
      LOG_DEBUG("Setting Delete End Address...");
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
                                   100, KeepAlive::kYes);
   17de0:	9b05      	ldr	r3, [sp, #20]
   17de2:	681b      	ldr	r3, [r3, #0]
   17de4:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDelTo, end, sd.response.data.byte,
   17de6:	ab06      	add	r3, sp, #24
   17de8:	f103 0208 	add.w	r2, r3, #8
   17dec:	2301      	movs	r3, #1
   17dee:	9301      	str	r3, [sp, #4]
   17df0:	2364      	movs	r3, #100	; 0x64
   17df2:	9300      	str	r3, [sp, #0]
   17df4:	4613      	mov	r3, r2
   17df6:	9a03      	ldr	r2, [sp, #12]
   17df8:	2161      	movs	r1, #97	; 0x61
   17dfa:	9805      	ldr	r0, [sp, #20]
   17dfc:	47a0      	blx	r4
   17dfe:	4603      	mov	r3, r0
   17e00:	930a      	str	r3, [sp, #40]	; 0x28
    }

    // Wait while the writing the end address
    WaitWhileBusy();
   17e02:	9805      	ldr	r0, [sp, #20]
   17e04:	f7ff fca8 	bl	17758 <Sd::WaitWhileBusy()>

    // Force return if an error occurred
    if (sd.response.data.byte[0] != 0x00)
   17e08:	f89d 3020 	ldrb.w	r3, [sp, #32]
   17e0c:	2b00      	cmp	r3, #0
   17e0e:	d009      	beq.n	17e24 <Sd::DeleteBlock(unsigned long, unsigned long)+0xb8>
    {
      LOG_ERROR("Failed to set End Address!");
   17e10:	f240 33ba 	movw	r3, #954	; 0x3ba
   17e14:	4a18      	ldr	r2, [pc, #96]	; (17e78 <Sd::DeleteBlock(unsigned long, unsigned long)+0x10c>)
   17e16:	491b      	ldr	r1, [pc, #108]	; (17e84 <Sd::DeleteBlock(unsigned long, unsigned long)+0x118>)
   17e18:	481b      	ldr	r0, [pc, #108]	; (17e88 <Sd::DeleteBlock(unsigned long, unsigned long)+0x11c>)
   17e1a:	f7fe f81f 	bl	15e5c <printf>
      delete_failed = true;
   17e1e:	2301      	movs	r3, #1
   17e20:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // Finally, attempt a delete
    if (!delete_failed)
   17e24:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
   17e28:	f083 0301 	eor.w	r3, r3, #1
   17e2c:	b2db      	uxtb	r3, r3
   17e2e:	2b00      	cmp	r3, #0
   17e30:	d014      	beq.n	17e5c <Sd::DeleteBlock(unsigned long, unsigned long)+0xf0>
    {
      // Issue the delete command to delete from our from:to range
      LOG_DEBUG("Issuing Delete Command...");
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
                                   sd.response.data.byte, 100, KeepAlive::kYes);
   17e32:	9b05      	ldr	r3, [sp, #20]
   17e34:	681b      	ldr	r3, [r3, #0]
   17e36:	681c      	ldr	r4, [r3, #0]
      sd.response.length = SendCmd(Command::kDel, 0xFFFFFFFF,
   17e38:	ab06      	add	r3, sp, #24
   17e3a:	f103 0208 	add.w	r2, r3, #8
   17e3e:	2301      	movs	r3, #1
   17e40:	9301      	str	r3, [sp, #4]
   17e42:	2364      	movs	r3, #100	; 0x64
   17e44:	9300      	str	r3, [sp, #0]
   17e46:	4613      	mov	r3, r2
   17e48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   17e4c:	2166      	movs	r1, #102	; 0x66
   17e4e:	9805      	ldr	r0, [sp, #20]
   17e50:	47a0      	blx	r4
   17e52:	4603      	mov	r3, r0
   17e54:	930a      	str	r3, [sp, #40]	; 0x28

      // Wait while the deletion occurs
      WaitWhileBusy();
   17e56:	9805      	ldr	r0, [sp, #20]
   17e58:	f7ff fc7e 	bl	17758 <Sd::WaitWhileBusy()>
      LOG_DEBUG("[R1 Response: 0x%02X]", sd.response.data.byte[0]);
      LOG_DEBUG("Deletion Complete...");
    }

    // Return status
    return sd.response.data.byte[0];
   17e5c:	f89d 4020 	ldrb.w	r4, [sp, #32]
   17e60:	462b      	mov	r3, r5
   17e62:	4619      	mov	r1, r3
   17e64:	4803      	ldr	r0, [pc, #12]	; (17e74 <Sd::DeleteBlock(unsigned long, unsigned long)+0x108>)
   17e66:	f7fb fa71 	bl	1334c <__cyg_profile_func_exit>
   17e6a:	4623      	mov	r3, r4
  }
   17e6c:	4618      	mov	r0, r3
   17e6e:	b00f      	add	sp, #60	; 0x3c
   17e70:	bd30      	pop	{r4, r5, pc}
   17e72:	bf00      	nop
   17e74:	00017d6d 	.word	0x00017d6d
   17e78:	0001aea0 	.word	0x0001aea0
   17e7c:	0001abc0 	.word	0x0001abc0
   17e80:	0001a65c 	.word	0x0001a65c
   17e84:	0001abc8 	.word	0x0001abc8
   17e88:	0001a6b4 	.word	0x0001a6b4

00017e8c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)>:

  // Send a command
  uint32_t SendCmd(Command sdc, uint32_t arg, uint8_t response_buffer[],
   17e8c:	e92d 49f0 	stmdb	sp!, {r4, r5, r6, r7, r8, fp, lr}
   17e90:	b08f      	sub	sp, #60	; 0x3c
   17e92:	46f0      	mov	r8, lr
   17e94:	9003      	str	r0, [sp, #12]
   17e96:	9102      	str	r1, [sp, #8]
   17e98:	9201      	str	r2, [sp, #4]
   17e9a:	9300      	str	r3, [sp, #0]
   17e9c:	4643      	mov	r3, r8
   17e9e:	4619      	mov	r1, r3
   17ea0:	4840      	ldr	r0, [pc, #256]	; (17fa4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x118>)
   17ea2:	f7fb fa3f 	bl	13324 <__cyg_profile_func_enter>
                   uint32_t delay, KeepAlive keep_alive) override
  {
    ResponseType res_type;
    uint8_t res_len    = 0;
   17ea6:	2300      	movs	r3, #0
   17ea8:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    uint8_t crc        = 0;
   17eac:	2300      	movs	r3, #0
   17eae:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    uint8_t tries      = 0;
   17eb2:	2300      	movs	r3, #0
   17eb4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    uint8_t bit_offset = 0;  // determines the distance of the response's
   17eb8:	2300      	movs	r3, #0
   17eba:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                             // 0 bit from the MSB place
    uint8_t temp_byte = 0;
   17ebe:	2300      	movs	r3, #0
   17ec0:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f

    // Determine the response type of the set command
    switch (sdc)
   17ec4:	9b02      	ldr	r3, [sp, #8]
   17ec6:	2b58      	cmp	r3, #88	; 0x58
   17ec8:	d052      	beq.n	17f70 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xe4>
   17eca:	2b58      	cmp	r3, #88	; 0x58
   17ecc:	dc16      	bgt.n	17efc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x70>
   17ece:	2b48      	cmp	r3, #72	; 0x48
   17ed0:	d033      	beq.n	17f3a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xae>
   17ed2:	2b48      	cmp	r3, #72	; 0x48
   17ed4:	dc06      	bgt.n	17ee4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x58>
   17ed6:	2b40      	cmp	r3, #64	; 0x40
   17ed8:	d029      	beq.n	17f2e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa2>
   17eda:	2b41      	cmp	r3, #65	; 0x41
   17edc:	d02a      	beq.n	17f34 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xa8>
   17ede:	2b0d      	cmp	r3, #13
   17ee0:	d031      	beq.n	17f46 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xba>
   17ee2:	e054      	b.n	17f8e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   17ee4:	2b50      	cmp	r3, #80	; 0x50
   17ee6:	d03a      	beq.n	17f5e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd2>
   17ee8:	2b50      	cmp	r3, #80	; 0x50
   17eea:	dc02      	bgt.n	17ef2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x66>
   17eec:	2b4c      	cmp	r3, #76	; 0x4c
   17eee:	d027      	beq.n	17f40 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xb4>
   17ef0:	e04d      	b.n	17f8e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   17ef2:	2b51      	cmp	r3, #81	; 0x51
   17ef4:	d036      	beq.n	17f64 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xd8>
   17ef6:	2b52      	cmp	r3, #82	; 0x52
   17ef8:	d037      	beq.n	17f6a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xde>
   17efa:	e048      	b.n	17f8e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   17efc:	2b66      	cmp	r3, #102	; 0x66
   17efe:	d043      	beq.n	17f88 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xfc>
   17f00:	2b66      	cmp	r3, #102	; 0x66
   17f02:	dc06      	bgt.n	17f12 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x86>
   17f04:	2b60      	cmp	r3, #96	; 0x60
   17f06:	d039      	beq.n	17f7c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf0>
   17f08:	2b61      	cmp	r3, #97	; 0x61
   17f0a:	d03a      	beq.n	17f82 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xf6>
   17f0c:	2b59      	cmp	r3, #89	; 0x59
   17f0e:	d032      	beq.n	17f76 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xea>
   17f10:	e03d      	b.n	17f8e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   17f12:	2b77      	cmp	r3, #119	; 0x77
   17f14:	d01a      	beq.n	17f4c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc0>
   17f16:	2b77      	cmp	r3, #119	; 0x77
   17f18:	dc02      	bgt.n	17f20 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x94>
   17f1a:	2b69      	cmp	r3, #105	; 0x69
   17f1c:	d019      	beq.n	17f52 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xc6>
   17f1e:	e036      	b.n	17f8e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
   17f20:	2b7a      	cmp	r3, #122	; 0x7a
   17f22:	d019      	beq.n	17f58 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0xcc>
   17f24:	2bff      	cmp	r3, #255	; 0xff
   17f26:	d132      	bne.n	17f8e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x102>
    {
      case Command::kGarbage: res_type = ResponseType::kR1; break;
   17f28:	2300      	movs	r3, #0
   17f2a:	930d      	str	r3, [sp, #52]	; 0x34
   17f2c:	e042      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReset: res_type = ResponseType::kR1; break;
   17f2e:	2300      	movs	r3, #0
   17f30:	930d      	str	r3, [sp, #52]	; 0x34
   17f32:	e03f      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kInit: res_type = ResponseType::kR1; break;
   17f34:	2300      	movs	r3, #0
   17f36:	930d      	str	r3, [sp, #52]	; 0x34
   17f38:	e03c      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOp: res_type = ResponseType::kR7; break;
   17f3a:	2307      	movs	r3, #7
   17f3c:	930d      	str	r3, [sp, #52]	; 0x34
   17f3e:	e039      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kStopTrans: res_type = ResponseType::kR1; break;
   17f40:	2300      	movs	r3, #0
   17f42:	930d      	str	r3, [sp, #52]	; 0x34
   17f44:	e036      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetStatus: res_type = ResponseType::kR2; break;
   17f46:	2302      	movs	r3, #2
   17f48:	930d      	str	r3, [sp, #52]	; 0x34
   17f4a:	e033      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcBegin: res_type = ResponseType::kR1; break;
   17f4c:	2300      	movs	r3, #0
   17f4e:	930d      	str	r3, [sp, #52]	; 0x34
   17f50:	e030      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kAcInit: res_type = ResponseType::kR1; break;
   17f52:	2300      	movs	r3, #0
   17f54:	930d      	str	r3, [sp, #52]	; 0x34
   17f56:	e02d      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kGetOcr: res_type = ResponseType::kR3; break;
   17f58:	2303      	movs	r3, #3
   17f5a:	930d      	str	r3, [sp, #52]	; 0x34
   17f5c:	e02a      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kChgBlkLen: res_type = ResponseType::kR1; break;
   17f5e:	2300      	movs	r3, #0
   17f60:	930d      	str	r3, [sp, #52]	; 0x34
   17f62:	e027      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadSingle: res_type = ResponseType::kR1; break;
   17f64:	2300      	movs	r3, #0
   17f66:	930d      	str	r3, [sp, #52]	; 0x34
   17f68:	e024      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kReadMulti: res_type = ResponseType::kR1; break;
   17f6a:	2300      	movs	r3, #0
   17f6c:	930d      	str	r3, [sp, #52]	; 0x34
   17f6e:	e021      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteSingle: res_type = ResponseType::kR1; break;
   17f70:	2300      	movs	r3, #0
   17f72:	930d      	str	r3, [sp, #52]	; 0x34
   17f74:	e01e      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kWriteMulti: res_type = ResponseType::kR1; break;
   17f76:	2300      	movs	r3, #0
   17f78:	930d      	str	r3, [sp, #52]	; 0x34
   17f7a:	e01b      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelFrom: res_type = ResponseType::kR1; break;
   17f7c:	2300      	movs	r3, #0
   17f7e:	930d      	str	r3, [sp, #52]	; 0x34
   17f80:	e018      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDelTo: res_type = ResponseType::kR1; break;
   17f82:	2300      	movs	r3, #0
   17f84:	930d      	str	r3, [sp, #52]	; 0x34
   17f86:	e015      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      case Command::kDel: res_type = ResponseType::kR1b; break;
   17f88:	2301      	movs	r3, #1
   17f8a:	930d      	str	r3, [sp, #52]	; 0x34
   17f8c:	e012      	b.n	17fb4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x128>
      default:
        LOG_ERROR("Unknown response type. Aborting!");
   17f8e:	f240 33f3 	movw	r3, #1011	; 0x3f3
   17f92:	4a05      	ldr	r2, [pc, #20]	; (17fa8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x11c>)
   17f94:	4905      	ldr	r1, [pc, #20]	; (17fac <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x120>)
   17f96:	4806      	ldr	r0, [pc, #24]	; (17fb0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x124>)
   17f98:	f7fd ff60 	bl	15e5c <printf>
        return -1;
   17f9c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   17fa0:	e1b1      	b.n	18306 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
   17fa2:	bf00      	nop
   17fa4:	00017e8d 	.word	0x00017e8d
   17fa8:	0001aed4 	.word	0x0001aed4
   17fac:	0001abd0 	.word	0x0001abd0
   17fb0:	0001a708 	.word	0x0001a708
    // algorithm
    uint8_t msg[5] = { static_cast<uint8_t>(sdc),
                       static_cast<uint8_t>(arg >> 24),
                       static_cast<uint8_t>(arg >> 16),
                       static_cast<uint8_t>(arg >> 8),
                       static_cast<uint8_t>(arg >> 0) };
   17fb4:	9b02      	ldr	r3, [sp, #8]
   17fb6:	b2db      	uxtb	r3, r3
   17fb8:	f88d 3010 	strb.w	r3, [sp, #16]
                       static_cast<uint8_t>(arg >> 24),
   17fbc:	9b01      	ldr	r3, [sp, #4]
   17fbe:	0e1b      	lsrs	r3, r3, #24
                       static_cast<uint8_t>(arg >> 0) };
   17fc0:	b2db      	uxtb	r3, r3
   17fc2:	f88d 3011 	strb.w	r3, [sp, #17]
                       static_cast<uint8_t>(arg >> 16),
   17fc6:	9b01      	ldr	r3, [sp, #4]
   17fc8:	0c1b      	lsrs	r3, r3, #16
                       static_cast<uint8_t>(arg >> 0) };
   17fca:	b2db      	uxtb	r3, r3
   17fcc:	f88d 3012 	strb.w	r3, [sp, #18]
                       static_cast<uint8_t>(arg >> 8),
   17fd0:	9b01      	ldr	r3, [sp, #4]
   17fd2:	0a1b      	lsrs	r3, r3, #8
                       static_cast<uint8_t>(arg >> 0) };
   17fd4:	b2db      	uxtb	r3, r3
   17fd6:	f88d 3013 	strb.w	r3, [sp, #19]
   17fda:	9b01      	ldr	r3, [sp, #4]
   17fdc:	b2db      	uxtb	r3, r3
   17fde:	f88d 3014 	strb.w	r3, [sp, #20]

    crc = GetCrc7(msg, sizeof(msg));
   17fe2:	9b03      	ldr	r3, [sp, #12]
   17fe4:	681b      	ldr	r3, [r3, #0]
   17fe6:	331c      	adds	r3, #28
   17fe8:	681b      	ldr	r3, [r3, #0]
   17fea:	a904      	add	r1, sp, #16
   17fec:	2205      	movs	r2, #5
   17fee:	9803      	ldr	r0, [sp, #12]
   17ff0:	4798      	blx	r3
   17ff2:	4603      	mov	r3, r0
   17ff4:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    if (sdc == Command::kGarbage)
   17ff8:	9b02      	ldr	r3, [sp, #8]
   17ffa:	2bff      	cmp	r3, #255	; 0xff
   17ffc:	d102      	bne.n	18004 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x178>
    {
      crc = 0xFF;
   17ffe:	23ff      	movs	r3, #255	; 0xff
   18000:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    }

    // Select the SD Card
    chip_select_->SetLow();
   18004:	9b03      	ldr	r3, [sp, #12]
   18006:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   18008:	9b03      	ldr	r3, [sp, #12]
   1800a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1800c:	681b      	ldr	r3, [r3, #0]
   1800e:	3310      	adds	r3, #16
   18010:	681b      	ldr	r3, [r3, #0]
   18012:	4610      	mov	r0, r2
   18014:	4798      	blx	r3
    chip_select_external_->SetLow();
   18016:	9b03      	ldr	r3, [sp, #12]
   18018:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   1801a:	9b03      	ldr	r3, [sp, #12]
   1801c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   1801e:	681b      	ldr	r3, [r3, #0]
   18020:	3310      	adds	r3, #16
   18022:	681b      	ldr	r3, [r3, #0]
   18024:	4610      	mov	r0, r2
   18026:	4798      	blx	r3

    // If desired, wait a bit before talking
    if (delay > 0)
   18028:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1802a:	2b00      	cmp	r3, #0
   1802c:	d007      	beq.n	1803e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x1b2>
    {
      Delay(delay);
   1802e:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18030:	461a      	mov	r2, r3
   18032:	f04f 0300 	mov.w	r3, #0
   18036:	4610      	mov	r0, r2
   18038:	4619      	mov	r1, r3
   1803a:	f7f8 fc4d 	bl	108d8 <Delay(unsigned long long)>
    }

    // Send the desired command frame to the SD card board
    // Begin by transfering the command byte
    ssp_interface_->Transfer(static_cast<uint16_t>(sdc));
   1803e:	9b03      	ldr	r3, [sp, #12]
   18040:	685a      	ldr	r2, [r3, #4]
   18042:	9b03      	ldr	r3, [sp, #12]
   18044:	685b      	ldr	r3, [r3, #4]
   18046:	681b      	ldr	r3, [r3, #0]
   18048:	3308      	adds	r3, #8
   1804a:	681b      	ldr	r3, [r3, #0]
   1804c:	9902      	ldr	r1, [sp, #8]
   1804e:	b289      	uxth	r1, r1
   18050:	4610      	mov	r0, r2
   18052:	4798      	blx	r3
    // Send arg byte [31:24]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 24) & 0xFF);
   18054:	9b03      	ldr	r3, [sp, #12]
   18056:	6858      	ldr	r0, [r3, #4]
   18058:	9b03      	ldr	r3, [sp, #12]
   1805a:	685b      	ldr	r3, [r3, #4]
   1805c:	681b      	ldr	r3, [r3, #0]
   1805e:	3308      	adds	r3, #8
   18060:	681b      	ldr	r3, [r3, #0]
   18062:	9a01      	ldr	r2, [sp, #4]
   18064:	0e12      	lsrs	r2, r2, #24
   18066:	b292      	uxth	r2, r2
   18068:	b2d2      	uxtb	r2, r2
   1806a:	b292      	uxth	r2, r2
   1806c:	4611      	mov	r1, r2
   1806e:	4798      	blx	r3
    // Send arg byte [23:16]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 16) & 0xFF);
   18070:	9b03      	ldr	r3, [sp, #12]
   18072:	6858      	ldr	r0, [r3, #4]
   18074:	9b03      	ldr	r3, [sp, #12]
   18076:	685b      	ldr	r3, [r3, #4]
   18078:	681b      	ldr	r3, [r3, #0]
   1807a:	3308      	adds	r3, #8
   1807c:	681b      	ldr	r3, [r3, #0]
   1807e:	9a01      	ldr	r2, [sp, #4]
   18080:	0c12      	lsrs	r2, r2, #16
   18082:	b292      	uxth	r2, r2
   18084:	b2d2      	uxtb	r2, r2
   18086:	b292      	uxth	r2, r2
   18088:	4611      	mov	r1, r2
   1808a:	4798      	blx	r3
    // Send arg byte [15:8]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 8) & 0xFF);
   1808c:	9b03      	ldr	r3, [sp, #12]
   1808e:	6858      	ldr	r0, [r3, #4]
   18090:	9b03      	ldr	r3, [sp, #12]
   18092:	685b      	ldr	r3, [r3, #4]
   18094:	681b      	ldr	r3, [r3, #0]
   18096:	3308      	adds	r3, #8
   18098:	681b      	ldr	r3, [r3, #0]
   1809a:	9a01      	ldr	r2, [sp, #4]
   1809c:	0a12      	lsrs	r2, r2, #8
   1809e:	b292      	uxth	r2, r2
   180a0:	b2d2      	uxtb	r2, r2
   180a2:	b292      	uxth	r2, r2
   180a4:	4611      	mov	r1, r2
   180a6:	4798      	blx	r3
    // Send arg byte [7:0]
    ssp_interface_->Transfer(static_cast<uint16_t>(arg >> 0) & 0xFF);
   180a8:	9b03      	ldr	r3, [sp, #12]
   180aa:	685a      	ldr	r2, [r3, #4]
   180ac:	9b03      	ldr	r3, [sp, #12]
   180ae:	685b      	ldr	r3, [r3, #4]
   180b0:	681b      	ldr	r3, [r3, #0]
   180b2:	3308      	adds	r3, #8
   180b4:	681b      	ldr	r3, [r3, #0]
   180b6:	9901      	ldr	r1, [sp, #4]
   180b8:	b289      	uxth	r1, r1
   180ba:	b2c9      	uxtb	r1, r1
   180bc:	b289      	uxth	r1, r1
   180be:	4610      	mov	r0, r2
   180c0:	4798      	blx	r3
    // Send 7-bit CRC and LSB stop addr (as b1)
    ssp_interface_->Transfer(static_cast<uint16_t>(crc << 1) | 0x01);
   180c2:	9b03      	ldr	r3, [sp, #12]
   180c4:	6858      	ldr	r0, [r3, #4]
   180c6:	9b03      	ldr	r3, [sp, #12]
   180c8:	685b      	ldr	r3, [r3, #4]
   180ca:	681b      	ldr	r3, [r3, #0]
   180cc:	3308      	adds	r3, #8
   180ce:	681b      	ldr	r3, [r3, #0]
   180d0:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   180d4:	b292      	uxth	r2, r2
   180d6:	0052      	lsls	r2, r2, #1
   180d8:	b292      	uxth	r2, r2
   180da:	f042 0201 	orr.w	r2, r2, #1
   180de:	b292      	uxth	r2, r2
   180e0:	4611      	mov	r1, r2
   180e2:	4798      	blx	r3

    // Write garbage while waiting for a response
    // Send at least 1 byte of garbage before checking for a response
    temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   180e4:	9b03      	ldr	r3, [sp, #12]
   180e6:	685a      	ldr	r2, [r3, #4]
   180e8:	9b03      	ldr	r3, [sp, #12]
   180ea:	685b      	ldr	r3, [r3, #4]
   180ec:	681b      	ldr	r3, [r3, #0]
   180ee:	3308      	adds	r3, #8
   180f0:	681b      	ldr	r3, [r3, #0]
   180f2:	21ff      	movs	r1, #255	; 0xff
   180f4:	4610      	mov	r0, r2
   180f6:	4798      	blx	r3
   180f8:	4603      	mov	r3, r0
   180fa:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (tries++ < kBusTimeout)
   180fe:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   18102:	1c5a      	adds	r2, r3, #1
   18104:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   18108:	2bf9      	cmp	r3, #249	; 0xf9
   1810a:	bf94      	ite	ls
   1810c:	2301      	movls	r3, #1
   1810e:	2300      	movhi	r3, #0
   18110:	b2db      	uxtb	r3, r3
   18112:	2b00      	cmp	r3, #0
   18114:	d027      	beq.n	18166 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2da>
    {
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   18116:	9b03      	ldr	r3, [sp, #12]
   18118:	685a      	ldr	r2, [r3, #4]
   1811a:	9b03      	ldr	r3, [sp, #12]
   1811c:	685b      	ldr	r3, [r3, #4]
   1811e:	681b      	ldr	r3, [r3, #0]
   18120:	3308      	adds	r3, #8
   18122:	681b      	ldr	r3, [r3, #0]
   18124:	21ff      	movs	r1, #255	; 0xff
   18126:	4610      	mov	r0, r2
   18128:	4798      	blx	r3
   1812a:	4603      	mov	r3, r0
   1812c:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
      if (temp_byte != 0xFF)
   18130:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   18134:	2bff      	cmp	r3, #255	; 0xff
   18136:	d00f      	beq.n	18158 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2cc>
      {
        // Determine the offset, since the first byte of a
        // response will always be 0.
        while (temp_byte & (0x80 >> bit_offset))
   18138:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   1813c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18140:	2180      	movs	r1, #128	; 0x80
   18142:	fa41 f303 	asr.w	r3, r1, r3
   18146:	4013      	ands	r3, r2
   18148:	2b00      	cmp	r3, #0
   1814a:	d00b      	beq.n	18164 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2d8>
        {
          bit_offset++;
   1814c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   18150:	3301      	adds	r3, #1
   18152:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
        while (temp_byte & (0x80 >> bit_offset))
   18156:	e7ef      	b.n	18138 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2ac>
        }
        break;
      }
      tries++;
   18158:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   1815c:	3301      	adds	r3, #1
   1815e:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    while (tries++ < kBusTimeout)
   18162:	e7cc      	b.n	180fe <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x272>
        break;
   18164:	bf00      	nop
    }

    // Determine response length (in bytes) based on response type
    switch (res_type)
   18166:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18168:	2b07      	cmp	r3, #7
   1816a:	d827      	bhi.n	181bc <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x330>
   1816c:	a201      	add	r2, pc, #4	; (adr r2, 18174 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x2e8>)
   1816e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   18172:	bf00      	nop
   18174:	00018195 	.word	0x00018195
   18178:	0001819d 	.word	0x0001819d
   1817c:	000181a5 	.word	0x000181a5
   18180:	000181ad 	.word	0x000181ad
   18184:	000181bd 	.word	0x000181bd
   18188:	000181bd 	.word	0x000181bd
   1818c:	000181bd 	.word	0x000181bd
   18190:	000181b5 	.word	0x000181b5
    {
      case ResponseType::kR1: res_len = 1; break;
   18194:	2301      	movs	r3, #1
   18196:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   1819a:	e019      	b.n	181d0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR1b: res_len = 1; break;
   1819c:	2301      	movs	r3, #1
   1819e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   181a2:	e015      	b.n	181d0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR2: res_len = 2; break;
   181a4:	2302      	movs	r3, #2
   181a6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   181aa:	e011      	b.n	181d0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR3: res_len = 5; break;
   181ac:	2305      	movs	r3, #5
   181ae:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   181b2:	e00d      	b.n	181d0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      case ResponseType::kR7: res_len = 5; break;
   181b4:	2305      	movs	r3, #5
   181b6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
   181ba:	e009      	b.n	181d0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x344>
      default:
        LOG_ERROR("Response unsupported in SPI mode. Aborting!");
   181bc:	f240 433a 	movw	r3, #1082	; 0x43a
   181c0:	4a56      	ldr	r2, [pc, #344]	; (1831c <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x490>)
   181c2:	4957      	ldr	r1, [pc, #348]	; (18320 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x494>)
   181c4:	4857      	ldr	r0, [pc, #348]	; (18324 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x498>)
   181c6:	f7fd fe49 	bl	15e5c <printf>
        return -1;
   181ca:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   181ce:	e09a      	b.n	18306 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x47a>
        break;
    }

    // Acquire the response
    uint64_t temp_response = 0;
   181d0:	f04f 0200 	mov.w	r2, #0
   181d4:	f04f 0300 	mov.w	r3, #0
   181d8:	e9cd 2308 	strd	r2, r3, [sp, #32]
    // Read an extra 8 bits since the response was offset
    uint8_t bytes_to_read =
   181dc:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   181e0:	2b00      	cmp	r3, #0
   181e2:	d004      	beq.n	181ee <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x362>
   181e4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   181e8:	3301      	adds	r3, #1
   181ea:	b2db      	uxtb	r3, r3
   181ec:	e001      	b.n	181f2 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x366>
   181ee:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   181f2:	f88d 301f 	strb.w	r3, [sp, #31]
        static_cast<uint8_t>((bit_offset > 0) ? res_len + 1 : res_len);
    while (bytes_to_read-- > 0)
   181f6:	f89d 301f 	ldrb.w	r3, [sp, #31]
   181fa:	1e5a      	subs	r2, r3, #1
   181fc:	f88d 201f 	strb.w	r2, [sp, #31]
   18200:	2b00      	cmp	r3, #0
   18202:	bf14      	ite	ne
   18204:	2301      	movne	r3, #1
   18206:	2300      	moveq	r3, #0
   18208:	b2db      	uxtb	r3, r3
   1820a:	2b00      	cmp	r3, #0
   1820c:	d025      	beq.n	1825a <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x3ce>
    {
      // Make space for the next byte
      temp_response = temp_response << 8;
   1820e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   18212:	f04f 0200 	mov.w	r2, #0
   18216:	f04f 0300 	mov.w	r3, #0
   1821a:	020b      	lsls	r3, r1, #8
   1821c:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
   18220:	0202      	lsls	r2, r0, #8
   18222:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_response |= temp_byte;
   18226:	f89d b02f 	ldrb.w	fp, [sp, #47]	; 0x2f
   1822a:	f04f 0c00 	mov.w	ip, #0
   1822e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   18232:	ea4b 0200 	orr.w	r2, fp, r0
   18236:	ea4c 0301 	orr.w	r3, ip, r1
   1823a:	e9cd 2308 	strd	r2, r3, [sp, #32]
      temp_byte = static_cast<uint8_t>(ssp_interface_->Transfer(0xFF));
   1823e:	9b03      	ldr	r3, [sp, #12]
   18240:	685a      	ldr	r2, [r3, #4]
   18242:	9b03      	ldr	r3, [sp, #12]
   18244:	685b      	ldr	r3, [r3, #4]
   18246:	681b      	ldr	r3, [r3, #0]
   18248:	3308      	adds	r3, #8
   1824a:	681b      	ldr	r3, [r3, #0]
   1824c:	21ff      	movs	r1, #255	; 0xff
   1824e:	4610      	mov	r0, r2
   18250:	4798      	blx	r3
   18252:	4603      	mov	r3, r0
   18254:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    while (bytes_to_read-- > 0)
   18258:	e7cd      	b.n	181f6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x36a>
    }
    // Compensate for the bit offset
    temp_response = temp_response >> bit_offset;
   1825a:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
   1825e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   18262:	f1c1 0c20 	rsb	ip, r1, #32
   18266:	f1a1 0020 	sub.w	r0, r1, #32
   1826a:	fa22 f401 	lsr.w	r4, r2, r1
   1826e:	fa03 fc0c 	lsl.w	ip, r3, ip
   18272:	ea44 040c 	orr.w	r4, r4, ip
   18276:	fa23 f000 	lsr.w	r0, r3, r0
   1827a:	4304      	orrs	r4, r0
   1827c:	fa23 f501 	lsr.w	r5, r3, r1
   18280:	e9cd 4508 	strd	r4, r5, [sp, #32]

    // Only write to the response buffer if it is provided
    if (response_buffer != nullptr)
   18284:	9b00      	ldr	r3, [sp, #0]
   18286:	2b00      	cmp	r3, #0
   18288:	d025      	beq.n	182d6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
    {
      for (int i = 0; i < res_len; i++)
   1828a:	2300      	movs	r3, #0
   1828c:	9306      	str	r3, [sp, #24]
   1828e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   18292:	9a06      	ldr	r2, [sp, #24]
   18294:	429a      	cmp	r2, r3
   18296:	da1e      	bge.n	182d6 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x44a>
      {
        response_buffer[i] =
            static_cast<uint8_t>(temp_response >> 8 * (res_len - 1 - i));
   18298:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
   1829c:	1e5a      	subs	r2, r3, #1
   1829e:	9b06      	ldr	r3, [sp, #24]
   182a0:	1ad3      	subs	r3, r2, r3
   182a2:	00da      	lsls	r2, r3, #3
   182a4:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   182a8:	f1c2 0020 	rsb	r0, r2, #32
   182ac:	f1a2 0120 	sub.w	r1, r2, #32
   182b0:	fa23 f602 	lsr.w	r6, r3, r2
   182b4:	fa04 f000 	lsl.w	r0, r4, r0
   182b8:	4306      	orrs	r6, r0
   182ba:	fa24 f101 	lsr.w	r1, r4, r1
   182be:	430e      	orrs	r6, r1
   182c0:	fa24 f702 	lsr.w	r7, r4, r2
        response_buffer[i] =
   182c4:	9b06      	ldr	r3, [sp, #24]
   182c6:	9a00      	ldr	r2, [sp, #0]
   182c8:	4413      	add	r3, r2
   182ca:	b2f2      	uxtb	r2, r6
   182cc:	701a      	strb	r2, [r3, #0]
      for (int i = 0; i < res_len; i++)
   182ce:	9b06      	ldr	r3, [sp, #24]
   182d0:	3301      	adds	r3, #1
   182d2:	9306      	str	r3, [sp, #24]
   182d4:	e7db      	b.n	1828e <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x402>
      }
    }

    // Only end the transaction if keep_alive isn't requested
    if (keep_alive == KeepAlive::kNo)
   182d6:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
   182da:	2b00      	cmp	r3, #0
   182dc:	d111      	bne.n	18302 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x476>
    {
      // Deselect the SPI comm board
      chip_select_->SetHigh();
   182de:	9b03      	ldr	r3, [sp, #12]
   182e0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   182e2:	9b03      	ldr	r3, [sp, #12]
   182e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   182e6:	681b      	ldr	r3, [r3, #0]
   182e8:	330c      	adds	r3, #12
   182ea:	681b      	ldr	r3, [r3, #0]
   182ec:	4610      	mov	r0, r2
   182ee:	4798      	blx	r3
      chip_select_external_->SetHigh();
   182f0:	9b03      	ldr	r3, [sp, #12]
   182f2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   182f4:	9b03      	ldr	r3, [sp, #12]
   182f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   182f8:	681b      	ldr	r3, [r3, #0]
   182fa:	330c      	adds	r3, #12
   182fc:	681b      	ldr	r3, [r3, #0]
   182fe:	4610      	mov	r0, r2
   18300:	4798      	blx	r3
    }
    return res_len;
   18302:	f89d 4033 	ldrb.w	r4, [sp, #51]	; 0x33
   18306:	4643      	mov	r3, r8
   18308:	4619      	mov	r1, r3
   1830a:	4807      	ldr	r0, [pc, #28]	; (18328 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)+0x49c>)
   1830c:	f7fb f81e 	bl	1334c <__cyg_profile_func_exit>
   18310:	4623      	mov	r3, r4
  }
   18312:	4618      	mov	r0, r3
   18314:	b00f      	add	sp, #60	; 0x3c
   18316:	e8bd 89f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, fp, pc}
   1831a:	bf00      	nop
   1831c:	0001aed4 	.word	0x0001aed4
   18320:	0001abd8 	.word	0x0001abd8
   18324:	0001a764 	.word	0x0001a764
   18328:	00017e8d 	.word	0x00017e8d

0001832c <Sd::Crc7Add(unsigned char, unsigned char)>:

  // Adds a message byte to the current CRC-7 to get a the new CRC-7
  uint8_t Crc7Add(uint8_t crc, uint8_t message_byte) override
   1832c:	b530      	push	{r4, r5, lr}
   1832e:	b083      	sub	sp, #12
   18330:	4675      	mov	r5, lr
   18332:	9001      	str	r0, [sp, #4]
   18334:	460b      	mov	r3, r1
   18336:	f88d 3003 	strb.w	r3, [sp, #3]
   1833a:	4613      	mov	r3, r2
   1833c:	f88d 3002 	strb.w	r3, [sp, #2]
   18340:	462b      	mov	r3, r5
   18342:	4619      	mov	r1, r3
   18344:	4809      	ldr	r0, [pc, #36]	; (1836c <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   18346:	f7fa ffed 	bl	13324 <__cyg_profile_func_enter>
  {
    return kCrcTable8.crc_table[(crc << 1) ^ message_byte];
   1834a:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1834e:	005a      	lsls	r2, r3, #1
   18350:	f89d 3002 	ldrb.w	r3, [sp, #2]
   18354:	4053      	eors	r3, r2
   18356:	4a06      	ldr	r2, [pc, #24]	; (18370 <Sd::Crc7Add(unsigned char, unsigned char)+0x44>)
   18358:	5cd4      	ldrb	r4, [r2, r3]
   1835a:	462b      	mov	r3, r5
   1835c:	4619      	mov	r1, r3
   1835e:	4803      	ldr	r0, [pc, #12]	; (1836c <Sd::Crc7Add(unsigned char, unsigned char)+0x40>)
   18360:	f7fa fff4 	bl	1334c <__cyg_profile_func_exit>
   18364:	4623      	mov	r3, r4
  }
   18366:	4618      	mov	r0, r3
   18368:	b003      	add	sp, #12
   1836a:	bd30      	pop	{r4, r5, pc}
   1836c:	0001832d 	.word	0x0001832d
   18370:	0001a848 	.word	0x0001a848

00018374 <Sd::GetCrc7(unsigned char*, unsigned char)>:

  // Returns the CRC-7 for a message of "length" bytes
  uint8_t GetCrc7(uint8_t * message, uint8_t length) override
   18374:	b530      	push	{r4, r5, lr}
   18376:	b087      	sub	sp, #28
   18378:	4675      	mov	r5, lr
   1837a:	9003      	str	r0, [sp, #12]
   1837c:	9102      	str	r1, [sp, #8]
   1837e:	4613      	mov	r3, r2
   18380:	f88d 3007 	strb.w	r3, [sp, #7]
   18384:	462b      	mov	r3, r5
   18386:	4619      	mov	r1, r3
   18388:	4815      	ldr	r0, [pc, #84]	; (183e0 <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   1838a:	f7fa ffcb 	bl	13324 <__cyg_profile_func_enter>
  {
    uint8_t crc = 0;
   1838e:	2300      	movs	r3, #0
   18390:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   18394:	2300      	movs	r3, #0
   18396:	9304      	str	r3, [sp, #16]
   18398:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1839c:	9a04      	ldr	r2, [sp, #16]
   1839e:	429a      	cmp	r2, r3
   183a0:	da12      	bge.n	183c8 <Sd::GetCrc7(unsigned char*, unsigned char)+0x54>
    {
      crc = Crc7Add(crc, message[i]);
   183a2:	9b03      	ldr	r3, [sp, #12]
   183a4:	681b      	ldr	r3, [r3, #0]
   183a6:	3318      	adds	r3, #24
   183a8:	681b      	ldr	r3, [r3, #0]
   183aa:	9a04      	ldr	r2, [sp, #16]
   183ac:	9902      	ldr	r1, [sp, #8]
   183ae:	440a      	add	r2, r1
   183b0:	7812      	ldrb	r2, [r2, #0]
   183b2:	f89d 1017 	ldrb.w	r1, [sp, #23]
   183b6:	9803      	ldr	r0, [sp, #12]
   183b8:	4798      	blx	r3
   183ba:	4603      	mov	r3, r0
   183bc:	f88d 3017 	strb.w	r3, [sp, #23]
    for (int i = 0; i < length; i++)
   183c0:	9b04      	ldr	r3, [sp, #16]
   183c2:	3301      	adds	r3, #1
   183c4:	9304      	str	r3, [sp, #16]
   183c6:	e7e7      	b.n	18398 <Sd::GetCrc7(unsigned char*, unsigned char)+0x24>
    }
    return crc;
   183c8:	f89d 4017 	ldrb.w	r4, [sp, #23]
   183cc:	462b      	mov	r3, r5
   183ce:	4619      	mov	r1, r3
   183d0:	4803      	ldr	r0, [pc, #12]	; (183e0 <Sd::GetCrc7(unsigned char*, unsigned char)+0x6c>)
   183d2:	f7fa ffbb 	bl	1334c <__cyg_profile_func_exit>
   183d6:	4623      	mov	r3, r4
  }
   183d8:	4618      	mov	r0, r3
   183da:	b007      	add	sp, #28
   183dc:	bd30      	pop	{r4, r5, pc}
   183de:	bf00      	nop
   183e0:	00018375 	.word	0x00018375

000183e4 <Sd::GetCrc16(unsigned char*, unsigned short)>:

  // Returns CCITT CRC-16 for a message of "length" bytes
  uint16_t GetCrc16(uint8_t * message, uint16_t length) override
   183e4:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   183e8:	b08c      	sub	sp, #48	; 0x30
   183ea:	4677      	mov	r7, lr
   183ec:	9003      	str	r0, [sp, #12]
   183ee:	9102      	str	r1, [sp, #8]
   183f0:	4613      	mov	r3, r2
   183f2:	f8ad 3006 	strh.w	r3, [sp, #6]
   183f6:	463b      	mov	r3, r7
   183f8:	4619      	mov	r1, r3
   183fa:	4837      	ldr	r0, [pc, #220]	; (184d8 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   183fc:	f7fa ff92 	bl	13324 <__cyg_profile_func_enter>
  {
    uint64_t crc = 0x0000;
   18400:	f04f 0300 	mov.w	r3, #0
   18404:	f04f 0400 	mov.w	r4, #0
   18408:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    uint64_t temp;
    uint64_t final_value = 0;
   1840c:	f04f 0300 	mov.w	r3, #0
   18410:	f04f 0400 	mov.w	r4, #0
   18414:	e9cd 3406 	strd	r3, r4, [sp, #24]

    for (uint64_t count = 0; count < length; ++count)
   18418:	f04f 0300 	mov.w	r3, #0
   1841c:	f04f 0400 	mov.w	r4, #0
   18420:	e9cd 3408 	strd	r3, r4, [sp, #32]
   18424:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   18428:	f04f 0400 	mov.w	r4, #0
   1842c:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
   18430:	42a2      	cmp	r2, r4
   18432:	bf08      	it	eq
   18434:	4299      	cmpeq	r1, r3
   18436:	d23f      	bcs.n	184b8 <Sd::GetCrc16(unsigned char*, unsigned short)+0xd4>
    {
      temp = (*message++ ^ (crc >> 8)) & 0xff;
   18438:	9b02      	ldr	r3, [sp, #8]
   1843a:	1c5a      	adds	r2, r3, #1
   1843c:	9202      	str	r2, [sp, #8]
   1843e:	781b      	ldrb	r3, [r3, #0]
   18440:	b2dd      	uxtb	r5, r3
   18442:	f04f 0600 	mov.w	r6, #0
   18446:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   1844a:	f04f 0300 	mov.w	r3, #0
   1844e:	f04f 0400 	mov.w	r4, #0
   18452:	0a0b      	lsrs	r3, r1, #8
   18454:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   18458:	0a14      	lsrs	r4, r2, #8
   1845a:	ea83 0b05 	eor.w	fp, r3, r5
   1845e:	ea84 0c06 	eor.w	ip, r4, r6
   18462:	f04f 01ff 	mov.w	r1, #255	; 0xff
   18466:	f04f 0200 	mov.w	r2, #0
   1846a:	ea0b 0301 	and.w	r3, fp, r1
   1846e:	ea0c 0402 	and.w	r4, ip, r2
   18472:	e9cd 3404 	strd	r3, r4, [sp, #16]
      crc  = kCrcTable16.crc_table[temp] ^ (crc << 8);
   18476:	4a19      	ldr	r2, [pc, #100]	; (184dc <Sd::GetCrc16(unsigned char*, unsigned short)+0xf8>)
   18478:	9b04      	ldr	r3, [sp, #16]
   1847a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   1847e:	b29d      	uxth	r5, r3
   18480:	f04f 0600 	mov.w	r6, #0
   18484:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
   18488:	f04f 0b00 	mov.w	fp, #0
   1848c:	f04f 0c00 	mov.w	ip, #0
   18490:	ea4f 2c02 	mov.w	ip, r2, lsl #8
   18494:	ea4c 6c11 	orr.w	ip, ip, r1, lsr #24
   18498:	ea4f 2b01 	mov.w	fp, r1, lsl #8
   1849c:	ea8b 0305 	eor.w	r3, fp, r5
   184a0:	ea8c 0406 	eor.w	r4, ip, r6
   184a4:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
    for (uint64_t count = 0; count < length; ++count)
   184a8:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   184ac:	1c59      	adds	r1, r3, #1
   184ae:	f144 0200 	adc.w	r2, r4, #0
   184b2:	e9cd 1208 	strd	r1, r2, [sp, #32]
   184b6:	e7b5      	b.n	18424 <Sd::GetCrc16(unsigned char*, unsigned short)+0x40>
    }

    return static_cast<uint16_t>(crc ^ final_value);
   184b8:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   184bc:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   184c0:	4053      	eors	r3, r2
   184c2:	b29c      	uxth	r4, r3
   184c4:	463b      	mov	r3, r7
   184c6:	4619      	mov	r1, r3
   184c8:	4803      	ldr	r0, [pc, #12]	; (184d8 <Sd::GetCrc16(unsigned char*, unsigned short)+0xf4>)
   184ca:	f7fa ff3f 	bl	1334c <__cyg_profile_func_exit>
   184ce:	4623      	mov	r3, r4
  }
   184d0:	4618      	mov	r0, r3
   184d2:	b00c      	add	sp, #48	; 0x30
   184d4:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   184d8:	000183e5 	.word	0x000183e5
   184dc:	0001a948 	.word	0x0001a948

000184e0 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)>:
constexpr T Set(T target, uint32_t position)
   184e0:	b530      	push	{r4, r5, lr}
   184e2:	b083      	sub	sp, #12
   184e4:	4675      	mov	r5, lr
   184e6:	9001      	str	r0, [sp, #4]
   184e8:	9100      	str	r1, [sp, #0]
   184ea:	462b      	mov	r3, r5
   184ec:	4619      	mov	r1, r3
   184ee:	480a      	ldr	r0, [pc, #40]	; (18518 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   184f0:	f7fa ff18 	bl	13324 <__cyg_profile_func_enter>
  return target | (1 << position);
   184f4:	2201      	movs	r2, #1
   184f6:	9b00      	ldr	r3, [sp, #0]
   184f8:	fa02 f303 	lsl.w	r3, r2, r3
   184fc:	461a      	mov	r2, r3
   184fe:	9b01      	ldr	r3, [sp, #4]
   18500:	ea42 0403 	orr.w	r4, r2, r3
   18504:	462b      	mov	r3, r5
   18506:	4619      	mov	r1, r3
   18508:	4803      	ldr	r0, [pc, #12]	; (18518 <unsigned long bit::Set<unsigned long>(unsigned long, unsigned long)+0x38>)
   1850a:	f7fa ff1f 	bl	1334c <__cyg_profile_func_exit>
   1850e:	4623      	mov	r3, r4
}
   18510:	4618      	mov	r0, r3
   18512:	b003      	add	sp, #12
   18514:	bd30      	pop	{r4, r5, pc}
   18516:	bf00      	nop
   18518:	000184e1 	.word	0x000184e1

0001851c <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   1851c:	b530      	push	{r4, r5, lr}
   1851e:	b089      	sub	sp, #36	; 0x24
   18520:	4675      	mov	r5, lr
   18522:	9003      	str	r0, [sp, #12]
   18524:	9201      	str	r2, [sp, #4]
   18526:	9300      	str	r3, [sp, #0]
   18528:	460b      	mov	r3, r1
   1852a:	f88d 300b 	strb.w	r3, [sp, #11]
   1852e:	462b      	mov	r3, r5
   18530:	4619      	mov	r1, r3
   18532:	4816      	ldr	r0, [pc, #88]	; (1858c <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   18534:	f7fa fef6 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   18538:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1853c:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   1853e:	2320      	movs	r3, #32
   18540:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   18542:	9b00      	ldr	r3, [sp, #0]
   18544:	f1c3 0320 	rsb	r3, r3, #32
   18548:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1854c:	fa22 f303 	lsr.w	r3, r2, r3
   18550:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   18552:	9a05      	ldr	r2, [sp, #20]
   18554:	9b01      	ldr	r3, [sp, #4]
   18556:	fa02 f303 	lsl.w	r3, r2, r3
   1855a:	43db      	mvns	r3, r3
   1855c:	9a03      	ldr	r2, [sp, #12]
   1855e:	4013      	ands	r3, r2
   18560:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   18562:	f89d 200b 	ldrb.w	r2, [sp, #11]
   18566:	9b05      	ldr	r3, [sp, #20]
   18568:	401a      	ands	r2, r3
   1856a:	9b01      	ldr	r3, [sp, #4]
   1856c:	fa02 f303 	lsl.w	r3, r2, r3
   18570:	9a03      	ldr	r2, [sp, #12]
   18572:	4313      	orrs	r3, r2
   18574:	9303      	str	r3, [sp, #12]
  return target;
   18576:	9c03      	ldr	r4, [sp, #12]
   18578:	462b      	mov	r3, r5
   1857a:	4619      	mov	r1, r3
   1857c:	4803      	ldr	r0, [pc, #12]	; (1858c <unsigned long bit::Insert<unsigned long, unsigned char>(unsigned long, unsigned char, unsigned long, unsigned long)+0x70>)
   1857e:	f7fa fee5 	bl	1334c <__cyg_profile_func_exit>
   18582:	4623      	mov	r3, r4
}
   18584:	4618      	mov	r0, r3
   18586:	b009      	add	sp, #36	; 0x24
   18588:	bd30      	pop	{r4, r5, pc}
   1858a:	bf00      	nop
   1858c:	0001851d 	.word	0x0001851d

00018590 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)>:
constexpr T Extract(T target, uint32_t position, uint32_t width = 1)
   18590:	b530      	push	{r4, r5, lr}
   18592:	b089      	sub	sp, #36	; 0x24
   18594:	4675      	mov	r5, lr
   18596:	9003      	str	r0, [sp, #12]
   18598:	9102      	str	r1, [sp, #8]
   1859a:	9201      	str	r2, [sp, #4]
   1859c:	462b      	mov	r3, r5
   1859e:	4619      	mov	r1, r3
   185a0:	480f      	ldr	r0, [pc, #60]	; (185e0 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   185a2:	f7fa febf 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   185a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   185aa:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   185ac:	2320      	movs	r3, #32
   185ae:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   185b0:	9b01      	ldr	r3, [sp, #4]
   185b2:	f1c3 0320 	rsb	r3, r3, #32
   185b6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   185ba:	fa22 f303 	lsr.w	r3, r2, r3
   185be:	9305      	str	r3, [sp, #20]
  return (target >> position) & mask;
   185c0:	9a03      	ldr	r2, [sp, #12]
   185c2:	9b02      	ldr	r3, [sp, #8]
   185c4:	40da      	lsrs	r2, r3
   185c6:	9b05      	ldr	r3, [sp, #20]
   185c8:	ea02 0403 	and.w	r4, r2, r3
   185cc:	462b      	mov	r3, r5
   185ce:	4619      	mov	r1, r3
   185d0:	4803      	ldr	r0, [pc, #12]	; (185e0 <unsigned long bit::Extract<unsigned long>(unsigned long, unsigned long, unsigned long)+0x50>)
   185d2:	f7fa febb 	bl	1334c <__cyg_profile_func_exit>
   185d6:	4623      	mov	r3, r4
}
   185d8:	4618      	mov	r0, r3
   185da:	b009      	add	sp, #36	; 0x24
   185dc:	bd30      	pop	{r4, r5, pc}
   185de:	bf00      	nop
   185e0:	00018591 	.word	0x00018591

000185e4 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)>:
constexpr T Insert(T target, U value, uint32_t position, uint32_t width = 1)
   185e4:	b530      	push	{r4, r5, lr}
   185e6:	b089      	sub	sp, #36	; 0x24
   185e8:	4675      	mov	r5, lr
   185ea:	9003      	str	r0, [sp, #12]
   185ec:	9201      	str	r2, [sp, #4]
   185ee:	9300      	str	r3, [sp, #0]
   185f0:	460b      	mov	r3, r1
   185f2:	f88d 300b 	strb.w	r3, [sp, #11]
   185f6:	462b      	mov	r3, r5
   185f8:	4619      	mov	r1, r3
   185fa:	4816      	ldr	r0, [pc, #88]	; (18654 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   185fc:	f7fa fe92 	bl	13324 <__cyg_profile_func_enter>
  constexpr UnsignedT kFieldOfOnes = GenerateFieldOfOnes<T>();
   18600:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   18604:	9307      	str	r3, [sp, #28]
  constexpr size_t kTargetWidth     = sizeof(T) * 8;
   18606:	2320      	movs	r3, #32
   18608:	9306      	str	r3, [sp, #24]
  UnsignedT mask   = kFieldOfOnes >> (kTargetWidth - width);
   1860a:	9b00      	ldr	r3, [sp, #0]
   1860c:	f1c3 0320 	rsb	r3, r3, #32
   18610:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   18614:	fa22 f303 	lsr.w	r3, r2, r3
   18618:	9305      	str	r3, [sp, #20]
  target &= ~(mask << position);
   1861a:	9a05      	ldr	r2, [sp, #20]
   1861c:	9b01      	ldr	r3, [sp, #4]
   1861e:	fa02 f303 	lsl.w	r3, r2, r3
   18622:	43db      	mvns	r3, r3
   18624:	9a03      	ldr	r2, [sp, #12]
   18626:	4013      	ands	r3, r2
   18628:	9303      	str	r3, [sp, #12]
  target |= (value & mask) << position;
   1862a:	f89d 200b 	ldrb.w	r2, [sp, #11]
   1862e:	9b05      	ldr	r3, [sp, #20]
   18630:	401a      	ands	r2, r3
   18632:	9b01      	ldr	r3, [sp, #4]
   18634:	fa02 f303 	lsl.w	r3, r2, r3
   18638:	9a03      	ldr	r2, [sp, #12]
   1863a:	4313      	orrs	r3, r2
   1863c:	9303      	str	r3, [sp, #12]
  return target;
   1863e:	9c03      	ldr	r4, [sp, #12]
   18640:	462b      	mov	r3, r5
   18642:	4619      	mov	r1, r3
   18644:	4803      	ldr	r0, [pc, #12]	; (18654 <unsigned long bit::Insert<unsigned long, bool>(unsigned long, bool, unsigned long, unsigned long)+0x70>)
   18646:	f7fa fe81 	bl	1334c <__cyg_profile_func_exit>
   1864a:	4623      	mov	r3, r4
}
   1864c:	4618      	mov	r0, r3
   1864e:	b009      	add	sp, #36	; 0x24
   18650:	bd30      	pop	{r4, r5, pc}
   18652:	bf00      	nop
   18654:	000185e5 	.word	0x000185e5

00018658 <__static_initialization_and_destruction_0(int, int)>:
extern "C" DRESULT disk_ioctl([[maybe_unused]] BYTE drive_number,
                              [[maybe_unused]] BYTE command,
                              [[maybe_unused]] void * buffer)
{
  return RES_PARERR;
}
   18658:	b530      	push	{r4, r5, lr}
   1865a:	b085      	sub	sp, #20
   1865c:	4674      	mov	r4, lr
   1865e:	9003      	str	r0, [sp, #12]
   18660:	9102      	str	r1, [sp, #8]
   18662:	4623      	mov	r3, r4
   18664:	4619      	mov	r1, r3
   18666:	480e      	ldr	r0, [pc, #56]	; (186a0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   18668:	f7fa fe5c 	bl	13324 <__cyg_profile_func_enter>
   1866c:	9b03      	ldr	r3, [sp, #12]
   1866e:	2b01      	cmp	r3, #1
   18670:	d10e      	bne.n	18690 <__static_initialization_and_destruction_0(int, int)+0x38>
   18672:	9b02      	ldr	r3, [sp, #8]
   18674:	f64f 72ff 	movw	r2, #65535	; 0xffff
   18678:	4293      	cmp	r3, r2
   1867a:	d109      	bne.n	18690 <__static_initialization_and_destruction_0(int, int)+0x38>
Sd sd_card(Sd::DebugSdCard_t{});
   1867c:	2306      	movs	r3, #6
   1867e:	9301      	str	r3, [sp, #4]
   18680:	2300      	movs	r3, #0
   18682:	9300      	str	r3, [sp, #0]
   18684:	2308      	movs	r3, #8
   18686:	2201      	movs	r2, #1
   18688:	4629      	mov	r1, r5
   1868a:	4806      	ldr	r0, [pc, #24]	; (186a4 <__static_initialization_and_destruction_0(int, int)+0x4c>)
   1868c:	f7fe fdda 	bl	17244 <Sd::Sd(Sd::DebugSdCard_t, unsigned char, unsigned char, unsigned char, unsigned char)>
   18690:	4623      	mov	r3, r4
   18692:	4619      	mov	r1, r3
   18694:	4802      	ldr	r0, [pc, #8]	; (186a0 <__static_initialization_and_destruction_0(int, int)+0x48>)
   18696:	f7fa fe59 	bl	1334c <__cyg_profile_func_exit>
}
   1869a:	bf00      	nop
   1869c:	b005      	add	sp, #20
   1869e:	bd30      	pop	{r4, r5, pc}
   186a0:	00018659 	.word	0x00018659
   186a4:	100008cc 	.word	0x100008cc

000186a8 <_GLOBAL__sub_I_disk_status>:
   186a8:	b510      	push	{r4, lr}
   186aa:	4674      	mov	r4, lr
   186ac:	4623      	mov	r3, r4
   186ae:	4619      	mov	r1, r3
   186b0:	4806      	ldr	r0, [pc, #24]	; (186cc <_GLOBAL__sub_I_disk_status+0x24>)
   186b2:	f7fa fe37 	bl	13324 <__cyg_profile_func_enter>
   186b6:	f64f 71ff 	movw	r1, #65535	; 0xffff
   186ba:	2001      	movs	r0, #1
   186bc:	f7ff ffcc 	bl	18658 <__static_initialization_and_destruction_0(int, int)>
   186c0:	4623      	mov	r3, r4
   186c2:	4619      	mov	r1, r3
   186c4:	4801      	ldr	r0, [pc, #4]	; (186cc <_GLOBAL__sub_I_disk_status+0x24>)
   186c6:	f7fa fe41 	bl	1334c <__cyg_profile_func_exit>
   186ca:	bd10      	pop	{r4, pc}
   186cc:	000186a9 	.word	0x000186a9

000186d0 <__cxa_pure_virtual>:
   186d0:	b508      	push	{r3, lr}
   186d2:	f000 f80d 	bl	186f0 <std::terminate()>

000186d6 <__cxxabiv1::__terminate(void (*)())>:
   186d6:	b508      	push	{r3, lr}
   186d8:	4780      	blx	r0
   186da:	f000 fa0f 	bl	18afc <abort>
   186de:	Address 0x00000000000186de is out of bounds.


000186e0 <std::get_terminate()>:
   186e0:	4b02      	ldr	r3, [pc, #8]	; (186ec <std::get_terminate()+0xc>)
   186e2:	6818      	ldr	r0, [r3, #0]
   186e4:	f3bf 8f5b 	dmb	ish
   186e8:	4770      	bx	lr
   186ea:	bf00      	nop
   186ec:	1000021c 	.word	0x1000021c

000186f0 <std::terminate()>:
   186f0:	b508      	push	{r3, lr}
   186f2:	f7ff fff5 	bl	186e0 <std::get_terminate()>
   186f6:	f7ff ffee 	bl	186d6 <__cxxabiv1::__terminate(void (*)())>
   186fa:	Address 0x00000000000186fa is out of bounds.


000186fc <roundf>:
   186fc:	b082      	sub	sp, #8
   186fe:	ed8d 0a01 	vstr	s0, [sp, #4]
   18702:	9901      	ldr	r1, [sp, #4]
   18704:	f3c1 53c7 	ubfx	r3, r1, #23, #8
   18708:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
   1870c:	2a16      	cmp	r2, #22
   1870e:	dc0c      	bgt.n	1872a <roundf+0x2e>
   18710:	2a00      	cmp	r2, #0
   18712:	db10      	blt.n	18736 <roundf+0x3a>
   18714:	4810      	ldr	r0, [pc, #64]	; (18758 <roundf+0x5c>)
   18716:	4110      	asrs	r0, r2
   18718:	4201      	tst	r1, r0
   1871a:	d008      	beq.n	1872e <roundf+0x32>
   1871c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   18720:	4113      	asrs	r3, r2
   18722:	440b      	add	r3, r1
   18724:	ea23 0300 	bic.w	r3, r3, r0
   18728:	e00b      	b.n	18742 <roundf+0x46>
   1872a:	2a80      	cmp	r2, #128	; 0x80
   1872c:	d00d      	beq.n	1874a <roundf+0x4e>
   1872e:	ed9d 0a01 	vldr	s0, [sp, #4]
   18732:	b002      	add	sp, #8
   18734:	4770      	bx	lr
   18736:	3201      	adds	r2, #1
   18738:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
   1873c:	d101      	bne.n	18742 <roundf+0x46>
   1873e:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
   18742:	ee00 3a10 	vmov	s0, r3
   18746:	b002      	add	sp, #8
   18748:	4770      	bx	lr
   1874a:	eddd 7a01 	vldr	s15, [sp, #4]
   1874e:	ee37 0aa7 	vadd.f32	s0, s15, s15
   18752:	b002      	add	sp, #8
   18754:	4770      	bx	lr
   18756:	bf00      	nop
   18758:	007fffff 	.word	0x007fffff

0001875c <__aeabi_d2f>:
   1875c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   18760:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   18764:	bf24      	itt	cs
   18766:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1876a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1876e:	d90d      	bls.n	1878c <__aeabi_d2f+0x30>
   18770:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   18774:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   18778:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   1877c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   18780:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   18784:	bf08      	it	eq
   18786:	f020 0001 	biceq.w	r0, r0, #1
   1878a:	4770      	bx	lr
   1878c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   18790:	d121      	bne.n	187d6 <__aeabi_d2f+0x7a>
   18792:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   18796:	bfbc      	itt	lt
   18798:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   1879c:	4770      	bxlt	lr
   1879e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   187a2:	ea4f 5252 	mov.w	r2, r2, lsr #21
   187a6:	f1c2 0218 	rsb	r2, r2, #24
   187aa:	f1c2 0c20 	rsb	ip, r2, #32
   187ae:	fa10 f30c 	lsls.w	r3, r0, ip
   187b2:	fa20 f002 	lsr.w	r0, r0, r2
   187b6:	bf18      	it	ne
   187b8:	f040 0001 	orrne.w	r0, r0, #1
   187bc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   187c0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   187c4:	fa03 fc0c 	lsl.w	ip, r3, ip
   187c8:	ea40 000c 	orr.w	r0, r0, ip
   187cc:	fa23 f302 	lsr.w	r3, r3, r2
   187d0:	ea4f 0343 	mov.w	r3, r3, lsl #1
   187d4:	e7cc      	b.n	18770 <__aeabi_d2f+0x14>
   187d6:	ea7f 5362 	mvns.w	r3, r2, asr #21
   187da:	d107      	bne.n	187ec <__aeabi_d2f+0x90>
   187dc:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   187e0:	bf1e      	ittt	ne
   187e2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   187e6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   187ea:	4770      	bxne	lr
   187ec:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   187f0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   187f4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   187f8:	4770      	bx	lr
   187fa:	bf00      	nop

000187fc <__aeabi_uldivmod>:
   187fc:	b953      	cbnz	r3, 18814 <__aeabi_uldivmod+0x18>
   187fe:	b94a      	cbnz	r2, 18814 <__aeabi_uldivmod+0x18>
   18800:	2900      	cmp	r1, #0
   18802:	bf08      	it	eq
   18804:	2800      	cmpeq	r0, #0
   18806:	bf1c      	itt	ne
   18808:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1880c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   18810:	f000 b972 	b.w	18af8 <__aeabi_idiv0>
   18814:	f1ad 0c08 	sub.w	ip, sp, #8
   18818:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1881c:	f000 f806 	bl	1882c <__udivmoddi4>
   18820:	f8dd e004 	ldr.w	lr, [sp, #4]
   18824:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   18828:	b004      	add	sp, #16
   1882a:	4770      	bx	lr

0001882c <__udivmoddi4>:
   1882c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   18830:	9e08      	ldr	r6, [sp, #32]
   18832:	4604      	mov	r4, r0
   18834:	4688      	mov	r8, r1
   18836:	2b00      	cmp	r3, #0
   18838:	d14b      	bne.n	188d2 <__udivmoddi4+0xa6>
   1883a:	428a      	cmp	r2, r1
   1883c:	4615      	mov	r5, r2
   1883e:	d967      	bls.n	18910 <__udivmoddi4+0xe4>
   18840:	fab2 f282 	clz	r2, r2
   18844:	b14a      	cbz	r2, 1885a <__udivmoddi4+0x2e>
   18846:	f1c2 0720 	rsb	r7, r2, #32
   1884a:	fa01 f302 	lsl.w	r3, r1, r2
   1884e:	fa20 f707 	lsr.w	r7, r0, r7
   18852:	4095      	lsls	r5, r2
   18854:	ea47 0803 	orr.w	r8, r7, r3
   18858:	4094      	lsls	r4, r2
   1885a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1885e:	0c23      	lsrs	r3, r4, #16
   18860:	fbb8 f7fe 	udiv	r7, r8, lr
   18864:	fa1f fc85 	uxth.w	ip, r5
   18868:	fb0e 8817 	mls	r8, lr, r7, r8
   1886c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   18870:	fb07 f10c 	mul.w	r1, r7, ip
   18874:	4299      	cmp	r1, r3
   18876:	d909      	bls.n	1888c <__udivmoddi4+0x60>
   18878:	18eb      	adds	r3, r5, r3
   1887a:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   1887e:	f080 811b 	bcs.w	18ab8 <__udivmoddi4+0x28c>
   18882:	4299      	cmp	r1, r3
   18884:	f240 8118 	bls.w	18ab8 <__udivmoddi4+0x28c>
   18888:	3f02      	subs	r7, #2
   1888a:	442b      	add	r3, r5
   1888c:	1a5b      	subs	r3, r3, r1
   1888e:	b2a4      	uxth	r4, r4
   18890:	fbb3 f0fe 	udiv	r0, r3, lr
   18894:	fb0e 3310 	mls	r3, lr, r0, r3
   18898:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1889c:	fb00 fc0c 	mul.w	ip, r0, ip
   188a0:	45a4      	cmp	ip, r4
   188a2:	d909      	bls.n	188b8 <__udivmoddi4+0x8c>
   188a4:	192c      	adds	r4, r5, r4
   188a6:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   188aa:	f080 8107 	bcs.w	18abc <__udivmoddi4+0x290>
   188ae:	45a4      	cmp	ip, r4
   188b0:	f240 8104 	bls.w	18abc <__udivmoddi4+0x290>
   188b4:	3802      	subs	r0, #2
   188b6:	442c      	add	r4, r5
   188b8:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   188bc:	eba4 040c 	sub.w	r4, r4, ip
   188c0:	2700      	movs	r7, #0
   188c2:	b11e      	cbz	r6, 188cc <__udivmoddi4+0xa0>
   188c4:	40d4      	lsrs	r4, r2
   188c6:	2300      	movs	r3, #0
   188c8:	e9c6 4300 	strd	r4, r3, [r6]
   188cc:	4639      	mov	r1, r7
   188ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   188d2:	428b      	cmp	r3, r1
   188d4:	d909      	bls.n	188ea <__udivmoddi4+0xbe>
   188d6:	2e00      	cmp	r6, #0
   188d8:	f000 80eb 	beq.w	18ab2 <__udivmoddi4+0x286>
   188dc:	2700      	movs	r7, #0
   188de:	e9c6 0100 	strd	r0, r1, [r6]
   188e2:	4638      	mov	r0, r7
   188e4:	4639      	mov	r1, r7
   188e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   188ea:	fab3 f783 	clz	r7, r3
   188ee:	2f00      	cmp	r7, #0
   188f0:	d147      	bne.n	18982 <__udivmoddi4+0x156>
   188f2:	428b      	cmp	r3, r1
   188f4:	d302      	bcc.n	188fc <__udivmoddi4+0xd0>
   188f6:	4282      	cmp	r2, r0
   188f8:	f200 80fa 	bhi.w	18af0 <__udivmoddi4+0x2c4>
   188fc:	1a84      	subs	r4, r0, r2
   188fe:	eb61 0303 	sbc.w	r3, r1, r3
   18902:	2001      	movs	r0, #1
   18904:	4698      	mov	r8, r3
   18906:	2e00      	cmp	r6, #0
   18908:	d0e0      	beq.n	188cc <__udivmoddi4+0xa0>
   1890a:	e9c6 4800 	strd	r4, r8, [r6]
   1890e:	e7dd      	b.n	188cc <__udivmoddi4+0xa0>
   18910:	b902      	cbnz	r2, 18914 <__udivmoddi4+0xe8>
   18912:	deff      	udf	#255	; 0xff
   18914:	fab2 f282 	clz	r2, r2
   18918:	2a00      	cmp	r2, #0
   1891a:	f040 808f 	bne.w	18a3c <__udivmoddi4+0x210>
   1891e:	1b49      	subs	r1, r1, r5
   18920:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   18924:	fa1f f885 	uxth.w	r8, r5
   18928:	2701      	movs	r7, #1
   1892a:	fbb1 fcfe 	udiv	ip, r1, lr
   1892e:	0c23      	lsrs	r3, r4, #16
   18930:	fb0e 111c 	mls	r1, lr, ip, r1
   18934:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   18938:	fb08 f10c 	mul.w	r1, r8, ip
   1893c:	4299      	cmp	r1, r3
   1893e:	d907      	bls.n	18950 <__udivmoddi4+0x124>
   18940:	18eb      	adds	r3, r5, r3
   18942:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   18946:	d202      	bcs.n	1894e <__udivmoddi4+0x122>
   18948:	4299      	cmp	r1, r3
   1894a:	f200 80cd 	bhi.w	18ae8 <__udivmoddi4+0x2bc>
   1894e:	4684      	mov	ip, r0
   18950:	1a59      	subs	r1, r3, r1
   18952:	b2a3      	uxth	r3, r4
   18954:	fbb1 f0fe 	udiv	r0, r1, lr
   18958:	fb0e 1410 	mls	r4, lr, r0, r1
   1895c:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   18960:	fb08 f800 	mul.w	r8, r8, r0
   18964:	45a0      	cmp	r8, r4
   18966:	d907      	bls.n	18978 <__udivmoddi4+0x14c>
   18968:	192c      	adds	r4, r5, r4
   1896a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1896e:	d202      	bcs.n	18976 <__udivmoddi4+0x14a>
   18970:	45a0      	cmp	r8, r4
   18972:	f200 80b6 	bhi.w	18ae2 <__udivmoddi4+0x2b6>
   18976:	4618      	mov	r0, r3
   18978:	eba4 0408 	sub.w	r4, r4, r8
   1897c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   18980:	e79f      	b.n	188c2 <__udivmoddi4+0x96>
   18982:	f1c7 0c20 	rsb	ip, r7, #32
   18986:	40bb      	lsls	r3, r7
   18988:	fa22 fe0c 	lsr.w	lr, r2, ip
   1898c:	ea4e 0e03 	orr.w	lr, lr, r3
   18990:	fa01 f407 	lsl.w	r4, r1, r7
   18994:	fa20 f50c 	lsr.w	r5, r0, ip
   18998:	fa21 f30c 	lsr.w	r3, r1, ip
   1899c:	ea4f 481e 	mov.w	r8, lr, lsr #16
   189a0:	4325      	orrs	r5, r4
   189a2:	fbb3 f9f8 	udiv	r9, r3, r8
   189a6:	0c2c      	lsrs	r4, r5, #16
   189a8:	fb08 3319 	mls	r3, r8, r9, r3
   189ac:	fa1f fa8e 	uxth.w	sl, lr
   189b0:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   189b4:	fb09 f40a 	mul.w	r4, r9, sl
   189b8:	429c      	cmp	r4, r3
   189ba:	fa02 f207 	lsl.w	r2, r2, r7
   189be:	fa00 f107 	lsl.w	r1, r0, r7
   189c2:	d90b      	bls.n	189dc <__udivmoddi4+0x1b0>
   189c4:	eb1e 0303 	adds.w	r3, lr, r3
   189c8:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   189cc:	f080 8087 	bcs.w	18ade <__udivmoddi4+0x2b2>
   189d0:	429c      	cmp	r4, r3
   189d2:	f240 8084 	bls.w	18ade <__udivmoddi4+0x2b2>
   189d6:	f1a9 0902 	sub.w	r9, r9, #2
   189da:	4473      	add	r3, lr
   189dc:	1b1b      	subs	r3, r3, r4
   189de:	b2ad      	uxth	r5, r5
   189e0:	fbb3 f0f8 	udiv	r0, r3, r8
   189e4:	fb08 3310 	mls	r3, r8, r0, r3
   189e8:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   189ec:	fb00 fa0a 	mul.w	sl, r0, sl
   189f0:	45a2      	cmp	sl, r4
   189f2:	d908      	bls.n	18a06 <__udivmoddi4+0x1da>
   189f4:	eb1e 0404 	adds.w	r4, lr, r4
   189f8:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   189fc:	d26b      	bcs.n	18ad6 <__udivmoddi4+0x2aa>
   189fe:	45a2      	cmp	sl, r4
   18a00:	d969      	bls.n	18ad6 <__udivmoddi4+0x2aa>
   18a02:	3802      	subs	r0, #2
   18a04:	4474      	add	r4, lr
   18a06:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   18a0a:	fba0 8902 	umull	r8, r9, r0, r2
   18a0e:	eba4 040a 	sub.w	r4, r4, sl
   18a12:	454c      	cmp	r4, r9
   18a14:	46c2      	mov	sl, r8
   18a16:	464b      	mov	r3, r9
   18a18:	d354      	bcc.n	18ac4 <__udivmoddi4+0x298>
   18a1a:	d051      	beq.n	18ac0 <__udivmoddi4+0x294>
   18a1c:	2e00      	cmp	r6, #0
   18a1e:	d069      	beq.n	18af4 <__udivmoddi4+0x2c8>
   18a20:	ebb1 050a 	subs.w	r5, r1, sl
   18a24:	eb64 0403 	sbc.w	r4, r4, r3
   18a28:	fa04 fc0c 	lsl.w	ip, r4, ip
   18a2c:	40fd      	lsrs	r5, r7
   18a2e:	40fc      	lsrs	r4, r7
   18a30:	ea4c 0505 	orr.w	r5, ip, r5
   18a34:	e9c6 5400 	strd	r5, r4, [r6]
   18a38:	2700      	movs	r7, #0
   18a3a:	e747      	b.n	188cc <__udivmoddi4+0xa0>
   18a3c:	f1c2 0320 	rsb	r3, r2, #32
   18a40:	fa20 f703 	lsr.w	r7, r0, r3
   18a44:	4095      	lsls	r5, r2
   18a46:	fa01 f002 	lsl.w	r0, r1, r2
   18a4a:	fa21 f303 	lsr.w	r3, r1, r3
   18a4e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   18a52:	4338      	orrs	r0, r7
   18a54:	0c01      	lsrs	r1, r0, #16
   18a56:	fbb3 f7fe 	udiv	r7, r3, lr
   18a5a:	fa1f f885 	uxth.w	r8, r5
   18a5e:	fb0e 3317 	mls	r3, lr, r7, r3
   18a62:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   18a66:	fb07 f308 	mul.w	r3, r7, r8
   18a6a:	428b      	cmp	r3, r1
   18a6c:	fa04 f402 	lsl.w	r4, r4, r2
   18a70:	d907      	bls.n	18a82 <__udivmoddi4+0x256>
   18a72:	1869      	adds	r1, r5, r1
   18a74:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   18a78:	d22f      	bcs.n	18ada <__udivmoddi4+0x2ae>
   18a7a:	428b      	cmp	r3, r1
   18a7c:	d92d      	bls.n	18ada <__udivmoddi4+0x2ae>
   18a7e:	3f02      	subs	r7, #2
   18a80:	4429      	add	r1, r5
   18a82:	1acb      	subs	r3, r1, r3
   18a84:	b281      	uxth	r1, r0
   18a86:	fbb3 f0fe 	udiv	r0, r3, lr
   18a8a:	fb0e 3310 	mls	r3, lr, r0, r3
   18a8e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   18a92:	fb00 f308 	mul.w	r3, r0, r8
   18a96:	428b      	cmp	r3, r1
   18a98:	d907      	bls.n	18aaa <__udivmoddi4+0x27e>
   18a9a:	1869      	adds	r1, r5, r1
   18a9c:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   18aa0:	d217      	bcs.n	18ad2 <__udivmoddi4+0x2a6>
   18aa2:	428b      	cmp	r3, r1
   18aa4:	d915      	bls.n	18ad2 <__udivmoddi4+0x2a6>
   18aa6:	3802      	subs	r0, #2
   18aa8:	4429      	add	r1, r5
   18aaa:	1ac9      	subs	r1, r1, r3
   18aac:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   18ab0:	e73b      	b.n	1892a <__udivmoddi4+0xfe>
   18ab2:	4637      	mov	r7, r6
   18ab4:	4630      	mov	r0, r6
   18ab6:	e709      	b.n	188cc <__udivmoddi4+0xa0>
   18ab8:	4607      	mov	r7, r0
   18aba:	e6e7      	b.n	1888c <__udivmoddi4+0x60>
   18abc:	4618      	mov	r0, r3
   18abe:	e6fb      	b.n	188b8 <__udivmoddi4+0x8c>
   18ac0:	4541      	cmp	r1, r8
   18ac2:	d2ab      	bcs.n	18a1c <__udivmoddi4+0x1f0>
   18ac4:	ebb8 0a02 	subs.w	sl, r8, r2
   18ac8:	eb69 020e 	sbc.w	r2, r9, lr
   18acc:	3801      	subs	r0, #1
   18ace:	4613      	mov	r3, r2
   18ad0:	e7a4      	b.n	18a1c <__udivmoddi4+0x1f0>
   18ad2:	4660      	mov	r0, ip
   18ad4:	e7e9      	b.n	18aaa <__udivmoddi4+0x27e>
   18ad6:	4618      	mov	r0, r3
   18ad8:	e795      	b.n	18a06 <__udivmoddi4+0x1da>
   18ada:	4667      	mov	r7, ip
   18adc:	e7d1      	b.n	18a82 <__udivmoddi4+0x256>
   18ade:	4681      	mov	r9, r0
   18ae0:	e77c      	b.n	189dc <__udivmoddi4+0x1b0>
   18ae2:	3802      	subs	r0, #2
   18ae4:	442c      	add	r4, r5
   18ae6:	e747      	b.n	18978 <__udivmoddi4+0x14c>
   18ae8:	f1ac 0c02 	sub.w	ip, ip, #2
   18aec:	442b      	add	r3, r5
   18aee:	e72f      	b.n	18950 <__udivmoddi4+0x124>
   18af0:	4638      	mov	r0, r7
   18af2:	e708      	b.n	18906 <__udivmoddi4+0xda>
   18af4:	4637      	mov	r7, r6
   18af6:	e6e9      	b.n	188cc <__udivmoddi4+0xa0>

00018af8 <__aeabi_idiv0>:
   18af8:	4770      	bx	lr
   18afa:	bf00      	nop

00018afc <abort>:
   18afc:	b508      	push	{r3, lr}
   18afe:	2006      	movs	r0, #6
   18b00:	f000 f92c 	bl	18d5c <raise>
   18b04:	2001      	movs	r0, #1
   18b06:	f7fa fb41 	bl	1318c <_exit>
   18b0a:	Address 0x0000000000018b0a is out of bounds.


00018b0c <__libc_init_array>:
   18b0c:	b570      	push	{r4, r5, r6, lr}
   18b0e:	4e0d      	ldr	r6, [pc, #52]	; (18b44 <__libc_init_array+0x38>)
   18b10:	4c0d      	ldr	r4, [pc, #52]	; (18b48 <__libc_init_array+0x3c>)
   18b12:	1ba4      	subs	r4, r4, r6
   18b14:	10a4      	asrs	r4, r4, #2
   18b16:	2500      	movs	r5, #0
   18b18:	42a5      	cmp	r5, r4
   18b1a:	d109      	bne.n	18b30 <__libc_init_array+0x24>
   18b1c:	4e0b      	ldr	r6, [pc, #44]	; (18b4c <__libc_init_array+0x40>)
   18b1e:	4c0c      	ldr	r4, [pc, #48]	; (18b50 <__libc_init_array+0x44>)
   18b20:	f7f7 fbee 	bl	10300 <_init>
   18b24:	1ba4      	subs	r4, r4, r6
   18b26:	10a4      	asrs	r4, r4, #2
   18b28:	2500      	movs	r5, #0
   18b2a:	42a5      	cmp	r5, r4
   18b2c:	d105      	bne.n	18b3a <__libc_init_array+0x2e>
   18b2e:	bd70      	pop	{r4, r5, r6, pc}
   18b30:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   18b34:	4798      	blx	r3
   18b36:	3501      	adds	r5, #1
   18b38:	e7ee      	b.n	18b18 <__libc_init_array+0xc>
   18b3a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   18b3e:	4798      	blx	r3
   18b40:	3501      	adds	r5, #1
   18b42:	e7f2      	b.n	18b2a <__libc_init_array+0x1e>
   18b44:	0001030c 	.word	0x0001030c
   18b48:	0001030c 	.word	0x0001030c
   18b4c:	0001030c 	.word	0x0001030c
   18b50:	0001031c 	.word	0x0001031c

00018b54 <malloc>:
   18b54:	4b02      	ldr	r3, [pc, #8]	; (18b60 <malloc+0xc>)
   18b56:	4601      	mov	r1, r0
   18b58:	6818      	ldr	r0, [r3, #0]
   18b5a:	f000 b86d 	b.w	18c38 <_malloc_r>
   18b5e:	bf00      	nop
   18b60:	10000220 	.word	0x10000220

00018b64 <free>:
   18b64:	4b02      	ldr	r3, [pc, #8]	; (18b70 <free+0xc>)
   18b66:	4601      	mov	r1, r0
   18b68:	6818      	ldr	r0, [r3, #0]
   18b6a:	f000 b817 	b.w	18b9c <_free_r>
   18b6e:	bf00      	nop
   18b70:	10000220 	.word	0x10000220

00018b74 <memcpy>:
   18b74:	b510      	push	{r4, lr}
   18b76:	1e43      	subs	r3, r0, #1
   18b78:	440a      	add	r2, r1
   18b7a:	4291      	cmp	r1, r2
   18b7c:	d100      	bne.n	18b80 <memcpy+0xc>
   18b7e:	bd10      	pop	{r4, pc}
   18b80:	f811 4b01 	ldrb.w	r4, [r1], #1
   18b84:	f803 4f01 	strb.w	r4, [r3, #1]!
   18b88:	e7f7      	b.n	18b7a <memcpy+0x6>

00018b8a <memset>:
   18b8a:	4402      	add	r2, r0
   18b8c:	4603      	mov	r3, r0
   18b8e:	4293      	cmp	r3, r2
   18b90:	d100      	bne.n	18b94 <memset+0xa>
   18b92:	4770      	bx	lr
   18b94:	f803 1b01 	strb.w	r1, [r3], #1
   18b98:	e7f9      	b.n	18b8e <memset+0x4>
   18b9a:	Address 0x0000000000018b9a is out of bounds.


00018b9c <_free_r>:
   18b9c:	b538      	push	{r3, r4, r5, lr}
   18b9e:	4605      	mov	r5, r0
   18ba0:	2900      	cmp	r1, #0
   18ba2:	d045      	beq.n	18c30 <_free_r+0x94>
   18ba4:	f851 3c04 	ldr.w	r3, [r1, #-4]
   18ba8:	1f0c      	subs	r4, r1, #4
   18baa:	2b00      	cmp	r3, #0
   18bac:	bfb8      	it	lt
   18bae:	18e4      	addlt	r4, r4, r3
   18bb0:	f000 f8f0 	bl	18d94 <__malloc_lock>
   18bb4:	4a1f      	ldr	r2, [pc, #124]	; (18c34 <_free_r+0x98>)
   18bb6:	6813      	ldr	r3, [r2, #0]
   18bb8:	4610      	mov	r0, r2
   18bba:	b933      	cbnz	r3, 18bca <_free_r+0x2e>
   18bbc:	6063      	str	r3, [r4, #4]
   18bbe:	6014      	str	r4, [r2, #0]
   18bc0:	4628      	mov	r0, r5
   18bc2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   18bc6:	f000 b8e6 	b.w	18d96 <__malloc_unlock>
   18bca:	42a3      	cmp	r3, r4
   18bcc:	d90c      	bls.n	18be8 <_free_r+0x4c>
   18bce:	6821      	ldr	r1, [r4, #0]
   18bd0:	1862      	adds	r2, r4, r1
   18bd2:	4293      	cmp	r3, r2
   18bd4:	bf04      	itt	eq
   18bd6:	681a      	ldreq	r2, [r3, #0]
   18bd8:	685b      	ldreq	r3, [r3, #4]
   18bda:	6063      	str	r3, [r4, #4]
   18bdc:	bf04      	itt	eq
   18bde:	1852      	addeq	r2, r2, r1
   18be0:	6022      	streq	r2, [r4, #0]
   18be2:	6004      	str	r4, [r0, #0]
   18be4:	e7ec      	b.n	18bc0 <_free_r+0x24>
   18be6:	4613      	mov	r3, r2
   18be8:	685a      	ldr	r2, [r3, #4]
   18bea:	b10a      	cbz	r2, 18bf0 <_free_r+0x54>
   18bec:	42a2      	cmp	r2, r4
   18bee:	d9fa      	bls.n	18be6 <_free_r+0x4a>
   18bf0:	6819      	ldr	r1, [r3, #0]
   18bf2:	1858      	adds	r0, r3, r1
   18bf4:	42a0      	cmp	r0, r4
   18bf6:	d10b      	bne.n	18c10 <_free_r+0x74>
   18bf8:	6820      	ldr	r0, [r4, #0]
   18bfa:	4401      	add	r1, r0
   18bfc:	1858      	adds	r0, r3, r1
   18bfe:	4282      	cmp	r2, r0
   18c00:	6019      	str	r1, [r3, #0]
   18c02:	d1dd      	bne.n	18bc0 <_free_r+0x24>
   18c04:	6810      	ldr	r0, [r2, #0]
   18c06:	6852      	ldr	r2, [r2, #4]
   18c08:	605a      	str	r2, [r3, #4]
   18c0a:	4401      	add	r1, r0
   18c0c:	6019      	str	r1, [r3, #0]
   18c0e:	e7d7      	b.n	18bc0 <_free_r+0x24>
   18c10:	d902      	bls.n	18c18 <_free_r+0x7c>
   18c12:	230c      	movs	r3, #12
   18c14:	602b      	str	r3, [r5, #0]
   18c16:	e7d3      	b.n	18bc0 <_free_r+0x24>
   18c18:	6820      	ldr	r0, [r4, #0]
   18c1a:	1821      	adds	r1, r4, r0
   18c1c:	428a      	cmp	r2, r1
   18c1e:	bf04      	itt	eq
   18c20:	6811      	ldreq	r1, [r2, #0]
   18c22:	6852      	ldreq	r2, [r2, #4]
   18c24:	6062      	str	r2, [r4, #4]
   18c26:	bf04      	itt	eq
   18c28:	1809      	addeq	r1, r1, r0
   18c2a:	6021      	streq	r1, [r4, #0]
   18c2c:	605c      	str	r4, [r3, #4]
   18c2e:	e7c7      	b.n	18bc0 <_free_r+0x24>
   18c30:	bd38      	pop	{r3, r4, r5, pc}
   18c32:	bf00      	nop
   18c34:	10000934 	.word	0x10000934

00018c38 <_malloc_r>:
   18c38:	b570      	push	{r4, r5, r6, lr}
   18c3a:	1ccd      	adds	r5, r1, #3
   18c3c:	f025 0503 	bic.w	r5, r5, #3
   18c40:	3508      	adds	r5, #8
   18c42:	2d0c      	cmp	r5, #12
   18c44:	bf38      	it	cc
   18c46:	250c      	movcc	r5, #12
   18c48:	2d00      	cmp	r5, #0
   18c4a:	4606      	mov	r6, r0
   18c4c:	db01      	blt.n	18c52 <_malloc_r+0x1a>
   18c4e:	42a9      	cmp	r1, r5
   18c50:	d903      	bls.n	18c5a <_malloc_r+0x22>
   18c52:	230c      	movs	r3, #12
   18c54:	6033      	str	r3, [r6, #0]
   18c56:	2000      	movs	r0, #0
   18c58:	bd70      	pop	{r4, r5, r6, pc}
   18c5a:	f000 f89b 	bl	18d94 <__malloc_lock>
   18c5e:	4a21      	ldr	r2, [pc, #132]	; (18ce4 <_malloc_r+0xac>)
   18c60:	6814      	ldr	r4, [r2, #0]
   18c62:	4621      	mov	r1, r4
   18c64:	b991      	cbnz	r1, 18c8c <_malloc_r+0x54>
   18c66:	4c20      	ldr	r4, [pc, #128]	; (18ce8 <_malloc_r+0xb0>)
   18c68:	6823      	ldr	r3, [r4, #0]
   18c6a:	b91b      	cbnz	r3, 18c74 <_malloc_r+0x3c>
   18c6c:	4630      	mov	r0, r6
   18c6e:	f000 f83d 	bl	18cec <_sbrk_r>
   18c72:	6020      	str	r0, [r4, #0]
   18c74:	4629      	mov	r1, r5
   18c76:	4630      	mov	r0, r6
   18c78:	f000 f838 	bl	18cec <_sbrk_r>
   18c7c:	1c43      	adds	r3, r0, #1
   18c7e:	d124      	bne.n	18cca <_malloc_r+0x92>
   18c80:	230c      	movs	r3, #12
   18c82:	6033      	str	r3, [r6, #0]
   18c84:	4630      	mov	r0, r6
   18c86:	f000 f886 	bl	18d96 <__malloc_unlock>
   18c8a:	e7e4      	b.n	18c56 <_malloc_r+0x1e>
   18c8c:	680b      	ldr	r3, [r1, #0]
   18c8e:	1b5b      	subs	r3, r3, r5
   18c90:	d418      	bmi.n	18cc4 <_malloc_r+0x8c>
   18c92:	2b0b      	cmp	r3, #11
   18c94:	d90f      	bls.n	18cb6 <_malloc_r+0x7e>
   18c96:	600b      	str	r3, [r1, #0]
   18c98:	50cd      	str	r5, [r1, r3]
   18c9a:	18cc      	adds	r4, r1, r3
   18c9c:	4630      	mov	r0, r6
   18c9e:	f000 f87a 	bl	18d96 <__malloc_unlock>
   18ca2:	f104 000b 	add.w	r0, r4, #11
   18ca6:	1d23      	adds	r3, r4, #4
   18ca8:	f020 0007 	bic.w	r0, r0, #7
   18cac:	1ac3      	subs	r3, r0, r3
   18cae:	d0d3      	beq.n	18c58 <_malloc_r+0x20>
   18cb0:	425a      	negs	r2, r3
   18cb2:	50e2      	str	r2, [r4, r3]
   18cb4:	e7d0      	b.n	18c58 <_malloc_r+0x20>
   18cb6:	428c      	cmp	r4, r1
   18cb8:	684b      	ldr	r3, [r1, #4]
   18cba:	bf16      	itet	ne
   18cbc:	6063      	strne	r3, [r4, #4]
   18cbe:	6013      	streq	r3, [r2, #0]
   18cc0:	460c      	movne	r4, r1
   18cc2:	e7eb      	b.n	18c9c <_malloc_r+0x64>
   18cc4:	460c      	mov	r4, r1
   18cc6:	6849      	ldr	r1, [r1, #4]
   18cc8:	e7cc      	b.n	18c64 <_malloc_r+0x2c>
   18cca:	1cc4      	adds	r4, r0, #3
   18ccc:	f024 0403 	bic.w	r4, r4, #3
   18cd0:	42a0      	cmp	r0, r4
   18cd2:	d005      	beq.n	18ce0 <_malloc_r+0xa8>
   18cd4:	1a21      	subs	r1, r4, r0
   18cd6:	4630      	mov	r0, r6
   18cd8:	f000 f808 	bl	18cec <_sbrk_r>
   18cdc:	3001      	adds	r0, #1
   18cde:	d0cf      	beq.n	18c80 <_malloc_r+0x48>
   18ce0:	6025      	str	r5, [r4, #0]
   18ce2:	e7db      	b.n	18c9c <_malloc_r+0x64>
   18ce4:	10000934 	.word	0x10000934
   18ce8:	10000938 	.word	0x10000938

00018cec <_sbrk_r>:
   18cec:	b538      	push	{r3, r4, r5, lr}
   18cee:	4c06      	ldr	r4, [pc, #24]	; (18d08 <_sbrk_r+0x1c>)
   18cf0:	2300      	movs	r3, #0
   18cf2:	4605      	mov	r5, r0
   18cf4:	4608      	mov	r0, r1
   18cf6:	6023      	str	r3, [r4, #0]
   18cf8:	f7fa fa7e 	bl	131f8 <_sbrk>
   18cfc:	1c43      	adds	r3, r0, #1
   18cfe:	d102      	bne.n	18d06 <_sbrk_r+0x1a>
   18d00:	6823      	ldr	r3, [r4, #0]
   18d02:	b103      	cbz	r3, 18d06 <_sbrk_r+0x1a>
   18d04:	602b      	str	r3, [r5, #0]
   18d06:	bd38      	pop	{r3, r4, r5, pc}
   18d08:	1000093c 	.word	0x1000093c

00018d0c <_raise_r>:
   18d0c:	291f      	cmp	r1, #31
   18d0e:	b538      	push	{r3, r4, r5, lr}
   18d10:	4604      	mov	r4, r0
   18d12:	460d      	mov	r5, r1
   18d14:	d904      	bls.n	18d20 <_raise_r+0x14>
   18d16:	2316      	movs	r3, #22
   18d18:	6003      	str	r3, [r0, #0]
   18d1a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   18d1e:	bd38      	pop	{r3, r4, r5, pc}
   18d20:	6c42      	ldr	r2, [r0, #68]	; 0x44
   18d22:	b112      	cbz	r2, 18d2a <_raise_r+0x1e>
   18d24:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   18d28:	b94b      	cbnz	r3, 18d3e <_raise_r+0x32>
   18d2a:	4620      	mov	r0, r4
   18d2c:	f000 f830 	bl	18d90 <_getpid_r>
   18d30:	462a      	mov	r2, r5
   18d32:	4601      	mov	r1, r0
   18d34:	4620      	mov	r0, r4
   18d36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   18d3a:	f000 b817 	b.w	18d6c <_kill_r>
   18d3e:	2b01      	cmp	r3, #1
   18d40:	d00a      	beq.n	18d58 <_raise_r+0x4c>
   18d42:	1c59      	adds	r1, r3, #1
   18d44:	d103      	bne.n	18d4e <_raise_r+0x42>
   18d46:	2316      	movs	r3, #22
   18d48:	6003      	str	r3, [r0, #0]
   18d4a:	2001      	movs	r0, #1
   18d4c:	e7e7      	b.n	18d1e <_raise_r+0x12>
   18d4e:	2400      	movs	r4, #0
   18d50:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   18d54:	4628      	mov	r0, r5
   18d56:	4798      	blx	r3
   18d58:	2000      	movs	r0, #0
   18d5a:	e7e0      	b.n	18d1e <_raise_r+0x12>

00018d5c <raise>:
   18d5c:	4b02      	ldr	r3, [pc, #8]	; (18d68 <raise+0xc>)
   18d5e:	4601      	mov	r1, r0
   18d60:	6818      	ldr	r0, [r3, #0]
   18d62:	f7ff bfd3 	b.w	18d0c <_raise_r>
   18d66:	bf00      	nop
   18d68:	10000220 	.word	0x10000220

00018d6c <_kill_r>:
   18d6c:	b538      	push	{r3, r4, r5, lr}
   18d6e:	4c07      	ldr	r4, [pc, #28]	; (18d8c <_kill_r+0x20>)
   18d70:	2300      	movs	r3, #0
   18d72:	4605      	mov	r5, r0
   18d74:	4608      	mov	r0, r1
   18d76:	4611      	mov	r1, r2
   18d78:	6023      	str	r3, [r4, #0]
   18d7a:	f7fa fa25 	bl	131c8 <_kill>
   18d7e:	1c43      	adds	r3, r0, #1
   18d80:	d102      	bne.n	18d88 <_kill_r+0x1c>
   18d82:	6823      	ldr	r3, [r4, #0]
   18d84:	b103      	cbz	r3, 18d88 <_kill_r+0x1c>
   18d86:	602b      	str	r3, [r5, #0]
   18d88:	bd38      	pop	{r3, r4, r5, pc}
   18d8a:	bf00      	nop
   18d8c:	1000093c 	.word	0x1000093c

00018d90 <_getpid_r>:
   18d90:	f7fa ba08 	b.w	131a4 <_getpid>

00018d94 <__malloc_lock>:
   18d94:	4770      	bx	lr

00018d96 <__malloc_unlock>:
   18d96:	4770      	bx	lr

00018d98 <LabGPIO::IntEdge(LabGPIO::Edge)::file>:
   18d98:	614c 4762 4950 2e4f 7063 0070 5b1b 3234     LabGPIO.cpp..[42
   18da8:	206d 2020 4920 464e 1b4f 305b 393b 6d34     m    INFO.[0;94m
   18db8:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   18dc8:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   18dd8:	6f4e 6520 6764 2065 6573 656c 7463 6465     No edge selected
   18de8:	5b1b 6d30 000a ffff                         .[0m....

00018df0 <LabGPIO::IntEdge(LabGPIO::Edge)::__PRETTY_FUNCTION__>:
   18df0:	6f76 6469 4c20 6261 5047 4f49 3a3a 6e49     void LabGPIO::In
   18e00:	4574 6764 2865 614c 4762 4950 3a4f 453a     tEdge(LabGPIO::E
   18e10:	6764 2965 ff00 ffff                         dge)....

00018e18 <main::file>:
   18e18:	616d 6e69 632e 7070 ff00 ffff 5b1b 3234     main.cpp.....[42
   18e28:	206d 2020 4920 464e 1b4f 305b 393b 6d34     m    INFO.[0;94m
   18e38:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   18e48:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   18e58:	7453 7261 1b74 305b 0a6d 0000 0074 0000     Start.[0m...t...
   18e68:	5b1b 3234 206d 2020 4920 464e 1b4f 305b     .[42m    INFO.[0
   18e78:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   18e88:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   18e98:	333b 6d37 6e49 7420 6568 6920 746e 7265     ;37mIn the inter
   18ea8:	7572 7470 5b1b 6d30 000a 0000 5b1b 3234     rupt.[0m.....[42
   18eb8:	206d 2020 4920 464e 1b4f 305b 393b 6d34     m    INFO.[0;94m
   18ec8:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   18ed8:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   18ee8:	6553 616d 6870 726f 2065 6552 6963 7665     Semaphore Reciev
   18ef8:	6465 1b0a 305b 0a6d 0000 0000 5b1b 3234     ed..[0m......[42
   18f08:	206d 2020 4920 464e 1b4f 305b 393b 6d34     m    INFO.[0;94m
   18f18:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   18f28:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   18f38:	4f4e 2054 4954 4b43 1b0a 305b 0a6d ff00     NOT TICK..[0m...

00018f48 <isr_toggle()::file>:
   18f48:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

00018f54 <sem_task(void*)::file>:
   18f54:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

00018f60 <sem_task(void*)::file>:
   18f60:	616d 6e69 632e 7070 ff00 ffff               main.cpp....

00018f6c <main::__PRETTY_FUNCTION__>:
   18f6c:	6e69 2074 616d 6e69 2928 ff00               int main()..

00018f78 <isr_toggle()::__PRETTY_FUNCTION__>:
   18f78:	6f76 6469 6920 7273 745f 676f 6c67 2865     void isr_toggle(
   18f88:	0029 ffff                                   )...

00018f8c <sem_task(void*)::__PRETTY_FUNCTION__>:
   18f8c:	6f76 6469 7320 6d65 745f 7361 286b 6f76     void sem_task(vo
   18f9c:	6469 292a ff00 ffff 7453 6361 206b 6544     id*)....Stack De
   18fac:	7470 2068 203d 7a25 0a64 0000 2020 2523     pth = %zd...  #%
   18fbc:	757a 203a 7830 7025 000a 0000 520a 6e75     zu: 0x%p.....Run
   18fcc:	203a 6874 2065 6f66 6c6c 776f 6e69 2067     : the following 
   18fdc:	6f63 6d6d 6e61 2064 6e69 7920 756f 2072     command in your 
   18fec:	7270 6a6f 6365 2074 6964 6572 7463 726f     project director
   18ffc:	0079 0000 200a 1b20 315b 333b 6d37 616d     y....  .[1;37mma
   1900c:	656b 7320 6174 6b63 7274 6361 2d65 7325     ke stacktrace-%s
   1901c:	5420 4152 4543 3d53 0022 0000 7830 7025      TRACES="...0x%p
   1902c:	0000 0000 3020 2578 0070 0000 0a22 5b1b     .... 0x%p..."..[
   1903c:	6d30 0000 6854 7369 7720 6c69 206c 6572     0m..This will re
   1904c:	6f70 7472 7420 6568 6620 6c69 2065 6e61     port the file an
   1905c:	2064 696c 656e 6e20 6d75 6562 2072 6874     d line number th
   1906c:	7461 6c20 6465 7420 206f 6874 7369 6620     at led to this f
   1907c:	6e75 7463 6f69 206e 6562 6e69 2067 6163     unction being ca
   1908c:	6c6c 6465 002e 0000 7061 6c70 6369 7461     lled....applicat
   1909c:	6f69 006e 5b1b 3134 436d 4952 4954 4143     ion..[41mCRITICA
   190ac:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   190bc:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   190cc:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   190dc:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   190ec:	6974 6e6f 5420 7365 6574 3a64 2820 6570     tion Tested: (pe
   190fc:	6972 6870 7265 6c61 645f 7669 6469 7265     ripheral_divider
   1910c:	3c20 203d 2934 200a 2020 2020 2020 2020      <= 4).         
   1911c:	4420 7669 6469 7265 6d20 7375 6e74 7427      Divider mustn't
   1912c:	6520 6378 6565 2064 3233 5b1b 6d30 5b1b      exceed 32.[0m.[
   1913c:	6d30 000a 500a 6972 746e 6e69 2067 7453     0m...Printing St
   1914c:	6361 206b 7254 6361 3a65 000a 5b1b 3134     ack Trace:...[41
   1915c:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   1916c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1917c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1918c:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   1919c:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   191ac:	6574 3a64 2820 6564 6973 6572 5f64 7073     ted: (desired_sp
   191bc:	6565 5f64 6e69 6d5f 7a68 3c20 3320 3438     eed_in_mhz < 384
   191cc:	2620 2026 6564 6973 6572 5f64 7073 6565      && desired_spee
   191dc:	5f64 6e69 6d5f 7a68 3e20 3120 2932 200a     d_in_mhz > 12). 
   191ec:	2020 2020 2020 2020 4620 6572 7571 6e65              Frequen
   191fc:	7963 6d20 7375 2074 6562 6c20 776f 7265     cy must be lower
   1920c:	7420 6168 206e 3833 2034 484d 617a 646e      than 384 MHzand
   1921c:	6720 6572 7461 7265 7420 6168 206e 726f      greater than or
   1922c:	6520 7571 6c61 7420 206f 3231 4d20 7a48      equal to 12 MHz
   1923c:	5b1b 6d30 5b1b 6d30 000a 0000 5b1b 3134     .[0m.[0m.....[41
   1924c:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   1925c:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1926c:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1927c:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   1928c:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   1929c:	6574 3a64 2820 6964 6976 6564 5f72 6176     ted: (divider_va
   192ac:	756c 2065 203c 2938 200a 2020 2020 2020     lue < 8).       
   192bc:	2020 5020 4c4c 6420 7669 6469 7265 7620        PLL divider v
   192cc:	6c61 6575 7720 6e65 2074 756f 2074 666f     alue went out of
   192dc:	6220 756f 646e 1b73 305b 1b6d 305b 0a6d      bounds.[0m.[0m.
   192ec:	0000 0000 5b1b 3134 436d 4952 4954 4143     .....[41mCRITICA
   192fc:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   1930c:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1931c:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   1932c:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   1933c:	6974 6e6f 5420 7365 6574 3a64 2820 6166     tion Tested: (fa
   1934c:	736c 2965 200a 2020 2020 2020 2020 5020     lse).          P
   1935c:	4c4c 6c20 636f 206b 6f63 6c75 2064 6f6e     LL lock could no
   1936c:	2074 6562 6520 7473 6261 696c 6873 6465     t be established
   1937c:	6220 6665 726f 2065 6974 656d 756f 1b74      before timeout.
   1938c:	305b 1b6d 305b 0a6d 0000 0000 5b1b 3134     [0m.[0m......[41
   1939c:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   193ac:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   193bc:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   193cc:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   193dc:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   193ec:	6574 3a64 2820 7063 5f75 6964 6976 6564     ted: (cpu_divide
   193fc:	2072 203c 3233 0a29 2020 2020 2020 2020     r < 32).        
   1940c:	2020 6944 6976 6564 2072 756d 7473 276e       Divider mustn'
   1941c:	2074 7865 6563 6465 3320 1b32 305b 1b6d     t exceed 32.[0m.
   1942c:	305b 0a6d 0000 0000 5b1b 3134 436d 4952     [0m......[41mCRI
   1943c:	4954 4143 1b4c 305b 393b 6d34 253a 3a73     TICAL.[0;94m:%s:
   1944c:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1945c:	256d 3e64 1b20 305b 333b 6d37 7341 6573     m%d> .[0;37mAsse
   1946c:	7472 6f69 206e 6146 6c69 7275 2c65 4320     rtion Failure, C
   1947c:	6e6f 6964 6974 6e6f 5420 7365 6574 3a64     ondition Tested:
   1948c:	2820 7266 7165 6575 636e 2079 3d21 3020      (frequency != 0
   1949c:	0a29 2020 2020 2020 2020 2020 6143 6e6e     ).          Cann
   194ac:	746f 6820 7661 2065 657a 6f72 7420 6369     ot have zero tic
   194bc:	736b 7020 7265 6d20 6369 6f72 6573 6f63     ks per microseco
   194cc:	646e 202c 6c70 6165 6573 6320 6f68 736f     nd, please choos
   194dc:	2065 2031 726f 6d20 726f 2e65 5b1b 6d30     e 1 or more..[0m
   194ec:	5b1b 6d30 000a 0000 5b1b 3334 206d 4157     .[0m.....[43m WA
   194fc:	4e52 4e49 1b47 305b 393b 6d34 253a 3a73     RNING.[0;94m:%s:
   1950c:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1951c:	256d 3e64 1b20 305b 333b 6d37 7953 7473     m%d> .[0;37mSyst
   1952c:	6d65 5420 6d69 7265 6820 7361 4620 4941     em Timer has FAI
   1953c:	454c 2044 6f74 7320 6174 7472 1b21 305b     LED to start!.[0
   1954c:	1b6d 305b 0a6d ff00                         m.[0m...

00019554 <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::file>:
   19554:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   19564:	2e72 7068 0070 ffff                         r.hpp...

0001956c <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1956c:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   1957c:	2e72 7068 0070 ffff                         r.hpp...

00019584 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   19584:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   19594:	2e72 7068 0070 ffff                         r.hpp...

0001959c <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::file>:
   1959c:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   195ac:	2e72 7068 0070 ffff                         r.hpp...

000195b4 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::file>:
   195b4:	7973 7473 6d65 635f 6e6f 7274 6c6f 656c     system_controlle
   195c4:	2e72 7068 0070 ffff                         r.hpp...

000195cc <Timer::kPowerbit>:
   195cc:	0001 0000 0002 0000 0016 0000 0017 0000     ................

000195dc <Timer::kTimerIrq>:
   195dc:	0201 0403                                   ....

000195e0 <Timer::kTimerIsr>:
   195e0:	29e5 0001 2a21 0001 2a5d 0001 2a99 0001     .)..!*..]*...*..

000195f0 <Timer::Initialize(unsigned long, void (*)(), long)::file>:
   195f0:	6974 656d 2e72 7068 0070 ffff               timer.hpp...

000195fc <Uart::kTxUartPortFunction>:
   195fc:	0201 0502                                   ....

00019600 <Uart::kRxUartPortFunction>:
   19600:	0201 0302                                   ....

00019604 <Uart::kPowerbit>:
   19604:	0003 0000 0018 0000 0019 0000 0008 0000     ................

00019614 <LowLevelInit()::file>:
   19614:	7473 7261 7574 2e70 7063 0070               startup.cpp.

00019620 <vtable for Uart>:
	...
   19628:	1f51 0001 201d 0001 214d 0001 2281 0001     Q.... ..M!..."..
   19638:	fffc ffff 0000 0000 0f25 0001 0fb5 0001     ........%.......
   19648:	100d 0001 1025 0001 1039 0001 1079 0001     ....%...9...y...
   19658:	10a9 0001                                   ....

0001965c <vtable for Timer>:
	...
   19664:	1cb9 0001 1e1d 0001 1f15 0001 fffc ffff     ................
   19674:	0000 0000 0f25 0001 0fb5 0001 100d 0001     ....%...........
   19684:	1025 0001 1039 0001 1079 0001 10a9 0001     %...9...y.......

00019694 <vtable for Pin>:
	...
   1969c:	1689 0001 1701 0001 1781 0001 17f5 0001     ................
   196ac:	1869 0001 18e5 0001 1961 0001 19d5 0001     i.......a.......
   196bc:	1a51 0001 1ac5 0001 1b39 0001 1c11 0001     Q.......9.......
   196cc:	1c3d 0001                                   =...

000196d0 <vtable for SystemTimer>:
	...
   196d8:	1525 0001 1559 0001 15f5 0001 fffc ffff     %...Y...........
   196e8:	0000 0000 0f25 0001 0fb5 0001 100d 0001     ....%...........
   196f8:	1025 0001 1039 0001 1079 0001 10a9 0001     %...9...y.......

00019708 <vtable for Lpc40xxSystemController>:
	...
   19710:	0f25 0001 0fb5 0001 100d 0001 1025 0001     %...........%...
   19720:	1039 0001 1079 0001 10a9 0001               9...y.......

0001972c <Lpc40xxSystemController::SetPeripheralClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   1972c:	6976 7472 6175 206c 6f76 6469 4c20 6370     virtual void Lpc
   1973c:	3034 7878 7953 7473 6d65 6f43 746e 6f72     40xxSystemContro
   1974c:	6c6c 7265 3a3a 6553 5074 7265 7069 6568     ller::SetPeriphe
   1975c:	6172 436c 6f6c 6b63 6944 6976 6564 2872     ralClockDivider(
   1976c:	6975 746e 5f38 2974 ff00 ffff               uint8_t)....

00019778 <Lpc40xxSystemController::SetMainPll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   19778:	6975 746e 3233 745f 4c20 6370 3034 7878     uint32_t Lpc40xx
   19788:	7953 7473 6d65 6f43 746e 6f72 6c6c 7265     SystemController
   19798:	3a3a 6553 4d74 6961 506e 6c6c 4c28 6370     ::SetMainPll(Lpc
   197a8:	3034 7878 7953 7473 6d65 6f43 746e 6f72     40xxSystemContro
   197b8:	6c6c 7265 3a3a 6c50 496c 706e 7475 202c     ller::PllInput, 
   197c8:	6975 746e 3631 745f 0029 ffff               uint16_t)...

000197d4 <Lpc40xxSystemController::CalculatePll(Lpc40xxSystemController::PllInput, unsigned short)::__PRETTY_FUNCTION__>:
   197d4:	6975 746e 3233 745f 4c20 6370 3034 7878     uint32_t Lpc40xx
   197e4:	7953 7473 6d65 6f43 746e 6f72 6c6c 7265     SystemController
   197f4:	3a3a 6143 636c 6c75 7461 5065 6c6c 4c28     ::CalculatePll(L
   19804:	6370 3034 7878 7953 7473 6d65 6f43 746e     pc40xxSystemCont
   19814:	6f72 6c6c 7265 3a3a 6c50 496c 706e 7475     roller::PllInput
   19824:	202c 6975 746e 3631 745f 0029               , uint16_t).

00019830 <Lpc40xxSystemController::SetCpuClockDivider(unsigned char)::__PRETTY_FUNCTION__>:
   19830:	6f76 6469 4c20 6370 3034 7878 7953 7473     void Lpc40xxSyst
   19840:	6d65 6f43 746e 6f72 6c6c 7265 3a3a 6553     emController::Se
   19850:	4374 7570 6c43 636f 446b 7669 6469 7265     tCpuClockDivider
   19860:	7528 6e69 3874 745f 0029 ffff               (uint8_t)...

0001986c <Timer::Initialize(unsigned long, void (*)(), long)::__PRETTY_FUNCTION__>:
   1986c:	6976 7472 6175 206c 6f76 6469 5420 6d69     virtual void Tim
   1987c:	7265 3a3a 6e49 7469 6169 696c 657a 7528     er::Initialize(u
   1988c:	6e69 3374 5f32 2c74 4920 7273 6f50 6e69     int32_t, IsrPoin
   1989c:	6574 2c72 6920 746e 3233 745f 0029 ffff     ter, int32_t)...

000198ac <LowLevelInit()::__PRETTY_FUNCTION__>:
   198ac:	6f76 6469 4c20 776f 654c 6576 496c 696e     void LowLevelIni
   198bc:	2874 0029 7453 6361 206b 6544 7470 2068     t().Stack Depth 
   198cc:	203d 7a25 0a64 0000 2020 2523 757a 203a     = %zd...  #%zu: 
   198dc:	7830 7025 000a 0000 520a 6e75 203a 6874     0x%p.....Run: th
   198ec:	2065 6f66 6c6c 776f 6e69 2067 6f63 6d6d     e following comm
   198fc:	6e61 2064 6e69 7920 756f 2072 7270 6a6f     and in your proj
   1990c:	6365 2074 6964 6572 7463 726f 0079 0000     ect directory...
   1991c:	200a 1b20 315b 333b 6d37 616d 656b 7320     .  .[1;37mmake s
   1992c:	6174 6b63 7274 6361 2d65 7325 5420 4152     tacktrace-%s TRA
   1993c:	4543 3d53 0022 0000 7830 7025 0000 0000     CES="...0x%p....
   1994c:	3020 2578 0070 0000 0a22 5b1b 6d30 0000      0x%p..."..[0m..
   1995c:	6854 7369 7720 6c69 206c 6572 6f70 7472     This will report
   1996c:	7420 6568 6620 6c69 2065 6e61 2064 696c      the file and li
   1997c:	656e 6e20 6d75 6562 2072 6874 7461 6c20     ne number that l
   1998c:	6465 7420 206f 6874 7369 6620 6e75 7463     ed to this funct
   1999c:	6f69 206e 6562 6e69 2067 6163 6c6c 6465     ion being called
   199ac:	002e 0000 7061 6c70 6369 7461 6f69 006e     ....application.
   199bc:	5b1b 3134 436d 4952 4954 4143 1b4c 305b     .[41mCRITICAL.[0
   199cc:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   199dc:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   199ec:	333b 6d37 7341 6573 7472 6f69 206e 6146     ;37mAssertion Fa
   199fc:	6c69 7275 2c65 4320 6e6f 6964 6974 6e6f     ilure, Condition
   19a0c:	5420 7365 6574 3a64 2820 7369 2072 3d21      Tested: (isr !=
   19a1c:	4920 746e 7265 7572 7470 6f4c 6b6f 7075      InterruptLookup
   19a2c:	6148 646e 656c 2972 200a 2020 2020 2020     Handler).       
   19a3c:	2020 4e20 206f 5349 2052 6f66 6e75 2064        No ISR found 
   19a4c:	6f66 2072 6874 2065 6576 7463 726f 2520     for the vector %
   19a5c:	1b75 305b 1b6d 305b 0a6d 0000 500a 6972     u.[0m.[0m....Pri
   19a6c:	746e 6e69 2067 7453 6361 206b 7254 6361     nting Stack Trac
   19a7c:	3a65 000a 5b1b 3134 486d 7261 2064 6146     e:...[41mHard Fa
   19a8c:	6c75 2074 7845 6563 7470 6f69 206e 634f     ult Exception Oc
   19a9c:	7563 7272 6465 0a21 5b1b 6d30 0000 0000     curred!..[0m....
   19aac:	3072 203a 7830 3025 6c38 2c58 7220 3a31     r0: 0x%08lX, r1:
   19abc:	3020 2578 3830 586c 202c 3272 203a 7830      0x%08lX, r2: 0x
   19acc:	3025 6c38 2c58 7220 3a33 3020 2578 3830     %08lX, r3: 0x%08
   19adc:	586c 000a 3172 3a32 3020 2578 3830 586c     lX..r12: 0x%08lX
   19aec:	202c 726c 203a 7830 3025 6c38 2c58 7020     , lr: 0x%08lX, p
   19afc:	3a63 3020 2578 3830 586c 202c 7370 3a72     c: 0x%08lX, psr:
   19b0c:	3020 2578 3830 586c 000a ffff                0x%08lX....

00019b18 <InterruptLookupHandler::file>:
   19b18:	6e69 6574 7272 7075 2e74 7063 0070 ffff     interrupt.cpp...

00019b28 <InterruptLookupHandler::__PRETTY_FUNCTION__>:
   19b28:	6f76 6469 4920 746e 7265 7572 7470 6f4c     void InterruptLo
   19b38:	6b6f 7075 6148 646e 656c 2872 0029 ffff     okupHandler()...
   19b48:	4449 454c 0000 0000 2509 0963 7525 2509     IDLE.....%c.%u.%
   19b58:	0975 7525 0a0d 0000 2509 0975 2509 2575     u.%u.....%u..%u%
   19b68:	0d25 000a 2509 0975 3c09 2531 0d25 000a     %....%u..<1%%...

00019b78 <_ftoa(void (*)(char, void*, unsigned int, unsigned int), char*, unsigned int, unsigned int, double, unsigned int, unsigned int, unsigned int)::pow10>:
   19b78:	0000 3f80 0000 4120 0000 42c8 0000 447a     ...?.. A...B..zD
   19b88:	4000 461c 5000 47c3 2400 4974 9680 4b18     .@.F.P.G.$tI...K
   19b98:	bc20 4cbe 6b28 4e6e 7453 6361 206b 6544      ..L(knNStack De
   19ba8:	7470 2068 203d 7a25 0a64 0000 2020 2523     pth = %zd...  #%
   19bb8:	757a 203a 7830 7025 000a 0000 520a 6e75     zu: 0x%p.....Run
   19bc8:	203a 6874 2065 6f66 6c6c 776f 6e69 2067     : the following 
   19bd8:	6f63 6d6d 6e61 2064 6e69 7920 756f 2072     command in your 
   19be8:	7270 6a6f 6365 2074 6964 6572 7463 726f     project director
   19bf8:	0079 0000 200a 1b20 315b 333b 6d37 616d     y....  .[1;37mma
   19c08:	656b 7320 6174 6b63 7274 6361 2d65 7325     ke stacktrace-%s
   19c18:	5420 4152 4543 3d53 0022 0000 7830 7025      TRACES="...0x%p
   19c28:	0000 0000 3020 2578 0070 0000 0a22 5b1b     .... 0x%p..."..[
   19c38:	6d30 0000 6854 7369 7720 6c69 206c 6572     0m..This will re
   19c48:	6f70 7472 7420 6568 6620 6c69 2065 6e61     port the file an
   19c58:	2064 696c 656e 6e20 6d75 6562 2072 6874     d line number th
   19c68:	7461 6c20 6465 7420 206f 6874 7369 6620     at led to this f
   19c78:	6e75 7463 6f69 206e 6562 6e69 2067 6163     unction being ca
   19c88:	6c6c 6465 002e 0000 7061 6c70 6369 7461     lled....applicat
   19c98:	6f69 006e 5b1b 3334 206d 4157 4e52 4e49     ion..[43m WARNIN
   19ca8:	1b47 305b 393b 6d34 253a 3a73 5b1b 3b30     G.[0;94m:%s:.[0;
   19cb8:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   19cc8:	1b20 305b 333b 6d37 6f50 7472 2520 2064      .[0;37mPort %d 
   19cd8:	6163 6e6e 746f 6220 2065 7375 6465 6620     cannot be used f
   19ce8:	726f 4520 7478 7265 616e 206c 6e49 6574     or External Inte
   19cf8:	7272 7075 7374 202e 654e 6465 7420 206f     rrupts. Need to 
   19d08:	7375 2065 5047 4f49 6f20 206e 6f50 7472     use GPIO on Port
   19d18:	3020 6f20 2072 2e32 5b1b 6d30 5b1b 6d30      0 or 2..[0m.[0m
   19d28:	000a 0000 5b1b 3334 206d 4157 4e52 4e49     .....[43m WARNIN
   19d38:	1b47 305b 393b 6d34 253a 3a73 5b1b 3b30     G.[0;94m:%s:.[0;
   19d48:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   19d58:	1b20 305b 333b 6d37 6445 6567 2520 2064      .[0;37mEdge %d 
   19d68:	6163 6e6e 746f 6220 2065 7375 6465 6620     cannot be used f
   19d78:	726f 4520 7478 7265 616e 206c 6e49 6574     or External Inte
   19d88:	7272 7075 7374 4e2e 6565 2064 6f74 7520     rrupts.Need to u
   19d98:	6573 6120 7220 7369 6e69 2c67 6620 6c61     se a rising, fal
   19da8:	696c 676e 202c 726f 6220 746f 2068 6f63     ling, or both co
   19db8:	666e 6769 7275 7461 6f69 2e6e 5b1b 6d30     nfiguration..[0m
   19dc8:	000a 0000 5b1b 3134 436d 4952 4954 4143     .....[41mCRITICA
   19dd8:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   19de8:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   19df8:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   19e08:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   19e18:	6974 6e6f 5420 7365 6574 3a64 2820 6570     tion Tested: (pe
   19e28:	6972 6870 7265 6c61 645f 7669 6469 7265     ripheral_divider
   19e38:	3c20 203d 2934 200a 2020 2020 2020 2020      <= 4).         
   19e48:	4420 7669 6469 7265 6d20 7375 6e74 7427      Divider mustn't
   19e58:	6520 6378 6565 2064 3233 5b1b 6d30 5b1b      exceed 32.[0m.[
   19e68:	6d30 000a 500a 6972 746e 6e69 2067 7453     0m...Printing St
   19e78:	6361 206b 7254 6361 3a65 000a 5b1b 3134     ack Trace:...[41
   19e88:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   19e98:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   19ea8:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   19eb8:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   19ec8:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   19ed8:	6574 3a64 2820 6564 6973 6572 5f64 7073     ted: (desired_sp
   19ee8:	6565 5f64 6e69 6d5f 7a68 3c20 3320 3438     eed_in_mhz < 384
   19ef8:	2620 2026 6564 6973 6572 5f64 7073 6565      && desired_spee
   19f08:	5f64 6e69 6d5f 7a68 3e20 3120 2932 200a     d_in_mhz > 12). 
   19f18:	2020 2020 2020 2020 4620 6572 7571 6e65              Frequen
   19f28:	7963 6d20 7375 2074 6562 6c20 776f 7265     cy must be lower
   19f38:	7420 6168 206e 3833 2034 484d 617a 646e      than 384 MHzand
   19f48:	6720 6572 7461 7265 7420 6168 206e 726f      greater than or
   19f58:	6520 7571 6c61 7420 206f 3231 4d20 7a48      equal to 12 MHz
   19f68:	5b1b 6d30 5b1b 6d30 000a 0000 5b1b 3134     .[0m.[0m.....[41
   19f78:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   19f88:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   19f98:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   19fa8:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   19fb8:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   19fc8:	6574 3a64 2820 6964 6976 6564 5f72 6176     ted: (divider_va
   19fd8:	756c 2065 203c 2938 200a 2020 2020 2020     lue < 8).       
   19fe8:	2020 5020 4c4c 6420 7669 6469 7265 7620        PLL divider v
   19ff8:	6c61 6575 7720 6e65 2074 756f 2074 666f     alue went out of
   1a008:	6220 756f 646e 1b73 305b 1b6d 305b 0a6d      bounds.[0m.[0m.
   1a018:	0000 0000 5b1b 3134 436d 4952 4954 4143     .....[41mCRITICA
   1a028:	1b4c 305b 393b 6d34 253a 3a73 5b1b 3b30     L.[0;94m:%s:.[0;
   1a038:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a048:	1b20 305b 333b 6d37 7341 6573 7472 6f69      .[0;37mAssertio
   1a058:	206e 6146 6c69 7275 2c65 4320 6e6f 6964     n Failure, Condi
   1a068:	6974 6e6f 5420 7365 6574 3a64 2820 6166     tion Tested: (fa
   1a078:	736c 2965 200a 2020 2020 2020 2020 5020     lse).          P
   1a088:	4c4c 6c20 636f 206b 6f63 6c75 2064 6f6e     LL lock could no
   1a098:	2074 6562 6520 7473 6261 696c 6873 6465     t be established
   1a0a8:	6220 6665 726f 2065 6974 656d 756f 1b74      before timeout.
   1a0b8:	305b 1b6d 305b 0a6d 0000 0000 5b1b 3134     [0m.[0m......[41
   1a0c8:	436d 4952 4954 4143 1b4c 305b 393b 6d34     mCRITICAL.[0;94m
   1a0d8:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a0e8:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a0f8:	7341 6573 7472 6f69 206e 6146 6c69 7275     Assertion Failur
   1a108:	2c65 4320 6e6f 6964 6974 6e6f 5420 7365     e, Condition Tes
   1a118:	6574 3a64 2820 7063 5f75 6964 6976 6564     ted: (cpu_divide
   1a128:	2072 203c 3233 0a29 2020 2020 2020 2020     r < 32).        
   1a138:	2020 6944 6976 6564 2072 756d 7473 276e       Divider mustn'
   1a148:	2074 7865 6563 6465 3320 1b32 305b 1b6d     t exceed 32.[0m.
   1a158:	305b 0a6d 0000 0000 5b1b 3534 206d 2020     [0m......[45m   
   1a168:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a178:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a188:	256d 3e64 1b20 305b 333b 6d37 6146 6c69     m%d> .[0;37mFail
   1a198:	6465 7420 206f 6e69 7469 6169 6574 5320     ed to initiate S
   1a1a8:	4950 6d20 646f 2065 6977 6874 6e69 7420     PI mode within t
   1a1b8:	6d69 6f65 7475 202e 6241 726f 6974 676e     imeout. Aborting
   1a1c8:	1b21 305b 0a6d 0000 5b1b 3534 206d 2020     !.[0m....[45m   
   1a1d8:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a1e8:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a1f8:	256d 3e64 1b20 305b 333b 6d37 6552 7073     m%d> .[0;37mResp
   1a208:	6e6f 6573 6920 746e 6765 6972 7974 6320     onse integrity c
   1a218:	6568 6b63 6620 6961 656c 2e64 4120 6f62     heck failed. Abo
   1a228:	7472 6e69 2167 5b1b 6d30 000a 5b1b 3534     rting!.[0m...[45
   1a238:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a248:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a258:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a268:	6e55 7573 7070 726f 6574 2064 6f76 746c     Unsupported volt
   1a278:	6761 2065 6e69 7520 6573 202e 6241 726f     age in use. Abor
   1a288:	6974 676e 1b21 305b 0a6d 0000 5b1b 3534     ting!.[0m....[45
   1a298:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a2a8:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a2b8:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a2c8:	4453 4320 7261 2064 6974 656d 2064 756f     SD Card timed ou
   1a2d8:	2e74 4120 6f62 7472 6e69 2167 5b1b 6d30     t. Aborting!.[0m
   1a2e8:	000a 0000 7274 6575 0000 0000 6166 736c     ....true....fals
   1a2f8:	0065 0000 5b1b 3534 206d 2020 5245 4f52     e....[45m   ERRO
   1a308:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1a318:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a328:	1b20 305b 333b 6d37 6857 6c69 2065 6552      .[0;37mWhile Re
   1a338:	6461 6e69 2067 6c42 636f 206b 2523 2064     ading Block #%d 
   1a348:	5243 3143 3a36 5b1b 6d30 000a 5b1b 3534     CRC16:.[0m...[45
   1a358:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a368:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a378:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a388:	7845 6570 7463 6465 2720 7830 3025 5834     Expected '0x%04X
   1a398:	1b27 305b 0a6d 0000 5b1b 3534 206d 2020     '.[0m....[45m   
   1a3a8:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a3b8:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a3c8:	256d 3e64 1b20 305b 333b 6d37 6f47 2074     m%d> .[0;37mGot 
   1a3d8:	3027 2578 3430 2758 5b1b 6d30 000a 0000     '0x%04X'.[0m....
   1a3e8:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a3f8:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a408:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a418:	333b 6d37 6552 6461 4320 646d 7720 7361     ;37mRead Cmd was
   1a428:	6e20 746f 6120 6b63 6f6e 6c77 6465 6567      not acknowledge
   1a438:	2064 7270 706f 7265 796c 1b21 305b 0a6d     d properly!.[0m.
   1a448:	0000 0000 5b1b 3534 206d 2020 5245 4f52     .....[45m   ERRO
   1a458:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1a468:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a478:	1b20 305b 333b 6d37 6150 6172 656d 6574      .[0;37mParamete
   1a488:	2072 7245 3a72 2520 1b73 305b 0a6d 0000     r Err: %s.[0m...
   1a498:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a4a8:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a4b8:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a4c8:	333b 6d37 6441 7264 4520 7272 203a 7325     ;37mAddr Err: %s
   1a4d8:	5b1b 6d30 000a 0000 5b1b 3534 206d 2020     .[0m.....[45m   
   1a4e8:	5245 4f52 1b52 305b 393b 6d34 253a 3a73     ERROR.[0;94m:%s:
   1a4f8:	5b1b 3b30 3239 256d 3a73 5b1b 3b30 3339     .[0;92m%s:.[0;93
   1a508:	256d 3e64 1b20 305b 333b 6d37 7245 7361     m%d> .[0;37mEras
   1a518:	2065 6553 2071 7245 3a72 2520 1b73 305b     e Seq Err: %s.[0
   1a528:	0a6d 0000 5b1b 3534 206d 2020 5245 4f52     m....[45m   ERRO
   1a538:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1a548:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a558:	1b20 305b 333b 6d37 6f43 206d 5243 2043      .[0;37mCom CRC 
   1a568:	7245 3a72 2520 1b73 305b 0a6d 0000 0000     Err: %s.[0m.....
   1a578:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a588:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a598:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a5a8:	333b 6d37 6c49 656c 6167 206c 6d43 2064     ;37mIllegal Cmd 
   1a5b8:	7245 3a72 2520 1b73 305b 0a6d 0000 0000     Err: %s.[0m.....
   1a5c8:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a5d8:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a5e8:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a5f8:	333b 6d37 7245 7361 2065 6552 6573 3a74     ;37mErase Reset:
   1a608:	2520 1b73 305b 0a6d 0000 0000 5b1b 3534      %s.[0m......[45
   1a618:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a628:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a638:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a648:	6e49 4920 6c64 3a65 2520 1b73 305b 0a6d     In Idle: %s.[0m.
   1a658:	0000 0000 5b1b 3534 206d 2020 5245 4f52     .....[45m   ERRO
   1a668:	1b52 305b 393b 6d34 253a 3a73 5b1b 3b30     R.[0;94m:%s:.[0;
   1a678:	3239 256d 3a73 5b1b 3b30 3339 256d 3e64     92m%s:.[0;93m%d>
   1a688:	1b20 305b 333b 6d37 6146 6c69 6465 7420      .[0;37mFailed t
   1a698:	206f 6573 2074 7453 7261 2074 6441 7264     o set Start Addr
   1a6a8:	7365 2173 5b1b 6d30 000a 0000 5b1b 3534     ess!.[0m.....[45
   1a6b8:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a6c8:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a6d8:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a6e8:	6146 6c69 6465 7420 206f 6573 2074 6e45     Failed to set En
   1a6f8:	2064 6441 7264 7365 2173 5b1b 6d30 000a     d Address!.[0m..
   1a708:	5b1b 3534 206d 2020 5245 4f52 1b52 305b     .[45m   ERROR.[0
   1a718:	393b 6d34 253a 3a73 5b1b 3b30 3239 256d     ;94m:%s:.[0;92m%
   1a728:	3a73 5b1b 3b30 3339 256d 3e64 1b20 305b     s:.[0;93m%d> .[0
   1a738:	333b 6d37 6e55 6e6b 776f 206e 6572 7073     ;37mUnknown resp
   1a748:	6e6f 6573 7420 7079 2e65 4120 6f62 7472     onse type. Abort
   1a758:	6e69 2167 5b1b 6d30 000a 0000 5b1b 3534     ing!.[0m.....[45
   1a768:	206d 2020 5245 4f52 1b52 305b 393b 6d34     m   ERROR.[0;94m
   1a778:	253a 3a73 5b1b 3b30 3239 256d 3a73 5b1b     :%s:.[0;92m%s:.[
   1a788:	3b30 3339 256d 3e64 1b20 305b 333b 6d37     0;93m%d> .[0;37m
   1a798:	6552 7073 6e6f 6573 7520 736e 7075 6f70     Response unsuppo
   1a7a8:	7472 6465 6920 206e 5053 2049 6f6d 6564     rted in SPI mode
   1a7b8:	202e 6241 726f 6974 676e 1b21 305b 0a6d     . Aborting!.[0m.
   1a7c8:	ff00 ffff                                   ....

0001a7cc <Gpio::ValidPortCheck()::file>:
   1a7cc:	7067 6f69 682e 7070 ff00 ffff               gpio.hpp....

0001a7d8 <Gpio::SetInterruptEdge(GpioInterface::Edge)::file>:
   1a7d8:	7067 6f69 682e 7070 ff00 ffff               gpio.hpp....

0001a7e4 <Gpio::ClearInterruptEdge(GpioInterface::Edge)::file>:
   1a7e4:	7067 6f69 682e 7070 ff00 ffff               gpio.hpp....

0001a7f0 <Ssp::kPinSelect>:
   1a7f0:	0202 ff04                                   ....

0001a7f4 <Ssp::kSspPinMatrix>:
   1a7f4:	969c 0001 1200 0000 969c 0001 1100 0000     ................
   1a804:	969c 0001 0f00 0000 969c 0001 0900 0000     ................
   1a814:	969c 0001 0800 0000 969c 0001 0700 0000     ................
   1a824:	969c 0001 0101 0000 969c 0001 0401 0000     ................
   1a834:	969c 0001 0001 0000                         ........

0001a83c <Ssp::kPowerBit>:
   1a83c:	0015 0000 000a 0000 0014 0000               ............

0001a848 <Sd::kCrcTable8>:
   1a848:	0900 1b12 2d24 3f36 4148 535a 656c 777e     ....$-6?HAZSle~w
   1a858:	1019 020b 343d 262f 5851 4a43 7c75 6e67     ....=4/&QXCJu|gn
   1a868:	3b32 2920 1f16 0d04 737a 6168 575e 454c     2; )....zsha^WLE
   1a878:	222b 3039 060f 141d 6a63 7871 4e47 5c55     +"90....cjqxGNU\
   1a888:	6d64 7f76 4940 5b52 252c 373e 0108 131a     dmv.@IR[,%>7....
   1a898:	747d 666f 5059 424b 3c35 2e27 1811 0a03     }tofYPKB5<'.....
   1a8a8:	5f56 4d44 7b72 6960 171e 050c 333a 2128     V_DMr{`i....:3(!
   1a8b8:	464f 545d 626b 7079 0e07 1c15 2a23 3831     OF]Tkbyp....#*18
   1a8c8:	4841 5a53 6c65 7e77 0009 121b 242d 363f     AHSZelw~....-$?6
   1a8d8:	5158 434a 757c 676e 1910 0b02 3d34 2f26     XQJC|ung....4=&/
   1a8e8:	7a73 6861 5e57 4c45 323b 2029 161f 040d     szahW^EL;2) ....
   1a8f8:	636a 7178 474e 555c 2b22 3930 0f06 1d14     jcxqNG\U"+09....
   1a908:	2c25 3e37 0801 1a13 646d 767f 4049 525b     %,7>....md.vI@[R
   1a918:	353c 272e 1118 030a 7d74 6f66 5950 4b42     <5.'....t}foPYBK
   1a928:	1e17 0c05 3a33 2821 565f 444d 727b 6069     ....3:!(_VMD{ri`
   1a938:	070e 151c 232a 3138 4f46 5d54 6b62 0070     ....*#81FOT]bkp.

0001a948 <Sd::kCrcTable16>:
   1a948:	0000 1021 2042 3063 4084 50a5 60c6 70e7     ..!.B c0.@.P.`.p
   1a958:	8108 9129 a14a b16b c18c d1ad e1ce f1ef     ..).J.k.........
   1a968:	1231 0210 3273 2252 52b5 4294 72f7 62d6     1...s2R".R.B.r.b
   1a978:	9339 8318 b37b a35a d3bd c39c f3ff e3de     9...{.Z.........
   1a988:	2462 3443 0420 1401 64e6 74c7 44a4 5485     b$C4 ....d.t.D.T
   1a998:	a56a b54b 8528 9509 e5ee f5cf c5ac d58d     j.K.(...........
   1a9a8:	3653 2672 1611 0630 76d7 66f6 5695 46b4     S6r&..0..v.f.V.F
   1a9b8:	b75b a77a 9719 8738 f7df e7fe d79d c7bc     [.z...8.........
   1a9c8:	48c4 58e5 6886 78a7 0840 1861 2802 3823     .H.X.h.x@.a..(#8
   1a9d8:	c9cc d9ed e98e f9af 8948 9969 a90a b92b     ........H.i...+.
   1a9e8:	5af5 4ad4 7ab7 6a96 1a71 0a50 3a33 2a12     .Z.J.z.jq.P.3:.*
   1a9f8:	dbfd cbdc fbbf eb9e 9b79 8b58 bb3b ab1a     ........y.X.;...
   1aa08:	6ca6 7c87 4ce4 5cc5 2c22 3c03 0c60 1c41     .l.|.L.\",.<`.A.
   1aa18:	edae fd8f cdec ddcd ad2a bd0b 8d68 9d49     ........*...h.I.
   1aa28:	7e97 6eb6 5ed5 4ef4 3e13 2e32 1e51 0e70     .~.n.^.N.>2.Q.p.
   1aa38:	ff9f efbe dfdd cffc bf1b af3a 9f59 8f78     ..........:.Y.x.
   1aa48:	9188 81a9 b1ca a1eb d10c c12d f14e e16f     ..........-.N.o.
   1aa58:	1080 00a1 30c2 20e3 5004 4025 7046 6067     .....0. .P%@Fpg`
   1aa68:	83b9 9398 a3fb b3da c33d d31c e37f f35e     ........=.....^.
   1aa78:	02b1 1290 22f3 32d2 4235 5214 6277 7256     .....".25B.RwbVr
   1aa88:	b5ea a5cb 95a8 8589 f56e e54f d52c c50d     ........n.O.,...
   1aa98:	34e2 24c3 14a0 0481 7466 6447 5424 4405     .4.$....ftGd$T.D
   1aaa8:	a7db b7fa 8799 97b8 e75f f77e c71d d73c     ........_.~...<.
   1aab8:	26d3 36f2 0691 16b0 6657 7676 4615 5634     .&.6....Wfvv.F4V
   1aac8:	d94c c96d f90e e92f 99c8 89e9 b98a a9ab     L.m.../.........
   1aad8:	5844 4865 7806 6827 18c0 08e1 3882 28a3     DXeH.x'h.....8.(
   1aae8:	cb7d db5c eb3f fb1e 8bf9 9bd8 abbb bb9a     }.\.?...........
   1aaf8:	4a75 5a54 6a37 7a16 0af1 1ad0 2ab3 3a92     uJTZ7j.z.....*.:
   1ab08:	fd2e ed0f dd6c cd4d bdaa ad8b 9de8 8dc9     ....l.M.........
   1ab18:	7c26 6c07 5c64 4c45 3ca2 2c83 1ce0 0cc1     &|.ld\EL.<.,....
   1ab28:	ef1f ff3e cf5d df7c af9b bfba 8fd9 9ff8     ..>.].|.........
   1ab38:	6e17 7e36 4e55 5e74 2e93 3eb2 0ed1 1ef0     .n6~UNt^...>....

0001ab48 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1ab48:	6473 682e 7070 ff00                         sd.hpp..

0001ab50 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1ab50:	6473 682e 7070 ff00                         sd.hpp..

0001ab58 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1ab58:	6473 682e 7070 ff00                         sd.hpp..

0001ab60 <Sd::Mount(SdInterface::CardInfo_t*)::file>:
   1ab60:	6473 682e 7070 ff00                         sd.hpp..

0001ab68 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1ab68:	6473 682e 7070 ff00                         sd.hpp..

0001ab70 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1ab70:	6473 682e 7070 ff00                         sd.hpp..

0001ab78 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1ab78:	6473 682e 7070 ff00                         sd.hpp..

0001ab80 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1ab80:	6473 682e 7070 ff00                         sd.hpp..

0001ab88 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1ab88:	6473 682e 7070 ff00                         sd.hpp..

0001ab90 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1ab90:	6473 682e 7070 ff00                         sd.hpp..

0001ab98 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1ab98:	6473 682e 7070 ff00                         sd.hpp..

0001aba0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1aba0:	6473 682e 7070 ff00                         sd.hpp..

0001aba8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1aba8:	6473 682e 7070 ff00                         sd.hpp..

0001abb0 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1abb0:	6473 682e 7070 ff00                         sd.hpp..

0001abb8 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::file>:
   1abb8:	6473 682e 7070 ff00                         sd.hpp..

0001abc0 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1abc0:	6473 682e 7070 ff00                         sd.hpp..

0001abc8 <Sd::DeleteBlock(unsigned long, unsigned long)::file>:
   1abc8:	6473 682e 7070 ff00                         sd.hpp..

0001abd0 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1abd0:	6473 682e 7070 ff00                         sd.hpp..

0001abd8 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::file>:
   1abd8:	6473 682e 7070 ff00                         sd.hpp..

0001abe0 <vtable for Sd>:
	...
   1abe8:	7e8d 0001 72e5 0001 7395 0001 77a9 0001     .~...r...s...w..
   1abf8:	7bc1 0001 7d6d 0001 832d 0001 8375 0001     .{..m}..-...u...
   1ac08:	83e5 0001                                   ....

0001ac0c <vtable for SdInterface>:
	...
   1ac14:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ac24:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ac34:	86d1 0001                                   ....

0001ac38 <vtable for Ssp>:
	...
   1ac40:	6965 0001 0a41 0001 0ab9 0001 6a49 0001     ei..A.......Ij..
   1ac50:	6b35 0001 6d41 0001 6ea1 0001 708d 0001     5k..Am...n...p..
   1ac60:	fffc ffff 0000 0000 0f25 0001 0fb5 0001     ........%.......
   1ac70:	100d 0001 1025 0001 1039 0001 1079 0001     ....%...9...y...
   1ac80:	10a9 0001                                   ....

0001ac84 <vtable for SspInterface>:
	...
   1ac8c:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ac9c:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................

0001acac <vtable for SystemControllerInterface>:
	...
   1acb4:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1acc4:	86d1 0001 86d1 0001 86d1 0001               ............

0001acd0 <vtable for Gpio>:
	...
   1acd8:	5fe5 0001 6061 0001 60dd 0001 0909 0001     ._..a`...`......
   1ace8:	096d 0001 09d1 0001 6121 0001 618d 0001     m.......!a...a..
   1acf8:	6205 0001 6275 0001 650d 0001 6555 0001     .b..ub...e..Ue..
   1ad08:	631d 0001 6379 0001 63fd 0001 6485 0001     .c..yc...c...d..

0001ad18 <vtable for GpioInterface>:
	...
   1ad20:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ad30:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ad40:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ad50:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................

0001ad60 <vtable for PinInterface>:
	...
   1ad68:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ad78:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ad88:	86d1 0001 86d1 0001 86d1 0001 86d1 0001     ................
   1ad98:	86d1 0001                                   ....

0001ad9c <Gpio::ClearInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1ad9c:	6976 7472 6175 206c 6f76 6469 4720 6970     virtual void Gpi
   1adac:	3a6f 433a 656c 7261 6e49 6574 7272 7075     o::ClearInterrup
   1adbc:	4574 6764 2865 7047 6f69 6e49 6574 6672     tEdge(GpioInterf
   1adcc:	6361 3a65 453a 6764 2965 ff00               ace::Edge)..

0001add8 <Gpio::ValidPortCheck()::__PRETTY_FUNCTION__>:
   1add8:	6f62 6c6f 4720 6970 3a6f 563a 6c61 6469     bool Gpio::Valid
   1ade8:	6f50 7472 6843 6365 286b 0029               PortCheck().

0001adf4 <Gpio::SetInterruptEdge(GpioInterface::Edge)::__PRETTY_FUNCTION__>:
   1adf4:	6976 7472 6175 206c 6f76 6469 4720 6970     virtual void Gpi
   1ae04:	3a6f 533a 7465 6e49 6574 7272 7075 4574     o::SetInterruptE
   1ae14:	6764 2865 7047 6f69 6e49 6574 6672 6361     dge(GpioInterfac
   1ae24:	3a65 453a 6764 2965 ff00 ffff               e::Edge)....

0001ae30 <Sd::Mount(SdInterface::CardInfo_t*)::__PRETTY_FUNCTION__>:
   1ae30:	6976 7472 6175 206c 6f62 6c6f 5320 3a64     virtual bool Sd:
   1ae40:	4d3a 756f 746e 5328 4964 746e 7265 6166     :Mount(SdInterfa
   1ae50:	6563 3a3a 6143 6472 6e49 6f66 745f 292a     ce::CardInfo_t*)
   1ae60:	ff00 ffff                                   ....

0001ae64 <Sd::ReadBlock(unsigned long, unsigned char*, unsigned long)::__PRETTY_FUNCTION__>:
   1ae64:	6976 7472 6175 206c 6975 746e 5f38 2074     virtual uint8_t 
   1ae74:	6453 3a3a 6552 6461 6c42 636f 286b 6975     Sd::ReadBlock(ui
   1ae84:	746e 3233 745f 202c 6975 746e 5f38 2a74     nt32_t, uint8_t*
   1ae94:	202c 6975 746e 3233 745f 0029               , uint32_t).

0001aea0 <Sd::DeleteBlock(unsigned long, unsigned long)::__PRETTY_FUNCTION__>:
   1aea0:	6976 7472 6175 206c 6975 746e 5f38 2074     virtual uint8_t 
   1aeb0:	6453 3a3a 6544 656c 6574 6c42 636f 286b     Sd::DeleteBlock(
   1aec0:	6975 746e 3233 745f 202c 6975 746e 3233     uint32_t, uint32
   1aed0:	745f 0029                                   _t).

0001aed4 <Sd::SendCmd(SdInterface::Command, unsigned long, unsigned char*, unsigned long, SdInterface::KeepAlive)::__PRETTY_FUNCTION__>:
   1aed4:	6976 7472 6175 206c 6975 746e 3233 745f     virtual uint32_t
   1aee4:	5320 3a64 533a 6e65 4364 646d 5328 4964      Sd::SendCmd(SdI
   1aef4:	746e 7265 6166 6563 3a3a 6f43 6d6d 6e61     nterface::Comman
   1af04:	2c64 7520 6e69 3374 5f32 2c74 7520 6e69     d, uint32_t, uin
   1af14:	3874 745f 2c2a 7520 6e69 3374 5f32 2c74     t8_t*, uint32_t,
   1af24:	5320 4964 746e 7265 6166 6563 3a3a 654b      SdInterface::Ke
   1af34:	7065 6c41 7669 2965 ff00 ffff               epAlive)....

0001af40 <__sf_fake_stderr>:
	...

0001af60 <__sf_fake_stdin>:
	...

0001af80 <__sf_fake_stdout>:
	...
